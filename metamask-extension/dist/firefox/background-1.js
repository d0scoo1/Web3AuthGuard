LavaPack.loadBundle([
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\metamask-controller.js", {"../../shared/constants/app":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\app.ts","../../shared/constants/hardware-wallets":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\hardware-wallets.ts","../../shared/constants/keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\keyring.ts","../../shared/constants/metametrics":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\metametrics.ts","../../shared/constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","../../shared/constants/permissions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\permissions.ts","../../shared/constants/swaps":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\swaps.ts","../../shared/constants/test-flags":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\test-flags.js","../../shared/constants/time":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\time.ts","../../shared/constants/tokens":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\tokens.js","../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","../../shared/lib/metamask-controller-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\metamask-controller-utils.js","../../shared/lib/token-util.ts":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\token-util.ts","../../shared/modules/conversion.utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\conversion.utils.ts","../../shared/modules/mv3.utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\mv3.utils.js","../../shared/modules/string-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\string-utils.ts","../../shared/modules/transaction.utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\transaction.utils.js","../../shared/notifications":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\notifications\\index.js","./account-import-strategies":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\account-import-strategies\\index.js","./controllers/alert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\alert.js","./controllers/app-state":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\app-state.js","./controllers/backup":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\backup.js","./controllers/cached-balances":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\cached-balances.js","./controllers/decrypt-message":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\decrypt-message.ts","./controllers/detect-tokens":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\detect-tokens.js","./controllers/encryption-public-key":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\encryption-public-key.ts","./controllers/ens":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\ens\\index.js","./controllers/incoming-transactions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\incoming-transactions.js","./controllers/metametrics":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\metametrics.js","./controllers/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\network\\index.ts","./controllers/onboarding":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\onboarding.js","./controllers/permissions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\permissions\\index.js","./controllers/preferences":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\preferences.js","./controllers/swaps":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\swaps.js","./controllers/transactions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\transactions\\index.js","./controllers/web3/web3-auth":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\web3\\web3-auth.js","./detect-multiple-instances":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\detect-multiple-instances.js","./lib/ComposableObservableStore":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\ComposableObservableStore.js","./lib/account-tracker":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\account-tracker.js","./lib/createDupeReqFilterMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createDupeReqFilterMiddleware.js","./lib/createLoggerMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createLoggerMiddleware.js","./lib/createMetaRPCHandler":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createMetaRPCHandler.js","./lib/createMetamaskMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createMetamaskMiddleware.js","./lib/createOnboardingMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createOnboardingMiddleware.js","./lib/createOriginMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createOriginMiddleware.js","./lib/createRPCMethodTrackingMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createRPCMethodTrackingMiddleware.js","./lib/createTabIdMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\createTabIdMiddleware.js","./lib/rpc-method-middleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\rpc-method-middleware\\index.js","./lib/security-provider-helpers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\security-provider-helpers.ts","./lib/seed-phrase-verifier":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\seed-phrase-verifier.js","./lib/segment":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\segment\\index.js","./lib/stream-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\stream-utils.js","./lib/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\util.ts","@keystonehq/metamask-airgapped-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js","@metamask/address-book-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\address-book-controller\\dist\\index.js","@metamask/announcement-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\announcement-controller\\dist\\index.js","@metamask/approval-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\index.js","@metamask/assets-controllers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\assets-controllers\\dist\\index.js","@metamask/base-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js","@metamask/controller-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","@metamask/eth-json-rpc-middleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js","@metamask/eth-keyring-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\index.js","@metamask/eth-ledger-bridge-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js","@metamask/eth-trezor-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\index.js","@metamask/gas-fee-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\index.js","@metamask/obs-store":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\index.js","@metamask/obs-store/dist/asStream":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","@metamask/permission-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\permission-controller\\dist\\index.js","@metamask/phishing-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\phishing-controller\\dist\\index.js","@metamask/signature-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\signature-controller\\dist\\index.js","@metamask/smart-transactions-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\index.js","@metamask/subject-metadata-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\subject-metadata-controller\\dist\\index.js","@sentry/browser":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@sentry\\browser\\dist\\index.js","await-semaphore":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\await-semaphore\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-json-rpc-filters":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\index.js","eth-json-rpc-filters/subscriptionManager":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\subscriptionManager.js","eth-lattice-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-lattice-keyring\\index.js","eth-query":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-query\\index.js","eth-rpc-errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","events":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","json-rpc-middleware-stream":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-middleware-stream\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js","loglevel":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js","nanoid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\nanoid\\index.browser.js","pump":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\pump\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmetamask-controller.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.METAMASK_CONTROLLER_EVENTS = void 0;
var _events = _interopRequireDefault(require("events"));
var _pump = _interopRequireDefault(require("pump"));
var _obsStore = require("@metamask/obs-store");
var _asStream = require("@metamask/obs-store/dist/asStream");
var _jsonRpcEngine = require("json-rpc-engine");
var _jsonRpcMiddlewareStream = require("json-rpc-middleware-stream");
var _ethJsonRpcMiddleware = require("@metamask/eth-json-rpc-middleware");
var _lodash = require("lodash");
var _ethKeyringController = require("@metamask/eth-keyring-controller");
var _ethJsonRpcFilters = _interopRequireDefault(require("eth-json-rpc-filters"));
var _subscriptionManager = _interopRequireDefault(require("eth-json-rpc-filters/subscriptionManager"));
var _ethRpcErrors = require("eth-rpc-errors");
var _awaitSemaphore = require("await-semaphore");
var _loglevel = _interopRequireDefault(require("loglevel"));
var _ethTrezorKeyring = _interopRequireDefault(require("@metamask/eth-trezor-keyring"));
var _ethLedgerBridgeKeyring = _interopRequireDefault(require("@metamask/eth-ledger-bridge-keyring"));
var _ethLatticeKeyring = _interopRequireDefault(require("eth-lattice-keyring"));
var _metamaskAirgappedKeyring = require("@keystonehq/metamask-airgapped-keyring");
var _ethQuery = _interopRequireDefault(require("eth-query"));
var _nanoid = _interopRequireDefault(require("nanoid"));
var _browser = require("@sentry/browser");
var _addressBookController = require("@metamask/address-book-controller");
var _approvalController = require("@metamask/approval-controller");
var _baseController = require("@metamask/base-controller");
var _assetsControllers = require("@metamask/assets-controllers");
var _phishingController = require("@metamask/phishing-controller");
var _announcementController = require("@metamask/announcement-controller");
var _gasFeeController = require("@metamask/gas-fee-controller");
var _permissionController = require("@metamask/permission-controller");
var _subjectMetadataController = require("@metamask/subject-metadata-controller");
var _smartTransactionsController = _interopRequireDefault(require("@metamask/smart-transactions-controller"));
var _signatureController = require("@metamask/signature-controller");
var _controllerUtils = require("@metamask/controller-utils");
var _transaction = require("../../shared/constants/transaction");
var _swaps = require("../../shared/constants/swaps");
var _network = require("../../shared/constants/network");
var _hardwareWallets = require("../../shared/constants/hardware-wallets");
var _keyring = require("../../shared/constants/keyring");
var _permissions = require("../../shared/constants/permissions");
var _notifications = require("../../shared/notifications");
var _time = require("../../shared/constants/time");
var _app = require("../../shared/constants/app");
var _metametrics = require("../../shared/constants/metametrics");
var _tokenUtil = require("../../shared/lib/token-util.ts");
var _stringUtils = require("../../shared/modules/string-utils");
var _transaction2 = require("../../shared/modules/transaction.utils");
var _tokens = require("../../shared/constants/tokens");
var _metamaskControllerUtils = require("../../shared/lib/metamask-controller-utils");
var _mv = require("../../shared/modules/mv3.utils");
var _conversion = require("../../shared/modules/conversion.utils");
var _testFlags = require("../../shared/constants/test-flags");
var _detectMultipleInstances = require("./detect-multiple-instances");
var _ComposableObservableStore = _interopRequireDefault(require("./lib/ComposableObservableStore"));
var _accountTracker = _interopRequireDefault(require("./lib/account-tracker"));
var _createDupeReqFilterMiddleware = _interopRequireDefault(require("./lib/createDupeReqFilterMiddleware"));
var _createLoggerMiddleware = _interopRequireDefault(require("./lib/createLoggerMiddleware"));
var _rpcMethodMiddleware = require("./lib/rpc-method-middleware");
var _createOriginMiddleware = _interopRequireDefault(require("./lib/createOriginMiddleware"));
var _createTabIdMiddleware = _interopRequireDefault(require("./lib/createTabIdMiddleware"));
var _createOnboardingMiddleware = _interopRequireDefault(require("./lib/createOnboardingMiddleware"));
var _streamUtils = require("./lib/stream-utils");
var _ens = _interopRequireDefault(require("./controllers/ens"));
var _network2 = require("./controllers/network");
var _preferences = _interopRequireDefault(require("./controllers/preferences"));
var _appState = _interopRequireDefault(require("./controllers/app-state"));
var _cachedBalances = _interopRequireDefault(require("./controllers/cached-balances"));
var _alert = _interopRequireDefault(require("./controllers/alert"));
var _onboarding = _interopRequireDefault(require("./controllers/onboarding"));
var _backup = _interopRequireDefault(require("./controllers/backup"));
var _incomingTransactions = _interopRequireDefault(require("./controllers/incoming-transactions"));
var _decryptMessage = _interopRequireDefault(require("./controllers/decrypt-message"));
var _transactions = _interopRequireDefault(require("./controllers/transactions"));
var _detectTokens = _interopRequireDefault(require("./controllers/detect-tokens"));
var _swaps2 = _interopRequireDefault(require("./controllers/swaps"));
var _accountImportStrategies = _interopRequireDefault(require("./account-import-strategies"));
var _seedPhraseVerifier = _interopRequireDefault(require("./lib/seed-phrase-verifier"));
var _metametrics2 = _interopRequireDefault(require("./controllers/metametrics"));
var _segment = require("./lib/segment");
var _createMetaRPCHandler = _interopRequireDefault(require("./lib/createMetaRPCHandler"));
var _util = require("./lib/util");
var _createMetamaskMiddleware = _interopRequireDefault(require("./lib/createMetamaskMiddleware"));
var _encryptionPublicKey = _interopRequireDefault(require("./controllers/encryption-public-key"));
var _web3Auth = _interopRequireDefault(require("./controllers/web3/web3-auth"));
var _permissions2 = require("./controllers/permissions");
var _createRPCMethodTrackingMiddleware = _interopRequireDefault(require("./lib/createRPCMethodTrackingMiddleware"));
var _securityProviderHelpers = require("./lib/security-provider-helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const METAMASK_CONTROLLER_EVENTS = {
  // Fired after state changes that impact the extension badge (unapproved msg count)
  // The process of updating the badge happens in app/scripts/background.js.
  UPDATE_BADGE: 'updateBadge',
  // TODO: Add this and similar enums to the `controllers` repo and export them
  APPROVAL_STATE_CHANGE: 'ApprovalController:stateChange'
};

// stream channels
exports.METAMASK_CONTROLLER_EVENTS = METAMASK_CONTROLLER_EVENTS;
const PHISHING_SAFELIST = 'metamask-phishing-safelist';
class MetamaskController extends _events.default {
  /**
   * @param {object} opts
   */
  constructor(opts) {
    var _initState$AccountTra;
    super();
    _defineProperty(this, "removePermissionsFor", subjects => {
      try {
        this.permissionController.revokePermissions(subjects);
      } catch (exp) {
        if (!(exp instanceof _permissionController.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "rejectPermissionsRequest", requestId => {
      try {
        this.permissionController.rejectPermissionsRequest(requestId);
      } catch (exp) {
        if (!(exp instanceof _permissionController.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "acceptPermissionsRequest", request => {
      try {
        this.permissionController.acceptPermissionsRequest(request);
      } catch (exp) {
        if (!(exp instanceof _permissionController.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "resolvePendingApproval", (id, value) => {
      try {
        this.approvalController.accept(id, value);
      } catch (exp) {
        if (!(exp instanceof _approvalController.ApprovalRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "rejectPendingApproval", (id, error) => {
      try {
        this.approvalController.reject(id, new _ethRpcErrors.EthereumRpcError(error.code, error.message, error.data));
      } catch (exp) {
        if (!(exp instanceof _approvalController.ApprovalRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    const {
      isFirstMetaMaskControllerSetup
    } = opts;
    this.defaultMaxListeners = 20;
    this.sendUpdate = (0, _lodash.debounce)(this.privateSendUpdate.bind(this), _time.MILLISECOND * 200);
    this.opts = opts;
    this.extension = opts.browser;
    this.platform = opts.platform;
    this.notificationManager = opts.notificationManager;
    const initState = opts.initState || {};
    const version = this.platform.getVersion();
    this.recordFirstTimeInfo(initState);

    // this keeps track of how many "controllerStream" connections are open
    // the only thing that uses controller connections are open metamask UI instances
    this.activeControllerConnections = 0;
    this.getRequestAccountTabIds = opts.getRequestAccountTabIds;
    this.getOpenMetamaskTabsIds = opts.getOpenMetamaskTabsIds;
    this.controllerMessenger = new _baseController.ControllerMessenger();

    // instance of a class that wraps the extension's storage local API.
    this.localStoreApiWrapper = opts.localStore;

    // observable state store
    this.store = new _ComposableObservableStore.default({
      state: initState,
      controllerMessenger: this.controllerMessenger,
      persist: true
    });

    // external connections by origin
    // Do not modify directly. Use the associated methods.
    this.connections = {};

    // lock to ensure only one vault created at once
    this.createVaultMutex = new _awaitSemaphore.Mutex();
    this.extension.runtime.onInstalled.addListener(details => {
      if (details.reason === 'update' && version === '8.1.0') {
        this.platform.openExtensionInBrowser();
      }
    });

    // next, we will initialize the controllers
    // controller initialization order matters

    this.approvalController = new _approvalController.ApprovalController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'ApprovalController'
      }),
      showApprovalRequest: opts.showUserConfirmation,
      typesExcludedFromRateLimiting: [_controllerUtils.ApprovalType.EthSign, _controllerUtils.ApprovalType.PersonalSign, _controllerUtils.ApprovalType.EthSignTypedData, _controllerUtils.ApprovalType.Transaction, _controllerUtils.ApprovalType.WatchAsset, _controllerUtils.ApprovalType.EthGetEncryptionPublicKey, _controllerUtils.ApprovalType.EthDecrypt]
    });
    const networkControllerMessenger = this.controllerMessenger.getRestricted({
      name: 'NetworkController',
      allowedEvents: Object.values(_network2.NetworkControllerEventType)
    });
    this.networkController = new _network2.NetworkController({
      messenger: networkControllerMessenger,
      state: initState.NetworkController,
      infuraProjectId: opts.infuraProjectId,
      trackMetaMetricsEvent: (...args) => this.metaMetricsController.trackEvent(...args)
    });
    this.networkController.initializeProvider();
    this.provider = this.networkController.getProviderAndBlockTracker().provider;
    this.blockTracker = this.networkController.getProviderAndBlockTracker().blockTracker;
    const tokenListMessenger = this.controllerMessenger.getRestricted({
      name: 'TokenListController'
    });
    this.tokenListController = new _assetsControllers.TokenListController({
      chainId: (0, _conversion.hexToDecimal)(this.networkController.store.getState().providerConfig.chainId),
      preventPollingOnNetworkRestart: initState.TokenListController ? initState.TokenListController.preventPollingOnNetworkRestart : true,
      onNetworkStateChange: cb => {
        this.networkController.store.subscribe(networkState => {
          const modifiedNetworkState = {
            ...networkState,
            providerConfig: {
              ...networkState.providerConfig,
              chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
            }
          };
          return cb(modifiedNetworkState);
        });
      },
      messenger: tokenListMessenger,
      state: initState.TokenListController
    });
    this.preferencesController = new _preferences.default({
      initState: initState.PreferencesController,
      initLangCode: opts.initLangCode,
      onInfuraIsBlocked: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.InfuraIsBlocked),
      onInfuraIsUnblocked: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.InfuraIsUnblocked),
      tokenListController: this.tokenListController,
      provider: this.provider
    });
    this.tokensController = new _assetsControllers.TokensController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig
          }
        };
        return cb(modifiedNetworkState);
      }),
      config: {
        provider: this.provider
      },
      state: initState.TokensController,
      messenger: this.controllerMessenger.getRestricted({
        name: 'TokensController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      })
    });
    this.assetsContractController = new _assetsControllers.AssetsContractController({
      onPreferencesStateChange: listener => this.preferencesController.store.subscribe(listener),
      // This handler is misnamed, and is a known issue that will be resolved
      // by planned refactors. It should be onNetworkDidChange which happens
      // AFTER the provider in the network controller is updated to reflect
      // the new state of the network controller. In #18041 we changed this
      // handler to be triggered by the change in the network state because
      // that is what the handler name implies, but this triggers too soon
      // causing the provider of the AssetsContractController to trail the
      // network provider by one update.
      onNetworkStateChange: cb => networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkDidChange, () => {
        const networkState = this.networkController.store.getState();
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      })
    }, {
      provider: this.provider
    }, initState.AssetsContractController);
    this.nftController = new _assetsControllers.NftController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      }),
      getERC721AssetName: this.assetsContractController.getERC721AssetName.bind(this.assetsContractController),
      getERC721AssetSymbol: this.assetsContractController.getERC721AssetSymbol.bind(this.assetsContractController),
      getERC721TokenURI: this.assetsContractController.getERC721TokenURI.bind(this.assetsContractController),
      getERC721OwnerOf: this.assetsContractController.getERC721OwnerOf.bind(this.assetsContractController),
      getERC1155BalanceOf: this.assetsContractController.getERC1155BalanceOf.bind(this.assetsContractController),
      getERC1155TokenURI: this.assetsContractController.getERC1155TokenURI.bind(this.assetsContractController),
      onNftAdded: ({
        address,
        symbol,
        tokenId,
        standard,
        source
      }) => this.metaMetricsController.trackEvent({
        event: _metametrics.MetaMetricsEventName.NftAdded,
        category: _metametrics.MetaMetricsEventCategory.Wallet,
        properties: {
          token_contract_address: address,
          token_symbol: symbol,
          asset_type: _transaction.AssetType.NFT,
          token_standard: standard,
          source
        },
        sensitiveProperties: {
          tokenId
        }
      })
    }, {}, initState.NftController);
    this.nftController.setApiKey(null);
    this.nftDetectionController = new _assetsControllers.NftDetectionController({
      onNftsStateChange: listener => this.nftController.subscribe(listener),
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      }),
      getOpenSeaApiKey: () => this.nftController.openSeaApiKey,
      getBalancesInSingleCall: this.assetsContractController.getBalancesInSingleCall.bind(this.assetsContractController),
      addNft: this.nftController.addNft.bind(this.nftController),
      getNftState: () => this.nftController.state
    });
    this.metaMetricsController = new _metametrics2.default({
      segment: _segment.segment,
      preferencesStore: this.preferencesController.store,
      onNetworkDidChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange),
      getNetworkIdentifier: () => {
        const {
          type,
          rpcUrl
        } = this.networkController.store.getState().providerConfig;
        return type === _network.NETWORK_TYPES.RPC ? rpcUrl : type;
      },
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      version: this.platform.getVersion(),
      environment: "development",
      extension: this.extension,
      initState: initState.MetaMetricsController,
      captureException: _browser.captureException
    });
    this.on('update', update => {
      this.metaMetricsController.handleMetaMaskStateUpdate(update);
    });
    const gasFeeMessenger = this.controllerMessenger.getRestricted({
      name: 'GasFeeController'
    });
    const gasApiBaseUrl = false ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
    this.gasFeeController = new _gasFeeController.GasFeeController({
      state: initState.GasFeeController,
      interval: 10000,
      messenger: gasFeeMessenger,
      clientId: _swaps.SWAPS_CLIENT_ID,
      getProvider: () => this.networkController.getProviderAndBlockTracker().provider,
      // NOTE: This option is inaccurately named; it should be called
      // onNetworkDidChange
      onNetworkStateChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      legacyAPIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/gasPrices`,
      EIP1559APIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/suggestedGasFees`,
      getCurrentNetworkLegacyGasAPICompatibility: () => {
        const {
          chainId
        } = this.networkController.store.getState().providerConfig;
        return false || chainId === _network.CHAIN_IDS.MAINNET;
      },
      getChainId: () => {
        return false ? _network.CHAIN_IDS.MAINNET : this.networkController.store.getState().providerConfig.chainId;
      }
    });
    this.qrHardwareKeyring = new _metamaskAirgappedKeyring.MetaMaskKeyring();
    this.appStateController = new _appState.default({
      addUnlockListener: this.on.bind(this, 'unlock'),
      isUnlocked: this.isUnlocked.bind(this),
      initState: initState.AppStateController,
      onInactiveTimeout: () => this.setLocked(),
      preferencesStore: this.preferencesController.store,
      qrHardwareStore: this.qrHardwareKeyring.getMemStore(),
      messenger: this.controllerMessenger.getRestricted({
        name: 'AppStateController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`]
      })
    });
    const currencyRateMessenger = this.controllerMessenger.getRestricted({
      name: 'CurrencyRateController'
    });
    this.currencyRateController = new _assetsControllers.CurrencyRateController({
      includeUsdRate: true,
      messenger: currencyRateMessenger,
      state: {
        ...initState.CurrencyController,
        nativeCurrency: this.networkController.store.getState().providerConfig.ticker
      }
    });
    this.phishingController = new _phishingController.PhishingController({}, initState.PhishingController);
    this.phishingController.maybeUpdateState();
    if (false) {
      this.phishingController.setHotlistRefreshInterval(5 * _time.SECOND);
      this.phishingController.setStalelistRefreshInterval(30 * _time.SECOND);
    }
    const announcementMessenger = this.controllerMessenger.getRestricted({
      name: 'AnnouncementController'
    });
    this.announcementController = new _announcementController.AnnouncementController({
      messenger: announcementMessenger,
      allAnnouncements: _notifications.UI_NOTIFICATIONS,
      state: initState.AnnouncementController
    });

    // token exchange rate tracker
    this.tokenRatesController = new _assetsControllers.TokenRatesController({
      onTokensStateChange: listener => this.tokensController.subscribe(listener),
      onCurrencyRateStateChange: listener => this.controllerMessenger.subscribe(`${this.currencyRateController.name}:stateChange`, listener),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      })
    }, {
      disabled: !this.preferencesController.store.getState().useCurrencyRateCheck
    }, initState.TokenRatesController);
    this.preferencesController.store.subscribe((0, _util.previousValueComparator)((prevState, currState) => {
      const {
        useCurrencyRateCheck: prevUseCurrencyRateCheck
      } = prevState;
      const {
        useCurrencyRateCheck: currUseCurrencyRateCheck
      } = currState;
      if (currUseCurrencyRateCheck && !prevUseCurrencyRateCheck) {
        this.currencyRateController.start();
        this.tokenRatesController.configure({
          disabled: false
        }, false, false);
      } else if (!currUseCurrencyRateCheck && prevUseCurrencyRateCheck) {
        this.currencyRateController.stop();
        this.tokenRatesController.configure({
          disabled: true
        }, false, false);
      }
    }, this.preferencesController.store.getState()));
    this.ensController = new _ens.default({
      provider: this.provider,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      onNetworkDidChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange)
    });
    this.onboardingController = new _onboarding.default({
      initState: initState.OnboardingController
    });
    this.incomingTransactionsController = new _incomingTransactions.default({
      blockTracker: this.blockTracker,
      onNetworkDidChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange),
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      preferencesController: this.preferencesController,
      onboardingController: this.onboardingController,
      initState: initState.IncomingTransactionsController
    });

    // account tracker watches balances, nonces, and any code at their address
    this.accountTracker = new _accountTracker.default({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      getNetworkIdentifier: () => {
        const {
          type,
          rpcUrl
        } = this.networkController.store.getState().providerConfig;
        return type === _network.NETWORK_TYPES.RPC ? rpcUrl : type;
      },
      preferencesController: this.preferencesController,
      onboardingController: this.onboardingController,
      initState: _mv.isManifestV3 && isFirstMetaMaskControllerSetup === false && (_initState$AccountTra = initState.AccountTracker) !== null && _initState$AccountTra !== void 0 && _initState$AccountTra.accounts ? {
        accounts: initState.AccountTracker.accounts
      } : {
        accounts: {}
      }
    });

    // start and stop polling for balances based on activeControllerConnections
    this.on('controllerConnectionChanged', activeControllerConnections => {
      const {
        completedOnboarding
      } = this.onboardingController.store.getState();
      if (activeControllerConnections > 0 && completedOnboarding) {
        this.triggerNetworkrequests();
      } else {
        this.stopNetworkRequests();
      }
    });
    this.onboardingController.store.subscribe((0, _util.previousValueComparator)(async (prevState, currState) => {
      const {
        completedOnboarding: prevCompletedOnboarding
      } = prevState;
      const {
        completedOnboarding: currCompletedOnboarding
      } = currState;
      if (!prevCompletedOnboarding && currCompletedOnboarding) {
        this.triggerNetworkrequests();
      }
    }, this.onboardingController.store.getState()));
    this.cachedBalancesController = new _cachedBalances.default({
      accountTracker: this.accountTracker,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      initState: initState.CachedBalancesController
    });
    let additionalKeyrings = [(0, _ethKeyringController.keyringBuilderFactory)(_metamaskAirgappedKeyring.MetaMaskKeyring)];
    if (this.canUseHardwareWallets()) {
      var _this$opts$overrides;
      const keyringOverrides = (_this$opts$overrides = this.opts.overrides) === null || _this$opts$overrides === void 0 ? void 0 : _this$opts$overrides.keyrings;
      const additionalKeyringTypes = [(keyringOverrides === null || keyringOverrides === void 0 ? void 0 : keyringOverrides.trezor) || _ethTrezorKeyring.default, (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : keyringOverrides.ledger) || _ethLedgerBridgeKeyring.default, (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : keyringOverrides.lattice) || _ethLatticeKeyring.default, _metamaskAirgappedKeyring.MetaMaskKeyring];
      additionalKeyrings = additionalKeyringTypes.map(keyringType => (0, _ethKeyringController.keyringBuilderFactory)(keyringType));
    }
    this.keyringController = new _ethKeyringController.KeyringController({
      keyringBuilders: additionalKeyrings,
      initState: initState.KeyringController,
      encryptor: opts.encryptor || undefined,
      cacheEncryptionKey: _mv.isManifestV3
    });
    this.keyringController.memStore.subscribe(state => this._onKeyringControllerUpdate(state));
    this.keyringController.on('unlock', () => this._onUnlock());
    this.keyringController.on('lock', () => this._onLock());
    const getIdentities = () => this.preferencesController.store.getState().identities;
    this.permissionController = new _permissionController.PermissionController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'PermissionController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:hasRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`, `SnapController:getPermitted`, `SnapController:install`, `SubjectMetadataController:getSubjectMetadata`]
      }),
      state: initState.PermissionController,
      caveatSpecifications: (0, _permissions2.getCaveatSpecifications)({
        getIdentities
      }),
      permissionSpecifications: {
        ...(0, _permissions2.getPermissionSpecifications)({
          getIdentities,
          getAllAccounts: this.keyringController.getAccounts.bind(this.keyringController),
          captureKeyringTypesWithMissingIdentities: (identities = {}, accounts = []) => {
            const accountsMissingIdentities = accounts.filter(address => !identities[address]);
            const keyringTypesWithMissingIdentities = accountsMissingIdentities.map(address => {
              var _this$keyringControll;
              return (_this$keyringControll = this.keyringController.getKeyringForAccount(address)) === null || _this$keyringControll === void 0 ? void 0 : _this$keyringControll.type;
            });
            const identitiesCount = Object.keys(identities || {}).length;
            const accountTrackerCount = Object.keys(this.accountTracker.store.getState().accounts || {}).length;
            (0, _browser.captureException)(new Error(`Attempt to get permission specifications failed because their were ${accounts.length} accounts, but ${identitiesCount} identities, and the ${keyringTypesWithMissingIdentities} keyrings included accounts with missing identities. Meanwhile, there are ${accountTrackerCount} accounts in the account tracker.`));
          }
        })
      },
      unrestrictedMethods: _permissions2.unrestrictedMethods
    });
    this.permissionLogController = new _permissions2.PermissionLogController({
      restrictedMethods: new Set(Object.keys(_permissions.RestrictedMethods)),
      initState: initState.PermissionLogController
    });
    this.subjectMetadataController = new _subjectMetadataController.SubjectMetadataController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'SubjectMetadataController',
        allowedActions: [`${this.permissionController.name}:hasPermissions`]
      }),
      state: initState.SubjectMetadataController,
      subjectCacheLimit: 100
    });
    this.detectTokensController = new _detectTokens.default({
      preferences: this.preferencesController,
      tokensController: this.tokensController,
      assetsContractController: this.assetsContractController,
      network: this.networkController,
      keyringMemStore: this.keyringController.memStore,
      tokenList: this.tokenListController,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.addressBookController = new _addressBookController.AddressBookController(undefined, initState.AddressBookController);
    this.alertController = new _alert.default({
      initState: initState.AlertController,
      preferencesStore: this.preferencesController.store
    });
    this.web3AuthController = new _web3Auth.default({
      initState: initState.Web3AuthController
    });
    this.backupController = new _backup.default({
      preferencesController: this.preferencesController,
      addressBookController: this.addressBookController,
      networkController: this.networkController,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.txController = new _transactions.default({
      initState: initState.TransactionController || initState.TransactionManager,
      getPermittedAccounts: this.getPermittedAccounts.bind(this),
      getProviderConfig: () => this.networkController.store.getState().providerConfig,
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      getNetworkId: () => this.networkController.store.getState().networkId,
      getNetworkStatus: () => this.networkController.store.getState().networkStatus,
      onNetworkStateChange: listener => {
        let previousNetworkId = this.networkController.store.getState().networkId;
        this.networkController.store.subscribe(state => {
          if (previousNetworkId !== state.networkId) {
            listener();
            previousNetworkId = state.networkId;
          }
        });
      },
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      preferencesStore: this.preferencesController.store,
      txHistoryLimit: 60,
      signTransaction: this.keyringController.signTransaction.bind(this.keyringController),
      provider: this.provider,
      blockTracker: this.blockTracker,
      createEventFragment: this.metaMetricsController.createEventFragment.bind(this.metaMetricsController),
      updateEventFragment: this.metaMetricsController.updateEventFragment.bind(this.metaMetricsController),
      finalizeEventFragment: this.metaMetricsController.finalizeEventFragment.bind(this.metaMetricsController),
      getEventFragmentById: this.metaMetricsController.getEventFragmentById.bind(this.metaMetricsController),
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getParticipateInMetrics: () => this.metaMetricsController.state.participateInMetaMetrics,
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController),
      getExternalPendingTransactions: this.getExternalPendingTransactions.bind(this),
      getAccountType: this.getAccountType.bind(this),
      getDeviceModel: this.getDeviceModel.bind(this),
      getTokenStandardAndDetails: this.getTokenStandardAndDetails.bind(this),
      securityProviderRequest: this.securityProviderRequest.bind(this),
      messenger: this.controllerMessenger.getRestricted({
        name: 'TransactionController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      })
    });
    this.txController.on(`tx:status-update`, async (txId, status) => {
      if (status === _transaction.TransactionStatus.confirmed || status === _transaction.TransactionStatus.failed) {
        const txMeta = this.txController.txStateManager.getTransaction(txId);
        let rpcPrefs = {};
        if (txMeta.chainId) {
          const {
            networkConfigurations
          } = this.networkController.store.getState();
          const matchingNetworkConfig = Object.values(networkConfigurations).find(networkConfiguration => networkConfiguration.chainId === txMeta.chainId);
          rpcPrefs = (matchingNetworkConfig === null || matchingNetworkConfig === void 0 ? void 0 : matchingNetworkConfig.rpcPrefs) ?? {};
        }
        try {
          await this.platform.showTransactionNotification(txMeta, rpcPrefs);
        } catch (error) {
          _loglevel.default.error('Failed to create transaction notification', error);
        }
        const {
          txReceipt
        } = txMeta;

        // if this is a transferFrom method generated from within the app it may be an NFT transfer transaction
        // in which case we will want to check and update ownership status of the transferred NFT.
        if (txMeta.type === _transaction.TransactionType.tokenMethodTransferFrom && txMeta.txParams !== undefined) {
          var _allNfts$userAddress, _allNfts$userAddress$;
          const {
            data,
            to: contractAddress,
            from: userAddress
          } = txMeta.txParams;
          const {
            chainId
          } = txMeta;
          const transactionData = (0, _transaction2.parseStandardTokenTransactionData)(data);
          // Sometimes the tokenId value is parsed as "_value" param. Not seeing this often any more, but still occasionally:
          // i.e. call approve() on BAYC contract - https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#writeContract, and tokenId shows up as _value,
          // not sure why since it doesn't match the ERC721 ABI spec we use to parse these transactions - https://github.com/MetaMask/metamask-eth-abis/blob/d0474308a288f9252597b7c93a3a8deaad19e1b2/src/abis/abiERC721.ts#L62.
          const transactionDataTokenId = (0, _tokenUtil.getTokenIdParam)(transactionData) ?? (0, _metamaskControllerUtils.getTokenValueParam)(transactionData);
          const {
            allNfts
          } = this.nftController.state;
          const chainIdAsDecimal = (0, _conversion.hexToDecimal)(chainId);
          // check if its a known NFT
          const knownNft = allNfts === null || allNfts === void 0 ? void 0 : (_allNfts$userAddress = allNfts[userAddress]) === null || _allNfts$userAddress === void 0 ? void 0 : (_allNfts$userAddress$ = _allNfts$userAddress[chainIdAsDecimal]) === null || _allNfts$userAddress$ === void 0 ? void 0 : _allNfts$userAddress$.find(({
            address,
            tokenId
          }) => (0, _stringUtils.isEqualCaseInsensitive)(address, contractAddress) && tokenId === transactionDataTokenId);

          // if it is we check and update ownership status.
          if (knownNft) {
            this.nftController.checkAndUpdateSingleNftOwnershipStatus(knownNft, false, {
              userAddress,
              chainId: chainIdAsDecimal
            });
          }
        }
        const metamaskState = this.getState();
        if (txReceipt && txReceipt.status === '0x0') {
          var _txMeta$simulationFai;
          this.metaMetricsController.trackEvent({
            event: 'Tx Status Update: On-Chain Failure',
            category: _metametrics.MetaMetricsEventCategory.Background,
            properties: {
              action: 'Transactions',
              errorMessage: (_txMeta$simulationFai = txMeta.simulationFails) === null || _txMeta$simulationFai === void 0 ? void 0 : _txMeta$simulationFai.reason,
              numberOfTokens: metamaskState.tokens.length,
              numberOfAccounts: Object.keys(metamaskState.accounts).length
            }
          }, {
            matomoEvent: true
          });
        }
      }
    });
    networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkDidChange, async () => {
      const {
        ticker
      } = this.networkController.store.getState().providerConfig;
      try {
        await this.currencyRateController.setNativeCurrency(ticker);
      } catch (error) {
        // TODO: Handle failure to get conversion rate more gracefully
        console.error(error);
      }
    });
    this.networkController.lookupNetwork();
    this.decryptMessageController = new _decryptMessage.default({
      getState: this.getState.bind(this),
      keyringController: this.keyringController,
      messenger: this.controllerMessenger.getRestricted({
        name: 'DecryptMessageController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.encryptionPublicKeyController = new _encryptionPublicKey.default({
      messenger: this.controllerMessenger.getRestricted({
        name: 'EncryptionPublicKeyController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      keyringController: this.keyringController,
      getState: this.getState.bind(this),
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.signatureController = new _signatureController.SignatureController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'SignatureController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      keyringController: this.keyringController,
      isEthSignEnabled: () => {
        var _this$preferencesCont, _this$preferencesCont2;
        return (_this$preferencesCont = this.preferencesController.store.getState()) === null || _this$preferencesCont === void 0 ? void 0 : (_this$preferencesCont2 = _this$preferencesCont.disabledRpcMethodPreferences) === null || _this$preferencesCont2 === void 0 ? void 0 : _this$preferencesCont2.eth_sign;
      },
      getAllState: this.getState.bind(this),
      securityProviderRequest: this.securityProviderRequest.bind(this),
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId
    });
    this.signatureController.hub.on('cancelWithReason', (message, reason) => {
      this.metaMetricsController.trackEvent({
        event: reason,
        category: _metametrics.MetaMetricsEventCategory.Transactions,
        properties: {
          action: 'Sign Request',
          type: message.type
        }
      });
    });
    this.swapsController = new _swaps2.default({
      getBufferedGasLimit: this.txController.txGasUtil.getBufferedGasLimit.bind(this.txController.txGasUtil),
      networkController: this.networkController,
      onNetworkStateChange: listener => this.networkController.store.subscribe(listener),
      provider: this.provider,
      getProviderConfig: () => this.networkController.store.getState().providerConfig,
      getTokenRatesState: () => this.tokenRatesController.state,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController)
    });
    this.smartTransactionsController = new _smartTransactionsController.default({
      onNetworkStateChange: cb => {
        this.networkController.store.subscribe(networkState => {
          const modifiedNetworkState = {
            ...networkState,
            providerConfig: {
              ...networkState.providerConfig
            }
          };
          return cb(modifiedNetworkState);
        });
      },
      getNetwork: () => this.networkController.store.getState().networkId ?? 'loading',
      getNonceLock: this.txController.nonceTracker.getNonceLock.bind(this.txController.nonceTracker),
      confirmExternalTransaction: this.txController.confirmExternalTransaction.bind(this.txController),
      provider: this.provider,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    }, {
      supportedChainIds: [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI]
    }, initState.SmartTransactionsController);

    // ensure accountTracker updates balances after network change
    networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkDidChange, () => {
      this.accountTracker._updateAccounts();
    });

    // clear unapproved transactions and messages when the network will change
    networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkWillChange, () => {
      this.txController.txStateManager.clearUnapprovedTxs();
      this.encryptionPublicKeyController.clearUnapproved();
      this.decryptMessageController.clearUnapproved();
      this.signatureController.clearUnapproved();
    });
    if (_mv.isManifestV3 && globalThis.isFirstTimeProfileLoaded === undefined) {
      const {
        serviceWorkerLastActiveTime
      } = this.appStateController.store.getState();
      const metametricsPayload = {
        category: _metametrics.MetaMetricsEventCategory.ServiceWorkers,
        event: _metametrics.MetaMetricsEventName.ServiceWorkerRestarted,
        properties: {
          service_worker_restarted_time: Date.now() - serviceWorkerLastActiveTime
        }
      };
      try {
        this.metaMetricsController.trackEvent(metametricsPayload);
      } catch (e) {
        _loglevel.default.warn('Failed to track service worker restart metric:', e);
      }
    }
    this.metamaskMiddleware = (0, _createMetamaskMiddleware.default)({
      static: {
        eth_syncing: false,
        web3_clientVersion: `MetaMask/v${version}`
      },
      version,
      // account mgmt
      getAccounts: async ({
        origin: innerOrigin
      }, {
        suppressUnauthorizedError = true
      } = {}) => {
        if (innerOrigin === _app.ORIGIN_METAMASK) {
          const selectedAddress = this.preferencesController.getSelectedAddress();
          return selectedAddress ? [selectedAddress] : [];
        } else if (this.isUnlocked()) {
          return await this.getPermittedAccounts(innerOrigin, {
            suppressUnauthorizedError
          });
        }
        return []; // changing this is a breaking change
      },

      // tx signing
      processTransaction: this.newUnapprovedTransaction.bind(this),
      // msg signing
      processEthSignMessage: this.signatureController.newUnsignedMessage.bind(this.signatureController),
      processTypedMessage: this.signatureController.newUnsignedTypedMessage.bind(this.signatureController),
      processTypedMessageV3: this.signatureController.newUnsignedTypedMessage.bind(this.signatureController),
      processTypedMessageV4: this.signatureController.newUnsignedTypedMessage.bind(this.signatureController),
      processPersonalMessage: this.signatureController.newUnsignedPersonalMessage.bind(this.signatureController),
      processEncryptionPublicKey: this.encryptionPublicKeyController.newRequestEncryptionPublicKey.bind(this.encryptionPublicKeyController),
      processDecryptMessage: this.decryptMessageController.newRequestDecryptMessage.bind(this.decryptMessageController),
      getPendingNonce: this.getPendingNonce.bind(this),
      getPendingTransactionByHash: hash => this.txController.getTransactions({
        searchCriteria: {
          hash,
          status: _transaction.TransactionStatus.submitted
        }
      })[0]
    });

    // ensure isClientOpenAndUnlocked is updated when memState updates
    this.on('update', memState => this._onStateUpdate(memState));

    /**
     * All controllers in Memstore but not in store. They are not persisted.
     * On chrome profile re-start, they will be re-initialized.
     */
    const resetOnRestartStore = {
      AccountTracker: this.accountTracker.store,
      TxController: this.txController.memStore,
      TokenRatesController: this.tokenRatesController,
      DecryptMessageController: this.decryptMessageController,
      EncryptionPublicKeyController: this.encryptionPublicKeyController,
      SignatureController: this.signatureController,
      SwapsController: this.swapsController.store,
      EnsController: this.ensController.store,
      ApprovalController: this.approvalController
    };
    this.store.updateStructure({
      AppStateController: this.appStateController.store,
      TransactionController: this.txController.store,
      KeyringController: this.keyringController.store,
      PreferencesController: this.preferencesController.store,
      MetaMetricsController: this.metaMetricsController.store,
      AddressBookController: this.addressBookController,
      CurrencyController: this.currencyRateController,
      NetworkController: this.networkController.store,
      CachedBalancesController: this.cachedBalancesController.store,
      AlertController: this.alertController.store,
      Web3AuthController: this.web3AuthController.store,
      OnboardingController: this.onboardingController.store,
      IncomingTransactionsController: this.incomingTransactionsController.store,
      PermissionController: this.permissionController,
      PermissionLogController: this.permissionLogController.store,
      SubjectMetadataController: this.subjectMetadataController,
      BackupController: this.backupController,
      AnnouncementController: this.announcementController,
      GasFeeController: this.gasFeeController,
      TokenListController: this.tokenListController,
      TokensController: this.tokensController,
      SmartTransactionsController: this.smartTransactionsController,
      NftController: this.nftController,
      PhishingController: this.phishingController,
      ...resetOnRestartStore
    });
    this.memStore = new _ComposableObservableStore.default({
      config: {
        AppStateController: this.appStateController.store,
        NetworkController: this.networkController.store,
        CachedBalancesController: this.cachedBalancesController.store,
        KeyringController: this.keyringController.memStore,
        PreferencesController: this.preferencesController.store,
        MetaMetricsController: this.metaMetricsController.store,
        AddressBookController: this.addressBookController,
        CurrencyController: this.currencyRateController,
        AlertController: this.alertController.store,
        Web3AuthController: this.web3AuthController.store,
        OnboardingController: this.onboardingController.store,
        IncomingTransactionsController: this.incomingTransactionsController.store,
        PermissionController: this.permissionController,
        PermissionLogController: this.permissionLogController.store,
        SubjectMetadataController: this.subjectMetadataController,
        BackupController: this.backupController,
        AnnouncementController: this.announcementController,
        GasFeeController: this.gasFeeController,
        TokenListController: this.tokenListController,
        TokensController: this.tokensController,
        SmartTransactionsController: this.smartTransactionsController,
        NftController: this.nftController,
        ...resetOnRestartStore
      },
      controllerMessenger: this.controllerMessenger
    });

    // if this is the first time, clear the state of by calling these methods
    const resetMethods = [this.accountTracker.resetState, this.txController.resetState, this.decryptMessageController.resetState.bind(this.decryptMessageController), this.encryptionPublicKeyController.resetState.bind(this.encryptionPublicKeyController), this.signatureController.resetState.bind(this.signatureController), this.swapsController.resetState, this.ensController.resetState, this.approvalController.clear.bind(this.approvalController)
    // WE SHOULD ADD TokenListController.resetState here too. But it's not implemented yet.
    ];

    if (_mv.isManifestV3) {
      if (isFirstMetaMaskControllerSetup === true) {
        this.resetStates(resetMethods);
        this.extension.storage.session.set({
          isFirstMetaMaskControllerSetup: false
        });
      }
    } else {
      // it's always the first time in MV2
      this.resetStates(resetMethods);
    }

    // Automatic login via config password or loginToken
    if (!this.isUnlocked() && this.onboardingController.store.getState().completedOnboarding) {
      this._loginUser();
    } else {
      this._startUISync();
    }

    // Lazily update the store with the current extension environment
    this.extension.runtime.getPlatformInfo().then(({
      os
    }) => {
      this.appStateController.setBrowserEnvironment(os,
      // This method is presently only supported by Firefox
      this.extension.runtime.getBrowserInfo === undefined ? 'chrome' : 'firefox');
    });
    this.setupControllerEventSubscriptions();

    // For more information about these legacy streams, see here:
    // https://github.com/MetaMask/metamask-extension/issues/15491
    // TODO:LegacyProvider: Delete
    this.publicConfigStore = this.createPublicConfigStore();

    // Multiple MetaMask instances launched warning
    this.extension.runtime.onMessageExternal.addListener(_detectMultipleInstances.onMessageReceived);
    // Fire a ping message to check if other extensions are running
    (0, _detectMultipleInstances.checkForMultipleVersionsRunning)();
  }
  triggerNetworkrequests() {
    this.accountTracker.start();
    this.incomingTransactionsController.start();
    if (this.preferencesController.store.getState().useCurrencyRateCheck) {
      this.currencyRateController.start();
    }
    if (this.preferencesController.store.getState().useTokenDetection) {
      this.tokenListController.start();
    }
  }
  stopNetworkRequests() {
    this.accountTracker.stop();
    this.incomingTransactionsController.stop();
    if (this.preferencesController.store.getState().useCurrencyRateCheck) {
      this.currencyRateController.stop();
    }
    if (this.preferencesController.store.getState().useTokenDetection) {
      this.tokenListController.stop();
    }
  }
  canUseHardwareWallets() {
    return !_mv.isManifestV3 || false;
  }
  resetStates(resetMethods) {
    resetMethods.forEach(resetMethod => {
      try {
        resetMethod();
      } catch (err) {
        console.error(err);
      }
    });
  }

  /**
   * Sets up BaseController V2 event subscriptions. Currently, this includes
   * the subscriptions necessary to notify permission subjects of account
   * changes.
   *
   * Some of the subscriptions in this method are ControllerMessenger selector
   * event subscriptions. See the relevant documentation for
   * `@metamask/base-controller` for more information.
   *
   * Note that account-related notifications emitted when the extension
   * becomes unlocked are handled in MetaMaskController._onUnlock.
   */
  setupControllerEventSubscriptions() {
    const handleAccountsChange = async (origin, newAccounts) => {
      if (this.isUnlocked()) {
        this.notifyConnections(origin, {
          method: _permissions2.NOTIFICATION_NAMES.accountsChanged,
          // This should be the same as the return value of `eth_accounts`,
          // namely an array of the current / most recently selected Ethereum
          // account.
          params: newAccounts.length < 2 ?
          // If the length is 1 or 0, the accounts are sorted by definition.
          newAccounts :
          // If the length is 2 or greater, we have to execute
          // `eth_accounts` vi this method.
          await this.getPermittedAccounts(origin)
        });
      }
      this.permissionLogController.updateAccountsHistory(origin, newAccounts);
    };

    // This handles account changes whenever the selected address changes.
    let lastSelectedAddress;
    this.preferencesController.store.subscribe(async ({
      selectedAddress
    }) => {
      if (selectedAddress && selectedAddress !== lastSelectedAddress) {
        lastSelectedAddress = selectedAddress;
        const permittedAccountsMap = (0, _permissions2.getPermittedAccountsByOrigin)(this.permissionController.state);
        for (const [origin, accounts] of permittedAccountsMap.entries()) {
          if (accounts.includes(selectedAddress)) {
            handleAccountsChange(origin, accounts);
          }
        }
      }
    });

    // This handles account changes every time relevant permission state
    // changes, for any reason.
    this.controllerMessenger.subscribe(`${this.permissionController.name}:stateChange`, async (currentValue, previousValue) => {
      const changedAccounts = (0, _permissions2.getChangedAccounts)(currentValue, previousValue);
      for (const [origin, accounts] of changedAccounts.entries()) {
        handleAccountsChange(origin, accounts);
      }
    }, _permissions2.getPermittedAccountsByOrigin);
  }

  /**
   * TODO:LegacyProvider: Delete
   * Constructor helper: initialize a public config store.
   * This store is used to make some config info available to Dapps synchronously.
   */
  createPublicConfigStore() {
    // subset of state for metamask inpage provider
    const publicConfigStore = new _obsStore.ObservableStore();
    const {
      networkController
    } = this;

    // setup memStore subscription hooks
    this.on('update', updatePublicConfigStore);
    updatePublicConfigStore(this.getState());
    function updatePublicConfigStore(memState) {
      const {
        chainId
      } = networkController.store.getState().providerConfig;
      if (memState.networkStatus === _network.NetworkStatus.Available) {
        publicConfigStore.putState(selectPublicState(chainId, memState));
      }
    }
    function selectPublicState(chainId, {
      isUnlocked,
      networkId
    }) {
      return {
        isUnlocked,
        chainId,
        networkVersion: networkId ?? 'loading'
      };
    }
    return publicConfigStore;
  }

  /**
   * Gets relevant state for the provider of an external origin.
   *
   * @param {string} origin - The origin to get the provider state for.
   * @returns {Promise<{ isUnlocked: boolean, networkVersion: string, chainId: string, accounts: string[] }>} An object with relevant state properties.
   */
  async getProviderState(origin) {
    return {
      isUnlocked: this.isUnlocked(),
      ...this.getProviderNetworkState(),
      accounts: await this.getPermittedAccounts(origin)
    };
  }

  /**
   * Gets network state relevant for external providers.
   *
   * @param {object} [memState] - The MetaMask memState. If not provided,
   * this function will retrieve the most recent state.
   * @returns {object} An object with relevant network state properties.
   */
  getProviderNetworkState(memState) {
    const {
      networkId
    } = memState || this.getState();
    return {
      chainId: this.networkController.store.getState().providerConfig.chainId,
      networkVersion: networkId ?? 'loading'
    };
  }

  //=============================================================================
  // EXPOSED TO THE UI SUBSYSTEM
  //=============================================================================

  /**
   * The metamask-state of the various controllers, made available to the UI
   *
   * @returns {object} status
   */
  getState() {
    const {
      vault
    } = this.keyringController.store.getState();
    const isInitialized = Boolean(vault);
    return {
      isInitialized,
      ...this.memStore.getFlatState()
    };
  }

  /**
   * Returns an Object containing API Callback Functions.
   * These functions are the interface for the UI.
   * The API object can be transmitted over a stream via JSON-RPC.
   *
   * @returns {object} Object containing API functions.
   */
  getApi() {
    const {
      addressBookController,
      alertController,
      web3AuthController,
      appStateController,
      nftController,
      nftDetectionController,
      currencyRateController,
      detectTokensController,
      ensController,
      gasFeeController,
      metaMetricsController,
      networkController,
      announcementController,
      onboardingController,
      permissionController,
      preferencesController,
      qrHardwareKeyring,
      swapsController,
      tokensController,
      smartTransactionsController,
      txController,
      assetsContractController,
      backupController,
      approvalController
    } = this;
    return {
      // etc
      getState: this.getState.bind(this),
      setCurrentCurrency: currencyRateController.setCurrentCurrency.bind(currencyRateController),
      setUseBlockie: preferencesController.setUseBlockie.bind(preferencesController),
      setUseNonceField: preferencesController.setUseNonceField.bind(preferencesController),
      setUsePhishDetect: preferencesController.setUsePhishDetect.bind(preferencesController),
      setUseMultiAccountBalanceChecker: preferencesController.setUseMultiAccountBalanceChecker.bind(preferencesController),
      setUseTokenDetection: preferencesController.setUseTokenDetection.bind(preferencesController),
      setUseNftDetection: preferencesController.setUseNftDetection.bind(preferencesController),
      setUseCurrencyRateCheck: preferencesController.setUseCurrencyRateCheck.bind(preferencesController),
      setOpenSeaEnabled: preferencesController.setOpenSeaEnabled.bind(preferencesController),
      setIpfsGateway: preferencesController.setIpfsGateway.bind(preferencesController),
      setParticipateInMetaMetrics: metaMetricsController.setParticipateInMetaMetrics.bind(metaMetricsController),
      setCurrentLocale: preferencesController.setCurrentLocale.bind(preferencesController),
      markPasswordForgotten: this.markPasswordForgotten.bind(this),
      unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),
      getRequestAccountTabIds: this.getRequestAccountTabIds,
      getOpenMetamaskTabsIds: this.getOpenMetamaskTabsIds,
      markNotificationPopupAsAutomaticallyClosed: () => this.notificationManager.markAsAutomaticallyClosed(),
      // approval
      requestUserApproval: approvalController.addAndShowApprovalRequest.bind(approvalController),
      // primary HD keyring management
      addNewAccount: this.addNewAccount.bind(this),
      verifySeedPhrase: this.verifySeedPhrase.bind(this),
      resetAccount: this.resetAccount.bind(this),
      removeAccount: this.removeAccount.bind(this),
      importAccountWithStrategy: this.importAccountWithStrategy.bind(this),
      // hardware wallets
      connectHardware: this.connectHardware.bind(this),
      forgetDevice: this.forgetDevice.bind(this),
      checkHardwareStatus: this.checkHardwareStatus.bind(this),
      unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),
      setLedgerTransportPreference: this.setLedgerTransportPreference.bind(this),
      attemptLedgerTransportCreation: this.attemptLedgerTransportCreation.bind(this),
      establishLedgerTransportPreference: this.establishLedgerTransportPreference.bind(this),
      // qr hardware devices
      submitQRHardwareCryptoHDKey: qrHardwareKeyring.submitCryptoHDKey.bind(qrHardwareKeyring),
      submitQRHardwareCryptoAccount: qrHardwareKeyring.submitCryptoAccount.bind(qrHardwareKeyring),
      cancelSyncQRHardware: qrHardwareKeyring.cancelSync.bind(qrHardwareKeyring),
      submitQRHardwareSignature: qrHardwareKeyring.submitSignature.bind(qrHardwareKeyring),
      cancelQRHardwareSignRequest: qrHardwareKeyring.cancelSignRequest.bind(qrHardwareKeyring),
      // vault management
      submitPassword: this.submitPassword.bind(this),
      verifyPassword: this.verifyPassword.bind(this),
      // network management
      setProviderType: networkController.setProviderType.bind(networkController),
      rollbackToPreviousProvider: networkController.rollbackToPreviousProvider.bind(networkController),
      removeNetworkConfiguration: networkController.removeNetworkConfiguration.bind(networkController),
      setActiveNetwork: networkController.setActiveNetwork.bind(networkController),
      upsertNetworkConfiguration: this.networkController.upsertNetworkConfiguration.bind(this.networkController),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      // PreferencesController
      setSelectedAddress: preferencesController.setSelectedAddress.bind(preferencesController),
      addToken: tokensController.addToken.bind(tokensController),
      rejectWatchAsset: tokensController.rejectWatchAsset.bind(tokensController),
      acceptWatchAsset: tokensController.acceptWatchAsset.bind(tokensController),
      updateTokenType: tokensController.updateTokenType.bind(tokensController),
      setAccountLabel: preferencesController.setAccountLabel.bind(preferencesController),
      setFeatureFlag: preferencesController.setFeatureFlag.bind(preferencesController),
      setPreference: preferencesController.setPreference.bind(preferencesController),
      addKnownMethodData: preferencesController.addKnownMethodData.bind(preferencesController),
      setDismissSeedBackUpReminder: preferencesController.setDismissSeedBackUpReminder.bind(preferencesController),
      setDisabledRpcMethodPreference: preferencesController.setDisabledRpcMethodPreference.bind(preferencesController),
      getRpcMethodPreferences: preferencesController.getRpcMethodPreferences.bind(preferencesController),
      setAdvancedGasFee: preferencesController.setAdvancedGasFee.bind(preferencesController),
      setTheme: preferencesController.setTheme.bind(preferencesController),
      setTransactionSecurityCheckEnabled: preferencesController.setTransactionSecurityCheckEnabled.bind(preferencesController),
      // AssetsContractController
      getTokenStandardAndDetails: this.getTokenStandardAndDetails.bind(this),
      // NftController
      addNft: nftController.addNft.bind(nftController),
      addNftVerifyOwnership: nftController.addNftVerifyOwnership.bind(nftController),
      removeAndIgnoreNft: nftController.removeAndIgnoreNft.bind(nftController),
      removeNft: nftController.removeNft.bind(nftController),
      checkAndUpdateAllNftsOwnershipStatus: nftController.checkAndUpdateAllNftsOwnershipStatus.bind(nftController),
      checkAndUpdateSingleNftOwnershipStatus: nftController.checkAndUpdateSingleNftOwnershipStatus.bind(nftController),
      isNftOwner: nftController.isNftOwner.bind(nftController),
      // AddressController
      setAddressBook: addressBookController.set.bind(addressBookController),
      removeFromAddressBook: addressBookController.delete.bind(addressBookController),
      // AppStateController
      setLastActiveTime: appStateController.setLastActiveTime.bind(appStateController),
      setDefaultHomeActiveTabName: appStateController.setDefaultHomeActiveTabName.bind(appStateController),
      setConnectedStatusPopoverHasBeenShown: appStateController.setConnectedStatusPopoverHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderHasBeenShown: appStateController.setRecoveryPhraseReminderHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderLastShown: appStateController.setRecoveryPhraseReminderLastShown.bind(appStateController),
      setTermsOfUseLastAgreed: appStateController.setTermsOfUseLastAgreed.bind(appStateController),
      setOutdatedBrowserWarningLastShown: appStateController.setOutdatedBrowserWarningLastShown.bind(appStateController),
      setShowTestnetMessageInDropdown: appStateController.setShowTestnetMessageInDropdown.bind(appStateController),
      setShowBetaHeader: appStateController.setShowBetaHeader.bind(appStateController),
      setShowProductTour: appStateController.setShowProductTour.bind(appStateController),
      updateNftDropDownState: appStateController.updateNftDropDownState.bind(appStateController),
      setFirstTimeUsedNetwork: appStateController.setFirstTimeUsedNetwork.bind(appStateController),
      // EnsController
      tryReverseResolveAddress: ensController.reverseResolveAddress.bind(ensController),
      // KeyringController
      setLocked: this.setLocked.bind(this),
      createNewVaultAndKeychain: this.createNewVaultAndKeychain.bind(this),
      createNewVaultAndRestore: this.createNewVaultAndRestore.bind(this),
      exportAccount: this.exportAccount.bind(this),
      // txController
      cancelTransaction: txController.cancelTransaction.bind(txController),
      updateTransaction: txController.updateTransaction.bind(txController),
      updateAndApproveTransaction: txController.updateAndApproveTransaction.bind(txController),
      approveTransactionsWithSameNonce: txController.approveTransactionsWithSameNonce.bind(txController),
      createCancelTransaction: this.createCancelTransaction.bind(this),
      createSpeedUpTransaction: this.createSpeedUpTransaction.bind(this),
      estimateGas: this.estimateGas.bind(this),
      getNextNonce: this.getNextNonce.bind(this),
      addUnapprovedTransaction: txController.addUnapprovedTransaction.bind(txController),
      createTransactionEventFragment: txController.createTransactionEventFragment.bind(txController),
      getTransactions: txController.getTransactions.bind(txController),
      updateEditableParams: txController.updateEditableParams.bind(txController),
      updateTransactionGasFees: txController.updateTransactionGasFees.bind(txController),
      updateTransactionSendFlowHistory: txController.updateTransactionSendFlowHistory.bind(txController),
      updateSwapApprovalTransaction: txController.updateSwapApprovalTransaction.bind(txController),
      updateSwapTransaction: txController.updateSwapTransaction.bind(txController),
      updatePreviousGasParams: txController.updatePreviousGasParams.bind(txController),
      // signatureController
      signMessage: this.signatureController.signMessage.bind(this.signatureController),
      cancelMessage: this.signatureController.cancelMessage.bind(this.signatureController),
      signPersonalMessage: this.signatureController.signPersonalMessage.bind(this.signatureController),
      cancelPersonalMessage: this.signatureController.cancelPersonalMessage.bind(this.signatureController),
      signTypedMessage: this.signatureController.signTypedMessage.bind(this.signatureController),
      cancelTypedMessage: this.signatureController.cancelTypedMessage.bind(this.signatureController),
      // decryptMessageController
      decryptMessage: this.decryptMessageController.decryptMessage.bind(this.decryptMessageController),
      decryptMessageInline: this.decryptMessageController.decryptMessageInline.bind(this.decryptMessageController),
      cancelDecryptMessage: this.decryptMessageController.cancelDecryptMessage.bind(this.decryptMessageController),
      // EncryptionPublicKeyController
      encryptionPublicKey: this.encryptionPublicKeyController.encryptionPublicKey.bind(this.encryptionPublicKeyController),
      cancelEncryptionPublicKey: this.encryptionPublicKeyController.cancelEncryptionPublicKey.bind(this.encryptionPublicKeyController),
      // onboarding controller
      setSeedPhraseBackedUp: onboardingController.setSeedPhraseBackedUp.bind(onboardingController),
      completeOnboarding: onboardingController.completeOnboarding.bind(onboardingController),
      setFirstTimeFlowType: onboardingController.setFirstTimeFlowType.bind(onboardingController),
      // alert controller
      setAlertEnabledness: alertController.setAlertEnabledness.bind(alertController),
      setUnconnectedAccountAlertShown: alertController.setUnconnectedAccountAlertShown.bind(alertController),
      setWeb3ShimUsageAlertDismissed: alertController.setWeb3ShimUsageAlertDismissed.bind(alertController),
      // msg sig auth controller
      setMessageInfo: web3AuthController.setMessageInfo.bind(web3AuthController),
      setGlobalFingerprint: web3AuthController.setGlobalFingerprint.bind(web3AuthController),
      // permissions
      removePermissionsFor: this.removePermissionsFor,
      approvePermissionsRequest: this.acceptPermissionsRequest,
      rejectPermissionsRequest: this.rejectPermissionsRequest,
      ...(0, _permissions2.getPermissionBackgroundApiMethods)(permissionController),
      // swaps
      fetchAndSetQuotes: swapsController.fetchAndSetQuotes.bind(swapsController),
      setSelectedQuoteAggId: swapsController.setSelectedQuoteAggId.bind(swapsController),
      resetSwapsState: swapsController.resetSwapsState.bind(swapsController),
      setSwapsTokens: swapsController.setSwapsTokens.bind(swapsController),
      clearSwapsQuotes: swapsController.clearSwapsQuotes.bind(swapsController),
      setApproveTxId: swapsController.setApproveTxId.bind(swapsController),
      setTradeTxId: swapsController.setTradeTxId.bind(swapsController),
      setSwapsTxGasPrice: swapsController.setSwapsTxGasPrice.bind(swapsController),
      setSwapsTxGasLimit: swapsController.setSwapsTxGasLimit.bind(swapsController),
      setSwapsTxMaxFeePerGas: swapsController.setSwapsTxMaxFeePerGas.bind(swapsController),
      setSwapsTxMaxFeePriorityPerGas: swapsController.setSwapsTxMaxFeePriorityPerGas.bind(swapsController),
      safeRefetchQuotes: swapsController.safeRefetchQuotes.bind(swapsController),
      stopPollingForQuotes: swapsController.stopPollingForQuotes.bind(swapsController),
      setBackgroundSwapRouteState: swapsController.setBackgroundSwapRouteState.bind(swapsController),
      resetPostFetchState: swapsController.resetPostFetchState.bind(swapsController),
      setSwapsErrorKey: swapsController.setSwapsErrorKey.bind(swapsController),
      setInitialGasEstimate: swapsController.setInitialGasEstimate.bind(swapsController),
      setCustomApproveTxData: swapsController.setCustomApproveTxData.bind(swapsController),
      setSwapsLiveness: swapsController.setSwapsLiveness.bind(swapsController),
      setSwapsFeatureFlags: swapsController.setSwapsFeatureFlags.bind(swapsController),
      setSwapsUserFeeLevel: swapsController.setSwapsUserFeeLevel.bind(swapsController),
      setSwapsQuotesPollingLimitEnabled: swapsController.setSwapsQuotesPollingLimitEnabled.bind(swapsController),
      // Smart Transactions
      setSmartTransactionsOptInStatus: smartTransactionsController.setOptInState.bind(smartTransactionsController),
      fetchSmartTransactionFees: smartTransactionsController.getFees.bind(smartTransactionsController),
      clearSmartTransactionFees: smartTransactionsController.clearFees.bind(smartTransactionsController),
      submitSignedTransactions: smartTransactionsController.submitSignedTransactions.bind(smartTransactionsController),
      cancelSmartTransaction: smartTransactionsController.cancelSmartTransaction.bind(smartTransactionsController),
      fetchSmartTransactionsLiveness: smartTransactionsController.fetchLiveness.bind(smartTransactionsController),
      updateSmartTransaction: smartTransactionsController.updateSmartTransaction.bind(smartTransactionsController),
      setStatusRefreshInterval: smartTransactionsController.setStatusRefreshInterval.bind(smartTransactionsController),
      // MetaMetrics
      trackMetaMetricsEvent: metaMetricsController.trackEvent.bind(metaMetricsController),
      trackMetaMetricsPage: metaMetricsController.trackPage.bind(metaMetricsController),
      createEventFragment: metaMetricsController.createEventFragment.bind(metaMetricsController),
      updateEventFragment: metaMetricsController.updateEventFragment.bind(metaMetricsController),
      finalizeEventFragment: metaMetricsController.finalizeEventFragment.bind(metaMetricsController),
      // approval controller
      resolvePendingApproval: this.resolvePendingApproval,
      rejectPendingApproval: this.rejectPendingApproval,
      // Notifications
      updateViewedNotifications: announcementController.updateViewed.bind(announcementController),
      // GasFeeController
      getGasFeeEstimatesAndStartPolling: gasFeeController.getGasFeeEstimatesAndStartPolling.bind(gasFeeController),
      disconnectGasFeeEstimatePoller: gasFeeController.disconnectPoller.bind(gasFeeController),
      getGasFeeTimeEstimate: gasFeeController.getTimeEstimate.bind(gasFeeController),
      addPollingTokenToAppState: appStateController.addPollingToken.bind(appStateController),
      removePollingTokenFromAppState: appStateController.removePollingToken.bind(appStateController),
      // BackupController
      backupUserData: backupController.backupUserData.bind(backupController),
      restoreUserData: backupController.restoreUserData.bind(backupController),
      // DetectTokenController
      detectNewTokens: detectTokensController.detectNewTokens.bind(detectTokensController),
      // DetectCollectibleController
      detectNfts: nftDetectionController.detectNfts.bind(nftDetectionController),
      /** Token Detection V2 */
      addDetectedTokens: tokensController.addDetectedTokens.bind(tokensController),
      addImportedTokens: tokensController.addTokens.bind(tokensController),
      ignoreTokens: tokensController.ignoreTokens.bind(tokensController),
      getBalancesInSingleCall: assetsContractController.getBalancesInSingleCall.bind(assetsContractController)
    };
  }
  async exportAccount(address, password) {
    await this.verifyPassword(password);
    return this.keyringController.exportAccount(address, password);
  }
  async getTokenStandardAndDetails(address, userAddress, tokenId) {
    var _details, _details$decimals, _details2, _details2$balance;
    const {
      tokenList
    } = this.tokenListController.state;
    const {
      tokens
    } = this.tokensController.state;
    const staticTokenListDetails = _tokens.STATIC_MAINNET_TOKEN_LIST[address.toLowerCase()] || {};
    const tokenListDetails = tokenList[address.toLowerCase()] || {};
    const userDefinedTokenDetails = tokens.find(({
      address: _address
    }) => (0, _stringUtils.isEqualCaseInsensitive)(_address, address)) || {};
    const tokenDetails = {
      ...staticTokenListDetails,
      ...tokenListDetails,
      ...userDefinedTokenDetails
    };
    const tokenDetailsStandardIsERC20 = (0, _stringUtils.isEqualCaseInsensitive)(tokenDetails.standard, _transaction.TokenStandard.ERC20) || tokenDetails.erc20 === true;
    const noEvidenceThatTokenIsAnNFT = !tokenId && !(0, _stringUtils.isEqualCaseInsensitive)(tokenDetails.standard, _transaction.TokenStandard.ERC1155) && !(0, _stringUtils.isEqualCaseInsensitive)(tokenDetails.standard, _transaction.TokenStandard.ERC721) && !tokenDetails.erc721;
    const otherDetailsAreERC20Like = tokenDetails.decimals !== undefined && tokenDetails.symbol;
    const tokenCanBeTreatedAsAnERC20 = tokenDetailsStandardIsERC20 || noEvidenceThatTokenIsAnNFT && otherDetailsAreERC20Like;
    let details;
    if (tokenCanBeTreatedAsAnERC20) {
      try {
        const balance = await (0, _tokenUtil.fetchTokenBalance)(address, userAddress, this.provider);
        details = {
          address,
          balance,
          standard: _transaction.TokenStandard.ERC20,
          decimals: tokenDetails.decimals,
          symbol: tokenDetails.symbol
        };
      } catch (e) {
        // If the `fetchTokenBalance` call failed, `details` remains undefined, and we
        // fall back to the below `assetsContractController.getTokenStandardAndDetails` call
        _loglevel.default.warning(`Failed to get token balance. Error: ${e}`);
      }
    }

    // `details`` will be undefined if `tokenCanBeTreatedAsAnERC20`` is false,
    // or if it is true but the `fetchTokenBalance`` call failed. In either case, we should
    // attempt to retrieve details from `assetsContractController.getTokenStandardAndDetails`
    if (details === undefined) {
      details = await this.assetsContractController.getTokenStandardAndDetails(address, userAddress, tokenId);
    }
    return {
      ...details,
      decimals: (_details = details) === null || _details === void 0 ? void 0 : (_details$decimals = _details.decimals) === null || _details$decimals === void 0 ? void 0 : _details$decimals.toString(10),
      balance: (_details2 = details) === null || _details2 === void 0 ? void 0 : (_details2$balance = _details2.balance) === null || _details2$balance === void 0 ? void 0 : _details2$balance.toString(10)
    };
  }

  //=============================================================================
  // VAULT / KEYRING RELATED METHODS
  //=============================================================================

  /**
   * Creates a new Vault and create a new keychain.
   *
   * A vault, or KeyringController, is a controller that contains
   * many different account strategies, currently called Keyrings.
   * Creating it new means wiping all previous keyrings.
   *
   * A keychain, or keyring, controls many accounts with a single backup and signing strategy.
   * For example, a mnemonic phrase can generate many accounts, and is a keyring.
   *
   * @param {string} password
   * @returns {object} vault
   */
  async createNewVaultAndKeychain(password) {
    const releaseLock = await this.createVaultMutex.acquire();
    try {
      let vault;
      const accounts = await this.keyringController.getAccounts();
      if (accounts.length > 0) {
        vault = await this.keyringController.fullUpdate();
      } else {
        vault = await this.keyringController.createNewVaultAndKeychain(password);
        const addresses = await this.keyringController.getAccounts();
        this.preferencesController.setAddresses(addresses);
        this.selectFirstIdentity();
      }
      return vault;
    } finally {
      releaseLock();
    }
  }

  /**
   * Create a new Vault and restore an existent keyring.
   *
   * @param {string} password
   * @param {number[]} encodedSeedPhrase - The seed phrase, encoded as an array
   * of UTF-8 bytes.
   */
  async createNewVaultAndRestore(password, encodedSeedPhrase) {
    const releaseLock = await this.createVaultMutex.acquire();
    try {
      let accounts, lastBalance;
      const seedPhraseAsBuffer = Buffer.from(encodedSeedPhrase);
      const {
        keyringController
      } = this;

      // clear known identities
      this.preferencesController.setAddresses([]);

      // clear permissions
      this.permissionController.clearState();

      // clear accounts in accountTracker
      this.accountTracker.clearAccounts();

      // clear cachedBalances
      this.cachedBalancesController.clearCachedBalances();

      // clear unapproved transactions
      this.txController.txStateManager.clearUnapprovedTxs();

      // create new vault
      const vault = await keyringController.createNewVaultAndRestore(password, seedPhraseAsBuffer);
      const ethQuery = new _ethQuery.default(this.provider);
      accounts = await keyringController.getAccounts();
      lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      const [primaryKeyring] = keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
      if (!primaryKeyring) {
        throw new Error('MetamaskController - No HD Key Tree found');
      }

      // seek out the first zero balance
      while (lastBalance !== '0x0') {
        await keyringController.addNewAccount(primaryKeyring);
        accounts = await keyringController.getAccounts();
        lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      }

      // remove extra zero balance account potentially created from seeking ahead
      if (accounts.length > 1 && lastBalance === '0x0') {
        await this.removeAccount(accounts[accounts.length - 1]);
        accounts = await keyringController.getAccounts();
      }

      // This must be set as soon as possible to communicate to the
      // keyring's iframe and have the setting initialized properly
      // Optimistically called to not block MetaMask login due to
      // Ledger Keyring GitHub downtime
      const transportPreference = this.preferencesController.getLedgerTransportPreference();
      this.setLedgerTransportPreference(transportPreference);

      // set new identities
      this.preferencesController.setAddresses(accounts);
      this.selectFirstIdentity();
      return vault;
    } finally {
      releaseLock();
    }
  }

  /**
   * Get an account balance from the AccountTracker or request it directly from the network.
   *
   * @param {string} address - The account address
   * @param {EthQuery} ethQuery - The EthQuery instance to use when asking the network
   */
  getBalance(address, ethQuery) {
    return new Promise((resolve, reject) => {
      const cached = this.accountTracker.store.getState().accounts[address];
      if (cached && cached.balance) {
        resolve(cached.balance);
      } else {
        ethQuery.getBalance(address, (error, balance) => {
          if (error) {
            reject(error);
            _loglevel.default.error(error);
          } else {
            resolve(balance || '0x0');
          }
        });
      }
    });
  }

  /**
   * Submits the user's password and attempts to unlock the vault.
   * Also synchronizes the preferencesController, to ensure its schema
   * is up to date with known accounts once the vault is decrypted.
   *
   * @param {string} password - The user's password
   * @returns {Promise<object>} The keyringController update.
   */
  async submitPassword(password) {
    await this.keyringController.submitPassword(password);
    try {
      await this.blockTracker.checkForLatestBlock();
    } catch (error) {
      _loglevel.default.error('Error while unlocking extension.', error);
    }

    // This must be set as soon as possible to communicate to the
    // keyring's iframe and have the setting initialized properly
    // Optimistically called to not block MetaMask login due to
    // Ledger Keyring GitHub downtime
    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    this.setLedgerTransportPreference(transportPreference);
    return this.keyringController.fullUpdate();
  }
  async _loginUser() {
    try {
      // Automatic login via config password
      const password = null;
      if (password && !false) {
        await this.submitPassword(password);
      }
      // Automatic login via storage encryption key
      else if (_mv.isManifestV3) {
        await this.submitEncryptionKey();
      }
      // Updating accounts in this.accountTracker before starting UI syncing ensure that
      // state has account balance before it is synced with UI
      await this.accountTracker._updateAccounts();
    } finally {
      this._startUISync();
    }
  }
  _startUISync() {
    // Message startUISync is used in MV3 to start syncing state with UI
    // Sending this message after login is completed helps to ensure that incomplete state without
    // account details are not flushed to UI.
    this.emit('startUISync');
    this.startUISync = true;
    this.memStore.subscribe(this.sendUpdate.bind(this));
  }

  /**
   * Submits a user's encryption key to log the user in via login token
   */
  async submitEncryptionKey() {
    try {
      const {
        loginToken,
        loginSalt
      } = await this.extension.storage.session.get(['loginToken', 'loginSalt']);
      if (loginToken && loginSalt) {
        const {
          vault
        } = this.keyringController.store.getState();
        const jsonVault = JSON.parse(vault);
        if (jsonVault.salt !== loginSalt) {
          console.warn('submitEncryptionKey: Stored salt and vault salt do not match');
          await this.clearLoginArtifacts();
          return;
        }
        await this.keyringController.submitEncryptionKey(loginToken, loginSalt);
      }
    } catch (e) {
      // If somehow this login token doesn't work properly,
      // remove it and the user will get shown back to the unlock screen
      await this.clearLoginArtifacts();
      throw e;
    }
  }
  async clearLoginArtifacts() {
    await this.extension.storage.session.remove(['loginToken', 'loginSalt']);
  }

  /**
   * Submits a user's password to check its validity.
   *
   * @param {string} password - The user's password
   */
  async verifyPassword(password) {
    await this.keyringController.verifyPassword(password);
  }

  /**
   * @type Identity
   * @property {string} name - The account nickname.
   * @property {string} address - The account's ethereum address, in lower case.
   * receiving funds from our automatic Ropsten faucet.
   */

  /**
   * Sets the first address in the state to the selected address
   */
  selectFirstIdentity() {
    const {
      identities
    } = this.preferencesController.store.getState();
    const [address] = Object.keys(identities);
    this.preferencesController.setSelectedAddress(address);
  }

  /**
   * Gets the mnemonic of the user's primary keyring.
   */
  getPrimaryKeyringMnemonic() {
    const [keyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
    if (!keyring.mnemonic) {
      throw new Error('Primary keyring mnemonic unavailable.');
    }
    return keyring.mnemonic;
  }

  //
  // Hardware
  //

  async getKeyringForDevice(deviceName, hdPath = null) {
    var _this$opts$overrides2, _keyringOverrides$tre, _keyringOverrides$led, _keyringOverrides$lat;
    const keyringOverrides = (_this$opts$overrides2 = this.opts.overrides) === null || _this$opts$overrides2 === void 0 ? void 0 : _this$opts$overrides2.keyrings;
    let keyringName = null;
    if (deviceName !== _hardwareWallets.HardwareDeviceNames.QR && !this.canUseHardwareWallets()) {
      throw new Error('Hardware wallets are not supported on this version.');
    }
    switch (deviceName) {
      case _hardwareWallets.HardwareDeviceNames.trezor:
        keyringName = (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : (_keyringOverrides$tre = keyringOverrides.trezor) === null || _keyringOverrides$tre === void 0 ? void 0 : _keyringOverrides$tre.type) || _ethTrezorKeyring.default.type;
        break;
      case _hardwareWallets.HardwareDeviceNames.ledger:
        keyringName = (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : (_keyringOverrides$led = keyringOverrides.ledger) === null || _keyringOverrides$led === void 0 ? void 0 : _keyringOverrides$led.type) || _ethLedgerBridgeKeyring.default.type;
        break;
      case _hardwareWallets.HardwareDeviceNames.qr:
        keyringName = _metamaskAirgappedKeyring.MetaMaskKeyring.type;
        break;
      case _hardwareWallets.HardwareDeviceNames.lattice:
        keyringName = (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : (_keyringOverrides$lat = keyringOverrides.lattice) === null || _keyringOverrides$lat === void 0 ? void 0 : _keyringOverrides$lat.type) || _ethLatticeKeyring.default.type;
        break;
      default:
        throw new Error('MetamaskController:getKeyringForDevice - Unknown device');
    }
    let [keyring] = await this.keyringController.getKeyringsByType(keyringName);
    if (!keyring) {
      keyring = await this.keyringController.addNewKeyring(keyringName);
    }
    if (hdPath && keyring.setHdPath) {
      keyring.setHdPath(hdPath);
    }
    if (deviceName === _hardwareWallets.HardwareDeviceNames.lattice) {
      keyring.appName = 'MetaMask';
    }
    if (deviceName === _hardwareWallets.HardwareDeviceNames.trezor) {
      const model = keyring.getModel();
      this.appStateController.setTrezorModel(model);
    }
    keyring.network = this.networkController.store.getState().providerConfig.type;
    return keyring;
  }
  async attemptLedgerTransportCreation() {
    const keyring = await this.getKeyringForDevice(_hardwareWallets.HardwareDeviceNames.ledger);
    return await keyring.attemptMakeApp();
  }
  async establishLedgerTransportPreference() {
    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    return await this.setLedgerTransportPreference(transportPreference);
  }

  /**
   * Fetch account list from a trezor device.
   *
   * @param deviceName
   * @param page
   * @param hdPath
   * @returns [] accounts
   */
  async connectHardware(deviceName, page, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    let accounts = [];
    switch (page) {
      case -1:
        accounts = await keyring.getPreviousPage();
        break;
      case 1:
        accounts = await keyring.getNextPage();
        break;
      default:
        accounts = await keyring.getFirstPage();
    }

    // Merge with existing accounts
    // and make sure addresses are not repeated
    const oldAccounts = await this.keyringController.getAccounts();
    const accountsToTrack = [...new Set(oldAccounts.concat(accounts.map(a => a.address.toLowerCase())))];
    this.accountTracker.syncWithAddresses(accountsToTrack);
    return accounts;
  }

  /**
   * Check if the device is unlocked
   *
   * @param deviceName
   * @param hdPath
   * @returns {Promise<boolean>}
   */
  async checkHardwareStatus(deviceName, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    return keyring.isUnlocked();
  }

  /**
   * Clear
   *
   * @param deviceName
   * @returns {Promise<boolean>}
   */
  async forgetDevice(deviceName) {
    const keyring = await this.getKeyringForDevice(deviceName);
    keyring.forgetDevice();
    return true;
  }

  /**
   * Retrieves the keyring for the selected address and using the .type returns
   * a subtype for the account. Either 'hardware', 'imported' or 'MetaMask'.
   *
   * @param {string} address - Address to retrieve keyring for
   * @returns {'hardware' | 'imported' | 'MetaMask'}
   */
  async getAccountType(address) {
    const keyring = await this.keyringController.getKeyringForAccount(address);
    switch (keyring.type) {
      case _keyring.KeyringType.trezor:
      case _keyring.KeyringType.lattice:
      case _keyring.KeyringType.qr:
      case _keyring.KeyringType.ledger:
        return 'hardware';
      case _keyring.KeyringType.imported:
        return 'imported';
      default:
        return 'MetaMask';
    }
  }

  /**
   * Retrieves the keyring for the selected address and using the .type
   * determines if a more specific name for the device is available. Returns
   * 'N/A' for non hardware wallets.
   *
   * @param {string} address - Address to retrieve keyring for
   * @returns {'ledger' | 'lattice' | 'N/A' | string}
   */
  async getDeviceModel(address) {
    const keyring = await this.keyringController.getKeyringForAccount(address);
    switch (keyring.type) {
      case _keyring.KeyringType.trezor:
        return keyring.getModel();
      case _keyring.KeyringType.qr:
        return keyring.getName();
      case _keyring.KeyringType.ledger:
        // TODO: get model after ledger keyring exposes method
        return _hardwareWallets.HardwareDeviceNames.ledger;
      case _keyring.KeyringType.lattice:
        // TODO: get model after lattice keyring exposes method
        return _hardwareWallets.HardwareDeviceNames.lattice;
      default:
        return 'N/A';
    }
  }

  /**
   * get hardware account label
   *
   * @returns string label
   */

  getAccountLabel(name, index, hdPathDescription) {
    return `${name[0].toUpperCase()}${name.slice(1)} ${parseInt(index, 10) + 1} ${hdPathDescription || ''}`.trim();
  }

  /**
   * Imports an account from a Trezor or Ledger device.
   *
   * @param index
   * @param deviceName
   * @param hdPath
   * @param hdPathDescription
   * @returns {} keyState
   */
  async unlockHardwareWalletAccount(index, deviceName, hdPath, hdPathDescription) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    keyring.setAccountToUnlock(index);
    const oldAccounts = await this.keyringController.getAccounts();
    const keyState = await this.keyringController.addNewAccount(keyring);
    const newAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(newAccounts);
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        const label = this.getAccountLabel(deviceName === _hardwareWallets.HardwareDeviceNames.qr ? keyring.getName() : deviceName, index, hdPathDescription);
        // Set the account label to Trezor 1 /  Ledger 1 / QR Hardware 1, etc
        this.preferencesController.setAccountLabel(address, label);
        // Select the account
        this.preferencesController.setSelectedAddress(address);
      }
    });
    const {
      identities
    } = this.preferencesController.store.getState();
    return {
      ...keyState,
      identities
    };
  }

  //
  // Account Management
  //

  /**
   * Adds a new account to the default (first) HD seed phrase Keyring.
   *
   * @param accountCount
   * @returns {} keyState
   */
  async addNewAccount(accountCount) {
    const isActionMetricsQueueE2ETest = this.appStateController.store.getState()[_testFlags.ACTION_QUEUE_METRICS_E2E_TEST];
    if (false && isActionMetricsQueueE2ETest) {
      await new Promise(resolve => setTimeout(resolve, 5_000));
    }
    const [primaryKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }
    const {
      keyringController
    } = this;
    const {
      identities: oldIdentities
    } = this.preferencesController.store.getState();
    if (Object.keys(oldIdentities).length === accountCount) {
      const oldAccounts = await keyringController.getAccounts();
      const keyState = await keyringController.addNewAccount(primaryKeyring);
      const newAccounts = await keyringController.getAccounts();
      await this.verifySeedPhrase();
      this.preferencesController.setAddresses(newAccounts);
      newAccounts.forEach(address => {
        if (!oldAccounts.includes(address)) {
          this.preferencesController.setSelectedAddress(address);
        }
      });
      const {
        identities
      } = this.preferencesController.store.getState();
      return {
        ...keyState,
        identities
      };
    }
    return {
      ...keyringController.memStore.getState(),
      identities: oldIdentities
    };
  }

  /**
   * Verifies the validity of the current vault's seed phrase.
   *
   * Validity: seed phrase restores the accounts belonging to the current vault.
   *
   * Called when the first account is created and on unlocking the vault.
   *
   * @returns {Promise<number[]>} The seed phrase to be confirmed by the user,
   * encoded as an array of UTF-8 bytes.
   */
  async verifySeedPhrase() {
    const [primaryKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }
    const serialized = await primaryKeyring.serialize();
    const seedPhraseAsBuffer = Buffer.from(serialized.mnemonic);
    const accounts = await primaryKeyring.getAccounts();
    if (accounts.length < 1) {
      throw new Error('MetamaskController - No accounts found');
    }
    try {
      await _seedPhraseVerifier.default.verifyAccounts(accounts, seedPhraseAsBuffer);
      return Array.from(seedPhraseAsBuffer.values());
    } catch (err) {
      _loglevel.default.error(err.message);
      throw err;
    }
  }

  /**
   * Clears the transaction history, to allow users to force-reset their nonces.
   * Mostly used in development environments, when networks are restarted with
   * the same network ID.
   *
   * @returns {Promise<string>} The current selected address.
   */
  async resetAccount() {
    const selectedAddress = this.preferencesController.getSelectedAddress();
    this.txController.wipeTransactions(selectedAddress);
    this.networkController.resetConnection();
    return selectedAddress;
  }

  /**
   * Gets the permitted accounts for the specified origin. Returns an empty
   * array if no accounts are permitted.
   *
   * @param {string} origin - The origin whose exposed accounts to retrieve.
   * @param {boolean} [suppressUnauthorizedError] - Suppresses the unauthorized error.
   * @returns {Promise<string[]>} The origin's permitted accounts, or an empty
   * array.
   */
  async getPermittedAccounts(origin, {
    suppressUnauthorizedError = true
  } = {}) {
    try {
      return await this.permissionController.executeRestrictedMethod(origin, _permissions.RestrictedMethods.eth_accounts);
    } catch (error) {
      if (suppressUnauthorizedError && error.code === _ethRpcErrors.errorCodes.provider.unauthorized) {
        return [];
      }
      throw error;
    }
  }

  /**
   * Stops exposing the account with the specified address to all third parties.
   * Exposed accounts are stored in caveats of the eth_accounts permission. This
   * method uses `PermissionController.updatePermissionsByCaveat` to
   * remove the specified address from every eth_accounts permission. If a
   * permission only included this address, the permission is revoked entirely.
   *
   * @param {string} targetAccount - The address of the account to stop exposing
   * to third parties.
   */
  removeAllAccountPermissions(targetAccount) {
    this.permissionController.updatePermissionsByCaveat(_permissions.CaveatTypes.restrictReturnedAccounts, existingAccounts => _permissions2.CaveatMutatorFactories[_permissions.CaveatTypes.restrictReturnedAccounts].removeAccount(targetAccount, existingAccounts));
  }

  /**
   * Removes an account from state / storage.
   *
   * @param {string[]} address - A hex address
   */
  async removeAccount(address) {
    // Remove all associated permissions
    this.removeAllAccountPermissions(address);
    // Remove account from the preferences controller
    this.preferencesController.removeAddress(address);
    // Remove account from the account tracker controller
    this.accountTracker.removeAccount([address]);
    const keyring = await this.keyringController.getKeyringForAccount(address);
    // Remove account from the keyring
    await this.keyringController.removeAccount(address);
    const updatedKeyringAccounts = keyring ? await keyring.getAccounts() : {};
    if ((updatedKeyringAccounts === null || updatedKeyringAccounts === void 0 ? void 0 : updatedKeyringAccounts.length) === 0) {
      var _keyring$destroy;
      (_keyring$destroy = keyring.destroy) === null || _keyring$destroy === void 0 ? void 0 : _keyring$destroy.call(keyring);
    }
    return address;
  }

  /**
   * Imports an account with the specified import strategy.
   * These are defined in app/scripts/account-import-strategies
   * Each strategy represents a different way of serializing an Ethereum key pair.
   *
   * @param {string} strategy - A unique identifier for an account import strategy.
   * @param {any} args - The data required by that strategy to import an account.
   */
  async importAccountWithStrategy(strategy, args) {
    const privateKey = await _accountImportStrategies.default.importAccount(strategy, args);
    const keyring = await this.keyringController.addNewKeyring(_keyring.KeyringType.imported, [privateKey]);
    const [firstAccount] = await keyring.getAccounts();
    // update accounts in preferences controller
    const allAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(allAccounts);
    // set new account as selected
    this.preferencesController.setSelectedAddress(firstAccount);
  }

  // ---------------------------------------------------------------------------
  // Identity Management (signature operations)

  /**
   * Called when a Dapp suggests a new tx to be signed.
   * this wrapper needs to exist so we can provide a reference to
   *  "newUnapprovedTransaction" before "txController" is instantiated
   *
   * @param {object} txParams - The transaction parameters.
   * @param {object} [req] - The original request, containing the origin.
   */
  async newUnapprovedTransaction(txParams, req) {
    return await this.txController.newUnapprovedTransaction(txParams, req);
  }

  /**
   * @returns {boolean} true if the keyring type supports EIP-1559
   */
  async getCurrentAccountEIP1559Compatibility() {
    return true;
  }

  //=============================================================================
  // END (VAULT / KEYRING RELATED METHODS)
  //=============================================================================

  /**
   * Allows a user to attempt to cancel a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to cancel
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param options
   * @returns {object} MetaMask state
   */
  async createCancelTransaction(originalTxId, customGasSettings, options) {
    await this.txController.createCancelTransaction(originalTxId, customGasSettings, options);
    const state = this.getState();
    return state;
  }

  /**
   * Allows a user to attempt to speed up a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to speed up
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param options
   * @returns {object} MetaMask state
   */
  async createSpeedUpTransaction(originalTxId, customGasSettings, options) {
    await this.txController.createSpeedUpTransaction(originalTxId, customGasSettings, options);
    const state = this.getState();
    return state;
  }
  estimateGas(estimateGasParams) {
    return new Promise((resolve, reject) => {
      return this.txController.txGasUtil.query.estimateGas(estimateGasParams, (err, res) => {
        if (err) {
          return reject(err);
        }
        return resolve(res.toString(16));
      });
    });
  }

  //=============================================================================
  // PASSWORD MANAGEMENT
  //=============================================================================

  /**
   * Allows a user to begin the seed phrase recovery process.
   */
  markPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(true);
    this.sendUpdate();
  }

  /**
   * Allows a user to end the seed phrase recovery process.
   */
  unMarkPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(false);
    this.sendUpdate();
  }

  //=============================================================================
  // SETUP
  //=============================================================================

  /**
   * A runtime.MessageSender object, as provided by the browser:
   *
   * @see https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/MessageSender
   * @typedef {object} MessageSender
   * @property {string} - The URL of the page or frame hosting the script that sent the message.
   */

  /**
   * A Snap sender object.
   *
   * @typedef {object} SnapSender
   * @property {string} snapId - The ID of the snap.
   */

  /**
   * Used to create a multiplexed stream for connecting to an untrusted context
   * like a Dapp or other extension.
   *
   * @param options - Options bag.
   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.
   * @param {MessageSender | SnapSender} options.sender - The sender of the messages on this stream.
   * @param {string} [options.subjectType] - The type of the sender, i.e. subject.
   */
  setupUntrustedCommunication({
    connectionStream,
    sender,
    subjectType
  }) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();
    let _subjectType;
    if (subjectType) {
      _subjectType = subjectType;
    } else if (sender.id && sender.id !== this.extension.runtime.id) {
      _subjectType = _subjectMetadataController.SubjectType.Extension;
    } else {
      _subjectType = _subjectMetadataController.SubjectType.Website;
    }
    if (sender.url) {
      const {
        hostname
      } = new URL(sender.url);
      this.phishingController.maybeUpdateState();
      // Check if new connection is blocked if phishing detection is on
      const phishingTestResponse = this.phishingController.test(hostname);
      if (usePhishDetect && phishingTestResponse !== null && phishingTestResponse !== void 0 && phishingTestResponse.result) {
        this.sendPhishingWarning(connectionStream, hostname);
        this.metaMetricsController.trackEvent({
          event: _metametrics.MetaMetricsEventName.PhishingPageDisplayed,
          category: _metametrics.MetaMetricsEventCategory.Phishing,
          properties: {
            url: hostname
          }
        });
        return;
      }
    }

    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);

    // messages between inpage and background
    this.setupProviderConnection(mux.createStream('metamask-provider'), sender, _subjectType);

    // TODO:LegacyProvider: Delete
    if (sender.url) {
      // legacy streams
      this.setupPublicConfig(mux.createStream('publicConfig'));
    }
  }

  /**
   * Used to create a multiplexed stream for connecting to a trusted context,
   * like our own user interfaces, which have the provider APIs, but also
   * receive the exported API from this controller, which includes trusted
   * functions, like the ability to approve transactions or sign messages.
   *
   * @param {*} connectionStream - The duplex stream to connect to.
   * @param {MessageSender} sender - The sender of the messages on this stream
   */
  setupTrustedCommunication(connectionStream, sender) {
    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    // connect features
    this.setupControllerConnection(mux.createStream('controller'));
    this.setupProviderConnection(mux.createStream('provider'), sender, _subjectMetadataController.SubjectType.Internal);
  }

  /**
   * Used to create a multiplexed stream for connecting to the phishing warning page.
   *
   * @param options - Options bag.
   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.
   */
  setupPhishingCommunication({
    connectionStream
  }) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();
    if (!usePhishDetect) {
      return;
    }

    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream(PHISHING_SAFELIST);

    // set up postStream transport
    phishingStream.on('data', (0, _createMetaRPCHandler.default)({
      safelistPhishingDomain: this.safelistPhishingDomain.bind(this),
      backToSafetyPhishingWarning: this.backToSafetyPhishingWarning.bind(this)
    }, phishingStream));
  }

  /**
   * Called when we detect a suspicious domain. Requests the browser redirects
   * to our anti-phishing page.
   *
   * @private
   * @param {*} connectionStream - The duplex stream to the per-page script,
   * for sending the reload attempt to.
   * @param {string} hostname - The hostname that triggered the suspicion.
   */
  sendPhishingWarning(connectionStream, hostname) {
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream('phishing');
    phishingStream.write({
      hostname
    });
  }

  /**
   * A method for providing our API over a stream using JSON-RPC.
   *
   * @param {*} outStream - The stream to provide our API over.
   */
  setupControllerConnection(outStream) {
    const api = this.getApi();

    // report new active controller connection
    this.activeControllerConnections += 1;
    this.emit('controllerConnectionChanged', this.activeControllerConnections);

    // set up postStream transport
    outStream.on('data', (0, _createMetaRPCHandler.default)(api, outStream, this.store, this.localStoreApiWrapper));
    const handleUpdate = update => {
      if (outStream._writableState.ended) {
        return;
      }
      // send notification to client-side
      outStream.write({
        jsonrpc: '2.0',
        method: 'sendUpdate',
        params: [update]
      });
    };
    this.on('update', handleUpdate);
    const startUISync = () => {
      if (outStream._writableState.ended) {
        return;
      }
      // send notification to client-side
      outStream.write({
        jsonrpc: '2.0',
        method: 'startUISync'
      });
    };
    if (this.startUISync) {
      startUISync();
    } else {
      this.once('startUISync', startUISync);
    }
    outStream.on('end', () => {
      this.activeControllerConnections -= 1;
      this.emit('controllerConnectionChanged', this.activeControllerConnections);
      this.removeListener('update', handleUpdate);
    });
  }

  /**
   * A method for serving our ethereum provider over a given stream.
   *
   * @param {*} outStream - The stream to provide over.
   * @param {MessageSender | SnapSender} sender - The sender of the messages on this stream
   * @param {SubjectType} subjectType - The type of the sender, i.e. subject.
   */
  setupProviderConnection(outStream, sender, subjectType) {
    let origin;
    if (subjectType === _subjectMetadataController.SubjectType.Internal) {
      origin = _app.ORIGIN_METAMASK;
    } else {
      origin = new URL(sender.url).origin;
    }
    if (sender.id && sender.id !== this.extension.runtime.id) {
      this.subjectMetadataController.addSubjectMetadata({
        origin,
        extensionId: sender.id,
        subjectType: _subjectMetadataController.SubjectType.Extension
      });
    }
    let tabId;
    if (sender.tab && sender.tab.id) {
      tabId = sender.tab.id;
    }
    const engine = this.setupProviderEngine({
      origin,
      sender,
      subjectType,
      tabId
    });

    // setup connection
    const providerStream = (0, _jsonRpcMiddlewareStream.createEngineStream)({
      engine
    });
    const connectionId = this.addConnection(origin, {
      engine
    });
    (0, _pump.default)(outStream, providerStream, outStream, err => {
      // handle any middleware cleanup
      engine._middleware.forEach(mid => {
        if (mid.destroy && typeof mid.destroy === 'function') {
          mid.destroy();
        }
      });
      connectionId && this.removeConnection(origin, connectionId);
      if (err) {
        _loglevel.default.error(err);
      }
    });
  }

  /**
   * A method for creating a provider that is safely restricted for the requesting subject.
   *
   * @param {object} options - Provider engine options
   * @param {string} options.origin - The origin of the sender
   * @param {MessageSender | SnapSender} options.sender - The sender object.
   * @param {string} options.subjectType - The type of the sender subject.
   * @param {tabId} [options.tabId] - The tab ID of the sender - if the sender is within a tab
   */
  setupProviderEngine({
    origin,
    subjectType,
    sender,
    tabId
  }) {
    // setup json rpc engine stack
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    const {
      blockTracker,
      provider
    } = this;

    // create filter polyfill middleware
    const filterMiddleware = (0, _ethJsonRpcFilters.default)({
      provider,
      blockTracker
    });

    // create subscription polyfill middleware
    const subscriptionManager = (0, _subscriptionManager.default)({
      provider,
      blockTracker
    });
    subscriptionManager.events.on('notification', message => engine.emit('notification', message));
    if (_mv.isManifestV3) {
      engine.push((0, _createDupeReqFilterMiddleware.default)());
    }

    // append origin to each request
    engine.push((0, _createOriginMiddleware.default)({
      origin
    }));

    // append tabId to each request if it exists
    if (tabId) {
      engine.push((0, _createTabIdMiddleware.default)({
        tabId
      }));
    }

    // logging
    engine.push((0, _createLoggerMiddleware.default)({
      origin
    }));
    engine.push(this.permissionLogController.createMiddleware());
    engine.push((0, _createRPCMethodTrackingMiddleware.default)({
      trackEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getMetricsState: this.metaMetricsController.store.getState.bind(this.metaMetricsController.store),
      securityProviderRequest: this.securityProviderRequest.bind(this)
    }));

    // onboarding
    if (subjectType === _subjectMetadataController.SubjectType.Website) {
      engine.push((0, _createOnboardingMiddleware.default)({
        location: sender.url,
        registerOnboarding: this.onboardingController.registerOnboarding
      }));
    }

    // Unrestricted/permissionless RPC method implementations
    engine.push((0, _rpcMethodMiddleware.createMethodMiddleware)({
      origin,
      subjectType,
      // Miscellaneous
      addSubjectMetadata: this.subjectMetadataController.addSubjectMetadata.bind(this.subjectMetadataController),
      getProviderState: this.getProviderState.bind(this),
      getUnlockPromise: this.appStateController.getUnlockPromise.bind(this.appStateController),
      handleWatchAssetRequest: this.tokensController.watchAsset.bind(this.tokensController),
      requestUserApproval: this.approvalController.addAndShowApprovalRequest.bind(this.approvalController),
      sendMetrics: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      // Permission-related
      getAccounts: this.getPermittedAccounts.bind(this, origin),
      getPermissionsForOrigin: this.permissionController.getPermissions.bind(this.permissionController, origin),
      hasPermission: this.permissionController.hasPermission.bind(this.permissionController, origin),
      requestAccountsPermission: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }, {
        eth_accounts: {}
      }),
      requestPermissionsForOrigin: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }),
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      getCurrentRpcUrl: () => this.networkController.store.getState().providerConfig.rpcUrl,
      // network configuration-related
      getNetworkConfigurations: () => this.networkController.store.getState().networkConfigurations,
      upsertNetworkConfiguration: this.networkController.upsertNetworkConfiguration.bind(this.networkController),
      setActiveNetwork: this.networkController.setActiveNetwork.bind(this.networkController),
      findNetworkConfigurationBy: this.findNetworkConfigurationBy.bind(this),
      setProviderType: this.networkController.setProviderType.bind(this.networkController),
      // Web3 shim-related
      getWeb3ShimUsageState: this.alertController.getWeb3ShimUsageState.bind(this.alertController),
      setWeb3ShimUsageRecorded: this.alertController.setWeb3ShimUsageRecorded.bind(this.alertController)
    }));

    // filter and subscription polyfills
    engine.push(filterMiddleware);
    engine.push(subscriptionManager.middleware);
    if (subjectType !== _subjectMetadataController.SubjectType.Internal) {
      // permissions
      engine.push(this.permissionController.createPermissionMiddleware({
        origin
      }));
    }
    engine.push(this.metamaskMiddleware);

    // forward to metamask primary provider
    engine.push((0, _ethJsonRpcMiddleware.providerAsMiddleware)(provider));
    return engine;
  }

  /**
   * TODO:LegacyProvider: Delete
   * A method for providing our public config info over a stream.
   * This includes info we like to be synchronous if possible, like
   * the current selected account, and network ID.
   *
   * Since synchronous methods have been deprecated in web3,
   * this is a good candidate for deprecation.
   *
   * @param {*} outStream - The stream to provide public config over.
   */
  setupPublicConfig(outStream) {
    const configStream = (0, _asStream.storeAsStream)(this.publicConfigStore);
    (0, _pump.default)(configStream, outStream, err => {
      configStream.destroy();
      if (err) {
        _loglevel.default.error(err);
      }
    });
  }

  /**
   * Adds a reference to a connection by origin. Ignores the 'metamask' origin.
   * Caller must ensure that the returned id is stored such that the reference
   * can be deleted later.
   *
   * @param {string} origin - The connection's origin string.
   * @param {object} options - Data associated with the connection
   * @param {object} options.engine - The connection's JSON Rpc Engine
   * @returns {string} The connection's id (so that it can be deleted later)
   */
  addConnection(origin, {
    engine
  }) {
    if (origin === _app.ORIGIN_METAMASK) {
      return null;
    }
    if (!this.connections[origin]) {
      this.connections[origin] = {};
    }
    const id = (0, _nanoid.default)();
    this.connections[origin][id] = {
      engine
    };
    return id;
  }

  /**
   * Deletes a reference to a connection, by origin and id.
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {string} id - The connection's id, as returned from addConnection.
   */
  removeConnection(origin, id) {
    const connections = this.connections[origin];
    if (!connections) {
      return;
    }
    delete connections[id];
    if (Object.keys(connections).length === 0) {
      delete this.connections[origin];
    }
  }

  /**
   * Closes all connections for the given origin, and removes the references
   * to them.
   * Ignores unknown origins.
   *
   * @param {string} origin - The origin string.
   */
  removeAllConnections(origin) {
    const connections = this.connections[origin];
    if (!connections) {
      return;
    }
    Object.keys(connections).forEach(id => {
      this.removeConnection(origin, id);
    });
  }

  /**
   * Causes the RPC engines associated with the connections to the given origin
   * to emit a notification event with the given payload.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {unknown} payload - The event payload.
   */
  notifyConnections(origin, payload) {
    const connections = this.connections[origin];
    if (connections) {
      Object.values(connections).forEach(conn => {
        if (conn.engine) {
          conn.engine.emit('notification', payload);
        }
      });
    }
  }

  /**
   * Causes the RPC engines associated with all connections to emit a
   * notification event with the given payload.
   *
   * If the "payload" parameter is a function, the payload for each connection
   * will be the return value of that function called with the connection's
   * origin.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * @param {unknown} payload - The event payload, or payload getter function.
   */
  notifyAllConnections(payload) {
    const getPayload = typeof payload === 'function' ? origin => payload(origin) : () => payload;
    Object.keys(this.connections).forEach(origin => {
      Object.values(this.connections[origin]).forEach(async conn => {
        if (conn.engine) {
          conn.engine.emit('notification', await getPayload(origin));
        }
      });
    });
  }

  // handlers

  /**
   * Handle a KeyringController update
   *
   * @param {object} state - the KC state
   * @returns {Promise<void>}
   * @private
   */
  async _onKeyringControllerUpdate(state) {
    const {
      keyrings,
      encryptionKey: loginToken,
      encryptionSalt: loginSalt
    } = state;
    const addresses = keyrings.reduce((acc, {
      accounts
    }) => acc.concat(accounts), []);
    if (_mv.isManifestV3) {
      await this.extension.storage.session.set({
        loginToken,
        loginSalt
      });
    }
    if (!addresses.length) {
      return;
    }

    // Ensure preferences + identities controller know about all addresses
    this.preferencesController.syncAddresses(addresses);
    this.accountTracker.syncWithAddresses(addresses);
  }

  /**
   * Handle global application unlock.
   * Notifies all connections that the extension is unlocked, and which
   * account(s) are currently accessible, if any.
   */
  _onUnlock() {
    this.notifyAllConnections(async origin => {
      return {
        method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
        params: {
          isUnlocked: true,
          accounts: await this.getPermittedAccounts(origin)
        }
      };
    });
    this.unMarkPasswordForgotten();

    // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'unlock'
    // event of the MetaMaskController itself.
    this.emit('unlock');
  }

  /**
   * Handle global application lock.
   * Notifies all connections that the extension is locked.
   */
  _onLock() {
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
      params: {
        isUnlocked: false
      }
    });

    // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'lock'
    // event of the MetaMaskController itself.
    this.emit('lock');
  }

  /**
   * Handle memory state updates.
   * - Ensure isClientOpenAndUnlocked is updated
   * - Notifies all connections with the new provider network state
   *   - The external providers handle diffing the state
   *
   * @param newState
   */
  _onStateUpdate(newState) {
    this.isClientOpenAndUnlocked = newState.isUnlocked && this._isClientOpen;
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.chainChanged,
      params: this.getProviderNetworkState(newState)
    });
  }

  // misc

  /**
   * A method for emitting the full MetaMask state to all registered listeners.
   *
   * @private
   */
  privateSendUpdate() {
    this.emit('update', this.getState());
  }

  /**
   * @returns {boolean} Whether the extension is unlocked.
   */
  isUnlocked() {
    return this.keyringController.memStore.getState().isUnlocked;
  }

  //=============================================================================
  // MISCELLANEOUS
  //=============================================================================

  getExternalPendingTransactions(address) {
    return this.smartTransactionsController.getTransactions({
      addressFrom: address,
      status: 'pending'
    });
  }

  /**
   * Returns the nonce that will be associated with a transaction once approved
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */
  async getPendingNonce(address) {
    const {
      nonceDetails,
      releaseLock
    } = await this.txController.nonceTracker.getNonceLock(address);
    const pendingNonce = nonceDetails.params.highestSuggested;
    releaseLock();
    return pendingNonce;
  }

  /**
   * Returns the next nonce according to the nonce-tracker
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */
  async getNextNonce(address) {
    const nonceLock = await this.txController.nonceTracker.getNonceLock(address);
    nonceLock.releaseLock();
    return nonceLock.nextNonce;
  }

  //=============================================================================
  // CONFIG
  //=============================================================================

  /**
   * Returns the first network configuration object that matches at least one field of the
   * provided search criteria. Returns null if no match is found
   *
   * @param {object} rpcInfo - The RPC endpoint properties and values to check.
   * @returns {object} rpcInfo found in the network configurations list
   */
  findNetworkConfigurationBy(rpcInfo) {
    const {
      networkConfigurations
    } = this.networkController.store.getState();
    const networkConfiguration = Object.values(networkConfigurations).find(configuration => {
      return Object.keys(rpcInfo).some(key => {
        return configuration[key] === rpcInfo[key];
      });
    });
    return networkConfiguration || null;
  }

  /**
   * Sets the Ledger Live preference to use for Ledger hardware wallet support
   *
   * @param {string} transportType - The Ledger transport type.
   */
  async setLedgerTransportPreference(transportType) {
    if (!this.canUseHardwareWallets()) {
      return undefined;
    }
    const currentValue = this.preferencesController.getLedgerTransportPreference();
    const newValue = this.preferencesController.setLedgerTransportPreference(transportType);
    const keyring = await this.getKeyringForDevice(_hardwareWallets.HardwareDeviceNames.ledger);
    if (keyring !== null && keyring !== void 0 && keyring.updateTransportMethod) {
      return keyring.updateTransportMethod(newValue).catch(e => {
        // If there was an error updating the transport, we should
        // fall back to the original value
        this.preferencesController.setLedgerTransportPreference(currentValue);
        throw e;
      });
    }
    return undefined;
  }

  /**
   * A method for initializing storage the first time.
   *
   * @param {object} initState - The default state to initialize with.
   * @private
   */
  recordFirstTimeInfo(initState) {
    if (!('firstTimeInfo' in initState)) {
      const version = this.platform.getVersion();
      initState.firstTimeInfo = {
        version,
        date: Date.now()
      };
    }
  }

  // TODO: Replace isClientOpen methods with `controllerConnectionChanged` events.
  /* eslint-disable accessor-pairs */
  /**
   * A method for recording whether the MetaMask user interface is open or not.
   *
   * @param {boolean} open
   */
  set isClientOpen(open) {
    this._isClientOpen = open;
    this.detectTokensController.isOpen = open;
  }
  /* eslint-enable accessor-pairs */

  /**
   * A method that is called by the background when all instances of metamask are closed.
   * Currently used to stop polling in the gasFeeController.
   */
  onClientClosed() {
    try {
      this.gasFeeController.stopPolling();
      this.appStateController.clearPollingTokens();
    } catch (error) {
      console.error(error);
    }
  }

  /**
   * A method that is called by the background when a particular environment type is closed (fullscreen, popup, notification).
   * Currently used to stop polling in the gasFeeController for only that environement type
   *
   * @param environmentType
   */
  onEnvironmentTypeClosed(environmentType) {
    const appStatePollingTokenType = _app.POLLING_TOKEN_ENVIRONMENT_TYPES[environmentType];
    const pollingTokensToDisconnect = this.appStateController.store.getState()[appStatePollingTokenType];
    pollingTokensToDisconnect.forEach(pollingToken => {
      this.gasFeeController.disconnectPoller(pollingToken);
      this.appStateController.removePollingToken(pollingToken, appStatePollingTokenType);
    });
  }

  /**
   * Adds a domain to the PhishingController safelist
   *
   * @param {string} hostname - the domain to safelist
   */
  safelistPhishingDomain(hostname) {
    return this.phishingController.bypass(hostname);
  }
  async backToSafetyPhishingWarning() {
    const extensionURL = this.platform.getExtensionURL();
    await this.platform.switchToAnotherURL(undefined, extensionURL);
  }

  /**
   * Locks MetaMask
   */
  setLocked() {
    var _ledgerKeyring$destro;
    const [trezorKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.trezor);
    if (trezorKeyring) {
      trezorKeyring.dispose();
    }
    const [ledgerKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.ledger);
    ledgerKeyring === null || ledgerKeyring === void 0 ? void 0 : (_ledgerKeyring$destro = ledgerKeyring.destroy) === null || _ledgerKeyring$destro === void 0 ? void 0 : _ledgerKeyring$destro.call(ledgerKeyring);
    if (_mv.isManifestV3) {
      this.clearLoginArtifacts();
    }
    return this.keyringController.setLocked();
  }
  async securityProviderRequest(requestData, methodName) {
    const {
      currentLocale,
      transactionSecurityCheckEnabled
    } = this.preferencesController.store.getState();
    if (transactionSecurityCheckEnabled) {
      const chainId = Number((0, _conversion.hexToDecimal)(this.networkController.store.getState().providerConfig.chainId));
      try {
        const securityProviderResponse = await (0, _securityProviderHelpers.securityProviderCheck)(requestData, methodName, chainId, currentLocale);
        return securityProviderResponse;
      } catch (err) {
        _loglevel.default.error(err.message);
        throw err;
      }
    }
    return null;
  }
}
exports.default = MetamaskController;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\metamask-controller.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\002.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C002.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 2;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      if (versionedData.data.config.provider.type === 'etherscan') {
        versionedData.data.config.provider.type = 'rpc';
        versionedData.data.config.provider.rpcTarget = 'https://rpc.metamask.io/';
      }
    } catch (_) {
      // empty
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\002.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\003.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C003.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 3;
const oldTestRpc = 'https://rawtestrpc.metamask.io/';
const newTestRpc = 'https://testrpc.metamask.io/';
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      if (versionedData.data.config.provider.rpcTarget === oldTestRpc) {
        versionedData.data.config.provider.rpcTarget = newTestRpc;
      }
    } catch (_) {
      // empty
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\003.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\004.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C004.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 4;
var _default = {
  version,
  migrate(versionedData) {
    const safeVersionedData = (0, _lodash.cloneDeep)(versionedData);
    safeVersionedData.meta.version = version;
    try {
      if (safeVersionedData.data.config.provider.type !== 'rpc') {
        return Promise.resolve(safeVersionedData);
      }
      switch (safeVersionedData.data.config.provider.rpcTarget) {
        case 'https://testrpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'testnet'
          };
          break;
        case 'https://rpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'mainnet'
          };
          break;
        // No default
      }
    } catch (_) {
      // empty
    }
    return Promise.resolve(safeVersionedData);
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\004.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\005.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C005.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves state from the flat state trie into KeyringController substate

*/

const version = 5;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = selectSubstateForKeyringController(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #5${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function selectSubstateForKeyringController(state) {
  const {
    config
  } = state;
  const newState = {
    ...state,
    KeyringController: {
      vault: state.vault,
      selectedAccount: config.selectedAccount,
      walletNicknames: state.walletNicknames
    }
  };
  delete newState.vault;
  delete newState.walletNicknames;
  delete newState.config.selectedAccount;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\005.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\006.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C006.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves KeyringController.selectedAddress to PreferencesController.selectedAddress

*/

const version = 6;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = migrateState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function migrateState(state) {
  const keyringSubstate = state.KeyringController;

  // add new state
  const newState = {
    ...state,
    PreferencesController: {
      selectedAddress: keyringSubstate.selectedAccount
    }
  };

  // rm old state
  delete newState.KeyringController.selectedAccount;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\006.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\007.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C007.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the TransactionManager substate

*/

const version = 7;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = {
    ...state,
    TransactionManager: {
      transactions: state.transactions || [],
      gasMultiplier: state.gasMultiplier || 1
    }
  };
  delete newState.transactions;
  delete newState.gasMultiplier;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\007.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\008.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C008.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the NoticeController substate

*/

const version = 8;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = {
    ...state,
    NoticeController: {
      noticesList: state.noticesList || []
    }
  };
  delete newState.noticesList;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\008.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\009.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C009.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the CurrencyController substate

*/

const version = 9;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    CurrencyController: {
      currentCurrency: state.currentFiat || state.fiatCurrency || 'USD',
      conversionRate: state.conversionRate,
      conversionDate: state.conversionDate
    }
  });
  delete newState.currentFiat;
  delete newState.fiatCurrency;
  delete newState.conversionRate;
  delete newState.conversionDate;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\009.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\010.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C010.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the ShapeShiftController substate

*/

const version = 10;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    ShapeShiftController: {
      shapeShiftTxList: state.shapeShiftTxList || []
    }
  });
  delete newState.shapeShiftTxList;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\010.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\011.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C011.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes the discaimer state from our app, which was integrated into our notices.

*/

const version = 11;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  delete newState.TOSHash;
  delete newState.isDisclaimerConfirmed;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\011.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\012.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C012.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration modifies our notices to delete their body after being read.

*/

const version = 12;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  newState.NoticeController.noticesList.forEach(notice => {
    if (notice.read) {
      notice.body = '';
    }
  });
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\012.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\013.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C013.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration modifies the network config from ambiguous 'testnet' to explicit 'ropsten'

*/

const version = 13;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    config
  } = newState;
  if (config && config.provider) {
    if (config.provider.type === 'testnet') {
      newState.config.provider.type = 'ropsten';
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\013.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\014.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C014.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes provider from config and moves it too NetworkController.

*/

const version = 14;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  newState.NetworkController = {};
  newState.NetworkController.provider = newState.config.provider;
  delete newState.config.provider;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\014.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\015.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C015.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/

const version = 15;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      } else if (txMeta.err.message === 'Gave up submitting tx.') {
        txMeta.status = _transaction.TransactionStatus.failed;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\015.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\016.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C016.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/

const version = 16;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      }
      if (txMeta.err === 'transaction with the same hash was already imported.') {
        txMeta.status = _transaction.TransactionStatus.submitted;
        delete txMeta.err;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\016.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\017.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C017.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions who were retried and marked as failed to submitted

*/

const version = 17;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.status === _transaction.TransactionStatus.failed) {
        return txMeta;
      }
      if (txMeta.retryCount > 0 && txMeta.retryCount < 2) {
        txMeta.status = _transaction.TransactionStatus.submitted;
        delete txMeta.err;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\017.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\018.js", {"../controllers/transactions/lib/tx-state-history-helpers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C018.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _txStateHistoryHelpers = require("../controllers/transactions/lib/tx-state-history-helpers");
/*

This migration updates "transaction state history" to diffs style

*/

const version = 18;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      // no history: initialize
      if (!txMeta.history || txMeta.history.length === 0) {
        const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
        txMeta.history = [snapshot];
        return txMeta;
      }
      // has history: migrate
      const newHistory = (0, _txStateHistoryHelpers.migrateFromSnapshotsToDiffs)(txMeta.history)
      // remove empty diffs
      .filter(entry => {
        return !Array.isArray(entry) || entry.length > 0;
      });
      txMeta.history = newHistory;
      return txMeta;
    });
  }
  return newState;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\018.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\019.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C019.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions as failed
whos nonce is too high

*/

const version = 19;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map((txMeta, _, txList) => {
      if (txMeta.status !== _transaction.TransactionStatus.submitted) {
        return txMeta;
      }
      const confirmedTxs = txList.filter(tx => tx.status === _transaction.TransactionStatus.confirmed).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestConfirmedNonce = getHighestNonce(confirmedTxs);
      const pendingTxs = txList.filter(tx => tx.status === _transaction.TransactionStatus.submitted).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestContinuousNonce = getHighestContinuousFrom(pendingTxs, highestConfirmedNonce);
      const maxNonce = Math.max(highestContinuousNonce, highestConfirmedNonce);
      if (parseInt(txMeta.txParams.nonce, 16) > maxNonce + 1) {
        txMeta.status = _transaction.TransactionStatus.failed;
        txMeta.err = {
          message: 'nonce too high',
          note: 'migration 019 custom error'
        };
      }
      return txMeta;
    });
  }
  return newState;
}
function getHighestContinuousFrom(txList, startPoint) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce, 16);
  });
  let highest = startPoint;
  while (nonces.includes(highest)) {
    highest += 1;
  }
  return highest;
}
function getHighestNonce(txList) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce || '0x0', 16);
  });
  const highestNonce = Math.max.apply(null, nonces);
  return highestNonce;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\019.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\020.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C020.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration ensures previous installations
get a `firstTimeInfo` key on the metamask state,
so that we can version notices in the future.

*/

const version = 20;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if ('metamask' in newState && !('firstTimeInfo' in newState.metamask)) {
    newState.metamask.firstTimeInfo = {
      version: '3.12.0',
      date: Date.now()
    };
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\020.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\021.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C021.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes the BlackListController from disk state

*/

const version = 21;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  delete newState.BlacklistController;
  delete newState.RecentBlocks;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\021.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\022.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C022.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration adds submittedTime to the txMeta if it is not their

*/

const version = 22;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (txMeta.status !== _transaction.TransactionStatus.submitted || txMeta.submittedTime) {
        return txMeta;
      }
      txMeta.submittedTime = new Date().getTime();
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\022.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\023.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C023.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration removes transactions that are no longer usefull down to 40 total

*/

const version = 23;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    if (transactions.length <= 40) {
      return newState;
    }
    const reverseTxList = transactions.reverse();
    let stripping = true;
    while (reverseTxList.length > 40 && stripping) {
      const txIndex = reverseTxList.findIndex(txMeta => {
        return txMeta.status === _transaction.TransactionStatus.failed || txMeta.status === _transaction.TransactionStatus.rejected || txMeta.status === _transaction.TransactionStatus.confirmed || txMeta.status === _transaction.TransactionStatus.dropped;
      });
      if (txIndex < 0) {
        stripping = false;
      } else {
        reverseTxList.splice(txIndex, 1);
      }
    }
    newState.TransactionController.transactions = reverseTxList.reverse();
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\023.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\024.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C024.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration ensures that the from address in txParams is to lower case for
all unapproved transactions

*/

const version = 24;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (!newState.TransactionController) {
    return newState;
  }
  const {
    transactions
  } = newState.TransactionController;
  newState.TransactionController.transactions = transactions.map((txMeta, _) => {
    if (txMeta.status === _transaction.TransactionStatus.unapproved && txMeta.txParams && txMeta.txParams.from) {
      txMeta.txParams.from = txMeta.txParams.from.toLowerCase();
    }
    return txMeta;
  });
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\024.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\025.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","../lib/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\util.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C025.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _util = require("../lib/util");
var _transaction = require("../../../shared/constants/transaction");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 25;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.map(txMeta => {
        if (txMeta.status !== _transaction.TransactionStatus.unapproved) {
          return txMeta;
        }
        txMeta.txParams = normalizeTxParams(txMeta.txParams);
        return txMeta;
      });
    }
  }
  return newState;
}
function normalizeTxParams(txParams) {
  // functions that handle normalizing of that key in txParams
  const whiteList = {
    from: from => (0, _util.addHexPrefix)(from).toLowerCase(),
    to: () => (0, _util.addHexPrefix)(txParams.to).toLowerCase(),
    nonce: nonce => (0, _util.addHexPrefix)(nonce),
    value: value => (0, _util.addHexPrefix)(value),
    data: data => (0, _util.addHexPrefix)(data),
    gas: gas => (0, _util.addHexPrefix)(gas),
    gasPrice: gasPrice => (0, _util.addHexPrefix)(gasPrice)
  };

  // apply only keys in the whiteList
  const normalizedTxParams = {};
  Object.keys(whiteList).forEach(key => {
    if (txParams[key]) {
      normalizedTxParams[key] = whiteList[key](txParams[key]);
    }
  });
  return normalizedTxParams;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\025.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\026.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C026.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves the identities stored in the KeyringController
 into the PreferencesController

*/

const version = 26;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      versionedData.data = transformState(state);
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
      return Promise.reject(err);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  if (!state.KeyringController || !state.PreferencesController) {
    return state;
  }
  if (!state.KeyringController.walletNicknames) {
    return state;
  }
  state.PreferencesController.identities = Object.keys(state.KeyringController.walletNicknames).reduce((identities, address) => {
    identities[address] = {
      name: state.KeyringController.walletNicknames[address],
      address
    };
    return identities;
  }, {});
  delete state.KeyringController.walletNicknames;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\026.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\027.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C027.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 27;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.filter(txMeta => txMeta.status !== _transaction.TransactionStatus.rejected);
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\027.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\028.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C028.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 28;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.PreferencesController) {
    if (newState.PreferencesController.tokens && newState.PreferencesController.identities) {
      const {
        identities,
        tokens
      } = newState.PreferencesController;
      newState.PreferencesController.accountTokens = {};
      Object.keys(identities).forEach(identity => {
        newState.PreferencesController.accountTokens[identity] = {
          mainnet: tokens
        };
      });
      newState.PreferencesController.tokens = [];
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\028.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\029.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","./fail-tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\fail-tx.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C029.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _transaction = require("../../../shared/constants/transaction");
var _failTx = _interopRequireDefault(require("./fail-tx"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// next version number

const version = 29;

// time
const seconds = 1000;
const minutes = 60 * seconds;
const hours = 60 * minutes;
const unacceptableDelay = 12 * hours;

/*

normalizes txParams on unconfirmed txs

*/
var _default = {
  version,
  migrate: (0, _failTx.default)(version, 'Stuck in approved state for too long.', txMeta => {
    const isApproved = txMeta.status === _transaction.TransactionStatus.approved;
    const createdTime = txMeta.submittedTime;
    const now = Date.now();
    return isApproved && now - createdTime > unacceptableDelay;
  })
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\029.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\030.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C030.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

removes invalid chaids from preferences and networkController for custom rpcs

*/

const version = 30;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (state.PreferencesController) {
    const {
      frequentRpcListDetail
    } = newState.PreferencesController;
    if (frequentRpcListDetail) {
      frequentRpcListDetail.forEach((rpc, index) => {
        // eslint-disable-next-line radix
        if (Boolean(rpc.chainId) && Number.isNaN(parseInt(rpc.chainId))) {
          delete frequentRpcListDetail[index].chainId;
        }
      });
      newState.PreferencesController.frequentRpcListDetail = frequentRpcListDetail;
    }
  }
  if (state.NetworkController) {
    if (newState.NetworkController.network &&
    // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.network))) {
      delete newState.NetworkController.network;
    }
    if (newState.NetworkController.provider && newState.NetworkController.provider.chainId &&
    // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.provider.chainId))) {
      delete newState.NetworkController.provider.chainId;
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\030.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\031.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C031.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number

const version = 31;

/*
 * The purpose of this migration is to properly set the completedOnboarding flag based on the state
 * of the KeyringController.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    KeyringController,
    PreferencesController
  } = state;
  if (KeyringController && PreferencesController) {
    const {
      vault
    } = KeyringController;
    PreferencesController.completedOnboarding = Boolean(vault);
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\031.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\032.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C032.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 32;

/**
 * The purpose of this migration is to set the {@code completedUiMigration} flag based on the user's UI preferences
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const {
      betaUI
    } = PreferencesController.featureFlags || {};
    // Users who have been using the "beta" UI are considered to have completed the migration
    // as they'll see no difference in this version
    PreferencesController.completedUiMigration = betaUI;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\032.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\033.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C033.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

Cleans up notices and assocated notice controller code

*/

const version = 33;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  // transform state here
  if (state.NoticeController) {
    delete newState.NoticeController;
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\033.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\034.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C034.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 34;

/**
 * The purpose of this migration is to enable the {@code privacyMode} feature flag and set the user as being migrated
 * if it was {@code false}.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};
    if (!featureFlags.privacyMode && typeof PreferencesController.migratedPrivacyMode === 'undefined') {
      // Mark the state has being migrated and enable Privacy Mode
      PreferencesController.migratedPrivacyMode = true;
      featureFlags.privacyMode = true;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\034.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\035.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C035.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

Removes the deprecated 'seedWords' state

*/

const version = 35;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    versionedData.data = transformState(versionedData.data);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.seedWords !== undefined) {
    delete state.PreferencesController.seedWords;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\035.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\036.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C036.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 36;

/**
 * The purpose of this migration is to remove the {@code privacyMode} feature flag.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};
    if (typeof featureFlags.privacyMode !== 'undefined') {
      delete featureFlags.privacyMode;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\036.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\037.js", {"@metamask/controller-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C037.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _controllerUtils = require("@metamask/controller-utils");
const version = 37;

/**
 * The purpose of this migration is to update the address book state
 * to the new schema with chainId as a key.
 * and to add the isEns flag to all entries
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.AddressBookController) {
    const ab = state.AddressBookController.addressBook;
    const chainIds = new Set();
    const newAddressBook = {};

    // add all of the chainIds to a set
    Object.values(ab).forEach(v => {
      chainIds.add(v.chainId);
    });

    // fill the chainId object with the entries with the matching chainId
    for (const id of chainIds.values()) {
      // make an empty object entry for each chainId
      newAddressBook[id] = {};
      for (const address in ab) {
        if (ab[address].chainId === id) {
          ab[address].isEns = false;
          if ((0, _controllerUtils.normalizeEnsName)(ab[address].name)) {
            ab[address].isEns = true;
          }
          newAddressBook[id][address] = ab[address];
        }
      }
    }
    state.AddressBookController.addressBook = newAddressBook;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\037.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\038.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C038.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 38;

/**
 * The purpose of this migration is to assign all users to a test group for the fullScreenVsPopup a/b test
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    ABTestController: ABTestControllerState = {}
  } = state;
  const {
    abTests = {}
  } = ABTestControllerState;
  if (abTests.fullScreenVsPopup) {
    return state;
  }
  return {
    ...state,
    ABTestController: {
      ...ABTestControllerState,
      abTests: {
        ...abTests,
        fullScreenVsPopup: 'control'
      }
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\038.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\039.js", {"../../../shared/modules/hexstring-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\hexstring-utils.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C039.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _hexstringUtils = require("../../../shared/modules/hexstring-utils");
const version = 39;
const DAI_V1_CONTRACT_ADDRESS = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359';
const DAI_V1_TOKEN_SYMBOL = 'DAI';
const SAI_TOKEN_SYMBOL = 'SAI';
function isOldDai(token = {}) {
  return token && typeof token === 'object' && token.symbol === DAI_V1_TOKEN_SYMBOL && (0, _hexstringUtils.toChecksumHexAddress)(token.address) === DAI_V1_CONTRACT_ADDRESS;
}

/**
 * This migration renames the Dai token to Sai.
 *
 * As of 2019-11-18 Dai is now called Sai (refs https://git.io/JeooP) to facilitate
 * Maker's upgrade to Multi-Collateral Dai and this migration renames the token
 * at the old address.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const tokens = PreferencesController.tokens || [];
    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        if (isOldDai(token)) {
          token.symbol = SAI_TOKEN_SYMBOL;
        }
      }
    }
    const accountTokens = PreferencesController.accountTokens || {};
    if (accountTokens && typeof accountTokens === 'object') {
      for (const address of Object.keys(accountTokens)) {
        const networkTokens = accountTokens[address];
        if (networkTokens && typeof networkTokens === 'object') {
          for (const network of Object.keys(networkTokens)) {
            const tokensOnNetwork = networkTokens[network];
            if (Array.isArray(tokensOnNetwork)) {
              for (const token of tokensOnNetwork) {
                if (isOldDai(token)) {
                  token.symbol = SAI_TOKEN_SYMBOL;
                }
              }
            }
          }
        }
      }
    }
  }
  return state;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\039.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\040.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C040.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 40;

/**
 * Site connections are now managed by the PermissionsController, and the
 * ProviderApprovalController is removed. This migration deletes all
 * ProviderApprovalController state.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  delete state.ProviderApprovalController;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\040.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\041.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C041.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 41;

/**
 * PreferencesController.autoLogoutTimeLimit -> autoLockTimeLimit
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.preferences) {
    state.PreferencesController.preferences.autoLockTimeLimit = state.PreferencesController.preferences.autoLogoutTimeLimit;
    delete state.PreferencesController.preferences.autoLogoutTimeLimit;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\041.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\042.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C042.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 42;

/**
 * Initialize `connectedStatusPopoverHasBeenShown` to `false` if it hasn't yet been set,
 * so that existing users are introduced to the new connected status indicator
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.AppStateController) {
    state.AppStateController.connectedStatusPopoverHasBeenShown = false;
  } else {
    state.AppStateController = {
      connectedStatusPopoverHasBeenShown: false
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\042.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\043.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C043.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 43;

/**
 * Remove unused 'currentAccountTab' state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  if (state !== null && state !== void 0 && (_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.currentAccountTab) {
    delete state.PreferencesController.currentAccountTab;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\043.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\044.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C044.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 44;

/**
 * Remove unused 'mkrMigrationReminderTimestamp' state from the `AppStateController`
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro;
  if (typeof (state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.mkrMigrationReminderTimestamp) !== 'undefined') {
    delete state.AppStateController.mkrMigrationReminderTimestamp;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\044.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\045.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C045.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 45;

/**
 * Replaces {@code PreferencesController.ipfsGateway} with 'dweb.link' if set
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const outdatedGateways = ['ipfs.io', 'ipfs.dweb.link'];
function transformState(state) {
  var _state$PreferencesCon;
  if (outdatedGateways.includes(state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.ipfsGateway)) {
    state.PreferencesController.ipfsGateway = 'dweb.link';
  }
  return state;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\045.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\046.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C046.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 46;

/**
 * Delete {@code ABTestController} state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (typeof (state === null || state === void 0 ? void 0 : state.ABTestController) !== 'undefined') {
    delete state.ABTestController;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\046.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\047.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C047.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 47;

/**
 * Stringify the `metamaskNetworkId` property of all transactions
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (typeof transaction.metamaskNetworkId === 'number') {
        transaction.metamaskNetworkId = transaction.metamaskNetworkId.toString();
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\047.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\048.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C048.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 48;

/**
 * 1.  Delete NetworkController.settings
 * 2a. Migrate NetworkController.provider to Rinkeby if set to type 'rpc' or
 *     'localhost'.
 * 2b. Re-key provider.rpcTarget to provider.rpcUrl
 * 3.  Add localhost network to frequentRpcListDetail.
 * 4.  Delete CachedBalancesController.cachedBalances
 * 5.  Convert transactions metamaskNetworkId to decimal if they are hex
 * 6.  Convert address book keys from decimal to hex
 * 7.  Delete localhost key in IncomingTransactionsController
 * 8.  Merge 'localhost' tokens into 'rpc' tokens
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const hexRegEx = /^0x[0-9a-f]+$/iu;
const chainIdRegEx = /^0x[1-9a-f]+[0-9a-f]*$/iu;
function transformState(state = {}) {
  var _state$NetworkControl, _state$NetworkControl2, _state$NetworkControl3, _state$CachedBalances, _state$TransactionCon, _state$AddressBookCon, _state$IncomingTransa, _state$IncomingTransa2, _state$PreferencesCon;
  // 1. Delete NetworkController.settings
  (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? true : delete _state$NetworkControl.settings;

  // 2. Migrate NetworkController.provider to Rinkeby or rename rpcTarget key
  const provider = ((_state$NetworkControl2 = state.NetworkController) === null || _state$NetworkControl2 === void 0 ? void 0 : _state$NetworkControl2.provider) || {};
  const isCustomRpcWithInvalidChainId = provider.type === 'rpc' && (typeof provider.chainId !== 'string' || !chainIdRegEx.test(provider.chainId));
  if (isCustomRpcWithInvalidChainId || provider.type === 'localhost') {
    state.NetworkController.provider = {
      type: 'rinkeby',
      rpcUrl: '',
      chainId: '0x4',
      nickname: '',
      rpcPrefs: {},
      ticker: 'ETH'
    };
  } else if ((_state$NetworkControl3 = state.NetworkController) !== null && _state$NetworkControl3 !== void 0 && _state$NetworkControl3.provider) {
    var _state$NetworkControl4, _state$NetworkControl5;
    if ('rpcTarget' in state.NetworkController.provider) {
      const rpcUrl = state.NetworkController.provider.rpcTarget;
      state.NetworkController.provider.rpcUrl = rpcUrl;
    }
    (_state$NetworkControl4 = state.NetworkController) === null || _state$NetworkControl4 === void 0 ? true : (_state$NetworkControl5 = _state$NetworkControl4.provider) === null || _state$NetworkControl5 === void 0 ? true : delete _state$NetworkControl5.rpcTarget;
  }

  // 3.  Add localhost network to frequentRpcListDetail.
  if (!state.PreferencesController) {
    state.PreferencesController = {};
  }
  if (!state.PreferencesController.frequentRpcListDetail) {
    state.PreferencesController.frequentRpcListDetail = [];
  }
  state.PreferencesController.frequentRpcListDetail.unshift({
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    ticker: 'ETH',
    nickname: 'Localhost 8545',
    rpcPrefs: {}
  });

  // 4.  Delete CachedBalancesController.cachedBalances
  (_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? true : delete _state$CachedBalances.cachedBalances;

  // 5.  Convert transactions metamaskNetworkId to decimal if they are hex
  const transactions = (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      const metamaskNetworkId = transaction === null || transaction === void 0 ? void 0 : transaction.metamaskNetworkId;
      if (typeof metamaskNetworkId === 'string' && hexRegEx.test(metamaskNetworkId)) {
        transaction.metamaskNetworkId = parseInt(metamaskNetworkId, 16).toString(10);
      }
    });
  }

  // 6.  Convert address book keys from decimal to hex
  const addressBook = ((_state$AddressBookCon = state.AddressBookController) === null || _state$AddressBookCon === void 0 ? void 0 : _state$AddressBookCon.addressBook) || {};
  Object.keys(addressBook).forEach(networkKey => {
    if (/^\d+$/iu.test(networkKey)) {
      const chainId = `0x${parseInt(networkKey, 10).toString(16)}`;
      updateChainIds(addressBook[networkKey], chainId);
      if (addressBook[chainId]) {
        mergeAddressBookKeys(addressBook, networkKey, chainId);
      } else {
        addressBook[chainId] = addressBook[networkKey];
      }
      delete addressBook[networkKey];
    }
  });

  // 7.  Delete localhost key in IncomingTransactionsController
  (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? true : (_state$IncomingTransa2 = _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) === null || _state$IncomingTransa2 === void 0 ? true : delete _state$IncomingTransa2.localhost;

  // 8.  Merge 'localhost' tokens into 'rpc' tokens
  const accountTokens = (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  if (accountTokens) {
    Object.keys(accountTokens).forEach(account => {
      var _accountTokens$accoun, _accountTokens$accoun2;
      const localhostTokens = ((_accountTokens$accoun = accountTokens[account]) === null || _accountTokens$accoun === void 0 ? void 0 : _accountTokens$accoun.localhost) || [];
      if (localhostTokens.length > 0) {
        const rpcTokens = accountTokens[account].rpc || [];
        if (rpcTokens.length > 0) {
          accountTokens[account].rpc = mergeTokenArrays(localhostTokens, rpcTokens);
        } else {
          accountTokens[account].rpc = localhostTokens;
        }
      }
      (_accountTokens$accoun2 = accountTokens[account]) === null || _accountTokens$accoun2 === void 0 ? true : delete _accountTokens$accoun2.localhost;
    });
  }
  return state;
}

/**
 * Merges the two given keys for the given address book in place.
 *
 * @param addressBook
 * @param networkKey
 * @param chainIdKey
 */
function mergeAddressBookKeys(addressBook, networkKey, chainIdKey) {
  const networkKeyEntries = addressBook[networkKey] || {};
  // For the new entries, start by copying the existing entries for the chainId
  const newEntries = {
    ...addressBook[chainIdKey]
  };

  // For each address of the old/networkId key entries
  Object.keys(networkKeyEntries).forEach(address => {
    if (newEntries[address] && typeof newEntries[address] === 'object') {
      const mergedEntry = {};

      // Collect all keys from both entries and merge the corresponding chainId
      // entry with the networkId entry
      new Set([...Object.keys(newEntries[address]), ...Object.keys(networkKeyEntries[address] || {})]).forEach(key => {
        var _networkKeyEntries$ad;
        // Use non-empty value for the current key, if any
        mergedEntry[key] = newEntries[address][key] || ((_networkKeyEntries$ad = networkKeyEntries[address]) === null || _networkKeyEntries$ad === void 0 ? void 0 : _networkKeyEntries$ad[key]) || '';
      });
      newEntries[address] = mergedEntry;
    } else if (networkKeyEntries[address] && typeof networkKeyEntries[address] === 'object') {
      // If there is no corresponding chainId entry, just use the networkId entry
      // directly
      newEntries[address] = networkKeyEntries[address];
    }
  });
  addressBook[chainIdKey] = newEntries;
}

/**
 * Updates the chainId key values to the given chainId in place for all values
 * of the given networkEntries object.
 *
 * @param networkEntries
 * @param chainId
 */
function updateChainIds(networkEntries, chainId) {
  Object.values(networkEntries).forEach(entry => {
    if (entry && typeof entry === 'object') {
      entry.chainId = chainId;
    }
  });
}

/**
 * Merges the two given, non-empty arrays of token objects and returns a new
 * array.
 *
 * @param localhostTokens
 * @param rpcTokens
 * @returns {Array<object>}
 */
function mergeTokenArrays(localhostTokens, rpcTokens) {
  const localhostTokensMap = tokenArrayToMap(localhostTokens);
  const rpcTokensMap = tokenArrayToMap(rpcTokens);
  const mergedTokens = [];
  new Set([...Object.keys(localhostTokensMap), ...Object.keys(rpcTokensMap)]).forEach(tokenAddress => {
    mergedTokens.push({
      ...localhostTokensMap[tokenAddress],
      ...rpcTokensMap[tokenAddress]
    });
  });
  return mergedTokens;
  function tokenArrayToMap(array) {
    return array.reduce((map, token) => {
      if (token !== null && token !== void 0 && token.address && typeof (token === null || token === void 0 ? void 0 : token.address) === 'string') {
        map[token.address] = token;
      }
      return map;
    }, {});
  }
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\048.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\049.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C049.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 49;

/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      metaMetricsId,
      participateInMetaMetrics,
      metaMetricsSendCount
    } = state.PreferencesController;
    state.MetaMetricsController = state.MetaMetricsController ?? {};
    if (metaMetricsId !== undefined) {
      state.MetaMetricsController.metaMetricsId = metaMetricsId;
      delete state.PreferencesController.metaMetricsId;
    }
    if (participateInMetaMetrics !== undefined) {
      state.MetaMetricsController.participateInMetaMetrics = participateInMetaMetrics;
      delete state.PreferencesController.participateInMetaMetrics;
    }
    if (metaMetricsSendCount !== undefined) {
      state.MetaMetricsController.metaMetricsSendCount = metaMetricsSendCount;
      delete state.PreferencesController.metaMetricsSendCount;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\049.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\050.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C050.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 50;
const LEGACY_LOCAL_STORAGE_KEYS = ['METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED', 'METASWAP_GAS_PRICE_ESTIMATES', 'cachedFetch', 'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED', 'BASIC_PRICE_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES'];

/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    LEGACY_LOCAL_STORAGE_KEYS.forEach(key => {
      var _window$localStorage;
      return (_window$localStorage = window.localStorage) === null || _window$localStorage === void 0 ? void 0 : _window$localStorage.removeItem(key);
    });
    return versionedData;
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\050.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\051.js", {"../../../shared/constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C051.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 51;

/**
 * Set the chainId in the Network Controller provider data for all infura networks
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$NetworkControl, _BUILT_IN_NETWORKS$ty;
  const {
    chainId,
    type
  } = (state === null || state === void 0 ? void 0 : (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const enumChainId = (_BUILT_IN_NETWORKS$ty = _network.BUILT_IN_NETWORKS[type]) === null || _BUILT_IN_NETWORKS$ty === void 0 ? void 0 : _BUILT_IN_NETWORKS$ty.chainId;
  if (enumChainId && chainId !== enumChainId) {
    state.NetworkController.provider.chainId = enumChainId;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\051.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\052.js", {"../../../shared/constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C052.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 52;

/**
 * Migrate tokens in Preferences to be keyed by chainId instead of
 * providerType. To prevent breaking user's MetaMask and selected
 * tokens, this migration copies the RPC entry into *every* custom RPC
 * chainId.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      accountTokens,
      accountHiddenTokens,
      frequentRpcListDetail
    } = state.PreferencesController;
    const newAccountTokens = {};
    const newAccountHiddenTokens = {};
    if (accountTokens && Object.keys(accountTokens).length > 0) {
      for (const address of Object.keys(accountTokens)) {
        newAccountTokens[address] = {};
        if (accountTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountTokens[address][detail.chainId] = accountTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }
        for (const providerType of Object.keys(accountTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountTokens[address][_network.CHAIN_IDS.MAINNET] = accountTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;
            case 'ropsten':
              newAccountTokens[address]['0x3'] = accountTokens[address].ropsten;
              break;
            case 'rinkeby':
              newAccountTokens[address]['0x4'] = accountTokens[address].rinkeby;
              break;
            case _network.NETWORK_TYPES.GOERLI:
              newAccountTokens[address][_network.CHAIN_IDS.GOERLI] = accountTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;
            case 'kovan':
              newAccountTokens[address]['0x2a'] = accountTokens[address].kovan;
              break;
            default:
              break;
          }
        }
      }
      state.PreferencesController.accountTokens = newAccountTokens;
    }
    if (accountHiddenTokens && Object.keys(accountHiddenTokens).length > 0) {
      for (const address of Object.keys(accountHiddenTokens)) {
        newAccountHiddenTokens[address] = {};
        if (accountHiddenTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountHiddenTokens[address][detail.chainId] = accountHiddenTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }
        for (const providerType of Object.keys(accountHiddenTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.MAINNET] = accountHiddenTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;
            case 'ropsten':
              newAccountHiddenTokens[address]['0x3'] = accountHiddenTokens[address].ropsten;
              break;
            case 'rinkeby':
              newAccountHiddenTokens[address]['0x4'] = accountHiddenTokens[address].rinkeby;
              break;
            case _network.NETWORK_TYPES.GOERLI:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.GOERLI] = accountHiddenTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;
            case 'kovan':
              newAccountHiddenTokens[address]['0x2a'] = accountHiddenTokens[address].kovan;
              break;
            default:
              break;
          }
        }
      }
      state.PreferencesController.accountHiddenTokens = newAccountHiddenTokens;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\052.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\053.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C053.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 53;

/**
 * Deprecate transactionCategory and consolidate on 'type'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$IncomingTransa;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  const incomingTransactions = state === null || state === void 0 ? void 0 : (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? void 0 : _state$IncomingTransa.incomingTransactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (transaction) {
        if (transaction.type !== _transaction.TransactionType.retry && transaction.type !== _transaction.TransactionType.cancel) {
          transaction.type = transaction.transactionCategory;
        }
        delete transaction.transactionCategory;
      }
    });
  }
  if (incomingTransactions) {
    const incomingTransactionsEntries = Object.entries(incomingTransactions);
    incomingTransactionsEntries.forEach(([key, transaction]) => {
      if (transaction) {
        delete transaction.transactionCategory;
        state.IncomingTransactionsController.incomingTransactions[key] = {
          ...transaction,
          type: _transaction.TransactionType.incoming
        };
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\053.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\054.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C054.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 54;
function isValidDecimals(decimals) {
  return typeof decimals === 'number' || typeof decimals === 'string' && decimals.match(/^(0x)?\d+$/u);
}

/**
 * Migrates preference tokens with decimals typed as string to number.
 * It also removes any tokens with corrupted or inconvertible decimal values.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (!newState.PreferencesController) {
    return newState;
  }
  const tokens = newState.PreferencesController.tokens || [];
  // Filter out any tokens with corrupted decimal values
  const validTokens = tokens.filter(({
    decimals
  }) => isValidDecimals(decimals));
  for (const token of validTokens) {
    // In the case of a decimal value type string, convert to a number.
    if (typeof token.decimals === 'string') {
      // eslint-disable-next-line radix
      token.decimals = parseInt(token.decimals);
    }
  }
  newState.PreferencesController.tokens = validTokens;
  const {
    accountTokens
  } = newState.PreferencesController;
  if (accountTokens && typeof accountTokens === 'object') {
    for (const address of Object.keys(accountTokens)) {
      const networkTokens = accountTokens[address];
      if (networkTokens && typeof networkTokens === 'object') {
        for (const network of Object.keys(networkTokens)) {
          const tokensOnNetwork = networkTokens[network] || [];
          // Filter out any tokens with corrupted decimal values
          const validTokensOnNetwork = tokensOnNetwork.filter(({
            decimals
          }) => isValidDecimals(decimals));
          // In the case of a decimal value type string, convert to a number.
          for (const token of validTokensOnNetwork) {
            if (typeof token.decimals === 'string') {
              // eslint-disable-next-line radix
              token.decimals = parseInt(token.decimals);
            }
          }
          networkTokens[network] = validTokensOnNetwork;
        }
      }
    }
  }
  newState.PreferencesController.accountTokens = accountTokens;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\054.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\055.js", {"../../../shared/constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C055.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 55;

/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const UNKNOWN_CHAIN_ID_KEY = 'UNKNOWN';
_network.BUILT_IN_NETWORKS.rinkeby = {
  networkId: '4',
  chainId: '0x4',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.ropsten = {
  networkId: '3',
  chainId: '0x3',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.kovan = {
  networkId: '42',
  chainId: '0x2a',
  ticker: 'ETH'
};
function transformState(state) {
  var _state$IncomingTransa;
  if (state !== null && state !== void 0 && (_state$IncomingTransa = state.IncomingTransactionsController) !== null && _state$IncomingTransa !== void 0 && _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) {
    state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId = (0, _lodash.mapKeys)(state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork,
    // using optional chaining in case user's state has fetched blocks for
    // RPC network types (which don't map to a single chainId). This should
    // not be possible, but it's safer
    (_, key) => {
      var _BUILT_IN_NETWORKS$ke;
      return ((_BUILT_IN_NETWORKS$ke = _network.BUILT_IN_NETWORKS[key]) === null || _BUILT_IN_NETWORKS$ke === void 0 ? void 0 : _BUILT_IN_NETWORKS$ke.chainId) ?? UNKNOWN_CHAIN_ID_KEY;
    });
    // Now that mainnet and test net last fetched blocks are keyed by their
    // respective chainIds, we can safely delete anything we had for custom
    // networks. Any custom network that shares a chainId with one of the
    // aforementioned networks will use the value stored by chainId.
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId[UNKNOWN_CHAIN_ID_KEY];
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\055.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\056.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C056.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 56;

/**
 * Remove tokens that don't have an address due to
 * lack of previous addToken validation.  Also removes
 * an unwanted, undefined image property
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const {
      PreferencesController
    } = versionedData.data;
    if (Array.isArray(PreferencesController === null || PreferencesController === void 0 ? void 0 : PreferencesController.tokens)) {
      PreferencesController.tokens = PreferencesController.tokens.filter(({
        address
      }) => address);
    }
    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.accountTokens && typeof PreferencesController.accountTokens === 'object') {
      Object.keys(PreferencesController.accountTokens).forEach(account => {
        const chains = Object.keys(PreferencesController.accountTokens[account]);
        chains.forEach(chain => {
          PreferencesController.accountTokens[account][chain] = PreferencesController.accountTokens[account][chain].filter(({
            address
          }) => address);
        });
      });
    }
    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.assetImages && 'undefined' in PreferencesController.assetImages) {
      delete PreferencesController.assetImages.undefined;
    }
    return versionedData;
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\056.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\057.js", {"../../../shared/modules/random-id":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\random-id.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C057.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const version = 57;

/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  if (state !== null && state !== void 0 && (_state$TransactionCon = state.TransactionController) !== null && _state$TransactionCon !== void 0 && _state$TransactionCon.transactions && Array.isArray(state.TransactionController.transactions) && !state.TransactionController.transactions.some(item => typeof item !== 'object' || typeof item.txParams === 'undefined')) {
    state.TransactionController.transactions = (0, _lodash.keyBy)(state.TransactionController.transactions,
    // In case for some reason any of a user's transactions do not have an id
    // generate a new one for the transaction.
    tx => {
      if (typeof tx.id === 'undefined' || tx.id === null) {
        // This mutates the item in the array, so will result in a change to
        // the state.
        tx.id = (0, _randomId.default)();
      }
      return tx.id;
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\057.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\058.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C058.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 58;

/**
 * Deletes the swapsWelcomeMessageHasBeenShown property from state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro;
  (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? true : delete _state$AppStateContro.swapsWelcomeMessageHasBeenShown;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\058.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\059.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C059.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 59;

/**
 * Removes orphaned cancel and retry transactions that no longer have the
 * original transaction in state, which results in bugs.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if ((0, _lodash.isPlainObject)(transactions)) {
    const nonceNetworkGroupedObject = (0, _lodash.groupBy)(Object.values(transactions), tx => {
      var _tx$txParams;
      return `${(_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : _tx$txParams.nonce}-${tx.chainId ?? tx.metamaskNetworkId}`;
    });
    const withoutOrphans = (0, _lodash.pickBy)(nonceNetworkGroupedObject, group => {
      return group.some(tx => tx.type !== _transaction.TransactionType.cancel && tx.type !== _transaction.TransactionType.retry);
    });
    state.TransactionController.transactions = (0, _lodash.keyBy)((0, _lodash.concat)(...Object.values(withoutOrphans)), tx => tx.id);
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\059.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\060.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C060.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 60;
const SUPPORT_NOTIFICATION_KEY = 2;
const SUPPORT_NOTIFICATION_DATE = '2020-08-31';

/**
 * Removes the support survey notification
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$NotificationCo;
  const notifications = state === null || state === void 0 ? void 0 : (_state$NotificationCo = state.NotificationController) === null || _state$NotificationCo === void 0 ? void 0 : _state$NotificationCo.notifications;
  if ((0, _lodash.isPlainObject)(notifications)) {
    var _notifications$SUPPOR;
    if (((_notifications$SUPPOR = notifications[SUPPORT_NOTIFICATION_KEY]) === null || _notifications$SUPPOR === void 0 ? void 0 : _notifications$SUPPOR.date) === SUPPORT_NOTIFICATION_DATE) {
      delete state.NotificationController.notifications[SUPPORT_NOTIFICATION_KEY];
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\060.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\061.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C061.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 61;

/**
 * Initialize attributes related to recovery seed phrase reminder
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const currentTime = new Date().getTime();
  if (state.AppStateController) {
    state.AppStateController.recoveryPhraseReminderHasBeenShown = false;
    state.AppStateController.recoveryPhraseReminderLastShown = currentTime;
  } else {
    state.AppStateController = {
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: currentTime
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\061.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\062.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C062.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 62;

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.MetaMetricsController) {
    const {
      metaMetricsSendCount
    } = state.MetaMetricsController;
    if (metaMetricsSendCount !== undefined) {
      delete state.MetaMetricsController.metaMetricsSendCount;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\062.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\063.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C063.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 63;

/**
 * Moves token state from preferences controller to TokensController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon, _state$PreferencesCon2, _state$PreferencesCon3, _state$PreferencesCon4, _state$PreferencesCon5, _state$PreferencesCon6, _state$PreferencesCon7, _state$PreferencesCon8;
  const accountTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  const accountHiddenTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon2 = state.PreferencesController) === null || _state$PreferencesCon2 === void 0 ? void 0 : _state$PreferencesCon2.accountHiddenTokens;
  const newAllTokens = {};
  if (accountTokens) {
    Object.keys(accountTokens).forEach(accountAddress => {
      Object.keys(accountTokens[accountAddress]).forEach(chainId => {
        const tokensArray = accountTokens[accountAddress][chainId];
        if (newAllTokens[chainId] === undefined) {
          newAllTokens[chainId] = {
            [accountAddress]: tokensArray
          };
        } else {
          newAllTokens[chainId] = {
            ...newAllTokens[chainId],
            [accountAddress]: tokensArray
          };
        }
      });
    });
  }
  const newAllIgnoredTokens = {};
  if (accountHiddenTokens) {
    Object.keys(accountHiddenTokens).forEach(accountAddress => {
      Object.keys(accountHiddenTokens[accountAddress]).forEach(chainId => {
        const ignoredTokensArray = accountHiddenTokens[accountAddress][chainId];
        if (newAllIgnoredTokens[chainId] === undefined) {
          newAllIgnoredTokens[chainId] = {
            [accountAddress]: ignoredTokensArray
          };
        } else {
          newAllIgnoredTokens[chainId] = {
            ...newAllIgnoredTokens[chainId],
            [accountAddress]: ignoredTokensArray
          };
        }
      });
    });
  }
  if (state.TokensController) {
    state.TokensController.allTokens = newAllTokens;
    state.TokensController.allIgnoredTokens = newAllIgnoredTokens;
  } else {
    state.TokensController = {
      allTokens: newAllTokens,
      allIgnoredTokens: newAllIgnoredTokens
    };
  }
  state === null || state === void 0 ? true : (_state$PreferencesCon3 = state.PreferencesController) === null || _state$PreferencesCon3 === void 0 ? true : delete _state$PreferencesCon3.accountHiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon4 = state.PreferencesController) === null || _state$PreferencesCon4 === void 0 ? true : delete _state$PreferencesCon4.accountTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon5 = state.PreferencesController) === null || _state$PreferencesCon5 === void 0 ? true : delete _state$PreferencesCon5.assetImages;
  state === null || state === void 0 ? true : (_state$PreferencesCon6 = state.PreferencesController) === null || _state$PreferencesCon6 === void 0 ? true : delete _state$PreferencesCon6.hiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon7 = state.PreferencesController) === null || _state$PreferencesCon7 === void 0 ? true : delete _state$PreferencesCon7.tokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon8 = state.PreferencesController) === null || _state$PreferencesCon8 === void 0 ? true : delete _state$PreferencesCon8.suggestedTokens;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\063.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\064.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C064.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 64;
const SENT_ETHER = 'sentEther'; // the legacy transaction type being replaced in this migration with TransactionType.simpleSend

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if ((0, _lodash.isPlainObject)(transactions)) {
    for (const tx of Object.values(transactions)) {
      if (tx.type === SENT_ETHER) {
        tx.type = _transaction.TransactionType.simpleSend;
      }
      if (tx.history) {
        tx.history.map(txEvent => {
          if (txEvent.type && txEvent.type === SENT_ETHER) {
            txEvent.type = _transaction.TransactionType.simpleSend;
          }
          return txEvent;
        });
      }
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\064.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\065.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C065.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 65;

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController) {
    const {
      completedOnboarding,
      firstTimeFlowType
    } = state.PreferencesController;
    state.OnboardingController = state.OnboardingController ?? {};
    if (completedOnboarding !== undefined) {
      state.OnboardingController.completedOnboarding = completedOnboarding;
      delete state.PreferencesController.completedOnboarding;
    }
    if (firstTimeFlowType !== undefined) {
      state.OnboardingController.firstTimeFlowType = firstTimeFlowType;
      delete state.PreferencesController.firstTimeFlowType;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\065.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\066.js", {"../../../shared/constants/hardware-wallets":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\hardware-wallets.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C066.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _hardwareWallets = require("../../../shared/constants/hardware-wallets");
const version = 66;

/**
 * Changes the useLedgerLive boolean property to the ledgerTransportType enum
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  const defaultTransportType = window.navigator.hid ? _hardwareWallets.LedgerTransportTypes.webhid : _hardwareWallets.LedgerTransportTypes.u2f;
  const useLedgerLive = Boolean((_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.useLedgerLive);
  const newState = {
    ...state,
    PreferencesController: {
      ...(state === null || state === void 0 ? void 0 : state.PreferencesController),
      ledgerTransportType: useLedgerLive ? _hardwareWallets.LedgerTransportTypes.live : defaultTransportType
    }
  };
  delete newState.PreferencesController.useLedgerLive;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\066.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\067.js", {"../../../shared/constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C067.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _network = require("../../../shared/constants/network");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);
const version = 67;

/**
 * Sets the showTestNetworks property to true if it was false or undefined, and there is evidence
 * that the user has used a test net
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$NetworkControl, _state$CachedBalances;
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};
  if (preferences.showTestNetworks) {
    return state;
  }
  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const provider = ((_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};
  const userIsCurrentlyOnATestNet = _network.TEST_CHAINS.includes(provider === null || provider === void 0 ? void 0 : provider.chainId);
  const userHasMadeATestNetTransaction = Object.values(transactions).some(({
    chainId
  }) => _network.TEST_CHAINS.includes(chainId));
  const userHasACachedBalanceOnATestnet = _network.TEST_CHAINS.some(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });
  const userHasUsedATestnet = userIsCurrentlyOnATestNet || userHasMadeATestNetTransaction || userHasACachedBalanceOnATestnet;
  const newState = {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      preferences: {
        ...preferences,
        showTestNetworks: userHasUsedATestnet
      }
    }
  };
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\067.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\068.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C068.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 68;

/**
 * Transforms the PermissionsController and PermissionsMetadata substates
 * to match the new permission system.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PermissionsController = {},
    PermissionsMetadata = {},
    ...remainingState
  } = state;
  const {
    domainMetadata = {},
    permissionsHistory = {},
    permissionsLog = []
  } = PermissionsMetadata;
  return {
    ...remainingState,
    PermissionController: getPermissionControllerState(PermissionsController),
    PermissionLogController: {
      permissionActivityLog: permissionsLog,
      permissionHistory: permissionsHistory
    },
    SubjectMetadataController: getSubjectMetadataControllerState(domainMetadata)
  };
}
function getPermissionControllerState(PermissionsController) {
  const {
    domains = {}
  } = PermissionsController;

  /**
   * Example existing domain entry. Every existing domain will have a single
   * eth_accounts permission, which simplifies the transform.
   *
   * 'https://metamask.github.io': {
   *   permissions: [
   *     {
   *       '@context': ['https://github.com/MetaMask/rpc-cap'],
   *       'caveats': [
   *         {
   *           name: 'primaryAccountOnly',
   *           type: 'limitResponseLength',
   *           value: 1,
   *         },
   *         {
   *           name: 'exposedAccounts',
   *           type: 'filterResponse',
   *           value: ['0x0c97a5c81e50a02ff8be73cc3f0a0569e61f4ed8'],
   *         },
   *       ],
   *       'date': 1616006369498,
   *       'id': '3d0bdc27-e8e4-4fb0-a24b-340d61f6a3fa',
   *       'invoker': 'https://metamask.github.io',
   *       'parentCapability': 'eth_accounts',
   *     },
   *   ],
   * },
   */

  const ETH_ACCOUNTS = 'eth_accounts';
  const NEW_CAVEAT_TYPE = 'restrictReturnedAccounts';
  const OLD_CAVEAT_NAME = 'exposedAccounts';
  const subjects = Object.entries(domains).reduce((transformed, [origin, domainEntry]) => {
    const {
      permissions: [ethAccountsPermission]
    } = domainEntry;

    // There are two caveats for each eth_accounts permission, but we only
    // need the value of one of them in the new permission system.
    const oldCaveat = ethAccountsPermission.caveats.find(caveat => caveat.name === OLD_CAVEAT_NAME);
    const newPermission = {
      ...ethAccountsPermission,
      caveats: [{
        type: NEW_CAVEAT_TYPE,
        value: oldCaveat.value
      }]
    };

    // We never used this, and just omit it in the new system.
    delete newPermission['@context'];
    transformed[origin] = {
      origin,
      permissions: {
        [ETH_ACCOUNTS]: newPermission
      }
    };
    return transformed;
  }, {});
  return {
    subjects
  };
}
function getSubjectMetadataControllerState(domainMetadata) {
  /**
   * Example existing domainMetadata entry.
   *
   * "https://www.youtube.com": {
   *   "host": "www.youtube.com",
   *   "icon": null,
   *   "lastUpdated": 1637697914908,
   *   "name": "YouTube"
   * }
   */

  const subjectMetadata = Object.entries(domainMetadata).reduce((transformed, [origin, metadata]) => {
    const {
      name = null,
      icon = null,
      extensionId = null,
      ...other
    } = metadata;

    // We're getting rid of these.
    delete other.lastUpdated;
    delete other.host;
    if (origin) {
      transformed[origin] = {
        name,
        iconUrl: icon,
        extensionId,
        ...other,
        origin
      };
    }
    return transformed;
  }, {});
  return {
    subjectMetadata
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\068.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\069.js", {"@metamask/subject-metadata-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\subject-metadata-controller\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C069.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _subjectMetadataController = require("@metamask/subject-metadata-controller");
var _lodash = require("lodash");
const version = 69;

/**
 * Adds the `subjectType` property to all subject metadata.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$SubjectMetadat;
  if (typeof (state === null || state === void 0 ? void 0 : (_state$SubjectMetadat = state.SubjectMetadataController) === null || _state$SubjectMetadat === void 0 ? void 0 : _state$SubjectMetadat.subjectMetadata) === 'object') {
    const {
      SubjectMetadataController: {
        subjectMetadata
      }
    } = state;

    // mutate SubjectMetadataController.subjectMetadata in place
    Object.values(subjectMetadata).forEach(metadata => {
      if (metadata && typeof metadata === 'object' && !Array.isArray(metadata)) {
        metadata.subjectType = metadata.extensionId ? _subjectMetadataController.SubjectType.Extension : _subjectMetadataController.SubjectType.Website;
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\069.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\070.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C070.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 70;

/**
 * Removes the `request` and `response` properties from
 * `PermissionLogController.permissionActivityLog` objects.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PermissionLogC;
  if (Array.isArray(state === null || state === void 0 ? void 0 : (_state$PermissionLogC = state.PermissionLogController) === null || _state$PermissionLogC === void 0 ? void 0 : _state$PermissionLogC.permissionActivityLog)) {
    const {
      PermissionLogController: {
        permissionActivityLog
      }
    } = state;

    // mutate activity log entries in place
    permissionActivityLog.forEach(logEntry => {
      if (logEntry && typeof logEntry === 'object' && !Array.isArray(logEntry)) {
        delete logEntry.request;
        delete logEntry.response;
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\070.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\071.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C071.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 71;

/**
 * Renames NotificationController to AnnouncementController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.NotificationController) {
    state.AnnouncementController = {
      announcements: state.NotificationController.notifications
    };
    delete state.NotificationController;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\071.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\072.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C072.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 72;

/**
 * Should empty the `knownMethodData` object in PreferencesController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\072.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\073.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C073.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 73;

/**
 * Should empty the `knownMethodData` object in PreferencesController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\073.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\074.js", {"../../../shared/constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C074.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _network = require("../../../shared/constants/network");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const version = 74;
const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);
const DEPRECATED_TEST_NET_CHAINIDS = ['0x3', '0x2a', '0x4'];
const DEPRECATED_TEST_NET_DETAILS = {
  '0x3': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'ropsten'
    }),
    nickname: 'Ropsten',
    ticker: 'RopstenETH'
  },
  '0x2a': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'kovan'
    }),
    nickname: 'Kovan',
    ticker: 'KovanETH'
  },
  '0x4': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'rinkeby'
    }),
    nickname: 'Rinkeby',
    ticker: 'RinkebyETH'
  }
};

/**
 * Migrates the user default but deprecated testnet networks to custom networks, and
 * if the current network is one such network, updates the network provider details so that it
 * will work as a custom rpc
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$CachedBalances;
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};
  const NetworkController = (state === null || state === void 0 ? void 0 : state.NetworkController) || {};
  const provider = (NetworkController === null || NetworkController === void 0 ? void 0 : NetworkController.provider) || {};
  const currentlyOnDeprecatedNetwork = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => chainId === (provider === null || provider === void 0 ? void 0 : provider.chainId));

  // If the user does not want to see test networks, and if the the user is not on a deprecated test network, then
  // no need to migrate the test network data to a custom network
  if (!preferences.showTestNetworks && currentlyOnDeprecatedNetwork.length === 0) {
    return state;
  }
  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};
  const deprecatedTestnetsOnWhichTheUserHasMadeATransaction = Object.values(transactions).filter(({
    chainId
  }) => DEPRECATED_TEST_NET_CHAINIDS.includes(chainId)).map(({
    chainId
  }) => chainId);
  const deprecatedTestnetsOnWhichTheUserHasCachedBalance = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });
  const deprecatedTestnetsThatHaveBeenUsed = (0, _lodash.uniq)([...deprecatedTestnetsOnWhichTheUserHasCachedBalance, ...deprecatedTestnetsOnWhichTheUserHasMadeATransaction, ...currentlyOnDeprecatedNetwork]);
  const newFrequentRpcListDetail = PreferencesController.frequentRpcListDetail ?? [];
  deprecatedTestnetsThatHaveBeenUsed.forEach(chainId => {
    if (!newFrequentRpcListDetail.find(rpcDetails => rpcDetails.chainId === chainId)) {
      newFrequentRpcListDetail.unshift({
        rpcUrl: DEPRECATED_TEST_NET_DETAILS[chainId].rpcUrl,
        chainId,
        ticker: DEPRECATED_TEST_NET_DETAILS[chainId].ticker,
        nickname: DEPRECATED_TEST_NET_DETAILS[chainId].nickname,
        rpcPrefs: {}
      });
    }
  });
  if (newFrequentRpcListDetail.length) {
    PreferencesController.frequentRpcListDetail = newFrequentRpcListDetail;
  }
  if (currentlyOnDeprecatedNetwork.length) {
    const selectedNetworkChainId = currentlyOnDeprecatedNetwork[0];
    NetworkController.provider = {
      ...NetworkController.provider,
      type: 'rpc',
      rpcUrl: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].rpcUrl,
      chainId: selectedNetworkChainId,
      nickname: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].nickname,
      ticker: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].ticker
    };
  }
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController
    },
    NetworkController: {
      ...NetworkController
    }
  };
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\074.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\075.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C075.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 75;

/**
 * Delete the ThreeBoxController.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  delete state.ThreeBoxController;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\075.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\076.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C076.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 76;

/**
 * Update to `@metamask/controllers@33.0.0` (rename "Collectible" to "NFT").
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  if (state.CollectiblesController) {
    const {
      allCollectibleContracts,
      allCollectibles,
      ignoredCollectibles,
      ...remainingState
    } = state.CollectiblesController;
    state.NftController = {
      ...(allCollectibleContracts ? {
        allNftContracts: allCollectibleContracts
      } : {}),
      ...(allCollectibles ? {
        allNfts: allCollectibles
      } : {}),
      ...(ignoredCollectibles ? {
        ignoredNfts: ignoredCollectibles
      } : {}),
      ...remainingState
    };
    delete state.CollectiblesController;
  }
  if ((_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.useCollectibleDetection) {
    state.PreferencesController.useNftDetection = state.PreferencesController.useCollectibleDetection;
    delete state.PreferencesController.useCollectibleDetection;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\076.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\077.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C077.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 77;

/**
 * Prior to token detection v2 the data property in tokensChainsCache was an array,
 * in v2 we changes that to an object. In this migration we are converting the data as array to object.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const TokenListController = (state === null || state === void 0 ? void 0 : state.TokenListController) || {};
  const {
    tokensChainsCache
  } = TokenListController;
  let dataCache;
  let dataObject;
  // eslint-disable-next-line
  for (const chainId in tokensChainsCache) {
    dataCache = tokensChainsCache[chainId].data;
    dataObject = {};
    // if the data is array conver that to object
    if (Array.isArray(dataCache)) {
      for (const token of dataCache) {
        dataObject[token.address] = token;
      }
    } else if (Object.keys(dataCache)[0].toLowerCase() !== dataCache[Object.keys(dataCache)[0]].address.toLowerCase()) {
      // for the users who already updated to the recent version
      // and the dataCache is already an object keyed with 0,1,2,3 etc
      // eslint-disable-next-line
      for (const tokenAddress in dataCache) {
        dataObject[dataCache[tokenAddress].address] = dataCache[tokenAddress];
      }
    }
    tokensChainsCache[chainId].data = Object.keys(dataObject).length > 0 ? dataObject : dataCache;
  }
  TokenListController.tokensChainsCache = tokensChainsCache;
  return {
    ...state,
    TokenListController: {
      ...TokenListController
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\077.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\078.ts", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C078.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 78;

/**
 * The`@metamask/phishing-controller` state was updated in v2.0.0.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'PhishingController') || !(0, _utils.isObject)(state.PhishingController)) {
    return state;
  }
  const {
    PhishingController
  } = state;
  delete PhishingController.phishing;
  delete PhishingController.lastFetched;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\078.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\079.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C079.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 79;

/**
 * Remove collectiblesDropdownState and collectiblesDetectionNoticeDismissed:.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro, _state$metamask;
  if ((state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.collectiblesDetectionNoticeDismissed) !== undefined) {
    delete state.AppStateController.collectiblesDetectionNoticeDismissed;
  }
  if ((state === null || state === void 0 ? void 0 : (_state$metamask = state.metamask) === null || _state$metamask === void 0 ? void 0 : _state$metamask.collectiblesDropdownState) !== undefined) {
    delete state.metamask.collectiblesDropdownState;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\079.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\080.js", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C080.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 80;

/**
 * The portfolio tooltip has been moved to a button on the home screen so
 * this property is no longer needed in state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$metamask;
  if ((state === null || state === void 0 ? void 0 : (_state$metamask = state.metamask) === null || _state$metamask === void 0 ? void 0 : _state$metamask.showPortfolioTooltip) !== undefined) {
    delete state.metamask.showPortfolioTooltip;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\080.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\081.ts", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C081.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 81;

/**
 * Prior to this migration, snap <> dapp permissions were wildcards i.e. `wallet_snap_*`.
 * Now the permission has been changed to `wallet_snap` and the current snap permissions
 * that are under wildcards will be added as caveats to a parent `wallet_snap` permission.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  const state = versionedData.data;
  const newState = transformState(state);
  versionedData.data = newState;
  return versionedData;
}

// We return state AS IS if there is any corruption
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'SnapController') || !(0, _utils.hasProperty)(state, 'PermissionController') || !(0, _utils.isObject)(state.PermissionController)) {
    return state;
  }
  const {
    PermissionController
  } = state;
  const {
    subjects
  } = PermissionController;
  if (!(0, _utils.isObject)(subjects)) {
    return state;
  }
  const snapPrefix = 'wallet_snap_';
  for (const [subjectName, subject] of Object.entries(subjects)) {
    if (!(0, _utils.isObject)(subject) || !(0, _utils.isObject)(subject.permissions)) {
      return state;
    }
    // We keep track of the latest permission's date and associated id
    // to assign to the wallet_snap permission after iterating through all permissions
    let date = 1;
    let id;
    const {
      permissions
    } = subject;
    // New permissions object that we use to tack on the `wallet_snap` permission
    const updatedPermissions = {
      ...permissions
    };
    for (const [permissionName, permission] of Object.entries(permissions)) {
      // check if the permission is namespaced
      if (permissionName.startsWith(snapPrefix)) {
        if (!(0, _utils.isObject)(permission) || !(0, _utils.hasProperty)(permission, 'id') || !(0, _utils.hasProperty)(permission, 'date')) {
          return state;
        }
        // We create a wallet_snap key if we already don't have one
        if (!(0, _utils.hasProperty)(updatedPermissions, 'wallet_snap')) {
          updatedPermissions.wallet_snap = {
            caveats: [{
              type: 'snapIds',
              value: {}
            }],
            invoker: subjectName,
            parentCapability: 'wallet_snap'
          };
        }

        // Check if the existing permission is valid
        if (!(0, _utils.isObject)(updatedPermissions.wallet_snap)) {
          return state;
        }
        if (!(0, _lodash.isArray)(updatedPermissions.wallet_snap.caveats)) {
          return state;
        }

        // Adding the snap name to the wallet_snap permission's caveat value
        const snapId = permissionName.slice(snapPrefix.length);
        const caveat = updatedPermissions.wallet_snap.caveats[0];
        if (!(0, _utils.isObject)(caveat)) {
          return state;
        }
        if (!(0, _utils.hasProperty)(caveat, 'type') || caveat.type !== 'snapIds' || !(0, _utils.hasProperty)(caveat, 'value') || !(0, _utils.isObject)(caveat.value)) {
          return state;
        }
        caveat.value[snapId] = {};
        if (typeof permission.date !== 'number' || typeof permission.id !== 'string') {
          return state;
        }

        // updating the date & id as we iterate through all permissions
        if (permission.date > date) {
          date = permission.date;
          id = permission.id;
        }

        // finally deleting the stale permission
        delete updatedPermissions[permissionName];
      }
    }

    // we reassign the date and id here after iterating through all permissions
    // and update the subject with the updated permissions
    if (updatedPermissions.wallet_snap) {
      updatedPermissions.wallet_snap.date = date;
      updatedPermissions.wallet_snap.id = id;
      subject.permissions = updatedPermissions;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\081.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\082.ts", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C082.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
var _uuid = require("uuid");
const version = 82;

/**
 * Migrate the frequentRpcListDetail from the PreferencesController to the NetworkController, convert it from an array to an object
 * keyed by random uuids.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'PreferencesController') || !(0, _utils.isObject)(state.PreferencesController) || !(0, _utils.isObject)(state.NetworkController) || !(0, _utils.hasProperty)(state.PreferencesController, 'frequentRpcListDetail') || !Array.isArray(state.PreferencesController.frequentRpcListDetail) || !state.PreferencesController.frequentRpcListDetail.every(_utils.isObject)) {
    return state;
  }
  const {
    PreferencesController,
    NetworkController
  } = state;
  const {
    frequentRpcListDetail
  } = PreferencesController;
  if (!Array.isArray(frequentRpcListDetail)) {
    return state;
  }
  const networkConfigurations = frequentRpcListDetail.reduce((networkConfigurationsAcc, {
    rpcUrl,
    chainId,
    ticker,
    nickname,
    rpcPrefs
  }) => {
    const networkConfigurationId = (0, _uuid.v4)();
    return {
      ...networkConfigurationsAcc,
      [networkConfigurationId]: {
        rpcUrl,
        chainId,
        ticker,
        rpcPrefs,
        nickname
      }
    };
  }, {});
  delete PreferencesController.frequentRpcListDetail;
  return {
    ...state,
    NetworkController: {
      ...NetworkController,
      networkConfigurations
    },
    PreferencesController: {
      ...PreferencesController
    }
  };
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\082.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\083.ts", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C083.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 83;

/**
 * Ensure that each networkConfigurations object in state.NetworkController.networkConfigurations has an
 * `id` property which matches the key pointing that object
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.isObject)(state.NetworkController)) {
    return state;
  }
  const {
    NetworkController
  } = state;
  if (!(0, _utils.isObject)(NetworkController.networkConfigurations)) {
    return state;
  }
  const {
    networkConfigurations
  } = NetworkController;
  const newNetworkConfigurations = {};
  for (const networkConfigurationId of Object.keys(networkConfigurations)) {
    const networkConfiguration = networkConfigurations[networkConfigurationId];
    if (!(0, _utils.isObject)(networkConfiguration)) {
      return state;
    }
    newNetworkConfigurations[networkConfigurationId] = {
      ...networkConfiguration,
      id: networkConfigurationId
    };
  }
  return {
    ...state,
    NetworkController: {
      ...NetworkController,
      networkConfigurations: newNetworkConfigurations
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\083.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\084.ts", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C084.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 84;

/**
 * The `network` property in state was replaced with `networkId` and `networkStatus`.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'NetworkController') || !(0, _utils.isObject)(state.NetworkController) || !(0, _utils.hasProperty)(state.NetworkController, 'network')) {
    return state;
  }
  const NetworkController = {
    ...state.NetworkController
  };
  if (NetworkController.network === 'loading') {
    NetworkController.networkId = null;
    NetworkController.networkStatus = 'unknown';
  } else {
    NetworkController.networkId = NetworkController.network;
    NetworkController.networkStatus = 'available';
  }
  delete NetworkController.network;
  return {
    ...state,
    NetworkController
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\084.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\085.ts", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C085.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 85;

/**
 * Remove the now-obsolete network controller `previousProviderStore` state.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.isObject)(state.NetworkController)) {
    return state;
  }
  delete state.NetworkController.previousProviderStore;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\085.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\086.ts", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C086.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _utils = require("@metamask/utils");
var _lodash = require("lodash");
const version = 86;

/**
 * Rename network controller `provider` state to `providerConfig`.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if ((0, _utils.hasProperty)(state, 'NetworkController') && (0, _utils.isObject)(state.NetworkController) && (0, _utils.hasProperty)(state.NetworkController, 'provider')) {
    const networkControllerState = state.NetworkController;
    networkControllerState.providerConfig = networkControllerState.provider;
    delete networkControllerState.provider;
    return {
      ...state,
      NetworkController: networkControllerState
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\086.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\fail-tx.js", {"../../../shared/constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5Cfail-tx.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = failTxsThat;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
function failTxsThat(version, reason, condition) {
  return function (originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state, condition, reason);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  };
}
function transformState(state, condition, reason) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!condition(txMeta)) {
        return txMeta;
      }
      txMeta.status = _transaction.TransactionStatus.failed;
      txMeta.err = {
        message: reason,
        note: `Tx automatically failed by migration because ${reason}`
      };
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\fail-tx.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\index.js", {"./002":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\002.js","./003":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\003.js","./004":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\004.js","./005":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\005.js","./006":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\006.js","./007":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\007.js","./008":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\008.js","./009":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\009.js","./010":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\010.js","./011":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\011.js","./012":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\012.js","./013":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\013.js","./014":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\014.js","./015":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\015.js","./016":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\016.js","./017":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\017.js","./018":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\018.js","./019":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\019.js","./020":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\020.js","./021":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\021.js","./022":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\022.js","./023":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\023.js","./024":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\024.js","./025":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\025.js","./026":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\026.js","./027":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\027.js","./028":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\028.js","./029":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\029.js","./030":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\030.js","./031":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\031.js","./032":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\032.js","./033":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\033.js","./034":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\034.js","./035":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\035.js","./036":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\036.js","./037":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\037.js","./038":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\038.js","./039":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\039.js","./040":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\040.js","./041":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\041.js","./042":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\042.js","./043":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\043.js","./044":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\044.js","./045":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\045.js","./046":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\046.js","./047":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\047.js","./048":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\048.js","./049":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\049.js","./050":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\050.js","./051":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\051.js","./052":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\052.js","./053":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\053.js","./054":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\054.js","./055":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\055.js","./056":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\056.js","./057":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\057.js","./058":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\058.js","./059":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\059.js","./060":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\060.js","./061":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\061.js","./062":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\062.js","./063":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\063.js","./064":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\064.js","./065":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\065.js","./066":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\066.js","./067":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\067.js","./068":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\068.js","./069":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\069.js","./070":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\070.js","./071":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\071.js","./072":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\072.js","./073":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\073.js","./074":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\074.js","./075":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\075.js","./076":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\076.js","./077":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\077.js","./078":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\078.ts","./079":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\079.js","./080":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\080.js","./081":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\081.ts","./082":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\082.ts","./083":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\083.ts","./084":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\084.ts","./085":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\085.ts","./086":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\migrations\\086.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ = _interopRequireDefault(require("./002"));
var _2 = _interopRequireDefault(require("./003"));
var _3 = _interopRequireDefault(require("./004"));
var _4 = _interopRequireDefault(require("./005"));
var _5 = _interopRequireDefault(require("./006"));
var _6 = _interopRequireDefault(require("./007"));
var _7 = _interopRequireDefault(require("./008"));
var _8 = _interopRequireDefault(require("./009"));
var _9 = _interopRequireDefault(require("./010"));
var _10 = _interopRequireDefault(require("./011"));
var _11 = _interopRequireDefault(require("./012"));
var _12 = _interopRequireDefault(require("./013"));
var _13 = _interopRequireDefault(require("./014"));
var _14 = _interopRequireDefault(require("./015"));
var _15 = _interopRequireDefault(require("./016"));
var _16 = _interopRequireDefault(require("./017"));
var _17 = _interopRequireDefault(require("./018"));
var _18 = _interopRequireDefault(require("./019"));
var _19 = _interopRequireDefault(require("./020"));
var _20 = _interopRequireDefault(require("./021"));
var _21 = _interopRequireDefault(require("./022"));
var _22 = _interopRequireDefault(require("./023"));
var _23 = _interopRequireDefault(require("./024"));
var _24 = _interopRequireDefault(require("./025"));
var _25 = _interopRequireDefault(require("./026"));
var _26 = _interopRequireDefault(require("./027"));
var _27 = _interopRequireDefault(require("./028"));
var _28 = _interopRequireDefault(require("./029"));
var _29 = _interopRequireDefault(require("./030"));
var _30 = _interopRequireDefault(require("./031"));
var _31 = _interopRequireDefault(require("./032"));
var _32 = _interopRequireDefault(require("./033"));
var _33 = _interopRequireDefault(require("./034"));
var _34 = _interopRequireDefault(require("./035"));
var _35 = _interopRequireDefault(require("./036"));
var _36 = _interopRequireDefault(require("./037"));
var _37 = _interopRequireDefault(require("./038"));
var _38 = _interopRequireDefault(require("./039"));
var _39 = _interopRequireDefault(require("./040"));
var _40 = _interopRequireDefault(require("./041"));
var _41 = _interopRequireDefault(require("./042"));
var _42 = _interopRequireDefault(require("./043"));
var _43 = _interopRequireDefault(require("./044"));
var _44 = _interopRequireDefault(require("./045"));
var _45 = _interopRequireDefault(require("./046"));
var _46 = _interopRequireDefault(require("./047"));
var _47 = _interopRequireDefault(require("./048"));
var _48 = _interopRequireDefault(require("./049"));
var _49 = _interopRequireDefault(require("./050"));
var _50 = _interopRequireDefault(require("./051"));
var _51 = _interopRequireDefault(require("./052"));
var _52 = _interopRequireDefault(require("./053"));
var _53 = _interopRequireDefault(require("./054"));
var _54 = _interopRequireDefault(require("./055"));
var _55 = _interopRequireDefault(require("./056"));
var _56 = _interopRequireDefault(require("./057"));
var _57 = _interopRequireDefault(require("./058"));
var _58 = _interopRequireDefault(require("./059"));
var _59 = _interopRequireDefault(require("./060"));
var _60 = _interopRequireDefault(require("./061"));
var _61 = _interopRequireDefault(require("./062"));
var _62 = _interopRequireDefault(require("./063"));
var _63 = _interopRequireDefault(require("./064"));
var _64 = _interopRequireDefault(require("./065"));
var _65 = _interopRequireDefault(require("./066"));
var _66 = _interopRequireDefault(require("./067"));
var _67 = _interopRequireDefault(require("./068"));
var _68 = _interopRequireDefault(require("./069"));
var _69 = _interopRequireDefault(require("./070"));
var _70 = _interopRequireDefault(require("./071"));
var _71 = _interopRequireDefault(require("./072"));
var _72 = _interopRequireDefault(require("./073"));
var _73 = _interopRequireDefault(require("./074"));
var _74 = _interopRequireDefault(require("./075"));
var _75 = _interopRequireDefault(require("./076"));
var _76 = _interopRequireDefault(require("./077"));
var m078 = _interopRequireWildcard(require("./078"));
var _78 = _interopRequireDefault(require("./079"));
var _79 = _interopRequireDefault(require("./080"));
var m081 = _interopRequireWildcard(require("./081"));
var m082 = _interopRequireWildcard(require("./082"));
var m083 = _interopRequireWildcard(require("./083"));
var m084 = _interopRequireWildcard(require("./084"));
var m085 = _interopRequireWildcard(require("./085"));
var m086 = _interopRequireWildcard(require("./086"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Migrations must start at version 1 or later.
// They are objects with a `version` number
// and a `migrate` function.
//
// The `migrate` function receives the previous
// config data format, and returns the new one.

const migrations = [_.default, _2.default, _3.default, _4.default, _5.default, _6.default, _7.default, _8.default, _9.default, _10.default, _11.default, _12.default, _13.default, _14.default, _15.default, _16.default, _17.default, _18.default, _19.default, _20.default, _21.default, _22.default, _23.default, _24.default, _25.default, _26.default, _27.default, _28.default, _29.default, _30.default, _31.default, _32.default, _33.default, _34.default, _35.default, _36.default, _37.default, _38.default, _39.default, _40.default, _41.default, _42.default, _43.default, _44.default, _45.default, _46.default, _47.default, _48.default, _49.default, _50.default, _51.default, _52.default, _53.default, _54.default, _55.default, _56.default, _57.default, _58.default, _59.default, _60.default, _61.default, _62.default, _63.default, _64.default, _65.default, _66.default, _67.default, _68.default, _69.default, _70.default, _71.default, _72.default, _73.default, _74.default, _75.default, _76.default, m078, _78.default, _79.default, m081, m082, m083, m084, m085, m086];
var _default = migrations;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js", {"./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
'use strict'

const { encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__("./types").BaseName} BaseName */
/** @typedef {__import__("./types").BaseCode} BaseCode */

/**
 * Class to encode/decode in the supported Bases
 *
 */
class Base {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor (name, code, factory, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = encodeText(this.code)
    this.alphabet = alphabet
    this.codec = factory(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.codec.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.codec.decode(string)
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js", {"./base.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js","./rfc4648":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js","@multiformats/base-x":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@multiformats\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

const baseX = require('@multiformats/base-x')
const Base = require('./base.js')
const { rfc4648 } = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__('./types').Codec} Codec */
/** @typedef {__import__('./types').BaseName} BaseName */
/** @typedef {__import__('./types').BaseCode} BaseCode */

/** @type {CodecFactory} */
const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

/** @type {Record<BaseName,Base>} */
const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, /** @type {Record<BaseName,Base>} */({}))

/** @type {Record<BaseCode,Base>} */
const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, /** @type {Record<BaseCode,Base>} */({}))

module.exports = {
  names,
  codes
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Crfc4648.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./types').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
const rfc4648 = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

module.exports = { rfc4648 }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js", {"web-encoding":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

// @ts-ignore
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */
function concat (arrs, length) {
  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrs) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = { decodeText, encodeText, concat }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cdecode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cencode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js", {"./decode.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js","./encode.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js","./length.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cindex.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Clength.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cbase-table.js
      return function (require, module, exports) {
// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */
'use strict'

/**
 * @type {__import__('./generated-types').NameNumberMap}
 */
const baseTable = Object.freeze({
  'identity': 0x00,
  'cidv1': 0x01,
  'cidv2': 0x02,
  'cidv3': 0x03,
  'ip4': 0x04,
  'tcp': 0x06,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'dccp': 0x21,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'ip6': 0x29,
  'ip6zone': 0x2a,
  'path': 0x2f,
  'multicodec': 0x30,
  'multihash': 0x31,
  'multiaddr': 0x32,
  'multibase': 0x33,
  'dns': 0x35,
  'dns4': 0x36,
  'dns6': 0x37,
  'dnsaddr': 0x38,
  'protobuf': 0x50,
  'cbor': 0x51,
  'raw': 0x55,
  'dbl-sha2-256': 0x56,
  'rlp': 0x60,
  'bencode': 0x63,
  'dag-pb': 0x70,
  'dag-cbor': 0x71,
  'libp2p-key': 0x72,
  'git-raw': 0x78,
  'torrent-info': 0x7b,
  'torrent-file': 0x7c,
  'leofcoin-block': 0x81,
  'leofcoin-tx': 0x82,
  'leofcoin-pr': 0x83,
  'sctp': 0x84,
  'dag-jose': 0x85,
  'dag-cose': 0x86,
  'eth-block': 0x90,
  'eth-block-list': 0x91,
  'eth-tx-trie': 0x92,
  'eth-tx': 0x93,
  'eth-tx-receipt-trie': 0x94,
  'eth-tx-receipt': 0x95,
  'eth-state-trie': 0x96,
  'eth-account-snapshot': 0x97,
  'eth-storage-trie': 0x98,
  'bitcoin-block': 0xb0,
  'bitcoin-tx': 0xb1,
  'bitcoin-witness-commitment': 0xb2,
  'zcash-block': 0xc0,
  'zcash-tx': 0xc1,
  'docid': 0xce,
  'stellar-block': 0xd0,
  'stellar-tx': 0xd1,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'decred-block': 0xe0,
  'decred-tx': 0xe1,
  'ipld-ns': 0xe2,
  'ipfs-ns': 0xe3,
  'swarm-ns': 0xe4,
  'ipns-ns': 0xe5,
  'zeronet': 0xe6,
  'secp256k1-pub': 0xe7,
  'bls12_381-g1-pub': 0xea,
  'bls12_381-g2-pub': 0xeb,
  'x25519-pub': 0xec,
  'ed25519-pub': 0xed,
  'bls12_381-g1g2-pub': 0xee,
  'dash-block': 0xf0,
  'dash-tx': 0xf1,
  'swarm-manifest': 0xfa,
  'swarm-feed': 0xfb,
  'udp': 0x0111,
  'p2p-webrtc-star': 0x0113,
  'p2p-webrtc-direct': 0x0114,
  'p2p-stardust': 0x0115,
  'p2p-circuit': 0x0122,
  'dag-json': 0x0129,
  'udt': 0x012d,
  'utp': 0x012e,
  'unix': 0x0190,
  'p2p': 0x01a5,
  'ipfs': 0x01a5,
  'https': 0x01bb,
  'onion': 0x01bc,
  'onion3': 0x01bd,
  'garlic64': 0x01be,
  'garlic32': 0x01bf,
  'tls': 0x01c0,
  'quic': 0x01cc,
  'ws': 0x01dd,
  'wss': 0x01de,
  'p2p-websocket-star': 0x01df,
  'http': 0x01e0,
  'json': 0x0200,
  'messagepack': 0x0201,
  'libp2p-peer-record': 0x0301,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'p256-pub': 0x1200,
  'p384-pub': 0x1201,
  'p521-pub': 0x1202,
  'ed448-pub': 0x1203,
  'x448-pub': 0x1204,
  'ed25519-priv': 0x1300,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402,
  'zeroxcert-imprint-256': 0xce11,
  'fil-commitment-unsealed': 0xf101,
  'fil-commitment-sealed': 0xf102,
  'holochain-adr-v0': 0x807124,
  'holochain-adr-v1': 0x817124,
  'holochain-key-v0': 0x947124,
  'holochain-key-v1': 0x957124,
  'holochain-sig-v0': 0xa27124,
  'holochain-sig-v1': 0xa37124,
  'skynet-ns': 0xb19910
})

module.exports = { baseTable }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js", {"./base-table":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').ConstantNumberMap} ConstantNumberMap */

const { baseTable } = require('./base-table')

const constants = /** @type {ConstantNumberMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  const constant = name.toUpperCase().replace(/-/g, '_')
  constants[constant] = code
}

module.exports = Object.freeze(constants)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js","./int-table":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js","./print":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js","./varint-table":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js","uint8arrays/concat":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js","varint":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const varint = require('varint')
const intTable = require('./int-table')
const codecNameToCodeVarint = require('./varint-table')
const util = require('./util')
const uint8ArrayConcat = require('uint8arrays/concat')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  const code = varint.decode(prefixedData)
  const codecName = intTable.get(code)
  if (codecName === undefined) {
    throw new Error(`Code ${code} not found`)
  }
  return codecName
}

/**
 * Get the name of the codec.
 *
 * @param {CodecNumber} codec
 * @returns {CodecName|undefined}
 */
function getName (codec) {
  return intTable.get(codec)
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecNumber}
 */
function getNumber (name) {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return varint.decode(code)
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecNumber}
 */
function getCode (prefixedData) {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} codecName
 * @returns {Uint8Array}
 */
function getCodeVarint (codecName) {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecNumber} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')

// Human friendly names for printing, e.g. in error messages
const print = require('./print')

module.exports = {
  addPrefix,
  rmPrefix,
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  print,
  ...constants
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js", {"./base-table":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const { baseTable } = require('./base-table')

/**
 * @type {Map<CodecNumber,CodecName>}
 */
const nameTable = new Map()

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  nameTable.set(code, /** @type {CodecName} */(encodingName))
}

module.exports = Object.freeze(nameTable)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js", {"./base-table":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cprint.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').NumberNameMap} NumberNameMap */

const { baseTable } = require('./base-table')

const tableByCode = /** @type {NumberNameMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  if (tableByCode[code] === undefined) {
    tableByCode[code] = /** @type {CodecName} **/(name)
  }
}

module.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js", {"uint8arrays/from-string":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js","uint8arrays/to-string":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js","varint":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js", {"./base-table":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cvarint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */

const { baseTable } = require('./base-table')
const varintEncode = require('./util').varintEncode

const varintTable = /** @type {NameUint8ArrayMap} */ ({})

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  varintTable[encodingName] = varintEncode(code)
}

module.exports = Object.freeze(varintTable)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
// @ts-check
'use strict'
const { Buffer } = require('buffer')

/**
 * @typedef {Object} Codec
 * @property {function(Uint8Array):string} encode
 * @property {function(string):Uint8Array} decode
 *
 * @typedef {function(string):Codec} CodecFactory
 */

class Base {
  /**
   * @param {string} name
   * @param {string} code
   * @param {CodecFactory} implementation
   * @param {string} alphabet
   */
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = Buffer.from(this.code)
    this.alphabet = alphabet
    this.engine = implementation(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.engine.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.engine.decode(string)
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js", {"./base.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js","./rfc4648":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js","base-x":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const baseX = require('base-x')
const Base = require('./base.js')
const rfc4648 = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 * @typedef {__import__('./base').CodecFactory} CodecFactory
 *
 * name, code, implementation, alphabet
 * @type {Array<[string, string, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names,
  codes
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cindex.js
      return function (require, module, exports) {
// @ts-check
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')
const { decodeText, asBuffer } = require('./util')

/** @typedef {__import__("./base")} Base */

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  const buffer = Buffer.alloc(codeBuf.length + buf.length)
  buffer.set(codeBuf, 0)
  buffer.set(buf, codeBuf.length)

  return buffer
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)

  return Buffer.concat([enc.codeBuf, Buffer.from(enc.encode(buf))])
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (ArrayBuffer.isView(data)) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(data[0])
  return asBuffer(enc.decode(data.substring(1)))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 * @returns {false|string}
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(data[0])
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {string} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {string|number} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (constants.names[nameOrCode]) {
    return constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    return constants.codes[nameOrCode]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(data[0])
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
exports.names = Object.freeze(constants.names)
exports.codes = Object.freeze(constants.codes)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Crfc4648.js
      return function (require, module, exports) {
// @ts-check
'use strict'

/** @typedef {__import__('./base').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
module.exports = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","web-encoding":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cutil.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const { Buffer } = require('buffer')
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * @param {ArrayBufferView} bytes
 * @returns {Buffer}
 */
const asBuffer = ({ buffer, byteLength, byteOffset }) =>
  Buffer.from(buffer, byteOffset, byteLength)

module.exports = { decodeText, encodeText, asBuffer }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Csrc%5Cconstants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
'use strict'

const names = Object.freeze({
  'identity': 0x00,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'dbl-sha2-256': 0x56,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402
})

module.exports = { names }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","multibase":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js","varint":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\index.js","web-encoding":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Csrc%5Cindex.js
      return function (require, module, exports) {
// @ts-check
/* eslint-disable guard-for-in */
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const { TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
const codes = {}

for (const key in names) {
  codes[names[key]] = key
}
exports.names = names
exports.codes = Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  const buffer = Buffer.isBuffer(hash)
    ? hash
    : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)

  return buffer.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? textDecoder.decode(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }
  let buf = Buffer.isBuffer(bytes)
    ? bytes
    : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  const buffer = Buffer.alloc(hash.length + len.length + digest.length)
  buffer.set(hash, 0)
  buffer.set(len, hash.length)
  buffer.set(digest, hash.length + len.length)
  return buffer
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Buffer}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return Buffer.from(multihash.buffer, multihash.byteOffset, 2)
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cconcat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {Number} length
 * @returns {Uint8Array}
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js", {"multibase/src/constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js","web-encoding":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cfrom-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextEncoder } = require('web-encoding')
const utf8Encoder = new TextEncoder()

/**
 * Interperets each character in a string as a byte and
 * returns a Uint8Array of those bytes.
 *
 * @param {String} string The string to turn into an array
 * @returns {Uint8Array}
 */
function asciiStringToUint8Array (string) {
  const array = new Uint8Array(string.length)

  for (let i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i)
  }

  return array
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {String} string
 * @param {String} [encoding=utf8] utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function fromString (string, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Encoder.encode(string)
  }

  if (encoding === 'ascii') {
    return asciiStringToUint8Array(string)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.decode(string)
}

module.exports = fromString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js", {"multibase/src/constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js","web-encoding":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cto-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextDecoder } = require('web-encoding')
const utf8Decoder = new TextDecoder('utf8')

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array The array to turn into a string
 * @returns {String}
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array The array to turn into a string
 * @param {String} [encoding=utf8] The encoding to use
 * @returns {String}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.encode(array)
}

module.exports = toString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js", {"cids":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\cids\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Chelpers.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');

// Label's max length in DNS (https://tools.ietf.org/html/rfc1034#page-7)
const dnsLabelMaxLength = 63;

/**
 * Take any ipfsHash and convert it to DNS-compatible CID
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidForWeb = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
  let dnsLabel = cid.toString('base32');
  if (dnsLabel.length > dnsLabelMaxLength) {
    const b36 = cid.toString('base36');
    if (b36.length <= dnsLabelMaxLength) {
      return b36;
    }
    throw new TypeError ('CID is longer than DNS limit of 63 characters and is not compatible with public gateways');
  }
	return dnsLabel;
}

exports.cidForWeb = cidForWeb;


/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\helpers.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\index.js", {"./helpers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js","./profiles":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js","multicodec":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js","multihashes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Cindex.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const multiC = require('multicodec');
const multiH = require('multihashes');

const { hexStringToBuffer, profiles } = require('./profiles');
const { cidForWeb, cidV0ToV1Base32 } = require('./helpers');

module.exports = {

	//export some helpers functions
	helpers: {
		cidForWeb,
		cidV0ToV1Base32,
	},

	/**
	* Decode a Content Hash.
	* @param {string} hash an hex string containing a content hash
	* @return {string} the decoded content
	*/
	decode: function (contentHash) {
		const buffer = hexStringToBuffer(contentHash);
		const codec = multiC.getCodec(buffer);
		const value = multiC.rmPrefix(buffer);
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		return profile.decode(value);
	},

	/**
	* Encode an IPFS address into a content hash
	* @param {string} ipfsHash string containing an IPFS address
	* @return {string} the resulting content hash
	*/
	fromIpfs: function (ipfsHash) {
		return this.encode('ipfs-ns', ipfsHash);
	},

	/**
	* Encode a Skylink into a content hash
	* @param {string} skylink string containing a Skylink
	* @return {string} the resulting content hash
	*/
	fromSkylink: function (skylink) {
		return this.encode('skynet-ns', skylink);
	},

	/**
	* Encode a Swarm address into a content hash
	* @param {string} swarmHash string containing a Swarm address
	* @return {string} the resulting content hash
	*/
	fromSwarm: function (swarmHash) {
		return this.encode('swarm-ns', swarmHash);
	},

	/**
	* General purpose encoding function
  * @param {string} codec 
  * @param {string} value 
  */
	encode: function (codec, value) {
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		const encodedValue = profile.encode(value);
		return multiH.toHexString(multiC.addPrefix(codec, encodedValue))
	},

	/**
	* Extract the codec of a content hash
	* @param {string} hash hex string containing a content hash
	* @return {string} the extracted codec
	*/
	getCodec: function (hash) {
		let buffer = hexStringToBuffer(hash);
		return multiC.getCodec(buffer);
	},
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\cids\\src\\index.js","js-base64":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\js-base64\\base64.js","multihashes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Cprofiles.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');
const multiH = require('multihashes');
const base64 = require('js-base64')

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
 * Validates IPNS identifier  to safeguard against insecure names.
 * @param {CID} name ised in ipns-ns
 * @return {bool}
 */
const isCryptographicIPNS =  (cid) => {
  try {
    const { multihash } = cid
    // Additional check for identifiers shorter
    // than what inlined ED25519 pubkey would be
    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950
    if (multihash.length < 38) {
      const mh = multiH.decode(multihash)
      // ED25519 pubkeys are inlined using identity hash function
      // and we should not see anything shorter than that
      if (mh.name === 'identity' && mh.length < 36) {
        // One can read inlined string value via:
        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))
        return false
      }
    }
    // ok, CID looks fine
    return true
  } catch (_) { return false }
  return false
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  skynet: (value) => {
    return base64.toUint8Array(value)
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    return new CID(value).toV1().bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipns: (value) => {
    const cid = new CID(value)
    if (!isCryptographicIPNS(cid)) {
        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    // Represent IPNS name as a CID with libp2p-key codec
    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md
    return new CID(1, 'libp2p-key', cid.multihash).bytes
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  ipfs: (value) => {
    const cid = new CID(value).toV1();
    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')
  },
  /**
  * @param {Buffer} value 
  */
  ipns: (value) => {
    const cid = new CID(value).toV1()
    if (!isCryptographicIPNS(cid)) {
        // Value is not a libp2p-key, return original string
        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')
        return String(multiH.decode(new CID(value).multihash).digest)
        // TODO: start throwing an error (after some deprecation period)
        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    return cid.toString('base36')
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
  base64: (value) => {
    // `true` option makes it URL safe (replaces / and + with - and _ )
    return base64.fromUint8Array(value, true)
  }
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'skynet-ns': {
    encode: encodes.skynet,
    decode: decodes.base64,
  },
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.ipfs,
  },
  'ipns-ns': {
    encode: encodes.ipns,
    decode: decodes.ipns,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\profiles.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js", {"@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cbase-eth-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');
var rlp = _interopDefault(require('rlp'));
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = "QR Hardware Wallet Device";
const pathBase = "m";
const MAX_INDEX = 1000;
const DEFAULT_CHILDREN_PATH = "0/*";
var KEYRING_MODE;

(function (KEYRING_MODE) {
  KEYRING_MODE["hd"] = "hd";
  KEYRING_MODE["pubkey"] = "pubkey";
})(KEYRING_MODE || (KEYRING_MODE = {}));

var KEYRING_ACCOUNT;

(function (KEYRING_ACCOUNT) {
  KEYRING_ACCOUNT["standard"] = "account.standard";
  KEYRING_ACCOUNT["ledger_live"] = "account.ledger_live";
  KEYRING_ACCOUNT["ledger_legacy"] = "account.ledger_legacy";
})(KEYRING_ACCOUNT || (KEYRING_ACCOUNT = {}));

class BaseKeyring {
  constructor(opts) {
    // @ts-ignore
    this.version = 1;

    this.getInteraction = () => {
      throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.__readCryptoHDKey = cryptoHDKey => {
      var _cryptoHDKey$getOrigi, _cryptoHDKey$getChild;

      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString("hex");
      const childrenPath = ((_cryptoHDKey$getChild = cryptoHDKey.getChildren()) == null ? void 0 : _cryptoHDKey$getChild.getPath()) || DEFAULT_CHILDREN_PATH;
      const name = cryptoHDKey.getName();

      if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {
        this.keyringAccount = KEYRING_ACCOUNT.standard;
      } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {
        this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;
      }

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");
      }

      const xpub = cryptoHDKey.getBip32Key();
      this.xfp = xfp;
      this.xpub = xpub;
      this.hdPath = hdPath;
      this.childrenPath = childrenPath;

      if (name !== undefined && name !== "") {
        this.name = name;
      }

      this.initialized = true;
    };

    this.__readCryptoAccount = cryptoAccount => {
      var _cryptoAccount$getMas, _cryptoAccount$getOut;

      const xfp = (_cryptoAccount$getMas = cryptoAccount.getMasterFingerprint()) == null ? void 0 : _cryptoAccount$getMas.toString("hex");

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");
      }

      this.xfp = xfp;
      this.initialized = true;
      let changed = false;
      const outputs = cryptoAccount.getOutputDescriptors();

      if (!outputs || outputs.length === 0) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");
      }

      if (outputs.length % 5 !== 0) {
        throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");
      }

      (_cryptoAccount$getOut = cryptoAccount.getOutputDescriptors()) == null ? void 0 : _cryptoAccount$getOut.forEach(od => {
        try {
          const cryptoHDKey = od.getHDKey();

          if (cryptoHDKey) {
            const key = cryptoHDKey.getKey();
            const path = `M/${cryptoHDKey.getOrigin().getPath()}`;
            const address = "0x" + util.publicToAddress(key, true).toString("hex");
            this.name = cryptoHDKey.getName();

            if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {
              this.keyringAccount = KEYRING_ACCOUNT.ledger_live;
            }

            if (this.paths[util.toChecksumAddress(address)] === undefined) {
              changed = true;
            }

            this.paths[util.toChecksumAddress(address)] = path;
          }
        } catch (e) {
          throw new Error(`KeystoneError#invalid_data: ${e}`);
        }
      });
      return changed;
    }; // private __readLedgerLiveAccounts = async () => {
    //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {
    //         const changed = this.__readCryptoAccount(result as CryptoAccount);
    //         if (!changed) {
    //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);
    //         }
    //     } else {
    //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);
    //     }
    // };


    this.getName = () => {
      return this.name;
    };

    this.setAccountToUnlock = index => {
      this.unlockedAccount = parseInt(index, 10);
    };

    this.__getNormalPage = async increment => {
      this.page += increment;

      if (this.page <= 0) {
        this.page = 1;
      }

      const from = (this.page - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
        this.indexes[util.toChecksumAddress(address)] = i;
      }

      return accounts;
    };

    this.__getLedgerLivePage = async increment => {
      const nextPage = this.page + increment;
      const from = (nextPage - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
      }

      this.page += increment;
      return accounts;
    };

    this.__addressFromIndex = async (pb, i) => {
      if (this.keyringMode === KEYRING_MODE.hd) {
        this.checkKeyring();

        if (!this.hdk) {
          // @ts-ignore
          this.hdk = HDKey.fromExtendedKey(this.xpub);
        }

        const childrenPath = this.childrenPath.replace("*", String(i)).replace(/\*/g, "0");
        const dkey = this.hdk.derive(`${pb}/${childrenPath}`);
        const address = "0x" + util.publicToAddress(dkey.publicKey, true).toString("hex");
        return util.toChecksumAddress(address);
      } else {
        const result = Object.keys(this.paths)[i];

        if (result) {
          return util.toChecksumAddress(result);
        } else {
          throw new Error(`KeystoneError#pubkey_account.no_expected_account`);
        }
      }
    }; //common props


    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.unlockedAccount = 0;
    this.name = "QR Hardware";
    this.keyringMode = KEYRING_MODE.hd;
    this.keyringAccount = KEYRING_ACCOUNT.standard;
    this.initialized = false; //hd props;

    this.xfp = "";
    this.xpub = "";
    this.hdPath = "";
    this.childrenPath = DEFAULT_CHILDREN_PATH;
    this.indexes = {}; //pubkey props;

    this.paths = {};
    this.deserialize(opts);
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    this.syncKeyring(result);
  }

  syncKeyring(data) {
    if (data.getRegistryType().getType() === bcUrRegistryEth.extend.RegistryTypes.CRYPTO_HDKEY.getType()) {
      this.keyringMode = KEYRING_MODE.hd;

      this.__readCryptoHDKey(data);
    } else {
      this.keyringMode = KEYRING_MODE.pubkey;

      this.__readCryptoAccount(data);
    }
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly");
    }
  }

  serialize() {
    return Promise.resolve({
      //common
      initialized: this.initialized,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      keyringAccount: this.keyringAccount,
      keyringMode: this.keyringMode,
      name: this.name,
      version: this.version,
      xfp: this.xfp,
      //hd
      xpub: this.xpub,
      hdPath: this.hdPath,
      childrenPath: this.childrenPath,
      indexes: this.indexes,
      //pubkey
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      //common props;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.name = opts.name;
      this.initialized = opts.initialized;
      this.keyringMode = opts.keyringMode || KEYRING_MODE.hd;
      this.keyringAccount = opts.keyringAccount || KEYRING_ACCOUNT.standard;
      this.xfp = opts.xfp; //hd props;

      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.indexes = opts.indexes;
      this.paths = opts.paths;
      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  async addAccounts(n = 1) {
    const from = this.unlockedAccount;
    const to = from + n;
    const newAccounts = [];

    for (let i = from; i < to; i++) {
      const address = await this.__addressFromIndex(pathBase, i);
      newAccounts.push(address);
      this.page = 0;
      this.unlockedAccount++;
    }

    this.accounts = this.accounts.concat(newAccounts);
    return this.accounts;
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    if (!this.initialized) {
      await this.readKeyring();
    }

    if (this.keyringMode === KEYRING_MODE.hd) {
      return this.__getNormalPage(increment);
    } else {
      return this.__getLedgerLivePage(increment);
    }
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = Buffer.from(rlp.encode(tx$1.getMessageToSign(false)));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = Number(tx$1.common.chainId());
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    return tx.TransactionFactory.fromTxData({ ...tx$1.toJSON(),
      type: tx$1.type,
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = util.stripHexPrefix(messageHex);
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, "hex"), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), "utf-8"), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async _pathFromAddress(address) {
    if (this.keyringMode === KEYRING_MODE.hd) {
      const checksummedAddress = util.toChecksumAddress(address);
      let index = this.indexes[checksummedAddress];

      if (typeof index === "undefined") {
        for (let i = 0; i < MAX_INDEX; i++) {
          if (checksummedAddress === (await this.__addressFromIndex(pathBase, i))) {
            index = i;
            break;
          }
        }
      }

      if (typeof index === "undefined") {
        throw new Error("Unknown address");
      }

      return `${this.hdPath}/${this.childrenPath.replace("*", index.toString()).replace(/\*/g, "0")}`;
    } else {
      const checksummedAddress = util.toChecksumAddress(address);
      const path = this.paths[checksummedAddress];

      if (typeof path === "undefined") {
        throw new Error("Unknown address");
      }

      return path;
    }
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js", {"@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cbase-eth-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t,r,i=e(require("hdkey")),s=require("@ethereumjs/util"),n=e(require("rlp")),a=require("@ethereumjs/tx"),o=require("@keystonehq/bc-ur-registry-eth"),h=require("uuid");!function(e){e.hd="hd",e.pubkey="pubkey"}(t||(t={})),function(e){e.standard="account.standard",e.ledger_live="account.ledger_live",e.ledger_legacy="account.ledger_legacy"}(r||(r={}));class c{constructor(e){this.version=1,this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,r,i)=>{const s=await this.getInteraction().requestSignature(t,r,i),n=s.getRequestId(),a=s.getSignature();if(n&&h.stringify(n)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return{r:a.slice(0,32),s:a.slice(32,64),v:a.slice(64)}},this.__readCryptoHDKey=e=>{var t,i;const s="m/"+e.getOrigin().getPath(),n=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),a=(null==(i=e.getChildren())?void 0:i.getPath())||"0/*",o=e.getName();if(e.getNote()===r.standard?this.keyringAccount=r.standard:e.getNote()===r.ledger_legacy&&(this.keyringAccount=r.ledger_legacy),!n)throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");const h=e.getBip32Key();this.xfp=n,this.xpub=h,this.hdPath=s,this.childrenPath=a,void 0!==o&&""!==o&&(this.name=o),this.initialized=!0},this.__readCryptoAccount=e=>{var t,i;const n=null==(t=e.getMasterFingerprint())?void 0:t.toString("hex");if(!n)throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");this.xfp=n,this.initialized=!0;let a=!1;const o=e.getOutputDescriptors();if(!o||0===o.length)throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");if(o.length%5!=0)throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");return null==(i=e.getOutputDescriptors())||i.forEach(e=>{try{const t=e.getHDKey();if(t){const e=t.getKey(),i="M/"+t.getOrigin().getPath(),n="0x"+s.publicToAddress(e,!0).toString("hex");this.name=t.getName(),t.getNote()===r.ledger_live&&(this.keyringAccount=r.ledger_live),void 0===this.paths[s.toChecksumAddress(n)]&&(a=!0),this.paths[s.toChecksumAddress(n)]=i}}catch(e){throw new Error("KeystoneError#invalid_data: "+e)}}),a},this.getName=()=>this.name,this.setAccountToUnlock=e=>{this.unlockedAccount=parseInt(e,10)},this.__getNormalPage=async e=>{this.page+=e,this.page<=0&&(this.page=1);const t=(this.page-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e}),this.indexes[s.toChecksumAddress(t)]=e}return i},this.__getLedgerLivePage=async e=>{const t=(this.page+e-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e})}return this.page+=e,i},this.__addressFromIndex=async(e,r)=>{if(this.keyringMode===t.hd){this.checkKeyring(),this.hdk||(this.hdk=i.fromExtendedKey(this.xpub));const t=this.childrenPath.replace("*",String(r)).replace(/\*/g,"0"),n=this.hdk.derive(`${e}/${t}`),a="0x"+s.publicToAddress(n.publicKey,!0).toString("hex");return s.toChecksumAddress(a)}{const e=Object.keys(this.paths)[r];if(e)return s.toChecksumAddress(e);throw new Error("KeystoneError#pubkey_account.no_expected_account")}},this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.unlockedAccount=0,this.name="QR Hardware",this.keyringMode=t.hd,this.keyringAccount=r.standard,this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.childrenPath="0/*",this.indexes={},this.paths={},this.deserialize(e)}async readKeyring(){const e=await this.getInteraction().readCryptoHDKeyOrCryptoAccount();this.syncKeyring(e)}syncKeyring(e){e.getRegistryType().getType()===o.extend.RegistryTypes.CRYPTO_HDKEY.getType()?(this.keyringMode=t.hd,this.__readCryptoHDKey(e)):(this.keyringMode=t.pubkey,this.__readCryptoAccount(e))}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({initialized:this.initialized,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,keyringAccount:this.keyringAccount,keyringMode:this.keyringMode,name:this.name,version:this.version,xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,childrenPath:this.childrenPath,indexes:this.indexes,paths:this.paths})}deserialize(e){e&&(this.accounts=e.accounts,this.currentAccount=e.currentAccount,this.page=e.page,this.perPage=e.perPage,this.name=e.name,this.initialized=e.initialized,this.keyringMode=e.keyringMode||t.hd,this.keyringAccount=e.keyringAccount||r.standard,this.xfp=e.xfp,this.xpub=e.xpub,this.hdPath=e.hdPath,this.indexes=e.indexes,this.paths=e.paths,this.childrenPath=e.childrenPath||"0/*")}setCurrentAccount(e){this.currentAccount=e}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}async addAccounts(e=1){const t=this.unlockedAccount,r=t+e,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push(t),this.page=0,this.unlockedAccount++}return this.accounts=this.accounts.concat(i),this.accounts}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(e){return this.initialized||await this.readKeyring(),this.keyringMode===t.hd?this.__getNormalPage(e):this.__getLedgerLivePage(e)}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(e){if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())}async signTransaction(e,t){const r=0===t.type?o.DataType.transaction:o.DataType.typedTransaction;let i;i=0===t.type?Buffer.from(n.encode(t.getMessageToSign(!1))):t.getMessageToSign(!1);const s=await this._pathFromAddress(e),c=Number(t.common.chainId()),d=h.v4(),u=o.EthSignRequest.constructETHRequest(i,r,s,this.xfp,d,c),{r:g,s:y,v:p}=await this.requestSignature(d,u,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');return a.TransactionFactory.fromTxData({...t.toJSON(),type:t.type,r:g,s:y,v:p},{common:t.common})}signMessage(e,t){return this.signPersonalMessage(e,t)}async signPersonalMessage(e,t){const r=s.stripHexPrefix(t),i=await this._pathFromAddress(e),n=h.v4(),a=o.EthSignRequest.constructETHRequest(Buffer.from(r,"hex"),o.DataType.personalMessage,i,this.xfp,n,void 0,e),{r:c,s:d,v:u}=await this.requestSignature(n,a,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,d,u]).toString("hex")}async signTypedData(e,t){const r=await this._pathFromAddress(e),i=h.v4(),s=o.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(t),"utf-8"),o.DataType.typedData,r,this.xfp,i,void 0,e),{r:n,s:a,v:c}=await this.requestSignature(i,s,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([n,a,c]).toString("hex")}async _pathFromAddress(e){if(this.keyringMode===t.hd){const t=s.toChecksumAddress(e);let r=this.indexes[t];if(void 0===r)for(let e=0;e<1e3;e++)if(t===await this.__addressFromIndex("m",e)){r=e;break}if(void 0===r)throw new Error("Unknown address");return`${this.hdPath}/${this.childrenPath.replace("*",r.toString()).replace(/\*/g,"0")}`}{const t=s.toChecksumAddress(e),r=this.paths[t];if(void 0===r)throw new Error("Unknown address");return r}}}c.type="QR Hardware Wallet Device",exports.BaseKeyring=c;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js", {"./base-eth-keyring.cjs.development.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js","./base-eth-keyring.cjs.production.min.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./base-eth-keyring.cjs.production.min.js')
} else {
  module.exports = require('./base-eth-keyring.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js", {"@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');

const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-sign-request", 401),
  ETH_SIGNATURE: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-signature", 402),
  ETH_NFT_ITEM: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-nft-item", 403)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSourceFingerprint = () => this.derivationPath.getSourceFingerprint();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.requestId = args.requestId;
    this.signData = args.signData;
    this.dataType = args.dataType;
    this.chainId = args.chainId;
    this.derivationPath = args.derivationPath;
    this.address = args.address;
    this.origin = args.origin;
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, "").split("/");
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ""));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, "hex"));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace("0x", ""), "hex") : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
  Keys[Keys["origin"] = 3] = "origin";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId, origin) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      if (this.origin) map[Keys$1.origin] = this.origin;
      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
    this.origin = origin;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId, map[Keys$1.origin]);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

const {
  decodeToDataItem: decodeToDataItem$2
} = bcUrRegistry.extend;
var Keys$2;

(function (Keys) {
  Keys[Keys["chainId"] = 1] = "chainId";
  Keys[Keys["contractAddress"] = 2] = "contractAddress";
  Keys[Keys["contractName"] = 3] = "contractName";
  Keys[Keys["name"] = 4] = "name";
  Keys[Keys["mediaData"] = 5] = "mediaData";
})(Keys$2 || (Keys$2 = {}));

class ETHNFTItem extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_NFT_ITEM;

    this.getChainId = () => this.chainId;

    this.getName = () => this.name;

    this.getmediaData = () => this.mediaData;

    this.getContractAddress = () => this.contractAddress;

    this.getContractName = () => this.contractName;

    this.toDataItem = () => {
      const map = {};
      map[Keys$2.chainId] = this.chainId;
      map[Keys$2.name] = this.name;
      map[Keys$2.contractAddress] = this.contractAddress;
      map[Keys$2.contractName] = this.contractName;
      map[Keys$2.mediaData] = this.mediaData;
      return new bcUrRegistry.DataItem(map);
    };

    this.chainId = args.chainId;
    this.name = args.name;
    this.contractAddress = args.contractAddress;
    this.contractName = args.contractName;
    this.mediaData = args.mediaData; // remove the data perfix for android usage
  }

  static constructETHNFTItem(chainId, contractAddress, contractName, name, mediaData) {
    return new ETHNFTItem({
      chainId,
      contractAddress,
      contractName,
      mediaData,
      name
    });
  }

}

ETHNFTItem.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const chainId = map[Keys$2.chainId];
  const name = map[Keys$2.name];
  const mediaData = map[Keys$2.mediaData];
  const contractAddress = map[Keys$2.contractAddress];
  const contractName = map[Keys$2.contractName];
  return new ETHNFTItem({
    chainId,
    name,
    contractAddress,
    contractName,
    mediaData
  });
};

ETHNFTItem.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$2(_cborPayload);
  return ETHNFTItem.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressFromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = "0x" + util.publicToAddress(publicKey.publicKey, true).toString("hex");
  return util.toChecksumAddress(address);
};
const findHDPathFromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;

    const _address = generateAddressFromXpub(xpub, path);

    if (address.toLowerCase() == _address.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

bcUrRegistry.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return bcUrRegistry[k];
    }
  });
});
exports.ETHNFTItem = ETHNFTItem;
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDPathFromAddress = findHDPathFromAddress;
exports.generateAddressFromXpub = generateAddressFromXpub;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js", {"@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),a=require("uuid"),s=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("@ethereumjs/util");const r={ETH_SIGN_REQUEST:new e.RegistryType("eth-sign-request",401),ETH_SIGNATURE:new e.RegistryType("eth-signature",402),ETH_NFT_ITEM:new e.RegistryType("eth-nft-item",403)},{decodeToDataItem:n,RegistryTypes:d}=e.extend;var o,h;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(o||(o={})),(h=exports.DataType||(exports.DataType={}))[h.transaction=1]="transaction",h[h.typedData=2]="typedData",h[h.personalMessage=3]="personalMessage",h[h.typedTransaction=4]="typedTransaction";class c extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_SIGN_REQUEST,this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSourceFingerprint=()=>this.derivationPath.getSourceFingerprint(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[o.requestId]=new e.DataItem(this.requestId,d.UUID.getTag())),this.address&&(t[o.address]=this.address),this.chainId&&(t[o.chainId]=this.chainId),this.origin&&(t[o.origin]=this.origin),t[o.signData]=this.signData,t[o.dataType]=this.dataType;const a=this.derivationPath.toDataItem();return a.setTag(this.derivationPath.getRegistryType().getTag()),t[o.derivationPath]=a,new e.DataItem(t)},this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin}static constructETHRequest(t,s,i,r,n,d,o,h){const g=i.replace(/[m|M]\//,"").split("/"),u=new e.CryptoKeypath(g.map(t=>{const a=parseInt(t.replace("'",""));let s=!1;return t.endsWith("'")&&(s=!0),new e.PathComponent({index:a,hardened:s})}),Buffer.from(r,"hex"));return new c({requestId:n?Buffer.from(a.parse(n)):void 0,signData:t,dataType:s,derivationPath:u,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}c.fromDataItem=t=>{const a=t.getData(),s=a[o.signData],i=a[o.dataType],r=e.CryptoKeypath.fromDataItem(a[o.derivationPath]),n=a[o.chainId]?a[o.chainId]:void 0,d=a[o.address]?a[o.address]:void 0,h=a[o.requestId]?a[o.requestId].getData():void 0;return new c({requestId:h,signData:s,dataType:i,chainId:n,derivationPath:r,address:d,origin:a[o.origin]?a[o.origin]:void 0})},c.fromCBOR=t=>{const e=n(t);return c.fromDataItem(e)};const{RegistryTypes:g,decodeToDataItem:u}=e.extend;var m;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature",t[t.origin=3]="origin"}(m||(m={}));class I extends e.RegistryItem{constructor(t,a,s){super(),this.getRegistryType=()=>r.ETH_SIGNATURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};return this.requestId&&(t[m.requestId]=new e.DataItem(this.requestId,g.UUID.getTag())),this.origin&&(t[m.origin]=this.origin),t[m.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=a,this.origin=s}}I.fromDataItem=t=>{const e=t.getData(),a=e[m.signature],s=e[m.requestId]?e[m.requestId].getData():void 0;return new I(a,s,e[m.origin])},I.fromCBOR=t=>{const e=u(t);return I.fromDataItem(e)};const{decodeToDataItem:p}=e.extend;var D;!function(t){t[t.chainId=1]="chainId",t[t.contractAddress=2]="contractAddress",t[t.contractName=3]="contractName",t[t.name=4]="name",t[t.mediaData=5]="mediaData"}(D||(D={}));class T extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_NFT_ITEM,this.getChainId=()=>this.chainId,this.getName=()=>this.name,this.getmediaData=()=>this.mediaData,this.getContractAddress=()=>this.contractAddress,this.getContractName=()=>this.contractName,this.toDataItem=()=>{const t={};return t[D.chainId]=this.chainId,t[D.name]=this.name,t[D.contractAddress]=this.contractAddress,t[D.contractName]=this.contractName,t[D.mediaData]=this.mediaData,new e.DataItem(t)},this.chainId=t.chainId,this.name=t.name,this.contractAddress=t.contractAddress,this.contractName=t.contractName,this.mediaData=t.mediaData}static constructETHNFTItem(t,e,a,s,i){return new T({chainId:t,contractAddress:e,contractName:a,mediaData:i,name:s})}}T.fromDataItem=t=>{const e=t.getData();return new T({chainId:e[D.chainId],name:e[D.name],contractAddress:e[D.contractAddress],contractName:e[D.contractName],mediaData:e[D.mediaData]})},T.fromCBOR=t=>{const e=p(t);return T.fromDataItem(e)};const y=(t,e)=>{const a=s.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(a.publicKey,!0).toString("hex");return i.toChecksumAddress(r)};e.patchTags(Object.values(r).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHNFTItem=T,exports.ETHSignature=I,exports.EthSignRequest=c,exports.findHDPathFromAddress=(t,e,a,s)=>{for(let i=0;i<a;i++){const a=y(e,"M/0/"+i);if(t.toLowerCase()==a.toLowerCase())return`${s}/0/${i}`}return null},exports.generateAddressFromXpub=y;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js", {"./bc-ur-registry-eth.cjs.development.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CBytes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bytes = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class Bytes extends RegistryItem_1.RegistryItem {
    constructor(bytes) {
        super();
        this.bytes = bytes;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.BYTES;
        };
        this.getData = () => this.bytes;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.bytes);
        };
    }
}
exports.Bytes = Bytes;
Bytes.fromDataItem = (dataItem) => {
    const bytes = dataItem.getData();
    if (!bytes) {
        throw new Error(`#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new Bytes(bytes);
};
Bytes.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return Bytes.fromDataItem(dataItem);
};
//# sourceMappingURL=Bytes.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js", {".":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoAccount.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoAccount = void 0;
const _1 = require(".");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["outputDescriptors"] = 2] = "outputDescriptors";
})(Keys || (Keys = {}));
class CryptoAccount extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, outputDescriptors) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.outputDescriptors = outputDescriptors;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;
        };
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getOutputDescriptors = () => this.outputDescriptors;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.outputDescriptors) {
                map[Keys.outputDescriptors] = this.outputDescriptors.map((item) => item.toDataItem());
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoAccount = CryptoAccount;
CryptoAccount.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const outputDescriptors = map[Keys.outputDescriptors];
    const cryptoOutputs = outputDescriptors.map((item) => _1.CryptoOutput.fromDataItem(item));
    return new CryptoAccount(masterFingerprint, cryptoOutputs);
};
CryptoAccount.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoAccount.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoCoinInfo.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoCoinInfo = exports.Network = exports.Type = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys["type"] = "1";
    Keys["network"] = "2";
})(Keys || (Keys = {}));
var Type;
(function (Type) {
    Type[Type["bitcoin"] = 0] = "bitcoin";
})(Type = exports.Type || (exports.Type = {}));
var Network;
(function (Network) {
    Network[Network["mainnet"] = 0] = "mainnet";
    Network[Network["testnet"] = 1] = "testnet";
})(Network = exports.Network || (exports.Network = {}));
class CryptoCoinInfo extends RegistryItem_1.RegistryItem {
    constructor(type, network) {
        super();
        this.type = type;
        this.network = network;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO;
        };
        this.getType = () => {
            return this.type || Type.bitcoin;
        };
        this.getNetwork = () => {
            return this.network || Network.mainnet;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.type) {
                map[Keys.type] = this.type;
            }
            if (this.network) {
                map[Keys.network] = this.network;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoCoinInfo = CryptoCoinInfo;
CryptoCoinInfo.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys.type];
    const network = map[Keys.network];
    return new CryptoCoinInfo(type, network);
};
CryptoCoinInfo.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoCoinInfo.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoCoinInfo.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoECKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoECKey = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["curve"] = 1] = "curve";
    Keys[Keys["private"] = 2] = "private";
    Keys[Keys["data"] = 3] = "data";
})(Keys || (Keys = {}));
class CryptoECKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return true;
        };
        this.getCurve = () => this.curve || 0;
        this.isPrivateKey = () => this.privateKey || false;
        this.getData = () => this.data;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ECKEY;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.curve) {
                map[Keys.curve] = this.curve;
            }
            if (this.privateKey !== undefined) {
                map[Keys.private] = this.privateKey;
            }
            map[Keys.data] = this.data;
            return new lib_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return this.data.toString('hex');
        };
        this.data = args.data;
        this.curve = args.curve;
        this.privateKey = args.privateKey || undefined;
    }
}
exports.CryptoECKey = CryptoECKey;
CryptoECKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const curve = map[Keys.curve];
    const privateKey = map[Keys.private];
    const data = map[Keys.data];
    if (!data) {
        throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);
    }
    return new CryptoECKey({ data, curve, privateKey });
};
CryptoECKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoECKey.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoECKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js", {"./CryptoCoinInfo":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoKeypath":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","bs58check":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bs58check\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoHDKey.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoHDKey = void 0;
const bs58check_1 = require("bs58check");
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
const CryptoKeypath_1 = require("./CryptoKeypath");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["is_master"] = 1] = "is_master";
    Keys[Keys["is_private"] = 2] = "is_private";
    Keys[Keys["key_data"] = 3] = "key_data";
    Keys[Keys["chain_code"] = 4] = "chain_code";
    Keys[Keys["use_info"] = 5] = "use_info";
    Keys[Keys["origin"] = 6] = "origin";
    Keys[Keys["children"] = 7] = "children";
    Keys[Keys["parent_fingerprint"] = 8] = "parent_fingerprint";
    Keys[Keys["name"] = 9] = "name";
    Keys[Keys["note"] = 10] = "note";
})(Keys || (Keys = {}));
class CryptoHDKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return false;
        };
        this.getKey = () => this.key;
        this.getChainCode = () => this.chainCode;
        this.isMaster = () => this.master;
        this.isPrivateKey = () => !!this.privateKey;
        this.getUseInfo = () => this.useInfo;
        this.getOrigin = () => this.origin;
        this.getChildren = () => this.children;
        this.getParentFingerprint = () => this.parentFingerprint;
        this.getName = () => this.name;
        this.getNote = () => this.note;
        this.getBip32Key = () => {
            var _a, _b, _c;
            let version;
            let depth;
            let index = 0;
            let parentFingerprint = Buffer.alloc(4).fill(0);
            if (this.isMaster()) {
                version = Buffer.from('0488ADE4', 'hex');
                depth = 0;
                index = 0;
            }
            else {
                depth = ((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());
                const paths = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();
                const lastPath = paths[paths.length - 1];
                if (lastPath) {
                    index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();
                    if (this.getParentFingerprint()) {
                        parentFingerprint = this.getParentFingerprint();
                    }
                }
                if (this.isPrivateKey()) {
                    version = Buffer.from('0488ADE4', 'hex');
                }
                else {
                    version = Buffer.from('0488B21E', 'hex');
                }
            }
            const depthBuffer = Buffer.alloc(1);
            depthBuffer.writeUInt8(depth, 0);
            const indexBuffer = Buffer.alloc(4);
            indexBuffer.writeUInt32BE(index, 0);
            const chainCode = this.getChainCode();
            const key = this.getKey();
            return (0, bs58check_1.encode)(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));
        };
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;
        };
        this.getOutputDescriptorContent = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            let result = '';
            if (this.getOrigin()) {
                if (((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {
                    result += `${(_d = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString('hex')}/${(_e = this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath()}`;
                }
            }
            result += this.getBip32Key();
            if (this.getChildren()) {
                if ((_f = this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {
                    result += `/${(_g = this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath()}`;
                }
            }
            return result;
        };
        this.setupMasterKey = (args) => {
            this.master = true;
            this.key = args.key;
            this.chainCode = args.chainCode;
        };
        this.setupDeriveKey = (args) => {
            this.master = false;
            this.privateKey = args.isPrivateKey;
            this.key = args.key;
            this.chainCode = args.chainCode;
            this.useInfo = args.useInfo;
            this.origin = args.origin;
            this.children = args.children;
            this.parentFingerprint = args.parentFingerprint;
            this.name = args.name;
            this.note = args.note;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.master) {
                map[Keys.is_master] = true;
                map[Keys.key_data] = this.key;
                map[Keys.chain_code] = this.chainCode;
            }
            else {
                if (this.privateKey !== undefined) {
                    map[Keys.is_private] = this.privateKey;
                }
                map[Keys.key_data] = this.key;
                if (this.chainCode) {
                    map[Keys.chain_code] = this.chainCode;
                }
                if (this.useInfo) {
                    const useInfo = this.useInfo.toDataItem();
                    useInfo.setTag(this.useInfo.getRegistryType().getTag());
                    map[Keys.use_info] = useInfo;
                }
                if (this.origin) {
                    const origin = this.origin.toDataItem();
                    origin.setTag(this.origin.getRegistryType().getTag());
                    map[Keys.origin] = origin;
                }
                if (this.children) {
                    const children = this.children.toDataItem();
                    children.setTag(this.children.getRegistryType().getTag());
                    map[Keys.children] = children;
                }
                if (this.parentFingerprint) {
                    map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);
                }
                if (this.name !== undefined) {
                    map[Keys.name] = this.name;
                }
                if (this.note !== undefined) {
                    map[Keys.note] = this.note;
                }
            }
            return new lib_1.DataItem(map);
        };
        if (args.isMaster) {
            this.setupMasterKey(args);
        }
        else {
            this.setupDeriveKey(args);
        }
    }
}
exports.CryptoHDKey = CryptoHDKey;
CryptoHDKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const isMaster = !!map[Keys.is_master];
    const isPrivateKey = map[Keys.is_private];
    const key = map[Keys.key_data];
    const chainCode = map[Keys.chain_code];
    const useInfo = map[Keys.use_info]
        ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info])
        : undefined;
    const origin = map[Keys.origin]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin])
        : undefined;
    const children = map[Keys.children]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children])
        : undefined;
    const _parentFingerprint = map[Keys.parent_fingerprint];
    let parentFingerprint = undefined;
    if (_parentFingerprint) {
        parentFingerprint = Buffer.alloc(4);
        parentFingerprint.writeUInt32BE(_parentFingerprint, 0);
    }
    const name = map[Keys.name];
    const note = map[Keys.note];
    return new CryptoHDKey({
        isMaster,
        isPrivateKey,
        key,
        chainCode,
        useInfo,
        origin,
        children,
        parentFingerprint,
        name,
        note,
    });
};
CryptoHDKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoHDKey.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js", {"./PathComponent":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoKeypath.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoKeypath = void 0;
const lib_1 = require("./lib");
const PathComponent_1 = require("./PathComponent");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["components"] = 1] = "components";
    Keys[Keys["source_fingerprint"] = 2] = "source_fingerprint";
    Keys[Keys["depth"] = 3] = "depth";
})(Keys || (Keys = {}));
class CryptoKeypath extends RegistryItem_1.RegistryItem {
    constructor(components = [], sourceFingerprint, depth) {
        super();
        this.components = components;
        this.sourceFingerprint = sourceFingerprint;
        this.depth = depth;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;
        };
        this.getPath = () => {
            if (this.components.length === 0) {
                return undefined;
            }
            const components = this.components.map((component) => {
                return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? "'" : ''}`;
            });
            return components.join('/');
        };
        this.getComponents = () => this.components;
        this.getSourceFingerprint = () => this.sourceFingerprint;
        this.getDepth = () => this.depth;
        this.toDataItem = () => {
            const map = {};
            const components = [];
            this.components &&
                this.components.forEach((component) => {
                    if (component.isWildcard()) {
                        components.push([]);
                    }
                    else {
                        components.push(component.getIndex());
                    }
                    components.push(component.isHardened());
                });
            map[Keys.components] = components;
            if (this.sourceFingerprint) {
                map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);
            }
            if (this.depth !== undefined) {
                map[Keys.depth] = this.depth;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoKeypath = CryptoKeypath;
CryptoKeypath.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const pathComponents = [];
    const components = map[Keys.components];
    if (components) {
        for (let i = 0; i < components.length; i += 2) {
            const isHardened = components[i + 1];
            const path = components[i];
            if (typeof path === 'number') {
                pathComponents.push(new PathComponent_1.PathComponent({ index: path, hardened: isHardened }));
            }
            else {
                pathComponents.push(new PathComponent_1.PathComponent({ hardened: isHardened }));
            }
        }
    }
    const _sourceFingerprint = map[Keys.source_fingerprint];
    let sourceFingerprint;
    if (_sourceFingerprint) {
        sourceFingerprint = Buffer.alloc(4);
        sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);
    }
    const depth = map[Keys.depth];
    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);
};
CryptoKeypath.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoKeypath.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js", {"./CryptoECKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./MultiKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoOutput.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoOutput = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const lib_1 = require("./lib");
const MultiKey_1 = require("./MultiKey");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
class CryptoOutput extends RegistryItem_1.RegistryItem {
    constructor(scriptExpressions, cryptoKey) {
        super();
        this.scriptExpressions = scriptExpressions;
        this.cryptoKey = cryptoKey;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_OUTPUT;
        };
        this.getCryptoKey = () => this.cryptoKey;
        this.getHDKey = () => {
            if (this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getECKey = () => {
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getMultiKey = () => {
            if (this.cryptoKey instanceof MultiKey_1.MultiKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getScriptExpressions = () => this.scriptExpressions;
        this._toOutputDescriptor = (seIndex) => {
            if (seIndex >= this.scriptExpressions.length) {
                return this.cryptoKey.getOutputDescriptorContent();
            }
            else {
                return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;
            }
        };
        this.toString = () => {
            return this._toOutputDescriptor(0);
        };
        this.toDataItem = () => {
            let dataItem = this.cryptoKey.toDataItem();
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey ||
                this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                dataItem.setTag(this.cryptoKey.getRegistryType().getTag());
            }
            const clonedSe = [...this.scriptExpressions];
            clonedSe.reverse().forEach((se) => {
                const tagValue = se.getTag();
                if (dataItem.getTag() === undefined) {
                    dataItem.setTag(tagValue);
                }
                else {
                    dataItem = new lib_1.DataItem(dataItem, tagValue);
                }
            });
            return dataItem;
        };
    }
}
exports.CryptoOutput = CryptoOutput;
CryptoOutput.fromDataItem = (dataItem) => {
    const scriptExpressions = [];
    let _dataItem = dataItem;
    while (true) {
        let _tag = _dataItem.getTag();
        const se = ScriptExpression_1.ScriptExpression.fromTag(_tag);
        if (se) {
            scriptExpressions.push(se);
            if (_dataItem.getData() instanceof lib_1.DataItem) {
                _dataItem = _dataItem.getData();
                _tag = _dataItem.getTag();
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    const seLength = scriptExpressions.length;
    const isMultiKey = seLength > 0 &&
        (scriptExpressions[seLength - 1].getExpression() ===
            ScriptExpression_1.ScriptExpressions.MULTISIG.getExpression() ||
            scriptExpressions[seLength - 1].getExpression() ===
                ScriptExpression_1.ScriptExpressions.SORTED_MULTISIG.getExpression());
    if (isMultiKey) {
        const multiKey = MultiKey_1.MultiKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, multiKey);
    }
    if (_dataItem.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
        const cryptoHDKey = CryptoHDKey_1.CryptoHDKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoHDKey);
    }
    else {
        const cryptoECKey = CryptoECKey_1.CryptoECKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoECKey);
    }
};
CryptoOutput.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoOutput.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoOutput.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoPSBT.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoPSBT = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class CryptoPSBT extends RegistryItem_1.RegistryItem {
    constructor(psbt) {
        super();
        this.psbt = psbt;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_PSBT;
        this.getPSBT = () => this.psbt;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.psbt);
        };
    }
}
exports.CryptoPSBT = CryptoPSBT;
CryptoPSBT.fromDataItem = (dataItem) => {
    const psbt = dataItem.getData();
    if (!psbt) {
        throw new Error(`#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new CryptoPSBT(psbt);
};
CryptoPSBT.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoPSBT.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoPSBT.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js", {"..":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","../RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","@ngraveio/bc-ur":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CDecoder%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URRegistryDecoder = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const __1 = require("..");
const RegistryType_1 = require("../RegistryType");
const errors_1 = require("../errors");
class URRegistryDecoder extends bc_ur_1.URDecoder {
    constructor() {
        super(...arguments);
        this.resultRegistryType = () => {
            const ur = this.resultUR();
            switch (ur.type) {
                case RegistryType_1.RegistryTypes.BYTES.getType():
                    return __1.Bytes.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getType():
                    return __1.CryptoHDKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_KEYPATH.getType():
                    return __1.CryptoKeypath.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO.getType():
                    return __1.CryptoCoinInfo.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getType():
                    return __1.CryptoECKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_OUTPUT.getType():
                    return __1.CryptoOutput.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_PSBT.getType():
                    return __1.CryptoPSBT.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT.getType():
                    return __1.CryptoAccount.fromCBOR(ur.cbor);
                default:
                    throw new errors_1.UnknownURTypeError(`#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${ur.type} is not supported now`);
            }
        };
    }
}
exports.URRegistryDecoder = URRegistryDecoder;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js", {"./CryptoECKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib/DataItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CMultiKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiKey = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const DataItem_1 = require("./lib/DataItem");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["threshold"] = 1] = "threshold";
    Keys[Keys["keys"] = 2] = "keys";
})(Keys || (Keys = {}));
class MultiKey extends RegistryItem_1.RegistryItem {
    constructor(threshold, keys) {
        super();
        this.threshold = threshold;
        this.keys = keys;
        this.getThreshold = () => this.threshold;
        this.getKeys = () => this.keys;
        this.toDataItem = () => {
            const map = {};
            map[Keys.threshold] = this.threshold;
            const keys = this.keys.map((k) => {
                const dataItem = k.toDataItem();
                dataItem.setTag(k.getRegistryType().getTag());
                return dataItem;
            });
            map[Keys.keys] = keys;
            return new DataItem_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return [this.getThreshold(),
                this.keys.map(k => k.getOutputDescriptorContent()).join(','),
            ].join(',');
        };
    }
}
exports.MultiKey = MultiKey;
MultiKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const threshold = map[Keys.threshold];
    const _keys = map[Keys.keys];
    const keys = [];
    _keys.forEach((k) => {
        if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
            keys.push(CryptoHDKey_1.CryptoHDKey.fromDataItem(k));
        }
        else if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getTag()) {
            keys.push(CryptoECKey_1.CryptoECKey.fromDataItem(k));
        }
    });
    return new MultiKey(threshold, keys);
};
//# sourceMappingURL=MultiKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CPathComponent.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathComponent = void 0;
class PathComponent {
    constructor(args) {
        this.getIndex = () => this.index;
        this.isWildcard = () => this.wildcard;
        this.isHardened = () => this.hardened;
        this.index = args.index;
        this.hardened = args.hardened;
        if (this.index !== undefined) {
            this.wildcard = false;
        }
        else {
            this.wildcard = true;
        }
        if (this.index && (this.index & PathComponent.HARDENED_BIT) !== 0) {
            throw new Error(`#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`);
        }
    }
}
exports.PathComponent = PathComponent;
PathComponent.HARDENED_BIT = 0x80000000;
//# sourceMappingURL=PathComponent.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js", {"./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","@ngraveio/bc-ur":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryItem = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const lib_1 = require("./lib");
class RegistryItem {
    constructor() {
        this.toCBOR = () => {
            if (this.toDataItem() === undefined) {
                throw new Error(`#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`);
            }
            return (0, lib_1.encodeDataItem)(this.toDataItem());
        };
        this.toUR = () => {
            return new bc_ur_1.UR(this.toCBOR(), this.getRegistryType().getType());
        };
        this.toUREncoder = (maxFragmentLength, firstSeqNum, minFragmentLength) => {
            const ur = this.toUR();
            const urEncoder = new bc_ur_1.UREncoder(ur, maxFragmentLength, firstSeqNum, minFragmentLength);
            return urEncoder;
        };
    }
}
exports.RegistryItem = RegistryItem;
//# sourceMappingURL=RegistryItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryType.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryTypes = exports.RegistryType = void 0;
class RegistryType {
    constructor(type, tag) {
        this.type = type;
        this.tag = tag;
        this.getTag = () => this.tag;
        this.getType = () => this.type;
    }
}
exports.RegistryType = RegistryType;
exports.RegistryTypes = {
    UUID: new RegistryType('uuid', 37),
    BYTES: new RegistryType('bytes', undefined),
    CRYPTO_HDKEY: new RegistryType('crypto-hdkey', 303),
    CRYPTO_KEYPATH: new RegistryType('crypto-keypath', 304),
    CRYPTO_COIN_INFO: new RegistryType('crypto-coin-info', 305),
    CRYPTO_ECKEY: new RegistryType('crypto-eckey', 306),
    CRYPTO_OUTPUT: new RegistryType('crypto-output', 308),
    CRYPTO_PSBT: new RegistryType('crypto-psbt', 310),
    CRYPTO_ACCOUNT: new RegistryType('crypto-account', 311),
    CRYPTO_MULTI_ACCOUNTS: new RegistryType("crypto-multi-accounts", 1103),
};
//# sourceMappingURL=RegistryType.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CScriptExpression.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptExpressions = exports.ScriptExpression = void 0;
class ScriptExpression {
    constructor(tag, expression) {
        this.tag = tag;
        this.expression = expression;
        this.getTag = () => this.tag;
        this.getExpression = () => this.expression;
    }
}
exports.ScriptExpression = ScriptExpression;
ScriptExpression.fromTag = (tag) => {
    const se = Object.values(exports.ScriptExpressions).find((se) => se.getTag() === tag);
    return se;
};
exports.ScriptExpressions = {
    SCRIPT_HASH: new ScriptExpression(400, 'sh'),
    WITNESS_SCRIPT_HASH: new ScriptExpression(401, 'wsh'),
    PUBLIC_KEY: new ScriptExpression(402, 'pk'),
    PUBLIC_KEY_HASH: new ScriptExpression(403, 'pkh'),
    WITNESS_PUBLIC_KEY_HASH: new ScriptExpression(404, 'wpkh'),
    COMBO: new ScriptExpression(405, 'combo'),
    MULTISIG: new ScriptExpression(406, 'multi'),
    SORTED_MULTISIG: new ScriptExpression(407, 'sortedmulti'),
    ADDRESS: new ScriptExpression(307, 'addr'),
    RAW_SCRIPT: new ScriptExpression(408, 'raw'),
};
//# sourceMappingURL=ScriptExpression.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cerrors%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownURTypeError = void 0;
class UnknownURTypeError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.UnknownURTypeError = UnknownURTypeError;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js", {"../CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","../RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","../RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cextended%5CCryptoMultiAccounts.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoMultiAccounts = void 0;
const RegistryType_1 = require("../RegistryType");
const CryptoHDKey_1 = require("../CryptoHDKey");
const RegistryItem_1 = require("../RegistryItem");
const lib_1 = require("../lib");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["keys"] = 2] = "keys";
    Keys[Keys["device"] = 3] = "device";
})(Keys || (Keys = {}));
class CryptoMultiAccounts extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, keys, device) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.keys = keys;
        this.device = device;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_MULTI_ACCOUNTS;
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getKeys = () => this.keys;
        this.getDevice = () => this.device;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.keys) {
                map[Keys.keys] = this.keys.map((item) => {
                    const dataItem = item.toDataItem();
                    dataItem.setTag(item.getRegistryType().getTag());
                    return dataItem;
                });
            }
            if (this.device) {
                map[Keys.device] = this.device;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoMultiAccounts = CryptoMultiAccounts;
CryptoMultiAccounts.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const keys = map[Keys.keys];
    const cryptoHDKeys = keys.map((item) => CryptoHDKey_1.CryptoHDKey.fromDataItem(item));
    const device = map[Keys.device];
    return new CryptoMultiAccounts(masterFingerprint, cryptoHDKeys, device);
};
CryptoMultiAccounts.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoMultiAccounts.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js", {"./Bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js","./CryptoAccount":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js","./CryptoCoinInfo":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoECKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./CryptoKeypath":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./CryptoOutput":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js","./CryptoPSBT":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js","./Decoder":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js","./MultiKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./PathComponent":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","./extended/CryptoMultiAccounts":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","./patchCBOR":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js","./types":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js","./utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js","buffer/":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\buffer\\index.js","tslib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\tslib\\tslib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Buffer = exports.extend = exports.PathComponent = exports.ScriptExpressions = exports.MultiKey = exports.CryptoPSBT = exports.CryptoOutput = exports.CryptoECKey = exports.CryptoCoinInfoNetwork = exports.CryptoCoinInfoType = exports.CryptoCoinInfo = exports.CryptoKeypath = exports.CryptoMultiAccounts = exports.CryptoHDKey = exports.CryptoAccount = exports.Bytes = exports.URRegistryDecoder = exports.DataItem = void 0;
const tslib_1 = require("tslib");
require("./patchCBOR");
const buffer_1 = require("buffer/");
Object.defineProperty(exports, "Buffer", { enumerable: true, get: function () { return buffer_1.Buffer; } });
const CryptoHDKey_1 = require("./CryptoHDKey");
Object.defineProperty(exports, "CryptoHDKey", { enumerable: true, get: function () { return CryptoHDKey_1.CryptoHDKey; } });
const CryptoKeypath_1 = require("./CryptoKeypath");
Object.defineProperty(exports, "CryptoKeypath", { enumerable: true, get: function () { return CryptoKeypath_1.CryptoKeypath; } });
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
Object.defineProperty(exports, "CryptoCoinInfo", { enumerable: true, get: function () { return CryptoCoinInfo_1.CryptoCoinInfo; } });
Object.defineProperty(exports, "CryptoCoinInfoType", { enumerable: true, get: function () { return CryptoCoinInfo_1.Type; } });
Object.defineProperty(exports, "CryptoCoinInfoNetwork", { enumerable: true, get: function () { return CryptoCoinInfo_1.Network; } });
const CryptoECKey_1 = require("./CryptoECKey");
Object.defineProperty(exports, "CryptoECKey", { enumerable: true, get: function () { return CryptoECKey_1.CryptoECKey; } });
const Bytes_1 = require("./Bytes");
Object.defineProperty(exports, "Bytes", { enumerable: true, get: function () { return Bytes_1.Bytes; } });
const CryptoOutput_1 = require("./CryptoOutput");
Object.defineProperty(exports, "CryptoOutput", { enumerable: true, get: function () { return CryptoOutput_1.CryptoOutput; } });
const CryptoPSBT_1 = require("./CryptoPSBT");
Object.defineProperty(exports, "CryptoPSBT", { enumerable: true, get: function () { return CryptoPSBT_1.CryptoPSBT; } });
const CryptoAccount_1 = require("./CryptoAccount");
Object.defineProperty(exports, "CryptoAccount", { enumerable: true, get: function () { return CryptoAccount_1.CryptoAccount; } });
const Decoder_1 = require("./Decoder");
Object.defineProperty(exports, "URRegistryDecoder", { enumerable: true, get: function () { return Decoder_1.URRegistryDecoder; } });
const MultiKey_1 = require("./MultiKey");
Object.defineProperty(exports, "MultiKey", { enumerable: true, get: function () { return MultiKey_1.MultiKey; } });
const ScriptExpression_1 = require("./ScriptExpression");
Object.defineProperty(exports, "ScriptExpressions", { enumerable: true, get: function () { return ScriptExpression_1.ScriptExpressions; } });
const PathComponent_1 = require("./PathComponent");
Object.defineProperty(exports, "PathComponent", { enumerable: true, get: function () { return PathComponent_1.PathComponent; } });
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const lib_1 = require("./lib");
var lib_2 = require("./lib");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return lib_2.DataItem; } });
const utils_1 = require("./utils");
const CryptoMultiAccounts_1 = require("./extended/CryptoMultiAccounts");
Object.defineProperty(exports, "CryptoMultiAccounts", { enumerable: true, get: function () { return CryptoMultiAccounts_1.CryptoMultiAccounts; } });
const URlib = {
    URRegistryDecoder: Decoder_1.URRegistryDecoder,
    Bytes: Bytes_1.Bytes,
    CryptoAccount: CryptoAccount_1.CryptoAccount,
    CryptoHDKey: CryptoHDKey_1.CryptoHDKey,
    CryptoMultiAccounts: CryptoMultiAccounts_1.CryptoMultiAccounts,
    CryptoKeypath: CryptoKeypath_1.CryptoKeypath,
    CryptoCoinInfo: CryptoCoinInfo_1.CryptoCoinInfo,
    CryptoCoinInfoType: CryptoCoinInfo_1.Type,
    CryptoCoinInfoNetwork: CryptoCoinInfo_1.Network,
    CryptoECKey: CryptoECKey_1.CryptoECKey,
    CryptoOutput: CryptoOutput_1.CryptoOutput,
    CryptoPSBT: CryptoPSBT_1.CryptoPSBT,
    MultiKey: MultiKey_1.MultiKey,
    ScriptExpressions: ScriptExpression_1.ScriptExpressions,
    PathComponent: PathComponent_1.PathComponent,
};
const cbor = {
    addReader: lib_1.addReader,
    addSemanticDecode: lib_1.addSemanticDecode,
    addSemanticEncode: lib_1.addSemanticEncode,
    addWriter: lib_1.addWriter,
    patchTags: utils_1.patchTags,
};
const extend = {
    RegistryTypes: RegistryType_1.RegistryTypes,
    RegistryItem: RegistryItem_1.RegistryItem,
    RegistryType: RegistryType_1.RegistryType,
    decodeToDataItem: lib_1.decodeToDataItem,
    encodeDataItem: lib_1.encodeDataItem,
    cbor,
};
exports.extend = extend;
(0, tslib_1.__exportStar)(require("./errors"), exports);
(0, tslib_1.__exportStar)(require("./Decoder"), exports);
(0, tslib_1.__exportStar)(require("./lib"), exports);
(0, tslib_1.__exportStar)(require("./CryptoAccount"), exports);
(0, tslib_1.__exportStar)(require("./CryptoPSBT"), exports);
(0, tslib_1.__exportStar)(require("./CryptoHDKey"), exports);
(0, tslib_1.__exportStar)(require("./extended/CryptoMultiAccounts"), exports);
(0, tslib_1.__exportStar)(require("./CryptoOutput"), exports);
(0, tslib_1.__exportStar)(require("./CryptoCoinInfo"), exports);
(0, tslib_1.__exportStar)(require("./CryptoECKey"), exports);
(0, tslib_1.__exportStar)(require("./MultiKey"), exports);
(0, tslib_1.__exportStar)(require("./CryptoKeypath"), exports);
(0, tslib_1.__exportStar)(require("./patchCBOR"), exports);
(0, tslib_1.__exportStar)(require("./PathComponent"), exports);
(0, tslib_1.__exportStar)(require("./RegistryItem"), exports);
(0, tslib_1.__exportStar)(require("./RegistryType"), exports);
(0, tslib_1.__exportStar)(require("./types"), exports);
(0, tslib_1.__exportStar)(require("./utils"), exports);
exports.default = URlib;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5CDataItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = void 0;
class DataItem {
    constructor(data, tag) {
        this.setTag = (tag) => {
            this.tag = tag;
        };
        this.clearTag = () => {
            this.tag = undefined;
        };
        this.getTag = () => {
            return this.tag;
        };
        this.getData = () => {
            return this.data;
        };
        this.data = data;
        this.tag = tag;
    }
}
exports.DataItem = DataItem;
//# sourceMappingURL=DataItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js", {"./DataItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Ccbor-sync.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    }
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else {
        global.CBOR = factory();
    }
})(this, function () {
    const { DataItem } = require('./DataItem');
    var CBOR = (function () {
        function BinaryHex(hex) {
            this.$hex = hex;
        }
        BinaryHex.prototype = {
            length: function () {
                return this.$hex.length / 2;
            },
            toString: function (format) {
                if (!format || format === 'hex' || format === 16)
                    return this.$hex;
                if (format === 'utf-8') {
                    var encoded = '';
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded += '%' + this.$hex.substring(i, i + 2);
                    }
                    return decodeURIComponent(encoded);
                }
                if (format === 'latin') {
                    var encoded = [];
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
                    }
                    return String.fromCharCode.apply(String, encoded);
                }
                throw new Error('Unrecognised format: ' + format);
            },
        };
        BinaryHex.fromLatinString = function (latinString) {
            var hex = '';
            for (var i = 0; i < latinString.length; i++) {
                var pair = latinString.charCodeAt(i).toString(16);
                if (pair.length === 1)
                    pair = '0' + pair;
                hex += pair;
            }
            return new BinaryHex(hex);
        };
        BinaryHex.fromUtf8String = function (utf8String) {
            var encoded = encodeURIComponent(utf8String);
            var hex = '';
            for (var i = 0; i < encoded.length; i++) {
                if (encoded.charAt(i) === '%') {
                    hex += encoded.substring(i + 1, i + 3);
                    i += 2;
                }
                else {
                    var hexPair = encoded.charCodeAt(i).toString(16);
                    if (hexPair.length < 2)
                        hexPair = '0' + hexPair;
                    hex += hexPair;
                }
            }
            return new BinaryHex(hex);
        };
        var semanticEncoders = [];
        var semanticDecoders = {};
        var notImplemented = function (label) {
            return function () {
                throw new Error(label + ' not implemented');
            };
        };
        function Reader() { }
        Reader.prototype = {
            peekByte: notImplemented('peekByte'),
            readByte: notImplemented('readByte'),
            readChunk: notImplemented('readChunk'),
            readFloat16: function () {
                var half = this.readUint16();
                var exponent = (half & 0x7fff) >> 10;
                var mantissa = half & 0x3ff;
                var negative = half & 0x8000;
                if (exponent === 0x1f) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 25) * (1024 + mantissa)
                    : Math.pow(2, -24) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat32: function () {
                var intValue = this.readUint32();
                var exponent = (intValue & 0x7fffffff) >> 23;
                var mantissa = intValue & 0x7fffff;
                var negative = intValue & 0x80000000;
                if (exponent === 0xff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa)
                    : Math.pow(2, -23 - 126) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat64: function () {
                var int1 = this.readUint32(), int2 = this.readUint32();
                var exponent = (int1 >> 20) & 0x7ff;
                var mantissa = (int1 & 0xfffff) * 4294967296 + int2;
                var negative = int1 & 0x80000000;
                if (exponent === 0x7ff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa)
                    : Math.pow(2, -52 - 1022) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readUint16: function () {
                return this.readByte() * 256 + this.readByte();
            },
            readUint32: function () {
                return this.readUint16() * 65536 + this.readUint16();
            },
            readUint64: function () {
                return this.readUint32() * 4294967296 + this.readUint32();
            },
        };
        function Writer() { }
        Writer.prototype = {
            writeByte: notImplemented('writeByte'),
            result: notImplemented('result'),
            writeFloat16: notImplemented('writeFloat16'),
            writeFloat32: notImplemented('writeFloat32'),
            writeFloat64: notImplemented('writeFloat64'),
            writeUint16: function (value) {
                this.writeByte((value >> 8) & 0xff);
                this.writeByte(value & 0xff);
            },
            writeUint32: function (value) {
                this.writeUint16((value >> 16) & 0xffff);
                this.writeUint16(value & 0xffff);
            },
            writeUint64: function (value) {
                if (value >= 9007199254740992 || value <= -9007199254740992) {
                    throw new Error('Cannot encode Uint64 of: ' +
                        value +
                        ' magnitude to big (floating point errors)');
                }
                this.writeUint32(Math.floor(value / 4294967296));
                this.writeUint32(value % 4294967296);
            },
            writeString: notImplemented('writeString'),
            canWriteBinary: function (chunk) {
                return false;
            },
            writeBinary: notImplemented('writeChunk'),
        };
        function readHeaderRaw(reader) {
            var firstByte = reader.readByte();
            var majorType = firstByte >> 5, value = firstByte & 0x1f;
            return { type: majorType, value: value };
        }
        function valueFromHeader(header, reader) {
            var value = header.value;
            if (value < 24) {
                return value;
            }
            else if (value == 24) {
                return reader.readByte();
            }
            else if (value == 25) {
                return reader.readUint16();
            }
            else if (value == 26) {
                return reader.readUint32();
            }
            else if (value == 27) {
                return reader.readUint64();
            }
            else if (value == 31) {
                return null;
            }
            notImplemented('Additional info: ' + value)();
        }
        function writeHeaderRaw(type, value, writer) {
            writer.writeByte((type << 5) | value);
        }
        function writeHeader(type, value, writer) {
            var firstByte = type << 5;
            if (value < 24) {
                writer.writeByte(firstByte | value);
            }
            else if (value < 256) {
                writer.writeByte(firstByte | 24);
                writer.writeByte(value);
            }
            else if (value < 65536) {
                writer.writeByte(firstByte | 25);
                writer.writeUint16(value);
            }
            else if (value < 4294967296) {
                writer.writeByte(firstByte | 26);
                writer.writeUint32(value);
            }
            else {
                writer.writeByte(firstByte | 27);
                writer.writeUint64(value);
            }
        }
        var stopCode = new Error();
        function decodeReader(reader) {
            var header = readHeaderRaw(reader);
            switch (header.type) {
                case 0:
                    return valueFromHeader(header, reader);
                case 1:
                    return -1 - valueFromHeader(header, reader);
                case 2:
                    return reader.readChunk(valueFromHeader(header, reader));
                case 3:
                    var buffer = reader.readChunk(valueFromHeader(header, reader));
                    return buffer.toString('utf-8');
                case 4:
                case 5:
                    var arrayLength = valueFromHeader(header, reader);
                    var result = [];
                    if (arrayLength !== null) {
                        if (header.type === 5) {
                            arrayLength *= 2;
                        }
                        for (var i = 0; i < arrayLength; i++) {
                            result[i] = decodeReader(reader);
                        }
                    }
                    else {
                        var item;
                        while ((item = decodeReader(reader)) !== stopCode) {
                            result.push(item);
                        }
                    }
                    if (header.type === 5) {
                        var objResult = {};
                        for (var i = 0; i < result.length; i += 2) {
                            objResult[result[i]] = result[i + 1];
                        }
                        return objResult;
                    }
                    else {
                        return result;
                    }
                case 6:
                    var tag = valueFromHeader(header, reader);
                    var decoder = semanticDecoders[tag];
                    var result = decodeReader(reader);
                    return decoder ? decoder(result) : result;
                case 7:
                    if (header.value === 25) {
                        return reader.readFloat16();
                    }
                    else if (header.value === 26) {
                        return reader.readFloat32();
                    }
                    else if (header.value === 27) {
                        return reader.readFloat64();
                    }
                    switch (valueFromHeader(header, reader)) {
                        case 20:
                            return false;
                        case 21:
                            return true;
                        case 22:
                            return null;
                        case 23:
                            return undefined;
                        case null:
                            return stopCode;
                        default:
                            throw new Error('Unknown fixed value: ' + header.value);
                    }
                default:
                    throw new Error('Unsupported header: ' + JSON.stringify(header));
            }
            throw new Error('not implemented yet');
        }
        function encodeWriter(data, writer) {
            for (var i = 0; i < semanticEncoders.length; i++) {
                var replacement = semanticEncoders[i].fn(data);
                if (replacement !== undefined) {
                    writeHeader(6, semanticEncoders[i].tag, writer);
                    return encodeWriter(replacement, writer);
                }
            }
            if (data && typeof data.toCBOR === 'function') {
                data = data.toCBOR();
            }
            if (data === false) {
                writeHeader(7, 20, writer);
            }
            else if (data === true) {
                writeHeader(7, 21, writer);
            }
            else if (data === null) {
                writeHeader(7, 22, writer);
            }
            else if (data === undefined) {
                writeHeader(7, 23, writer);
            }
            else if (typeof data === 'number') {
                if (Math.floor(data) === data &&
                    data < 9007199254740992 &&
                    data > -9007199254740992) {
                    if (data < 0) {
                        writeHeader(1, -1 - data, writer);
                    }
                    else {
                        writeHeader(0, data, writer);
                    }
                }
                else {
                    writeHeaderRaw(7, 27, writer);
                    writer.writeFloat64(data);
                }
            }
            else if (typeof data === 'string') {
                writer.writeString(data, function (length) {
                    writeHeader(3, length, writer);
                });
            }
            else if (writer.canWriteBinary(data)) {
                writer.writeBinary(data, function (length) {
                    writeHeader(2, length, writer);
                });
            }
            else if (typeof data === 'object') {
                if (api.config.useToJSON && typeof data.toJSON === 'function') {
                    data = data.toJSON();
                }
                if (Array.isArray(data)) {
                    writeHeader(4, data.length, writer);
                    for (var i = 0; i < data.length; i++) {
                        encodeWriter(data[i], writer);
                    }
                }
                else {
                    var keys = Object.keys(data);
                    writeHeader(5, keys.length, writer);
                    for (var i = 0; i < keys.length; i++) {
                        const number = parseInt(keys[i]);
                        if (isNaN(number)) {
                            encodeWriter(keys[i], writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                        else {
                            encodeWriter(number, writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                    }
                }
            }
            else {
                throw new Error('CBOR encoding not supported: ' + data);
            }
        }
        var readerFunctions = [];
        var writerFunctions = [];
        var api = {
            config: {
                useToJSON: true,
            },
            addWriter: function (format, writerFunction) {
                if (typeof format === 'string') {
                    writerFunctions.push(function (f) {
                        if (format === f)
                            return writerFunction(f);
                    });
                }
                else {
                    writerFunctions.push(format);
                }
            },
            addReader: function (format, readerFunction) {
                if (typeof format === 'string') {
                    readerFunctions.push(function (data, f) {
                        if (format === f)
                            return readerFunction(data, f);
                    });
                }
                else {
                    readerFunctions.push(format);
                }
            },
            encode: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        encodeWriter(data, writer);
                        return writer.result();
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            encodeDataItem: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        if (data.getTag() !== undefined) {
                            encodeWriter(data, writer);
                            return writer.result();
                        }
                        else {
                            encodeWriter(data.getData(), writer);
                            return writer.result();
                        }
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            decode: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        return decodeReader(reader);
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            decodeToDataItem: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        const result = decodeReader(reader);
                        if (result instanceof DataItem) {
                            return result;
                        }
                        else {
                            return new DataItem(result);
                        }
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            addSemanticEncode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticEncoders.push({ tag: tag, fn: fn });
                return this;
            },
            addSemanticDecode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticDecoders[tag] = fn;
                return this;
            },
        };
        function BufferReader(buffer) {
            this.buffer = buffer;
            this.pos = 0;
        }
        BufferReader.prototype = Object.create(Reader.prototype);
        BufferReader.prototype.peekByte = function () {
            return this.buffer[this.pos];
        };
        BufferReader.prototype.readByte = function () {
            return this.buffer[this.pos++];
        };
        BufferReader.prototype.readUint16 = function () {
            var result = this.buffer.readUInt16BE(this.pos);
            this.pos += 2;
            return result;
        };
        BufferReader.prototype.readUint32 = function () {
            var result = this.buffer.readUInt32BE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat32 = function () {
            var result = this.buffer.readFloatBE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat64 = function () {
            var result = this.buffer.readDoubleBE(this.pos);
            this.pos += 8;
            return result;
        };
        BufferReader.prototype.readChunk = function (length) {
            var result = Buffer.alloc(length);
            this.buffer.copy(result, 0, this.pos, (this.pos += length));
            return result;
        };
        function BufferWriter(stringFormat) {
            this.byteLength = 0;
            this.defaultBufferLength = 16384;
            this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
            this.completeBuffers = [];
            this.stringFormat = stringFormat;
        }
        BufferWriter.prototype = Object.create(Writer.prototype);
        BufferWriter.prototype.writeByte = function (value) {
            this.latestBuffer[this.latestBufferOffset++] = value;
            if (this.latestBufferOffset >= this.latestBuffer.length) {
                this.completeBuffers.push(this.latestBuffer);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength++;
        };
        BufferWriter.prototype.writeFloat32 = function (value) {
            var buffer = Buffer.alloc(4);
            buffer.writeFloatBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeFloat64 = function (value) {
            var buffer = Buffer.alloc(8);
            buffer.writeDoubleBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeString = function (string, lengthFunc) {
            var buffer = Buffer.from(string, 'utf-8');
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.canWriteBinary = function (data) {
            return data instanceof Buffer;
        };
        BufferWriter.prototype.writeBinary = function (buffer, lengthFunc) {
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeBuffer = function (chunk) {
            if (!(chunk instanceof Buffer))
                throw new TypeError('BufferWriter only accepts Buffers');
            if (!this.latestBufferOffset) {
                this.completeBuffers.push(chunk);
            }
            else if (this.latestBuffer.length - this.latestBufferOffset >=
                chunk.length) {
                chunk.copy(this.latestBuffer, this.latestBufferOffset);
                this.latestBufferOffset += chunk.length;
                if (this.latestBufferOffset >= this.latestBuffer.length) {
                    this.completeBuffers.push(this.latestBuffer);
                    this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                    this.latestBufferOffset = 0;
                }
            }
            else {
                this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
                this.completeBuffers.push(chunk);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength += chunk.length;
        };
        BufferWriter.prototype.result = function () {
            var result = Buffer.alloc(this.byteLength);
            var offset = 0;
            for (var i = 0; i < this.completeBuffers.length; i++) {
                var buffer = this.completeBuffers[i];
                buffer.copy(result, offset, 0, buffer.length);
                offset += buffer.length;
            }
            if (this.latestBufferOffset) {
                this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
            }
            if (this.stringFormat)
                return result.toString(this.stringFormat);
            return result;
        };
        if (typeof Buffer === 'function') {
            api.addReader(function (data, format) {
                if (Buffer.isBuffer(data)) {
                    return new BufferReader(data);
                }
                if (format === 'hex' || format === 'base64') {
                    var buffer = Buffer.from(data, format);
                    return new BufferReader(buffer);
                }
            });
            api.addWriter(function (format) {
                if (!format || format === 'buffer') {
                    return new BufferWriter();
                }
                else if (format === 'hex' || format === 'base64') {
                    return new BufferWriter(format);
                }
            });
        }
        function HexReader(hex) {
            this.hex = hex;
            this.pos = 0;
        }
        HexReader.prototype = Object.create(Reader.prototype);
        HexReader.prototype.peekByte = function () {
            var pair = this.hex.substring(this.pos, 2);
            return parseInt(pair, 16);
        };
        HexReader.prototype.readByte = function () {
            var pair = this.hex.substring(this.pos, this.pos + 2);
            this.pos += 2;
            return parseInt(pair, 16);
        };
        HexReader.prototype.readChunk = function (length) {
            var hex = this.hex.substring(this.pos, this.pos + length * 2);
            this.pos += length * 2;
            if (typeof Buffer === 'function')
                return Buffer.from(hex, 'hex');
            return new BinaryHex(hex);
        };
        function HexWriter(finalFormat) {
            this.$hex = '';
            this.finalFormat = finalFormat || 'hex';
        }
        HexWriter.prototype = Object.create(Writer.prototype);
        HexWriter.prototype.writeByte = function (value) {
            if (value < 0 || value > 255)
                throw new Error('Byte value out of range: ' + value);
            var hex = value.toString(16);
            if (hex.length == 1) {
                hex = '0' + hex;
            }
            this.$hex += hex;
        };
        HexWriter.prototype.canWriteBinary = function (chunk) {
            return (chunk instanceof BinaryHex ||
                (typeof Buffer === 'function' && chunk instanceof Buffer));
        };
        HexWriter.prototype.writeBinary = function (chunk, lengthFunction) {
            if (chunk instanceof BinaryHex) {
                lengthFunction(chunk.length());
                this.$hex += chunk.$hex;
            }
            else if (typeof Buffer === 'function' && chunk instanceof Buffer) {
                lengthFunction(chunk.length);
                this.$hex += chunk.toString('hex');
            }
            else {
                throw new TypeError('HexWriter only accepts BinaryHex or Buffers');
            }
        };
        HexWriter.prototype.result = function () {
            if (this.finalFormat === 'buffer' && typeof Buffer === 'function') {
                return Buffer.from(this.$hex, 'hex');
            }
            return new BinaryHex(this.$hex).toString(this.finalFormat);
        };
        HexWriter.prototype.writeString = function (string, lengthFunction) {
            var buffer = BinaryHex.fromUtf8String(string);
            lengthFunction(buffer.length());
            this.$hex += buffer.$hex;
        };
        api.addReader(function (data, format) {
            if (data instanceof BinaryHex || data.$hex) {
                return new HexReader(data.$hex);
            }
            if (format === 'hex') {
                return new HexReader(data);
            }
        });
        api.addWriter(function (format) {
            if (format === 'hex') {
                return new HexWriter();
            }
        });
        return api;
    })();
    CBOR.addSemanticEncode(0, function (data) {
        if (data instanceof Date) {
            return data.toISOString();
        }
    })
        .addSemanticDecode(0, function (isoString) {
        return new Date(isoString);
    })
        .addSemanticDecode(1, function (isoString) {
        return new Date(isoString);
    });
    return CBOR;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js", {"./DataItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","./cbor-sync":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = exports.addWriter = exports.addReader = exports.addSemanticEncode = exports.addSemanticDecode = exports.decodeToDataItem = exports.encodeDataItem = void 0;
var cbor_sync_1 = require("./cbor-sync");
Object.defineProperty(exports, "encodeDataItem", { enumerable: true, get: function () { return cbor_sync_1.encodeDataItem; } });
Object.defineProperty(exports, "decodeToDataItem", { enumerable: true, get: function () { return cbor_sync_1.decodeToDataItem; } });
Object.defineProperty(exports, "addSemanticDecode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticDecode; } });
Object.defineProperty(exports, "addSemanticEncode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticEncode; } });
Object.defineProperty(exports, "addReader", { enumerable: true, get: function () { return cbor_sync_1.addReader; } });
Object.defineProperty(exports, "addWriter", { enumerable: true, get: function () { return cbor_sync_1.addWriter; } });
var DataItem_1 = require("./DataItem");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return DataItem_1.DataItem; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js", {"./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CpatchCBOR.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
const registryTags = Object.values(RegistryType_1.RegistryTypes)
    .filter((r) => !!r.getTag())
    .map((r) => r.getTag());
const scriptExpressionTags = Object.values(ScriptExpression_1.ScriptExpressions).map((se) => se.getTag());
(0, utils_1.patchTags)(registryTags.concat(scriptExpressionTags));
//# sourceMappingURL=patchCBOR.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js", {"./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchTags = void 0;
const lib_1 = require("./lib");
const alreadyPatchedTag = [];
const patchTags = (tags) => {
    tags.forEach((tag) => {
        if (alreadyPatchedTag.find((i) => i === tag))
            return;
        (0, lib_1.addSemanticEncode)(tag, (data) => {
            if (data instanceof lib_1.DataItem) {
                if (data.getTag() === tag) {
                    return data.getData();
                }
            }
        });
        (0, lib_1.addSemanticDecode)(tag, (data) => {
            return new lib_1.DataItem(data, tag);
        });
        alreadyPatchedTag.push(tag);
    });
};
exports.patchTags = patchTags;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5Crlp%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.decode = exports.encode = void 0;
/**
 * RLP Encoding based on https://eth.wiki/en/fundamentals/rlp
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        const buf = concatBytes(...output);
        return concatBytes(encodeLength(buf.length, 192), buf);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
exports.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
exports.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
exports.utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes,
};
const RLP = { encode, decode };
exports.default = RLP;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>rlp",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js", {"./metamask-airgapped-keyring.cjs.development.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js","./metamask-airgapped-keyring.cjs.production.min.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./metamask-airgapped-keyring.cjs.production.min.js')
} else {
  module.exports = require('./metamask-airgapped-keyring.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js", {"@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@keystonehq/base-eth-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cmetamask-airgapped-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var baseEthKeyring = require('@keystonehq/base-eth-keyring');
var events = require('events');
var obsStore = require('@metamask/obs-store');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');
var tx = require('@ethereumjs/tx');
var rlp = _interopDefault(require('rlp'));

class MetamaskInteractionProvider extends events.EventEmitter {
  constructor() {
    super();

    this.cleanSyncListeners = () => {
      this.removeAllListeners("keystone-sync_success-hdkey");
      this.removeAllListeners("keystone-sync_success-account");
      this.removeAllListeners("keystone-sync_cancel");
    };

    this.cleanSignListeners = requestId => {
      this.removeAllListeners(`${requestId}-signed`);
      this.removeAllListeners(`${requestId}-canceled`);
    };

    this.readCryptoHDKeyOrCryptoAccount = () => {
      return new Promise((resolve, reject) => {
        this.memStore.updateState({
          sync: {
            reading: true
          }
        });
        this.on("keystone-sync_success-hdkey", cbor => {
          const cryptoHDKey = bcUrRegistryEth.CryptoHDKey.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoHDKey);
        });
        this.on("keystone-sync_success-account", cbor => {
          const cryptoAccount = bcUrRegistryEth.CryptoAccount.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoAccount);
        });
        this.on("keystone-sync_cancel", () => {
          this.resetState();
          reject(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"));
        });
      });
    };

    this.submitCryptoHDKey = cbor => {
      this.emit("keystone-sync_success-hdkey", cbor);
    };

    this.submitCryptoAccount = cbor => {
      this.emit("keystone-sync_success-account", cbor);
    };

    this.cancelSync = () => {
      this.emit("keystone-sync_cancel");
    };

    this.requestSignature = (signRequest, requestTitle, requestDescription) => {
      return new Promise((resolve, reject) => {
        const ur = signRequest.toUR();
        const requestIdBuffer = signRequest.getRequestId();
        const requestId = uuid.stringify(requestIdBuffer);
        const signPayload = {
          requestId,
          payload: {
            type: ur.type,
            cbor: ur.cbor.toString("hex")
          },
          title: requestTitle,
          description: requestDescription
        };
        this.memStore.updateState({
          sign: {
            request: signPayload
          }
        });
        this.once(`${requestId}-signed`, cbor => {
          const ethSignature = bcUrRegistryEth.ETHSignature.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(ethSignature);
        });
        this.once(`${requestId}-canceled`, () => {
          this.resetState();
          reject(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"));
        });
      });
    };

    this.submitSignature = (requestId, cbor) => {
      this.emit(`${requestId}-signed`, cbor);
    };

    this.cancelRequestSignature = () => {
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.memStore.updateState({
          sign: {}
        });
        this.emit(`${requestId}-canceled`);
      }
    };

    this.reset = () => {
      this.cleanSyncListeners();
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.cleanSignListeners(requestId);
      }

      this.resetState();
    };

    this.resetState = () => {
      this.memStore.updateState({
        sync: {
          reading: false
        },
        sign: {}
      });
    };

    if (MetamaskInteractionProvider.instance) {
      return MetamaskInteractionProvider.instance;
    }

    this.memStore = new obsStore.ObservableStore({
      sync: {
        reading: false
      },
      sign: {},
      _version: 1
    });
    MetamaskInteractionProvider.instance = this;
  }

}

class MetaMaskKeyring extends baseEthKeyring.BaseKeyring {
  constructor(opts) {
    super(opts);

    this.getInteraction = () => {
      return new MetamaskInteractionProvider();
    };

    this.resetStore = () => {
      this.getInteraction().reset();
    };

    this.getMemStore = () => {
      return this.getInteraction().memStore;
    };

    this.removeAccount = address => {
      if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new Error(`Address ${address} not found in this keyring`);
      }

      this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
    };

    this.forgetDevice = () => {
      //common props
      this.page = 0;
      this.perPage = 5;
      this.accounts = [];
      this.currentAccount = 0;
      this.name = "QR Hardware";
      this.initialized = false; //hd props;

      this.xfp = "";
      this.xpub = "";
      this.hdPath = "";
      this.indexes = {};
      this.hdk = undefined; //pubkey props;

      this.paths = {};
    };

    this.submitCryptoHDKey = this.getInteraction().submitCryptoHDKey;
    this.submitCryptoAccount = this.getInteraction().submitCryptoAccount;
    this.submitSignature = this.getInteraction().submitSignature;
    this.cancelSync = this.getInteraction().cancelSync;
    this.cancelSignRequest = this.getInteraction().cancelRequestSignature;

    if (MetaMaskKeyring.instance) {
      MetaMaskKeyring.instance.deserialize(opts);
      return MetaMaskKeyring.instance;
    }

    MetaMaskKeyring.instance = this;
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = rlp.encode(tx$1.getMessageToSign(false));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId, address);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    txJson.v = v;
    txJson.s = s;
    txJson.r = r;
    txJson.type = tx$1.type;
    const transaction = tx.TransactionFactory.fromTxData(txJson, {
      common: tx$1.common
    });
    return transaction;
  }

}
MetaMaskKeyring.type = baseEthKeyring.BaseKeyring.type;

exports.MetaMaskKeyring = MetaMaskKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js", {"@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@keystonehq/base-eth-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cmetamask-airgapped-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("@keystonehq/base-eth-keyring"),s=require("events"),n=require("@metamask/obs-store"),i=require("@keystonehq/bc-ur-registry-eth"),r=require("uuid"),c=require("@ethereumjs/tx"),o=(e=require("rlp"))&&"object"==typeof e&&"default"in e?e.default:e;class a extends s.EventEmitter{constructor(){if(super(),this.cleanSyncListeners=()=>{this.removeAllListeners("keystone-sync_success-hdkey"),this.removeAllListeners("keystone-sync_success-account"),this.removeAllListeners("keystone-sync_cancel")},this.cleanSignListeners=e=>{this.removeAllListeners(e+"-signed"),this.removeAllListeners(e+"-canceled")},this.readCryptoHDKeyOrCryptoAccount=()=>new Promise((e,t)=>{this.memStore.updateState({sync:{reading:!0}}),this.on("keystone-sync_success-hdkey",t=>{const s=i.CryptoHDKey.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_success-account",t=>{const s=i.CryptoAccount.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_cancel",()=>{this.resetState(),t(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"))})}),this.submitCryptoHDKey=e=>{this.emit("keystone-sync_success-hdkey",e)},this.submitCryptoAccount=e=>{this.emit("keystone-sync_success-account",e)},this.cancelSync=()=>{this.emit("keystone-sync_cancel")},this.requestSignature=(e,t,s)=>new Promise((n,c)=>{const o=e.toUR(),a=e.getRequestId(),h=r.stringify(a),u={requestId:h,payload:{type:o.type,cbor:o.cbor.toString("hex")},title:t,description:s};this.memStore.updateState({sign:{request:u}}),this.once(h+"-signed",e=>{const t=i.ETHSignature.fromCBOR(Buffer.from(e,"hex"));this.resetState(),n(t)}),this.once(h+"-canceled",()=>{this.resetState(),c(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"))})}),this.submitSignature=(e,t)=>{this.emit(e+"-signed",t)},this.cancelRequestSignature=()=>{const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.memStore.updateState({sign:{}}),this.emit(t+"-canceled")}},this.reset=()=>{this.cleanSyncListeners();const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.cleanSignListeners(t)}this.resetState()},this.resetState=()=>{this.memStore.updateState({sync:{reading:!1},sign:{}})},a.instance)return a.instance;this.memStore=new n.ObservableStore({sync:{reading:!1},sign:{},_version:1}),a.instance=this}}class h extends t.BaseKeyring{constructor(e){if(super(e),this.getInteraction=()=>new a,this.resetStore=()=>{this.getInteraction().reset()},this.getMemStore=()=>this.getInteraction().memStore,this.removeAccount=e=>{if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())},this.forgetDevice=()=>{this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.name="QR Hardware",this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.indexes={},this.hdk=void 0,this.paths={}},this.submitCryptoHDKey=this.getInteraction().submitCryptoHDKey,this.submitCryptoAccount=this.getInteraction().submitCryptoAccount,this.submitSignature=this.getInteraction().submitSignature,this.cancelSync=this.getInteraction().cancelSync,this.cancelSignRequest=this.getInteraction().cancelRequestSignature,h.instance)return h.instance.deserialize(e),h.instance;h.instance=this}async signTransaction(e,t){const s=0===t.type?i.DataType.transaction:i.DataType.typedTransaction;let n;n=0===t.type?o.encode(t.getMessageToSign(!1)):t.getMessageToSign(!1);const a=await this._pathFromAddress(e),h=t.common.chainId(),u=r.v4(),y=i.EthSignRequest.constructETHRequest(n,s,a,this.xfp,u,h,e),{r:m,s:g,v:d}=await this.requestSignature(u,y,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),S=t.toJSON();return S.v=d,S.s=g,S.r=m,S.type=t.type,c.TransactionFactory.fromTxData(S,{common:t.common})}}h.type=t.BaseKeyring.type,exports.MetaMaskKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js", {"@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');

const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-sign-request", 401),
  ETH_SIGNATURE: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-signature", 402),
  ETH_NFT_ITEM: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-nft-item", 403)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSourceFingerprint = () => this.derivationPath.getSourceFingerprint();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.requestId = args.requestId;
    this.signData = args.signData;
    this.dataType = args.dataType;
    this.chainId = args.chainId;
    this.derivationPath = args.derivationPath;
    this.address = args.address;
    this.origin = args.origin;
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, "").split("/");
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ""));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, "hex"));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace("0x", ""), "hex") : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
  Keys[Keys["origin"] = 3] = "origin";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId, origin) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      if (this.origin) map[Keys$1.origin] = this.origin;
      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
    this.origin = origin;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId, map[Keys$1.origin]);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

const {
  decodeToDataItem: decodeToDataItem$2
} = bcUrRegistry.extend;
var Keys$2;

(function (Keys) {
  Keys[Keys["chainId"] = 1] = "chainId";
  Keys[Keys["contractAddress"] = 2] = "contractAddress";
  Keys[Keys["contractName"] = 3] = "contractName";
  Keys[Keys["name"] = 4] = "name";
  Keys[Keys["mediaData"] = 5] = "mediaData";
})(Keys$2 || (Keys$2 = {}));

class ETHNFTItem extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_NFT_ITEM;

    this.getChainId = () => this.chainId;

    this.getName = () => this.name;

    this.getmediaData = () => this.mediaData;

    this.getContractAddress = () => this.contractAddress;

    this.getContractName = () => this.contractName;

    this.toDataItem = () => {
      const map = {};
      map[Keys$2.chainId] = this.chainId;
      map[Keys$2.name] = this.name;
      map[Keys$2.contractAddress] = this.contractAddress;
      map[Keys$2.contractName] = this.contractName;
      map[Keys$2.mediaData] = this.mediaData;
      return new bcUrRegistry.DataItem(map);
    };

    this.chainId = args.chainId;
    this.name = args.name;
    this.contractAddress = args.contractAddress;
    this.contractName = args.contractName;
    this.mediaData = args.mediaData; // remove the data perfix for android usage
  }

  static constructETHNFTItem(chainId, contractAddress, contractName, name, mediaData) {
    return new ETHNFTItem({
      chainId,
      contractAddress,
      contractName,
      mediaData,
      name
    });
  }

}

ETHNFTItem.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const chainId = map[Keys$2.chainId];
  const name = map[Keys$2.name];
  const mediaData = map[Keys$2.mediaData];
  const contractAddress = map[Keys$2.contractAddress];
  const contractName = map[Keys$2.contractName];
  return new ETHNFTItem({
    chainId,
    name,
    contractAddress,
    contractName,
    mediaData
  });
};

ETHNFTItem.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$2(_cborPayload);
  return ETHNFTItem.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressFromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = "0x" + util.publicToAddress(publicKey.publicKey, true).toString("hex");
  return util.toChecksumAddress(address);
};
const findHDPathFromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;

    const _address = generateAddressFromXpub(xpub, path);

    if (address.toLowerCase() == _address.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

bcUrRegistry.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return bcUrRegistry[k];
    }
  });
});
exports.ETHNFTItem = ETHNFTItem;
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDPathFromAddress = findHDPathFromAddress;
exports.generateAddressFromXpub = generateAddressFromXpub;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js", {"@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),a=require("uuid"),s=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("@ethereumjs/util");const r={ETH_SIGN_REQUEST:new e.RegistryType("eth-sign-request",401),ETH_SIGNATURE:new e.RegistryType("eth-signature",402),ETH_NFT_ITEM:new e.RegistryType("eth-nft-item",403)},{decodeToDataItem:n,RegistryTypes:d}=e.extend;var o,h;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(o||(o={})),(h=exports.DataType||(exports.DataType={}))[h.transaction=1]="transaction",h[h.typedData=2]="typedData",h[h.personalMessage=3]="personalMessage",h[h.typedTransaction=4]="typedTransaction";class c extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_SIGN_REQUEST,this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSourceFingerprint=()=>this.derivationPath.getSourceFingerprint(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[o.requestId]=new e.DataItem(this.requestId,d.UUID.getTag())),this.address&&(t[o.address]=this.address),this.chainId&&(t[o.chainId]=this.chainId),this.origin&&(t[o.origin]=this.origin),t[o.signData]=this.signData,t[o.dataType]=this.dataType;const a=this.derivationPath.toDataItem();return a.setTag(this.derivationPath.getRegistryType().getTag()),t[o.derivationPath]=a,new e.DataItem(t)},this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin}static constructETHRequest(t,s,i,r,n,d,o,h){const g=i.replace(/[m|M]\//,"").split("/"),u=new e.CryptoKeypath(g.map(t=>{const a=parseInt(t.replace("'",""));let s=!1;return t.endsWith("'")&&(s=!0),new e.PathComponent({index:a,hardened:s})}),Buffer.from(r,"hex"));return new c({requestId:n?Buffer.from(a.parse(n)):void 0,signData:t,dataType:s,derivationPath:u,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}c.fromDataItem=t=>{const a=t.getData(),s=a[o.signData],i=a[o.dataType],r=e.CryptoKeypath.fromDataItem(a[o.derivationPath]),n=a[o.chainId]?a[o.chainId]:void 0,d=a[o.address]?a[o.address]:void 0,h=a[o.requestId]?a[o.requestId].getData():void 0;return new c({requestId:h,signData:s,dataType:i,chainId:n,derivationPath:r,address:d,origin:a[o.origin]?a[o.origin]:void 0})},c.fromCBOR=t=>{const e=n(t);return c.fromDataItem(e)};const{RegistryTypes:g,decodeToDataItem:u}=e.extend;var m;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature",t[t.origin=3]="origin"}(m||(m={}));class I extends e.RegistryItem{constructor(t,a,s){super(),this.getRegistryType=()=>r.ETH_SIGNATURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};return this.requestId&&(t[m.requestId]=new e.DataItem(this.requestId,g.UUID.getTag())),this.origin&&(t[m.origin]=this.origin),t[m.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=a,this.origin=s}}I.fromDataItem=t=>{const e=t.getData(),a=e[m.signature],s=e[m.requestId]?e[m.requestId].getData():void 0;return new I(a,s,e[m.origin])},I.fromCBOR=t=>{const e=u(t);return I.fromDataItem(e)};const{decodeToDataItem:p}=e.extend;var D;!function(t){t[t.chainId=1]="chainId",t[t.contractAddress=2]="contractAddress",t[t.contractName=3]="contractName",t[t.name=4]="name",t[t.mediaData=5]="mediaData"}(D||(D={}));class T extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_NFT_ITEM,this.getChainId=()=>this.chainId,this.getName=()=>this.name,this.getmediaData=()=>this.mediaData,this.getContractAddress=()=>this.contractAddress,this.getContractName=()=>this.contractName,this.toDataItem=()=>{const t={};return t[D.chainId]=this.chainId,t[D.name]=this.name,t[D.contractAddress]=this.contractAddress,t[D.contractName]=this.contractName,t[D.mediaData]=this.mediaData,new e.DataItem(t)},this.chainId=t.chainId,this.name=t.name,this.contractAddress=t.contractAddress,this.contractName=t.contractName,this.mediaData=t.mediaData}static constructETHNFTItem(t,e,a,s,i){return new T({chainId:t,contractAddress:e,contractName:a,mediaData:i,name:s})}}T.fromDataItem=t=>{const e=t.getData();return new T({chainId:e[D.chainId],name:e[D.name],contractAddress:e[D.contractAddress],contractName:e[D.contractName],mediaData:e[D.mediaData]})},T.fromCBOR=t=>{const e=p(t);return T.fromDataItem(e)};const y=(t,e)=>{const a=s.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(a.publicKey,!0).toString("hex");return i.toChecksumAddress(r)};e.patchTags(Object.values(r).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHNFTItem=T,exports.ETHSignature=I,exports.EthSignRequest=c,exports.findHDPathFromAddress=(t,e,a,s)=>{for(let i=0;i<a;i++){const a=y(e,"M/0/"+i);if(t.toLowerCase()==a.toLowerCase())return`${s}/0/${i}`}return null},exports.generateAddressFromXpub=y;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js", {"./bc-ur-registry-eth.cjs.development.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CBytes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bytes = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class Bytes extends RegistryItem_1.RegistryItem {
    constructor(bytes) {
        super();
        this.bytes = bytes;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.BYTES;
        };
        this.getData = () => this.bytes;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.bytes);
        };
    }
}
exports.Bytes = Bytes;
Bytes.fromDataItem = (dataItem) => {
    const bytes = dataItem.getData();
    if (!bytes) {
        throw new Error(`#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new Bytes(bytes);
};
Bytes.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return Bytes.fromDataItem(dataItem);
};
//# sourceMappingURL=Bytes.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js", {".":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoAccount.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoAccount = void 0;
const _1 = require(".");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["outputDescriptors"] = 2] = "outputDescriptors";
})(Keys || (Keys = {}));
class CryptoAccount extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, outputDescriptors) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.outputDescriptors = outputDescriptors;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;
        };
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getOutputDescriptors = () => this.outputDescriptors;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.outputDescriptors) {
                map[Keys.outputDescriptors] = this.outputDescriptors.map((item) => item.toDataItem());
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoAccount = CryptoAccount;
CryptoAccount.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const outputDescriptors = map[Keys.outputDescriptors];
    const cryptoOutputs = outputDescriptors.map((item) => _1.CryptoOutput.fromDataItem(item));
    return new CryptoAccount(masterFingerprint, cryptoOutputs);
};
CryptoAccount.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoAccount.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoCoinInfo.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoCoinInfo = exports.Network = exports.Type = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys["type"] = "1";
    Keys["network"] = "2";
})(Keys || (Keys = {}));
var Type;
(function (Type) {
    Type[Type["bitcoin"] = 0] = "bitcoin";
})(Type = exports.Type || (exports.Type = {}));
var Network;
(function (Network) {
    Network[Network["mainnet"] = 0] = "mainnet";
    Network[Network["testnet"] = 1] = "testnet";
})(Network = exports.Network || (exports.Network = {}));
class CryptoCoinInfo extends RegistryItem_1.RegistryItem {
    constructor(type, network) {
        super();
        this.type = type;
        this.network = network;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO;
        };
        this.getType = () => {
            return this.type || Type.bitcoin;
        };
        this.getNetwork = () => {
            return this.network || Network.mainnet;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.type) {
                map[Keys.type] = this.type;
            }
            if (this.network) {
                map[Keys.network] = this.network;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoCoinInfo = CryptoCoinInfo;
CryptoCoinInfo.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys.type];
    const network = map[Keys.network];
    return new CryptoCoinInfo(type, network);
};
CryptoCoinInfo.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoCoinInfo.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoCoinInfo.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoECKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoECKey = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["curve"] = 1] = "curve";
    Keys[Keys["private"] = 2] = "private";
    Keys[Keys["data"] = 3] = "data";
})(Keys || (Keys = {}));
class CryptoECKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return true;
        };
        this.getCurve = () => this.curve || 0;
        this.isPrivateKey = () => this.privateKey || false;
        this.getData = () => this.data;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ECKEY;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.curve) {
                map[Keys.curve] = this.curve;
            }
            if (this.privateKey !== undefined) {
                map[Keys.private] = this.privateKey;
            }
            map[Keys.data] = this.data;
            return new lib_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return this.data.toString('hex');
        };
        this.data = args.data;
        this.curve = args.curve;
        this.privateKey = args.privateKey || undefined;
    }
}
exports.CryptoECKey = CryptoECKey;
CryptoECKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const curve = map[Keys.curve];
    const privateKey = map[Keys.private];
    const data = map[Keys.data];
    if (!data) {
        throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);
    }
    return new CryptoECKey({ data, curve, privateKey });
};
CryptoECKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoECKey.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoECKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js", {"./CryptoCoinInfo":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoKeypath":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","bs58check":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bs58check\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoHDKey.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoHDKey = void 0;
const bs58check_1 = require("bs58check");
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
const CryptoKeypath_1 = require("./CryptoKeypath");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["is_master"] = 1] = "is_master";
    Keys[Keys["is_private"] = 2] = "is_private";
    Keys[Keys["key_data"] = 3] = "key_data";
    Keys[Keys["chain_code"] = 4] = "chain_code";
    Keys[Keys["use_info"] = 5] = "use_info";
    Keys[Keys["origin"] = 6] = "origin";
    Keys[Keys["children"] = 7] = "children";
    Keys[Keys["parent_fingerprint"] = 8] = "parent_fingerprint";
    Keys[Keys["name"] = 9] = "name";
    Keys[Keys["note"] = 10] = "note";
})(Keys || (Keys = {}));
class CryptoHDKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return false;
        };
        this.getKey = () => this.key;
        this.getChainCode = () => this.chainCode;
        this.isMaster = () => this.master;
        this.isPrivateKey = () => !!this.privateKey;
        this.getUseInfo = () => this.useInfo;
        this.getOrigin = () => this.origin;
        this.getChildren = () => this.children;
        this.getParentFingerprint = () => this.parentFingerprint;
        this.getName = () => this.name;
        this.getNote = () => this.note;
        this.getBip32Key = () => {
            var _a, _b, _c;
            let version;
            let depth;
            let index = 0;
            let parentFingerprint = Buffer.alloc(4).fill(0);
            if (this.isMaster()) {
                version = Buffer.from('0488ADE4', 'hex');
                depth = 0;
                index = 0;
            }
            else {
                depth = ((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());
                const paths = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();
                const lastPath = paths[paths.length - 1];
                if (lastPath) {
                    index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();
                    if (this.getParentFingerprint()) {
                        parentFingerprint = this.getParentFingerprint();
                    }
                }
                if (this.isPrivateKey()) {
                    version = Buffer.from('0488ADE4', 'hex');
                }
                else {
                    version = Buffer.from('0488B21E', 'hex');
                }
            }
            const depthBuffer = Buffer.alloc(1);
            depthBuffer.writeUInt8(depth, 0);
            const indexBuffer = Buffer.alloc(4);
            indexBuffer.writeUInt32BE(index, 0);
            const chainCode = this.getChainCode();
            const key = this.getKey();
            return (0, bs58check_1.encode)(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));
        };
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;
        };
        this.getOutputDescriptorContent = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            let result = '';
            if (this.getOrigin()) {
                if (((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {
                    result += `${(_d = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString('hex')}/${(_e = this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath()}`;
                }
            }
            result += this.getBip32Key();
            if (this.getChildren()) {
                if ((_f = this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {
                    result += `/${(_g = this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath()}`;
                }
            }
            return result;
        };
        this.setupMasterKey = (args) => {
            this.master = true;
            this.key = args.key;
            this.chainCode = args.chainCode;
        };
        this.setupDeriveKey = (args) => {
            this.master = false;
            this.privateKey = args.isPrivateKey;
            this.key = args.key;
            this.chainCode = args.chainCode;
            this.useInfo = args.useInfo;
            this.origin = args.origin;
            this.children = args.children;
            this.parentFingerprint = args.parentFingerprint;
            this.name = args.name;
            this.note = args.note;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.master) {
                map[Keys.is_master] = true;
                map[Keys.key_data] = this.key;
                map[Keys.chain_code] = this.chainCode;
            }
            else {
                if (this.privateKey !== undefined) {
                    map[Keys.is_private] = this.privateKey;
                }
                map[Keys.key_data] = this.key;
                if (this.chainCode) {
                    map[Keys.chain_code] = this.chainCode;
                }
                if (this.useInfo) {
                    const useInfo = this.useInfo.toDataItem();
                    useInfo.setTag(this.useInfo.getRegistryType().getTag());
                    map[Keys.use_info] = useInfo;
                }
                if (this.origin) {
                    const origin = this.origin.toDataItem();
                    origin.setTag(this.origin.getRegistryType().getTag());
                    map[Keys.origin] = origin;
                }
                if (this.children) {
                    const children = this.children.toDataItem();
                    children.setTag(this.children.getRegistryType().getTag());
                    map[Keys.children] = children;
                }
                if (this.parentFingerprint) {
                    map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);
                }
                if (this.name !== undefined) {
                    map[Keys.name] = this.name;
                }
                if (this.note !== undefined) {
                    map[Keys.note] = this.note;
                }
            }
            return new lib_1.DataItem(map);
        };
        if (args.isMaster) {
            this.setupMasterKey(args);
        }
        else {
            this.setupDeriveKey(args);
        }
    }
}
exports.CryptoHDKey = CryptoHDKey;
CryptoHDKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const isMaster = !!map[Keys.is_master];
    const isPrivateKey = map[Keys.is_private];
    const key = map[Keys.key_data];
    const chainCode = map[Keys.chain_code];
    const useInfo = map[Keys.use_info]
        ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info])
        : undefined;
    const origin = map[Keys.origin]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin])
        : undefined;
    const children = map[Keys.children]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children])
        : undefined;
    const _parentFingerprint = map[Keys.parent_fingerprint];
    let parentFingerprint = undefined;
    if (_parentFingerprint) {
        parentFingerprint = Buffer.alloc(4);
        parentFingerprint.writeUInt32BE(_parentFingerprint, 0);
    }
    const name = map[Keys.name];
    const note = map[Keys.note];
    return new CryptoHDKey({
        isMaster,
        isPrivateKey,
        key,
        chainCode,
        useInfo,
        origin,
        children,
        parentFingerprint,
        name,
        note,
    });
};
CryptoHDKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoHDKey.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js", {"./PathComponent":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoKeypath.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoKeypath = void 0;
const lib_1 = require("./lib");
const PathComponent_1 = require("./PathComponent");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["components"] = 1] = "components";
    Keys[Keys["source_fingerprint"] = 2] = "source_fingerprint";
    Keys[Keys["depth"] = 3] = "depth";
})(Keys || (Keys = {}));
class CryptoKeypath extends RegistryItem_1.RegistryItem {
    constructor(components = [], sourceFingerprint, depth) {
        super();
        this.components = components;
        this.sourceFingerprint = sourceFingerprint;
        this.depth = depth;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;
        };
        this.getPath = () => {
            if (this.components.length === 0) {
                return undefined;
            }
            const components = this.components.map((component) => {
                return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? "'" : ''}`;
            });
            return components.join('/');
        };
        this.getComponents = () => this.components;
        this.getSourceFingerprint = () => this.sourceFingerprint;
        this.getDepth = () => this.depth;
        this.toDataItem = () => {
            const map = {};
            const components = [];
            this.components &&
                this.components.forEach((component) => {
                    if (component.isWildcard()) {
                        components.push([]);
                    }
                    else {
                        components.push(component.getIndex());
                    }
                    components.push(component.isHardened());
                });
            map[Keys.components] = components;
            if (this.sourceFingerprint) {
                map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);
            }
            if (this.depth !== undefined) {
                map[Keys.depth] = this.depth;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoKeypath = CryptoKeypath;
CryptoKeypath.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const pathComponents = [];
    const components = map[Keys.components];
    if (components) {
        for (let i = 0; i < components.length; i += 2) {
            const isHardened = components[i + 1];
            const path = components[i];
            if (typeof path === 'number') {
                pathComponents.push(new PathComponent_1.PathComponent({ index: path, hardened: isHardened }));
            }
            else {
                pathComponents.push(new PathComponent_1.PathComponent({ hardened: isHardened }));
            }
        }
    }
    const _sourceFingerprint = map[Keys.source_fingerprint];
    let sourceFingerprint;
    if (_sourceFingerprint) {
        sourceFingerprint = Buffer.alloc(4);
        sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);
    }
    const depth = map[Keys.depth];
    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);
};
CryptoKeypath.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoKeypath.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js", {"./CryptoECKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./MultiKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoOutput.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoOutput = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const lib_1 = require("./lib");
const MultiKey_1 = require("./MultiKey");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
class CryptoOutput extends RegistryItem_1.RegistryItem {
    constructor(scriptExpressions, cryptoKey) {
        super();
        this.scriptExpressions = scriptExpressions;
        this.cryptoKey = cryptoKey;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_OUTPUT;
        };
        this.getCryptoKey = () => this.cryptoKey;
        this.getHDKey = () => {
            if (this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getECKey = () => {
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getMultiKey = () => {
            if (this.cryptoKey instanceof MultiKey_1.MultiKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getScriptExpressions = () => this.scriptExpressions;
        this._toOutputDescriptor = (seIndex) => {
            if (seIndex >= this.scriptExpressions.length) {
                return this.cryptoKey.getOutputDescriptorContent();
            }
            else {
                return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;
            }
        };
        this.toString = () => {
            return this._toOutputDescriptor(0);
        };
        this.toDataItem = () => {
            let dataItem = this.cryptoKey.toDataItem();
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey ||
                this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                dataItem.setTag(this.cryptoKey.getRegistryType().getTag());
            }
            const clonedSe = [...this.scriptExpressions];
            clonedSe.reverse().forEach((se) => {
                const tagValue = se.getTag();
                if (dataItem.getTag() === undefined) {
                    dataItem.setTag(tagValue);
                }
                else {
                    dataItem = new lib_1.DataItem(dataItem, tagValue);
                }
            });
            return dataItem;
        };
    }
}
exports.CryptoOutput = CryptoOutput;
CryptoOutput.fromDataItem = (dataItem) => {
    const scriptExpressions = [];
    let _dataItem = dataItem;
    while (true) {
        let _tag = _dataItem.getTag();
        const se = ScriptExpression_1.ScriptExpression.fromTag(_tag);
        if (se) {
            scriptExpressions.push(se);
            if (_dataItem.getData() instanceof lib_1.DataItem) {
                _dataItem = _dataItem.getData();
                _tag = _dataItem.getTag();
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    const seLength = scriptExpressions.length;
    const isMultiKey = seLength > 0 &&
        (scriptExpressions[seLength - 1].getExpression() ===
            ScriptExpression_1.ScriptExpressions.MULTISIG.getExpression() ||
            scriptExpressions[seLength - 1].getExpression() ===
                ScriptExpression_1.ScriptExpressions.SORTED_MULTISIG.getExpression());
    if (isMultiKey) {
        const multiKey = MultiKey_1.MultiKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, multiKey);
    }
    if (_dataItem.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
        const cryptoHDKey = CryptoHDKey_1.CryptoHDKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoHDKey);
    }
    else {
        const cryptoECKey = CryptoECKey_1.CryptoECKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoECKey);
    }
};
CryptoOutput.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoOutput.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoOutput.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js", {"./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoPSBT.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoPSBT = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class CryptoPSBT extends RegistryItem_1.RegistryItem {
    constructor(psbt) {
        super();
        this.psbt = psbt;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_PSBT;
        this.getPSBT = () => this.psbt;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.psbt);
        };
    }
}
exports.CryptoPSBT = CryptoPSBT;
CryptoPSBT.fromDataItem = (dataItem) => {
    const psbt = dataItem.getData();
    if (!psbt) {
        throw new Error(`#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new CryptoPSBT(psbt);
};
CryptoPSBT.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoPSBT.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoPSBT.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js", {"..":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","../RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","@ngraveio/bc-ur":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CDecoder%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URRegistryDecoder = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const __1 = require("..");
const RegistryType_1 = require("../RegistryType");
const errors_1 = require("../errors");
class URRegistryDecoder extends bc_ur_1.URDecoder {
    constructor() {
        super(...arguments);
        this.resultRegistryType = () => {
            const ur = this.resultUR();
            switch (ur.type) {
                case RegistryType_1.RegistryTypes.BYTES.getType():
                    return __1.Bytes.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getType():
                    return __1.CryptoHDKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_KEYPATH.getType():
                    return __1.CryptoKeypath.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO.getType():
                    return __1.CryptoCoinInfo.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getType():
                    return __1.CryptoECKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_OUTPUT.getType():
                    return __1.CryptoOutput.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_PSBT.getType():
                    return __1.CryptoPSBT.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT.getType():
                    return __1.CryptoAccount.fromCBOR(ur.cbor);
                default:
                    throw new errors_1.UnknownURTypeError(`#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${ur.type} is not supported now`);
            }
        };
    }
}
exports.URRegistryDecoder = URRegistryDecoder;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js", {"./CryptoECKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib/DataItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CMultiKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiKey = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const DataItem_1 = require("./lib/DataItem");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["threshold"] = 1] = "threshold";
    Keys[Keys["keys"] = 2] = "keys";
})(Keys || (Keys = {}));
class MultiKey extends RegistryItem_1.RegistryItem {
    constructor(threshold, keys) {
        super();
        this.threshold = threshold;
        this.keys = keys;
        this.getThreshold = () => this.threshold;
        this.getKeys = () => this.keys;
        this.toDataItem = () => {
            const map = {};
            map[Keys.threshold] = this.threshold;
            const keys = this.keys.map((k) => {
                const dataItem = k.toDataItem();
                dataItem.setTag(k.getRegistryType().getTag());
                return dataItem;
            });
            map[Keys.keys] = keys;
            return new DataItem_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return [this.getThreshold(),
                this.keys.map(k => k.getOutputDescriptorContent()).join(','),
            ].join(',');
        };
    }
}
exports.MultiKey = MultiKey;
MultiKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const threshold = map[Keys.threshold];
    const _keys = map[Keys.keys];
    const keys = [];
    _keys.forEach((k) => {
        if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
            keys.push(CryptoHDKey_1.CryptoHDKey.fromDataItem(k));
        }
        else if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getTag()) {
            keys.push(CryptoECKey_1.CryptoECKey.fromDataItem(k));
        }
    });
    return new MultiKey(threshold, keys);
};
//# sourceMappingURL=MultiKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CPathComponent.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathComponent = void 0;
class PathComponent {
    constructor(args) {
        this.getIndex = () => this.index;
        this.isWildcard = () => this.wildcard;
        this.isHardened = () => this.hardened;
        this.index = args.index;
        this.hardened = args.hardened;
        if (this.index !== undefined) {
            this.wildcard = false;
        }
        else {
            this.wildcard = true;
        }
        if (this.index && (this.index & PathComponent.HARDENED_BIT) !== 0) {
            throw new Error(`#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`);
        }
    }
}
exports.PathComponent = PathComponent;
PathComponent.HARDENED_BIT = 0x80000000;
//# sourceMappingURL=PathComponent.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js", {"./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","@ngraveio/bc-ur":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryItem = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const lib_1 = require("./lib");
class RegistryItem {
    constructor() {
        this.toCBOR = () => {
            if (this.toDataItem() === undefined) {
                throw new Error(`#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`);
            }
            return (0, lib_1.encodeDataItem)(this.toDataItem());
        };
        this.toUR = () => {
            return new bc_ur_1.UR(this.toCBOR(), this.getRegistryType().getType());
        };
        this.toUREncoder = (maxFragmentLength, firstSeqNum, minFragmentLength) => {
            const ur = this.toUR();
            const urEncoder = new bc_ur_1.UREncoder(ur, maxFragmentLength, firstSeqNum, minFragmentLength);
            return urEncoder;
        };
    }
}
exports.RegistryItem = RegistryItem;
//# sourceMappingURL=RegistryItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryType.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryTypes = exports.RegistryType = void 0;
class RegistryType {
    constructor(type, tag) {
        this.type = type;
        this.tag = tag;
        this.getTag = () => this.tag;
        this.getType = () => this.type;
    }
}
exports.RegistryType = RegistryType;
exports.RegistryTypes = {
    UUID: new RegistryType('uuid', 37),
    BYTES: new RegistryType('bytes', undefined),
    CRYPTO_HDKEY: new RegistryType('crypto-hdkey', 303),
    CRYPTO_KEYPATH: new RegistryType('crypto-keypath', 304),
    CRYPTO_COIN_INFO: new RegistryType('crypto-coin-info', 305),
    CRYPTO_ECKEY: new RegistryType('crypto-eckey', 306),
    CRYPTO_OUTPUT: new RegistryType('crypto-output', 308),
    CRYPTO_PSBT: new RegistryType('crypto-psbt', 310),
    CRYPTO_ACCOUNT: new RegistryType('crypto-account', 311),
    CRYPTO_MULTI_ACCOUNTS: new RegistryType("crypto-multi-accounts", 1103),
};
//# sourceMappingURL=RegistryType.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CScriptExpression.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptExpressions = exports.ScriptExpression = void 0;
class ScriptExpression {
    constructor(tag, expression) {
        this.tag = tag;
        this.expression = expression;
        this.getTag = () => this.tag;
        this.getExpression = () => this.expression;
    }
}
exports.ScriptExpression = ScriptExpression;
ScriptExpression.fromTag = (tag) => {
    const se = Object.values(exports.ScriptExpressions).find((se) => se.getTag() === tag);
    return se;
};
exports.ScriptExpressions = {
    SCRIPT_HASH: new ScriptExpression(400, 'sh'),
    WITNESS_SCRIPT_HASH: new ScriptExpression(401, 'wsh'),
    PUBLIC_KEY: new ScriptExpression(402, 'pk'),
    PUBLIC_KEY_HASH: new ScriptExpression(403, 'pkh'),
    WITNESS_PUBLIC_KEY_HASH: new ScriptExpression(404, 'wpkh'),
    COMBO: new ScriptExpression(405, 'combo'),
    MULTISIG: new ScriptExpression(406, 'multi'),
    SORTED_MULTISIG: new ScriptExpression(407, 'sortedmulti'),
    ADDRESS: new ScriptExpression(307, 'addr'),
    RAW_SCRIPT: new ScriptExpression(408, 'raw'),
};
//# sourceMappingURL=ScriptExpression.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cerrors%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownURTypeError = void 0;
class UnknownURTypeError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.UnknownURTypeError = UnknownURTypeError;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js", {"../CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","../RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","../RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cextended%5CCryptoMultiAccounts.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoMultiAccounts = void 0;
const RegistryType_1 = require("../RegistryType");
const CryptoHDKey_1 = require("../CryptoHDKey");
const RegistryItem_1 = require("../RegistryItem");
const lib_1 = require("../lib");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["keys"] = 2] = "keys";
    Keys[Keys["device"] = 3] = "device";
})(Keys || (Keys = {}));
class CryptoMultiAccounts extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, keys, device) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.keys = keys;
        this.device = device;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_MULTI_ACCOUNTS;
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getKeys = () => this.keys;
        this.getDevice = () => this.device;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.keys) {
                map[Keys.keys] = this.keys.map((item) => {
                    const dataItem = item.toDataItem();
                    dataItem.setTag(item.getRegistryType().getTag());
                    return dataItem;
                });
            }
            if (this.device) {
                map[Keys.device] = this.device;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoMultiAccounts = CryptoMultiAccounts;
CryptoMultiAccounts.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const keys = map[Keys.keys];
    const cryptoHDKeys = keys.map((item) => CryptoHDKey_1.CryptoHDKey.fromDataItem(item));
    const device = map[Keys.device];
    return new CryptoMultiAccounts(masterFingerprint, cryptoHDKeys, device);
};
CryptoMultiAccounts.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoMultiAccounts.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js", {"./Bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js","./CryptoAccount":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js","./CryptoCoinInfo":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoECKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./CryptoKeypath":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./CryptoOutput":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js","./CryptoPSBT":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js","./Decoder":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js","./MultiKey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./PathComponent":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","./extended/CryptoMultiAccounts":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js","./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","./patchCBOR":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js","./types":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js","./utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js","buffer/":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\buffer\\index.js","tslib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\tslib\\tslib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Buffer = exports.extend = exports.PathComponent = exports.ScriptExpressions = exports.MultiKey = exports.CryptoPSBT = exports.CryptoOutput = exports.CryptoECKey = exports.CryptoCoinInfoNetwork = exports.CryptoCoinInfoType = exports.CryptoCoinInfo = exports.CryptoKeypath = exports.CryptoMultiAccounts = exports.CryptoHDKey = exports.CryptoAccount = exports.Bytes = exports.URRegistryDecoder = exports.DataItem = void 0;
const tslib_1 = require("tslib");
require("./patchCBOR");
const buffer_1 = require("buffer/");
Object.defineProperty(exports, "Buffer", { enumerable: true, get: function () { return buffer_1.Buffer; } });
const CryptoHDKey_1 = require("./CryptoHDKey");
Object.defineProperty(exports, "CryptoHDKey", { enumerable: true, get: function () { return CryptoHDKey_1.CryptoHDKey; } });
const CryptoKeypath_1 = require("./CryptoKeypath");
Object.defineProperty(exports, "CryptoKeypath", { enumerable: true, get: function () { return CryptoKeypath_1.CryptoKeypath; } });
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
Object.defineProperty(exports, "CryptoCoinInfo", { enumerable: true, get: function () { return CryptoCoinInfo_1.CryptoCoinInfo; } });
Object.defineProperty(exports, "CryptoCoinInfoType", { enumerable: true, get: function () { return CryptoCoinInfo_1.Type; } });
Object.defineProperty(exports, "CryptoCoinInfoNetwork", { enumerable: true, get: function () { return CryptoCoinInfo_1.Network; } });
const CryptoECKey_1 = require("./CryptoECKey");
Object.defineProperty(exports, "CryptoECKey", { enumerable: true, get: function () { return CryptoECKey_1.CryptoECKey; } });
const Bytes_1 = require("./Bytes");
Object.defineProperty(exports, "Bytes", { enumerable: true, get: function () { return Bytes_1.Bytes; } });
const CryptoOutput_1 = require("./CryptoOutput");
Object.defineProperty(exports, "CryptoOutput", { enumerable: true, get: function () { return CryptoOutput_1.CryptoOutput; } });
const CryptoPSBT_1 = require("./CryptoPSBT");
Object.defineProperty(exports, "CryptoPSBT", { enumerable: true, get: function () { return CryptoPSBT_1.CryptoPSBT; } });
const CryptoAccount_1 = require("./CryptoAccount");
Object.defineProperty(exports, "CryptoAccount", { enumerable: true, get: function () { return CryptoAccount_1.CryptoAccount; } });
const Decoder_1 = require("./Decoder");
Object.defineProperty(exports, "URRegistryDecoder", { enumerable: true, get: function () { return Decoder_1.URRegistryDecoder; } });
const MultiKey_1 = require("./MultiKey");
Object.defineProperty(exports, "MultiKey", { enumerable: true, get: function () { return MultiKey_1.MultiKey; } });
const ScriptExpression_1 = require("./ScriptExpression");
Object.defineProperty(exports, "ScriptExpressions", { enumerable: true, get: function () { return ScriptExpression_1.ScriptExpressions; } });
const PathComponent_1 = require("./PathComponent");
Object.defineProperty(exports, "PathComponent", { enumerable: true, get: function () { return PathComponent_1.PathComponent; } });
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const lib_1 = require("./lib");
var lib_2 = require("./lib");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return lib_2.DataItem; } });
const utils_1 = require("./utils");
const CryptoMultiAccounts_1 = require("./extended/CryptoMultiAccounts");
Object.defineProperty(exports, "CryptoMultiAccounts", { enumerable: true, get: function () { return CryptoMultiAccounts_1.CryptoMultiAccounts; } });
const URlib = {
    URRegistryDecoder: Decoder_1.URRegistryDecoder,
    Bytes: Bytes_1.Bytes,
    CryptoAccount: CryptoAccount_1.CryptoAccount,
    CryptoHDKey: CryptoHDKey_1.CryptoHDKey,
    CryptoMultiAccounts: CryptoMultiAccounts_1.CryptoMultiAccounts,
    CryptoKeypath: CryptoKeypath_1.CryptoKeypath,
    CryptoCoinInfo: CryptoCoinInfo_1.CryptoCoinInfo,
    CryptoCoinInfoType: CryptoCoinInfo_1.Type,
    CryptoCoinInfoNetwork: CryptoCoinInfo_1.Network,
    CryptoECKey: CryptoECKey_1.CryptoECKey,
    CryptoOutput: CryptoOutput_1.CryptoOutput,
    CryptoPSBT: CryptoPSBT_1.CryptoPSBT,
    MultiKey: MultiKey_1.MultiKey,
    ScriptExpressions: ScriptExpression_1.ScriptExpressions,
    PathComponent: PathComponent_1.PathComponent,
};
const cbor = {
    addReader: lib_1.addReader,
    addSemanticDecode: lib_1.addSemanticDecode,
    addSemanticEncode: lib_1.addSemanticEncode,
    addWriter: lib_1.addWriter,
    patchTags: utils_1.patchTags,
};
const extend = {
    RegistryTypes: RegistryType_1.RegistryTypes,
    RegistryItem: RegistryItem_1.RegistryItem,
    RegistryType: RegistryType_1.RegistryType,
    decodeToDataItem: lib_1.decodeToDataItem,
    encodeDataItem: lib_1.encodeDataItem,
    cbor,
};
exports.extend = extend;
(0, tslib_1.__exportStar)(require("./errors"), exports);
(0, tslib_1.__exportStar)(require("./Decoder"), exports);
(0, tslib_1.__exportStar)(require("./lib"), exports);
(0, tslib_1.__exportStar)(require("./CryptoAccount"), exports);
(0, tslib_1.__exportStar)(require("./CryptoPSBT"), exports);
(0, tslib_1.__exportStar)(require("./CryptoHDKey"), exports);
(0, tslib_1.__exportStar)(require("./extended/CryptoMultiAccounts"), exports);
(0, tslib_1.__exportStar)(require("./CryptoOutput"), exports);
(0, tslib_1.__exportStar)(require("./CryptoCoinInfo"), exports);
(0, tslib_1.__exportStar)(require("./CryptoECKey"), exports);
(0, tslib_1.__exportStar)(require("./MultiKey"), exports);
(0, tslib_1.__exportStar)(require("./CryptoKeypath"), exports);
(0, tslib_1.__exportStar)(require("./patchCBOR"), exports);
(0, tslib_1.__exportStar)(require("./PathComponent"), exports);
(0, tslib_1.__exportStar)(require("./RegistryItem"), exports);
(0, tslib_1.__exportStar)(require("./RegistryType"), exports);
(0, tslib_1.__exportStar)(require("./types"), exports);
(0, tslib_1.__exportStar)(require("./utils"), exports);
exports.default = URlib;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5CDataItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = void 0;
class DataItem {
    constructor(data, tag) {
        this.setTag = (tag) => {
            this.tag = tag;
        };
        this.clearTag = () => {
            this.tag = undefined;
        };
        this.getTag = () => {
            return this.tag;
        };
        this.getData = () => {
            return this.data;
        };
        this.data = data;
        this.tag = tag;
    }
}
exports.DataItem = DataItem;
//# sourceMappingURL=DataItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js", {"./DataItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Ccbor-sync.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    }
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else {
        global.CBOR = factory();
    }
})(this, function () {
    const { DataItem } = require('./DataItem');
    var CBOR = (function () {
        function BinaryHex(hex) {
            this.$hex = hex;
        }
        BinaryHex.prototype = {
            length: function () {
                return this.$hex.length / 2;
            },
            toString: function (format) {
                if (!format || format === 'hex' || format === 16)
                    return this.$hex;
                if (format === 'utf-8') {
                    var encoded = '';
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded += '%' + this.$hex.substring(i, i + 2);
                    }
                    return decodeURIComponent(encoded);
                }
                if (format === 'latin') {
                    var encoded = [];
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
                    }
                    return String.fromCharCode.apply(String, encoded);
                }
                throw new Error('Unrecognised format: ' + format);
            },
        };
        BinaryHex.fromLatinString = function (latinString) {
            var hex = '';
            for (var i = 0; i < latinString.length; i++) {
                var pair = latinString.charCodeAt(i).toString(16);
                if (pair.length === 1)
                    pair = '0' + pair;
                hex += pair;
            }
            return new BinaryHex(hex);
        };
        BinaryHex.fromUtf8String = function (utf8String) {
            var encoded = encodeURIComponent(utf8String);
            var hex = '';
            for (var i = 0; i < encoded.length; i++) {
                if (encoded.charAt(i) === '%') {
                    hex += encoded.substring(i + 1, i + 3);
                    i += 2;
                }
                else {
                    var hexPair = encoded.charCodeAt(i).toString(16);
                    if (hexPair.length < 2)
                        hexPair = '0' + hexPair;
                    hex += hexPair;
                }
            }
            return new BinaryHex(hex);
        };
        var semanticEncoders = [];
        var semanticDecoders = {};
        var notImplemented = function (label) {
            return function () {
                throw new Error(label + ' not implemented');
            };
        };
        function Reader() { }
        Reader.prototype = {
            peekByte: notImplemented('peekByte'),
            readByte: notImplemented('readByte'),
            readChunk: notImplemented('readChunk'),
            readFloat16: function () {
                var half = this.readUint16();
                var exponent = (half & 0x7fff) >> 10;
                var mantissa = half & 0x3ff;
                var negative = half & 0x8000;
                if (exponent === 0x1f) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 25) * (1024 + mantissa)
                    : Math.pow(2, -24) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat32: function () {
                var intValue = this.readUint32();
                var exponent = (intValue & 0x7fffffff) >> 23;
                var mantissa = intValue & 0x7fffff;
                var negative = intValue & 0x80000000;
                if (exponent === 0xff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa)
                    : Math.pow(2, -23 - 126) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat64: function () {
                var int1 = this.readUint32(), int2 = this.readUint32();
                var exponent = (int1 >> 20) & 0x7ff;
                var mantissa = (int1 & 0xfffff) * 4294967296 + int2;
                var negative = int1 & 0x80000000;
                if (exponent === 0x7ff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa)
                    : Math.pow(2, -52 - 1022) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readUint16: function () {
                return this.readByte() * 256 + this.readByte();
            },
            readUint32: function () {
                return this.readUint16() * 65536 + this.readUint16();
            },
            readUint64: function () {
                return this.readUint32() * 4294967296 + this.readUint32();
            },
        };
        function Writer() { }
        Writer.prototype = {
            writeByte: notImplemented('writeByte'),
            result: notImplemented('result'),
            writeFloat16: notImplemented('writeFloat16'),
            writeFloat32: notImplemented('writeFloat32'),
            writeFloat64: notImplemented('writeFloat64'),
            writeUint16: function (value) {
                this.writeByte((value >> 8) & 0xff);
                this.writeByte(value & 0xff);
            },
            writeUint32: function (value) {
                this.writeUint16((value >> 16) & 0xffff);
                this.writeUint16(value & 0xffff);
            },
            writeUint64: function (value) {
                if (value >= 9007199254740992 || value <= -9007199254740992) {
                    throw new Error('Cannot encode Uint64 of: ' +
                        value +
                        ' magnitude to big (floating point errors)');
                }
                this.writeUint32(Math.floor(value / 4294967296));
                this.writeUint32(value % 4294967296);
            },
            writeString: notImplemented('writeString'),
            canWriteBinary: function (chunk) {
                return false;
            },
            writeBinary: notImplemented('writeChunk'),
        };
        function readHeaderRaw(reader) {
            var firstByte = reader.readByte();
            var majorType = firstByte >> 5, value = firstByte & 0x1f;
            return { type: majorType, value: value };
        }
        function valueFromHeader(header, reader) {
            var value = header.value;
            if (value < 24) {
                return value;
            }
            else if (value == 24) {
                return reader.readByte();
            }
            else if (value == 25) {
                return reader.readUint16();
            }
            else if (value == 26) {
                return reader.readUint32();
            }
            else if (value == 27) {
                return reader.readUint64();
            }
            else if (value == 31) {
                return null;
            }
            notImplemented('Additional info: ' + value)();
        }
        function writeHeaderRaw(type, value, writer) {
            writer.writeByte((type << 5) | value);
        }
        function writeHeader(type, value, writer) {
            var firstByte = type << 5;
            if (value < 24) {
                writer.writeByte(firstByte | value);
            }
            else if (value < 256) {
                writer.writeByte(firstByte | 24);
                writer.writeByte(value);
            }
            else if (value < 65536) {
                writer.writeByte(firstByte | 25);
                writer.writeUint16(value);
            }
            else if (value < 4294967296) {
                writer.writeByte(firstByte | 26);
                writer.writeUint32(value);
            }
            else {
                writer.writeByte(firstByte | 27);
                writer.writeUint64(value);
            }
        }
        var stopCode = new Error();
        function decodeReader(reader) {
            var header = readHeaderRaw(reader);
            switch (header.type) {
                case 0:
                    return valueFromHeader(header, reader);
                case 1:
                    return -1 - valueFromHeader(header, reader);
                case 2:
                    return reader.readChunk(valueFromHeader(header, reader));
                case 3:
                    var buffer = reader.readChunk(valueFromHeader(header, reader));
                    return buffer.toString('utf-8');
                case 4:
                case 5:
                    var arrayLength = valueFromHeader(header, reader);
                    var result = [];
                    if (arrayLength !== null) {
                        if (header.type === 5) {
                            arrayLength *= 2;
                        }
                        for (var i = 0; i < arrayLength; i++) {
                            result[i] = decodeReader(reader);
                        }
                    }
                    else {
                        var item;
                        while ((item = decodeReader(reader)) !== stopCode) {
                            result.push(item);
                        }
                    }
                    if (header.type === 5) {
                        var objResult = {};
                        for (var i = 0; i < result.length; i += 2) {
                            objResult[result[i]] = result[i + 1];
                        }
                        return objResult;
                    }
                    else {
                        return result;
                    }
                case 6:
                    var tag = valueFromHeader(header, reader);
                    var decoder = semanticDecoders[tag];
                    var result = decodeReader(reader);
                    return decoder ? decoder(result) : result;
                case 7:
                    if (header.value === 25) {
                        return reader.readFloat16();
                    }
                    else if (header.value === 26) {
                        return reader.readFloat32();
                    }
                    else if (header.value === 27) {
                        return reader.readFloat64();
                    }
                    switch (valueFromHeader(header, reader)) {
                        case 20:
                            return false;
                        case 21:
                            return true;
                        case 22:
                            return null;
                        case 23:
                            return undefined;
                        case null:
                            return stopCode;
                        default:
                            throw new Error('Unknown fixed value: ' + header.value);
                    }
                default:
                    throw new Error('Unsupported header: ' + JSON.stringify(header));
            }
            throw new Error('not implemented yet');
        }
        function encodeWriter(data, writer) {
            for (var i = 0; i < semanticEncoders.length; i++) {
                var replacement = semanticEncoders[i].fn(data);
                if (replacement !== undefined) {
                    writeHeader(6, semanticEncoders[i].tag, writer);
                    return encodeWriter(replacement, writer);
                }
            }
            if (data && typeof data.toCBOR === 'function') {
                data = data.toCBOR();
            }
            if (data === false) {
                writeHeader(7, 20, writer);
            }
            else if (data === true) {
                writeHeader(7, 21, writer);
            }
            else if (data === null) {
                writeHeader(7, 22, writer);
            }
            else if (data === undefined) {
                writeHeader(7, 23, writer);
            }
            else if (typeof data === 'number') {
                if (Math.floor(data) === data &&
                    data < 9007199254740992 &&
                    data > -9007199254740992) {
                    if (data < 0) {
                        writeHeader(1, -1 - data, writer);
                    }
                    else {
                        writeHeader(0, data, writer);
                    }
                }
                else {
                    writeHeaderRaw(7, 27, writer);
                    writer.writeFloat64(data);
                }
            }
            else if (typeof data === 'string') {
                writer.writeString(data, function (length) {
                    writeHeader(3, length, writer);
                });
            }
            else if (writer.canWriteBinary(data)) {
                writer.writeBinary(data, function (length) {
                    writeHeader(2, length, writer);
                });
            }
            else if (typeof data === 'object') {
                if (api.config.useToJSON && typeof data.toJSON === 'function') {
                    data = data.toJSON();
                }
                if (Array.isArray(data)) {
                    writeHeader(4, data.length, writer);
                    for (var i = 0; i < data.length; i++) {
                        encodeWriter(data[i], writer);
                    }
                }
                else {
                    var keys = Object.keys(data);
                    writeHeader(5, keys.length, writer);
                    for (var i = 0; i < keys.length; i++) {
                        const number = parseInt(keys[i]);
                        if (isNaN(number)) {
                            encodeWriter(keys[i], writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                        else {
                            encodeWriter(number, writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                    }
                }
            }
            else {
                throw new Error('CBOR encoding not supported: ' + data);
            }
        }
        var readerFunctions = [];
        var writerFunctions = [];
        var api = {
            config: {
                useToJSON: true,
            },
            addWriter: function (format, writerFunction) {
                if (typeof format === 'string') {
                    writerFunctions.push(function (f) {
                        if (format === f)
                            return writerFunction(f);
                    });
                }
                else {
                    writerFunctions.push(format);
                }
            },
            addReader: function (format, readerFunction) {
                if (typeof format === 'string') {
                    readerFunctions.push(function (data, f) {
                        if (format === f)
                            return readerFunction(data, f);
                    });
                }
                else {
                    readerFunctions.push(format);
                }
            },
            encode: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        encodeWriter(data, writer);
                        return writer.result();
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            encodeDataItem: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        if (data.getTag() !== undefined) {
                            encodeWriter(data, writer);
                            return writer.result();
                        }
                        else {
                            encodeWriter(data.getData(), writer);
                            return writer.result();
                        }
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            decode: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        return decodeReader(reader);
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            decodeToDataItem: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        const result = decodeReader(reader);
                        if (result instanceof DataItem) {
                            return result;
                        }
                        else {
                            return new DataItem(result);
                        }
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            addSemanticEncode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticEncoders.push({ tag: tag, fn: fn });
                return this;
            },
            addSemanticDecode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticDecoders[tag] = fn;
                return this;
            },
        };
        function BufferReader(buffer) {
            this.buffer = buffer;
            this.pos = 0;
        }
        BufferReader.prototype = Object.create(Reader.prototype);
        BufferReader.prototype.peekByte = function () {
            return this.buffer[this.pos];
        };
        BufferReader.prototype.readByte = function () {
            return this.buffer[this.pos++];
        };
        BufferReader.prototype.readUint16 = function () {
            var result = this.buffer.readUInt16BE(this.pos);
            this.pos += 2;
            return result;
        };
        BufferReader.prototype.readUint32 = function () {
            var result = this.buffer.readUInt32BE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat32 = function () {
            var result = this.buffer.readFloatBE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat64 = function () {
            var result = this.buffer.readDoubleBE(this.pos);
            this.pos += 8;
            return result;
        };
        BufferReader.prototype.readChunk = function (length) {
            var result = Buffer.alloc(length);
            this.buffer.copy(result, 0, this.pos, (this.pos += length));
            return result;
        };
        function BufferWriter(stringFormat) {
            this.byteLength = 0;
            this.defaultBufferLength = 16384;
            this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
            this.completeBuffers = [];
            this.stringFormat = stringFormat;
        }
        BufferWriter.prototype = Object.create(Writer.prototype);
        BufferWriter.prototype.writeByte = function (value) {
            this.latestBuffer[this.latestBufferOffset++] = value;
            if (this.latestBufferOffset >= this.latestBuffer.length) {
                this.completeBuffers.push(this.latestBuffer);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength++;
        };
        BufferWriter.prototype.writeFloat32 = function (value) {
            var buffer = Buffer.alloc(4);
            buffer.writeFloatBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeFloat64 = function (value) {
            var buffer = Buffer.alloc(8);
            buffer.writeDoubleBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeString = function (string, lengthFunc) {
            var buffer = Buffer.from(string, 'utf-8');
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.canWriteBinary = function (data) {
            return data instanceof Buffer;
        };
        BufferWriter.prototype.writeBinary = function (buffer, lengthFunc) {
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeBuffer = function (chunk) {
            if (!(chunk instanceof Buffer))
                throw new TypeError('BufferWriter only accepts Buffers');
            if (!this.latestBufferOffset) {
                this.completeBuffers.push(chunk);
            }
            else if (this.latestBuffer.length - this.latestBufferOffset >=
                chunk.length) {
                chunk.copy(this.latestBuffer, this.latestBufferOffset);
                this.latestBufferOffset += chunk.length;
                if (this.latestBufferOffset >= this.latestBuffer.length) {
                    this.completeBuffers.push(this.latestBuffer);
                    this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                    this.latestBufferOffset = 0;
                }
            }
            else {
                this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
                this.completeBuffers.push(chunk);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength += chunk.length;
        };
        BufferWriter.prototype.result = function () {
            var result = Buffer.alloc(this.byteLength);
            var offset = 0;
            for (var i = 0; i < this.completeBuffers.length; i++) {
                var buffer = this.completeBuffers[i];
                buffer.copy(result, offset, 0, buffer.length);
                offset += buffer.length;
            }
            if (this.latestBufferOffset) {
                this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
            }
            if (this.stringFormat)
                return result.toString(this.stringFormat);
            return result;
        };
        if (typeof Buffer === 'function') {
            api.addReader(function (data, format) {
                if (Buffer.isBuffer(data)) {
                    return new BufferReader(data);
                }
                if (format === 'hex' || format === 'base64') {
                    var buffer = Buffer.from(data, format);
                    return new BufferReader(buffer);
                }
            });
            api.addWriter(function (format) {
                if (!format || format === 'buffer') {
                    return new BufferWriter();
                }
                else if (format === 'hex' || format === 'base64') {
                    return new BufferWriter(format);
                }
            });
        }
        function HexReader(hex) {
            this.hex = hex;
            this.pos = 0;
        }
        HexReader.prototype = Object.create(Reader.prototype);
        HexReader.prototype.peekByte = function () {
            var pair = this.hex.substring(this.pos, 2);
            return parseInt(pair, 16);
        };
        HexReader.prototype.readByte = function () {
            var pair = this.hex.substring(this.pos, this.pos + 2);
            this.pos += 2;
            return parseInt(pair, 16);
        };
        HexReader.prototype.readChunk = function (length) {
            var hex = this.hex.substring(this.pos, this.pos + length * 2);
            this.pos += length * 2;
            if (typeof Buffer === 'function')
                return Buffer.from(hex, 'hex');
            return new BinaryHex(hex);
        };
        function HexWriter(finalFormat) {
            this.$hex = '';
            this.finalFormat = finalFormat || 'hex';
        }
        HexWriter.prototype = Object.create(Writer.prototype);
        HexWriter.prototype.writeByte = function (value) {
            if (value < 0 || value > 255)
                throw new Error('Byte value out of range: ' + value);
            var hex = value.toString(16);
            if (hex.length == 1) {
                hex = '0' + hex;
            }
            this.$hex += hex;
        };
        HexWriter.prototype.canWriteBinary = function (chunk) {
            return (chunk instanceof BinaryHex ||
                (typeof Buffer === 'function' && chunk instanceof Buffer));
        };
        HexWriter.prototype.writeBinary = function (chunk, lengthFunction) {
            if (chunk instanceof BinaryHex) {
                lengthFunction(chunk.length());
                this.$hex += chunk.$hex;
            }
            else if (typeof Buffer === 'function' && chunk instanceof Buffer) {
                lengthFunction(chunk.length);
                this.$hex += chunk.toString('hex');
            }
            else {
                throw new TypeError('HexWriter only accepts BinaryHex or Buffers');
            }
        };
        HexWriter.prototype.result = function () {
            if (this.finalFormat === 'buffer' && typeof Buffer === 'function') {
                return Buffer.from(this.$hex, 'hex');
            }
            return new BinaryHex(this.$hex).toString(this.finalFormat);
        };
        HexWriter.prototype.writeString = function (string, lengthFunction) {
            var buffer = BinaryHex.fromUtf8String(string);
            lengthFunction(buffer.length());
            this.$hex += buffer.$hex;
        };
        api.addReader(function (data, format) {
            if (data instanceof BinaryHex || data.$hex) {
                return new HexReader(data.$hex);
            }
            if (format === 'hex') {
                return new HexReader(data);
            }
        });
        api.addWriter(function (format) {
            if (format === 'hex') {
                return new HexWriter();
            }
        });
        return api;
    })();
    CBOR.addSemanticEncode(0, function (data) {
        if (data instanceof Date) {
            return data.toISOString();
        }
    })
        .addSemanticDecode(0, function (isoString) {
        return new Date(isoString);
    })
        .addSemanticDecode(1, function (isoString) {
        return new Date(isoString);
    });
    return CBOR;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js", {"./DataItem":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","./cbor-sync":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = exports.addWriter = exports.addReader = exports.addSemanticEncode = exports.addSemanticDecode = exports.decodeToDataItem = exports.encodeDataItem = void 0;
var cbor_sync_1 = require("./cbor-sync");
Object.defineProperty(exports, "encodeDataItem", { enumerable: true, get: function () { return cbor_sync_1.encodeDataItem; } });
Object.defineProperty(exports, "decodeToDataItem", { enumerable: true, get: function () { return cbor_sync_1.decodeToDataItem; } });
Object.defineProperty(exports, "addSemanticDecode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticDecode; } });
Object.defineProperty(exports, "addSemanticEncode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticEncode; } });
Object.defineProperty(exports, "addReader", { enumerable: true, get: function () { return cbor_sync_1.addReader; } });
Object.defineProperty(exports, "addWriter", { enumerable: true, get: function () { return cbor_sync_1.addWriter; } });
var DataItem_1 = require("./DataItem");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return DataItem_1.DataItem; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js", {"./RegistryType":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CpatchCBOR.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
const registryTags = Object.values(RegistryType_1.RegistryTypes)
    .filter((r) => !!r.getTag())
    .map((r) => r.getTag());
const scriptExpressionTags = Object.values(ScriptExpression_1.ScriptExpressions).map((se) => se.getTag());
(0, utils_1.patchTags)(registryTags.concat(scriptExpressionTags));
//# sourceMappingURL=patchCBOR.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js", {"./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchTags = void 0;
const lib_1 = require("./lib");
const alreadyPatchedTag = [];
const patchTags = (tags) => {
    tags.forEach((tag) => {
        if (alreadyPatchedTag.find((i) => i === tag))
            return;
        (0, lib_1.addSemanticEncode)(tag, (data) => {
            if (data instanceof lib_1.DataItem) {
                if (data.getTag() === tag) {
                    return data.getData();
                }
            }
        });
        (0, lib_1.addSemanticDecode)(tag, (data) => {
            return new lib_1.DataItem(data, tag);
        });
        alreadyPatchedTag.push(tag);
    });
};
exports.patchTags = patchTags;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CMergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CasStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./MergedStore":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5Ctransform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js", {"_process":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\process\\browser.js","readable-stream":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\readable-stream\\readable-browser.js","util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5Cthrough2%5Cthrough2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store>through2",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js", {"@metamask/base-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js","@metamask/controller-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Caddress-book-controller%5Cdist%5CAddressBookController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = exports.AddressType = void 0;
const controller_utils_1 = require("@metamask/controller-utils");
const base_controller_1 = require("@metamask/base-controller");
var AddressType;
(function (AddressType) {
    AddressType["externallyOwnedAccounts"] = "EXTERNALLY_OWNED_ACCOUNTS";
    AddressType["contractAccounts"] = "CONTRACT_ACCOUNTS";
    AddressType["nonAccounts"] = "NON_ACCOUNTS";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
/**
 * Controller that manages a list of recipient addresses associated with nicknames.
 */
class AddressBookController extends base_controller_1.BaseController {
    /**
     * Creates an AddressBookController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries.
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address.
     *
     * @param chainId - Chain id identifies the current chain.
     * @param address - Recipient address to delete.
     * @returns Whether the entry was deleted.
     */
    delete(chainId, address) {
        address = (0, controller_utils_1.toChecksumHexAddress)(address);
        if (!(0, controller_utils_1.isValidHexAddress)(address) ||
            !this.state.addressBook[chainId] ||
            !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address.
     *
     * @param address - Recipient address to add or update.
     * @param name - Nickname to associate with this address.
     * @param chainId - Chain id identifies the current chain.
     * @param memo - User's note about address.
     * @param addressType - Contact's address type.
     * @returns Boolean indicating if the address was successfully set.
     */
    set(address, name, chainId = '1', memo = '', addressType) {
        address = (0, controller_utils_1.toChecksumHexAddress)(address);
        if (!(0, controller_utils_1.isValidHexAddress)(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
            addressType,
        };
        const ensName = (0, controller_utils_1.normalizeEnsName)(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
      };
    };
  }
  }
}, {package:"@metamask/address-book-controller",file:"node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\address-book-controller\\dist\\index.js", {"./AddressBookController":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Caddress-book-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AddressBookController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/address-book-controller",file:"node_modules\\@metamask\\address-book-controller\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js", {"@metamask/base-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cannouncement-controller%5Cdist%5CAnnouncementController.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AnnouncementController_instances, _AnnouncementController_addAnnouncements;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnnouncementController = void 0;
const base_controller_1 = require("@metamask/base-controller");
const controllerName = 'AnnouncementController';
const defaultState = {
    announcements: {},
};
const metadata = {
    announcements: {
        persist: true,
        anonymous: true,
    },
};
/**
 * Controller for managing in-app announcements.
 */
class AnnouncementController extends base_controller_1.BaseControllerV2 {
    /**
     * Creates a AnnouncementController instance.
     *
     * @param args - The arguments to this function.
     * @param args.messenger - Messenger used to communicate with BaseV2 controller.
     * @param args.state - Initial state to set on this controller.
     * @param args.allAnnouncements - Announcements to be passed through to #addAnnouncements
     */
    constructor({ messenger, state, allAnnouncements, }) {
        const mergedState = Object.assign(Object.assign({}, defaultState), state);
        super({ messenger, metadata, name: controllerName, state: mergedState });
        _AnnouncementController_instances.add(this);
        __classPrivateFieldGet(this, _AnnouncementController_instances, "m", _AnnouncementController_addAnnouncements).call(this, allAnnouncements);
    }
    /**
     * Updates the status of the status of the specified announcements
     * once it is read by the user.
     *
     * @param viewedIds - The announcement IDs to mark as viewed.
     */
    updateViewed(viewedIds) {
        this.update(({ announcements }) => {
            for (const id of Object.keys(viewedIds).map(Number)) {
                announcements[id].isShown = viewedIds[id];
            }
        });
    }
}
exports.AnnouncementController = AnnouncementController;
_AnnouncementController_instances = new WeakSet(), _AnnouncementController_addAnnouncements = function _AnnouncementController_addAnnouncements(allAnnouncements) {
    this.update((state) => {
        Object.values(allAnnouncements).forEach((announcement) => {
            var _a;
            state.announcements[announcement.id] = (_a = state.announcements[announcement.id]) !== null && _a !== void 0 ? _a : Object.assign(Object.assign({}, announcement), { isShown: false });
        });
    });
};
//# sourceMappingURL=AnnouncementController.js.map
      };
    };
  }
  }
}, {package:"@metamask/announcement-controller",file:"node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\announcement-controller\\dist\\index.js", {"./AnnouncementController":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cannouncement-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AnnouncementController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/announcement-controller",file:"node_modules\\@metamask\\announcement-controller\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js", {"./errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\errors.js","@metamask/base-controller":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js","eth-rpc-errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","nanoid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5CApprovalController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const base_controller_1 = require("@metamask/base-controller");
const errors_1 = require("./errors");
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends base_controller_1.BaseControllerV2 {
    /**
     * Construct an Approval controller.
     *
     * @param options - The controller options.
     * @param options.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     * @param options.messenger - The restricted controller messenger for the Approval controller.
     * @param options.state - The initial controller state.
     * @param options.typesExcludedFromRateLimiting - Array of aproval types which allow multiple pending approval requests from the same origin.
     */
    constructor({ messenger, showApprovalRequest, state = {}, typesExcludedFromRateLimiting = [], }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._approvals = new Map();
        this._origins = new Map();
        this._showApprovalRequest = showApprovalRequest;
        this._typesExcludedFromRateLimiting = typesExcludedFromRateLimiting;
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:updateRequestState`, this.updateRequestState.bind(this));
    }
    /**
     * Adds an approval request per the given arguments, calls the show approval
     * request function, and returns the associated approval promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * @param opts.requestState - Additional state associated with the request,
     * if any.
     * @returns The approval promise.
     */
    addAndShowApprovalRequest(opts) {
        const promise = this._add(opts.origin, opts.type, opts.id, opts.requestData, opts.requestState);
        this._showApprovalRequest();
        return promise;
    }
    /**
     * Adds an approval request per the given arguments and returns the approval
     * promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    add(opts) {
        return this._add(opts.origin, opts.type, opts.id, opts.requestData, opts.requestState);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts - The approval count options.
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return ((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type)) || 0;
        }
        if (origin) {
            return Array.from((this._origins.get(origin) || new Map()).values()).reduce((total, value) => total + value, 0);
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * Get the total count of all pending approval requests for all origins.
     *
     * @returns The total pending approval request count.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return this._approvals.has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type));
            }
            return this._origins.has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     */
    accept(id, value) {
        this._deleteApprovalAndGetCallbacks(id).resolve(value);
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        this._deleteApprovalAndGetCallbacks(id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     *
     * @param rejectionError - The EthereumRpcError to reject the approval
     * requests with.
     */
    clear(rejectionError) {
        for (const id of this._approvals.keys()) {
            this.reject(id, rejectionError);
        }
        this._origins.clear();
        this.update(() => getDefaultState());
    }
    /**
     * Updates the request state of the approval with the given id.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request.
     * @param opts.requestState - Additional data associated with the request
     */
    updateRequestState(opts) {
        if (!this.state.pendingApprovals[opts.id]) {
            throw new errors_1.ApprovalRequestNotFoundError(opts.id);
        }
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[opts.id].requestState =
                opts.requestState;
        });
    }
    /**
     * Implementation of add operation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param id - The id of the approval request.
     * @param requestData - The request data associated with the approval request.
     * @param requestState - The request state associated with the approval request.
     * @returns The approval promise.
     */
    _add(origin, type, id = (0, nanoid_1.nanoid)(), requestData, requestState) {
        this._validateAddParams(id, origin, type, requestData, requestState);
        if (!this._typesExcludedFromRateLimiting.includes(type) &&
            this.has({ origin, type })) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
        }
        // add pending approval
        return new Promise((resolve, reject) => {
            this._approvals.set(id, { resolve, reject });
            this._addPendingApprovalOrigin(origin, type);
            this._addToStore(id, origin, type, requestData, requestState);
        });
    }
    /**
     * Validates parameters to the add method.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     * @param requestState - The request state associated with the approval request.
     */
    _validateAddParams(id, origin, type, requestData, requestState) {
        let errorMessage = null;
        if (!id || typeof id !== 'string') {
            errorMessage = 'Must specify non-empty string id.';
        }
        else if (this._approvals.has(id)) {
            errorMessage = `Approval request with id '${id}' already exists.`;
        }
        else if (!origin || typeof origin !== 'string') {
            errorMessage = 'Must specify non-empty string origin.';
        }
        else if (!type || typeof type !== 'string') {
            errorMessage = 'Must specify non-empty string type.';
        }
        else if (requestData &&
            (typeof requestData !== 'object' || Array.isArray(requestData))) {
            errorMessage = 'Request data must be a plain object if specified.';
        }
        else if (requestState &&
            (typeof requestState !== 'object' || Array.isArray(requestState))) {
            errorMessage = 'Request state must be a plain object if specified.';
        }
        if (errorMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
        }
    }
    /**
     * Adds an entry to _origins.
     * Performs no validation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     */
    _addPendingApprovalOrigin(origin, type) {
        let originMap = this._origins.get(origin);
        if (!originMap) {
            originMap = new Map();
            this._origins.set(origin, originMap);
        }
        const currentValue = originMap.get(type) || 0;
        originMap.set(type, currentValue + 1);
    }
    /**
     * Adds an entry to the store.
     * Performs no validation.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     * @param requestState - The request state associated with the approval request.
     */
    _addToStore(id, origin, type, requestData, requestState) {
        const approval = {
            id,
            origin,
            type,
            time: Date.now(),
            requestData: requestData || null,
            requestState: requestState || null,
        };
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[id] = approval;
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Deletes the approval with the given id. The approval promise must be
     * resolved or reject before this method is called.
     * Deletion is an internal operation because approval state is solely
     * managed by this controller.
     *
     * @param id - The id of the approval request to be deleted.
     */
    _delete(id) {
        this._approvals.delete(id);
        // This method is only called after verifying that the approval with the
        // specified id exists.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const { origin, type } = this.state.pendingApprovals[id];
        const originMap = this._origins.get(origin);
        const originTotalCount = this.getApprovalCount({ origin });
        const originTypeCount = originMap.get(type);
        if (originTotalCount === 1) {
            this._origins.delete(origin);
        }
        else {
            originMap.set(type, originTypeCount - 1);
        }
        this.update((draftState) => {
            delete draftState.pendingApprovals[id];
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Gets the approval callbacks for the given id, deletes the entry, and then
     * returns the callbacks for promise resolution.
     * Throws an error if no approval is found for the given id.
     *
     * @param id - The id of the approval request.
     * @returns The promise callbacks associated with the approval request.
     */
    _deleteApprovalAndGetCallbacks(id) {
        const callbacks = this._approvals.get(id);
        if (!callbacks) {
            throw new errors_1.ApprovalRequestNotFoundError(id);
        }
        this._delete(id);
        return callbacks;
    }
}
exports.ApprovalController = ApprovalController;
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\errors.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5Cerrors.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalRequestNotFoundError = void 0;
class ApprovalRequestNotFoundError extends Error {
    constructor(id) {
        super(`Approval request with id '${id}' not found.`);
    }
}
exports.ApprovalRequestNotFoundError = ApprovalRequestNotFoundError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\errors.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\index.js", {"./ApprovalController":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js","./errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\errors.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ApprovalController"), exports);
__exportStar(require("./errors"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs", {"./url-alphabet/index.cjs":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cnode_modules%5Cnanoid%5Cindex.browser.cjs
      return function (require, module, exports) {
let { urlAlphabet } = require('./url-alphabet/index.cjs')
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')
module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

      };
    };
  }
  }
}, {package:"@metamask/approval-controller>nanoid",file:"node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cnode_modules%5Cnanoid%5Curl-alphabet%5Cindex.cjs
      return function (require, module, exports) {
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
module.exports = { urlAlphabet }

      };
    };
  }
  }
}, {package:"@metamask/approval-controller>nanoid",file:"node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\browser-passworder\\dist\\index.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cbrowser-passworder%5Cdist%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSalt = exports.serializeBufferForStorage = exports.serializeBufferFromStorage = exports.keyFromPassword = exports.exportKey = exports.importKey = exports.decryptWithKey = exports.decryptWithDetail = exports.decrypt = exports.encryptWithKey = exports.encryptWithDetail = exports.encrypt = void 0;
const EXPORT_FORMAT = 'jwk';
const DERIVED_KEY_FORMAT = 'AES-GCM';
const STRING_ENCODING = 'utf-8';
/**
 * Encrypts a data object that can be any serializable value using
 * a provided password.
 *
 * @param password - The password to use for encryption.
 * @param dataObj - The data to encrypt.
 * @param key - The CryptoKey to encrypt with.
 * @param salt - The salt to use to encrypt.
 * @returns The encrypted vault.
 */
async function encrypt(password, dataObj, key, salt = generateSalt()) {
    const cryptoKey = key || (await keyFromPassword(password, salt));
    const payload = await encryptWithKey(cryptoKey, dataObj);
    payload.salt = salt;
    return JSON.stringify(payload);
}
exports.encrypt = encrypt;
/**
 * Encrypts a data object that can be any serializable value using
 * a provided password.
 *
 * @param password - A password to use for encryption.
 * @param dataObj - The data to encrypt.
 * @param salt - The salt used to encrypt.
 * @returns The vault and exported key string.
 */
async function encryptWithDetail(password, dataObj, salt = generateSalt()) {
    const key = await keyFromPassword(password, salt, true);
    const exportedKeyString = await exportKey(key);
    const vault = await encrypt(password, dataObj, key, salt);
    return {
        vault,
        exportedKeyString,
    };
}
exports.encryptWithDetail = encryptWithDetail;
/**
 * Encrypts the provided serializable javascript object using the
 * provided CryptoKey and returns an object containing the cypher text and
 * the initialization vector used.
 *
 * @param key - The CryptoKey to encrypt with.
 * @param dataObj - A serializable JavaScript object to encrypt.
 * @returns The encrypted data.
 */
async function encryptWithKey(key, dataObj) {
    const data = JSON.stringify(dataObj);
    const dataBuffer = Buffer.from(data, STRING_ENCODING);
    const vector = global.crypto.getRandomValues(new Uint8Array(16));
    const buf = await global.crypto.subtle.encrypt({
        name: DERIVED_KEY_FORMAT,
        iv: vector,
    }, key, dataBuffer);
    const buffer = new Uint8Array(buf);
    const vectorStr = Buffer.from(vector).toString('base64');
    const vaultStr = Buffer.from(buffer).toString('base64');
    return {
        data: vaultStr,
        iv: vectorStr,
    };
}
exports.encryptWithKey = encryptWithKey;
/**
 * Given a password and a cypher text, decrypts the text and returns
 * the resulting value.
 *
 * @param password - The password to decrypt with.
 * @param text - The cypher text to decrypt.
 * @param key - The key to decrypt with.
 * @returns The decrypted data.
 */
async function decrypt(password, text, key) {
    const payload = JSON.parse(text);
    const { salt } = payload;
    const cryptoKey = key || (await keyFromPassword(password, salt));
    const result = await decryptWithKey(cryptoKey, payload);
    return result;
}
exports.decrypt = decrypt;
/**
 * Given a password and a cypher text, decrypts the text and returns
 * the resulting value, keyString, and salt.
 *
 * @param password - The password to decrypt with.
 * @param text - The encrypted vault to decrypt.
 * @returns The decrypted vault along with the salt and exported key.
 */
async function decryptWithDetail(password, text) {
    const payload = JSON.parse(text);
    const { salt } = payload;
    const key = await keyFromPassword(password, salt, true);
    const exportedKeyString = await exportKey(key);
    const vault = await decrypt(password, text, key);
    return {
        exportedKeyString,
        vault,
        salt,
    };
}
exports.decryptWithDetail = decryptWithDetail;
/**
 * Given a CryptoKey and an EncryptionResult object containing the initialization
 * vector (iv) and data to decrypt, return the resulting decrypted value.
 *
 * @param key - The CryptoKey to decrypt with.
 * @param payload - The payload to decrypt, returned from an encryption method.
 * @returns The decrypted data.
 */
async function decryptWithKey(key, payload) {
    const encryptedData = Buffer.from(payload.data, 'base64');
    const vector = Buffer.from(payload.iv, 'base64');
    let decryptedObj;
    try {
        const result = await crypto.subtle.decrypt({ name: DERIVED_KEY_FORMAT, iv: vector }, key, encryptedData);
        const decryptedData = new Uint8Array(result);
        const decryptedStr = Buffer.from(decryptedData).toString(STRING_ENCODING);
        decryptedObj = JSON.parse(decryptedStr);
    }
    catch (e) {
        throw new Error('Incorrect password');
    }
    return decryptedObj;
}
exports.decryptWithKey = decryptWithKey;
/**
 * Receives an exported CryptoKey string and creates a key.
 *
 * @param keyString - The key string to import.
 * @returns A CryptoKey.
 */
async function importKey(keyString) {
    const key = await window.crypto.subtle.importKey(EXPORT_FORMAT, JSON.parse(keyString), DERIVED_KEY_FORMAT, true, ['encrypt', 'decrypt']);
    return key;
}
exports.importKey = importKey;
/**
 * Receives an exported CryptoKey string, creates a key,
 * and decrypts cipher text with the reconstructed key.
 *
 * @param key - The CryptoKey to export.
 * @returns A key string.
 */
async function exportKey(key) {
    const exportedKey = await window.crypto.subtle.exportKey(EXPORT_FORMAT, key);
    return JSON.stringify(exportedKey);
}
exports.exportKey = exportKey;
/**
 * Generate a CryptoKey from a password and random salt.
 *
 * @param password - The password to use to generate key.
 * @param salt - The salt string to use in key derivation.
 * @param exportable - Should the derived key be exportable.
 * @returns A CryptoKey for encryption and decryption.
 */
async function keyFromPassword(password, salt, exportable = false) {
    const passBuffer = Buffer.from(password, STRING_ENCODING);
    const saltBuffer = Buffer.from(salt, 'base64');
    const key = await global.crypto.subtle.importKey('raw', passBuffer, { name: 'PBKDF2' }, false, ['deriveBits', 'deriveKey']);
    const derivedKey = await global.crypto.subtle.deriveKey({
        name: 'PBKDF2',
        salt: saltBuffer,
        iterations: 10000,
        hash: 'SHA-256',
    }, key, { name: DERIVED_KEY_FORMAT, length: 256 }, exportable, ['encrypt', 'decrypt']);
    return derivedKey;
}
exports.keyFromPassword = keyFromPassword;
/**
 * Converts a hex string into a buffer.
 *
 * @param str - Hex encoded string.
 * @returns The string ecoded as a byte array.
 */
function serializeBufferFromStorage(str) {
    const stripStr = str.slice(0, 2) === '0x' ? str.slice(2) : str;
    const buf = new Uint8Array(stripStr.length / 2);
    for (let i = 0; i < stripStr.length; i += 2) {
        const seg = stripStr.substr(i, 2);
        buf[i / 2] = parseInt(seg, 16);
    }
    return buf;
}
exports.serializeBufferFromStorage = serializeBufferFromStorage;
/**
 * Converts a buffer into a hex string ready for storage.
 *
 * @param buffer - Buffer to serialize.
 * @returns A hex encoded string.
 */
function serializeBufferForStorage(buffer) {
    let result = '0x';
    buffer.forEach((value) => {
        result += unprefixedHex(value);
    });
    return result;
}
exports.serializeBufferForStorage = serializeBufferForStorage;
/**
 * Converts a number into hex value, and ensures proper leading 0
 * for single characters strings.
 *
 * @param num - The number to convert to string.
 * @returns An unprefixed hex string.
 */
function unprefixedHex(num) {
    let hex = num.toString(16);
    while (hex.length < 2) {
        hex = `0${hex}`;
    }
    return hex;
}
/**
 * Generates a random string for use as a salt in CryptoKey generation.
 *
 * @param byteCount - The number of bytes to generate.
 * @returns A randomly generated string.
 */
function generateSalt(byteCount = 32) {
    const view = new Uint8Array(byteCount);
    global.crypto.getRandomValues(view);
    // Uint8Array is a fixed length array and thus does not have methods like pop, etc
    // so TypeScript complains about casting it to an array. Array.from() works here for
    // getting the proper type, but it results in a functional difference. In order to
    // cast, you have to first cast view to unknown then cast the unknown value to number[]
    // TypeScript ftw: double opt in to write potentially type-mismatched code.
    const b64encoded = btoa(String.fromCharCode.apply(null, view));
    return b64encoded;
}
exports.generateSalt = generateSalt;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/browser-passworder",file:"node_modules\\@metamask\\browser-passworder\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\index.js", {"@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@metamask/eth-sig-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","@metamask/scure-bip39":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\scure-bip39\\dist\\index.js","@metamask/scure-bip39/dist/wordlists/english":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\scure-bip39\\dist\\wordlists\\english.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereum-cryptography\\hdkey.js","ethereum-cryptography/keccak":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereum-cryptography\\keccak.js","ethereum-cryptography/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereum-cryptography\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { HDKey } = require('ethereum-cryptography/hdkey');
const { keccak256 } = require('ethereum-cryptography/keccak');
const { bytesToHex } = require('ethereum-cryptography/utils');
const {
  stripHexPrefix,
  privateToPublic,
  publicToAddress,
  ecsign,
  arrToBufArr,
  bufferToHex,
} = require('@ethereumjs/util');
const bip39 = require('@metamask/scure-bip39');
const { wordlist } = require('@metamask/scure-bip39/dist/wordlists/english');
const {
  concatSig,
  decrypt,
  getEncryptionPublicKey,
  normalize,
  personalSign,
  signTypedData,
  SignTypedDataVersion,
} = require('@metamask/eth-sig-util');

// Options:
const hdPathString = `m/44'/60'/0'/0`;
const type = 'HD Key Tree';

class HdKeyring {
  /* PUBLIC METHODS */
  constructor(opts = {}) {
    this.type = type;
    this._wallets = [];
    this.deserialize(opts);
  }

  generateRandomMnemonic() {
    this._initFromMnemonic(bip39.generateMnemonic(wordlist));
  }

  _uint8ArrayToString(mnemonic) {
    const recoveredIndices = Array.from(
      new Uint16Array(new Uint8Array(mnemonic).buffer),
    );
    return recoveredIndices.map((i) => wordlist[i]).join(' ');
  }

  _stringToUint8Array(mnemonic) {
    const indices = mnemonic.split(' ').map((word) => wordlist.indexOf(word));
    return new Uint8Array(new Uint16Array(indices).buffer);
  }

  _mnemonicToUint8Array(mnemonic) {
    let mnemonicData = mnemonic;
    // when encrypted/decrypted, buffers get cast into js object with a property type set to buffer
    if (mnemonic && mnemonic.type && mnemonic.type === 'Buffer') {
      mnemonicData = mnemonic.data;
    }

    if (
      // this block is for backwards compatibility with vaults that were previously stored as buffers, number arrays or plain text strings
      typeof mnemonicData === 'string' ||
      Buffer.isBuffer(mnemonicData) ||
      Array.isArray(mnemonicData)
    ) {
      let mnemonicAsString = mnemonicData;
      if (Array.isArray(mnemonicData)) {
        mnemonicAsString = Buffer.from(mnemonicData).toString();
      } else if (Buffer.isBuffer(mnemonicData)) {
        mnemonicAsString = mnemonicData.toString();
      }
      return this._stringToUint8Array(mnemonicAsString);
    } else if (
      mnemonicData instanceof Object &&
      !(mnemonicData instanceof Uint8Array)
    ) {
      // when encrypted/decrypted the Uint8Array becomes a js object we need to cast back to a Uint8Array
      return Uint8Array.from(Object.values(mnemonicData));
    }
    return mnemonicData;
  }

  serialize() {
    const mnemonicAsString = this._uint8ArrayToString(this.mnemonic);
    const uint8ArrayMnemonic = new TextEncoder('utf-8').encode(
      mnemonicAsString,
    );

    return Promise.resolve({
      mnemonic: Array.from(uint8ArrayMnemonic),
      numberOfAccounts: this._wallets.length,
      hdPath: this.hdPath,
    });
  }

  deserialize(opts = {}) {
    if (opts.numberOfAccounts && !opts.mnemonic) {
      throw new Error(
        'Eth-Hd-Keyring: Deserialize method cannot be called with an opts value for numberOfAccounts and no menmonic',
      );
    }

    if (this.root) {
      throw new Error(
        'Eth-Hd-Keyring: Secret recovery phrase already provided',
      );
    }
    this.opts = opts;
    this._wallets = [];
    this.mnemonic = null;
    this.root = null;
    this.hdPath = opts.hdPath || hdPathString;

    if (opts.mnemonic) {
      this._initFromMnemonic(opts.mnemonic);
    }

    if (opts.numberOfAccounts) {
      return this.addAccounts(opts.numberOfAccounts);
    }

    return Promise.resolve([]);
  }

  addAccounts(numberOfAccounts = 1) {
    if (!this.root) {
      throw new Error('Eth-Hd-Keyring: No secret recovery phrase provided');
    }

    const oldLen = this._wallets.length;
    const newWallets = [];
    for (let i = oldLen; i < numberOfAccounts + oldLen; i++) {
      const wallet = this.root.deriveChild(i);
      newWallets.push(wallet);
      this._wallets.push(wallet);
    }
    const hexWallets = newWallets.map((w) => {
      return this._addressfromPublicKey(w.publicKey);
    });
    return Promise.resolve(hexWallets);
  }

  getAccounts() {
    return this._wallets.map((w) => this._addressfromPublicKey(w.publicKey));
  }

  /* BASE KEYRING METHODS */

  // returns an address specific to an app
  async getAppKeyAddress(address, origin) {
    if (!origin || typeof origin !== 'string') {
      throw new Error(`'origin' must be a non-empty string`);
    }
    const wallet = this._getWalletForAccount(address, {
      withAppKeyOrigin: origin,
    });
    const appKeyAddress = normalize(
      publicToAddress(wallet.publicKey).toString('hex'),
    );

    return appKeyAddress;
  }

  // exportAccount should return a hex-encoded private key:
  async exportAccount(address, opts = {}) {
    const wallet = this._getWalletForAccount(address, opts);
    return bytesToHex(wallet.privateKey);
  }

  // tx is an instance of the ethereumjs-transaction class.
  async signTransaction(address, tx, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const signedTx = tx.sign(privKey);
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return signedTx === undefined ? tx : signedTx;
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(address, data, opts = {}) {
    const message = stripHexPrefix(data);
    const privKey = this._getPrivateKeyFor(address, opts);
    const msgSig = ecsign(Buffer.from(message, 'hex'), privKey);
    const rawMsgSig = concatSig(msgSig.v, msgSig.r, msgSig.s);
    return rawMsgSig;
  }

  // For personal_sign, we need to prefix the message:
  async signPersonalMessage(address, msgHex, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const privateKey = Buffer.from(privKey, 'hex');
    const sig = personalSign({ privateKey, data: msgHex });
    return sig;
  }

  // For eth_decryptMessage:
  async decryptMessage(withAccount, encryptedData) {
    const wallet = this._getWalletForAccount(withAccount);
    const { privateKey: privateKeyAsUint8Array } = wallet;
    const privateKeyAsHex = Buffer.from(privateKeyAsUint8Array).toString('hex');
    const sig = decrypt({ privateKey: privateKeyAsHex, encryptedData });
    return sig;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(
    withAccount,
    typedData,
    opts = { version: SignTypedDataVersion.V1 },
  ) {
    // Treat invalid versions as "V1"
    const version = Object.keys(SignTypedDataVersion).includes(opts.version)
      ? opts.version
      : SignTypedDataVersion.V1;

    const privateKey = this._getPrivateKeyFor(withAccount, opts);
    return signTypedData({ privateKey, data: typedData, version });
  }

  removeAccount(account) {
    const address = normalize(account);
    if (
      !this._wallets
        .map(({ publicKey }) => this._addressfromPublicKey(publicKey))
        .includes(address)
    ) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this._wallets = this._wallets.filter(
      ({ publicKey }) => this._addressfromPublicKey(publicKey) !== address,
    );
  }

  // get public key for nacl
  async getEncryptionPublicKey(withAccount, opts = {}) {
    const privKey = this._getPrivateKeyFor(withAccount, opts);
    const publicKey = getEncryptionPublicKey(privKey);
    return publicKey;
  }

  _getPrivateKeyFor(address, opts = {}) {
    if (!address) {
      throw new Error('Must specify address.');
    }
    const wallet = this._getWalletForAccount(address, opts);
    return wallet.privateKey;
  }

  _getWalletForAccount(account, opts = {}) {
    const address = normalize(account);
    let wallet = this._wallets.find(({ publicKey }) => {
      return this._addressfromPublicKey(publicKey) === address;
    });
    if (!wallet) {
      throw new Error('HD Keyring - Unable to find matching address.');
    }

    if (opts.withAppKeyOrigin) {
      const { privateKey } = wallet;
      const appKeyOriginBuffer = Buffer.from(opts.withAppKeyOrigin, 'utf8');
      const appKeyBuffer = Buffer.concat([privateKey, appKeyOriginBuffer]);
      const appKeyPrivateKey = arrToBufArr(keccak256(appKeyBuffer, 256));
      const appKeyPublicKey = privateToPublic(appKeyPrivateKey);
      wallet = { privateKey: appKeyPrivateKey, publicKey: appKeyPublicKey };
    }

    return wallet;
  }

  /* PRIVATE / UTILITY METHODS */

  /**
   * Sets appropriate properties for the keyring based on the given
   * BIP39-compliant mnemonic.
   *
   * @param {string|Array<number>|Buffer} mnemonic - A seed phrase represented
   * as a string, an array of UTF-8 bytes, or a Buffer. Mnemonic input
   * passed as type buffer or array of UTF-8 bytes must be NFKD normalized.
   */
  _initFromMnemonic(mnemonic) {
    if (this.root) {
      throw new Error(
        'Eth-Hd-Keyring: Secret recovery phrase already provided',
      );
    }

    this.mnemonic = this._mnemonicToUint8Array(mnemonic);

    // validate before initializing
    const isValid = bip39.validateMnemonic(this.mnemonic, wordlist);
    if (!isValid) {
      throw new Error(
        'Eth-Hd-Keyring: Invalid secret recovery phrase provided',
      );
    }

    // eslint-disable-next-line node/no-sync
    const seed = bip39.mnemonicToSeedSync(this.mnemonic, wordlist);
    this.hdWallet = HDKey.fromMasterSeed(seed);
    this.root = this.hdWallet.derive(this.hdPath);
  }

  // small helper function to convert publicKey in Uint8Array form to a publicAddress as a hex
  _addressfromPublicKey(publicKey) {
    return bufferToHex(
      publicToAddress(Buffer.from(publicKey), true),
    ).toLowerCase();
  }
}

HdKeyring.type = type;
module.exports = HdKeyring;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring",file:"node_modules\\@metamask\\eth-hd-keyring\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js", {"./fetch-config-from-req":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js","./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js","eth-rpc-errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\node-fetch\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Ccreate-infura-middleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInfuraMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const node_fetch_1 = __importDefault(require("node-fetch"));
const fetch_config_from_req_1 = require("./fetch-config-from-req");
const logging_utils_1 = require("./logging-utils");
const log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, 'create-infura-middleware');
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    'ECONNRESET',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
];
/**
 * Builds [`json-rpc-engine`](https://github.com/MetaMask/json-rpc-engine)-compatible middleware designed
 * for interfacing with Infura's JSON-RPC endpoints.
 *
 * @param opts - The options.
 * @param opts.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io` (default: 'mainnet').
 * @param opts.maxAttempts - The number of times a request to Infura should be
 * retried in the case of failure (default: 5).
 * @param opts.source - A descriptor for the entity making the request; tracked
 * by Infura for analytics purposes.
 * @param opts.projectId - The Infura project id.
 * @param opts.headers - Extra headers that will be used to make the request.
 * @returns The `json-rpc-engine`-compatible middleware.
 */
function createInfuraMiddleware({ network = 'mainnet', maxAttempts = 5, source, projectId, headers = {}, }) {
    // validate options
    if (!projectId || typeof projectId !== 'string') {
        throw new Error(`Invalid value for 'projectId': "${projectId}"`);
    }
    if (!headers || typeof headers !== 'object') {
        throw new Error(`Invalid value for 'headers': "${headers}"`);
    }
    if (!maxAttempts) {
        throw new Error(`Invalid value for 'maxAttempts': "${maxAttempts}" (${typeof maxAttempts})`);
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res) => {
        // retry MAX_ATTEMPTS times, if error matches filter
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                // attempt request
                log('Attempting request to Infura. network = %o, projectId = %s, headers = %o, req = %o', network, projectId, headers, req);
                await performFetch(network, projectId, headers, req, res, source);
                // request was successful
                break;
            }
            catch (err) {
                // an error was caught while performing the request
                // if not retriable, resolve with the encountered error
                if (!isRetriableError(err)) {
                    // abort with error
                    log('Non-retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                    throw err;
                }
                // if no more attempts remaining, throw an error
                const remainingAttempts = maxAttempts - attempt;
                if (!remainingAttempts) {
                    log('Retriable request error encountered, but exceeded max attempts. req = %o, res = %o, error = %o', req, res, err);
                    const errMsg = `InfuraProvider - cannot complete request. All retries exhausted.\nOriginal Error:\n${err.toString()}\n\n`;
                    const retriesExhaustedErr = new Error(errMsg);
                    throw retriesExhaustedErr;
                }
                // otherwise, ignore error and retry again after timeout
                log('Retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                log('Waiting 1 second to try again...');
                await timeout(1000);
            }
        }
        // request was handled correctly, end
    });
}
exports.createInfuraMiddleware = createInfuraMiddleware;
/**
 * Makes a request to Infura, updating the given response object if the response
 * has a "successful" status code or throwing an error otherwise.
 *
 * @param network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param projectId - The Infura project id.
 * @param extraHeaders - Extra headers that will be used to make the request.
 * @param req - The original request object obtained via the middleware stack.
 * @param res - The original response object obtained via the middleware stack.
 * @param source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @throws an error with a detailed message if the HTTP status code is anywhere
 * outside 2xx, and especially if it is 405, 429, 503, or 504.
 */
async function performFetch(network, projectId, extraHeaders, req, res, source) {
    const { fetchUrl, fetchParams } = (0, fetch_config_from_req_1.fetchConfigFromReq)({
        network,
        projectId,
        extraHeaders,
        req,
        source,
    });
    const response = await (0, node_fetch_1.default)(fetchUrl, fetchParams);
    const rawData = await response.text();
    // handle errors
    if (!response.ok) {
        switch (response.status) {
            case 405:
                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
            case 429:
                throw createRatelimitError();
            case 503:
            case 504:
                throw createTimeoutError();
            default:
                throw createInternalError(rawData);
        }
    }
    // special case for now
    if (req.method === 'eth_getBlockByNumber' && rawData === 'Not Found') {
        res.result = null;
        return;
    }
    // parse JSON
    const data = JSON.parse(rawData);
    // finally return result
    res.result = data.result;
    res.error = data.error;
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a rate-limiting
 * error.
 *
 * @returns The error object.
 */
function createRatelimitError() {
    const msg = `Request is being rate limited.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a timeout error.
 *
 * @returns The error object.
 */
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object.
 *
 * @param msg - The message.
 * @returns The error object.
 */
function createInternalError(msg) {
    return eth_rpc_errors_1.ethErrors.rpc.internal(msg);
}
/**
 * Upon making a request, we may get an error that is temporary and
 * intermittent. In these cases we can attempt the request again with the
 * assumption that the error is unlikely to occur again. Here we determine if we
 * have received such an error.
 *
 * @param err - The error object.
 * @returns Whether the request that produced the error can be retried.
 */
function isRetriableError(err) {
    const errMessage = err.toString();
    return RETRIABLE_ERRORS.some((phrase) => errMessage.includes(phrase));
}
/**
 * A utility function that promisifies `setTimeout`.
 *
 * @param length - The number of milliseconds to wait.
 * @returns A promise that resolves after the given time has elapsed.
 */
function timeout(length) {
    return new Promise((resolve) => {
        setTimeout(resolve, length);
    });
}
//# sourceMappingURL=create-infura-middleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js", {"./create-infura-middleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","eth-json-rpc-middleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Ccreate-provider.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProvider = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_json_rpc_middleware_1 = require("eth-json-rpc-middleware");
const create_infura_middleware_1 = require("./create-infura-middleware");
/**
 * Creates a provider (as defined in
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)
 * which is preloaded with middleware specialized for interfacing with Infura
 * JSON-RPC endpoints.
 *
 * @param opts - Options to {@link createInfuraMiddleware}.
 * @returns The provider as returned by `providerFromEngine` (a part of
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)).
 */
function createProvider(opts) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push((0, create_infura_middleware_1.createInfuraMiddleware)(opts));
    return (0, eth_json_rpc_middleware_1.providerFromEngine)(engine);
}
exports.createProvider = createProvider;
//# sourceMappingURL=create-provider.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Cfetch-config-from-req.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchConfigFromReq = void 0;
/**
 * Determines the arguments to feed into `fetch` in order to make a request to
 * Infura.
 *
 * @param options - The options.
 * @param options.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param options.projectId - The Infura project id.
 * @param options.extraHeaders - Extra headers that will be used to make the
 * request.
 * @param options.req - The original request object obtained via the
 * middleware stack.
 * @param options.source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @returns An object containing the URL and a bag of options, both of which
 * will be passed to `fetch`.
 */
function fetchConfigFromReq({ network, projectId, extraHeaders = {}, req, source, }) {
    const requestOrigin = req.origin || 'internal';
    const headers = Object.assign({}, extraHeaders, {
        Accept: 'application/json',
        'Content-Type': 'application/json',
    });
    if (source) {
        headers['Infura-Source'] = `${source}/${requestOrigin}`;
    }
    return {
        fetchUrl: `https://${network}.infura.io/v3/${projectId}`,
        fetchParams: {
            method: 'POST',
            headers,
            body: JSON.stringify(normalizeReq(req)),
        },
    };
}
exports.fetchConfigFromReq = fetchConfigFromReq;
/**
 * Strips out extra keys from a request object that could be rejected by strict
 * nodes like parity.
 *
 * @param req - The original request object obtained via the middleware stack.
 * @returns An object that describes a JSON-RPC request.
 */
function normalizeReq(req) {
    return {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
}
//# sourceMappingURL=fetch-config-from-req.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\index.js", {"./create-infura-middleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","./create-provider":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js","./fetch-config-from-req":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./create-infura-middleware"), exports);
__exportStar(require("./fetch-config-from-req"), exports);
__exportStar(require("./create-provider"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = (0, utils_1.createProjectLogger)('eth-json-rpc-infura');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js", {"./base64":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cchecksum.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecksumStruct = void 0;
const superstruct_1 = require("superstruct");
const base64_1 = require("./base64");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
//# sourceMappingURL=checksum.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccoercers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;
//# sourceMappingURL=coercers.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccollections.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Chex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;
//# sourceMappingURL=hex.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./base64":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js","./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js","./checksum":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js","./coercers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js","./collections":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","./json":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js","./logging":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js","./misc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js","./number":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js","./opaque":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js","./time":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js","./versions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./base64"), exports);
__exportStar(require("./bytes"), exports);
__exportStar(require("./checksum"), exports);
__exportStar(require("./coercers"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./hex"), exports);
__exportStar(require("./json"), exports);
__exportStar(require("./logging"), exports);
__exportStar(require("./misc"), exports);
__exportStar(require("./number"), exports);
__exportStar(require("./opaque"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./versions"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./misc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const misc_1 = require("./misc");
exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
    const [isValid] = validateJsonAndGetSize(value, true);
    if (!isValid) {
        return 'Expected a valid JSON-serializable value';
    }
    return true;
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            return [false, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, (0, misc_1.calculateNumberSize)(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js", {"debug":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Clogging.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(require("debug"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;
//# sourceMappingURL=logging.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cmisc.js
      return function (require, module, exports) {
"use strict";
//
// Types
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;
//# sourceMappingURL=misc.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cnumber.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;
//# sourceMappingURL=number.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Copaque.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=opaque.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ctime.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
//# sourceMappingURL=time.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\index.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cversions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = require("semver");
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;
//# sourceMappingURL=versions.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-cache');
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCacheForPayload(_payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(payload, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        // lookup payload in block cache
        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(payload, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(payload, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(payload) {
        // check request method
        if (!cache_1.canCache(payload)) {
            return false;
        }
        // check blockTag
        const blockTag = cache_1.blockTagForPayload(payload);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(payload, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (payload.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache,
    };
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = cache_1.cacheTypeForPayload(req);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        let blockTag = cache_1.blockTagForPayload(req);
        if (!blockTag) {
            blockTag = 'latest';
        }
        log('blockTag = %o, req = %o', blockTag, req);
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            log('Fetching latest block number to determine cache key');
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            log('Clearing values stored under block numbers before %o', latestBlockNumber);
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            log('No cache stored under block number %o, carrying request forward', requestedBlockNumber);
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            log('Populating cache with', res);
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            log('Cache hit, reusing cache result stored under block number %o', requestedBlockNumber);
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, _res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (req.params) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-ref');
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a, _b;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        const blockRef = (_b = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex]) !== null && _b !== void 0 ? _b : 'latest';
        // skip if not "latest"
        if (blockRef !== 'latest') {
            log('blockRef is not "latest", carrying request forward');
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        log(`blockRef is "latest", setting param ${blockRefIndex} to latest block ${latestBlockNumber}`);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        if (childRequest.params) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        log('Performing another request %o', childRequest);
        const childRes = await pify_1.default(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return undefined;
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-tracker-inspector');
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        if (!((_a = res.result) === null || _a === void 0 ? void 0 : _a.blockNumber)) {
            return undefined;
        }
        log('res.result.blockNumber exists, proceeding. res = %o', res);
        if (typeof res.result.blockNumber === 'string') {
            // if number is higher, suggest block-tracker check for a new block
            const blockNumber = Number.parseInt(res.result.blockNumber, 16);
            // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
            const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
            if (blockNumber > currentBlockNumber) {
                log('blockNumber from response is greater than current block number, refreshing current block number');
                await blockTracker.checkForLatestBlock();
            }
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js", {"btoa":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","eth-rpc-errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cfetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
/* eslint-disable @typescript-eslint/no-require-imports,@typescript-eslint/no-shadow */
const fetch = global.fetch || require('node-fetch');
const btoa = global.btoa || require('btoa');
/* eslint-enable @typescript-eslint/no-require-imports,@typescript-eslint/no-shadow */
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
function createFetchMiddleware({ rpcUrl, originHttpHeaderKey, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./providerFromEngine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","./providerFromMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js","./retryOnEmpty":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./providerFromEngine"), exports);
__exportStar(require("./providerFromMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cinflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'inflight-cache');
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = cache_1.cacheIdentifierForPayload(req);
        // if not cacheable, skip
        if (!cacheId) {
            log('Request is not cacheable, proceeding. req = %o', req);
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            log('Running %i handler(s) for request %o', activeRequestHandlers.length, req);
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        log('Carrying original request forward %o', req);
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        log('Running %i collected handler(s) for request %o', activeRequestHandlers.length, req);
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = clone_1.default(handledRes.result);
            res.error = clone_1.default(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = utils_1.createProjectLogger('eth-json-rpc-middleware');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err instanceof Error) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js", {"@metamask/safe-event-emitter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderFromEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
function providerFromEngine(engine) {
    const provider = new safe_event_emitter_1.default();
    // handle both rpc send methods
    provider.sendAsync = (req, cb) => {
        engine.handle(req, cb);
    };
    provider.send = (req, callback) => {
        if (typeof callback !== 'function') {
            throw new Error('Must provide callback to "send" method.');
        }
        engine.handle(req, callback);
    };
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            provider.emit('data', null, message);
        });
    }
    return provider;
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=providerFromEngine.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js", {"./providerFromEngine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderFromMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const providerFromEngine_1 = require("./providerFromEngine");
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = providerFromEngine_1.providerFromEngine(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=providerFromMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CretryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'retry-on-empty');
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            log('Requested block number %o is higher than latest block number %o, falling through to original request', blockRefNumber, latestBlockNumber);
            return next();
        }
        log('Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received', blockRefNumber, latestBlockNumber);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            log('Performing request %o', childRequest);
            const attemptResponse = await pify_1.default(provider.sendAsync).call(provider, childRequest);
            log('Response is %o', attemptResponse);
            // verify result
            if (emptyValues.includes(attemptResponse.result)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        log('Copying result %o and error %o', childResponse.result, childResponse.error);
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return undefined;
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            log('(call %i) Request failed, waiting 1s to retry again...', index + 1);
            await timeout(1000);
        }
    }
    log('Retries exhausted');
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"json-stable-stringify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-stable-stringify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ccache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForPayload = exports.blockTagParamIndex = exports.paramsWithoutBlockTag = exports.blockTagForPayload = exports.canCache = exports.cacheIdentifierForPayload = void 0;
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(payload)
        : (_a = payload.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(payload)) {
        return `${payload.method}:${json_stable_stringify_1.default(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    if (!payload.params) {
        return undefined;
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return undefined;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    if (!payload.params) {
        return [];
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return 'block';
        // never cache
        default:
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;
//# sourceMappingURL=cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js", {"@metamask/eth-sig-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","eth-rpc-errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cwallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("@metamask/eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return json_rpc_engine_1.createScaffoldMiddleware({
        // account lookups
        eth_accounts: json_rpc_engine_1.createAsyncMiddleware(lookupAccounts),
        eth_coinbase: json_rpc_engine_1.createAsyncMiddleware(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: json_rpc_engine_1.createAsyncMiddleware(sendTransaction),
        eth_signTransaction: json_rpc_engine_1.createAsyncMiddleware(signTransaction),
        // message signatures
        eth_sign: json_rpc_engine_1.createAsyncMiddleware(ethSign),
        eth_signTypedData: json_rpc_engine_1.createAsyncMiddleware(signTypedData),
        eth_signTypedData_v3: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV3),
        eth_signTypedData_v4: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV4),
        personal_sign: json_rpc_engine_1.createAsyncMiddleware(personalSign),
        eth_getEncryptionPublicKey: json_rpc_engine_1.createAsyncMiddleware(encryptionPublicKey),
        eth_decrypt: json_rpc_engine_1.createAsyncMiddleware(decryptMessage),
        personal_ecRecover: json_rpc_engine_1.createAsyncMiddleware(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const signerAddress = sigUtil.recoverPersonalSignature({
            data: message,
            signature,
        });
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' &&
            address.length > 0 &&
            resemblesAddress(address)) {
            // ensure address is included in provided accounts. `suppressUnauthorized: false` is passed to `getAccounts`
            // so that an "unauthorized" error is thrown if the requester does not have the `eth_accounts`
            // permission.
            const accounts = await getAccounts(req, {
                suppressUnauthorized: false,
            });
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Cpify%5Cindex.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>pify",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-cache');
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCache(blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(request, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCache(requestedBlockNumber);
        // lookup payload in block cache
        const identifier = cache_1.cacheIdentifierForRequest(request, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(request, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(request, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = cache_1.cacheIdentifierForRequest(request, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCache(requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(request) {
        // check request method
        if (!cache_1.canCache(request.method)) {
            return false;
        }
        // check blockTag
        const blockTag = cache_1.blockTagForRequest(request);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(request, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (request.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(request.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        [cache_1.CacheStrategy.Permanent]: blockCache,
        [cache_1.CacheStrategy.Block]: blockCache,
        [cache_1.CacheStrategy.Fork]: blockCache,
        [cache_1.CacheStrategy.Never]: undefined,
    };
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = cache_1.cacheTypeForMethod(req.method);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        const requestBlockTag = cache_1.blockTagForRequest(req);
        const blockTag = requestBlockTag && typeof requestBlockTag === 'string'
            ? requestBlockTag
            : 'latest';
        log('blockTag = %o, req = %o', blockTag, req);
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            log('Fetching latest block number to determine cache key');
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            log('Clearing values stored under block numbers before %o', latestBlockNumber);
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            log('No cache stored under block number %o, carrying request forward', requestedBlockNumber);
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            log('Populating cache with', res);
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            log('Cache hit, reusing cache result stored under block number %o', requestedBlockNumber);
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, _res, next) => {
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = Array.isArray(req.params)
            ? req.params[blockRefIndex]
            : undefined;
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (Array.isArray(req.params)) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-ref');
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        const blockRef = Array.isArray(req.params)
            ? (_a = req.params[blockRefIndex]) !== null && _a !== void 0 ? _a : 'latest'
            : 'latest';
        // skip if not "latest"
        if (blockRef !== 'latest') {
            log('blockRef is not "latest", carrying request forward');
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        log(`blockRef is "latest", setting param ${blockRefIndex} to latest block ${latestBlockNumber}`);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        if (Array.isArray(childRequest.params)) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        log('Performing another request %o', childRequest);
        const childRes = await pify_1.default(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return undefined;
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-tracker-inspector');
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
/**
 * Determines whether the given object has the given property.
 *
 * @param objectToCheck - The object to check.
 * @param property - The property to look for.
 * @returns - Whether the object has the property.
 */
function hasProperty(objectToCheck, property) {
    return Object.hasOwnProperty.call(objectToCheck, property);
}
function getResultBlockNumber(response) {
    const { result } = response;
    if (!result ||
        typeof result !== 'object' ||
        !hasProperty(result, 'blockNumber')) {
        return undefined;
    }
    if (typeof result.blockNumber === 'string') {
        return result.blockNumber;
    }
    return undefined;
}
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        const responseBlockNumber = getResultBlockNumber(res);
        if (!responseBlockNumber) {
            return undefined;
        }
        log('res.result.blockNumber exists, proceeding. res = %o', res);
        // if number is higher, suggest block-tracker check for a new block
        const blockNumber = Number.parseInt(responseBlockNumber, 16);
        // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
        const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
        if (blockNumber > currentBlockNumber) {
            log('blockNumber from response is greater than current block number, refreshing current block number');
            await blockTracker.checkForLatestBlock();
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js", {"./utils/timeout":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js","eth-rpc-errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cfetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const timeout_1 = require("./utils/timeout");
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
/**
 * Create middleware for sending a JSON-RPC request to the given RPC URL.
 *
 * @param options - Options
 * @param options.btoa - Generates a base64-encoded string from a binary string.
 * @param options.fetch - The `fetch` function; expected to be equivalent to `window.fetch`.
 * @param options.rpcUrl - The URL to send the request to.
 * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request
 * will be attached to each outgoing fetch request under this header.
 * @returns The fetch middleware.
 */
function createFetchMiddleware({ 
// eslint-disable-next-line @typescript-eslint/no-shadow
btoa, 
// eslint-disable-next-line @typescript-eslint/no-shadow
fetch, rpcUrl, originHttpHeaderKey, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            btoa,
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout_1.timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
/**
 * Generate `fetch` configuration for sending the given request to an RPC API.
 *
 * @param options - Options
 * @param options.btoa - Generates a base64-encoded string from a binary string.
 * @param options.rpcUrl - The URL to send the request to.
 * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request
 * will be attached to each outgoing fetch request under this header.
 * @returns The fetch middleware.
 */
function createFetchConfigFromReq({ 
// eslint-disable-next-line @typescript-eslint/no-shadow
btoa, req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./retryOnEmpty":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cinflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'inflight-cache');
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = cache_1.cacheIdentifierForRequest(req);
        // if not cacheable, skip
        if (!cacheId) {
            log('Request is not cacheable, proceeding. req = %o', req);
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            log('Running %i handler(s) for request %o', activeRequestHandlers.length, req);
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        log('Carrying original request forward %o', req);
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        log('Running %i collected handler(s) for request %o', activeRequestHandlers.length, req);
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = clone_1.default(handledRes.result);
            res.error = clone_1.default(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = utils_1.createProjectLogger('eth-json-rpc-middleware');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5CproviderAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err instanceof Error) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                // TODO: Remove this cast when next major `json-rpc-engine` release is out
                // The next release changes how errors are propogated.
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","./utils/timeout":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js","clone":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5CretryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const timeout_1 = require("./utils/timeout");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'retry-on-empty');
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = Array.isArray(req.params)
            ? req.params[blockRefIndex]
            : undefined;
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            log('Requested block number %o is higher than latest block number %o, falling through to original request', blockRefNumber, latestBlockNumber);
            return next();
        }
        log('Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received', blockRefNumber, latestBlockNumber);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            log('Performing request %o', childRequest);
            const attemptResponse = await pify_1.default(provider.sendAsync).call(provider, childRequest);
            log('Response is %o', attemptResponse);
            // verify result
            if (emptyValues.includes(attemptResponse.result)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        log('Copying result %o and error %o', childResponse.result, childResponse.error);
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return undefined;
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            log('(call %i) Request failed, waiting 1s to retry again...', index + 1);
            await timeout_1.timeout(1000);
        }
    }
    log('Retries exhausted');
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"safe-stable-stringify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-stable-stringify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ccache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForMethod = exports.blockTagParamIndex = exports.blockTagForRequest = exports.canCache = exports.cacheIdentifierForRequest = exports.CacheStrategy = void 0;
const safe_stable_stringify_1 = require("safe-stable-stringify");
const stringify = safe_stable_stringify_1.configure({ bigint: false, circularValue: Error });
/**
 * The cache strategy to use for a given method.
 */
var CacheStrategy;
(function (CacheStrategy) {
    /**
     * Cache per-block.
     */
    CacheStrategy["Block"] = "block";
    /**
     * Cache until a chain reorganization occurs.
     */
    CacheStrategy["Fork"] = "fork";
    /**
     * Never cache.
     */
    CacheStrategy["Never"] = "never";
    /**
     * Permanently cache.
     */
    CacheStrategy["Permanent"] = "perma";
})(CacheStrategy = exports.CacheStrategy || (exports.CacheStrategy = {}));
/*
 * Return a cache identifier for the given request.
 *
 * This identifier should include any request details that might impact the
 * response, with the exception of the block parameter if the `skipBlockRef`
 * option is set,
 *
 * If the request cannot be cached, this will return `null`.
 *
 * @param request - The JSON-RPC request.
 * @param skipBlockRef - Skip the block parameter when generating the cache
 * identifier.
 * @returns The cache identifier for this request, or `null` if it can't be
 * cached.
 */
function cacheIdentifierForRequest(request, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(request)
        : (_a = request.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(request.method)) {
        return `${request.method}:${stringify(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForRequest = cacheIdentifierForRequest;
/**
 * Return whether a method can be cached or not.
 *
 * @param method - The method to check.
 * @returns Whether the method can be cached.
 */
function canCache(method) {
    return cacheTypeForMethod(method) !== CacheStrategy.Never;
}
exports.canCache = canCache;
/**
 * Return the block parameter for the given request, if it has one.
 *
 * @param request - The JSON-RPC request.
 * @returns The block parameter in the given request, or `undefined` if none was found.
 */
function blockTagForRequest(request) {
    if (!request.params) {
        return undefined;
    }
    const index = blockTagParamIndex(request.method);
    // Block tag param not passed.
    if (index === undefined ||
        !Array.isArray(request.params) ||
        index >= request.params.length) {
        return undefined;
    }
    return request.params[index];
}
exports.blockTagForRequest = blockTagForRequest;
/**
 * Return the request parameters without the block parameter.
 *
 * @param request - The JSON-RPC request.
 * @returns The request parameters with the block parameter removed, if one was found.
 */
function paramsWithoutBlockTag(request) {
    if (!request.params) {
        return [];
    }
    const index = blockTagParamIndex(request.method);
    // Block tag param not passed.
    if (index === undefined ||
        !Array.isArray(request.params) ||
        index >= request.params.length) {
        return request.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (request.method === 'eth_getBlockByNumber') {
        return request.params.slice(1);
    }
    return request.params.slice(0, index);
}
/**
 * Returns the index of the block parameter for the given method.
 *
 * @param method - A JSON-RPC method.
 * @returns The index of the block parameter for that method, or `undefined` if
 * there is no known block parameter.
 */
function blockTagParamIndex(method) {
    switch (method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
/**
 * Return the cache type used for the given method.
 *
 * @param method - A JSON-RPC method.
 * @returns The cache type to use for that method.
 */
function cacheTypeForMethod(method) {
    switch (method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return CacheStrategy.Permanent;
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return CacheStrategy.Fork;
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return CacheStrategy.Block;
        // never cache
        default:
            return CacheStrategy.Never;
    }
}
exports.cacheTypeForMethod = cacheTypeForMethod;
//# sourceMappingURL=cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ctimeout.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeout = void 0;
/**
 * Wait the specified number of milliseconds.
 *
 * @param duration - The number of milliseconds to wait.
 * @returns A promise that resolves after the specified amount of time.
 */
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
exports.timeout = timeout;
//# sourceMappingURL=timeout.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js", {"@metamask/eth-sig-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","eth-rpc-errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cwallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("@metamask/eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return json_rpc_engine_1.createScaffoldMiddleware({
        // account lookups
        eth_accounts: json_rpc_engine_1.createAsyncMiddleware(lookupAccounts),
        eth_coinbase: json_rpc_engine_1.createAsyncMiddleware(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: json_rpc_engine_1.createAsyncMiddleware(sendTransaction),
        eth_signTransaction: json_rpc_engine_1.createAsyncMiddleware(signTransaction),
        // message signatures
        eth_sign: json_rpc_engine_1.createAsyncMiddleware(ethSign),
        eth_signTypedData: json_rpc_engine_1.createAsyncMiddleware(signTypedData),
        eth_signTypedData_v3: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV3),
        eth_signTypedData_v4: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV4),
        personal_sign: json_rpc_engine_1.createAsyncMiddleware(personalSign),
        eth_getEncryptionPublicKey: json_rpc_engine_1.createAsyncMiddleware(encryptionPublicKey),
        eth_decrypt: json_rpc_engine_1.createAsyncMiddleware(decryptMessage),
        personal_ecRecover: json_rpc_engine_1.createAsyncMiddleware(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const signerAddress = sigUtil.recoverPersonalSignature({
            data: message,
            signature,
        });
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' &&
            address.length > 0 &&
            resemblesAddress(address)) {
            // Ensure that an "unauthorized" error is thrown if the requester does not have the `eth_accounts`
            // permission.
            const accounts = await getAccounts(req);
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js", {"./base64":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cchecksum.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecksumStruct = void 0;
const superstruct_1 = require("superstruct");
const base64_1 = require("./base64");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
//# sourceMappingURL=checksum.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccoercers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;
//# sourceMappingURL=coercers.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccollections.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Chex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;
//# sourceMappingURL=hex.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./base64":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js","./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js","./checksum":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js","./coercers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js","./collections":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","./json":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js","./logging":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js","./misc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js","./number":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js","./opaque":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js","./time":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js","./versions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./base64"), exports);
__exportStar(require("./bytes"), exports);
__exportStar(require("./checksum"), exports);
__exportStar(require("./coercers"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./hex"), exports);
__exportStar(require("./json"), exports);
__exportStar(require("./logging"), exports);
__exportStar(require("./misc"), exports);
__exportStar(require("./number"), exports);
__exportStar(require("./opaque"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./versions"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./misc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const misc_1 = require("./misc");
exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
    const [isValid] = validateJsonAndGetSize(value, true);
    if (!isValid) {
        return 'Expected a valid JSON-serializable value';
    }
    return true;
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            return [false, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, (0, misc_1.calculateNumberSize)(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js", {"debug":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Clogging.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(require("debug"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;
//# sourceMappingURL=logging.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cmisc.js
      return function (require, module, exports) {
"use strict";
//
// Types
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;
//# sourceMappingURL=misc.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cnumber.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;
//# sourceMappingURL=number.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Copaque.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=opaque.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ctime.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
//# sourceMappingURL=time.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\index.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cversions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = require("semver");
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;
//# sourceMappingURL=versions.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5Cpify%5Cindex.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>pify",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\index.js", {"./provider-from-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js","./provider-from-middleware":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./provider-from-engine"), exports);
__exportStar(require("./provider-from-middleware"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js", {"./safe-event-emitter-provider":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cprovider-from-engine.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_provider_1 = require("./safe-event-emitter-provider");
/**
 * Construct an Ethereum provider from the given JSON-RPC engine.
 *
 * @param engine - The JSON-RPC engine to construct a provider from.
 * @returns An Ethereum provider.
 */
function providerFromEngine(engine) {
    return new safe_event_emitter_provider_1.SafeEventEmitterProvider({ engine });
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=provider-from-engine.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js", {"./provider-from-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cprovider-from-middleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const provider_from_engine_1 = require("./provider-from-engine");
/**
 * Construct an Ethereum provider from the given middleware.
 *
 * @param middleware - The middleware to construct a provider from.
 * @returns An Ethereum provider.
 */
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = (0, provider_from_engine_1.providerFromEngine)(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=provider-from-middleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js", {"@metamask/safe-event-emitter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Csafe-event-emitter-provider.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SafeEventEmitterProvider_engine;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeEventEmitterProvider = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
/**
 * An Ethereum provider.
 *
 * This provider loosely follows conventions that pre-date EIP-1193.
 * It is not compliant with any Ethereum provider standard.
 */
class SafeEventEmitterProvider extends safe_event_emitter_1.default {
    /**
     * Construct a SafeEventEmitterProvider from a JSON-RPC engine.
     *
     * @param options - Options.
     * @param options.engine - The JSON-RPC engine used to process requests.
     */
    constructor({ engine }) {
        super();
        _SafeEventEmitterProvider_engine.set(this, void 0);
        /**
         * Send a provider request asynchronously.
         *
         * @param req - The request to send.
         * @param callback - A function that is called upon the success or failure of the request.
         */
        this.sendAsync = (req, callback) => {
            __classPrivateFieldGet(this, _SafeEventEmitterProvider_engine, "f").handle(req, callback);
        };
        /**
         * Send a provider request asynchronously.
         *
         * This method serves the same purpose as `sendAsync`. It only exists for
         * legacy reasons.
         *
         * @deprecated Use `sendAsync` instead.
         * @param req - The request to send.
         * @param callback - A function that is called upon the success or failure of the request.
         */
        this.send = (req, callback) => {
            if (typeof callback !== 'function') {
                throw new Error('Must provide callback to "send" method.');
            }
            __classPrivateFieldGet(this, _SafeEventEmitterProvider_engine, "f").handle(req, callback);
        };
        __classPrivateFieldSet(this, _SafeEventEmitterProvider_engine, engine, "f");
        if (engine.on) {
            engine.on('notification', (message) => {
                this.emit('data', null, message);
            });
        }
    }
}
exports.SafeEventEmitterProvider = SafeEventEmitterProvider;
_SafeEventEmitterProvider_engine = new WeakMap();
//# sourceMappingURL=safe-event-emitter-provider.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\index.js", {"@metamask/browser-passworder":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\browser-passworder\\dist\\index.js","@metamask/eth-hd-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\index.js","@metamask/eth-sig-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","@metamask/eth-simple-keyring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\index.js","events":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","obs-store":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\obs-store\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cindex.js
      return function (require, module, exports) {
const encryptor = require('@metamask/browser-passworder');
const HdKeyring = require('@metamask/eth-hd-keyring');
const { normalize: normalizeAddress } = require('@metamask/eth-sig-util');
const SimpleKeyring = require('@metamask/eth-simple-keyring');
// TODO: Stop using `events`, and remove the notice about this from the README
// eslint-disable-next-line import/no-nodejs-modules
const { EventEmitter } = require('events');
const ObservableStore = require('obs-store');

const defaultKeyringBuilders = [
  keyringBuilderFactory(SimpleKeyring),
  keyringBuilderFactory(HdKeyring),
];

const KEYRINGS_TYPE_MAP = {
  HD_KEYRING: 'HD Key Tree',
  SIMPLE_KEYRING: 'Simple Key Pair',
};

/**
 * Strip the hex prefix from an address, if present.
 *
 * @param {string} address - The address that might be hex prefixed.
 * @returns {string} The address without a hex prefix.
 */
function stripHexPrefix(address) {
  if (address.startsWith('0x')) {
    return address.slice(2);
  }
  return address;
}

class KeyringController extends EventEmitter {
  //
  // PUBLIC METHODS
  //

  constructor(opts) {
    super();
    const initState = opts.initState || {};
    this.keyringBuilders = opts.keyringBuilders
      ? defaultKeyringBuilders.concat(opts.keyringBuilders)
      : defaultKeyringBuilders;
    this.store = new ObservableStore(initState);
    this.memStore = new ObservableStore({
      isUnlocked: false,
      keyringTypes: this.keyringBuilders.map(
        (keyringBuilder) => keyringBuilder.type,
      ),
      keyrings: [],
      encryptionKey: null,
    });

    this.encryptor = opts.encryptor || encryptor;
    this.keyrings = [];
    this._unsupportedKeyrings = [];

    // This option allows the controller to cache an exported key
    // for use in decrypting and encrypting data without password
    this.cacheEncryptionKey = Boolean(opts.cacheEncryptionKey);
  }

  /**
   * Full Update
   *
   * Emits the `update` event and @returns a Promise that resolves to
   * the current state.
   *
   * Frequently used to end asynchronous chains in this class,
   * indicating consumers can often either listen for updates,
   * or accept a state-resolving promise to consume their results.
   *
   * @returns {object} The controller state.
   */
  fullUpdate() {
    this.emit('update', this.memStore.getState());
    return this.memStore.getState();
  }

  /**
   * Create New Vault And Keychain
   *
   * Destroys any old encrypted storage,
   * creates a new encrypted store with the given password,
   * randomly creates a new HD wallet with 1 account,
   * faucets that account on the testnet.
   *
   * @fires KeyringController#unlock
   * @param {string} password - The password to encrypt the vault with.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async createNewVaultAndKeychain(password) {
    this.password = password;

    await this.createFirstKeyTree();
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * CreateNewVaultAndRestore
   *
   * Destroys any old encrypted storage,
   * creates a new encrypted store with the given password,
   * creates a new HD wallet from the given seed with 1 account.
   *
   * @fires KeyringController#unlock
   * @param {string} password - The password to encrypt the vault with.
   * @param {Uint8Array | string} seedPhrase - The BIP39-compliant seed phrase,
   * either as a string or Uint8Array.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async createNewVaultAndRestore(password, seedPhrase) {
    if (typeof password !== 'string') {
      throw new Error('Password must be text.');
    }
    this.password = password;

    await this.clearKeyrings();
    const keyring = await this.addNewKeyring(KEYRINGS_TYPE_MAP.HD_KEYRING, {
      mnemonic: seedPhrase,
      numberOfAccounts: 1,
    });
    const [firstAccount] = await keyring.getAccounts();

    if (!firstAccount) {
      throw new Error('KeyringController - First Account not found.');
    }
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Set Locked
   * This method deallocates all secrets, and effectively locks MetaMask.
   *
   * @fires KeyringController#lock
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async setLocked() {
    delete this.password;

    // set locked
    this.memStore.updateState({
      isUnlocked: false,
      encryptionKey: null,
      encryptionSalt: null,
    });

    // remove keyrings
    this.keyrings = [];
    await this._updateMemStoreKeyrings();
    this.emit('lock');
    return this.fullUpdate();
  }

  /**
   * Submit password.
   *
   * Attempts to decrypt the current vault and load its keyrings
   * into memory.
   *
   * Temporarily also migrates any old-style vaults first, as well
   * (Pre MetaMask 3.0.0).
   *
   * @fires KeyringController#unlock
   * @param {string} password - The keyring controller password.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async submitPassword(password) {
    this.keyrings = await this.unlockKeyrings(password);

    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Submit Encryption Key.
   *
   * Attempts to decrypt the current vault and load its keyrings
   * into memory based on the vault and CryptoKey information.
   *
   * @fires KeyringController#unlock
   * @param {string} encryptionKey - The encrypted key information used to decrypt the vault.
   * @param {string} encryptionSalt - The salt used to generate the last key.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async submitEncryptionKey(encryptionKey, encryptionSalt) {
    this.keyrings = await this.unlockKeyrings(
      undefined,
      encryptionKey,
      encryptionSalt,
    );
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Verify Password
   *
   * Attempts to decrypt the current vault with a given password
   * to verify its validity.
   *
   * @param {string} password - The vault password.
   */
  async verifyPassword(password) {
    const encryptedVault = this.store.getState().vault;
    if (!encryptedVault) {
      throw new Error('Cannot unlock without a previous vault.');
    }
    await this.encryptor.decrypt(password, encryptedVault);
  }

  /**
   * Add New Keyring
   *
   * Adds a new Keyring of the given `type` to the vault
   * and the current decrypted Keyrings array.
   *
   * All Keyring classes implement a unique `type` string,
   * and this is used to retrieve them from the keyringBuilders array.
   *
   * @param {string} type - The type of keyring to add.
   * @param {object} opts - The constructor options for the keyring.
   * @returns {Promise<Keyring>} The new keyring.
   */
  async addNewKeyring(type, opts) {
    const keyring = await this._newKeyring(type, opts);

    if ((!opts || !opts.mnemonic) && type === KEYRINGS_TYPE_MAP.HD_KEYRING) {
      keyring.generateRandomMnemonic();
      await keyring.addAccounts();
    }

    const accounts = await keyring.getAccounts();
    await this.checkForDuplicate(type, accounts);

    this.keyrings.push(keyring);
    await this.persistAllKeyrings();

    this.fullUpdate();

    return keyring;
  }

  /**
   * Remove Empty Keyrings.
   *
   * Loops through the keyrings and removes the ones with empty accounts
   * (usually after removing the last / only account) from a keyring.
   */
  async removeEmptyKeyrings() {
    const validKeyrings = [];

    // Since getAccounts returns a Promise
    // We need to wait to hear back form each keyring
    // in order to decide which ones are now valid (accounts.length > 0)

    await Promise.all(
      this.keyrings.map(async (keyring) => {
        const accounts = await keyring.getAccounts();
        if (accounts.length > 0) {
          validKeyrings.push(keyring);
        }
      }),
    );
    this.keyrings = validKeyrings;
  }

  /**
   * Checks for duplicate keypairs, using the the first account in the given
   * array. Rejects if a duplicate is found.
   *
   * Only supports 'Simple Key Pair'.
   *
   * @param {string} type - The key pair type to check for.
   * @param {Array<string>} newAccountArray - Array of new accounts.
   * @returns {Promise<Array<string>>} The account, if no duplicate is found.
   */
  async checkForDuplicate(type, newAccountArray) {
    const accounts = await this.getAccounts();

    switch (type) {
      case KEYRINGS_TYPE_MAP.SIMPLE_KEYRING: {
        const isIncluded = Boolean(
          accounts.find(
            (key) =>
              key === newAccountArray[0] ||
              key === stripHexPrefix(newAccountArray[0]),
          ),
        );

        if (isIncluded) {
          throw new Error(
            'The account you are trying to import is a duplicate',
          );
        }
        return newAccountArray;
      }

      default: {
        return newAccountArray;
      }
    }
  }

  /**
   * Add New Account.
   *
   * Calls the `addAccounts` method on the given keyring,
   * and then saves those changes.
   *
   * @param {Keyring} selectedKeyring - The currently selected keyring.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async addNewAccount(selectedKeyring) {
    const accounts = await selectedKeyring.addAccounts(1);
    accounts.forEach((hexAccount) => {
      this.emit('newAccount', hexAccount);
    });

    await this.persistAllKeyrings();
    return this.fullUpdate();
  }

  /**
   * Export Account
   *
   * Requests the private key from the keyring controlling
   * the specified address.
   *
   * Returns a Promise that may resolve with the private key string.
   *
   * @param {string} address - The address of the account to export.
   * @returns {Promise<string>} The private key of the account.
   */
  async exportAccount(address) {
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.exportAccount(normalizeAddress(address));
  }

  /**
   * Remove Account.
   *
   * Removes a specific account from a keyring
   * If the account is the last/only one then it also removes the keyring.
   *
   * @param {string} address - The address of the account to remove.
   * @returns {Promise<void>} A Promise that resolves if the operation was successful.
   */
  async removeAccount(address) {
    const keyring = await this.getKeyringForAccount(address);

    // Not all the keyrings support this, so we have to check
    if (typeof keyring.removeAccount === 'function') {
      keyring.removeAccount(address);
      this.emit('removedAccount', address);
    } else {
      throw new Error(
        `Keyring ${keyring.type} doesn't support account removal operations`,
      );
    }

    const accounts = await keyring.getAccounts();
    // Check if this was the last/only account
    if (accounts.length === 0) {
      await this.removeEmptyKeyrings();
    }

    await this.persistAllKeyrings();
    return this.fullUpdate();
  }

  //
  // SIGNING METHODS
  //

  /**
   * Sign Ethereum Transaction
   *
   * Signs an Ethereum transaction object.
   *
   * @param {object} ethTx - The transaction to sign.
   * @param {string} _fromAddress - The transaction 'from' address.
   * @param {object} opts - Signing options.
   * @returns {Promise<object>} The signed transaction object.
   */
  async signTransaction(ethTx, _fromAddress, opts = {}) {
    const fromAddress = normalizeAddress(_fromAddress);
    const keyring = await this.getKeyringForAccount(fromAddress);
    return await keyring.signTransaction(fromAddress, ethTx, opts);
  }

  /**
   * Sign Message
   *
   * Attempts to sign the provided message parameters.
   *
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.signMessage(address, msgParams.data, opts);
  }

  /**
   * Sign Personal Message
   *
   * Attempts to sign the provided message parameters.
   * Prefixes the hash before signing per the personal sign expectation.
   *
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signPersonalMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.signPersonalMessage(address, msgParams.data, opts);
  }

  /**
   * Get encryption public key
   *
   * Get encryption public key for using in encrypt/decrypt process.
   *
   * @param {object} address - The address to get the encryption public key for.
   * @param {object} opts - Additional encryption options.
   * @returns {Promise<Buffer>} The public key.
   */
  async getEncryptionPublicKey(address, opts = {}) {
    const normalizedAddress = normalizeAddress(address);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.getEncryptionPublicKey(normalizedAddress, opts);
  }

  /**
   * Decrypt Message
   *
   * Attempts to decrypt the provided message parameters.
   *
   * @param {object} msgParams - The decryption message parameters.
   * @param {object} opts - Additional decryption options.
   * @returns {Promise<Buffer>} The raw decryption result.
   */
  async decryptMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.decryptMessage(address, msgParams.data, opts);
  }

  /**
   * Sign Typed Data.
   *
   * @see {@link https://github.com/ethereum/EIPs/pull/712#issuecomment-329988454|EIP712}.
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signTypedMessage(msgParams, opts = { version: 'V1' }) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.signTypedData(address, msgParams.data, opts);
  }

  /**
   * Gets the app key address for the given Ethereum address and origin.
   *
   * @param {string} _address - The Ethereum address for the app key.
   * @param {string} origin - The origin for the app key.
   * @returns {string} The app key address.
   */
  async getAppKeyAddress(_address, origin) {
    const address = normalizeAddress(_address);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.getAppKeyAddress(address, origin);
  }

  /**
   * Exports an app key private key for the given Ethereum address and origin.
   *
   * @param {string} _address - The Ethereum address for the app key.
   * @param {string} origin - The origin for the app key.
   * @returns {string} The app key private key.
   */
  async exportAppKeyForAddress(_address, origin) {
    const address = normalizeAddress(_address);
    const keyring = await this.getKeyringForAccount(address);
    // The "in" operator is typically restricted because it also checks inherited properties,
    // which can be unexpected for plain objects. We're allowing it here because `keyring` is not
    // a plain object, and we explicitly want to include inherited methods in this check.
    // eslint-disable-next-line no-restricted-syntax
    if (!('exportAccount' in keyring)) {
      throw new Error(
        `The keyring for address ${_address} does not support exporting.`,
      );
    }
    return keyring.exportAccount(address, { withAppKeyOrigin: origin });
  }

  //
  // PRIVATE METHODS
  //

  /**
   * Create First Key Tree.
   *
   * - Clears the existing vault.
   * - Creates a new vault.
   * - Creates a random new HD Keyring with 1 account.
   * - Makes that account the selected account.
   * - Faucets that account on testnet.
   * - Puts the current seed words into the state tree.
   *
   * @returns {Promise<void>} A promise that resolves if the operation was successful.
   */
  async createFirstKeyTree() {
    this.clearKeyrings();

    const keyring = await this.addNewKeyring(KEYRINGS_TYPE_MAP.HD_KEYRING);
    const [firstAccount] = await keyring.getAccounts();
    if (!firstAccount) {
      throw new Error('KeyringController - No account found on keychain.');
    }

    const hexAccount = normalizeAddress(firstAccount);
    this.emit('newVault', hexAccount);
    return null;
  }

  /**
   * Persist All Keyrings
   *
   * Iterates the current `keyrings` array,
   * serializes each one into a serialized array,
   * encrypts that array with the provided `password`,
   * and persists that encrypted string to storage.
   *
   * @returns {Promise<boolean>} Resolves to true once keyrings are persisted.
   */
  async persistAllKeyrings() {
    const { encryptionKey, encryptionSalt } = this.memStore.getState();

    if (!this.password && !encryptionKey) {
      throw new Error(
        'Cannot persist vault without password and encryption key',
      );
    }

    const serializedKeyrings = await Promise.all(
      this.keyrings.map(async (keyring) => {
        const [type, data] = await Promise.all([
          keyring.type,
          keyring.serialize(),
        ]);
        return { type, data };
      }),
    );

    serializedKeyrings.push(...this._unsupportedKeyrings);

    let vault;
    let newEncryptionKey;

    if (this.cacheEncryptionKey) {
      if (this.password) {
        const { vault: newVault, exportedKeyString } =
          await this.encryptor.encryptWithDetail(
            this.password,
            serializedKeyrings,
          );

        vault = newVault;
        newEncryptionKey = exportedKeyString;
      } else if (encryptionKey) {
        const key = await this.encryptor.importKey(encryptionKey);
        const vaultJSON = await this.encryptor.encryptWithKey(
          key,
          serializedKeyrings,
        );
        vaultJSON.salt = encryptionSalt;
        vault = JSON.stringify(vaultJSON);
      }
    } else {
      vault = await this.encryptor.encrypt(this.password, serializedKeyrings);
    }

    if (!vault) {
      throw new Error('Cannot persist vault without vault information');
    }

    this.store.updateState({ vault });

    // The keyring updates need to be announced before updating the encryptionKey
    // so that the updated keyring gets propagated to the extension first.
    // Not calling _updateMemStoreKeyrings results in the wrong account being selected
    // in the extension.
    await this._updateMemStoreKeyrings();

    if (newEncryptionKey) {
      this.memStore.updateState({
        encryptionKey: newEncryptionKey,
        encryptionSalt: JSON.parse(vault).salt,
      });
    }

    return true;
  }

  /**
   * Unlock Keyrings.
   *
   * Attempts to unlock the persisted encrypted storage,
   * initializing the persisted keyrings to RAM.
   *
   * @param {string} password - The keyring controller password.
   * @param {string} encryptionKey - An exported key string to unlock keyrings with.
   * @param {string} encryptionSalt - The salt used to encrypt the vault.
   * @returns {Promise<Array<Keyring>>} The keyrings.
   */
  async unlockKeyrings(password, encryptionKey, encryptionSalt) {
    const encryptedVault = this.store.getState().vault;
    if (!encryptedVault) {
      throw new Error('Cannot unlock without a previous vault.');
    }

    await this.clearKeyrings();

    let vault;

    if (this.cacheEncryptionKey) {
      if (password) {
        const result = await this.encryptor.decryptWithDetail(
          password,
          encryptedVault,
        );
        vault = result.vault;
        this.password = password;

        this.memStore.updateState({
          encryptionKey: result.exportedKeyString,
          encryptionSalt: result.salt,
        });
      } else {
        const parsedEncryptedVault = JSON.parse(encryptedVault);

        if (encryptionSalt !== parsedEncryptedVault.salt) {
          throw new Error('Encryption key and salt provided are expired');
        }

        const key = await this.encryptor.importKey(encryptionKey);
        vault = await this.encryptor.decryptWithKey(key, parsedEncryptedVault);

        // This call is required on the first call because encryptionKey
        // is not yet inside the memStore
        this.memStore.updateState({
          encryptionKey,
          encryptionSalt,
        });
      }
    } else {
      vault = await this.encryptor.decrypt(password, encryptedVault);
      this.password = password;
    }

    await Promise.all(vault.map(this._restoreKeyring.bind(this)));
    await this._updateMemStoreKeyrings();
    return this.keyrings;
  }

  /**
   * Restore Keyring
   *
   * Attempts to initialize a new keyring from the provided serialized payload.
   * On success, updates the memStore keyrings and returns the resulting
   * keyring instance.
   *
   * @param {object} serialized - The serialized keyring.
   * @returns {Promise<Keyring>} The deserialized keyring.
   */
  async restoreKeyring(serialized) {
    const keyring = await this._restoreKeyring(serialized);
    if (keyring) {
      await this._updateMemStoreKeyrings();
    }
    return keyring;
  }

  /**
   * Restore Keyring Helper
   *
   * Attempts to initialize a new keyring from the provided serialized payload.
   * On success, returns the resulting keyring instance.
   *
   * @param {object} serialized - The serialized keyring.
   * @returns {Promise<Keyring|undefined>} The deserialized keyring or undefined if the keyring type is unsupported.
   */
  async _restoreKeyring(serialized) {
    const { type, data } = serialized;

    const keyring = await this._newKeyring(type, data);
    if (!keyring) {
      this._unsupportedKeyrings.push(serialized);
      return undefined;
    }

    // getAccounts also validates the accounts for some keyrings
    await keyring.getAccounts();
    this.keyrings.push(keyring);
    return keyring;
  }

  /**
   * Get Keyring Class For Type
   *
   * Searches the current `keyringBuilders` array
   * for a Keyring builder whose unique `type` property
   * matches the provided `type`,
   * returning it if it exists.
   *
   * @param {string} type - The type whose class to get.
   * @returns {Keyring|undefined} The class, if it exists.
   */
  getKeyringBuilderForType(type) {
    return this.keyringBuilders.find(
      (keyringBuilder) => keyringBuilder.type === type,
    );
  }

  /**
   * Get Keyrings by Type
   *
   * Gets all keyrings of the given type.
   *
   * @param {string} type - The keyring types to retrieve.
   * @returns {Array<Keyring>} The keyrings.
   */
  getKeyringsByType(type) {
    return this.keyrings.filter((keyring) => keyring.type === type);
  }

  /**
   * Get Accounts
   *
   * Returns the public addresses of all current accounts
   * managed by all currently unlocked keyrings.
   *
   * @returns {Promise<Array<string>>} The array of accounts.
   */
  async getAccounts() {
    const keyrings = this.keyrings || [];

    const keyringArrays = await Promise.all(
      keyrings.map((keyring) => keyring.getAccounts()),
    );
    const addresses = keyringArrays.reduce((res, arr) => {
      return res.concat(arr);
    }, []);

    return addresses.map(normalizeAddress);
  }

  /**
   * Get Keyring For Account
   *
   * Returns the currently initialized keyring that manages
   * the specified `address` if one exists.
   *
   * @param {string} address - An account address.
   * @returns {Promise<Keyring>} The keyring of the account, if it exists.
   */
  async getKeyringForAccount(address) {
    const hexed = normalizeAddress(address);

    const candidates = await Promise.all(
      this.keyrings.map((keyring) => {
        return Promise.all([keyring, keyring.getAccounts()]);
      }),
    );

    const winners = candidates.filter((candidate) => {
      const accounts = candidate[1].map(normalizeAddress);
      return accounts.includes(hexed);
    });
    if (winners && winners.length > 0) {
      return winners[0][0];
    }

    // Adding more info to the error
    let errorInfo = '';
    if (!address) {
      errorInfo = 'The address passed in is invalid/empty';
    } else if (!candidates || !candidates.length) {
      errorInfo = 'There are no keyrings';
    } else if (!winners || !winners.length) {
      errorInfo = 'There are keyrings, but none match the address';
    }
    throw new Error(
      `No keyring found for the requested account. Error info: ${errorInfo}`,
    );
  }

  /**
   * Display For Keyring
   *
   * Is used for adding the current keyrings to the state object.
   *
   * @param {Keyring} keyring - The keyring to display.
   * @returns {Promise<object>} A keyring display object, with type and accounts properties.
   */
  async displayForKeyring(keyring) {
    const accounts = await keyring.getAccounts();

    return {
      type: keyring.type,
      accounts: accounts.map(normalizeAddress),
    };
  }

  /**
   * Clear Keyrings
   *
   * Deallocates all currently managed keyrings and accounts.
   * Used before initializing a new vault.
   */

  /* eslint-disable require-await */
  async clearKeyrings() {
    // clear keyrings from memory
    this.keyrings = [];
    this.memStore.updateState({
      keyrings: [],
    });
  }

  /**
   * Update memStore Keyrings
   *
   * Updates the in-memory keyrings, without persisting.
   */
  async _updateMemStoreKeyrings() {
    const keyrings = await Promise.all(
      this.keyrings.map(this.displayForKeyring),
    );
    return this.memStore.updateState({ keyrings });
  }

  /**
   * Unlock Keyrings
   *
   * Unlocks the keyrings.
   *
   * @fires KeyringController#unlock
   */
  setUnlocked() {
    this.memStore.updateState({ isUnlocked: true });
    this.emit('unlock');
  }

  /**
   * Forget hardware keyring.
   *
   * Forget hardware and update memorized state.
   *
   * @param {Keyring} keyring - The keyring to forget.
   */
  forgetKeyring(keyring) {
    if (keyring.forgetDevice) {
      keyring.forgetDevice();
      this.persistAllKeyrings();
    } else {
      throw new Error(
        `KeyringController - keyring does not have method "forgetDevice", keyring type: ${keyring.type}`,
      );
    }
  }

  /**
   * Instantiate, initialize and return a new keyring
   *
   * The keyring instantiated is of the given `type`.
   *
   * @param {string} type - The type of keyring to add.
   * @param {object} data - The data to restore a previously serialized keyring.
   * @returns {Promise<Keyring>} The new keyring.
   */
  async _newKeyring(type, data) {
    const keyringBuilder = this.getKeyringBuilderForType(type);

    if (!keyringBuilder) {
      return undefined;
    }

    const keyring = keyringBuilder();

    await keyring.deserialize(data);

    if (keyring.init) {
      await keyring.init();
    }

    return keyring;
  }
}

/**
 * Get builder function for `Keyring`
 *
 * Returns a builder function for `Keyring` with a `type` property.
 *
 * @param {Keyring} Keyring - The Keyring class for the builder.
 * @returns {Function} A builder function for the given Keyring.
 */
function keyringBuilderFactory(Keyring) {
  const builder = () => new Keyring();

  builder.type = Keyring.type;

  return builder;
}

module.exports = {
  KeyringController,
  keyringBuilderFactory,
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller",file:"node_modules\\@metamask\\eth-keyring-controller\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js", {"@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-sig-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","hdkey":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events')
const HDKey = require('hdkey')
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')
const { TransactionFactory } = require('@ethereumjs/tx')

const pathBase = 'm'
const hdPathString = `${pathBase}/44'/60'/0'`
const type = 'Ledger Hardware'

const BRIDGE_URL = 'https://metamask.github.io/eth-ledger-bridge-keyring'

const MAX_INDEX = 1000
const NETWORK_API_URLS = {
  ropsten: 'http://api-ropsten.etherscan.io',
  kovan: 'http://api-kovan.etherscan.io',
  rinkeby: 'https://api-rinkeby.etherscan.io',
  mainnet: 'https://api.etherscan.io',
}

const CONNECTION_EVENT = 'ledger-connection-change'

class LedgerBridgeKeyring extends EventEmitter {
  constructor (opts = {}) {
    super()
    this.accountDetails = {}
    this.bridgeUrl = null
    this.type = type
    this.page = 0
    this.perPage = 5
    this.unlockedAccount = 0
    this.hdk = new HDKey()
    this.paths = {}
    this.iframe = null
    this.network = 'mainnet'
    this.implementFullBIP44 = false
    this.deserialize(opts)

    this.iframeLoaded = false
    this._setupIframe()

    this.currentMessageId = 0
    this.messageCallbacks = {}
    this._setupListener()
  }

  serialize () {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      accountDetails: this.accountDetails,
      bridgeUrl: this.bridgeUrl,
      implementFullBIP44: false,
    })
  }

  deserialize (opts = {}) {
    this.hdPath = opts.hdPath || hdPathString
    this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
    this.accounts = opts.accounts || []
    this.accountDetails = opts.accountDetails || {}
    if (!opts.accountDetails) {
      this._migrateAccountDetails(opts)
    }

    this.implementFullBIP44 = opts.implementFullBIP44 || false

    // Remove accounts that don't have corresponding account details
    this.accounts = this.accounts
      .filter((account) => Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))

    return Promise.resolve()
  }

  _migrateAccountDetails (opts) {
    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {
      for (const account of Object.keys(opts.accountIndexes)) {
        this.accountDetails[account] = {
          bip44: true,
          hdPath: this._getPathForIndex(opts.accountIndexes[account]),
        }
      }
    }

    // try to migrate non-LedgerLive accounts too
    if (!this._isLedgerLiveHdPath()) {
      this.accounts
        .filter((account) => !Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))
        .forEach((account) => {
          try {
            this.accountDetails[ethUtil.toChecksumAddress(account)] = {
              bip44: false,
              hdPath: this._pathFromAddress(account),
            }
          } catch (e) {
            console.log(`failed to migrate account ${account}`)
          }
        })
    }
  }

  isUnlocked () {
    return Boolean(this.hdk && this.hdk.publicKey)
  }

  isConnected () {
    return this.isDeviceConnected
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  setHdPath (hdPath) {
    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey()
    }
    this.hdPath = hdPath
  }

  unlock (hdPath, updateHdk = true) {
    if (this.isUnlocked() && !hdPath) {
      return Promise.resolve('already unlocked')
    }
    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-unlock',
        params: {
          hdPath: path,
        },
      },
      ({ success, payload }) => {
        if (success) {
          if (updateHdk) {
            this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
            this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
          }
          resolve(payload.address)
        } else {
          reject(payload.error || new Error('Unknown error'))
        }
      })
    })
  }

  addAccounts (n = 1) {

    return new Promise((resolve, reject) => {
      this.unlock()
        .then(async (_) => {
          const from = this.unlockedAccount
          const to = from + n
          for (let i = from; i < to; i++) {
            const path = this._getPathForIndex(i)
            let address
            if (this._isLedgerLiveHdPath()) {
              address = await this.unlock(path)
            } else {
              address = this._addressFromIndex(pathBase, i)
            }
            this.accountDetails[ethUtil.toChecksumAddress(address)] = {
              // TODO: consider renaming this property, as the current name is misleading
              // It's currently used to represent whether an account uses the Ledger Live path.
              bip44: this._isLedgerLiveHdPath(),
              hdPath: path,
            }

            if (!this.accounts.includes(address)) {
              this.accounts.push(address)
            }
            this.page = 0
          }
          resolve(this.accounts)
        })
        .catch(reject)
    })
  }

  getFirstPage () {
    this.page = 0
    return this.__getPage(1)
  }

  getNextPage () {
    return this.__getPage(1)
  }

  getPreviousPage () {
    return this.__getPage(-1)
  }

  getAccounts () {
    return Promise.resolve(this.accounts.slice())
  }

  removeAccount (address) {
    if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`)
    }
    this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase())
    delete this.accountDetails[ethUtil.toChecksumAddress(address)]
  }

  attemptMakeApp () {
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-make-app',
      }, ({ success, error }) => {
        if (success) {
          resolve(true)
        } else {
          reject(error)
        }
      })
    })
  }

  updateTransportMethod (transportType) {
    return new Promise((resolve, reject) => {
      // If the iframe isn't loaded yet, let's store the desired transportType value and
      // optimistically return a successful promise
      if (!this.iframeLoaded) {
        this.delayedPromise = {
          resolve,
          reject,
          transportType,
        }
        return
      }

      this._sendMessage({
        action: 'ledger-update-transport',
        params: { transportType },
      }, ({ success }) => {
        if (success) {
          resolve(true)
        } else {
          reject(new Error('Ledger transport could not be updated'))
        }
      })
    })
  }

  // tx is an instance of the ethereumjs-transaction class.
  signTransaction (address, tx) {
    let rawTxHex
    // transactions built with older versions of ethereumjs-tx have a
    // getChainId method that newer versions do not. Older versions are mutable
    // while newer versions default to being immutable. Expected shape and type
    // of data for v, r and s differ (Buffer (old) vs BN (new))
    if (typeof tx.getChainId === 'function') {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      tx.v = ethUtil.bufferToHex(tx.getChainId())
      tx.r = '0x00'
      tx.s = '0x00'

      rawTxHex = tx.serialize().toString('hex')

      return this._signTransaction(address, rawTxHex, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex')
        tx.r = Buffer.from(payload.r, 'hex')
        tx.s = Buffer.from(payload.s, 'hex')
        return tx
      })
    }

    // The below `encode` call is only necessary for legacy transactions, as `getMessageToSign`
    // calls `rlp.encode` internally for non-legacy transactions. As per the "Transaction Execution"
    // section of the ethereum yellow paper, transactions need to be "well-formed RLP, with no additional
    // trailing bytes".

    // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
    // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
    // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
    const messageToSign = tx.getMessageToSign(false)

    rawTxHex = Buffer.isBuffer(messageToSign)
      ? messageToSign.toString('hex')
      : ethUtil.rlp.encode(messageToSign).toString('hex')

    return this._signTransaction(address, rawTxHex, (payload) => {
      // Because tx will be immutable, first get a plain javascript object that
      // represents the transaction. Using txData here as it aligns with the
      // nomenclature of ethereumjs/tx.
      const txData = tx.toJSON()
      // The fromTxData utility expects a type to support transactions with a type other than 0
      txData.type = tx.type
      // The fromTxData utility expects v,r and s to be hex prefixed
      txData.v = ethUtil.addHexPrefix(payload.v)
      txData.r = ethUtil.addHexPrefix(payload.r)
      txData.s = ethUtil.addHexPrefix(payload.s)
      // Adopt the 'common' option from the original transaction and set the
      // returned object to be frozen if the original is frozen.
      return TransactionFactory.fromTxData(txData, { common: tx.common, freeze: Object.isFrozen(tx) })
    })
  }

  _signTransaction (address, rawTxHex, handleSigning) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(address)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-transaction',
            params: {
              tx: rawTxHex,
              hdPath,
            },
          },
          ({ success, payload }) => {
            if (success) {

              const newOrMutatedTx = handleSigning(payload)
              const valid = newOrMutatedTx.verifySignature()
              if (valid) {
                resolve(newOrMutatedTx)
              } else {
                reject(new Error('Ledger: The transaction signature is not valid'))
              }
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing transaction'))
            }
          })
        })
        .catch(reject)
    })
  }

  signMessage (withAccount, data) {
    return this.signPersonalMessage(withAccount, data)
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage (withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(withAccount)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-personal-message',
            params: {
              hdPath,
              message: ethUtil.stripHexPrefix(message),
            },
          },
          ({ success, payload }) => {
            if (success) {
              let v = parseInt(payload.v, 10)
              v = v.toString(16)
              if (v.length < 2) {
                v = `0${v}`
              }
              const signature = `0x${payload.r}${payload.s}${v}`
              const addressSignedWith = sigUtil.recoverPersonalSignature({ data: message, sig: signature })
              if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
                reject(new Error('Ledger: The signature doesnt match the right address'))
              }
              resolve(signature)
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing message'))
            }
          })
        })
        .catch(reject)
    })
  }

  async unlockAccountByAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {
      throw new Error(`Ledger: Account for address '${checksummedAddress}' not found`)
    }
    const { hdPath } = this.accountDetails[checksummedAddress]
    const unlockedAddress = await this.unlock(hdPath, false)

    // unlock resolves to the address for the given hdPath as reported by the ledger device
    // if that address is not the requested address, then this account belongs to a different device or seed
    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {
      throw new Error(`Ledger: Account ${address} does not belong to the connected device`)
    }
    return hdPath
  }

  async signTypedData (withAccount, data, options = {}) {
    const isV4 = options.version === 'V4'
    if (!isV4) {
      throw new Error('Ledger: Only version 4 of typed data signing is supported')
    }

    const {
      domain,
      types,
      primaryType,
      message,
    } = sigUtil.TypedDataUtils.sanitizeData(data)
    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, types, isV4).toString('hex')
    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(primaryType, message, types, isV4).toString('hex')

    const hdPath = await this.unlockAccountByAddress(withAccount)
    const { success, payload } = await new Promise((resolve) => {
      this._sendMessage({
        action: 'ledger-sign-typed-data',
        params: {
          hdPath,
          domainSeparatorHex,
          hashStructMessageHex,
        },
      },
      (result) => resolve(result))
    })

    if (success) {
      let v = parseInt(payload.v, 10)
      v = v.toString(16)
      if (v.length < 2) {
        v = `0${v}`
      }
      const signature = `0x${payload.r}${payload.s}${v}`
      const addressSignedWith = sigUtil.recoverTypedSignature_v4({
        data,
        sig: signature,
      })
      if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
        throw new Error('Ledger: The signature doesnt match the right address')
      }
      return signature
    }
    throw payload.error || new Error('Ledger: Unknown error while signing message')
  }

  exportAccount () {
    throw new Error('Not supported on this device')
  }

  forgetDevice () {
    this.accounts = []
    this.page = 0
    this.unlockedAccount = 0
    this.paths = {}
    this.accountDetails = {}
    this.hdk = new HDKey()
  }

  /* PRIVATE METHODS */

  _setupIframe () {
    this.iframe = document.createElement('iframe')
    this.iframe.src = this.bridgeUrl
    this.iframe.allow = `hid 'src'`
    this.iframe.onload = async () => {
      // If the ledger live preference was set before the iframe is loaded,
      // set it after the iframe has loaded
      this.iframeLoaded = true
      if (this.delayedPromise) {
        try {
          const result = await this.updateTransportMethod(
            this.delayedPromise.transportType,
          )
          this.delayedPromise.resolve(result)
        } catch (e) {
          this.delayedPromise.reject(e)
        } finally {
          delete this.delayedPromise
        }
      }
    }
    document.head.appendChild(this.iframe)
  }

  _getOrigin () {
    const tmp = this.bridgeUrl.split('/')
    tmp.splice(-1, 1)
    return tmp.join('/')
  }

  _sendMessage (msg, cb) {
    msg.target = 'LEDGER-IFRAME'

    this.currentMessageId += 1
    msg.messageId = this.currentMessageId

    this.messageCallbacks[this.currentMessageId] = cb
    this.iframe.contentWindow.postMessage(msg, '*')
  }

  _setupListener () {
    this._eventListener = ({ origin, data }) => {
      if (origin !== this._getOrigin()) {
        return false
      }

      if (data) {
        if (this.messageCallbacks[data.messageId]) {
          this.messageCallbacks[data.messageId](data)
        } else if (data.action === CONNECTION_EVENT) {
          this.isDeviceConnected = data.payload.connected
        }
      }

      return undefined
    }
    window.addEventListener('message', this._eventListener)
  }

  destroy () {
    window.removeEventListener('message', this._eventListener)
  }

  async __getPage (increment) {

    this.page += increment

    if (this.page <= 0) {
      this.page = 1
    }
    const from = (this.page - 1) * this.perPage
    const to = from + this.perPage

    await this.unlock()
    let accounts
    if (this._isLedgerLiveHdPath()) {
      accounts = await this._getAccountsBIP44(from, to)
    } else {
      accounts = this._getAccountsLegacy(from, to)
    }
    return accounts
  }

  async _getAccountsBIP44 (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const path = this._getPathForIndex(i)
      const address = await this.unlock(path)
      const valid = this.implementFullBIP44 ? await this._hasPreviousTransactions(address) : true
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      // PER BIP44
      // "Software should prevent a creation of an account if
      // a previous account does not have a transaction history
      // (meaning none of its addresses have been used before)."
      if (!valid) {
        break
      }
    }
    return accounts
  }

  _getAccountsLegacy (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const address = this._addressFromIndex(pathBase, i)
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      this.paths[ethUtil.toChecksumAddress(address)] = i
    }
    return accounts
  }

  _padLeftEven (hex) {
    return hex.length % 2 === 0 ? hex : `0${hex}`
  }

  _normalize (buf) {
    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex (pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`)
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex')
    return ethUtil.toChecksumAddress(`0x${address}`)
  }

  _pathFromAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    let index = this.paths[checksummedAddress]
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i
          break
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address')
    }
    return this._getPathForIndex(index)
  }

  _toAscii (hex) {
    let str = ''
    let i = 0
    const l = hex.length
    if (hex.substring(0, 2) === '0x') {
      i = 2
    }
    for (; i < l; i += 2) {
      const code = parseInt(hex.substr(i, 2), 16)
      str += String.fromCharCode(code)
    }

    return str
  }

  _getPathForIndex (index) {
    // Check if the path is BIP 44 (Ledger Live)
    return this._isLedgerLiveHdPath() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}/${index}`
  }

  _isLedgerLiveHdPath () {
    return this.hdPath === `m/44'/60'/0'/0/0`
  }

  _toLedgerPath (path) {
    return path.toString().replace('m/', '')
  }

  async _hasPreviousTransactions (address) {
    const apiUrl = this._getApiUrl()
    const response = await window.fetch(`${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`)
    const parsedResponse = await response.json()
    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {
      return true
    }
    return false
  }

  _getApiUrl () {
    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet
  }

}

LedgerBridgeKeyring.type = type
module.exports = LedgerBridgeKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","tweetnacl":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cindex.js
      return function (require, module, exports) {
const { Buffer } = require('buffer')
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')
const nacl = require('tweetnacl')
nacl.util = require('tweetnacl-util')

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            type: { type: 'string' },
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: { type: 'string' },
    domain: { type: 'object' },
    message: { type: 'object' },
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {

  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if (useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            ethUtil.keccak(this.encodeData(type, value, types, useV4))]
        }

        if (value === undefined) {
          throw new Error(`missing value for field ${name} of type ${type}`)
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(
            typeValuePairs.map(([_type]) => _type),
            typeValuePairs.map(([, _value]) => _value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error(`No type definition specified: ${type}`)
      }
      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    const [firstWord] = primaryType.match(/^\w*/u)
    primaryType = firstWord
    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results
    }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }
    }
    return sanitizedData
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return ethUtil.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  concatSig (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize (input) {
    if (!input) {
      return undefined
    }

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ` received ${typeof input}: ${input}`
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign (privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data)
    const msgHash = ethUtil.hashPersonalMessage(message)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return `0x${publicKey.toString('hex')}`
  },

  typedSignatureHash (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedDataLegacy (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignatureLegacy (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  encrypt (receiverPublicKey, msgParams, version) {

    switch (version) {
      case 'x25519-xsalsa20-poly1305': {
        if (typeof msgParams.data === 'undefined') {
          throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ')
        }
        // generate ephemeral keypair
        const ephemeralKeyPair = nacl.box.keyPair()

        // assemble encryption parameters - from string to UInt8
        let pubKeyUInt8Array
        try {
          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)
        } catch (err) {
          throw new Error('Bad public key')
        }

        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)
        const nonce = nacl.randomBytes(nacl.box.nonceLength)

        // encrypt
        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)

        // handle encrypted data
        const output = {
          version: 'x25519-xsalsa20-poly1305',
          nonce: nacl.util.encodeBase64(nonce),
          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
          ciphertext: nacl.util.encodeBase64(encryptedMessage),
        }
        // return encrypted msg data
        return output
      }
      default:
        throw new Error('Encryption type/version not supported')

    }
  },

  encryptSafely (receiverPublicKey, msgParams, version) {

    const DEFAULT_PADDING_LENGTH = (2 ** 11)
    const NACL_EXTRA_BYTES = 16

    const { data } = msgParams
    if (!data) {
      throw new Error('Cannot encrypt empty msg.data')
    }

    if (typeof data === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')
    }

    // add padding
    const dataWithPadding = {
      data,
      padding: '',
    }

    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')
    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)
    let padLength = 0
    // Only pad if necessary
    if (modVal > 0) {
      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength)

    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }
    return this.encrypt(receiverPublicKey, paddedMsgParams, version)
  },

  decrypt (encryptedData, receiverPrivateKey) {

    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305': {
        // string to buffer to UInt8Array
        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)
        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey

        // assemble decryption parameters
        const nonce = nacl.util.decodeBase64(encryptedData.nonce)
        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)
        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)

        // decrypt
        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)

        // return decrypted msg data
        let output
        try {
          output = nacl.util.encodeUTF8(decryptedMessage)
        } catch (err) {
          throw new Error('Decryption failed.')
        }

        if (output) {
          return output
        }
        throw new Error('Decryption failed.')
      }

      default:
        throw new Error('Encryption type/version not supported.')
    }
  },

  decryptSafely (encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))
    return dataWithPadding.data
  },


  getEncryptionPublicKey (privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey)
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey
    return nacl.util.encodeBase64(encryptionPublicKey)
  },


  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage (privateKey, msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams)
      case 'V3':
        return this.signTypedData(privateKey, msgParams)
      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams)
    }
  },

  recoverTypedMessage (msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams)
      case 'V3':
        return this.recoverTypedSignature(msgParams)
      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams)
    }
  },

  signTypedData (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  signTypedData_v4 (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  recoverTypedSignature_v4 (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash (typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) {
    throw error
  }

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) {
    return e.type
  })
  const schema = typedData.map(function (e) {
    if (!e.name) {
      throw error
    }
    return `${e.type} ${e.name}`
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data),
    ],
  )
}

function recoverPublicKey (hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  let myString = `${number}`
  while (myString.length < length) {
    myString = `0${myString}`
  }
  return myString
}

// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex (msgHex) {
  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')
  return nacl.util.decodeBase64(msgBase64)
}



      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"./secp256k1-adapter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js","assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\assert\\assert.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", {"./secp256k1-lib/der":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js","./secp256k1-lib/index":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

function getSecp256k1 () { return require('./secp256k1-lib/index'); }
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  var secp256k1v3 = getSecp256k1();
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();
  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zY3JpcHRzL21ldGFtYXNrLWNvbnRyb2xsZXIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDAzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxMS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDEyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1MC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDUxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1My5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1Ni5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1OS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Mi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2OC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDcyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDc1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDc4LnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4MC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDgxLnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wODIudHMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4My50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDg0LnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wODUudHMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4Ni50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvZmFpbC10eC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvcmZjNDY0OC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2Jhc2UtdGFibGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2ludC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3ByaW50LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3ZhcmludC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL3JmYzQ2NDguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvcHJvZmlsZXMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2Jhc2UtZXRoLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvZGlzdC9iYXNlLWV0aC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvYmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGgvZGlzdC9iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQnl0ZXMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9DcnlwdG9BY2NvdW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvQ29pbkluZm8uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9DcnlwdG9FQ0tleS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b0hES2V5LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvS2V5cGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b091dHB1dC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b1BTQlQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9EZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvTXVsdGlLZXkuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9QYXRoQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvUmVnaXN0cnlJdGVtLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvUmVnaXN0cnlUeXBlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvU2NyaXB0RXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2Vycm9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2V4dGVuZGVkL0NyeXB0b011bHRpQWNjb3VudHMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9EYXRhSXRlbS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9jYm9yLXN5bmMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9wYXRjaENCT1IuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL3JscC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0J5dGVzLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b0FjY291bnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvQ29pbkluZm8uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvRUNLZXkuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvSERLZXkuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvS2V5cGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9DcnlwdG9PdXRwdXQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvUFNCVC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9EZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L011bHRpS2V5LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L1BhdGhDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvUmVnaXN0cnlJdGVtLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L1JlZ2lzdHJ5VHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9TY3JpcHRFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2Vycm9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9leHRlbmRlZC9DcnlwdG9NdWx0aUFjY291bnRzLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9EYXRhSXRlbS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9saWIvY2Jvci1zeW5jLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9wYXRjaENCT1IuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Db21wb3NlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9PYnNlcnZhYmxlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy90aHJvdWdoMi90aHJvdWdoMi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWRkcmVzcy1ib29rLWNvbnRyb2xsZXIvZGlzdC9BZGRyZXNzQm9va0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FkZHJlc3MtYm9vay1jb250cm9sbGVyL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2Fubm91bmNlbWVudC1jb250cm9sbGVyL2Rpc3QvQW5ub3VuY2VtZW50Q29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYW5ub3VuY2VtZW50LWNvbnRyb2xsZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYXBwcm92YWwtY29udHJvbGxlci9kaXN0L0FwcHJvdmFsQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYXBwcm92YWwtY29udHJvbGxlci9kaXN0L2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYXBwcm92YWwtY29udHJvbGxlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hcHByb3ZhbC1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5janMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FwcHJvdmFsLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL25hbm9pZC91cmwtYWxwaGFiZXQvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9icm93c2VyLXBhc3N3b3JkZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9mZXRjaC1jb25maWctZnJvbS1yZXEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9ieXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2xsZWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi1yZXdyaXRlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9ibG9jay10cmFja2VyLWluc3BlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmZsaWdodC1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9sb2dnaW5nLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyQXNNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyRnJvbUVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9wcm92aWRlckZyb21NaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3JldHJ5T25FbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC91dGlscy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC93YWxsZXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stY2FjaGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLXJld3JpdGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZmxpZ2h0LWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcHJvdmlkZXJBc01pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcmV0cnlPbkVtcHR5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3V0aWxzL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3V0aWxzL3RpbWVvdXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3Qvd2FsbGV0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaGVja3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9oZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9sb2dnaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC92ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1wcm92aWRlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtcHJvdmlkZXIvZGlzdC9wcm92aWRlci1mcm9tLWVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLXByb3ZpZGVyL2Rpc3QvcHJvdmlkZXItZnJvbS1taWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtcHJvdmlkZXIvZGlzdC9zYWZlLWV2ZW50LWVtaXR0ZXItcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtYWRhcHRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsUUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxZQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsaUJBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsMkJBQUEsT0FBQSxDQUFBLDRCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsd0JBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsVUFBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLHdCQUFBLE9BQUEsQ0FBQSxrQ0FBQSxDQUFBLENBQUE7QUFJQSxJQUFBLHFCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHNCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx1QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwwQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsZ0JBQUEsT0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsa0JBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxvQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsMEJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLHFCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSw0QkFBQSxPQUFBLENBQUEsd0NBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxZQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLFdBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsV0FBQSxPQUFBLENBQUEsaUJBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx5QkFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxzQkFBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBO0FBSUEsSUFBQSxrQkFBQSxPQUFBLENBQUEsMkJBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxxQkFBQSxPQUFBLENBQUEsOEJBQUEsQ0FBQSxDQUFBO0FBU0EsSUFBQSxzQkFBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSwwQkFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxvQkFBQSxPQUFBLENBQUEsOEJBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx3QkFBQSxPQUFBLENBQUEsaUNBQUEsQ0FBQSxDQUFBO0FBSUEsSUFBQSw2QkFBQSxPQUFBLENBQUEsdUNBQUEsQ0FBQSxDQUFBO0FBS0EsSUFBQSwrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx5Q0FBQSxDQUFBLENBQUEsQ0FBQTtBQUdBLElBQUEsdUJBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsbUJBQUEsT0FBQSxDQUFBLDRCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsZUFBQSxPQUFBLENBQUEsb0NBQUEsQ0FBQSxDQUFBO0FBTUEsSUFBQSxTQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUE7QUFLQSxJQUFBLFdBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUtBLElBQUEsbUJBQUEsT0FBQSxDQUFBLHlDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsV0FBQSxPQUFBLENBQUEsZ0NBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQ0FBQSxDQUFBLENBQUE7QUFLQSxJQUFBLGlCQUFBLE9BQUEsQ0FBQSw0QkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFFBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsT0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBO0FBS0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQ0FBQSxDQUFBLENBQUE7QUFLQSxJQUFBLGFBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUlBLElBQUEsZUFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxnQkFBQSxPQUFBLENBQUEsd0NBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSwrQkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDJCQUFBLE9BQUEsQ0FBQSw0Q0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLE1BQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsY0FBQSxPQUFBLENBQUEsdUNBQUEsQ0FBQSxDQUFBO0FBRUEsSUFBQSxhQUFBLE9BQUEsQ0FBQSxtQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDJCQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUE7QUFJQSxJQUFBLDZCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGlDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsaUNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDBCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDhCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx1QkFBQSxPQUFBLENBQUEsNkJBQUEsQ0FBQSxDQUFBO0FBSUEsSUFBQSwwQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEseUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNkJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDhCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGtDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLE9BQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsbUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQTtBQUlBLElBQUEsZUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwyQkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx5QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsa0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsMEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsc0JBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLHdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwrQkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsZ0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxVQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSwyQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsc0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDJCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxXQUFBLE9BQUEsQ0FBQSxlQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsd0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFFBQUEsT0FBQSxDQUFBLFlBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSw0QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxnQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsdUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7QUFFQSxJQUFBLFlBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsOEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFFQSxJQUFBLGdCQUFBLE9BQUEsQ0FBQSwyQkFBQSxDQUFBLENBQUE7QUFZQSxJQUFBLHFDQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHlDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSwyQkFBQSxPQUFBLENBQUEsaUNBQUEsQ0FBQSxDQUFBO0FBQXdFLHFDQUFBLEVBQUEsT0FBQSxHQUFBLElBQUEsR0FBQSxXQUFBLEdBQUEsR0FBQSxHQUFBLEVBQUEsU0FBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBO0FBQUEsMENBQUEsRUFBQSxNQUFBLGNBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsR0FBQSxJQUFBLEdBQUEsRUFBQSxFQUFBLE1BQUEsZUFBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLEVBQUEsRUFBQSxPQUFBLEtBQUEsRUFBQSxZQUFBLElBQUEsRUFBQSxjQUFBLElBQUEsRUFBQSxVQUFBLElBQUEsRUFBQSxDQUFBLENBQUEsRUFBQSxNQUFBLEVBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxFQUFBLENBQUEsT0FBQSxHQUFBLENBQUEsRUFBQTtBQUFBLDZCQUFBLEVBQUEsSUFBQSxNQUFBLFlBQUEsQ0FBQSxHQUFBLEVBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQSxPQUFBLE9BQUEsR0FBQSxLQUFBLFFBQUEsR0FBQSxHQUFBLEdBQUEsTUFBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEVBQUE7QUFBQSxtQ0FBQSxFQUFBLElBQUEsT0FBQSxLQUFBLEtBQUEsUUFBQSxJQUFBLEtBQUEsS0FBQSxJQUFBLEVBQUEsT0FBQSxLQUFBLENBQUEsQ0FBQSxJQUFBLE9BQUEsS0FBQSxDQUFBLE1BQUEsWUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLElBQUEsS0FBQSxTQUFBLEVBQUEsRUFBQSxJQUFBLE1BQUEsSUFBQSxLQUFBLENBQUEsS0FBQSxFQUFBLElBQUEsSUFBQSxTQUFBLENBQUEs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QUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLElBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLEdBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLElBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLElBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLElBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLElBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLElBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUE7QUFDQSxJQUFBLElBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUE7QUFBOEIsU0FBQSx5QkFBQSxXQUFBLGVBQUEsT0FBQSxrQ0FBQSxpQkFBQSxPQUFBLE9BQUEsUUFBQSxnQkFBQSxPQUFBLE9BQUEsWUFBQSx3QkFBQSxZQUFBLENBQUEsV0FBQSxXQUFBLFdBQUEsR0FBQSxnQkFBQSxHQUFBLGlCQUFBLEtBQUEsV0FBQTtBQUFBLFNBQUEsd0JBQUEsR0FBQSxFQUFBLFdBQUEsU0FBQSxXQUFBLElBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBQSxVQUFBLFdBQUEsR0FBQSxRQUFBLEdBQUEsb0JBQUEsR0FBQSx3QkFBQSxHQUFBLDRCQUFBLE9BQUEsRUFBQSxHQUFBLFVBQUEsS0FBQSxHQUFBLHdCQUFBLENBQUEsV0FBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsWUFBQSxLQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsU0FBQSxNQUFBLFdBQUEscUJBQUEsR0FBQSxNQUFBLENBQUEsY0FBQSxJQUFBLE1BQUEsQ0FBQSx3QkFBQSxXQUFBLEdBQUEsSUFBQSxHQUFBLFFBQUEsR0FBQSxrQkFBQSxNQUFBLENBQUEsU0FBQSxDQUFBLGNBQUEsQ0FBQSxJQUFBLENBQUEsR0FBQSxFQUFBLEdBQUEsU0FBQSxJQUFBLEdBQUEscUJBQUEsR0FBQSxNQUFBLENBQUEsd0JBQUEsQ0FBQSxHQUFBLEVBQUEsR0FBQSxjQUFBLElBQUEsS0FBQSxJQUFBLENBQUEsR0FBQSxJQUFBLElBQUEsQ0FBQSxHQUFBLEtBQUEsTUFBQSxDQUFBLGNBQUEsQ0FBQSxNQUFBLEVBQUEsR0FBQSxFQUFBLElBQUEsWUFBQSxNQUFBLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBQSxHQUFBLFNBQUEsTUFBQSxDQUFBLE9BQUEsR0FBQSxHQUFBLE1BQUEsS0FBQSxJQUFBLEtBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxFQUFBLE1BQUEsWUFBQSxNQUFBO0FBQUEsU0FBQSx1QkFBQSxHQUFBLFdBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBQSxVQUFBLEdBQUEsR0FBQSxLQUFBLE9BQUEsRUFBQSxHQUFBO0FBM0Y5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBd0ZBLE1BQU0sVUFBVSxHQUFHLENBQ2pCLFNBQUksRUFDSixVQUFJLEVBQ0osVUFBSSxFQUNKLFVBQUksRUFDSixVQUFJLEVBQ0osVUFBSSxFQUNKLFVBQUksRUFDSixVQUFJLEVBQ0osVUFBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixJQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksQ0FDTDtBQUFDLElBQUEsUUFBQSxHQUVhLFVBQVU7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7Ozs7Ozs7Ozs7Ozs7O0FDckx6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDblVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDblVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDaDZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDM29CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJiYWNrZ3JvdW5kLTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XHJcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcclxuaW1wb3J0IHsgc3RvcmVBc1N0cmVhbSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbSc7XHJcbmltcG9ydCB7IEpzb25ScGNFbmdpbmUgfSBmcm9tICdqc29uLXJwYy1lbmdpbmUnO1xyXG5pbXBvcnQgeyBjcmVhdGVFbmdpbmVTdHJlYW0gfSBmcm9tICdqc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbSc7XHJcbmltcG9ydCB7IHByb3ZpZGVyQXNNaWRkbGV3YXJlIH0gZnJvbSAnQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlJztcclxuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQge1xyXG4gIEtleXJpbmdDb250cm9sbGVyLFxyXG4gIGtleXJpbmdCdWlsZGVyRmFjdG9yeSxcclxufSBmcm9tICdAbWV0YW1hc2svZXRoLWtleXJpbmctY29udHJvbGxlcic7XHJcbmltcG9ydCBjcmVhdGVGaWx0ZXJNaWRkbGV3YXJlIGZyb20gJ2V0aC1qc29uLXJwYy1maWx0ZXJzJztcclxuaW1wb3J0IGNyZWF0ZVN1YnNjcmlwdGlvbk1hbmFnZXIgZnJvbSAnZXRoLWpzb24tcnBjLWZpbHRlcnMvc3Vic2NyaXB0aW9uTWFuYWdlcic7XHJcbmltcG9ydCB7IGVycm9yQ29kZXMgYXMgcnBjRXJyb3JDb2RlcywgRXRoZXJldW1ScGNFcnJvciB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcclxuaW1wb3J0IHsgTXV0ZXggfSBmcm9tICdhd2FpdC1zZW1hcGhvcmUnO1xyXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuaW1wb3J0IFRyZXpvcktleXJpbmcgZnJvbSAnQG1ldGFtYXNrL2V0aC10cmV6b3Ita2V5cmluZyc7XHJcbmltcG9ydCBMZWRnZXJCcmlkZ2VLZXlyaW5nIGZyb20gJ0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nJztcclxuaW1wb3J0IExhdHRpY2VLZXlyaW5nIGZyb20gJ2V0aC1sYXR0aWNlLWtleXJpbmcnO1xyXG5pbXBvcnQgeyBNZXRhTWFza0tleXJpbmcgYXMgUVJIYXJkd2FyZUtleXJpbmcgfSBmcm9tICdAa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZyc7XHJcbmltcG9ydCBFdGhRdWVyeSBmcm9tICdldGgtcXVlcnknO1xyXG5pbXBvcnQgbmFub2lkIGZyb20gJ25hbm9pZCc7XHJcbmltcG9ydCB7IGNhcHR1cmVFeGNlcHRpb24gfSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xyXG5pbXBvcnQgeyBBZGRyZXNzQm9va0NvbnRyb2xsZXIgfSBmcm9tICdAbWV0YW1hc2svYWRkcmVzcy1ib29rLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQge1xyXG4gIEFwcHJvdmFsQ29udHJvbGxlcixcclxuICBBcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yLFxyXG59IGZyb20gJ0BtZXRhbWFzay9hcHByb3ZhbC1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgQ29udHJvbGxlck1lc3NlbmdlciB9IGZyb20gJ0BtZXRhbWFzay9iYXNlLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQge1xyXG4gIEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXHJcbiAgVG9rZW5MaXN0Q29udHJvbGxlcixcclxuICBUb2tlbnNDb250cm9sbGVyLFxyXG4gIFRva2VuUmF0ZXNDb250cm9sbGVyLFxyXG4gIE5mdENvbnRyb2xsZXIsXHJcbiAgQXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxyXG4gIE5mdERldGVjdGlvbkNvbnRyb2xsZXIsXHJcbn0gZnJvbSAnQG1ldGFtYXNrL2Fzc2V0cy1jb250cm9sbGVycyc7XHJcbmltcG9ydCB7IFBoaXNoaW5nQ29udHJvbGxlciB9IGZyb20gJ0BtZXRhbWFzay9waGlzaGluZy1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgQW5ub3VuY2VtZW50Q29udHJvbGxlciB9IGZyb20gJ0BtZXRhbWFzay9hbm5vdW5jZW1lbnQtY29udHJvbGxlcic7XHJcbmltcG9ydCB7IEdhc0ZlZUNvbnRyb2xsZXIgfSBmcm9tICdAbWV0YW1hc2svZ2FzLWZlZS1jb250cm9sbGVyJztcclxuaW1wb3J0IHtcclxuICBQZXJtaXNzaW9uQ29udHJvbGxlcixcclxuICBQZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yLFxyXG59IGZyb20gJ0BtZXRhbWFzay9wZXJtaXNzaW9uLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQge1xyXG4gIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXHJcbiAgU3ViamVjdFR5cGUsXHJcbn0gZnJvbSAnQG1ldGFtYXNrL3N1YmplY3QtbWV0YWRhdGEtY29udHJvbGxlcic7XHJcblxuaW1wb3J0IFNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlciBmcm9tICdAbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXInO1xyXG5cblxyXG5pbXBvcnQgeyBTaWduYXR1cmVDb250cm9sbGVyIH0gZnJvbSAnQG1ldGFtYXNrL3NpZ25hdHVyZS1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgQXBwcm92YWxUeXBlIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHMnO1xyXG5pbXBvcnQge1xyXG4gIEFzc2V0VHlwZSxcclxuICBUcmFuc2FjdGlvblN0YXR1cyxcclxuICBUcmFuc2FjdGlvblR5cGUsXHJcbiAgVG9rZW5TdGFuZGFyZCxcclxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuaW1wb3J0IHtcclxuICBHQVNfQVBJX0JBU0VfVVJMLFxyXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxyXG4gIFNXQVBTX0NMSUVOVF9JRCxcclxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3N3YXBzJztcclxuaW1wb3J0IHtcclxuICBDSEFJTl9JRFMsXHJcbiAgTkVUV09SS19UWVBFUyxcclxuICBOZXR3b3JrU3RhdHVzLFxyXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XHJcbmltcG9ydCB7IEhhcmR3YXJlRGV2aWNlTmFtZXMgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMnO1xyXG5pbXBvcnQgeyBLZXlyaW5nVHlwZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMva2V5cmluZyc7XHJcbmltcG9ydCB7XHJcbiAgQ2F2ZWF0VHlwZXMsXHJcbiAgUmVzdHJpY3RlZE1ldGhvZHMsXHJcblxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3Blcm1pc3Npb25zJztcclxuaW1wb3J0IHsgVUlfTk9USUZJQ0FUSU9OUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9ub3RpZmljYXRpb25zJztcclxuaW1wb3J0IHsgTUlMTElTRUNPTkQsIFNFQ09ORCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XHJcbmltcG9ydCB7XHJcbiAgT1JJR0lOX01FVEFNQVNLLFxyXG5cbiAgUE9MTElOR19UT0tFTl9FTlZJUk9OTUVOVF9UWVBFUyxcclxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XHJcbmltcG9ydCB7XHJcbiAgTWV0YU1ldHJpY3NFdmVudENhdGVnb3J5LFxyXG4gIE1ldGFNZXRyaWNzRXZlbnROYW1lLFxyXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnO1xyXG5cclxuaW1wb3J0IHtcclxuICBnZXRUb2tlbklkUGFyYW0sXHJcbiAgZmV0Y2hUb2tlbkJhbGFuY2UsXHJcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi90b2tlbi11dGlsLnRzJztcclxuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9tb2R1bGVzL3N0cmluZy11dGlscyc7XHJcbmltcG9ydCB7IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YSB9IGZyb20gJy4uLy4uL3NoYXJlZC9tb2R1bGVzL3RyYW5zYWN0aW9uLnV0aWxzJztcclxuaW1wb3J0IHsgU1RBVElDX01BSU5ORVRfVE9LRU5fTElTVCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdG9rZW5zJztcclxuaW1wb3J0IHsgZ2V0VG9rZW5WYWx1ZVBhcmFtIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9tZXRhbWFzay1jb250cm9sbGVyLXV0aWxzJztcclxuaW1wb3J0IHsgaXNNYW5pZmVzdFYzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvbXYzLnV0aWxzJztcclxuaW1wb3J0IHsgaGV4VG9EZWNpbWFsIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XHJcblxuaW1wb3J0IHsgQUNUSU9OX1FVRVVFX01FVFJJQ1NfRTJFX1RFU1QgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3Rlc3QtZmxhZ3MnO1xyXG5pbXBvcnQge1xyXG4gIG9uTWVzc2FnZVJlY2VpdmVkLFxyXG4gIGNoZWNrRm9yTXVsdGlwbGVWZXJzaW9uc1J1bm5pbmcsXHJcbn0gZnJvbSAnLi9kZXRlY3QtbXVsdGlwbGUtaW5zdGFuY2VzJztcclxuaW1wb3J0IENvbXBvc2FibGVPYnNlcnZhYmxlU3RvcmUgZnJvbSAnLi9saWIvQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSc7XHJcbmltcG9ydCBBY2NvdW50VHJhY2tlciBmcm9tICcuL2xpYi9hY2NvdW50LXRyYWNrZXInO1xyXG5pbXBvcnQgY3JlYXRlRHVwZVJlcUZpbHRlck1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlRHVwZVJlcUZpbHRlck1pZGRsZXdhcmUnO1xyXG5pbXBvcnQgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVMb2dnZXJNaWRkbGV3YXJlJztcclxuaW1wb3J0IHtcclxuICBjcmVhdGVNZXRob2RNaWRkbGV3YXJlLFxyXG5cbn0gZnJvbSAnLi9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlJztcclxuaW1wb3J0IGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlT3JpZ2luTWlkZGxld2FyZSc7XHJcbmltcG9ydCBjcmVhdGVUYWJJZE1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlVGFiSWRNaWRkbGV3YXJlJztcclxuaW1wb3J0IGNyZWF0ZU9uYm9hcmRpbmdNaWRkbGV3YXJlIGZyb20gJy4vbGliL2NyZWF0ZU9uYm9hcmRpbmdNaWRkbGV3YXJlJztcclxuaW1wb3J0IHsgc2V0dXBNdWx0aXBsZXggfSBmcm9tICcuL2xpYi9zdHJlYW0tdXRpbHMnO1xyXG5pbXBvcnQgRW5zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2Vucyc7XHJcbmltcG9ydCB7XHJcbiAgTmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgTmV0d29ya0NvbnRyb2xsZXJFdmVudFR5cGUsXHJcbn0gZnJvbSAnLi9jb250cm9sbGVycy9uZXR3b3JrJztcclxuaW1wb3J0IFByZWZlcmVuY2VzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3ByZWZlcmVuY2VzJztcclxuaW1wb3J0IEFwcFN0YXRlQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2FwcC1zdGF0ZSc7XHJcbmltcG9ydCBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9jYWNoZWQtYmFsYW5jZXMnO1xyXG5pbXBvcnQgQWxlcnRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvYWxlcnQnO1xyXG5pbXBvcnQgT25ib2FyZGluZ0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9vbmJvYXJkaW5nJztcclxuaW1wb3J0IEJhY2t1cENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9iYWNrdXAnO1xyXG5pbXBvcnQgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvaW5jb21pbmctdHJhbnNhY3Rpb25zJztcclxuaW1wb3J0IERlY3J5cHRNZXNzYWdlQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2RlY3J5cHQtbWVzc2FnZSc7XHJcbmltcG9ydCBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy90cmFuc2FjdGlvbnMnO1xyXG5pbXBvcnQgRGV0ZWN0VG9rZW5zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2RldGVjdC10b2tlbnMnO1xyXG5pbXBvcnQgU3dhcHNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvc3dhcHMnO1xyXG5pbXBvcnQgYWNjb3VudEltcG9ydGVyIGZyb20gJy4vYWNjb3VudC1pbXBvcnQtc3RyYXRlZ2llcyc7XHJcbmltcG9ydCBzZWVkUGhyYXNlVmVyaWZpZXIgZnJvbSAnLi9saWIvc2VlZC1waHJhc2UtdmVyaWZpZXInO1xyXG5pbXBvcnQgTWV0YU1ldHJpY3NDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvbWV0YW1ldHJpY3MnO1xyXG5pbXBvcnQgeyBzZWdtZW50IH0gZnJvbSAnLi9saWIvc2VnbWVudCc7XHJcbmltcG9ydCBjcmVhdGVNZXRhUlBDSGFuZGxlciBmcm9tICcuL2xpYi9jcmVhdGVNZXRhUlBDSGFuZGxlcic7XHJcbmltcG9ydCB7IHByZXZpb3VzVmFsdWVDb21wYXJhdG9yIH0gZnJvbSAnLi9saWIvdXRpbCc7XHJcbmltcG9ydCBjcmVhdGVNZXRhbWFza01pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlTWV0YW1hc2tNaWRkbGV3YXJlJztcclxuaW1wb3J0IEVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvZW5jcnlwdGlvbi1wdWJsaWMta2V5JztcclxuXHJcbmltcG9ydCBXZWIzQXV0aENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy93ZWIzL3dlYjMtYXV0aCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIENhdmVhdE11dGF0b3JGYWN0b3JpZXMsXHJcbiAgZ2V0Q2F2ZWF0U3BlY2lmaWNhdGlvbnMsXHJcbiAgZ2V0Q2hhbmdlZEFjY291bnRzLFxyXG4gIGdldFBlcm1pc3Npb25CYWNrZ3JvdW5kQXBpTWV0aG9kcyxcclxuICBnZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsXHJcbiAgZ2V0UGVybWl0dGVkQWNjb3VudHNCeU9yaWdpbixcclxuICBOT1RJRklDQVRJT05fTkFNRVMsXHJcbiAgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIsXHJcbiAgdW5yZXN0cmljdGVkTWV0aG9kcyxcclxuXG59IGZyb20gJy4vY29udHJvbGxlcnMvcGVybWlzc2lvbnMnO1xyXG5pbXBvcnQgY3JlYXRlUlBDTWV0aG9kVHJhY2tpbmdNaWRkbGV3YXJlIGZyb20gJy4vbGliL2NyZWF0ZVJQQ01ldGhvZFRyYWNraW5nTWlkZGxld2FyZSc7XHJcbmltcG9ydCB7IHNlY3VyaXR5UHJvdmlkZXJDaGVjayB9IGZyb20gJy4vbGliL3NlY3VyaXR5LXByb3ZpZGVyLWhlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTID0ge1xyXG4gIC8vIEZpcmVkIGFmdGVyIHN0YXRlIGNoYW5nZXMgdGhhdCBpbXBhY3QgdGhlIGV4dGVuc2lvbiBiYWRnZSAodW5hcHByb3ZlZCBtc2cgY291bnQpXHJcbiAgLy8gVGhlIHByb2Nlc3Mgb2YgdXBkYXRpbmcgdGhlIGJhZGdlIGhhcHBlbnMgaW4gYXBwL3NjcmlwdHMvYmFja2dyb3VuZC5qcy5cclxuICBVUERBVEVfQkFER0U6ICd1cGRhdGVCYWRnZScsXHJcbiAgLy8gVE9ETzogQWRkIHRoaXMgYW5kIHNpbWlsYXIgZW51bXMgdG8gdGhlIGBjb250cm9sbGVyc2AgcmVwbyBhbmQgZXhwb3J0IHRoZW1cclxuICBBUFBST1ZBTF9TVEFURV9DSEFOR0U6ICdBcHByb3ZhbENvbnRyb2xsZXI6c3RhdGVDaGFuZ2UnLFxyXG59O1xyXG5cclxuLy8gc3RyZWFtIGNoYW5uZWxzXHJcbmNvbnN0IFBISVNISU5HX1NBRkVMSVNUID0gJ21ldGFtYXNrLXBoaXNoaW5nLXNhZmVsaXN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ldGFtYXNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIGNvbnN0IHsgaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwIH0gPSBvcHRzO1xyXG5cclxuICAgIHRoaXMuZGVmYXVsdE1heExpc3RlbmVycyA9IDIwO1xyXG5cclxuICAgIHRoaXMuc2VuZFVwZGF0ZSA9IGRlYm91bmNlKFxyXG4gICAgICB0aGlzLnByaXZhdGVTZW5kVXBkYXRlLmJpbmQodGhpcyksXHJcbiAgICAgIE1JTExJU0VDT05EICogMjAwLFxyXG4gICAgKTtcclxuICAgIHRoaXMub3B0cyA9IG9wdHM7XHJcbiAgICB0aGlzLmV4dGVuc2lvbiA9IG9wdHMuYnJvd3NlcjtcclxuICAgIHRoaXMucGxhdGZvcm0gPSBvcHRzLnBsYXRmb3JtO1xyXG4gICAgdGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyID0gb3B0cy5ub3RpZmljYXRpb25NYW5hZ2VyO1xyXG4gICAgY29uc3QgaW5pdFN0YXRlID0gb3B0cy5pbml0U3RhdGUgfHwge307XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5wbGF0Zm9ybS5nZXRWZXJzaW9uKCk7XHJcbiAgICB0aGlzLnJlY29yZEZpcnN0VGltZUluZm8oaW5pdFN0YXRlKTtcclxuXHJcbiAgICAvLyB0aGlzIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IFwiY29udHJvbGxlclN0cmVhbVwiIGNvbm5lY3Rpb25zIGFyZSBvcGVuXHJcbiAgICAvLyB0aGUgb25seSB0aGluZyB0aGF0IHVzZXMgY29udHJvbGxlciBjb25uZWN0aW9ucyBhcmUgb3BlbiBtZXRhbWFzayBVSSBpbnN0YW5jZXNcclxuICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zID0gMDtcclxuXHJcbiAgICB0aGlzLmdldFJlcXVlc3RBY2NvdW50VGFiSWRzID0gb3B0cy5nZXRSZXF1ZXN0QWNjb3VudFRhYklkcztcclxuICAgIHRoaXMuZ2V0T3Blbk1ldGFtYXNrVGFic0lkcyA9IG9wdHMuZ2V0T3Blbk1ldGFtYXNrVGFic0lkcztcclxuXHJcbiAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIgPSBuZXcgQ29udHJvbGxlck1lc3NlbmdlcigpO1xyXG5cclxuICAgIC8vIGluc3RhbmNlIG9mIGEgY2xhc3MgdGhhdCB3cmFwcyB0aGUgZXh0ZW5zaW9uJ3Mgc3RvcmFnZSBsb2NhbCBBUEkuXHJcbiAgICB0aGlzLmxvY2FsU3RvcmVBcGlXcmFwcGVyID0gb3B0cy5sb2NhbFN0b3JlO1xyXG5cclxuICAgIC8vIG9ic2VydmFibGUgc3RhdGUgc3RvcmVcclxuICAgIHRoaXMuc3RvcmUgPSBuZXcgQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSh7XHJcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUsXHJcbiAgICAgIGNvbnRyb2xsZXJNZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3NlbmdlcixcclxuICAgICAgcGVyc2lzdDogdHJ1ZSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGV4dGVybmFsIGNvbm5lY3Rpb25zIGJ5IG9yaWdpblxyXG4gICAgLy8gRG8gbm90IG1vZGlmeSBkaXJlY3RseS4gVXNlIHRoZSBhc3NvY2lhdGVkIG1ldGhvZHMuXHJcbiAgICB0aGlzLmNvbm5lY3Rpb25zID0ge307XHJcblxyXG4gICAgLy8gbG9jayB0byBlbnN1cmUgb25seSBvbmUgdmF1bHQgY3JlYXRlZCBhdCBvbmNlXHJcbiAgICB0aGlzLmNyZWF0ZVZhdWx0TXV0ZXggPSBuZXcgTXV0ZXgoKTtcclxuXHJcbiAgICB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLm9uSW5zdGFsbGVkLmFkZExpc3RlbmVyKChkZXRhaWxzKSA9PiB7XHJcbiAgICAgIGlmIChkZXRhaWxzLnJlYXNvbiA9PT0gJ3VwZGF0ZScgJiYgdmVyc2lvbiA9PT0gJzguMS4wJykge1xyXG4gICAgICAgIHRoaXMucGxhdGZvcm0ub3BlbkV4dGVuc2lvbkluQnJvd3NlcigpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBuZXh0LCB3ZSB3aWxsIGluaXRpYWxpemUgdGhlIGNvbnRyb2xsZXJzXHJcbiAgICAvLyBjb250cm9sbGVyIGluaXRpYWxpemF0aW9uIG9yZGVyIG1hdHRlcnNcclxuXHJcbiAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlciA9IG5ldyBBcHByb3ZhbENvbnRyb2xsZXIoe1xyXG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgICBuYW1lOiAnQXBwcm92YWxDb250cm9sbGVyJyxcclxuICAgICAgfSksXHJcbiAgICAgIHNob3dBcHByb3ZhbFJlcXVlc3Q6IG9wdHMuc2hvd1VzZXJDb25maXJtYXRpb24sXHJcbiAgICAgIHR5cGVzRXhjbHVkZWRGcm9tUmF0ZUxpbWl0aW5nOiBbXHJcbiAgICAgICAgQXBwcm92YWxUeXBlLkV0aFNpZ24sXHJcbiAgICAgICAgQXBwcm92YWxUeXBlLlBlcnNvbmFsU2lnbixcclxuICAgICAgICBBcHByb3ZhbFR5cGUuRXRoU2lnblR5cGVkRGF0YSxcclxuICAgICAgICBBcHByb3ZhbFR5cGUuVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgQXBwcm92YWxUeXBlLldhdGNoQXNzZXQsXHJcbiAgICAgICAgQXBwcm92YWxUeXBlLkV0aEdldEVuY3J5cHRpb25QdWJsaWNLZXksXHJcbiAgICAgICAgQXBwcm92YWxUeXBlLkV0aERlY3J5cHQsXHJcbiAgICAgIF0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBuZXR3b3JrQ29udHJvbGxlck1lc3NlbmdlciA9IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgbmFtZTogJ05ldHdvcmtDb250cm9sbGVyJyxcclxuICAgICAgYWxsb3dlZEV2ZW50czogT2JqZWN0LnZhbHVlcyhOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZSksXHJcbiAgICB9KTtcclxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIgPSBuZXcgTmV0d29ya0NvbnRyb2xsZXIoe1xyXG4gICAgICBtZXNzZW5nZXI6IG5ldHdvcmtDb250cm9sbGVyTWVzc2VuZ2VyLFxyXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLk5ldHdvcmtDb250cm9sbGVyLFxyXG4gICAgICBpbmZ1cmFQcm9qZWN0SWQ6IG9wdHMuaW5mdXJhUHJvamVjdElkLFxyXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6ICguLi5hcmdzKSA9PlxyXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQoLi4uYXJncyksXHJcbiAgICB9KTtcclxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuaW5pdGlhbGl6ZVByb3ZpZGVyKCk7XHJcbiAgICB0aGlzLnByb3ZpZGVyID1cclxuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLnByb3ZpZGVyO1xyXG4gICAgdGhpcy5ibG9ja1RyYWNrZXIgPVxyXG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQW5kQmxvY2tUcmFja2VyKCkuYmxvY2tUcmFja2VyO1xyXG5cclxuICAgIGNvbnN0IHRva2VuTGlzdE1lc3NlbmdlciA9IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgbmFtZTogJ1Rva2VuTGlzdENvbnRyb2xsZXInLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50b2tlbkxpc3RDb250cm9sbGVyID0gbmV3IFRva2VuTGlzdENvbnRyb2xsZXIoe1xyXG4gICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwoXHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQsXHJcbiAgICAgICksXHJcbiAgICAgIHByZXZlbnRQb2xsaW5nT25OZXR3b3JrUmVzdGFydDogaW5pdFN0YXRlLlRva2VuTGlzdENvbnRyb2xsZXJcclxuICAgICAgICA/IGluaXRTdGF0ZS5Ub2tlbkxpc3RDb250cm9sbGVyLnByZXZlbnRQb2xsaW5nT25OZXR3b3JrUmVzdGFydFxyXG4gICAgICAgIDogdHJ1ZSxcclxuICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChjYikgPT4ge1xyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKChuZXR3b3JrU3RhdGUpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTmV0d29ya1N0YXRlID0ge1xyXG4gICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyQ29uZmlnOiB7XHJcbiAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLFxyXG4gICAgICAgICAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbChuZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcuY2hhaW5JZCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgbWVzc2VuZ2VyOiB0b2tlbkxpc3RNZXNzZW5nZXIsXHJcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuVG9rZW5MaXN0Q29udHJvbGxlcixcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyID0gbmV3IFByZWZlcmVuY2VzQ29udHJvbGxlcih7XHJcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgaW5pdExhbmdDb2RlOiBvcHRzLmluaXRMYW5nQ29kZSxcclxuICAgICAgb25JbmZ1cmFJc0Jsb2NrZWQ6IG5ldHdvcmtDb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZS5iaW5kKFxyXG4gICAgICAgIG5ldHdvcmtDb250cm9sbGVyTWVzc2VuZ2VyLFxyXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLkluZnVyYUlzQmxvY2tlZCxcclxuICAgICAgKSxcclxuICAgICAgb25JbmZ1cmFJc1VuYmxvY2tlZDogbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlLmJpbmQoXHJcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIsXHJcbiAgICAgICAgTmV0d29ya0NvbnRyb2xsZXJFdmVudFR5cGUuSW5mdXJhSXNVbmJsb2NrZWQsXHJcbiAgICAgICksXHJcbiAgICAgIHRva2VuTGlzdENvbnRyb2xsZXI6IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlcixcclxuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRva2Vuc0NvbnRyb2xsZXIgPSBuZXcgVG9rZW5zQ29udHJvbGxlcih7XHJcbiAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXHJcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICksXHJcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiAoY2IpID0+XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKG5ldHdvcmtTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XHJcbiAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcclxuICAgICAgICAgICAgcHJvdmlkZXJDb25maWc6IHtcclxuICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcclxuICAgICAgICB9KSxcclxuICAgICAgY29uZmlnOiB7IHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyIH0sXHJcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuVG9rZW5zQ29udHJvbGxlcixcclxuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XHJcbiAgICAgICAgbmFtZTogJ1Rva2Vuc0NvbnRyb2xsZXInLFxyXG4gICAgICAgIGFsbG93ZWRBY3Rpb25zOiBbXHJcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphZGRSZXF1ZXN0YCxcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxyXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06cmVqZWN0UmVxdWVzdGAsXHJcbiAgICAgICAgXSxcclxuICAgICAgfSksXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciA9IG5ldyBBc3NldHNDb250cmFjdENvbnRyb2xsZXIoXHJcbiAgICAgIHtcclxuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT5cclxuICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZShsaXN0ZW5lciksXHJcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVyIGlzIG1pc25hbWVkLCBhbmQgaXMgYSBrbm93biBpc3N1ZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcclxuICAgICAgICAvLyBieSBwbGFubmVkIHJlZmFjdG9ycy4gSXQgc2hvdWxkIGJlIG9uTmV0d29ya0RpZENoYW5nZSB3aGljaCBoYXBwZW5zXHJcbiAgICAgICAgLy8gQUZURVIgdGhlIHByb3ZpZGVyIGluIHRoZSBuZXR3b3JrIGNvbnRyb2xsZXIgaXMgdXBkYXRlZCB0byByZWZsZWN0XHJcbiAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSBvZiB0aGUgbmV0d29yayBjb250cm9sbGVyLiBJbiAjMTgwNDEgd2UgY2hhbmdlZCB0aGlzXHJcbiAgICAgICAgLy8gaGFuZGxlciB0byBiZSB0cmlnZ2VyZWQgYnkgdGhlIGNoYW5nZSBpbiB0aGUgbmV0d29yayBzdGF0ZSBiZWNhdXNlXHJcbiAgICAgICAgLy8gdGhhdCBpcyB3aGF0IHRoZSBoYW5kbGVyIG5hbWUgaW1wbGllcywgYnV0IHRoaXMgdHJpZ2dlcnMgdG9vIHNvb25cclxuICAgICAgICAvLyBjYXVzaW5nIHRoZSBwcm92aWRlciBvZiB0aGUgQXNzZXRzQ29udHJhY3RDb250cm9sbGVyIHRvIHRyYWlsIHRoZVxyXG4gICAgICAgIC8vIG5ldHdvcmsgcHJvdmlkZXIgYnkgb25lIHVwZGF0ZS5cclxuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PlxyXG4gICAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrRGlkQ2hhbmdlLFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV0d29ya1N0YXRlID0gdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTmV0d29ya1N0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJDb25maWc6IHtcclxuICAgICAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwobmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICApLFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXHJcbiAgICAgIH0sXHJcbiAgICAgIGluaXRTdGF0ZS5Bc3NldHNDb250cmFjdENvbnRyb2xsZXIsXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMubmZ0Q29udHJvbGxlciA9IG5ldyBOZnRDb250cm9sbGVyKFxyXG4gICAgICB7XHJcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlOlxyXG4gICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXHJcbiAgICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PlxyXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKG5ldHdvcmtTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZE5ldHdvcmtTdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUsXHJcbiAgICAgICAgICAgICAgcHJvdmlkZXJDb25maWc6IHtcclxuICAgICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZS5wcm92aWRlckNvbmZpZyxcclxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbChuZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcuY2hhaW5JZCksXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIGdldEVSQzcyMUFzc2V0TmFtZTpcclxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzcyMUFzc2V0TmFtZS5iaW5kKFxyXG4gICAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcclxuICAgICAgICAgICksXHJcbiAgICAgICAgZ2V0RVJDNzIxQXNzZXRTeW1ib2w6XHJcbiAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRFUkM3MjFBc3NldFN5bWJvbC5iaW5kKFxyXG4gICAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcclxuICAgICAgICAgICksXHJcbiAgICAgICAgZ2V0RVJDNzIxVG9rZW5VUkk6IHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzcyMVRva2VuVVJJLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICAgIGdldEVSQzcyMU93bmVyT2Y6IHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzcyMU93bmVyT2YuYmluZChcclxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgZ2V0RVJDMTE1NUJhbGFuY2VPZjpcclxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzExNTVCYWxhbmNlT2YuYmluZChcclxuICAgICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgIGdldEVSQzExNTVUb2tlblVSSTpcclxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzExNTVUb2tlblVSSS5iaW5kKFxyXG4gICAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcclxuICAgICAgICAgICksXHJcbiAgICAgICAgb25OZnRBZGRlZDogKHsgYWRkcmVzcywgc3ltYm9sLCB0b2tlbklkLCBzdGFuZGFyZCwgc291cmNlIH0pID0+XHJcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KHtcclxuICAgICAgICAgICAgZXZlbnQ6IE1ldGFNZXRyaWNzRXZlbnROYW1lLk5mdEFkZGVkLFxyXG4gICAgICAgICAgICBjYXRlZ29yeTogTWV0YU1ldHJpY3NFdmVudENhdGVnb3J5LldhbGxldCxcclxuICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgIHRva2VuX2NvbnRyYWN0X2FkZHJlc3M6IGFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgdG9rZW5fc3ltYm9sOiBzeW1ib2wsXHJcbiAgICAgICAgICAgICAgYXNzZXRfdHlwZTogQXNzZXRUeXBlLk5GVCxcclxuICAgICAgICAgICAgICB0b2tlbl9zdGFuZGFyZDogc3RhbmRhcmQsXHJcbiAgICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgdG9rZW5JZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICB9LFxyXG4gICAgICB7fSxcclxuICAgICAgaW5pdFN0YXRlLk5mdENvbnRyb2xsZXIsXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMubmZ0Q29udHJvbGxlci5zZXRBcGlLZXkocHJvY2Vzcy5lbnYuT1BFTlNFQV9LRVkpO1xyXG5cclxuICAgIHRoaXMubmZ0RGV0ZWN0aW9uQ29udHJvbGxlciA9IG5ldyBOZnREZXRlY3Rpb25Db250cm9sbGVyKHtcclxuICAgICAgb25OZnRzU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT4gdGhpcy5uZnRDb250cm9sbGVyLnN1YnNjcmliZShsaXN0ZW5lciksXHJcbiAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXHJcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICksXHJcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiAoY2IpID0+XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKG5ldHdvcmtTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XHJcbiAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcclxuICAgICAgICAgICAgcHJvdmlkZXJDb25maWc6IHtcclxuICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcsXHJcbiAgICAgICAgICAgICAgY2hhaW5JZDogaGV4VG9EZWNpbWFsKG5ldHdvcmtTdGF0ZS5wcm92aWRlckNvbmZpZy5jaGFpbklkKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICByZXR1cm4gY2IobW9kaWZpZWROZXR3b3JrU3RhdGUpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICBnZXRPcGVuU2VhQXBpS2V5OiAoKSA9PiB0aGlzLm5mdENvbnRyb2xsZXIub3BlblNlYUFwaUtleSxcclxuICAgICAgZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGw6XHJcbiAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwuYmluZChcclxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIGFkZE5mdDogdGhpcy5uZnRDb250cm9sbGVyLmFkZE5mdC5iaW5kKHRoaXMubmZ0Q29udHJvbGxlciksXHJcbiAgICAgIGdldE5mdFN0YXRlOiAoKSA9PiB0aGlzLm5mdENvbnRyb2xsZXIuc3RhdGUsXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlciA9IG5ldyBNZXRhTWV0cmljc0NvbnRyb2xsZXIoe1xyXG4gICAgICBzZWdtZW50LFxyXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcclxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlck1lc3NlbmdlcixcclxuICAgICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrRGlkQ2hhbmdlLFxyXG4gICAgICApLFxyXG4gICAgICBnZXROZXR3b3JrSWRlbnRpZmllcjogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcnBjVXJsIH0gPVxyXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnO1xyXG4gICAgICAgIHJldHVybiB0eXBlID09PSBORVRXT1JLX1RZUEVTLlJQQyA/IHJwY1VybCA6IHR5cGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxyXG4gICAgICB2ZXJzaW9uOiB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKSxcclxuICAgICAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk1FVEFNQVNLX0VOVklST05NRU5ULFxyXG4gICAgICBleHRlbnNpb246IHRoaXMuZXh0ZW5zaW9uLFxyXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIsXHJcbiAgICAgIGNhcHR1cmVFeGNlcHRpb24sXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm9uKCd1cGRhdGUnLCAodXBkYXRlKSA9PiB7XHJcbiAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLmhhbmRsZU1ldGFNYXNrU3RhdGVVcGRhdGUodXBkYXRlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGdhc0ZlZU1lc3NlbmdlciA9IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgbmFtZTogJ0dhc0ZlZUNvbnRyb2xsZXInLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZ2FzQXBpQmFzZVVybCA9IHByb2Nlc3MuZW52LlNXQVBTX1VTRV9ERVZfQVBJU1xyXG4gICAgICA/IEdBU19ERVZfQVBJX0JBU0VfVVJMXHJcbiAgICAgIDogR0FTX0FQSV9CQVNFX1VSTDtcclxuXHJcbiAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIgPSBuZXcgR2FzRmVlQ29udHJvbGxlcih7XHJcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuR2FzRmVlQ29udHJvbGxlcixcclxuICAgICAgaW50ZXJ2YWw6IDEwMDAwLFxyXG4gICAgICBtZXNzZW5nZXI6IGdhc0ZlZU1lc3NlbmdlcixcclxuICAgICAgY2xpZW50SWQ6IFNXQVBTX0NMSUVOVF9JRCxcclxuICAgICAgZ2V0UHJvdmlkZXI6ICgpID0+XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLnByb3ZpZGVyLFxyXG4gICAgICAvLyBOT1RFOiBUaGlzIG9wdGlvbiBpcyBpbmFjY3VyYXRlbHkgbmFtZWQ7IGl0IHNob3VsZCBiZSBjYWxsZWRcclxuICAgICAgLy8gb25OZXR3b3JrRGlkQ2hhbmdlXHJcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcclxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlck1lc3NlbmdlcixcclxuICAgICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrRGlkQ2hhbmdlLFxyXG4gICAgICApLFxyXG4gICAgICBnZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5OlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcclxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eTpcclxuICAgICAgICB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZCh0aGlzKSxcclxuICAgICAgbGVnYWN5QVBJRW5kcG9pbnQ6IGAke2dhc0FwaUJhc2VVcmx9L25ldHdvcmtzLzxjaGFpbl9pZD4vZ2FzUHJpY2VzYCxcclxuICAgICAgRUlQMTU1OUFQSUVuZHBvaW50OiBgJHtnYXNBcGlCYXNlVXJsfS9uZXR3b3Jrcy88Y2hhaW5faWQ+L3N1Z2dlc3RlZEdhc0ZlZXNgLFxyXG4gICAgICBnZXRDdXJyZW50TmV0d29ya0xlZ2FjeUdhc0FQSUNvbXBhdGliaWxpdHk6ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9XHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWc7XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LklOX1RFU1QgfHwgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLk1BSU5ORVQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldENoYWluSWQ6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSU5fVEVTVFxyXG4gICAgICAgICAgPyBDSEFJTl9JRFMuTUFJTk5FVFxyXG4gICAgICAgICAgOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZDtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMucXJIYXJkd2FyZUtleXJpbmcgPSBuZXcgUVJIYXJkd2FyZUtleXJpbmcoKTtcclxuXHJcbiAgICB0aGlzLmFwcFN0YXRlQ29udHJvbGxlciA9IG5ldyBBcHBTdGF0ZUNvbnRyb2xsZXIoe1xyXG4gICAgICBhZGRVbmxvY2tMaXN0ZW5lcjogdGhpcy5vbi5iaW5kKHRoaXMsICd1bmxvY2snKSxcclxuICAgICAgaXNVbmxvY2tlZDogdGhpcy5pc1VubG9ja2VkLmJpbmQodGhpcyksXHJcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcixcclxuICAgICAgb25JbmFjdGl2ZVRpbWVvdXQ6ICgpID0+IHRoaXMuc2V0TG9ja2VkKCksXHJcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBxckhhcmR3YXJlU3RvcmU6IHRoaXMucXJIYXJkd2FyZUtleXJpbmcuZ2V0TWVtU3RvcmUoKSxcclxuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XHJcbiAgICAgICAgbmFtZTogJ0FwcFN0YXRlQ29udHJvbGxlcicsXHJcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFkZFJlcXVlc3RgLFxyXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06YWNjZXB0UmVxdWVzdGAsXHJcbiAgICAgICAgXSxcclxuICAgICAgfSksXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjdXJyZW5jeVJhdGVNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XHJcbiAgICAgIG5hbWU6ICdDdXJyZW5jeVJhdGVDb250cm9sbGVyJyxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyID0gbmV3IEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIoe1xyXG4gICAgICBpbmNsdWRlVXNkUmF0ZTogdHJ1ZSxcclxuICAgICAgbWVzc2VuZ2VyOiBjdXJyZW5jeVJhdGVNZXNzZW5nZXIsXHJcbiAgICAgIHN0YXRlOiB7XHJcbiAgICAgICAgLi4uaW5pdFN0YXRlLkN1cnJlbmN5Q29udHJvbGxlcixcclxuICAgICAgICBuYXRpdmVDdXJyZW5jeTpcclxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy50aWNrZXIsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnBoaXNoaW5nQ29udHJvbGxlciA9IG5ldyBQaGlzaGluZ0NvbnRyb2xsZXIoXHJcbiAgICAgIHt9LFxyXG4gICAgICBpbml0U3RhdGUuUGhpc2hpbmdDb250cm9sbGVyLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLnBoaXNoaW5nQ29udHJvbGxlci5tYXliZVVwZGF0ZVN0YXRlKCk7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52LklOX1RFU1QpIHtcclxuICAgICAgdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIuc2V0SG90bGlzdFJlZnJlc2hJbnRlcnZhbCg1ICogU0VDT05EKTtcclxuICAgICAgdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIuc2V0U3RhbGVsaXN0UmVmcmVzaEludGVydmFsKDMwICogU0VDT05EKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhbm5vdW5jZW1lbnRNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XHJcbiAgICAgIG5hbWU6ICdBbm5vdW5jZW1lbnRDb250cm9sbGVyJyxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5hbm5vdW5jZW1lbnRDb250cm9sbGVyID0gbmV3IEFubm91bmNlbWVudENvbnRyb2xsZXIoe1xyXG4gICAgICBtZXNzZW5nZXI6IGFubm91bmNlbWVudE1lc3NlbmdlcixcclxuICAgICAgYWxsQW5ub3VuY2VtZW50czogVUlfTk9USUZJQ0FUSU9OUyxcclxuICAgICAgc3RhdGU6IGluaXRTdGF0ZS5Bbm5vdW5jZW1lbnRDb250cm9sbGVyLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gdG9rZW4gZXhjaGFuZ2UgcmF0ZSB0cmFja2VyXHJcbiAgICB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyID0gbmV3IFRva2VuUmF0ZXNDb250cm9sbGVyKFxyXG4gICAgICB7XHJcbiAgICAgICAgb25Ub2tlbnNTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxyXG4gICAgICAgICAgdGhpcy50b2tlbnNDb250cm9sbGVyLnN1YnNjcmliZShsaXN0ZW5lciksXHJcbiAgICAgICAgb25DdXJyZW5jeVJhdGVTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxyXG4gICAgICAgICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShcclxuICAgICAgICAgICAgYCR7dGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLm5hbWV9OnN0YXRlQ2hhbmdlYCxcclxuICAgICAgICAgICAgbGlzdGVuZXIsXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiAoY2IpID0+XHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTmV0d29ya1N0YXRlID0ge1xyXG4gICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcclxuICAgICAgICAgICAgICBwcm92aWRlckNvbmZpZzoge1xyXG4gICAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogaGV4VG9EZWNpbWFsKG5ldHdvcmtTdGF0ZS5wcm92aWRlckNvbmZpZy5jaGFpbklkKSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY2IobW9kaWZpZWROZXR3b3JrU3RhdGUpO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBkaXNhYmxlZDpcclxuICAgICAgICAgICF0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnVzZUN1cnJlbmN5UmF0ZUNoZWNrLFxyXG4gICAgICB9LFxyXG4gICAgICBpbml0U3RhdGUuVG9rZW5SYXRlc0NvbnRyb2xsZXIsXHJcbiAgICApO1xyXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKFxyXG4gICAgICBwcmV2aW91c1ZhbHVlQ29tcGFyYXRvcigocHJldlN0YXRlLCBjdXJyU3RhdGUpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZUN1cnJlbmN5UmF0ZUNoZWNrOiBwcmV2VXNlQ3VycmVuY3lSYXRlQ2hlY2sgfSA9IHByZXZTdGF0ZTtcclxuICAgICAgICBjb25zdCB7IHVzZUN1cnJlbmN5UmF0ZUNoZWNrOiBjdXJyVXNlQ3VycmVuY3lSYXRlQ2hlY2sgfSA9IGN1cnJTdGF0ZTtcclxuICAgICAgICBpZiAoY3VyclVzZUN1cnJlbmN5UmF0ZUNoZWNrICYmICFwcmV2VXNlQ3VycmVuY3lSYXRlQ2hlY2spIHtcclxuICAgICAgICAgIHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlci5zdGFydCgpO1xyXG4gICAgICAgICAgdGhpcy50b2tlblJhdGVzQ29udHJvbGxlci5jb25maWd1cmUoXHJcbiAgICAgICAgICAgIHsgZGlzYWJsZWQ6IGZhbHNlIH0sXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghY3VyclVzZUN1cnJlbmN5UmF0ZUNoZWNrICYmIHByZXZVc2VDdXJyZW5jeVJhdGVDaGVjaykge1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLnN0b3AoKTtcclxuICAgICAgICAgIHRoaXMudG9rZW5SYXRlc0NvbnRyb2xsZXIuY29uZmlndXJlKHsgZGlzYWJsZWQ6IHRydWUgfSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkpLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmVuc0NvbnRyb2xsZXIgPSBuZXcgRW5zQ29udHJvbGxlcih7XHJcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxyXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogKCkgPT5cclxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcclxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcclxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlck1lc3NlbmdlcixcclxuICAgICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrRGlkQ2hhbmdlLFxyXG4gICAgICApLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlciA9IG5ldyBPbmJvYXJkaW5nQ29udHJvbGxlcih7XHJcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIgPSBuZXcgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyKHtcclxuICAgICAgYmxvY2tUcmFja2VyOiB0aGlzLmJsb2NrVHJhY2tlcixcclxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcclxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlck1lc3NlbmdlcixcclxuICAgICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrRGlkQ2hhbmdlLFxyXG4gICAgICApLFxyXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogKCkgPT5cclxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcclxuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXI6IHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIsXHJcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcixcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGFjY291bnQgdHJhY2tlciB3YXRjaGVzIGJhbGFuY2VzLCBub25jZXMsIGFuZCBhbnkgY29kZSBhdCB0aGVpciBhZGRyZXNzXHJcbiAgICB0aGlzLmFjY291bnRUcmFja2VyID0gbmV3IEFjY291bnRUcmFja2VyKHtcclxuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXHJcbiAgICAgIGJsb2NrVHJhY2tlcjogdGhpcy5ibG9ja1RyYWNrZXIsXHJcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxyXG4gICAgICBnZXROZXR3b3JrSWRlbnRpZmllcjogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcnBjVXJsIH0gPVxyXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnO1xyXG4gICAgICAgIHJldHVybiB0eXBlID09PSBORVRXT1JLX1RZUEVTLlJQQyA/IHJwY1VybCA6IHR5cGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcjogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICAgIG9uYm9hcmRpbmdDb250cm9sbGVyOiB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLFxyXG4gICAgICBpbml0U3RhdGU6XHJcbiAgICAgICAgaXNNYW5pZmVzdFYzICYmXHJcbiAgICAgICAgaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwID09PSBmYWxzZSAmJlxyXG4gICAgICAgIGluaXRTdGF0ZS5BY2NvdW50VHJhY2tlcj8uYWNjb3VudHNcclxuICAgICAgICAgID8geyBhY2NvdW50czogaW5pdFN0YXRlLkFjY291bnRUcmFja2VyLmFjY291bnRzIH1cclxuICAgICAgICAgIDogeyBhY2NvdW50czoge30gfSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHN0YXJ0IGFuZCBzdG9wIHBvbGxpbmcgZm9yIGJhbGFuY2VzIGJhc2VkIG9uIGFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9uc1xyXG4gICAgdGhpcy5vbignY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkJywgKGFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucykgPT4ge1xyXG4gICAgICBjb25zdCB7IGNvbXBsZXRlZE9uYm9hcmRpbmcgfSA9XHJcbiAgICAgICAgdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICBpZiAoYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zID4gMCAmJiBjb21wbGV0ZWRPbmJvYXJkaW5nKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyTmV0d29ya3JlcXVlc3RzKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTmV0d29ya1JlcXVlc3RzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKFxyXG4gICAgICBwcmV2aW91c1ZhbHVlQ29tcGFyYXRvcihhc3luYyAocHJldlN0YXRlLCBjdXJyU3RhdGUpID0+IHtcclxuICAgICAgICBjb25zdCB7IGNvbXBsZXRlZE9uYm9hcmRpbmc6IHByZXZDb21wbGV0ZWRPbmJvYXJkaW5nIH0gPSBwcmV2U3RhdGU7XHJcbiAgICAgICAgY29uc3QgeyBjb21wbGV0ZWRPbmJvYXJkaW5nOiBjdXJyQ29tcGxldGVkT25ib2FyZGluZyB9ID0gY3VyclN0YXRlO1xyXG4gICAgICAgIGlmICghcHJldkNvbXBsZXRlZE9uYm9hcmRpbmcgJiYgY3VyckNvbXBsZXRlZE9uYm9hcmRpbmcpIHtcclxuICAgICAgICAgIHRoaXMudHJpZ2dlck5ldHdvcmtyZXF1ZXN0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpKSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5jYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIgPSBuZXcgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyKHtcclxuICAgICAgYWNjb3VudFRyYWNrZXI6IHRoaXMuYWNjb3VudFRyYWNrZXIsXHJcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxyXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5DYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIsXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgYWRkaXRpb25hbEtleXJpbmdzID0gW2tleXJpbmdCdWlsZGVyRmFjdG9yeShRUkhhcmR3YXJlS2V5cmluZyldO1xyXG5cclxuICAgIGlmICh0aGlzLmNhblVzZUhhcmR3YXJlV2FsbGV0cygpKSB7XHJcbiAgICAgIGNvbnN0IGtleXJpbmdPdmVycmlkZXMgPSB0aGlzLm9wdHMub3ZlcnJpZGVzPy5rZXlyaW5ncztcclxuXHJcbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxLZXlyaW5nVHlwZXMgPSBbXHJcbiAgICAgICAga2V5cmluZ092ZXJyaWRlcz8udHJlem9yIHx8IFRyZXpvcktleXJpbmcsXHJcbiAgICAgICAga2V5cmluZ092ZXJyaWRlcz8ubGVkZ2VyIHx8IExlZGdlckJyaWRnZUtleXJpbmcsXHJcbiAgICAgICAga2V5cmluZ092ZXJyaWRlcz8ubGF0dGljZSB8fCBMYXR0aWNlS2V5cmluZyxcclxuICAgICAgICBRUkhhcmR3YXJlS2V5cmluZyxcclxuICAgICAgXTtcclxuICAgICAgYWRkaXRpb25hbEtleXJpbmdzID0gYWRkaXRpb25hbEtleXJpbmdUeXBlcy5tYXAoKGtleXJpbmdUeXBlKSA9PlxyXG4gICAgICAgIGtleXJpbmdCdWlsZGVyRmFjdG9yeShrZXlyaW5nVHlwZSksXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlciA9IG5ldyBLZXlyaW5nQ29udHJvbGxlcih7XHJcbiAgICAgIGtleXJpbmdCdWlsZGVyczogYWRkaXRpb25hbEtleXJpbmdzLFxyXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5LZXlyaW5nQ29udHJvbGxlcixcclxuICAgICAgZW5jcnlwdG9yOiBvcHRzLmVuY3J5cHRvciB8fCB1bmRlZmluZWQsXHJcbiAgICAgIGNhY2hlRW5jcnlwdGlvbktleTogaXNNYW5pZmVzdFYzLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZS5zdWJzY3JpYmUoKHN0YXRlKSA9PlxyXG4gICAgICB0aGlzLl9vbktleXJpbmdDb250cm9sbGVyVXBkYXRlKHN0YXRlKSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5vbigndW5sb2NrJywgKCkgPT4gdGhpcy5fb25VbmxvY2soKSk7XHJcbiAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLm9uKCdsb2NrJywgKCkgPT4gdGhpcy5fb25Mb2NrKCkpO1xyXG5cclxuICAgIGNvbnN0IGdldElkZW50aXRpZXMgPSAoKSA9PlxyXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLmlkZW50aXRpZXM7XHJcblxyXG4gICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlciA9IG5ldyBQZXJtaXNzaW9uQ29udHJvbGxlcih7XHJcbiAgICAgIG1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xyXG4gICAgICAgIG5hbWU6ICdQZXJtaXNzaW9uQ29udHJvbGxlcicsXHJcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFkZFJlcXVlc3RgLFxyXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06aGFzUmVxdWVzdGAsXHJcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphY2NlcHRSZXF1ZXN0YCxcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OnJlamVjdFJlcXVlc3RgLFxyXG4gICAgICAgICAgYFNuYXBDb250cm9sbGVyOmdldFBlcm1pdHRlZGAsXHJcbiAgICAgICAgICBgU25hcENvbnRyb2xsZXI6aW5zdGFsbGAsXHJcbiAgICAgICAgICBgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjpnZXRTdWJqZWN0TWV0YWRhdGFgLFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0pLFxyXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLlBlcm1pc3Npb25Db250cm9sbGVyLFxyXG4gICAgICBjYXZlYXRTcGVjaWZpY2F0aW9uczogZ2V0Q2F2ZWF0U3BlY2lmaWNhdGlvbnMoeyBnZXRJZGVudGl0aWVzIH0pLFxyXG4gICAgICBwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnM6IHtcclxuICAgICAgICAuLi5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMoe1xyXG4gICAgICAgICAgZ2V0SWRlbnRpdGllcyxcclxuICAgICAgICAgIGdldEFsbEFjY291bnRzOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzLmJpbmQoXHJcbiAgICAgICAgICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIsXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgY2FwdHVyZUtleXJpbmdUeXBlc1dpdGhNaXNzaW5nSWRlbnRpdGllczogKFxyXG4gICAgICAgICAgICBpZGVudGl0aWVzID0ge30sXHJcbiAgICAgICAgICAgIGFjY291bnRzID0gW10sXHJcbiAgICAgICAgICApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWNjb3VudHNNaXNzaW5nSWRlbnRpdGllcyA9IGFjY291bnRzLmZpbHRlcihcclxuICAgICAgICAgICAgICAoYWRkcmVzcykgPT4gIWlkZW50aXRpZXNbYWRkcmVzc10sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXJpbmdUeXBlc1dpdGhNaXNzaW5nSWRlbnRpdGllcyA9XHJcbiAgICAgICAgICAgICAgYWNjb3VudHNNaXNzaW5nSWRlbnRpdGllcy5tYXAoXHJcbiAgICAgICAgICAgICAgICAoYWRkcmVzcykgPT5cclxuICAgICAgICAgICAgICAgICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKT8udHlwZSxcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpdGllc0NvdW50ID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcyB8fCB7fSkubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYWNjb3VudFRyYWNrZXJDb3VudCA9IE9iamVjdC5rZXlzKFxyXG4gICAgICAgICAgICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUuZ2V0U3RhdGUoKS5hY2NvdW50cyB8fCB7fSxcclxuICAgICAgICAgICAgKS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBjYXB0dXJlRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgIGBBdHRlbXB0IHRvIGdldCBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb25zIGZhaWxlZCBiZWNhdXNlIHRoZWlyIHdlcmUgJHthY2NvdW50cy5sZW5ndGh9IGFjY291bnRzLCBidXQgJHtpZGVudGl0aWVzQ291bnR9IGlkZW50aXRpZXMsIGFuZCB0aGUgJHtrZXlyaW5nVHlwZXNXaXRoTWlzc2luZ0lkZW50aXRpZXN9IGtleXJpbmdzIGluY2x1ZGVkIGFjY291bnRzIHdpdGggbWlzc2luZyBpZGVudGl0aWVzLiBNZWFud2hpbGUsIHRoZXJlIGFyZSAke2FjY291bnRUcmFja2VyQ291bnR9IGFjY291bnRzIGluIHRoZSBhY2NvdW50IHRyYWNrZXIuYCxcclxuICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KSxcclxuXG4gICAgICB9LFxyXG4gICAgICB1bnJlc3RyaWN0ZWRNZXRob2RzLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlciA9IG5ldyBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcih7XHJcbiAgICAgIHJlc3RyaWN0ZWRNZXRob2RzOiBuZXcgU2V0KE9iamVjdC5rZXlzKFJlc3RyaWN0ZWRNZXRob2RzKSksXHJcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLlBlcm1pc3Npb25Mb2dDb250cm9sbGVyLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gbmV3IFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIoe1xyXG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgICBuYW1lOiAnU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcicsXHJcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtgJHt0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLm5hbWV9Omhhc1Blcm1pc3Npb25zYF0sXHJcbiAgICAgIH0pLFxyXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLlN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXHJcbiAgICAgIHN1YmplY3RDYWNoZUxpbWl0OiAxMDAsXHJcbiAgICB9KTtcclxuXHJcblxuXHJcblxuXHJcbiAgICB0aGlzLmRldGVjdFRva2Vuc0NvbnRyb2xsZXIgPSBuZXcgRGV0ZWN0VG9rZW5zQ29udHJvbGxlcih7XHJcbiAgICAgIHByZWZlcmVuY2VzOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgdG9rZW5zQ29udHJvbGxlcjogdGhpcy50b2tlbnNDb250cm9sbGVyLFxyXG4gICAgICBhc3NldHNDb250cmFjdENvbnRyb2xsZXI6IHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxyXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxyXG4gICAgICBrZXlyaW5nTWVtU3RvcmU6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUsXHJcbiAgICAgIHRva2VuTGlzdDogdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLFxyXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcclxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyID0gbmV3IEFkZHJlc3NCb29rQ29udHJvbGxlcihcclxuICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICBpbml0U3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmFsZXJ0Q29udHJvbGxlciA9IG5ldyBBbGVydENvbnRyb2xsZXIoe1xyXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5BbGVydENvbnRyb2xsZXIsXHJcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy53ZWIzQXV0aENvbnRyb2xsZXIgPSBuZXcgV2ViM0F1dGhDb250cm9sbGVyKFxyXG4gICAgICB7XHJcbiAgICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuV2ViM0F1dGhDb250cm9sbGVyLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuYmFja3VwQ29udHJvbGxlciA9IG5ldyBCYWNrdXBDb250cm9sbGVyKHtcclxuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgYWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcclxuICAgICAgbmV0d29ya0NvbnRyb2xsZXI6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgICAgIHRyYWNrTWV0YU1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxyXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50eENvbnRyb2xsZXIgPSBuZXcgVHJhbnNhY3Rpb25Db250cm9sbGVyKHtcclxuICAgICAgaW5pdFN0YXRlOlxyXG4gICAgICAgIGluaXRTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIgfHwgaW5pdFN0YXRlLlRyYW5zYWN0aW9uTWFuYWdlcixcclxuICAgICAgZ2V0UGVybWl0dGVkQWNjb3VudHM6IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMuYmluZCh0aGlzKSxcclxuICAgICAgZ2V0UHJvdmlkZXJDb25maWc6ICgpID0+XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLFxyXG4gICAgICBnZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5OlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcclxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eTpcclxuICAgICAgICB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZCh0aGlzKSxcclxuICAgICAgZ2V0TmV0d29ya0lkOiAoKSA9PiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkubmV0d29ya0lkLFxyXG4gICAgICBnZXROZXR3b3JrU3RhdHVzOiAoKSA9PlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5uZXR3b3JrU3RhdHVzLFxyXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgbGV0IHByZXZpb3VzTmV0d29ya0lkID1cclxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5uZXR3b3JrSWQ7XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKHN0YXRlKSA9PiB7XHJcbiAgICAgICAgICBpZiAocHJldmlvdXNOZXR3b3JrSWQgIT09IHN0YXRlLm5ldHdvcmtJZCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICBwcmV2aW91c05ldHdvcmtJZCA9IHN0YXRlLm5ldHdvcmtJZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6ICgpID0+XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQsXHJcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICB0eEhpc3RvcnlMaW1pdDogNjAsXHJcbiAgICAgIHNpZ25UcmFuc2FjdGlvbjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zaWduVHJhbnNhY3Rpb24uYmluZChcclxuICAgICAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcclxuICAgICAgYmxvY2tUcmFja2VyOiB0aGlzLmJsb2NrVHJhY2tlcixcclxuICAgICAgY3JlYXRlRXZlbnRGcmFnbWVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuY3JlYXRlRXZlbnRGcmFnbWVudC5iaW5kKFxyXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICB1cGRhdGVFdmVudEZyYWdtZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci51cGRhdGVFdmVudEZyYWdtZW50LmJpbmQoXHJcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIGZpbmFsaXplRXZlbnRGcmFnbWVudDpcclxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5maW5hbGl6ZUV2ZW50RnJhZ21lbnQuYmluZChcclxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIGdldEV2ZW50RnJhZ21lbnRCeUlkOlxyXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLmdldEV2ZW50RnJhZ21lbnRCeUlkLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcclxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgZ2V0UGFydGljaXBhdGVJbk1ldHJpY3M6ICgpID0+XHJcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuc3RhdGUucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzLFxyXG4gICAgICBnZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzOlxyXG4gICAgICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlci5mZXRjaEdhc0ZlZUVzdGltYXRlcy5iaW5kKHRoaXMuZ2FzRmVlQ29udHJvbGxlciksXHJcbiAgICAgIGdldEV4dGVybmFsUGVuZGluZ1RyYW5zYWN0aW9uczpcclxuICAgICAgICB0aGlzLmdldEV4dGVybmFsUGVuZGluZ1RyYW5zYWN0aW9ucy5iaW5kKHRoaXMpLFxyXG4gICAgICBnZXRBY2NvdW50VHlwZTogdGhpcy5nZXRBY2NvdW50VHlwZS5iaW5kKHRoaXMpLFxyXG4gICAgICBnZXREZXZpY2VNb2RlbDogdGhpcy5nZXREZXZpY2VNb2RlbC5iaW5kKHRoaXMpLFxyXG4gICAgICBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlsczogdGhpcy5nZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscy5iaW5kKHRoaXMpLFxyXG4gICAgICBzZWN1cml0eVByb3ZpZGVyUmVxdWVzdDogdGhpcy5zZWN1cml0eVByb3ZpZGVyUmVxdWVzdC5iaW5kKHRoaXMpLFxyXG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgICBuYW1lOiAnVHJhbnNhY3Rpb25Db250cm9sbGVyJyxcclxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW1xyXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06YWRkUmVxdWVzdGAsXHJcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphY2NlcHRSZXF1ZXN0YCxcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OnJlamVjdFJlcXVlc3RgLFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0pLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50eENvbnRyb2xsZXIub24oYHR4OnN0YXR1cy11cGRhdGVgLCBhc3luYyAodHhJZCwgc3RhdHVzKSA9PiB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCB8fFxyXG4gICAgICAgIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xyXG4gICAgICAgIGxldCBycGNQcmVmcyA9IHt9O1xyXG4gICAgICAgIGlmICh0eE1ldGEuY2hhaW5JZCkge1xyXG4gICAgICAgICAgY29uc3QgeyBuZXR3b3JrQ29uZmlndXJhdGlvbnMgfSA9XHJcbiAgICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgIGNvbnN0IG1hdGNoaW5nTmV0d29ya0NvbmZpZyA9IE9iamVjdC52YWx1ZXMoXHJcbiAgICAgICAgICAgIG5ldHdvcmtDb25maWd1cmF0aW9ucyxcclxuICAgICAgICAgICkuZmluZChcclxuICAgICAgICAgICAgKG5ldHdvcmtDb25maWd1cmF0aW9uKSA9PlxyXG4gICAgICAgICAgICAgIG5ldHdvcmtDb25maWd1cmF0aW9uLmNoYWluSWQgPT09IHR4TWV0YS5jaGFpbklkLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJwY1ByZWZzID0gbWF0Y2hpbmdOZXR3b3JrQ29uZmlnPy5ycGNQcmVmcyA/PyB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsYXRmb3JtLnNob3dUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbih0eE1ldGEsIHJwY1ByZWZzKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIG5vdGlmaWNhdGlvbicsIGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdHhSZWNlaXB0IH0gPSB0eE1ldGE7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2ZlckZyb20gbWV0aG9kIGdlbmVyYXRlZCBmcm9tIHdpdGhpbiB0aGUgYXBwIGl0IG1heSBiZSBhbiBORlQgdHJhbnNmZXIgdHJhbnNhY3Rpb25cclxuICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIHdpbGwgd2FudCB0byBjaGVjayBhbmQgdXBkYXRlIG93bmVyc2hpcCBzdGF0dXMgb2YgdGhlIHRyYW5zZmVycmVkIE5GVC5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0eE1ldGEudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXJGcm9tICYmXHJcbiAgICAgICAgICB0eE1ldGEudHhQYXJhbXMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICB0bzogY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICBmcm9tOiB1c2VyQWRkcmVzcyxcclxuICAgICAgICAgIH0gPSB0eE1ldGEudHhQYXJhbXM7XHJcbiAgICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHR4TWV0YTtcclxuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YShkYXRhKTtcclxuICAgICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgdG9rZW5JZCB2YWx1ZSBpcyBwYXJzZWQgYXMgXCJfdmFsdWVcIiBwYXJhbS4gTm90IHNlZWluZyB0aGlzIG9mdGVuIGFueSBtb3JlLCBidXQgc3RpbGwgb2NjYXNpb25hbGx5OlxyXG4gICAgICAgICAgLy8gaS5lLiBjYWxsIGFwcHJvdmUoKSBvbiBCQVlDIGNvbnRyYWN0IC0gaHR0cHM6Ly9ldGhlcnNjYW4uaW8vdG9rZW4vMHhiYzRjYTBlZGE3NjQ3YThhYjdjMjA2MWMyZTExOGExOGE5MzZmMTNkI3dyaXRlQ29udHJhY3QsIGFuZCB0b2tlbklkIHNob3dzIHVwIGFzIF92YWx1ZSxcclxuICAgICAgICAgIC8vIG5vdCBzdXJlIHdoeSBzaW5jZSBpdCBkb2Vzbid0IG1hdGNoIHRoZSBFUkM3MjEgQUJJIHNwZWMgd2UgdXNlIHRvIHBhcnNlIHRoZXNlIHRyYW5zYWN0aW9ucyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1ldGgtYWJpcy9ibG9iL2QwNDc0MzA4YTI4OGY5MjUyNTk3YjdjOTNhM2E4ZGVhYWQxOWUxYjIvc3JjL2FiaXMvYWJpRVJDNzIxLnRzI0w2Mi5cclxuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YVRva2VuSWQgPVxyXG4gICAgICAgICAgICBnZXRUb2tlbklkUGFyYW0odHJhbnNhY3Rpb25EYXRhKSA/P1xyXG4gICAgICAgICAgICBnZXRUb2tlblZhbHVlUGFyYW0odHJhbnNhY3Rpb25EYXRhKTtcclxuICAgICAgICAgIGNvbnN0IHsgYWxsTmZ0cyB9ID0gdGhpcy5uZnRDb250cm9sbGVyLnN0YXRlO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGNoYWluSWRBc0RlY2ltYWwgPSBoZXhUb0RlY2ltYWwoY2hhaW5JZCk7XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiBpdHMgYSBrbm93biBORlRcclxuICAgICAgICAgIGNvbnN0IGtub3duTmZ0ID0gYWxsTmZ0cz8uW3VzZXJBZGRyZXNzXT8uW2NoYWluSWRBc0RlY2ltYWxdPy5maW5kKFxyXG4gICAgICAgICAgICAoeyBhZGRyZXNzLCB0b2tlbklkIH0pID0+XHJcbiAgICAgICAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShhZGRyZXNzLCBjb250cmFjdEFkZHJlc3MpICYmXHJcbiAgICAgICAgICAgICAgdG9rZW5JZCA9PT0gdHJhbnNhY3Rpb25EYXRhVG9rZW5JZCxcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gaWYgaXQgaXMgd2UgY2hlY2sgYW5kIHVwZGF0ZSBvd25lcnNoaXAgc3RhdHVzLlxyXG4gICAgICAgICAgaWYgKGtub3duTmZ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubmZ0Q29udHJvbGxlci5jaGVja0FuZFVwZGF0ZVNpbmdsZU5mdE93bmVyc2hpcFN0YXR1cyhcclxuICAgICAgICAgICAgICBrbm93bk5mdCxcclxuICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICB7IHVzZXJBZGRyZXNzLCBjaGFpbklkOiBjaGFpbklkQXNEZWNpbWFsIH0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBtZXRhbWFza1N0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgICBpZiAodHhSZWNlaXB0ICYmIHR4UmVjZWlwdC5zdGF0dXMgPT09ICcweDAnKSB7XHJcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgZXZlbnQ6ICdUeCBTdGF0dXMgVXBkYXRlOiBPbi1DaGFpbiBGYWlsdXJlJyxcclxuICAgICAgICAgICAgICBjYXRlZ29yeTogTWV0YU1ldHJpY3NFdmVudENhdGVnb3J5LkJhY2tncm91bmQsXHJcbiAgICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnVHJhbnNhY3Rpb25zJyxcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogdHhNZXRhLnNpbXVsYXRpb25GYWlscz8ucmVhc29uLFxyXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZUb2tlbnM6IG1ldGFtYXNrU3RhdGUudG9rZW5zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG51bWJlck9mQWNjb3VudHM6IE9iamVjdC5rZXlzKG1ldGFtYXNrU3RhdGUuYWNjb3VudHMpLmxlbmd0aCxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbWF0b21vRXZlbnQ6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxyXG4gICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrRGlkQ2hhbmdlLFxyXG4gICAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0aWNrZXIgfSA9XHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWc7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlci5zZXROYXRpdmVDdXJyZW5jeSh0aWNrZXIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgZmFpbHVyZSB0byBnZXQgY29udmVyc2lvbiByYXRlIG1vcmUgZ3JhY2VmdWxseVxyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmxvb2t1cE5ldHdvcmsoKTtcclxuICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyID0gbmV3IERlY3J5cHRNZXNzYWdlQ29udHJvbGxlcih7XHJcbiAgICAgIGdldFN0YXRlOiB0aGlzLmdldFN0YXRlLmJpbmQodGhpcyksXHJcbiAgICAgIGtleXJpbmdDb250cm9sbGVyOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxyXG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgICBuYW1lOiAnRGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyJyxcclxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW1xyXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06YWRkUmVxdWVzdGAsXHJcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphY2NlcHRSZXF1ZXN0YCxcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OnJlamVjdFJlcXVlc3RgLFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0pLFxyXG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcclxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIgPSBuZXcgRW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIoe1xyXG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcclxuICAgICAgICBuYW1lOiAnRW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXInLFxyXG4gICAgICAgIGFsbG93ZWRBY3Rpb25zOiBbXHJcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphZGRSZXF1ZXN0YCxcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxyXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06cmVqZWN0UmVxdWVzdGAsXHJcbiAgICAgICAgXSxcclxuICAgICAgfSksXHJcbiAgICAgIGtleXJpbmdDb250cm9sbGVyOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxyXG4gICAgICBnZXRTdGF0ZTogdGhpcy5nZXRTdGF0ZS5iaW5kKHRoaXMpLFxyXG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcclxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlciA9IG5ldyBTaWduYXR1cmVDb250cm9sbGVyKHtcclxuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XHJcbiAgICAgICAgbmFtZTogJ1NpZ25hdHVyZUNvbnRyb2xsZXInLFxyXG4gICAgICAgIGFsbG93ZWRBY3Rpb25zOiBbXHJcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphZGRSZXF1ZXN0YCxcclxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxyXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06cmVqZWN0UmVxdWVzdGAsXHJcbiAgICAgICAgXSxcclxuICAgICAgfSksXHJcbiAgICAgIGtleXJpbmdDb250cm9sbGVyOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxyXG4gICAgICBpc0V0aFNpZ25FbmFibGVkOiAoKSA9PlxyXG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKClcclxuICAgICAgICAgID8uZGlzYWJsZWRScGNNZXRob2RQcmVmZXJlbmNlcz8uZXRoX3NpZ24sXHJcbiAgICAgIGdldEFsbFN0YXRlOiB0aGlzLmdldFN0YXRlLmJpbmQodGhpcyksXHJcbiAgICAgIHNlY3VyaXR5UHJvdmlkZXJSZXF1ZXN0OiB0aGlzLnNlY3VyaXR5UHJvdmlkZXJSZXF1ZXN0LmJpbmQodGhpcyksXHJcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLmh1Yi5vbignY2FuY2VsV2l0aFJlYXNvbicsIChtZXNzYWdlLCByZWFzb24pID0+IHtcclxuICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudCh7XHJcbiAgICAgICAgZXZlbnQ6IHJlYXNvbixcclxuICAgICAgICBjYXRlZ29yeTogTWV0YU1ldHJpY3NFdmVudENhdGVnb3J5LlRyYW5zYWN0aW9ucyxcclxuICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICBhY3Rpb246ICdTaWduIFJlcXVlc3QnLFxyXG4gICAgICAgICAgdHlwZTogbWVzc2FnZS50eXBlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zd2Fwc0NvbnRyb2xsZXIgPSBuZXcgU3dhcHNDb250cm9sbGVyKHtcclxuICAgICAgZ2V0QnVmZmVyZWRHYXNMaW1pdDogdGhpcy50eENvbnRyb2xsZXIudHhHYXNVdGlsLmdldEJ1ZmZlcmVkR2FzTGltaXQuYmluZChcclxuICAgICAgICB0aGlzLnR4Q29udHJvbGxlci50eEdhc1V0aWwsXHJcbiAgICAgICksXHJcbiAgICAgIG5ldHdvcmtDb250cm9sbGVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxyXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKGxpc3RlbmVyKSxcclxuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXHJcbiAgICAgIGdldFByb3ZpZGVyQ29uZmlnOiAoKSA9PlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZyxcclxuICAgICAgZ2V0VG9rZW5SYXRlc1N0YXRlOiAoKSA9PiB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyLnN0YXRlLFxyXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogKCkgPT5cclxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcclxuICAgICAgZ2V0RUlQMTU1OUdhc0ZlZUVzdGltYXRlczpcclxuICAgICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuZmV0Y2hHYXNGZWVFc3RpbWF0ZXMuYmluZCh0aGlzLmdhc0ZlZUNvbnRyb2xsZXIpLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlciA9IG5ldyBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIoXHJcbiAgICAgIHtcclxuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTmV0d29ya1N0YXRlID0ge1xyXG4gICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcclxuICAgICAgICAgICAgICBwcm92aWRlckNvbmZpZzoge1xyXG4gICAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldE5ldHdvcms6ICgpID0+XHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkubmV0d29ya0lkID8/ICdsb2FkaW5nJyxcclxuICAgICAgICBnZXROb25jZUxvY2s6IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2suYmluZChcclxuICAgICAgICAgIHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlcixcclxuICAgICAgICApLFxyXG4gICAgICAgIGNvbmZpcm1FeHRlcm5hbFRyYW5zYWN0aW9uOlxyXG4gICAgICAgICAgdGhpcy50eENvbnRyb2xsZXIuY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb24uYmluZCh0aGlzLnR4Q29udHJvbGxlciksXHJcbiAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXHJcbiAgICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXHJcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgc3VwcG9ydGVkQ2hhaW5JZHM6IFtDSEFJTl9JRFMuTUFJTk5FVCwgQ0hBSU5fSURTLkdPRVJMSV0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGluaXRTdGF0ZS5TbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXHJcbiAgICApO1xyXG5cclxuICAgIC8vIGVuc3VyZSBhY2NvdW50VHJhY2tlciB1cGRhdGVzIGJhbGFuY2VzIGFmdGVyIG5ldHdvcmsgY2hhbmdlXHJcbiAgICBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXHJcbiAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLk5ldHdvcmtEaWRDaGFuZ2UsXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICB0aGlzLmFjY291bnRUcmFja2VyLl91cGRhdGVBY2NvdW50cygpO1xyXG4gICAgICB9LFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBjbGVhciB1bmFwcHJvdmVkIHRyYW5zYWN0aW9ucyBhbmQgbWVzc2FnZXMgd2hlbiB0aGUgbmV0d29yayB3aWxsIGNoYW5nZVxyXG4gICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxyXG4gICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrV2lsbENoYW5nZSxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZFR4cygpO1xyXG4gICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIuY2xlYXJVbmFwcHJvdmVkKCk7XHJcbiAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIuY2xlYXJVbmFwcHJvdmVkKCk7XHJcbiAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLmNsZWFyVW5hcHByb3ZlZCgpO1xyXG4gICAgICB9LFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoaXNNYW5pZmVzdFYzICYmIGdsb2JhbFRoaXMuaXNGaXJzdFRpbWVQcm9maWxlTG9hZGVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgeyBzZXJ2aWNlV29ya2VyTGFzdEFjdGl2ZVRpbWUgfSA9XHJcbiAgICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgY29uc3QgbWV0YW1ldHJpY3NQYXlsb2FkID0ge1xyXG4gICAgICAgIGNhdGVnb3J5OiBNZXRhTWV0cmljc0V2ZW50Q2F0ZWdvcnkuU2VydmljZVdvcmtlcnMsXHJcbiAgICAgICAgZXZlbnQ6IE1ldGFNZXRyaWNzRXZlbnROYW1lLlNlcnZpY2VXb3JrZXJSZXN0YXJ0ZWQsXHJcbiAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgc2VydmljZV93b3JrZXJfcmVzdGFydGVkX3RpbWU6XHJcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBzZXJ2aWNlV29ya2VyTGFzdEFjdGl2ZVRpbWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudChtZXRhbWV0cmljc1BheWxvYWQpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nLndhcm4oJ0ZhaWxlZCB0byB0cmFjayBzZXJ2aWNlIHdvcmtlciByZXN0YXJ0IG1ldHJpYzonLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubWV0YW1hc2tNaWRkbGV3YXJlID0gY3JlYXRlTWV0YW1hc2tNaWRkbGV3YXJlKHtcclxuICAgICAgc3RhdGljOiB7XHJcbiAgICAgICAgZXRoX3N5bmNpbmc6IGZhbHNlLFxyXG4gICAgICAgIHdlYjNfY2xpZW50VmVyc2lvbjogYE1ldGFNYXNrL3Yke3ZlcnNpb259YCxcclxuICAgICAgfSxcclxuICAgICAgdmVyc2lvbixcclxuICAgICAgLy8gYWNjb3VudCBtZ210XHJcbiAgICAgIGdldEFjY291bnRzOiBhc3luYyAoXHJcbiAgICAgICAgeyBvcmlnaW46IGlubmVyT3JpZ2luIH0sXHJcbiAgICAgICAgeyBzdXBwcmVzc1VuYXV0aG9yaXplZEVycm9yID0gdHJ1ZSB9ID0ge30sXHJcbiAgICAgICkgPT4ge1xyXG4gICAgICAgIGlmIChpbm5lck9yaWdpbiA9PT0gT1JJR0lOX01FVEFNQVNLKSB7XHJcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPVxyXG4gICAgICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRTZWxlY3RlZEFkZHJlc3MoKTtcclxuICAgICAgICAgIHJldHVybiBzZWxlY3RlZEFkZHJlc3MgPyBbc2VsZWN0ZWRBZGRyZXNzXSA6IFtdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzKGlubmVyT3JpZ2luLCB7XHJcbiAgICAgICAgICAgIHN1cHByZXNzVW5hdXRob3JpemVkRXJyb3IsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdOyAvLyBjaGFuZ2luZyB0aGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIHR4IHNpZ25pbmdcclxuICAgICAgcHJvY2Vzc1RyYW5zYWN0aW9uOiB0aGlzLm5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAvLyBtc2cgc2lnbmluZ1xyXG4gICAgICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2U6IHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5uZXdVbnNpZ25lZE1lc3NhZ2UuYmluZChcclxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHByb2Nlc3NUeXBlZE1lc3NhZ2U6XHJcbiAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLm5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzOlxyXG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5uZXdVbnNpZ25lZFR5cGVkTWVzc2FnZS5iaW5kKFxyXG4gICAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIHByb2Nlc3NUeXBlZE1lc3NhZ2VWNDpcclxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIubmV3VW5zaWduZWRUeXBlZE1lc3NhZ2UuYmluZChcclxuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBwcm9jZXNzUGVyc29uYWxNZXNzYWdlOlxyXG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5uZXdVbnNpZ25lZFBlcnNvbmFsTWVzc2FnZS5iaW5kKFxyXG4gICAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5OlxyXG4gICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIubmV3UmVxdWVzdEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZChcclxuICAgICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlOlxyXG4gICAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyLm5ld1JlcXVlc3REZWNyeXB0TWVzc2FnZS5iaW5kKFxyXG4gICAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgZ2V0UGVuZGluZ05vbmNlOiB0aGlzLmdldFBlbmRpbmdOb25jZS5iaW5kKHRoaXMpLFxyXG4gICAgICBnZXRQZW5kaW5nVHJhbnNhY3Rpb25CeUhhc2g6IChoYXNoKSA9PlxyXG4gICAgICAgIHRoaXMudHhDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucyh7XHJcbiAgICAgICAgICBzZWFyY2hDcml0ZXJpYToge1xyXG4gICAgICAgICAgICBoYXNoLFxyXG4gICAgICAgICAgICBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSlbMF0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBlbnN1cmUgaXNDbGllbnRPcGVuQW5kVW5sb2NrZWQgaXMgdXBkYXRlZCB3aGVuIG1lbVN0YXRlIHVwZGF0ZXNcclxuICAgIHRoaXMub24oJ3VwZGF0ZScsIChtZW1TdGF0ZSkgPT4gdGhpcy5fb25TdGF0ZVVwZGF0ZShtZW1TdGF0ZSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGNvbnRyb2xsZXJzIGluIE1lbXN0b3JlIGJ1dCBub3QgaW4gc3RvcmUuIFRoZXkgYXJlIG5vdCBwZXJzaXN0ZWQuXHJcbiAgICAgKiBPbiBjaHJvbWUgcHJvZmlsZSByZS1zdGFydCwgdGhleSB3aWxsIGJlIHJlLWluaXRpYWxpemVkLlxyXG4gICAgICovXHJcbiAgICBjb25zdCByZXNldE9uUmVzdGFydFN0b3JlID0ge1xyXG4gICAgICBBY2NvdW50VHJhY2tlcjogdGhpcy5hY2NvdW50VHJhY2tlci5zdG9yZSxcclxuICAgICAgVHhDb250cm9sbGVyOiB0aGlzLnR4Q29udHJvbGxlci5tZW1TdG9yZSxcclxuICAgICAgVG9rZW5SYXRlc0NvbnRyb2xsZXI6IHRoaXMudG9rZW5SYXRlc0NvbnRyb2xsZXIsXHJcbiAgICAgIERlY3J5cHRNZXNzYWdlQ29udHJvbGxlcjogdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIsXHJcbiAgICAgIEVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyOiB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLFxyXG4gICAgICBTaWduYXR1cmVDb250cm9sbGVyOiB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXHJcbiAgICAgIFN3YXBzQ29udHJvbGxlcjogdGhpcy5zd2Fwc0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgIEVuc0NvbnRyb2xsZXI6IHRoaXMuZW5zQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgQXBwcm92YWxDb250cm9sbGVyOiB0aGlzLmFwcHJvdmFsQ29udHJvbGxlcixcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdHJ1Y3R1cmUoe1xyXG4gICAgICBBcHBTdGF0ZUNvbnRyb2xsZXI6IHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBUcmFuc2FjdGlvbkNvbnRyb2xsZXI6IHRoaXMudHhDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBLZXlyaW5nQ29udHJvbGxlcjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgTWV0YU1ldHJpY3NDb250cm9sbGVyOiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgQWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcclxuICAgICAgQ3VycmVuY3lDb250cm9sbGVyOiB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXHJcbiAgICAgIE5ldHdvcmtDb250cm9sbGVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXI6IHRoaXMuY2FjaGVkQmFsYW5jZXNDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBBbGVydENvbnRyb2xsZXI6IHRoaXMuYWxlcnRDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBXZWIzQXV0aENvbnRyb2xsZXI6IHRoaXMud2ViM0F1dGhDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBPbmJvYXJkaW5nQ29udHJvbGxlcjogdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyOiB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgUGVybWlzc2lvbkNvbnRyb2xsZXI6IHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXHJcbiAgICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB0aGlzLnBlcm1pc3Npb25Mb2dDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyOiB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXHJcbiAgICAgIEJhY2t1cENvbnRyb2xsZXI6IHRoaXMuYmFja3VwQ29udHJvbGxlcixcclxuICAgICAgQW5ub3VuY2VtZW50Q29udHJvbGxlcjogdGhpcy5hbm5vdW5jZW1lbnRDb250cm9sbGVyLFxyXG4gICAgICBHYXNGZWVDb250cm9sbGVyOiB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIsXHJcbiAgICAgIFRva2VuTGlzdENvbnRyb2xsZXI6IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlcixcclxuICAgICAgVG9rZW5zQ29udHJvbGxlcjogdGhpcy50b2tlbnNDb250cm9sbGVyLFxyXG4gICAgICBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXI6IHRoaXMuc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxyXG4gICAgICBOZnRDb250cm9sbGVyOiB0aGlzLm5mdENvbnRyb2xsZXIsXHJcbiAgICAgIFBoaXNoaW5nQ29udHJvbGxlcjogdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIsXHJcblxuXG4gICAgICAuLi5yZXNldE9uUmVzdGFydFN0b3JlLFxyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMubWVtU3RvcmUgPSBuZXcgQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSh7XHJcbiAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgIEFwcFN0YXRlQ29udHJvbGxlcjogdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICAgTmV0d29ya0NvbnRyb2xsZXI6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICAgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyOiB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgICBLZXlyaW5nQ29udHJvbGxlcjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZSxcclxuICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICAgIE1ldGFNZXRyaWNzQ29udHJvbGxlcjogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICAgQWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcclxuICAgICAgICBDdXJyZW5jeUNvbnRyb2xsZXI6IHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlcixcclxuICAgICAgICBBbGVydENvbnRyb2xsZXI6IHRoaXMuYWxlcnRDb250cm9sbGVyLnN0b3JlLFxyXG4gICAgICAgIFdlYjNBdXRoQ29udHJvbGxlcjogdGhpcy53ZWIzQXV0aENvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICAgT25ib2FyZGluZ0NvbnRyb2xsZXI6IHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICAgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyOlxyXG4gICAgICAgICAgdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICAgUGVybWlzc2lvbkNvbnRyb2xsZXI6IHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXHJcbiAgICAgICAgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXI6IHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIuc3RvcmUsXHJcbiAgICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxyXG4gICAgICAgIEJhY2t1cENvbnRyb2xsZXI6IHRoaXMuYmFja3VwQ29udHJvbGxlcixcclxuICAgICAgICBBbm5vdW5jZW1lbnRDb250cm9sbGVyOiB0aGlzLmFubm91bmNlbWVudENvbnRyb2xsZXIsXHJcbiAgICAgICAgR2FzRmVlQ29udHJvbGxlcjogdGhpcy5nYXNGZWVDb250cm9sbGVyLFxyXG4gICAgICAgIFRva2VuTGlzdENvbnRyb2xsZXI6IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlcixcclxuICAgICAgICBUb2tlbnNDb250cm9sbGVyOiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIsXHJcbiAgICAgICAgU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyOiB0aGlzLnNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcclxuICAgICAgICBOZnRDb250cm9sbGVyOiB0aGlzLm5mdENvbnRyb2xsZXIsXHJcblxuXG4gICAgICAgIC4uLnJlc2V0T25SZXN0YXJ0U3RvcmUsXHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbnRyb2xsZXJNZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3NlbmdlcixcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUsIGNsZWFyIHRoZSBzdGF0ZSBvZiBieSBjYWxsaW5nIHRoZXNlIG1ldGhvZHNcclxuICAgIGNvbnN0IHJlc2V0TWV0aG9kcyA9IFtcclxuICAgICAgdGhpcy5hY2NvdW50VHJhY2tlci5yZXNldFN0YXRlLFxyXG4gICAgICB0aGlzLnR4Q29udHJvbGxlci5yZXNldFN0YXRlLFxyXG4gICAgICB0aGlzLmRlY3J5cHRNZXNzYWdlQ29udHJvbGxlci5yZXNldFN0YXRlLmJpbmQoXHJcbiAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIucmVzZXRTdGF0ZS5iaW5kKFxyXG4gICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5yZXNldFN0YXRlLmJpbmQodGhpcy5zaWduYXR1cmVDb250cm9sbGVyKSxcclxuICAgICAgdGhpcy5zd2Fwc0NvbnRyb2xsZXIucmVzZXRTdGF0ZSxcclxuICAgICAgdGhpcy5lbnNDb250cm9sbGVyLnJlc2V0U3RhdGUsXHJcbiAgICAgIHRoaXMuYXBwcm92YWxDb250cm9sbGVyLmNsZWFyLmJpbmQodGhpcy5hcHByb3ZhbENvbnRyb2xsZXIpLFxyXG4gICAgICAvLyBXRSBTSE9VTEQgQUREIFRva2VuTGlzdENvbnRyb2xsZXIucmVzZXRTdGF0ZSBoZXJlIHRvby4gQnV0IGl0J3Mgbm90IGltcGxlbWVudGVkIHlldC5cclxuICAgIF07XHJcblxyXG4gICAgaWYgKGlzTWFuaWZlc3RWMykge1xyXG4gICAgICBpZiAoaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldFN0YXRlcyhyZXNldE1ldGhvZHMpO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uLnN0b3JhZ2Uuc2Vzc2lvbi5zZXQoe1xyXG4gICAgICAgICAgaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaXQncyBhbHdheXMgdGhlIGZpcnN0IHRpbWUgaW4gTVYyXHJcbiAgICAgIHRoaXMucmVzZXRTdGF0ZXMocmVzZXRNZXRob2RzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBdXRvbWF0aWMgbG9naW4gdmlhIGNvbmZpZyBwYXNzd29yZCBvciBsb2dpblRva2VuXHJcbiAgICBpZiAoXHJcbiAgICAgICF0aGlzLmlzVW5sb2NrZWQoKSAmJlxyXG4gICAgICB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkuY29tcGxldGVkT25ib2FyZGluZ1xyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuX2xvZ2luVXNlcigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fc3RhcnRVSVN5bmMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMYXppbHkgdXBkYXRlIHRoZSBzdG9yZSB3aXRoIHRoZSBjdXJyZW50IGV4dGVuc2lvbiBlbnZpcm9ubWVudFxyXG4gICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5nZXRQbGF0Zm9ybUluZm8oKS50aGVuKCh7IG9zIH0pID0+IHtcclxuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc2V0QnJvd3NlckVudmlyb25tZW50KFxyXG4gICAgICAgIG9zLFxyXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHByZXNlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBGaXJlZm94XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5nZXRCcm93c2VySW5mbyA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICA/ICdjaHJvbWUnXHJcbiAgICAgICAgICA6ICdmaXJlZm94JyxcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc2V0dXBDb250cm9sbGVyRXZlbnRTdWJzY3JpcHRpb25zKCk7XHJcblxyXG4gICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlc2UgbGVnYWN5IHN0cmVhbXMsIHNlZSBoZXJlOlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9pc3N1ZXMvMTU0OTFcclxuICAgIC8vIFRPRE86TGVnYWN5UHJvdmlkZXI6IERlbGV0ZVxyXG4gICAgdGhpcy5wdWJsaWNDb25maWdTdG9yZSA9IHRoaXMuY3JlYXRlUHVibGljQ29uZmlnU3RvcmUoKTtcclxuXHJcbiAgICAvLyBNdWx0aXBsZSBNZXRhTWFzayBpbnN0YW5jZXMgbGF1bmNoZWQgd2FybmluZ1xyXG4gICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5vbk1lc3NhZ2VFeHRlcm5hbC5hZGRMaXN0ZW5lcihvbk1lc3NhZ2VSZWNlaXZlZCk7XHJcbiAgICAvLyBGaXJlIGEgcGluZyBtZXNzYWdlIHRvIGNoZWNrIGlmIG90aGVyIGV4dGVuc2lvbnMgYXJlIHJ1bm5pbmdcclxuICAgIGNoZWNrRm9yTXVsdGlwbGVWZXJzaW9uc1J1bm5pbmcoKTtcclxuICB9XHJcblxyXG4gIHRyaWdnZXJOZXR3b3JrcmVxdWVzdHMoKSB7XHJcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnN0YXJ0KCk7XHJcbiAgICB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdGFydCgpO1xyXG4gICAgaWYgKHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkudXNlQ3VycmVuY3lSYXRlQ2hlY2spIHtcclxuICAgICAgdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLnN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS51c2VUb2tlbkRldGVjdGlvbikge1xyXG4gICAgICB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RhcnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0b3BOZXR3b3JrUmVxdWVzdHMoKSB7XHJcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnN0b3AoKTtcclxuICAgIHRoaXMuaW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLnN0b3AoKTtcclxuICAgIGlmICh0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnVzZUN1cnJlbmN5UmF0ZUNoZWNrKSB7XHJcbiAgICAgIHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlci5zdG9wKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS51c2VUb2tlbkRldGVjdGlvbikge1xyXG4gICAgICB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2FuVXNlSGFyZHdhcmVXYWxsZXRzKCkge1xyXG4gICAgcmV0dXJuICFpc01hbmlmZXN0VjMgfHwgcHJvY2Vzcy5lbnYuSEFSRFdBUkVfV0FMTEVUU19NVjM7XHJcbiAgfVxyXG5cclxuICByZXNldFN0YXRlcyhyZXNldE1ldGhvZHMpIHtcclxuICAgIHJlc2V0TWV0aG9kcy5mb3JFYWNoKChyZXNldE1ldGhvZCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJlc2V0TWV0aG9kKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuXG5cclxuICAvKipcclxuICAgKiBTZXRzIHVwIEJhc2VDb250cm9sbGVyIFYyIGV2ZW50IHN1YnNjcmlwdGlvbnMuIEN1cnJlbnRseSwgdGhpcyBpbmNsdWRlc1xyXG4gICAqIHRoZSBzdWJzY3JpcHRpb25zIG5lY2Vzc2FyeSB0byBub3RpZnkgcGVybWlzc2lvbiBzdWJqZWN0cyBvZiBhY2NvdW50XHJcbiAgICogY2hhbmdlcy5cclxuICAgKlxyXG4gICAqIFNvbWUgb2YgdGhlIHN1YnNjcmlwdGlvbnMgaW4gdGhpcyBtZXRob2QgYXJlIENvbnRyb2xsZXJNZXNzZW5nZXIgc2VsZWN0b3JcclxuICAgKiBldmVudCBzdWJzY3JpcHRpb25zLiBTZWUgdGhlIHJlbGV2YW50IGRvY3VtZW50YXRpb24gZm9yXHJcbiAgICogYEBtZXRhbWFzay9iYXNlLWNvbnRyb2xsZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGFjY291bnQtcmVsYXRlZCBub3RpZmljYXRpb25zIGVtaXR0ZWQgd2hlbiB0aGUgZXh0ZW5zaW9uXHJcbiAgICogYmVjb21lcyB1bmxvY2tlZCBhcmUgaGFuZGxlZCBpbiBNZXRhTWFza0NvbnRyb2xsZXIuX29uVW5sb2NrLlxyXG4gICAqL1xyXG4gIHNldHVwQ29udHJvbGxlckV2ZW50U3Vic2NyaXB0aW9ucygpIHtcclxuICAgIGNvbnN0IGhhbmRsZUFjY291bnRzQ2hhbmdlID0gYXN5bmMgKG9yaWdpbiwgbmV3QWNjb3VudHMpID0+IHtcclxuICAgICAgaWYgKHRoaXMuaXNVbmxvY2tlZCgpKSB7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlDb25uZWN0aW9ucyhvcmlnaW4sIHtcclxuICAgICAgICAgIG1ldGhvZDogTk9USUZJQ0FUSU9OX05BTUVTLmFjY291bnRzQ2hhbmdlZCxcclxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSByZXR1cm4gdmFsdWUgb2YgYGV0aF9hY2NvdW50c2AsXHJcbiAgICAgICAgICAvLyBuYW1lbHkgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgLyBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIEV0aGVyZXVtXHJcbiAgICAgICAgICAvLyBhY2NvdW50LlxyXG4gICAgICAgICAgcGFyYW1zOlxyXG4gICAgICAgICAgICBuZXdBY2NvdW50cy5sZW5ndGggPCAyXHJcbiAgICAgICAgICAgICAgPyAvLyBJZiB0aGUgbGVuZ3RoIGlzIDEgb3IgMCwgdGhlIGFjY291bnRzIGFyZSBzb3J0ZWQgYnkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICAgIG5ld0FjY291bnRzXHJcbiAgICAgICAgICAgICAgOiAvLyBJZiB0aGUgbGVuZ3RoIGlzIDIgb3IgZ3JlYXRlciwgd2UgaGF2ZSB0byBleGVjdXRlXHJcbiAgICAgICAgICAgICAgICAvLyBgZXRoX2FjY291bnRzYCB2aSB0aGlzIG1ldGhvZC5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci51cGRhdGVBY2NvdW50c0hpc3Rvcnkob3JpZ2luLCBuZXdBY2NvdW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoaXMgaGFuZGxlcyBhY2NvdW50IGNoYW5nZXMgd2hlbmV2ZXIgdGhlIHNlbGVjdGVkIGFkZHJlc3MgY2hhbmdlcy5cclxuICAgIGxldCBsYXN0U2VsZWN0ZWRBZGRyZXNzO1xyXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKGFzeW5jICh7IHNlbGVjdGVkQWRkcmVzcyB9KSA9PiB7XHJcbiAgICAgIGlmIChzZWxlY3RlZEFkZHJlc3MgJiYgc2VsZWN0ZWRBZGRyZXNzICE9PSBsYXN0U2VsZWN0ZWRBZGRyZXNzKSB7XHJcbiAgICAgICAgbGFzdFNlbGVjdGVkQWRkcmVzcyA9IHNlbGVjdGVkQWRkcmVzcztcclxuICAgICAgICBjb25zdCBwZXJtaXR0ZWRBY2NvdW50c01hcCA9IGdldFBlcm1pdHRlZEFjY291bnRzQnlPcmlnaW4oXHJcbiAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnN0YXRlLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgW29yaWdpbiwgYWNjb3VudHNdIG9mIHBlcm1pdHRlZEFjY291bnRzTWFwLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgaWYgKGFjY291bnRzLmluY2x1ZGVzKHNlbGVjdGVkQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgaGFuZGxlQWNjb3VudHNDaGFuZ2Uob3JpZ2luLCBhY2NvdW50cyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUaGlzIGhhbmRsZXMgYWNjb3VudCBjaGFuZ2VzIGV2ZXJ5IHRpbWUgcmVsZXZhbnQgcGVybWlzc2lvbiBzdGF0ZVxyXG4gICAgLy8gY2hhbmdlcywgZm9yIGFueSByZWFzb24uXHJcbiAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxyXG4gICAgICBgJHt0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLm5hbWV9OnN0YXRlQ2hhbmdlYCxcclxuICAgICAgYXN5bmMgKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRBY2NvdW50cyA9IGdldENoYW5nZWRBY2NvdW50cyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtvcmlnaW4sIGFjY291bnRzXSBvZiBjaGFuZ2VkQWNjb3VudHMuZW50cmllcygpKSB7XHJcbiAgICAgICAgICBoYW5kbGVBY2NvdW50c0NoYW5nZShvcmlnaW4sIGFjY291bnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldFBlcm1pdHRlZEFjY291bnRzQnlPcmlnaW4sXHJcbiAgICApO1xyXG5cclxuXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXHJcbiAgICogQ29uc3RydWN0b3IgaGVscGVyOiBpbml0aWFsaXplIGEgcHVibGljIGNvbmZpZyBzdG9yZS5cclxuICAgKiBUaGlzIHN0b3JlIGlzIHVzZWQgdG8gbWFrZSBzb21lIGNvbmZpZyBpbmZvIGF2YWlsYWJsZSB0byBEYXBwcyBzeW5jaHJvbm91c2x5LlxyXG4gICAqL1xyXG4gIGNyZWF0ZVB1YmxpY0NvbmZpZ1N0b3JlKCkge1xyXG4gICAgLy8gc3Vic2V0IG9mIHN0YXRlIGZvciBtZXRhbWFzayBpbnBhZ2UgcHJvdmlkZXJcclxuICAgIGNvbnN0IHB1YmxpY0NvbmZpZ1N0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSgpO1xyXG4gICAgY29uc3QgeyBuZXR3b3JrQ29udHJvbGxlciB9ID0gdGhpcztcclxuXHJcbiAgICAvLyBzZXR1cCBtZW1TdG9yZSBzdWJzY3JpcHRpb24gaG9va3NcclxuICAgIHRoaXMub24oJ3VwZGF0ZScsIHVwZGF0ZVB1YmxpY0NvbmZpZ1N0b3JlKTtcclxuICAgIHVwZGF0ZVB1YmxpY0NvbmZpZ1N0b3JlKHRoaXMuZ2V0U3RhdGUoKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlUHVibGljQ29uZmlnU3RvcmUobWVtU3RhdGUpIHtcclxuICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSBuZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnO1xyXG4gICAgICBpZiAobWVtU3RhdGUubmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5BdmFpbGFibGUpIHtcclxuICAgICAgICBwdWJsaWNDb25maWdTdG9yZS5wdXRTdGF0ZShzZWxlY3RQdWJsaWNTdGF0ZShjaGFpbklkLCBtZW1TdGF0ZSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2VsZWN0UHVibGljU3RhdGUoY2hhaW5JZCwgeyBpc1VubG9ja2VkLCBuZXR3b3JrSWQgfSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzVW5sb2NrZWQsXHJcbiAgICAgICAgY2hhaW5JZCxcclxuICAgICAgICBuZXR3b3JrVmVyc2lvbjogbmV0d29ya0lkID8/ICdsb2FkaW5nJyxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHVibGljQ29uZmlnU3RvcmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHJlbGV2YW50IHN0YXRlIGZvciB0aGUgcHJvdmlkZXIgb2YgYW4gZXh0ZXJuYWwgb3JpZ2luLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gZ2V0IHRoZSBwcm92aWRlciBzdGF0ZSBmb3IuXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBpc1VubG9ja2VkOiBib29sZWFuLCBuZXR3b3JrVmVyc2lvbjogc3RyaW5nLCBjaGFpbklkOiBzdHJpbmcsIGFjY291bnRzOiBzdHJpbmdbXSB9Pn0gQW4gb2JqZWN0IHdpdGggcmVsZXZhbnQgc3RhdGUgcHJvcGVydGllcy5cclxuICAgKi9cclxuICBhc3luYyBnZXRQcm92aWRlclN0YXRlKG9yaWdpbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNVbmxvY2tlZDogdGhpcy5pc1VubG9ja2VkKCksXHJcbiAgICAgIC4uLnRoaXMuZ2V0UHJvdmlkZXJOZXR3b3JrU3RhdGUoKSxcclxuICAgICAgYWNjb3VudHM6IGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIG5ldHdvcmsgc3RhdGUgcmVsZXZhbnQgZm9yIGV4dGVybmFsIHByb3ZpZGVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbbWVtU3RhdGVdIC0gVGhlIE1ldGFNYXNrIG1lbVN0YXRlLiBJZiBub3QgcHJvdmlkZWQsXHJcbiAgICogdGhpcyBmdW5jdGlvbiB3aWxsIHJldHJpZXZlIHRoZSBtb3N0IHJlY2VudCBzdGF0ZS5cclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxldmFudCBuZXR3b3JrIHN0YXRlIHByb3BlcnRpZXMuXHJcbiAgICovXHJcbiAgZ2V0UHJvdmlkZXJOZXR3b3JrU3RhdGUobWVtU3RhdGUpIHtcclxuICAgIGNvbnN0IHsgbmV0d29ya0lkIH0gPSBtZW1TdGF0ZSB8fCB0aGlzLmdldFN0YXRlKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcclxuICAgICAgbmV0d29ya1ZlcnNpb246IG5ldHdvcmtJZCA/PyAnbG9hZGluZycsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIEVYUE9TRUQgVE8gVEhFIFVJIFNVQlNZU1RFTVxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1ldGFtYXNrLXN0YXRlIG9mIHRoZSB2YXJpb3VzIGNvbnRyb2xsZXJzLCBtYWRlIGF2YWlsYWJsZSB0byB0aGUgVUlcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHN0YXR1c1xyXG4gICAqL1xyXG4gIGdldFN0YXRlKCkge1xyXG4gICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IEJvb2xlYW4odmF1bHQpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzSW5pdGlhbGl6ZWQsXHJcbiAgICAgIC4uLnRoaXMubWVtU3RvcmUuZ2V0RmxhdFN0YXRlKCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBPYmplY3QgY29udGFpbmluZyBBUEkgQ2FsbGJhY2sgRnVuY3Rpb25zLlxyXG4gICAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdGhlIGludGVyZmFjZSBmb3IgdGhlIFVJLlxyXG4gICAqIFRoZSBBUEkgb2JqZWN0IGNhbiBiZSB0cmFuc21pdHRlZCBvdmVyIGEgc3RyZWFtIHZpYSBKU09OLVJQQy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIEFQSSBmdW5jdGlvbnMuXHJcbiAgICovXHJcbiAgZ2V0QXBpKCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBhZGRyZXNzQm9va0NvbnRyb2xsZXIsXHJcbiAgICAgIGFsZXJ0Q29udHJvbGxlcixcclxuICAgICAgd2ViM0F1dGhDb250cm9sbGVyLFxyXG4gICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXHJcbiAgICAgIG5mdENvbnRyb2xsZXIsXHJcbiAgICAgIG5mdERldGVjdGlvbkNvbnRyb2xsZXIsXHJcbiAgICAgIGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXHJcbiAgICAgIGRldGVjdFRva2Vuc0NvbnRyb2xsZXIsXHJcbiAgICAgIGVuc0NvbnRyb2xsZXIsXHJcbiAgICAgIGdhc0ZlZUNvbnRyb2xsZXIsXHJcbiAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgbmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgICAgIGFubm91bmNlbWVudENvbnRyb2xsZXIsXHJcbiAgICAgIG9uYm9hcmRpbmdDb250cm9sbGVyLFxyXG4gICAgICBwZXJtaXNzaW9uQ29udHJvbGxlcixcclxuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICBxckhhcmR3YXJlS2V5cmluZyxcclxuICAgICAgc3dhcHNDb250cm9sbGVyLFxyXG4gICAgICB0b2tlbnNDb250cm9sbGVyLFxyXG4gICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXHJcbiAgICAgIHR4Q29udHJvbGxlcixcclxuICAgICAgYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxyXG4gICAgICBiYWNrdXBDb250cm9sbGVyLFxyXG4gICAgICBhcHByb3ZhbENvbnRyb2xsZXIsXHJcbiAgICB9ID0gdGhpcztcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBldGNcclxuICAgICAgZ2V0U3RhdGU6IHRoaXMuZ2V0U3RhdGUuYmluZCh0aGlzKSxcclxuICAgICAgc2V0Q3VycmVudEN1cnJlbmN5OiBjdXJyZW5jeVJhdGVDb250cm9sbGVyLnNldEN1cnJlbnRDdXJyZW5jeS5iaW5kKFxyXG4gICAgICAgIGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHNldFVzZUJsb2NraWU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VCbG9ja2llLmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBzZXRVc2VOb25jZUZpZWxkOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VXNlTm9uY2VGaWVsZC5iaW5kKFxyXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgc2V0VXNlUGhpc2hEZXRlY3Q6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VQaGlzaERldGVjdC5iaW5kKFxyXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgc2V0VXNlTXVsdGlBY2NvdW50QmFsYW5jZUNoZWNrZXI6XHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZU11bHRpQWNjb3VudEJhbGFuY2VDaGVja2VyLmJpbmQoXHJcbiAgICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgc2V0VXNlVG9rZW5EZXRlY3Rpb246IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VUb2tlbkRldGVjdGlvbi5iaW5kKFxyXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgc2V0VXNlTmZ0RGV0ZWN0aW9uOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VXNlTmZ0RGV0ZWN0aW9uLmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBzZXRVc2VDdXJyZW5jeVJhdGVDaGVjazpcclxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VXNlQ3VycmVuY3lSYXRlQ2hlY2suYmluZChcclxuICAgICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBzZXRPcGVuU2VhRW5hYmxlZDogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldE9wZW5TZWFFbmFibGVkLmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBzZXRJcGZzR2F0ZXdheTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldElwZnNHYXRld2F5LmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBzZXRQYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M6XHJcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLnNldFBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcy5iaW5kKFxyXG4gICAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIHNldEN1cnJlbnRMb2NhbGU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRDdXJyZW50TG9jYWxlLmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBtYXJrUGFzc3dvcmRGb3Jnb3R0ZW46IHRoaXMubWFya1Bhc3N3b3JkRm9yZ290dGVuLmJpbmQodGhpcyksXHJcbiAgICAgIHVuTWFya1Bhc3N3b3JkRm9yZ290dGVuOiB0aGlzLnVuTWFya1Bhc3N3b3JkRm9yZ290dGVuLmJpbmQodGhpcyksXHJcbiAgICAgIGdldFJlcXVlc3RBY2NvdW50VGFiSWRzOiB0aGlzLmdldFJlcXVlc3RBY2NvdW50VGFiSWRzLFxyXG4gICAgICBnZXRPcGVuTWV0YW1hc2tUYWJzSWRzOiB0aGlzLmdldE9wZW5NZXRhbWFza1RhYnNJZHMsXHJcbiAgICAgIG1hcmtOb3RpZmljYXRpb25Qb3B1cEFzQXV0b21hdGljYWxseUNsb3NlZDogKCkgPT5cclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIubWFya0FzQXV0b21hdGljYWxseUNsb3NlZCgpLFxyXG5cclxuICAgICAgLy8gYXBwcm92YWxcclxuICAgICAgcmVxdWVzdFVzZXJBcHByb3ZhbDpcclxuICAgICAgICBhcHByb3ZhbENvbnRyb2xsZXIuYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdC5iaW5kKGFwcHJvdmFsQ29udHJvbGxlciksXHJcblxyXG4gICAgICAvLyBwcmltYXJ5IEhEIGtleXJpbmcgbWFuYWdlbWVudFxyXG4gICAgICBhZGROZXdBY2NvdW50OiB0aGlzLmFkZE5ld0FjY291bnQuYmluZCh0aGlzKSxcclxuICAgICAgdmVyaWZ5U2VlZFBocmFzZTogdGhpcy52ZXJpZnlTZWVkUGhyYXNlLmJpbmQodGhpcyksXHJcbiAgICAgIHJlc2V0QWNjb3VudDogdGhpcy5yZXNldEFjY291bnQuYmluZCh0aGlzKSxcclxuICAgICAgcmVtb3ZlQWNjb3VudDogdGhpcy5yZW1vdmVBY2NvdW50LmJpbmQodGhpcyksXHJcbiAgICAgIGltcG9ydEFjY291bnRXaXRoU3RyYXRlZ3k6IHRoaXMuaW1wb3J0QWNjb3VudFdpdGhTdHJhdGVneS5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgLy8gaGFyZHdhcmUgd2FsbGV0c1xyXG4gICAgICBjb25uZWN0SGFyZHdhcmU6IHRoaXMuY29ubmVjdEhhcmR3YXJlLmJpbmQodGhpcyksXHJcbiAgICAgIGZvcmdldERldmljZTogdGhpcy5mb3JnZXREZXZpY2UuYmluZCh0aGlzKSxcclxuICAgICAgY2hlY2tIYXJkd2FyZVN0YXR1czogdGhpcy5jaGVja0hhcmR3YXJlU3RhdHVzLmJpbmQodGhpcyksXHJcbiAgICAgIHVubG9ja0hhcmR3YXJlV2FsbGV0QWNjb3VudDogdGhpcy51bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQuYmluZCh0aGlzKSxcclxuICAgICAgc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZTpcclxuICAgICAgICB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UuYmluZCh0aGlzKSxcclxuICAgICAgYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uOlxyXG4gICAgICAgIHRoaXMuYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uLmJpbmQodGhpcyksXHJcbiAgICAgIGVzdGFibGlzaExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2U6XHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlLmJpbmQodGhpcyksXHJcblxyXG4gICAgICAvLyBxciBoYXJkd2FyZSBkZXZpY2VzXHJcbiAgICAgIHN1Ym1pdFFSSGFyZHdhcmVDcnlwdG9IREtleTpcclxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZy5zdWJtaXRDcnlwdG9IREtleS5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcclxuICAgICAgc3VibWl0UVJIYXJkd2FyZUNyeXB0b0FjY291bnQ6XHJcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuc3VibWl0Q3J5cHRvQWNjb3VudC5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcclxuICAgICAgY2FuY2VsU3luY1FSSGFyZHdhcmU6XHJcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuY2FuY2VsU3luYy5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcclxuICAgICAgc3VibWl0UVJIYXJkd2FyZVNpZ25hdHVyZTpcclxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZy5zdWJtaXRTaWduYXR1cmUuYmluZChxckhhcmR3YXJlS2V5cmluZyksXHJcbiAgICAgIGNhbmNlbFFSSGFyZHdhcmVTaWduUmVxdWVzdDpcclxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZy5jYW5jZWxTaWduUmVxdWVzdC5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcclxuXHJcbiAgICAgIC8vIHZhdWx0IG1hbmFnZW1lbnRcclxuICAgICAgc3VibWl0UGFzc3dvcmQ6IHRoaXMuc3VibWl0UGFzc3dvcmQuYmluZCh0aGlzKSxcclxuICAgICAgdmVyaWZ5UGFzc3dvcmQ6IHRoaXMudmVyaWZ5UGFzc3dvcmQuYmluZCh0aGlzKSxcclxuXHJcbiAgICAgIC8vIG5ldHdvcmsgbWFuYWdlbWVudFxyXG4gICAgICBzZXRQcm92aWRlclR5cGU6XHJcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXIuc2V0UHJvdmlkZXJUeXBlLmJpbmQobmV0d29ya0NvbnRyb2xsZXIpLFxyXG4gICAgICByb2xsYmFja1RvUHJldmlvdXNQcm92aWRlcjpcclxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlci5yb2xsYmFja1RvUHJldmlvdXNQcm92aWRlci5iaW5kKG5ldHdvcmtDb250cm9sbGVyKSxcclxuICAgICAgcmVtb3ZlTmV0d29ya0NvbmZpZ3VyYXRpb246XHJcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXIucmVtb3ZlTmV0d29ya0NvbmZpZ3VyYXRpb24uYmluZChuZXR3b3JrQ29udHJvbGxlciksXHJcbiAgICAgIHNldEFjdGl2ZU5ldHdvcms6XHJcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXIuc2V0QWN0aXZlTmV0d29yay5iaW5kKG5ldHdvcmtDb250cm9sbGVyKSxcclxuICAgICAgdXBzZXJ0TmV0d29ya0NvbmZpZ3VyYXRpb246XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci51cHNlcnROZXR3b3JrQ29uZmlndXJhdGlvbi5iaW5kKFxyXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBnZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5OlxyXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcclxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgLy8gUHJlZmVyZW5jZXNDb250cm9sbGVyXHJcbiAgICAgIHNldFNlbGVjdGVkQWRkcmVzczogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFNlbGVjdGVkQWRkcmVzcy5iaW5kKFxyXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgYWRkVG9rZW46IHRva2Vuc0NvbnRyb2xsZXIuYWRkVG9rZW4uYmluZCh0b2tlbnNDb250cm9sbGVyKSxcclxuICAgICAgcmVqZWN0V2F0Y2hBc3NldDpcclxuICAgICAgICB0b2tlbnNDb250cm9sbGVyLnJlamVjdFdhdGNoQXNzZXQuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcclxuICAgICAgYWNjZXB0V2F0Y2hBc3NldDpcclxuICAgICAgICB0b2tlbnNDb250cm9sbGVyLmFjY2VwdFdhdGNoQXNzZXQuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcclxuICAgICAgdXBkYXRlVG9rZW5UeXBlOiB0b2tlbnNDb250cm9sbGVyLnVwZGF0ZVRva2VuVHlwZS5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRBY2NvdW50TGFiZWw6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBY2NvdW50TGFiZWwuYmluZChcclxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHNldEZlYXR1cmVGbGFnOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0RmVhdHVyZUZsYWcuYmluZChcclxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHNldFByZWZlcmVuY2U6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRQcmVmZXJlbmNlLmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG5cclxuICAgICAgYWRkS25vd25NZXRob2REYXRhOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkS25vd25NZXRob2REYXRhLmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBzZXREaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyOlxyXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXREaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyLmJpbmQoXHJcbiAgICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgc2V0RGlzYWJsZWRScGNNZXRob2RQcmVmZXJlbmNlOlxyXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXREaXNhYmxlZFJwY01ldGhvZFByZWZlcmVuY2UuYmluZChcclxuICAgICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBnZXRScGNNZXRob2RQcmVmZXJlbmNlczpcclxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0UnBjTWV0aG9kUHJlZmVyZW5jZXMuYmluZChcclxuICAgICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBzZXRBZHZhbmNlZEdhc0ZlZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkdmFuY2VkR2FzRmVlLmJpbmQoXHJcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBzZXRUaGVtZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFRoZW1lLmJpbmQocHJlZmVyZW5jZXNDb250cm9sbGVyKSxcclxuICAgICAgc2V0VHJhbnNhY3Rpb25TZWN1cml0eUNoZWNrRW5hYmxlZDpcclxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VHJhbnNhY3Rpb25TZWN1cml0eUNoZWNrRW5hYmxlZC5iaW5kKFxyXG4gICAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIC8vIEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlclxyXG4gICAgICBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlsczogdGhpcy5nZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscy5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgLy8gTmZ0Q29udHJvbGxlclxyXG4gICAgICBhZGROZnQ6IG5mdENvbnRyb2xsZXIuYWRkTmZ0LmJpbmQobmZ0Q29udHJvbGxlciksXHJcblxyXG4gICAgICBhZGROZnRWZXJpZnlPd25lcnNoaXA6XHJcbiAgICAgICAgbmZ0Q29udHJvbGxlci5hZGROZnRWZXJpZnlPd25lcnNoaXAuYmluZChuZnRDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIHJlbW92ZUFuZElnbm9yZU5mdDogbmZ0Q29udHJvbGxlci5yZW1vdmVBbmRJZ25vcmVOZnQuYmluZChuZnRDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIHJlbW92ZU5mdDogbmZ0Q29udHJvbGxlci5yZW1vdmVOZnQuYmluZChuZnRDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIGNoZWNrQW5kVXBkYXRlQWxsTmZ0c093bmVyc2hpcFN0YXR1czpcclxuICAgICAgICBuZnRDb250cm9sbGVyLmNoZWNrQW5kVXBkYXRlQWxsTmZ0c093bmVyc2hpcFN0YXR1cy5iaW5kKG5mdENvbnRyb2xsZXIpLFxyXG5cclxuICAgICAgY2hlY2tBbmRVcGRhdGVTaW5nbGVOZnRPd25lcnNoaXBTdGF0dXM6XHJcbiAgICAgICAgbmZ0Q29udHJvbGxlci5jaGVja0FuZFVwZGF0ZVNpbmdsZU5mdE93bmVyc2hpcFN0YXR1cy5iaW5kKFxyXG4gICAgICAgICAgbmZ0Q29udHJvbGxlcixcclxuICAgICAgICApLFxyXG5cclxuICAgICAgaXNOZnRPd25lcjogbmZ0Q29udHJvbGxlci5pc05mdE93bmVyLmJpbmQobmZ0Q29udHJvbGxlciksXHJcblxyXG4gICAgICAvLyBBZGRyZXNzQ29udHJvbGxlclxyXG4gICAgICBzZXRBZGRyZXNzQm9vazogYWRkcmVzc0Jvb2tDb250cm9sbGVyLnNldC5iaW5kKGFkZHJlc3NCb29rQ29udHJvbGxlciksXHJcbiAgICAgIHJlbW92ZUZyb21BZGRyZXNzQm9vazogYWRkcmVzc0Jvb2tDb250cm9sbGVyLmRlbGV0ZS5iaW5kKFxyXG4gICAgICAgIGFkZHJlc3NCb29rQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuXHJcbiAgICAgIC8vIEFwcFN0YXRlQ29udHJvbGxlclxyXG4gICAgICBzZXRMYXN0QWN0aXZlVGltZTpcclxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0TGFzdEFjdGl2ZVRpbWUuYmluZChhcHBTdGF0ZUNvbnRyb2xsZXIpLFxyXG4gICAgICBzZXREZWZhdWx0SG9tZUFjdGl2ZVRhYk5hbWU6XHJcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldERlZmF1bHRIb21lQWN0aXZlVGFiTmFtZS5iaW5kKGFwcFN0YXRlQ29udHJvbGxlciksXHJcbiAgICAgIHNldENvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd246XHJcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldENvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd24uYmluZChcclxuICAgICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBzZXRSZWNvdmVyeVBocmFzZVJlbWluZGVySGFzQmVlblNob3duOlxyXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRSZWNvdmVyeVBocmFzZVJlbWluZGVySGFzQmVlblNob3duLmJpbmQoXHJcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bjpcclxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bi5iaW5kKFxyXG4gICAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIHNldFRlcm1zT2ZVc2VMYXN0QWdyZWVkOlxyXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRUZXJtc09mVXNlTGFzdEFncmVlZC5iaW5kKGFwcFN0YXRlQ29udHJvbGxlciksXHJcbiAgICAgIHNldE91dGRhdGVkQnJvd3Nlcldhcm5pbmdMYXN0U2hvd246XHJcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldE91dGRhdGVkQnJvd3Nlcldhcm5pbmdMYXN0U2hvd24uYmluZChcclxuICAgICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBzZXRTaG93VGVzdG5ldE1lc3NhZ2VJbkRyb3Bkb3duOlxyXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRTaG93VGVzdG5ldE1lc3NhZ2VJbkRyb3Bkb3duLmJpbmQoXHJcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgc2V0U2hvd0JldGFIZWFkZXI6XHJcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldFNob3dCZXRhSGVhZGVyLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcclxuICAgICAgc2V0U2hvd1Byb2R1Y3RUb3VyOlxyXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRTaG93UHJvZHVjdFRvdXIuYmluZChhcHBTdGF0ZUNvbnRyb2xsZXIpLFxyXG4gICAgICB1cGRhdGVOZnREcm9wRG93blN0YXRlOlxyXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci51cGRhdGVOZnREcm9wRG93blN0YXRlLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcclxuICAgICAgc2V0Rmlyc3RUaW1lVXNlZE5ldHdvcms6XHJcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldEZpcnN0VGltZVVzZWROZXR3b3JrLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIC8vIEVuc0NvbnRyb2xsZXJcclxuICAgICAgdHJ5UmV2ZXJzZVJlc29sdmVBZGRyZXNzOlxyXG4gICAgICAgIGVuc0NvbnRyb2xsZXIucmV2ZXJzZVJlc29sdmVBZGRyZXNzLmJpbmQoZW5zQ29udHJvbGxlciksXHJcblxyXG4gICAgICAvLyBLZXlyaW5nQ29udHJvbGxlclxyXG4gICAgICBzZXRMb2NrZWQ6IHRoaXMuc2V0TG9ja2VkLmJpbmQodGhpcyksXHJcbiAgICAgIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW46IHRoaXMuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbi5iaW5kKHRoaXMpLFxyXG4gICAgICBjcmVhdGVOZXdWYXVsdEFuZFJlc3RvcmU6IHRoaXMuY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlLmJpbmQodGhpcyksXHJcbiAgICAgIGV4cG9ydEFjY291bnQ6IHRoaXMuZXhwb3J0QWNjb3VudC5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgLy8gdHhDb250cm9sbGVyXHJcbiAgICAgIGNhbmNlbFRyYW5zYWN0aW9uOiB0eENvbnRyb2xsZXIuY2FuY2VsVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxyXG4gICAgICB1cGRhdGVUcmFuc2FjdGlvbjogdHhDb250cm9sbGVyLnVwZGF0ZVRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcclxuICAgICAgdXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uOlxyXG4gICAgICAgIHR4Q29udHJvbGxlci51cGRhdGVBbmRBcHByb3ZlVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxyXG4gICAgICBhcHByb3ZlVHJhbnNhY3Rpb25zV2l0aFNhbWVOb25jZTpcclxuICAgICAgICB0eENvbnRyb2xsZXIuYXBwcm92ZVRyYW5zYWN0aW9uc1dpdGhTYW1lTm9uY2UuYmluZCh0eENvbnRyb2xsZXIpLFxyXG4gICAgICBjcmVhdGVDYW5jZWxUcmFuc2FjdGlvbjogdGhpcy5jcmVhdGVDYW5jZWxUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICBjcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb246IHRoaXMuY3JlYXRlU3BlZWRVcFRyYW5zYWN0aW9uLmJpbmQodGhpcyksXHJcbiAgICAgIGVzdGltYXRlR2FzOiB0aGlzLmVzdGltYXRlR2FzLmJpbmQodGhpcyksXHJcbiAgICAgIGdldE5leHROb25jZTogdGhpcy5nZXROZXh0Tm9uY2UuYmluZCh0aGlzKSxcclxuICAgICAgYWRkVW5hcHByb3ZlZFRyYW5zYWN0aW9uOlxyXG4gICAgICAgIHR4Q29udHJvbGxlci5hZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxyXG4gICAgICBjcmVhdGVUcmFuc2FjdGlvbkV2ZW50RnJhZ21lbnQ6XHJcbiAgICAgICAgdHhDb250cm9sbGVyLmNyZWF0ZVRyYW5zYWN0aW9uRXZlbnRGcmFnbWVudC5iaW5kKHR4Q29udHJvbGxlciksXHJcbiAgICAgIGdldFRyYW5zYWN0aW9uczogdHhDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucy5iaW5kKHR4Q29udHJvbGxlciksXHJcblxyXG4gICAgICB1cGRhdGVFZGl0YWJsZVBhcmFtczpcclxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlRWRpdGFibGVQYXJhbXMuYmluZCh0eENvbnRyb2xsZXIpLFxyXG4gICAgICB1cGRhdGVUcmFuc2FjdGlvbkdhc0ZlZXM6XHJcbiAgICAgICAgdHhDb250cm9sbGVyLnVwZGF0ZVRyYW5zYWN0aW9uR2FzRmVlcy5iaW5kKHR4Q29udHJvbGxlciksXHJcbiAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uU2VuZEZsb3dIaXN0b3J5OlxyXG4gICAgICAgIHR4Q29udHJvbGxlci51cGRhdGVUcmFuc2FjdGlvblNlbmRGbG93SGlzdG9yeS5iaW5kKHR4Q29udHJvbGxlciksXHJcblxyXG4gICAgICB1cGRhdGVTd2FwQXBwcm92YWxUcmFuc2FjdGlvbjpcclxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlU3dhcEFwcHJvdmFsVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxyXG4gICAgICB1cGRhdGVTd2FwVHJhbnNhY3Rpb246XHJcbiAgICAgICAgdHhDb250cm9sbGVyLnVwZGF0ZVN3YXBUcmFuc2FjdGlvbi5iaW5kKHR4Q29udHJvbGxlciksXHJcblxyXG4gICAgICB1cGRhdGVQcmV2aW91c0dhc1BhcmFtczpcclxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlUHJldmlvdXNHYXNQYXJhbXMuYmluZCh0eENvbnRyb2xsZXIpLFxyXG5cclxuICAgICAgLy8gc2lnbmF0dXJlQ29udHJvbGxlclxyXG4gICAgICBzaWduTWVzc2FnZTogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLnNpZ25NZXNzYWdlLmJpbmQoXHJcbiAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBjYW5jZWxNZXNzYWdlOiB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIuY2FuY2VsTWVzc2FnZS5iaW5kKFxyXG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgc2lnblBlcnNvbmFsTWVzc2FnZTogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLnNpZ25QZXJzb25hbE1lc3NhZ2UuYmluZChcclxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIGNhbmNlbFBlcnNvbmFsTWVzc2FnZTpcclxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIuY2FuY2VsUGVyc29uYWxNZXNzYWdlLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgc2lnblR5cGVkTWVzc2FnZTogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLnNpZ25UeXBlZE1lc3NhZ2UuYmluZChcclxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIGNhbmNlbFR5cGVkTWVzc2FnZTogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLmNhbmNlbFR5cGVkTWVzc2FnZS5iaW5kKFxyXG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuXHJcbiAgICAgIC8vIGRlY3J5cHRNZXNzYWdlQ29udHJvbGxlclxyXG4gICAgICBkZWNyeXB0TWVzc2FnZTogdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2UuYmluZChcclxuICAgICAgICB0aGlzLmRlY3J5cHRNZXNzYWdlQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgZGVjcnlwdE1lc3NhZ2VJbmxpbmU6XHJcbiAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2VJbmxpbmUuYmluZChcclxuICAgICAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIGNhbmNlbERlY3J5cHRNZXNzYWdlOlxyXG4gICAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyLmNhbmNlbERlY3J5cHRNZXNzYWdlLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLmRlY3J5cHRNZXNzYWdlQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG5cclxuICAgICAgLy8gRW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXJcclxuICAgICAgZW5jcnlwdGlvblB1YmxpY0tleTpcclxuICAgICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXkuYmluZChcclxuICAgICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgY2FuY2VsRW5jcnlwdGlvblB1YmxpY0tleTpcclxuICAgICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLmNhbmNlbEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZChcclxuICAgICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuXHJcbiAgICAgIC8vIG9uYm9hcmRpbmcgY29udHJvbGxlclxyXG4gICAgICBzZXRTZWVkUGhyYXNlQmFja2VkVXA6XHJcbiAgICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXIuc2V0U2VlZFBocmFzZUJhY2tlZFVwLmJpbmQob25ib2FyZGluZ0NvbnRyb2xsZXIpLFxyXG4gICAgICBjb21wbGV0ZU9uYm9hcmRpbmc6XHJcbiAgICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXIuY29tcGxldGVPbmJvYXJkaW5nLmJpbmQob25ib2FyZGluZ0NvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRGaXJzdFRpbWVGbG93VHlwZTpcclxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlci5zZXRGaXJzdFRpbWVGbG93VHlwZS5iaW5kKG9uYm9hcmRpbmdDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIC8vIGFsZXJ0IGNvbnRyb2xsZXJcclxuICAgICAgc2V0QWxlcnRFbmFibGVkbmVzczpcclxuICAgICAgICBhbGVydENvbnRyb2xsZXIuc2V0QWxlcnRFbmFibGVkbmVzcy5iaW5kKGFsZXJ0Q29udHJvbGxlciksXHJcbiAgICAgIHNldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd246XHJcbiAgICAgICAgYWxlcnRDb250cm9sbGVyLnNldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd24uYmluZChhbGVydENvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRXZWIzU2hpbVVzYWdlQWxlcnREaXNtaXNzZWQ6XHJcbiAgICAgICAgYWxlcnRDb250cm9sbGVyLnNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZC5iaW5kKGFsZXJ0Q29udHJvbGxlciksXHJcblxyXG4gICAgICAvLyBtc2cgc2lnIGF1dGggY29udHJvbGxlclxyXG4gICAgICBzZXRNZXNzYWdlSW5mbzpcclxuICAgICAgICB3ZWIzQXV0aENvbnRyb2xsZXIuc2V0TWVzc2FnZUluZm8uYmluZCh3ZWIzQXV0aENvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRHbG9iYWxGaW5nZXJwcmludDpcclxuICAgICAgICB3ZWIzQXV0aENvbnRyb2xsZXIuc2V0R2xvYmFsRmluZ2VycHJpbnQuYmluZCh3ZWIzQXV0aENvbnRyb2xsZXIpLFxyXG5cclxuICAgICAgLy8gcGVybWlzc2lvbnNcclxuICAgICAgcmVtb3ZlUGVybWlzc2lvbnNGb3I6IHRoaXMucmVtb3ZlUGVybWlzc2lvbnNGb3IsXHJcbiAgICAgIGFwcHJvdmVQZXJtaXNzaW9uc1JlcXVlc3Q6IHRoaXMuYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0LFxyXG4gICAgICByZWplY3RQZXJtaXNzaW9uc1JlcXVlc3Q6IHRoaXMucmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0LFxyXG4gICAgICAuLi5nZXRQZXJtaXNzaW9uQmFja2dyb3VuZEFwaU1ldGhvZHMocGVybWlzc2lvbkNvbnRyb2xsZXIpLFxyXG5cclxuXG5cblxyXG4gICAgICAvLyBzd2Fwc1xyXG4gICAgICBmZXRjaEFuZFNldFF1b3RlczpcclxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuZmV0Y2hBbmRTZXRRdW90ZXMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRTZWxlY3RlZFF1b3RlQWdnSWQ6XHJcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldFNlbGVjdGVkUXVvdGVBZ2dJZC5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHJlc2V0U3dhcHNTdGF0ZTogc3dhcHNDb250cm9sbGVyLnJlc2V0U3dhcHNTdGF0ZS5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldFN3YXBzVG9rZW5zOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUb2tlbnMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxyXG4gICAgICBjbGVhclN3YXBzUXVvdGVzOiBzd2Fwc0NvbnRyb2xsZXIuY2xlYXJTd2Fwc1F1b3Rlcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldEFwcHJvdmVUeElkOiBzd2Fwc0NvbnRyb2xsZXIuc2V0QXBwcm92ZVR4SWQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRUcmFkZVR4SWQ6IHN3YXBzQ29udHJvbGxlci5zZXRUcmFkZVR4SWQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRTd2Fwc1R4R2FzUHJpY2U6XHJcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVHhHYXNQcmljZS5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldFN3YXBzVHhHYXNMaW1pdDpcclxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUeEdhc0xpbWl0LmJpbmQoc3dhcHNDb250cm9sbGVyKSxcclxuICAgICAgc2V0U3dhcHNUeE1heEZlZVBlckdhczpcclxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUeE1heEZlZVBlckdhcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldFN3YXBzVHhNYXhGZWVQcmlvcml0eVBlckdhczpcclxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUeE1heEZlZVByaW9yaXR5UGVyR2FzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcclxuICAgICAgc2FmZVJlZmV0Y2hRdW90ZXM6XHJcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNhZmVSZWZldGNoUXVvdGVzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcclxuICAgICAgc3RvcFBvbGxpbmdGb3JRdW90ZXM6XHJcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnN0b3BQb2xsaW5nRm9yUXVvdGVzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcclxuICAgICAgc2V0QmFja2dyb3VuZFN3YXBSb3V0ZVN0YXRlOlxyXG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRCYWNrZ3JvdW5kU3dhcFJvdXRlU3RhdGUuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxyXG4gICAgICByZXNldFBvc3RGZXRjaFN0YXRlOlxyXG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5yZXNldFBvc3RGZXRjaFN0YXRlLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcclxuICAgICAgc2V0U3dhcHNFcnJvcktleTogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzRXJyb3JLZXkuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRJbml0aWFsR2FzRXN0aW1hdGU6XHJcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldEluaXRpYWxHYXNFc3RpbWF0ZS5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldEN1c3RvbUFwcHJvdmVUeERhdGE6XHJcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldEN1c3RvbUFwcHJvdmVUeERhdGEuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxyXG4gICAgICBzZXRTd2Fwc0xpdmVuZXNzOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNMaXZlbmVzcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldFN3YXBzRmVhdHVyZUZsYWdzOlxyXG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc0ZlYXR1cmVGbGFncy5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldFN3YXBzVXNlckZlZUxldmVsOlxyXG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1VzZXJGZWVMZXZlbC5iaW5kKHN3YXBzQ29udHJvbGxlciksXHJcbiAgICAgIHNldFN3YXBzUXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZDpcclxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNRdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIC8vIFNtYXJ0IFRyYW5zYWN0aW9uc1xyXG4gICAgICBzZXRTbWFydFRyYW5zYWN0aW9uc09wdEluU3RhdHVzOlxyXG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5zZXRPcHRJblN0YXRlLmJpbmQoXHJcbiAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgZmV0Y2hTbWFydFRyYW5zYWN0aW9uRmVlczogc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmdldEZlZXMuYmluZChcclxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIGNsZWFyU21hcnRUcmFuc2FjdGlvbkZlZXM6IHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5jbGVhckZlZXMuYmluZChcclxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHN1Ym1pdFNpZ25lZFRyYW5zYWN0aW9uczpcclxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3VibWl0U2lnbmVkVHJhbnNhY3Rpb25zLmJpbmQoXHJcbiAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgY2FuY2VsU21hcnRUcmFuc2FjdGlvbjpcclxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuY2FuY2VsU21hcnRUcmFuc2FjdGlvbi5iaW5kKFxyXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIGZldGNoU21hcnRUcmFuc2FjdGlvbnNMaXZlbmVzczpcclxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuZmV0Y2hMaXZlbmVzcy5iaW5kKFxyXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgIHVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb246XHJcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLnVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb24uYmluZChcclxuICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICBzZXRTdGF0dXNSZWZyZXNoSW50ZXJ2YWw6XHJcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLnNldFN0YXR1c1JlZnJlc2hJbnRlcnZhbC5iaW5kKFxyXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcblxyXG4gICAgICAvLyBNZXRhTWV0cmljc1xyXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IG1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXHJcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICB0cmFja01ldGFNZXRyaWNzUGFnZTogbWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrUGFnZS5iaW5kKFxyXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcclxuICAgICAgKSxcclxuICAgICAgY3JlYXRlRXZlbnRGcmFnbWVudDogbWV0YU1ldHJpY3NDb250cm9sbGVyLmNyZWF0ZUV2ZW50RnJhZ21lbnQuYmluZChcclxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcbiAgICAgIHVwZGF0ZUV2ZW50RnJhZ21lbnQ6IG1ldGFNZXRyaWNzQ29udHJvbGxlci51cGRhdGVFdmVudEZyYWdtZW50LmJpbmQoXHJcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG4gICAgICBmaW5hbGl6ZUV2ZW50RnJhZ21lbnQ6IG1ldGFNZXRyaWNzQ29udHJvbGxlci5maW5hbGl6ZUV2ZW50RnJhZ21lbnQuYmluZChcclxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcblxyXG4gICAgICAvLyBhcHByb3ZhbCBjb250cm9sbGVyXHJcbiAgICAgIHJlc29sdmVQZW5kaW5nQXBwcm92YWw6IHRoaXMucmVzb2x2ZVBlbmRpbmdBcHByb3ZhbCxcclxuICAgICAgcmVqZWN0UGVuZGluZ0FwcHJvdmFsOiB0aGlzLnJlamVjdFBlbmRpbmdBcHByb3ZhbCxcclxuXHJcbiAgICAgIC8vIE5vdGlmaWNhdGlvbnNcclxuICAgICAgdXBkYXRlVmlld2VkTm90aWZpY2F0aW9uczogYW5ub3VuY2VtZW50Q29udHJvbGxlci51cGRhdGVWaWV3ZWQuYmluZChcclxuICAgICAgICBhbm5vdW5jZW1lbnRDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG5cclxuICAgICAgLy8gR2FzRmVlQ29udHJvbGxlclxyXG4gICAgICBnZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmc6XHJcbiAgICAgICAgZ2FzRmVlQ29udHJvbGxlci5nZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcuYmluZChcclxuICAgICAgICAgIGdhc0ZlZUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuXHJcbiAgICAgIGRpc2Nvbm5lY3RHYXNGZWVFc3RpbWF0ZVBvbGxlcjpcclxuICAgICAgICBnYXNGZWVDb250cm9sbGVyLmRpc2Nvbm5lY3RQb2xsZXIuYmluZChnYXNGZWVDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIGdldEdhc0ZlZVRpbWVFc3RpbWF0ZTpcclxuICAgICAgICBnYXNGZWVDb250cm9sbGVyLmdldFRpbWVFc3RpbWF0ZS5iaW5kKGdhc0ZlZUNvbnRyb2xsZXIpLFxyXG5cclxuICAgICAgYWRkUG9sbGluZ1Rva2VuVG9BcHBTdGF0ZTpcclxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuYWRkUG9sbGluZ1Rva2VuLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIHJlbW92ZVBvbGxpbmdUb2tlbkZyb21BcHBTdGF0ZTpcclxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIucmVtb3ZlUG9sbGluZ1Rva2VuLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcclxuXHJcbiAgICAgIC8vIEJhY2t1cENvbnRyb2xsZXJcclxuICAgICAgYmFja3VwVXNlckRhdGE6IGJhY2t1cENvbnRyb2xsZXIuYmFja3VwVXNlckRhdGEuYmluZChiYWNrdXBDb250cm9sbGVyKSxcclxuICAgICAgcmVzdG9yZVVzZXJEYXRhOiBiYWNrdXBDb250cm9sbGVyLnJlc3RvcmVVc2VyRGF0YS5iaW5kKGJhY2t1cENvbnRyb2xsZXIpLFxyXG5cclxuICAgICAgLy8gRGV0ZWN0VG9rZW5Db250cm9sbGVyXHJcbiAgICAgIGRldGVjdE5ld1Rva2VuczogZGV0ZWN0VG9rZW5zQ29udHJvbGxlci5kZXRlY3ROZXdUb2tlbnMuYmluZChcclxuICAgICAgICBkZXRlY3RUb2tlbnNDb250cm9sbGVyLFxyXG4gICAgICApLFxyXG5cclxuICAgICAgLy8gRGV0ZWN0Q29sbGVjdGlibGVDb250cm9sbGVyXHJcbiAgICAgIGRldGVjdE5mdHM6IG5mdERldGVjdGlvbkNvbnRyb2xsZXIuZGV0ZWN0TmZ0cy5iaW5kKFxyXG4gICAgICAgIG5mdERldGVjdGlvbkNvbnRyb2xsZXIsXHJcbiAgICAgICksXHJcblxyXG4gICAgICAvKiogVG9rZW4gRGV0ZWN0aW9uIFYyICovXHJcbiAgICAgIGFkZERldGVjdGVkVG9rZW5zOlxyXG4gICAgICAgIHRva2Vuc0NvbnRyb2xsZXIuYWRkRGV0ZWN0ZWRUb2tlbnMuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcclxuICAgICAgYWRkSW1wb3J0ZWRUb2tlbnM6IHRva2Vuc0NvbnRyb2xsZXIuYWRkVG9rZW5zLmJpbmQodG9rZW5zQ29udHJvbGxlciksXHJcbiAgICAgIGlnbm9yZVRva2VuczogdG9rZW5zQ29udHJvbGxlci5pZ25vcmVUb2tlbnMuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcclxuICAgICAgZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGw6XHJcbiAgICAgICAgYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEJhbGFuY2VzSW5TaW5nbGVDYWxsLmJpbmQoXHJcbiAgICAgICAgICBhc3NldHNDb250cmFjdENvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHBvcnRBY2NvdW50KGFkZHJlc3MsIHBhc3N3b3JkKSB7XHJcbiAgICBhd2FpdCB0aGlzLnZlcmlmeVBhc3N3b3JkKHBhc3N3b3JkKTtcclxuICAgIHJldHVybiB0aGlzLmtleXJpbmdDb250cm9sbGVyLmV4cG9ydEFjY291bnQoYWRkcmVzcywgcGFzc3dvcmQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMoYWRkcmVzcywgdXNlckFkZHJlc3MsIHRva2VuSWQpIHtcclxuICAgIGNvbnN0IHsgdG9rZW5MaXN0IH0gPSB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RhdGU7XHJcbiAgICBjb25zdCB7IHRva2VucyB9ID0gdGhpcy50b2tlbnNDb250cm9sbGVyLnN0YXRlO1xyXG5cclxuICAgIGNvbnN0IHN0YXRpY1Rva2VuTGlzdERldGFpbHMgPVxyXG4gICAgICBTVEFUSUNfTUFJTk5FVF9UT0tFTl9MSVNUW2FkZHJlc3MudG9Mb3dlckNhc2UoKV0gfHwge307XHJcbiAgICBjb25zdCB0b2tlbkxpc3REZXRhaWxzID0gdG9rZW5MaXN0W2FkZHJlc3MudG9Mb3dlckNhc2UoKV0gfHwge307XHJcbiAgICBjb25zdCB1c2VyRGVmaW5lZFRva2VuRGV0YWlscyA9XHJcbiAgICAgIHRva2Vucy5maW5kKCh7IGFkZHJlc3M6IF9hZGRyZXNzIH0pID0+XHJcbiAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShfYWRkcmVzcywgYWRkcmVzcyksXHJcbiAgICAgICkgfHwge307XHJcblxyXG4gICAgY29uc3QgdG9rZW5EZXRhaWxzID0ge1xyXG4gICAgICAuLi5zdGF0aWNUb2tlbkxpc3REZXRhaWxzLFxyXG4gICAgICAuLi50b2tlbkxpc3REZXRhaWxzLFxyXG4gICAgICAuLi51c2VyRGVmaW5lZFRva2VuRGV0YWlscyxcclxuICAgIH07XHJcbiAgICBjb25zdCB0b2tlbkRldGFpbHNTdGFuZGFyZElzRVJDMjAgPVxyXG4gICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKHRva2VuRGV0YWlscy5zdGFuZGFyZCwgVG9rZW5TdGFuZGFyZC5FUkMyMCkgfHxcclxuICAgICAgdG9rZW5EZXRhaWxzLmVyYzIwID09PSB0cnVlO1xyXG4gICAgY29uc3Qgbm9FdmlkZW5jZVRoYXRUb2tlbklzQW5ORlQgPVxyXG4gICAgICAhdG9rZW5JZCAmJlxyXG4gICAgICAhaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSh0b2tlbkRldGFpbHMuc3RhbmRhcmQsIFRva2VuU3RhbmRhcmQuRVJDMTE1NSkgJiZcclxuICAgICAgIWlzRXF1YWxDYXNlSW5zZW5zaXRpdmUodG9rZW5EZXRhaWxzLnN0YW5kYXJkLCBUb2tlblN0YW5kYXJkLkVSQzcyMSkgJiZcclxuICAgICAgIXRva2VuRGV0YWlscy5lcmM3MjE7XHJcblxyXG4gICAgY29uc3Qgb3RoZXJEZXRhaWxzQXJlRVJDMjBMaWtlID1cclxuICAgICAgdG9rZW5EZXRhaWxzLmRlY2ltYWxzICE9PSB1bmRlZmluZWQgJiYgdG9rZW5EZXRhaWxzLnN5bWJvbDtcclxuXHJcbiAgICBjb25zdCB0b2tlbkNhbkJlVHJlYXRlZEFzQW5FUkMyMCA9XHJcbiAgICAgIHRva2VuRGV0YWlsc1N0YW5kYXJkSXNFUkMyMCB8fFxyXG4gICAgICAobm9FdmlkZW5jZVRoYXRUb2tlbklzQW5ORlQgJiYgb3RoZXJEZXRhaWxzQXJlRVJDMjBMaWtlKTtcclxuXHJcbiAgICBsZXQgZGV0YWlscztcclxuICAgIGlmICh0b2tlbkNhbkJlVHJlYXRlZEFzQW5FUkMyMCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBmZXRjaFRva2VuQmFsYW5jZShcclxuICAgICAgICAgIGFkZHJlc3MsXHJcbiAgICAgICAgICB1c2VyQWRkcmVzcyxcclxuICAgICAgICAgIHRoaXMucHJvdmlkZXIsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgZGV0YWlscyA9IHtcclxuICAgICAgICAgIGFkZHJlc3MsXHJcbiAgICAgICAgICBiYWxhbmNlLFxyXG4gICAgICAgICAgc3RhbmRhcmQ6IFRva2VuU3RhbmRhcmQuRVJDMjAsXHJcbiAgICAgICAgICBkZWNpbWFsczogdG9rZW5EZXRhaWxzLmRlY2ltYWxzLFxyXG4gICAgICAgICAgc3ltYm9sOiB0b2tlbkRldGFpbHMuc3ltYm9sLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBJZiB0aGUgYGZldGNoVG9rZW5CYWxhbmNlYCBjYWxsIGZhaWxlZCwgYGRldGFpbHNgIHJlbWFpbnMgdW5kZWZpbmVkLCBhbmQgd2VcclxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGJlbG93IGBhc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHNgIGNhbGxcclxuICAgICAgICBsb2cud2FybmluZyhgRmFpbGVkIHRvIGdldCB0b2tlbiBiYWxhbmNlLiBFcnJvcjogJHtlfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYGRldGFpbHNgYCB3aWxsIGJlIHVuZGVmaW5lZCBpZiBgdG9rZW5DYW5CZVRyZWF0ZWRBc0FuRVJDMjBgYCBpcyBmYWxzZSxcclxuICAgIC8vIG9yIGlmIGl0IGlzIHRydWUgYnV0IHRoZSBgZmV0Y2hUb2tlbkJhbGFuY2VgYCBjYWxsIGZhaWxlZC4gSW4gZWl0aGVyIGNhc2UsIHdlIHNob3VsZFxyXG4gICAgLy8gYXR0ZW1wdCB0byByZXRyaWV2ZSBkZXRhaWxzIGZyb20gYGFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlsc2BcclxuICAgIGlmIChkZXRhaWxzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZGV0YWlscyA9IGF3YWl0IHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKFxyXG4gICAgICAgIGFkZHJlc3MsXHJcbiAgICAgICAgdXNlckFkZHJlc3MsXHJcbiAgICAgICAgdG9rZW5JZCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi5kZXRhaWxzLFxyXG4gICAgICBkZWNpbWFsczogZGV0YWlscz8uZGVjaW1hbHM/LnRvU3RyaW5nKDEwKSxcclxuICAgICAgYmFsYW5jZTogZGV0YWlscz8uYmFsYW5jZT8udG9TdHJpbmcoMTApLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBWQVVMVCAvIEtFWVJJTkcgUkVMQVRFRCBNRVRIT0RTXHJcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFZhdWx0IGFuZCBjcmVhdGUgYSBuZXcga2V5Y2hhaW4uXHJcbiAgICpcclxuICAgKiBBIHZhdWx0LCBvciBLZXlyaW5nQ29udHJvbGxlciwgaXMgYSBjb250cm9sbGVyIHRoYXQgY29udGFpbnNcclxuICAgKiBtYW55IGRpZmZlcmVudCBhY2NvdW50IHN0cmF0ZWdpZXMsIGN1cnJlbnRseSBjYWxsZWQgS2V5cmluZ3MuXHJcbiAgICogQ3JlYXRpbmcgaXQgbmV3IG1lYW5zIHdpcGluZyBhbGwgcHJldmlvdXMga2V5cmluZ3MuXHJcbiAgICpcclxuICAgKiBBIGtleWNoYWluLCBvciBrZXlyaW5nLCBjb250cm9scyBtYW55IGFjY291bnRzIHdpdGggYSBzaW5nbGUgYmFja3VwIGFuZCBzaWduaW5nIHN0cmF0ZWd5LlxyXG4gICAqIEZvciBleGFtcGxlLCBhIG1uZW1vbmljIHBocmFzZSBjYW4gZ2VuZXJhdGUgbWFueSBhY2NvdW50cywgYW5kIGlzIGEga2V5cmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHZhdWx0XHJcbiAgICovXHJcbiAgYXN5bmMgY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbihwYXNzd29yZCkge1xyXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCB0aGlzLmNyZWF0ZVZhdWx0TXV0ZXguYWNxdWlyZSgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IHZhdWx0O1xyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcclxuICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXVsdCA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZnVsbFVwZGF0ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5jcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKFxyXG4gICAgICAgICAgcGFzc3dvcmQsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XHJcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RGaXJzdElkZW50aXR5KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB2YXVsdDtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHJlbGVhc2VMb2NrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgVmF1bHQgYW5kIHJlc3RvcmUgYW4gZXhpc3RlbnQga2V5cmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGVuY29kZWRTZWVkUGhyYXNlIC0gVGhlIHNlZWQgcGhyYXNlLCBlbmNvZGVkIGFzIGFuIGFycmF5XHJcbiAgICogb2YgVVRGLTggYnl0ZXMuXHJcbiAgICovXHJcbiAgYXN5bmMgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBlbmNvZGVkU2VlZFBocmFzZSkge1xyXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCB0aGlzLmNyZWF0ZVZhdWx0TXV0ZXguYWNxdWlyZSgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IGFjY291bnRzLCBsYXN0QmFsYW5jZTtcclxuXHJcbiAgICAgIGNvbnN0IHNlZWRQaHJhc2VBc0J1ZmZlciA9IEJ1ZmZlci5mcm9tKGVuY29kZWRTZWVkUGhyYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHsga2V5cmluZ0NvbnRyb2xsZXIgfSA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBjbGVhciBrbm93biBpZGVudGl0aWVzXHJcbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhbXSk7XHJcblxyXG4gICAgICAvLyBjbGVhciBwZXJtaXNzaW9uc1xyXG4gICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmNsZWFyU3RhdGUoKTtcclxuXHJcblxuXHJcbiAgICAgIC8vIGNsZWFyIGFjY291bnRzIGluIGFjY291bnRUcmFja2VyXHJcbiAgICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuY2xlYXJBY2NvdW50cygpO1xyXG5cclxuICAgICAgLy8gY2xlYXIgY2FjaGVkQmFsYW5jZXNcclxuICAgICAgdGhpcy5jYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2xlYXJDYWNoZWRCYWxhbmNlcygpO1xyXG5cclxuICAgICAgLy8gY2xlYXIgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnNcclxuICAgICAgdGhpcy50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuY2xlYXJVbmFwcHJvdmVkVHhzKCk7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgbmV3IHZhdWx0XHJcbiAgICAgIGNvbnN0IHZhdWx0ID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKFxyXG4gICAgICAgIHBhc3N3b3JkLFxyXG4gICAgICAgIHNlZWRQaHJhc2VBc0J1ZmZlcixcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGV0aFF1ZXJ5ID0gbmV3IEV0aFF1ZXJ5KHRoaXMucHJvdmlkZXIpO1xyXG4gICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XHJcbiAgICAgIGxhc3RCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKFxyXG4gICAgICAgIGFjY291bnRzW2FjY291bnRzLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgIGV0aFF1ZXJ5LFxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgW3ByaW1hcnlLZXlyaW5nXSA9IGtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxyXG4gICAgICAgIEtleXJpbmdUeXBlLmhkS2V5VHJlZSxcclxuICAgICAgKTtcclxuICAgICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gSEQgS2V5IFRyZWUgZm91bmQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2VlayBvdXQgdGhlIGZpcnN0IHplcm8gYmFsYW5jZVxyXG4gICAgICB3aGlsZSAobGFzdEJhbGFuY2UgIT09ICcweDAnKSB7XHJcbiAgICAgICAgYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XHJcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xyXG4gICAgICAgIGxhc3RCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKFxyXG4gICAgICAgICAgYWNjb3VudHNbYWNjb3VudHMubGVuZ3RoIC0gMV0sXHJcbiAgICAgICAgICBldGhRdWVyeSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZW1vdmUgZXh0cmEgemVybyBiYWxhbmNlIGFjY291bnQgcG90ZW50aWFsbHkgY3JlYXRlZCBmcm9tIHNlZWtpbmcgYWhlYWRcclxuICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDEgJiYgbGFzdEJhbGFuY2UgPT09ICcweDAnKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVBY2NvdW50KGFjY291bnRzW2FjY291bnRzLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoaXMgbXVzdCBiZSBzZXQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBjb21tdW5pY2F0ZSB0byB0aGVcclxuICAgICAgLy8ga2V5cmluZydzIGlmcmFtZSBhbmQgaGF2ZSB0aGUgc2V0dGluZyBpbml0aWFsaXplZCBwcm9wZXJseVxyXG4gICAgICAvLyBPcHRpbWlzdGljYWxseSBjYWxsZWQgdG8gbm90IGJsb2NrIE1ldGFNYXNrIGxvZ2luIGR1ZSB0b1xyXG4gICAgICAvLyBMZWRnZXIgS2V5cmluZyBHaXRIdWIgZG93bnRpbWVcclxuICAgICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9XHJcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xyXG4gICAgICB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0UHJlZmVyZW5jZSk7XHJcblxyXG4gICAgICAvLyBzZXQgbmV3IGlkZW50aXRpZXNcclxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKGFjY291bnRzKTtcclxuICAgICAgdGhpcy5zZWxlY3RGaXJzdElkZW50aXR5KCk7XHJcbiAgICAgIHJldHVybiB2YXVsdDtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHJlbGVhc2VMb2NrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYW4gYWNjb3VudCBiYWxhbmNlIGZyb20gdGhlIEFjY291bnRUcmFja2VyIG9yIHJlcXVlc3QgaXQgZGlyZWN0bHkgZnJvbSB0aGUgbmV0d29yay5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFjY291bnQgYWRkcmVzc1xyXG4gICAqIEBwYXJhbSB7RXRoUXVlcnl9IGV0aFF1ZXJ5IC0gVGhlIEV0aFF1ZXJ5IGluc3RhbmNlIHRvIHVzZSB3aGVuIGFza2luZyB0aGUgbmV0d29ya1xyXG4gICAqL1xyXG4gIGdldEJhbGFuY2UoYWRkcmVzcywgZXRoUXVlcnkpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUuZ2V0U3RhdGUoKS5hY2NvdW50c1thZGRyZXNzXTtcclxuXHJcbiAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmJhbGFuY2UpIHtcclxuICAgICAgICByZXNvbHZlKGNhY2hlZC5iYWxhbmNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBldGhRdWVyeS5nZXRCYWxhbmNlKGFkZHJlc3MsIChlcnJvciwgYmFsYW5jZSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIGxvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKGJhbGFuY2UgfHwgJzB4MCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1Ym1pdHMgdGhlIHVzZXIncyBwYXNzd29yZCBhbmQgYXR0ZW1wdHMgdG8gdW5sb2NrIHRoZSB2YXVsdC5cclxuICAgKiBBbHNvIHN5bmNocm9uaXplcyB0aGUgcHJlZmVyZW5jZXNDb250cm9sbGVyLCB0byBlbnN1cmUgaXRzIHNjaGVtYVxyXG4gICAqIGlzIHVwIHRvIGRhdGUgd2l0aCBrbm93biBhY2NvdW50cyBvbmNlIHRoZSB2YXVsdCBpcyBkZWNyeXB0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgdXNlcidzIHBhc3N3b3JkXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gVGhlIGtleXJpbmdDb250cm9sbGVyIHVwZGF0ZS5cclxuICAgKi9cclxuICBhc3luYyBzdWJtaXRQYXNzd29yZChwYXNzd29yZCkge1xyXG4gICAgYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5ibG9ja1RyYWNrZXIuY2hlY2tGb3JMYXRlc3RCbG9jaygpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKCdFcnJvciB3aGlsZSB1bmxvY2tpbmcgZXh0ZW5zaW9uLicsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIG11c3QgYmUgc2V0IGFzIHNvb24gYXMgcG9zc2libGUgdG8gY29tbXVuaWNhdGUgdG8gdGhlXHJcbiAgICAvLyBrZXlyaW5nJ3MgaWZyYW1lIGFuZCBoYXZlIHRoZSBzZXR0aW5nIGluaXRpYWxpemVkIHByb3Blcmx5XHJcbiAgICAvLyBPcHRpbWlzdGljYWxseSBjYWxsZWQgdG8gbm90IGJsb2NrIE1ldGFNYXNrIGxvZ2luIGR1ZSB0b1xyXG4gICAgLy8gTGVkZ2VyIEtleXJpbmcgR2l0SHViIGRvd250aW1lXHJcbiAgICBjb25zdCB0cmFuc3BvcnRQcmVmZXJlbmNlID1cclxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xyXG5cclxuICAgIHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnRQcmVmZXJlbmNlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5mdWxsVXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBfbG9naW5Vc2VyKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQXV0b21hdGljIGxvZ2luIHZpYSBjb25maWcgcGFzc3dvcmRcclxuICAgICAgY29uc3QgcGFzc3dvcmQgPSBwcm9jZXNzLmVudi5QQVNTV09SRDtcclxuICAgICAgaWYgKHBhc3N3b3JkICYmICFwcm9jZXNzLmVudi5JTl9URVNUKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQXV0b21hdGljIGxvZ2luIHZpYSBzdG9yYWdlIGVuY3J5cHRpb24ga2V5XHJcbiAgICAgIGVsc2UgaWYgKGlzTWFuaWZlc3RWMykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc3VibWl0RW5jcnlwdGlvbktleSgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFVwZGF0aW5nIGFjY291bnRzIGluIHRoaXMuYWNjb3VudFRyYWNrZXIgYmVmb3JlIHN0YXJ0aW5nIFVJIHN5bmNpbmcgZW5zdXJlIHRoYXRcclxuICAgICAgLy8gc3RhdGUgaGFzIGFjY291bnQgYmFsYW5jZSBiZWZvcmUgaXQgaXMgc3luY2VkIHdpdGggVUlcclxuICAgICAgYXdhaXQgdGhpcy5hY2NvdW50VHJhY2tlci5fdXBkYXRlQWNjb3VudHMoKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0VUlTeW5jKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfc3RhcnRVSVN5bmMoKSB7XHJcbiAgICAvLyBNZXNzYWdlIHN0YXJ0VUlTeW5jIGlzIHVzZWQgaW4gTVYzIHRvIHN0YXJ0IHN5bmNpbmcgc3RhdGUgd2l0aCBVSVxyXG4gICAgLy8gU2VuZGluZyB0aGlzIG1lc3NhZ2UgYWZ0ZXIgbG9naW4gaXMgY29tcGxldGVkIGhlbHBzIHRvIGVuc3VyZSB0aGF0IGluY29tcGxldGUgc3RhdGUgd2l0aG91dFxyXG4gICAgLy8gYWNjb3VudCBkZXRhaWxzIGFyZSBub3QgZmx1c2hlZCB0byBVSS5cclxuICAgIHRoaXMuZW1pdCgnc3RhcnRVSVN5bmMnKTtcclxuICAgIHRoaXMuc3RhcnRVSVN5bmMgPSB0cnVlO1xyXG4gICAgdGhpcy5tZW1TdG9yZS5zdWJzY3JpYmUodGhpcy5zZW5kVXBkYXRlLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3VibWl0cyBhIHVzZXIncyBlbmNyeXB0aW9uIGtleSB0byBsb2cgdGhlIHVzZXIgaW4gdmlhIGxvZ2luIHRva2VuXHJcbiAgICovXHJcbiAgYXN5bmMgc3VibWl0RW5jcnlwdGlvbktleSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgbG9naW5Ub2tlbiwgbG9naW5TYWx0IH0gPVxyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0ZW5zaW9uLnN0b3JhZ2Uuc2Vzc2lvbi5nZXQoWydsb2dpblRva2VuJywgJ2xvZ2luU2FsdCddKTtcclxuICAgICAgaWYgKGxvZ2luVG9rZW4gJiYgbG9naW5TYWx0KSB7XHJcbiAgICAgICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgICBjb25zdCBqc29uVmF1bHQgPSBKU09OLnBhcnNlKHZhdWx0KTtcclxuXHJcbiAgICAgICAgaWYgKGpzb25WYXVsdC5zYWx0ICE9PSBsb2dpblNhbHQpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgJ3N1Ym1pdEVuY3J5cHRpb25LZXk6IFN0b3JlZCBzYWx0IGFuZCB2YXVsdCBzYWx0IGRvIG5vdCBtYXRjaCcsXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5jbGVhckxvZ2luQXJ0aWZhY3RzKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnN1Ym1pdEVuY3J5cHRpb25LZXkobG9naW5Ub2tlbiwgbG9naW5TYWx0KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBJZiBzb21laG93IHRoaXMgbG9naW4gdG9rZW4gZG9lc24ndCB3b3JrIHByb3Blcmx5LFxyXG4gICAgICAvLyByZW1vdmUgaXQgYW5kIHRoZSB1c2VyIHdpbGwgZ2V0IHNob3duIGJhY2sgdG8gdGhlIHVubG9jayBzY3JlZW5cclxuICAgICAgYXdhaXQgdGhpcy5jbGVhckxvZ2luQXJ0aWZhY3RzKCk7XHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBjbGVhckxvZ2luQXJ0aWZhY3RzKCkge1xyXG4gICAgYXdhaXQgdGhpcy5leHRlbnNpb24uc3RvcmFnZS5zZXNzaW9uLnJlbW92ZShbJ2xvZ2luVG9rZW4nLCAnbG9naW5TYWx0J10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3VibWl0cyBhIHVzZXIncyBwYXNzd29yZCB0byBjaGVjayBpdHMgdmFsaWRpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgdXNlcidzIHBhc3N3b3JkXHJcbiAgICovXHJcbiAgYXN5bmMgdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpIHtcclxuICAgIGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIudmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUgSWRlbnRpdHlcclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBhY2NvdW50IG5pY2tuYW1lLlxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFjY291bnQncyBldGhlcmV1bSBhZGRyZXNzLCBpbiBsb3dlciBjYXNlLlxyXG4gICAqIHJlY2VpdmluZyBmdW5kcyBmcm9tIG91ciBhdXRvbWF0aWMgUm9wc3RlbiBmYXVjZXQuXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGZpcnN0IGFkZHJlc3MgaW4gdGhlIHN0YXRlIHRvIHRoZSBzZWxlY3RlZCBhZGRyZXNzXHJcbiAgICovXHJcbiAgc2VsZWN0Rmlyc3RJZGVudGl0eSgpIHtcclxuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IFthZGRyZXNzXSA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpO1xyXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbW5lbW9uaWMgb2YgdGhlIHVzZXIncyBwcmltYXJ5IGtleXJpbmcuXHJcbiAgICovXHJcbiAgZ2V0UHJpbWFyeUtleXJpbmdNbmVtb25pYygpIHtcclxuICAgIGNvbnN0IFtrZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXHJcbiAgICAgIEtleXJpbmdUeXBlLmhkS2V5VHJlZSxcclxuICAgICk7XHJcbiAgICBpZiAoIWtleXJpbmcubW5lbW9uaWMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmltYXJ5IGtleXJpbmcgbW5lbW9uaWMgdW5hdmFpbGFibGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGtleXJpbmcubW5lbW9uaWM7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIEhhcmR3YXJlXHJcbiAgLy9cclxuXHJcbiAgYXN5bmMgZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lLCBoZFBhdGggPSBudWxsKSB7XHJcbiAgICBjb25zdCBrZXlyaW5nT3ZlcnJpZGVzID0gdGhpcy5vcHRzLm92ZXJyaWRlcz8ua2V5cmluZ3M7XHJcbiAgICBsZXQga2V5cmluZ05hbWUgPSBudWxsO1xyXG4gICAgaWYgKFxyXG4gICAgICBkZXZpY2VOYW1lICE9PSBIYXJkd2FyZURldmljZU5hbWVzLlFSICYmXHJcbiAgICAgICF0aGlzLmNhblVzZUhhcmR3YXJlV2FsbGV0cygpXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXJkd2FyZSB3YWxsZXRzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgdmVyc2lvbi4nKTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoZGV2aWNlTmFtZSkge1xyXG4gICAgICBjYXNlIEhhcmR3YXJlRGV2aWNlTmFtZXMudHJlem9yOlxyXG4gICAgICAgIGtleXJpbmdOYW1lID0ga2V5cmluZ092ZXJyaWRlcz8udHJlem9yPy50eXBlIHx8IFRyZXpvcktleXJpbmcudHlwZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBIYXJkd2FyZURldmljZU5hbWVzLmxlZGdlcjpcclxuICAgICAgICBrZXlyaW5nTmFtZSA9XHJcbiAgICAgICAgICBrZXlyaW5nT3ZlcnJpZGVzPy5sZWRnZXI/LnR5cGUgfHwgTGVkZ2VyQnJpZGdlS2V5cmluZy50eXBlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIEhhcmR3YXJlRGV2aWNlTmFtZXMucXI6XHJcbiAgICAgICAga2V5cmluZ05hbWUgPSBRUkhhcmR3YXJlS2V5cmluZy50eXBlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIEhhcmR3YXJlRGV2aWNlTmFtZXMubGF0dGljZTpcclxuICAgICAgICBrZXlyaW5nTmFtZSA9IGtleXJpbmdPdmVycmlkZXM/LmxhdHRpY2U/LnR5cGUgfHwgTGF0dGljZUtleXJpbmcudHlwZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAnTWV0YW1hc2tDb250cm9sbGVyOmdldEtleXJpbmdGb3JEZXZpY2UgLSBVbmtub3duIGRldmljZScsXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGxldCBba2V5cmluZ10gPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKGtleXJpbmdOYW1lKTtcclxuICAgIGlmICgha2V5cmluZykge1xyXG4gICAgICBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5hZGROZXdLZXlyaW5nKGtleXJpbmdOYW1lKTtcclxuICAgIH1cclxuICAgIGlmIChoZFBhdGggJiYga2V5cmluZy5zZXRIZFBhdGgpIHtcclxuICAgICAga2V5cmluZy5zZXRIZFBhdGgoaGRQYXRoKTtcclxuICAgIH1cclxuICAgIGlmIChkZXZpY2VOYW1lID09PSBIYXJkd2FyZURldmljZU5hbWVzLmxhdHRpY2UpIHtcclxuICAgICAga2V5cmluZy5hcHBOYW1lID0gJ01ldGFNYXNrJztcclxuICAgIH1cclxuICAgIGlmIChkZXZpY2VOYW1lID09PSBIYXJkd2FyZURldmljZU5hbWVzLnRyZXpvcikge1xyXG4gICAgICBjb25zdCBtb2RlbCA9IGtleXJpbmcuZ2V0TW9kZWwoKTtcclxuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc2V0VHJlem9yTW9kZWwobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGtleXJpbmcubmV0d29yayA9XHJcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy50eXBlO1xyXG5cclxuICAgIHJldHVybiBrZXlyaW5nO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uKCkge1xyXG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShIYXJkd2FyZURldmljZU5hbWVzLmxlZGdlcik7XHJcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5hdHRlbXB0TWFrZUFwcCgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXN0YWJsaXNoTGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcclxuICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPVxyXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydFByZWZlcmVuY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmV0Y2ggYWNjb3VudCBsaXN0IGZyb20gYSB0cmV6b3IgZGV2aWNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRldmljZU5hbWVcclxuICAgKiBAcGFyYW0gcGFnZVxyXG4gICAqIEBwYXJhbSBoZFBhdGhcclxuICAgKiBAcmV0dXJucyBbXSBhY2NvdW50c1xyXG4gICAqL1xyXG4gIGFzeW5jIGNvbm5lY3RIYXJkd2FyZShkZXZpY2VOYW1lLCBwYWdlLCBoZFBhdGgpIHtcclxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcclxuICAgIGxldCBhY2NvdW50cyA9IFtdO1xyXG4gICAgc3dpdGNoIChwYWdlKSB7XHJcbiAgICAgIGNhc2UgLTE6XHJcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldFByZXZpb3VzUGFnZSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldE5leHRQYWdlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEZpcnN0UGFnZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgYWNjb3VudHNcclxuICAgIC8vIGFuZCBtYWtlIHN1cmUgYWRkcmVzc2VzIGFyZSBub3QgcmVwZWF0ZWRcclxuICAgIGNvbnN0IG9sZEFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xyXG4gICAgY29uc3QgYWNjb3VudHNUb1RyYWNrID0gW1xyXG4gICAgICAuLi5uZXcgU2V0KFxyXG4gICAgICAgIG9sZEFjY291bnRzLmNvbmNhdChhY2NvdW50cy5tYXAoKGEpID0+IGEuYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSksXHJcbiAgICAgICksXHJcbiAgICBdO1xyXG4gICAgdGhpcy5hY2NvdW50VHJhY2tlci5zeW5jV2l0aEFkZHJlc3NlcyhhY2NvdW50c1RvVHJhY2spO1xyXG4gICAgcmV0dXJuIGFjY291bnRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGRldmljZSBpcyB1bmxvY2tlZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRldmljZU5hbWVcclxuICAgKiBAcGFyYW0gaGRQYXRoXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XHJcbiAgICovXHJcbiAgYXN5bmMgY2hlY2tIYXJkd2FyZVN0YXR1cyhkZXZpY2VOYW1lLCBoZFBhdGgpIHtcclxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcclxuICAgIHJldHVybiBrZXlyaW5nLmlzVW5sb2NrZWQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGV2aWNlTmFtZVxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxyXG4gICAqL1xyXG4gIGFzeW5jIGZvcmdldERldmljZShkZXZpY2VOYW1lKSB7XHJcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKGRldmljZU5hbWUpO1xyXG4gICAga2V5cmluZy5mb3JnZXREZXZpY2UoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHRoZSBrZXlyaW5nIGZvciB0aGUgc2VsZWN0ZWQgYWRkcmVzcyBhbmQgdXNpbmcgdGhlIC50eXBlIHJldHVybnNcclxuICAgKiBhIHN1YnR5cGUgZm9yIHRoZSBhY2NvdW50LiBFaXRoZXIgJ2hhcmR3YXJlJywgJ2ltcG9ydGVkJyBvciAnTWV0YU1hc2snLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBZGRyZXNzIHRvIHJldHJpZXZlIGtleXJpbmcgZm9yXHJcbiAgICogQHJldHVybnMgeydoYXJkd2FyZScgfCAnaW1wb3J0ZWQnIHwgJ01ldGFNYXNrJ31cclxuICAgKi9cclxuICBhc3luYyBnZXRBY2NvdW50VHlwZShhZGRyZXNzKSB7XHJcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcclxuICAgIHN3aXRjaCAoa2V5cmluZy50eXBlKSB7XHJcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUudHJlem9yOlxyXG4gICAgICBjYXNlIEtleXJpbmdUeXBlLmxhdHRpY2U6XHJcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUucXI6XHJcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUubGVkZ2VyOlxyXG4gICAgICAgIHJldHVybiAnaGFyZHdhcmUnO1xyXG4gICAgICBjYXNlIEtleXJpbmdUeXBlLmltcG9ydGVkOlxyXG4gICAgICAgIHJldHVybiAnaW1wb3J0ZWQnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAnTWV0YU1hc2snO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHRoZSBrZXlyaW5nIGZvciB0aGUgc2VsZWN0ZWQgYWRkcmVzcyBhbmQgdXNpbmcgdGhlIC50eXBlXHJcbiAgICogZGV0ZXJtaW5lcyBpZiBhIG1vcmUgc3BlY2lmaWMgbmFtZSBmb3IgdGhlIGRldmljZSBpcyBhdmFpbGFibGUuIFJldHVybnNcclxuICAgKiAnTi9BJyBmb3Igbm9uIGhhcmR3YXJlIHdhbGxldHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFkZHJlc3MgdG8gcmV0cmlldmUga2V5cmluZyBmb3JcclxuICAgKiBAcmV0dXJucyB7J2xlZGdlcicgfCAnbGF0dGljZScgfCAnTi9BJyB8IHN0cmluZ31cclxuICAgKi9cclxuICBhc3luYyBnZXREZXZpY2VNb2RlbChhZGRyZXNzKSB7XHJcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcclxuICAgIHN3aXRjaCAoa2V5cmluZy50eXBlKSB7XHJcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUudHJlem9yOlxyXG4gICAgICAgIHJldHVybiBrZXlyaW5nLmdldE1vZGVsKCk7XHJcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUucXI6XHJcbiAgICAgICAgcmV0dXJuIGtleXJpbmcuZ2V0TmFtZSgpO1xyXG4gICAgICBjYXNlIEtleXJpbmdUeXBlLmxlZGdlcjpcclxuICAgICAgICAvLyBUT0RPOiBnZXQgbW9kZWwgYWZ0ZXIgbGVkZ2VyIGtleXJpbmcgZXhwb3NlcyBtZXRob2RcclxuICAgICAgICByZXR1cm4gSGFyZHdhcmVEZXZpY2VOYW1lcy5sZWRnZXI7XHJcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUubGF0dGljZTpcclxuICAgICAgICAvLyBUT0RPOiBnZXQgbW9kZWwgYWZ0ZXIgbGF0dGljZSBrZXlyaW5nIGV4cG9zZXMgbWV0aG9kXHJcbiAgICAgICAgcmV0dXJuIEhhcmR3YXJlRGV2aWNlTmFtZXMubGF0dGljZTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gJ04vQSc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBnZXQgaGFyZHdhcmUgYWNjb3VudCBsYWJlbFxyXG4gICAqXHJcbiAgICogQHJldHVybnMgc3RyaW5nIGxhYmVsXHJcbiAgICovXHJcblxyXG4gIGdldEFjY291bnRMYWJlbChuYW1lLCBpbmRleCwgaGRQYXRoRGVzY3JpcHRpb24pIHtcclxuICAgIHJldHVybiBgJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCl9JHtuYW1lLnNsaWNlKDEpfSAke1xyXG4gICAgICBwYXJzZUludChpbmRleCwgMTApICsgMVxyXG4gICAgfSAke2hkUGF0aERlc2NyaXB0aW9uIHx8ICcnfWAudHJpbSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wb3J0cyBhbiBhY2NvdW50IGZyb20gYSBUcmV6b3Igb3IgTGVkZ2VyIGRldmljZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpbmRleFxyXG4gICAqIEBwYXJhbSBkZXZpY2VOYW1lXHJcbiAgICogQHBhcmFtIGhkUGF0aFxyXG4gICAqIEBwYXJhbSBoZFBhdGhEZXNjcmlwdGlvblxyXG4gICAqIEByZXR1cm5zIHt9IGtleVN0YXRlXHJcbiAgICovXHJcbiAgYXN5bmMgdW5sb2NrSGFyZHdhcmVXYWxsZXRBY2NvdW50KFxyXG4gICAgaW5kZXgsXHJcbiAgICBkZXZpY2VOYW1lLFxyXG4gICAgaGRQYXRoLFxyXG4gICAgaGRQYXRoRGVzY3JpcHRpb24sXHJcbiAgKSB7XHJcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKGRldmljZU5hbWUsIGhkUGF0aCk7XHJcblxyXG4gICAga2V5cmluZy5zZXRBY2NvdW50VG9VbmxvY2soaW5kZXgpO1xyXG4gICAgY29uc3Qgb2xkQWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XHJcbiAgICBjb25zdCBrZXlTdGF0ZSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChrZXlyaW5nKTtcclxuICAgIGNvbnN0IG5ld0FjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xyXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKG5ld0FjY291bnRzKTtcclxuICAgIG5ld0FjY291bnRzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcclxuICAgICAgaWYgKCFvbGRBY2NvdW50cy5pbmNsdWRlcyhhZGRyZXNzKSkge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRBY2NvdW50TGFiZWwoXHJcbiAgICAgICAgICBkZXZpY2VOYW1lID09PSBIYXJkd2FyZURldmljZU5hbWVzLnFyXHJcbiAgICAgICAgICAgID8ga2V5cmluZy5nZXROYW1lKClcclxuICAgICAgICAgICAgOiBkZXZpY2VOYW1lLFxyXG4gICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICBoZFBhdGhEZXNjcmlwdGlvbixcclxuICAgICAgICApO1xyXG4gICAgICAgIC8vIFNldCB0aGUgYWNjb3VudCBsYWJlbCB0byBUcmV6b3IgMSAvICBMZWRnZXIgMSAvIFFSIEhhcmR3YXJlIDEsIGV0Y1xyXG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFjY291bnRMYWJlbChhZGRyZXNzLCBsYWJlbCk7XHJcbiAgICAgICAgLy8gU2VsZWN0IHRoZSBhY2NvdW50XHJcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICByZXR1cm4geyAuLi5rZXlTdGF0ZSwgaWRlbnRpdGllcyB9O1xyXG4gIH1cclxuXHJcbiAgLy9cclxuICAvLyBBY2NvdW50IE1hbmFnZW1lbnRcclxuICAvL1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbmV3IGFjY291bnQgdG8gdGhlIGRlZmF1bHQgKGZpcnN0KSBIRCBzZWVkIHBocmFzZSBLZXlyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFjY291bnRDb3VudFxyXG4gICAqIEByZXR1cm5zIHt9IGtleVN0YXRlXHJcbiAgICovXHJcbiAgYXN5bmMgYWRkTmV3QWNjb3VudChhY2NvdW50Q291bnQpIHtcclxuICAgIGNvbnN0IGlzQWN0aW9uTWV0cmljc1F1ZXVlRTJFVGVzdCA9XHJcbiAgICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKClbQUNUSU9OX1FVRVVFX01FVFJJQ1NfRTJFX1RFU1RdO1xyXG5cclxuICAgIGlmIChwcm9jZXNzLmVudi5JTl9URVNUICYmIGlzQWN0aW9uTWV0cmljc1F1ZXVlRTJFVGVzdCkge1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1XzAwMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFtwcmltYXJ5S2V5cmluZ10gPSB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxyXG4gICAgICBLZXlyaW5nVHlwZS5oZEtleVRyZWUsXHJcbiAgICApO1xyXG4gICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFtYXNrQ29udHJvbGxlciAtIE5vIEhEIEtleSBUcmVlIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGtleXJpbmdDb250cm9sbGVyIH0gPSB0aGlzO1xyXG4gICAgY29uc3QgeyBpZGVudGl0aWVzOiBvbGRJZGVudGl0aWVzIH0gPVxyXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgIGlmIChPYmplY3Qua2V5cyhvbGRJZGVudGl0aWVzKS5sZW5ndGggPT09IGFjY291bnRDb3VudCkge1xyXG4gICAgICBjb25zdCBvbGRBY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XHJcbiAgICAgIGNvbnN0IGtleVN0YXRlID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XHJcbiAgICAgIGNvbnN0IG5ld0FjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMudmVyaWZ5U2VlZFBocmFzZSgpO1xyXG5cclxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKG5ld0FjY291bnRzKTtcclxuICAgICAgbmV3QWNjb3VudHMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xyXG4gICAgICAgIGlmICghb2xkQWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcclxuICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFNlbGVjdGVkQWRkcmVzcyhhZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICByZXR1cm4geyAuLi5rZXlTdGF0ZSwgaWRlbnRpdGllcyB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLmtleXJpbmdDb250cm9sbGVyLm1lbVN0b3JlLmdldFN0YXRlKCksXHJcbiAgICAgIGlkZW50aXRpZXM6IG9sZElkZW50aXRpZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmVyaWZpZXMgdGhlIHZhbGlkaXR5IG9mIHRoZSBjdXJyZW50IHZhdWx0J3Mgc2VlZCBwaHJhc2UuXHJcbiAgICpcclxuICAgKiBWYWxpZGl0eTogc2VlZCBwaHJhc2UgcmVzdG9yZXMgdGhlIGFjY291bnRzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCB2YXVsdC5cclxuICAgKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSBmaXJzdCBhY2NvdW50IGlzIGNyZWF0ZWQgYW5kIG9uIHVubG9ja2luZyB0aGUgdmF1bHQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXJbXT59IFRoZSBzZWVkIHBocmFzZSB0byBiZSBjb25maXJtZWQgYnkgdGhlIHVzZXIsXHJcbiAgICogZW5jb2RlZCBhcyBhbiBhcnJheSBvZiBVVEYtOCBieXRlcy5cclxuICAgKi9cclxuICBhc3luYyB2ZXJpZnlTZWVkUGhyYXNlKCkge1xyXG4gICAgY29uc3QgW3ByaW1hcnlLZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXHJcbiAgICAgIEtleXJpbmdUeXBlLmhkS2V5VHJlZSxcclxuICAgICk7XHJcbiAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gSEQgS2V5IFRyZWUgZm91bmQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZXJpYWxpemVkID0gYXdhaXQgcHJpbWFyeUtleXJpbmcuc2VyaWFsaXplKCk7XHJcbiAgICBjb25zdCBzZWVkUGhyYXNlQXNCdWZmZXIgPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkLm1uZW1vbmljKTtcclxuXHJcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByaW1hcnlLZXlyaW5nLmdldEFjY291bnRzKCk7XHJcbiAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDwgMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFtYXNrQ29udHJvbGxlciAtIE5vIGFjY291bnRzIGZvdW5kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgc2VlZFBocmFzZVZlcmlmaWVyLnZlcmlmeUFjY291bnRzKGFjY291bnRzLCBzZWVkUGhyYXNlQXNCdWZmZXIpO1xyXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShzZWVkUGhyYXNlQXNCdWZmZXIudmFsdWVzKCkpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGxvZy5lcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFycyB0aGUgdHJhbnNhY3Rpb24gaGlzdG9yeSwgdG8gYWxsb3cgdXNlcnMgdG8gZm9yY2UtcmVzZXQgdGhlaXIgbm9uY2VzLlxyXG4gICAqIE1vc3RseSB1c2VkIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cywgd2hlbiBuZXR3b3JrcyBhcmUgcmVzdGFydGVkIHdpdGhcclxuICAgKiB0aGUgc2FtZSBuZXR3b3JrIElELlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIGN1cnJlbnQgc2VsZWN0ZWQgYWRkcmVzcy5cclxuICAgKi9cclxuICBhc3luYyByZXNldEFjY291bnQoKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRTZWxlY3RlZEFkZHJlc3MoKTtcclxuICAgIHRoaXMudHhDb250cm9sbGVyLndpcGVUcmFuc2FjdGlvbnMoc2VsZWN0ZWRBZGRyZXNzKTtcclxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIucmVzZXRDb25uZWN0aW9uKCk7XHJcblxyXG4gICAgcmV0dXJuIHNlbGVjdGVkQWRkcmVzcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBlcm1pdHRlZCBhY2NvdW50cyBmb3IgdGhlIHNwZWNpZmllZCBvcmlnaW4uIFJldHVybnMgYW4gZW1wdHlcclxuICAgKiBhcnJheSBpZiBubyBhY2NvdW50cyBhcmUgcGVybWl0dGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gd2hvc2UgZXhwb3NlZCBhY2NvdW50cyB0byByZXRyaWV2ZS5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdXBwcmVzc1VuYXV0aG9yaXplZEVycm9yXSAtIFN1cHByZXNzZXMgdGhlIHVuYXV0aG9yaXplZCBlcnJvci5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IFRoZSBvcmlnaW4ncyBwZXJtaXR0ZWQgYWNjb3VudHMsIG9yIGFuIGVtcHR5XHJcbiAgICogYXJyYXkuXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0UGVybWl0dGVkQWNjb3VudHMoXHJcbiAgICBvcmlnaW4sXHJcbiAgICB7IHN1cHByZXNzVW5hdXRob3JpemVkRXJyb3IgPSB0cnVlIH0gPSB7fSxcclxuICApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kKFxyXG4gICAgICAgIG9yaWdpbixcclxuICAgICAgICBSZXN0cmljdGVkTWV0aG9kcy5ldGhfYWNjb3VudHMsXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgc3VwcHJlc3NVbmF1dGhvcml6ZWRFcnJvciAmJlxyXG4gICAgICAgIGVycm9yLmNvZGUgPT09IHJwY0Vycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIGV4cG9zaW5nIHRoZSBhY2NvdW50IHdpdGggdGhlIHNwZWNpZmllZCBhZGRyZXNzIHRvIGFsbCB0aGlyZCBwYXJ0aWVzLlxyXG4gICAqIEV4cG9zZWQgYWNjb3VudHMgYXJlIHN0b3JlZCBpbiBjYXZlYXRzIG9mIHRoZSBldGhfYWNjb3VudHMgcGVybWlzc2lvbi4gVGhpc1xyXG4gICAqIG1ldGhvZCB1c2VzIGBQZXJtaXNzaW9uQ29udHJvbGxlci51cGRhdGVQZXJtaXNzaW9uc0J5Q2F2ZWF0YCB0b1xyXG4gICAqIHJlbW92ZSB0aGUgc3BlY2lmaWVkIGFkZHJlc3MgZnJvbSBldmVyeSBldGhfYWNjb3VudHMgcGVybWlzc2lvbi4gSWYgYVxyXG4gICAqIHBlcm1pc3Npb24gb25seSBpbmNsdWRlZCB0aGlzIGFkZHJlc3MsIHRoZSBwZXJtaXNzaW9uIGlzIHJldm9rZWQgZW50aXJlbHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0QWNjb3VudCAtIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIHN0b3AgZXhwb3NpbmdcclxuICAgKiB0byB0aGlyZCBwYXJ0aWVzLlxyXG4gICAqL1xyXG4gIHJlbW92ZUFsbEFjY291bnRQZXJtaXNzaW9ucyh0YXJnZXRBY2NvdW50KSB7XHJcbiAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQoXHJcbiAgICAgIENhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50cyxcclxuICAgICAgKGV4aXN0aW5nQWNjb3VudHMpID0+XHJcbiAgICAgICAgQ2F2ZWF0TXV0YXRvckZhY3Rvcmllc1tcclxuICAgICAgICAgIENhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50c1xyXG4gICAgICAgIF0ucmVtb3ZlQWNjb3VudCh0YXJnZXRBY2NvdW50LCBleGlzdGluZ0FjY291bnRzKSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFuIGFjY291bnQgZnJvbSBzdGF0ZSAvIHN0b3JhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzIC0gQSBoZXggYWRkcmVzc1xyXG4gICAqL1xyXG4gIGFzeW5jIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xyXG4gICAgLy8gUmVtb3ZlIGFsbCBhc3NvY2lhdGVkIHBlcm1pc3Npb25zXHJcbiAgICB0aGlzLnJlbW92ZUFsbEFjY291bnRQZXJtaXNzaW9ucyhhZGRyZXNzKTtcclxuICAgIC8vIFJlbW92ZSBhY2NvdW50IGZyb20gdGhlIHByZWZlcmVuY2VzIGNvbnRyb2xsZXJcclxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnJlbW92ZUFkZHJlc3MoYWRkcmVzcyk7XHJcbiAgICAvLyBSZW1vdmUgYWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IHRyYWNrZXIgY29udHJvbGxlclxyXG4gICAgdGhpcy5hY2NvdW50VHJhY2tlci5yZW1vdmVBY2NvdW50KFthZGRyZXNzXSk7XHJcblxyXG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XHJcbiAgICAvLyBSZW1vdmUgYWNjb3VudCBmcm9tIHRoZSBrZXlyaW5nXHJcbiAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnJlbW92ZUFjY291bnQoYWRkcmVzcyk7XHJcbiAgICBjb25zdCB1cGRhdGVkS2V5cmluZ0FjY291bnRzID0ga2V5cmluZyA/IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKSA6IHt9O1xyXG4gICAgaWYgKHVwZGF0ZWRLZXlyaW5nQWNjb3VudHM/Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBrZXlyaW5nLmRlc3Ryb3k/LigpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhZGRyZXNzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wb3J0cyBhbiBhY2NvdW50IHdpdGggdGhlIHNwZWNpZmllZCBpbXBvcnQgc3RyYXRlZ3kuXHJcbiAgICogVGhlc2UgYXJlIGRlZmluZWQgaW4gYXBwL3NjcmlwdHMvYWNjb3VudC1pbXBvcnQtc3RyYXRlZ2llc1xyXG4gICAqIEVhY2ggc3RyYXRlZ3kgcmVwcmVzZW50cyBhIGRpZmZlcmVudCB3YXkgb2Ygc2VyaWFsaXppbmcgYW4gRXRoZXJldW0ga2V5IHBhaXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyYXRlZ3kgLSBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBhbiBhY2NvdW50IGltcG9ydCBzdHJhdGVneS5cclxuICAgKiBAcGFyYW0ge2FueX0gYXJncyAtIFRoZSBkYXRhIHJlcXVpcmVkIGJ5IHRoYXQgc3RyYXRlZ3kgdG8gaW1wb3J0IGFuIGFjY291bnQuXHJcbiAgICovXHJcbiAgYXN5bmMgaW1wb3J0QWNjb3VudFdpdGhTdHJhdGVneShzdHJhdGVneSwgYXJncykge1xyXG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IGFjY291bnRJbXBvcnRlci5pbXBvcnRBY2NvdW50KHN0cmF0ZWd5LCBhcmdzKTtcclxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmFkZE5ld0tleXJpbmcoXHJcbiAgICAgIEtleXJpbmdUeXBlLmltcG9ydGVkLFxyXG4gICAgICBbcHJpdmF0ZUtleV0sXHJcbiAgICApO1xyXG4gICAgY29uc3QgW2ZpcnN0QWNjb3VudF0gPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XHJcbiAgICAvLyB1cGRhdGUgYWNjb3VudHMgaW4gcHJlZmVyZW5jZXMgY29udHJvbGxlclxyXG4gICAgY29uc3QgYWxsQWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XHJcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoYWxsQWNjb3VudHMpO1xyXG4gICAgLy8gc2V0IG5ldyBhY2NvdW50IGFzIHNlbGVjdGVkXHJcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRTZWxlY3RlZEFkZHJlc3MoZmlyc3RBY2NvdW50KTtcclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIElkZW50aXR5IE1hbmFnZW1lbnQgKHNpZ25hdHVyZSBvcGVyYXRpb25zKVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBhIERhcHAgc3VnZ2VzdHMgYSBuZXcgdHggdG8gYmUgc2lnbmVkLlxyXG4gICAqIHRoaXMgd3JhcHBlciBuZWVkcyB0byBleGlzdCBzbyB3ZSBjYW4gcHJvdmlkZSBhIHJlZmVyZW5jZSB0b1xyXG4gICAqICBcIm5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvblwiIGJlZm9yZSBcInR4Q29udHJvbGxlclwiIGlzIGluc3RhbnRpYXRlZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHR4UGFyYW1zIC0gVGhlIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnMuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3QsIGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cclxuICAgKi9cclxuICBhc3luYyBuZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXlyaW5nIHR5cGUgc3VwcG9ydHMgRUlQLTE1NTlcclxuICAgKi9cclxuICBhc3luYyBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5KCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gRU5EIChWQVVMVCAvIEtFWVJJTkcgUkVMQVRFRCBNRVRIT0RTKVxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIGEgdXNlciB0byBhdHRlbXB0IHRvIGNhbmNlbCBhIHByZXZpb3VzbHkgc3VibWl0dGVkIHRyYW5zYWN0aW9uXHJcbiAgICogYnkgY3JlYXRpbmcgYSBuZXcgdHJhbnNhY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luYWxUeElkIC0gdGhlIGlkIG9mIHRoZSB0eE1ldGEgdGhhdCB5b3Ugd2FudCB0b1xyXG4gICAqICBhdHRlbXB0IHRvIGNhbmNlbFxyXG4gICAqIEBwYXJhbSB7aW1wb3J0KFxyXG4gICAqICAnLi9jb250cm9sbGVycy90cmFuc2FjdGlvbnMnXHJcbiAgICogKS5DdXN0b21HYXNTZXR0aW5nc30gW2N1c3RvbUdhc1NldHRpbmdzXSAtIG92ZXJyaWRlcyB0byB1c2UgZm9yIGdhcyBwYXJhbXNcclxuICAgKiAgaW5zdGVhZCBvZiBhbGxvd2luZyB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB0aGVtXHJcbiAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBNZXRhTWFzayBzdGF0ZVxyXG4gICAqL1xyXG4gIGFzeW5jIGNyZWF0ZUNhbmNlbFRyYW5zYWN0aW9uKG9yaWdpbmFsVHhJZCwgY3VzdG9tR2FzU2V0dGluZ3MsIG9wdGlvbnMpIHtcclxuICAgIGF3YWl0IHRoaXMudHhDb250cm9sbGVyLmNyZWF0ZUNhbmNlbFRyYW5zYWN0aW9uKFxyXG4gICAgICBvcmlnaW5hbFR4SWQsXHJcbiAgICAgIGN1c3RvbUdhc1NldHRpbmdzLFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIGEgdXNlciB0byBhdHRlbXB0IHRvIHNwZWVkIHVwIGEgcHJldmlvdXNseSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25cclxuICAgKiBieSBjcmVhdGluZyBhIG5ldyB0cmFuc2FjdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5hbFR4SWQgLSB0aGUgaWQgb2YgdGhlIHR4TWV0YSB0aGF0IHlvdSB3YW50IHRvXHJcbiAgICogIGF0dGVtcHQgdG8gc3BlZWQgdXBcclxuICAgKiBAcGFyYW0ge2ltcG9ydChcclxuICAgKiAgJy4vY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zJ1xyXG4gICAqICkuQ3VzdG9tR2FzU2V0dGluZ3N9IFtjdXN0b21HYXNTZXR0aW5nc10gLSBvdmVycmlkZXMgdG8gdXNlIGZvciBnYXMgcGFyYW1zXHJcbiAgICogIGluc3RlYWQgb2YgYWxsb3dpbmcgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgdGhlbVxyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICogQHJldHVybnMge29iamVjdH0gTWV0YU1hc2sgc3RhdGVcclxuICAgKi9cclxuICBhc3luYyBjcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb24ob3JpZ2luYWxUeElkLCBjdXN0b21HYXNTZXR0aW5ncywgb3B0aW9ucykge1xyXG4gICAgYXdhaXQgdGhpcy50eENvbnRyb2xsZXIuY3JlYXRlU3BlZWRVcFRyYW5zYWN0aW9uKFxyXG4gICAgICBvcmlnaW5hbFR4SWQsXHJcbiAgICAgIGN1c3RvbUdhc1NldHRpbmdzLFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgZXN0aW1hdGVHYXMoZXN0aW1hdGVHYXNQYXJhbXMpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnR4Q29udHJvbGxlci50eEdhc1V0aWwucXVlcnkuZXN0aW1hdGVHYXMoXHJcbiAgICAgICAgZXN0aW1hdGVHYXNQYXJhbXMsXHJcbiAgICAgICAgKGVyciwgcmVzKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gUEFTU1dPUkQgTUFOQUdFTUVOVFxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIGEgdXNlciB0byBiZWdpbiB0aGUgc2VlZCBwaHJhc2UgcmVjb3ZlcnkgcHJvY2Vzcy5cclxuICAgKi9cclxuICBtYXJrUGFzc3dvcmRGb3Jnb3R0ZW4oKSB7XHJcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRQYXNzd29yZEZvcmdvdHRlbih0cnVlKTtcclxuICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIGEgdXNlciB0byBlbmQgdGhlIHNlZWQgcGhyYXNlIHJlY292ZXJ5IHByb2Nlc3MuXHJcbiAgICovXHJcbiAgdW5NYXJrUGFzc3dvcmRGb3Jnb3R0ZW4oKSB7XHJcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRQYXNzd29yZEZvcmdvdHRlbihmYWxzZSk7XHJcbiAgICB0aGlzLnNlbmRVcGRhdGUoKTtcclxuICB9XHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBTRVRVUFxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBydW50aW1lLk1lc3NhZ2VTZW5kZXIgb2JqZWN0LCBhcyBwcm92aWRlZCBieSB0aGUgYnJvd3NlcjpcclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9NZXNzYWdlU2VuZGVyXHJcbiAgICogQHR5cGVkZWYge29iamVjdH0gTWVzc2FnZVNlbmRlclxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAtIFRoZSBVUkwgb2YgdGhlIHBhZ2Ugb3IgZnJhbWUgaG9zdGluZyB0aGUgc2NyaXB0IHRoYXQgc2VudCB0aGUgbWVzc2FnZS5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQSBTbmFwIHNlbmRlciBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBTbmFwU2VuZGVyXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNuYXBJZCAtIFRoZSBJRCBvZiB0aGUgc25hcC5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBjcmVhdGUgYSBtdWx0aXBsZXhlZCBzdHJlYW0gZm9yIGNvbm5lY3RpbmcgdG8gYW4gdW50cnVzdGVkIGNvbnRleHRcclxuICAgKiBsaWtlIGEgRGFwcCBvciBvdGhlciBleHRlbnNpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxyXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW19IG9wdGlvbnMuY29ubmVjdGlvblN0cmVhbSAtIFRoZSBEdXBsZXggc3RyZWFtIHRvIGNvbm5lY3QgdG8uXHJcbiAgICogQHBhcmFtIHtNZXNzYWdlU2VuZGVyIHwgU25hcFNlbmRlcn0gb3B0aW9ucy5zZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlcyBvbiB0aGlzIHN0cmVhbS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ViamVjdFR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIHNlbmRlciwgaS5lLiBzdWJqZWN0LlxyXG4gICAqL1xyXG4gIHNldHVwVW50cnVzdGVkQ29tbXVuaWNhdGlvbih7IGNvbm5lY3Rpb25TdHJlYW0sIHNlbmRlciwgc3ViamVjdFR5cGUgfSkge1xyXG4gICAgY29uc3QgeyB1c2VQaGlzaERldGVjdCB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICBsZXQgX3N1YmplY3RUeXBlO1xyXG4gICAgaWYgKHN1YmplY3RUeXBlKSB7XHJcbiAgICAgIF9zdWJqZWN0VHlwZSA9IHN1YmplY3RUeXBlO1xyXG4gICAgfSBlbHNlIGlmIChzZW5kZXIuaWQgJiYgc2VuZGVyLmlkICE9PSB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLmlkKSB7XHJcbiAgICAgIF9zdWJqZWN0VHlwZSA9IFN1YmplY3RUeXBlLkV4dGVuc2lvbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9zdWJqZWN0VHlwZSA9IFN1YmplY3RUeXBlLldlYnNpdGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbmRlci51cmwpIHtcclxuICAgICAgY29uc3QgeyBob3N0bmFtZSB9ID0gbmV3IFVSTChzZW5kZXIudXJsKTtcclxuICAgICAgdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIubWF5YmVVcGRhdGVTdGF0ZSgpO1xyXG4gICAgICAvLyBDaGVjayBpZiBuZXcgY29ubmVjdGlvbiBpcyBibG9ja2VkIGlmIHBoaXNoaW5nIGRldGVjdGlvbiBpcyBvblxyXG4gICAgICBjb25zdCBwaGlzaGluZ1Rlc3RSZXNwb25zZSA9IHRoaXMucGhpc2hpbmdDb250cm9sbGVyLnRlc3QoaG9zdG5hbWUpO1xyXG4gICAgICBpZiAodXNlUGhpc2hEZXRlY3QgJiYgcGhpc2hpbmdUZXN0UmVzcG9uc2U/LnJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuc2VuZFBoaXNoaW5nV2FybmluZyhjb25uZWN0aW9uU3RyZWFtLCBob3N0bmFtZSk7XHJcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudCh7XHJcbiAgICAgICAgICBldmVudDogTWV0YU1ldHJpY3NFdmVudE5hbWUuUGhpc2hpbmdQYWdlRGlzcGxheWVkLFxyXG4gICAgICAgICAgY2F0ZWdvcnk6IE1ldGFNZXRyaWNzRXZlbnRDYXRlZ29yeS5QaGlzaGluZyxcclxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgdXJsOiBob3N0bmFtZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0dXAgbXVsdGlwbGV4aW5nXHJcbiAgICBjb25zdCBtdXggPSBzZXR1cE11bHRpcGxleChjb25uZWN0aW9uU3RyZWFtKTtcclxuXHJcbiAgICAvLyBtZXNzYWdlcyBiZXR3ZWVuIGlucGFnZSBhbmQgYmFja2dyb3VuZFxyXG4gICAgdGhpcy5zZXR1cFByb3ZpZGVyQ29ubmVjdGlvbihcclxuICAgICAgbXV4LmNyZWF0ZVN0cmVhbSgnbWV0YW1hc2stcHJvdmlkZXInKSxcclxuICAgICAgc2VuZGVyLFxyXG4gICAgICBfc3ViamVjdFR5cGUsXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRPRE86TGVnYWN5UHJvdmlkZXI6IERlbGV0ZVxyXG4gICAgaWYgKHNlbmRlci51cmwpIHtcclxuICAgICAgLy8gbGVnYWN5IHN0cmVhbXNcclxuICAgICAgdGhpcy5zZXR1cFB1YmxpY0NvbmZpZyhtdXguY3JlYXRlU3RyZWFtKCdwdWJsaWNDb25maWcnKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIHRvIGNyZWF0ZSBhIG11bHRpcGxleGVkIHN0cmVhbSBmb3IgY29ubmVjdGluZyB0byBhIHRydXN0ZWQgY29udGV4dCxcclxuICAgKiBsaWtlIG91ciBvd24gdXNlciBpbnRlcmZhY2VzLCB3aGljaCBoYXZlIHRoZSBwcm92aWRlciBBUElzLCBidXQgYWxzb1xyXG4gICAqIHJlY2VpdmUgdGhlIGV4cG9ydGVkIEFQSSBmcm9tIHRoaXMgY29udHJvbGxlciwgd2hpY2ggaW5jbHVkZXMgdHJ1c3RlZFxyXG4gICAqIGZ1bmN0aW9ucywgbGlrZSB0aGUgYWJpbGl0eSB0byBhcHByb3ZlIHRyYW5zYWN0aW9ucyBvciBzaWduIG1lc3NhZ2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBjb25uZWN0aW9uU3RyZWFtIC0gVGhlIGR1cGxleCBzdHJlYW0gdG8gY29ubmVjdCB0by5cclxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXJ9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2VzIG9uIHRoaXMgc3RyZWFtXHJcbiAgICovXHJcbiAgc2V0dXBUcnVzdGVkQ29tbXVuaWNhdGlvbihjb25uZWN0aW9uU3RyZWFtLCBzZW5kZXIpIHtcclxuICAgIC8vIHNldHVwIG11bHRpcGxleGluZ1xyXG4gICAgY29uc3QgbXV4ID0gc2V0dXBNdWx0aXBsZXgoY29ubmVjdGlvblN0cmVhbSk7XHJcbiAgICAvLyBjb25uZWN0IGZlYXR1cmVzXHJcbiAgICB0aGlzLnNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24obXV4LmNyZWF0ZVN0cmVhbSgnY29udHJvbGxlcicpKTtcclxuICAgIHRoaXMuc2V0dXBQcm92aWRlckNvbm5lY3Rpb24oXHJcbiAgICAgIG11eC5jcmVhdGVTdHJlYW0oJ3Byb3ZpZGVyJyksXHJcbiAgICAgIHNlbmRlcixcclxuICAgICAgU3ViamVjdFR5cGUuSW50ZXJuYWwsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBjcmVhdGUgYSBtdWx0aXBsZXhlZCBzdHJlYW0gZm9yIGNvbm5lY3RpbmcgdG8gdGhlIHBoaXNoaW5nIHdhcm5pbmcgcGFnZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXHJcbiAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbX0gb3B0aW9ucy5jb25uZWN0aW9uU3RyZWFtIC0gVGhlIER1cGxleCBzdHJlYW0gdG8gY29ubmVjdCB0by5cclxuICAgKi9cclxuICBzZXR1cFBoaXNoaW5nQ29tbXVuaWNhdGlvbih7IGNvbm5lY3Rpb25TdHJlYW0gfSkge1xyXG4gICAgY29uc3QgeyB1c2VQaGlzaERldGVjdCB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICBpZiAoIXVzZVBoaXNoRGV0ZWN0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXR1cCBtdWx0aXBsZXhpbmdcclxuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xyXG4gICAgY29uc3QgcGhpc2hpbmdTdHJlYW0gPSBtdXguY3JlYXRlU3RyZWFtKFBISVNISU5HX1NBRkVMSVNUKTtcclxuXHJcbiAgICAvLyBzZXQgdXAgcG9zdFN0cmVhbSB0cmFuc3BvcnRcclxuICAgIHBoaXNoaW5nU3RyZWFtLm9uKFxyXG4gICAgICAnZGF0YScsXHJcbiAgICAgIGNyZWF0ZU1ldGFSUENIYW5kbGVyKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHNhZmVsaXN0UGhpc2hpbmdEb21haW46IHRoaXMuc2FmZWxpc3RQaGlzaGluZ0RvbWFpbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgYmFja1RvU2FmZXR5UGhpc2hpbmdXYXJuaW5nOlxyXG4gICAgICAgICAgICB0aGlzLmJhY2tUb1NhZmV0eVBoaXNoaW5nV2FybmluZy5iaW5kKHRoaXMpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGhpc2hpbmdTdHJlYW0sXHJcbiAgICAgICksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gd2UgZGV0ZWN0IGEgc3VzcGljaW91cyBkb21haW4uIFJlcXVlc3RzIHRoZSBicm93c2VyIHJlZGlyZWN0c1xyXG4gICAqIHRvIG91ciBhbnRpLXBoaXNoaW5nIHBhZ2UuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gY29ubmVjdGlvblN0cmVhbSAtIFRoZSBkdXBsZXggc3RyZWFtIHRvIHRoZSBwZXItcGFnZSBzY3JpcHQsXHJcbiAgICogZm9yIHNlbmRpbmcgdGhlIHJlbG9hZCBhdHRlbXB0IHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIFRoZSBob3N0bmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgc3VzcGljaW9uLlxyXG4gICAqL1xyXG4gIHNlbmRQaGlzaGluZ1dhcm5pbmcoY29ubmVjdGlvblN0cmVhbSwgaG9zdG5hbWUpIHtcclxuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xyXG4gICAgY29uc3QgcGhpc2hpbmdTdHJlYW0gPSBtdXguY3JlYXRlU3RyZWFtKCdwaGlzaGluZycpO1xyXG4gICAgcGhpc2hpbmdTdHJlYW0ud3JpdGUoeyBob3N0bmFtZSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWV0aG9kIGZvciBwcm92aWRpbmcgb3VyIEFQSSBvdmVyIGEgc3RyZWFtIHVzaW5nIEpTT04tUlBDLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBvdXRTdHJlYW0gLSBUaGUgc3RyZWFtIHRvIHByb3ZpZGUgb3VyIEFQSSBvdmVyLlxyXG4gICAqL1xyXG4gIHNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24ob3V0U3RyZWFtKSB7XHJcbiAgICBjb25zdCBhcGkgPSB0aGlzLmdldEFwaSgpO1xyXG5cclxuICAgIC8vIHJlcG9ydCBuZXcgYWN0aXZlIGNvbnRyb2xsZXIgY29ubmVjdGlvblxyXG4gICAgdGhpcy5hY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnMgKz0gMTtcclxuICAgIHRoaXMuZW1pdCgnY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkJywgdGhpcy5hY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnMpO1xyXG5cclxuICAgIC8vIHNldCB1cCBwb3N0U3RyZWFtIHRyYW5zcG9ydFxyXG4gICAgb3V0U3RyZWFtLm9uKFxyXG4gICAgICAnZGF0YScsXHJcbiAgICAgIGNyZWF0ZU1ldGFSUENIYW5kbGVyKFxyXG4gICAgICAgIGFwaSxcclxuICAgICAgICBvdXRTdHJlYW0sXHJcbiAgICAgICAgdGhpcy5zdG9yZSxcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmVBcGlXcmFwcGVyLFxyXG4gICAgICApLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICh1cGRhdGUpID0+IHtcclxuICAgICAgaWYgKG91dFN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyBzZW5kIG5vdGlmaWNhdGlvbiB0byBjbGllbnQtc2lkZVxyXG4gICAgICBvdXRTdHJlYW0ud3JpdGUoe1xyXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxyXG4gICAgICAgIG1ldGhvZDogJ3NlbmRVcGRhdGUnLFxyXG4gICAgICAgIHBhcmFtczogW3VwZGF0ZV0sXHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XHJcbiAgICBjb25zdCBzdGFydFVJU3luYyA9ICgpID0+IHtcclxuICAgICAgaWYgKG91dFN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyBzZW5kIG5vdGlmaWNhdGlvbiB0byBjbGllbnQtc2lkZVxyXG4gICAgICBvdXRTdHJlYW0ud3JpdGUoe1xyXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxyXG4gICAgICAgIG1ldGhvZDogJ3N0YXJ0VUlTeW5jJyxcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLnN0YXJ0VUlTeW5jKSB7XHJcbiAgICAgIHN0YXJ0VUlTeW5jKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm9uY2UoJ3N0YXJ0VUlTeW5jJywgc3RhcnRVSVN5bmMpO1xyXG4gICAgfVxyXG5cclxuICAgIG91dFN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyAtPSAxO1xyXG4gICAgICB0aGlzLmVtaXQoXHJcbiAgICAgICAgJ2NvbnRyb2xsZXJDb25uZWN0aW9uQ2hhbmdlZCcsXHJcbiAgICAgICAgdGhpcy5hY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnMsXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWV0aG9kIGZvciBzZXJ2aW5nIG91ciBldGhlcmV1bSBwcm92aWRlciBvdmVyIGEgZ2l2ZW4gc3RyZWFtLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBvdXRTdHJlYW0gLSBUaGUgc3RyZWFtIHRvIHByb3ZpZGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXIgfCBTbmFwU2VuZGVyfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlcyBvbiB0aGlzIHN0cmVhbVxyXG4gICAqIEBwYXJhbSB7U3ViamVjdFR5cGV9IHN1YmplY3RUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNlbmRlciwgaS5lLiBzdWJqZWN0LlxyXG4gICAqL1xyXG4gIHNldHVwUHJvdmlkZXJDb25uZWN0aW9uKG91dFN0cmVhbSwgc2VuZGVyLCBzdWJqZWN0VHlwZSkge1xyXG4gICAgbGV0IG9yaWdpbjtcclxuICAgIGlmIChzdWJqZWN0VHlwZSA9PT0gU3ViamVjdFR5cGUuSW50ZXJuYWwpIHtcclxuICAgICAgb3JpZ2luID0gT1JJR0lOX01FVEFNQVNLO1xyXG4gICAgfVxyXG5cbiAgICBlbHNlIHtcclxuICAgICAgb3JpZ2luID0gbmV3IFVSTChzZW5kZXIudXJsKS5vcmlnaW47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbmRlci5pZCAmJiBzZW5kZXIuaWQgIT09IHRoaXMuZXh0ZW5zaW9uLnJ1bnRpbWUuaWQpIHtcclxuICAgICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmFkZFN1YmplY3RNZXRhZGF0YSh7XHJcbiAgICAgICAgb3JpZ2luLFxyXG4gICAgICAgIGV4dGVuc2lvbklkOiBzZW5kZXIuaWQsXHJcbiAgICAgICAgc3ViamVjdFR5cGU6IFN1YmplY3RUeXBlLkV4dGVuc2lvbixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRhYklkO1xyXG4gICAgaWYgKHNlbmRlci50YWIgJiYgc2VuZGVyLnRhYi5pZCkge1xyXG4gICAgICB0YWJJZCA9IHNlbmRlci50YWIuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZW5naW5lID0gdGhpcy5zZXR1cFByb3ZpZGVyRW5naW5lKHtcclxuICAgICAgb3JpZ2luLFxyXG4gICAgICBzZW5kZXIsXHJcbiAgICAgIHN1YmplY3RUeXBlLFxyXG4gICAgICB0YWJJZCxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNldHVwIGNvbm5lY3Rpb25cclxuICAgIGNvbnN0IHByb3ZpZGVyU3RyZWFtID0gY3JlYXRlRW5naW5lU3RyZWFtKHsgZW5naW5lIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IHRoaXMuYWRkQ29ubmVjdGlvbihvcmlnaW4sIHsgZW5naW5lIH0pO1xyXG5cclxuICAgIHB1bXAob3V0U3RyZWFtLCBwcm92aWRlclN0cmVhbSwgb3V0U3RyZWFtLCAoZXJyKSA9PiB7XHJcbiAgICAgIC8vIGhhbmRsZSBhbnkgbWlkZGxld2FyZSBjbGVhbnVwXHJcbiAgICAgIGVuZ2luZS5fbWlkZGxld2FyZS5mb3JFYWNoKChtaWQpID0+IHtcclxuICAgICAgICBpZiAobWlkLmRlc3Ryb3kgJiYgdHlwZW9mIG1pZC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBtaWQuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNvbm5lY3Rpb25JZCAmJiB0aGlzLnJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBjb25uZWN0aW9uSWQpO1xyXG4gICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgbG9nLmVycm9yKGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgcHJvdmlkZXIgdGhhdCBpcyBzYWZlbHkgcmVzdHJpY3RlZCBmb3IgdGhlIHJlcXVlc3Rpbmcgc3ViamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gUHJvdmlkZXIgZW5naW5lIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzZW5kZXJcclxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXIgfCBTbmFwU2VuZGVyfSBvcHRpb25zLnNlbmRlciAtIFRoZSBzZW5kZXIgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1YmplY3RUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNlbmRlciBzdWJqZWN0LlxyXG4gICAqIEBwYXJhbSB7dGFiSWR9IFtvcHRpb25zLnRhYklkXSAtIFRoZSB0YWIgSUQgb2YgdGhlIHNlbmRlciAtIGlmIHRoZSBzZW5kZXIgaXMgd2l0aGluIGEgdGFiXHJcbiAgICovXHJcbiAgc2V0dXBQcm92aWRlckVuZ2luZSh7IG9yaWdpbiwgc3ViamVjdFR5cGUsIHNlbmRlciwgdGFiSWQgfSkge1xyXG4gICAgLy8gc2V0dXAganNvbiBycGMgZW5naW5lIHN0YWNrXHJcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcgSnNvblJwY0VuZ2luZSgpO1xyXG4gICAgY29uc3QgeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0gPSB0aGlzO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBmaWx0ZXIgcG9seWZpbGwgbWlkZGxld2FyZVxyXG4gICAgY29uc3QgZmlsdGVyTWlkZGxld2FyZSA9IGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyIH0pO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBzdWJzY3JpcHRpb24gcG9seWZpbGwgbWlkZGxld2FyZVxyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uTWFuYWdlciA9IGNyZWF0ZVN1YnNjcmlwdGlvbk1hbmFnZXIoe1xyXG4gICAgICBwcm92aWRlcixcclxuICAgICAgYmxvY2tUcmFja2VyLFxyXG4gICAgfSk7XHJcbiAgICBzdWJzY3JpcHRpb25NYW5hZ2VyLmV2ZW50cy5vbignbm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+XHJcbiAgICAgIGVuZ2luZS5lbWl0KCdub3RpZmljYXRpb24nLCBtZXNzYWdlKSxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGlzTWFuaWZlc3RWMykge1xyXG4gICAgICBlbmdpbmUucHVzaChjcmVhdGVEdXBlUmVxRmlsdGVyTWlkZGxld2FyZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBlbmQgb3JpZ2luIHRvIGVhY2ggcmVxdWVzdFxyXG4gICAgZW5naW5lLnB1c2goY3JlYXRlT3JpZ2luTWlkZGxld2FyZSh7IG9yaWdpbiB9KSk7XHJcblxyXG4gICAgLy8gYXBwZW5kIHRhYklkIHRvIGVhY2ggcmVxdWVzdCBpZiBpdCBleGlzdHNcclxuICAgIGlmICh0YWJJZCkge1xyXG4gICAgICBlbmdpbmUucHVzaChjcmVhdGVUYWJJZE1pZGRsZXdhcmUoeyB0YWJJZCB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbG9nZ2luZ1xyXG4gICAgZW5naW5lLnB1c2goY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSh7IG9yaWdpbiB9KSk7XHJcbiAgICBlbmdpbmUucHVzaCh0aGlzLnBlcm1pc3Npb25Mb2dDb250cm9sbGVyLmNyZWF0ZU1pZGRsZXdhcmUoKSk7XHJcblxyXG4gICAgZW5naW5lLnB1c2goXHJcbiAgICAgIGNyZWF0ZVJQQ01ldGhvZFRyYWNraW5nTWlkZGxld2FyZSh7XHJcbiAgICAgICAgdHJhY2tFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxyXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgICBnZXRNZXRyaWNzU3RhdGU6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdG9yZSxcclxuICAgICAgICApLFxyXG4gICAgICAgIHNlY3VyaXR5UHJvdmlkZXJSZXF1ZXN0OiB0aGlzLnNlY3VyaXR5UHJvdmlkZXJSZXF1ZXN0LmJpbmQodGhpcyksXHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBvbmJvYXJkaW5nXHJcbiAgICBpZiAoc3ViamVjdFR5cGUgPT09IFN1YmplY3RUeXBlLldlYnNpdGUpIHtcclxuICAgICAgZW5naW5lLnB1c2goXHJcbiAgICAgICAgY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUoe1xyXG4gICAgICAgICAgbG9jYXRpb246IHNlbmRlci51cmwsXHJcbiAgICAgICAgICByZWdpc3Rlck9uYm9hcmRpbmc6IHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIucmVnaXN0ZXJPbmJvYXJkaW5nLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVucmVzdHJpY3RlZC9wZXJtaXNzaW9ubGVzcyBSUEMgbWV0aG9kIGltcGxlbWVudGF0aW9uc1xyXG4gICAgZW5naW5lLnB1c2goXHJcbiAgICAgIGNyZWF0ZU1ldGhvZE1pZGRsZXdhcmUoe1xyXG4gICAgICAgIG9yaWdpbixcclxuXHJcbiAgICAgICAgc3ViamVjdFR5cGUsXHJcblxyXG4gICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcclxuICAgICAgICBhZGRTdWJqZWN0TWV0YWRhdGE6XHJcbiAgICAgICAgICB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuYWRkU3ViamVjdE1ldGFkYXRhLmJpbmQoXHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcixcclxuICAgICAgICAgICksXHJcbiAgICAgICAgZ2V0UHJvdmlkZXJTdGF0ZTogdGhpcy5nZXRQcm92aWRlclN0YXRlLmJpbmQodGhpcyksXHJcbiAgICAgICAgZ2V0VW5sb2NrUHJvbWlzZTogdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuZ2V0VW5sb2NrUHJvbWlzZS5iaW5kKFxyXG4gICAgICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgICBoYW5kbGVXYXRjaEFzc2V0UmVxdWVzdDogdGhpcy50b2tlbnNDb250cm9sbGVyLndhdGNoQXNzZXQuYmluZChcclxuICAgICAgICAgIHRoaXMudG9rZW5zQ29udHJvbGxlcixcclxuICAgICAgICApLFxyXG4gICAgICAgIHJlcXVlc3RVc2VyQXBwcm92YWw6XHJcbiAgICAgICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0LmJpbmQoXHJcbiAgICAgICAgICAgIHRoaXMuYXBwcm92YWxDb250cm9sbGVyLFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICBzZW5kTWV0cmljczogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxyXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXHJcbiAgICAgICAgKSxcclxuICAgICAgICAvLyBQZXJtaXNzaW9uLXJlbGF0ZWRcclxuICAgICAgICBnZXRBY2NvdW50czogdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cy5iaW5kKHRoaXMsIG9yaWdpbiksXHJcbiAgICAgICAgZ2V0UGVybWlzc2lvbnNGb3JPcmlnaW46IHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuZ2V0UGVybWlzc2lvbnMuYmluZChcclxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXHJcbiAgICAgICAgICBvcmlnaW4sXHJcbiAgICAgICAgKSxcclxuICAgICAgICBoYXNQZXJtaXNzaW9uOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmhhc1Blcm1pc3Npb24uYmluZChcclxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXHJcbiAgICAgICAgICBvcmlnaW4sXHJcbiAgICAgICAgKSxcclxuICAgICAgICByZXF1ZXN0QWNjb3VudHNQZXJtaXNzaW9uOlxyXG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5yZXF1ZXN0UGVybWlzc2lvbnMuYmluZChcclxuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcclxuICAgICAgICAgICAgeyBvcmlnaW4gfSxcclxuICAgICAgICAgICAgeyBldGhfYWNjb3VudHM6IHt9IH0sXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uc0Zvck9yaWdpbjpcclxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIucmVxdWVzdFBlcm1pc3Npb25zLmJpbmQoXHJcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXHJcbiAgICAgICAgICAgIHsgb3JpZ2luIH0sXHJcbiAgICAgICAgICApLFxyXG5cclxuICAgICAgICBnZXRDdXJyZW50Q2hhaW5JZDogKCkgPT5cclxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxyXG4gICAgICAgIGdldEN1cnJlbnRScGNVcmw6ICgpID0+XHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcucnBjVXJsLFxyXG4gICAgICAgIC8vIG5ldHdvcmsgY29uZmlndXJhdGlvbi1yZWxhdGVkXHJcbiAgICAgICAgZ2V0TmV0d29ya0NvbmZpZ3VyYXRpb25zOiAoKSA9PlxyXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLm5ldHdvcmtDb25maWd1cmF0aW9ucyxcclxuICAgICAgICB1cHNlcnROZXR3b3JrQ29uZmlndXJhdGlvbjpcclxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIudXBzZXJ0TmV0d29ya0NvbmZpZ3VyYXRpb24uYmluZChcclxuICAgICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcclxuICAgICAgICAgICksXHJcbiAgICAgICAgc2V0QWN0aXZlTmV0d29yazogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zZXRBY3RpdmVOZXR3b3JrLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgZmluZE5ldHdvcmtDb25maWd1cmF0aW9uQnk6IHRoaXMuZmluZE5ldHdvcmtDb25maWd1cmF0aW9uQnkuYmluZCh0aGlzKSxcclxuICAgICAgICBzZXRQcm92aWRlclR5cGU6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc2V0UHJvdmlkZXJUeXBlLmJpbmQoXHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcblxyXG4gICAgICAgIC8vIFdlYjMgc2hpbS1yZWxhdGVkXHJcbiAgICAgICAgZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlOiB0aGlzLmFsZXJ0Q29udHJvbGxlci5nZXRXZWIzU2hpbVVzYWdlU3RhdGUuYmluZChcclxuICAgICAgICAgIHRoaXMuYWxlcnRDb250cm9sbGVyLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkOlxyXG4gICAgICAgICAgdGhpcy5hbGVydENvbnRyb2xsZXIuc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkLmJpbmQoXHJcbiAgICAgICAgICAgIHRoaXMuYWxlcnRDb250cm9sbGVyLFxyXG4gICAgICAgICAgKSxcclxuICAgICAgfSksXHJcbiAgICApO1xyXG5cclxuXG5cclxuICAgIC8vIGZpbHRlciBhbmQgc3Vic2NyaXB0aW9uIHBvbHlmaWxsc1xyXG4gICAgZW5naW5lLnB1c2goZmlsdGVyTWlkZGxld2FyZSk7XHJcbiAgICBlbmdpbmUucHVzaChzdWJzY3JpcHRpb25NYW5hZ2VyLm1pZGRsZXdhcmUpO1xyXG4gICAgaWYgKHN1YmplY3RUeXBlICE9PSBTdWJqZWN0VHlwZS5JbnRlcm5hbCkge1xyXG4gICAgICAvLyBwZXJtaXNzaW9uc1xyXG4gICAgICBlbmdpbmUucHVzaChcclxuICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlKHtcclxuICAgICAgICAgIG9yaWdpbixcclxuICAgICAgICB9KSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBlbmdpbmUucHVzaCh0aGlzLm1ldGFtYXNrTWlkZGxld2FyZSk7XHJcblxyXG4gICAgLy8gZm9yd2FyZCB0byBtZXRhbWFzayBwcmltYXJ5IHByb3ZpZGVyXHJcbiAgICBlbmdpbmUucHVzaChwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikpO1xyXG4gICAgcmV0dXJuIGVuZ2luZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86TGVnYWN5UHJvdmlkZXI6IERlbGV0ZVxyXG4gICAqIEEgbWV0aG9kIGZvciBwcm92aWRpbmcgb3VyIHB1YmxpYyBjb25maWcgaW5mbyBvdmVyIGEgc3RyZWFtLlxyXG4gICAqIFRoaXMgaW5jbHVkZXMgaW5mbyB3ZSBsaWtlIHRvIGJlIHN5bmNocm9ub3VzIGlmIHBvc3NpYmxlLCBsaWtlXHJcbiAgICogdGhlIGN1cnJlbnQgc2VsZWN0ZWQgYWNjb3VudCwgYW5kIG5ldHdvcmsgSUQuXHJcbiAgICpcclxuICAgKiBTaW5jZSBzeW5jaHJvbm91cyBtZXRob2RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGluIHdlYjMsXHJcbiAgICogdGhpcyBpcyBhIGdvb2QgY2FuZGlkYXRlIGZvciBkZXByZWNhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gb3V0U3RyZWFtIC0gVGhlIHN0cmVhbSB0byBwcm92aWRlIHB1YmxpYyBjb25maWcgb3Zlci5cclxuICAgKi9cclxuICBzZXR1cFB1YmxpY0NvbmZpZyhvdXRTdHJlYW0pIHtcclxuICAgIGNvbnN0IGNvbmZpZ1N0cmVhbSA9IHN0b3JlQXNTdHJlYW0odGhpcy5wdWJsaWNDb25maWdTdG9yZSk7XHJcblxyXG4gICAgcHVtcChjb25maWdTdHJlYW0sIG91dFN0cmVhbSwgKGVycikgPT4ge1xyXG4gICAgICBjb25maWdTdHJlYW0uZGVzdHJveSgpO1xyXG4gICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgbG9nLmVycm9yKGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHJlZmVyZW5jZSB0byBhIGNvbm5lY3Rpb24gYnkgb3JpZ2luLiBJZ25vcmVzIHRoZSAnbWV0YW1hc2snIG9yaWdpbi5cclxuICAgKiBDYWxsZXIgbXVzdCBlbnN1cmUgdGhhdCB0aGUgcmV0dXJuZWQgaWQgaXMgc3RvcmVkIHN1Y2ggdGhhdCB0aGUgcmVmZXJlbmNlXHJcbiAgICogY2FuIGJlIGRlbGV0ZWQgbGF0ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIGNvbm5lY3Rpb24ncyBvcmlnaW4gc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gRGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbm5lY3Rpb25cclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5lbmdpbmUgLSBUaGUgY29ubmVjdGlvbidzIEpTT04gUnBjIEVuZ2luZVxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb25uZWN0aW9uJ3MgaWQgKHNvIHRoYXQgaXQgY2FuIGJlIGRlbGV0ZWQgbGF0ZXIpXHJcbiAgICovXHJcbiAgYWRkQ29ubmVjdGlvbihvcmlnaW4sIHsgZW5naW5lIH0pIHtcclxuICAgIGlmIChvcmlnaW4gPT09IE9SSUdJTl9NRVRBTUFTSykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXSkge1xyXG4gICAgICB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl0gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpZCA9IG5hbm9pZCgpO1xyXG4gICAgdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dW2lkXSA9IHtcclxuICAgICAgZW5naW5lLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gaWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGVzIGEgcmVmZXJlbmNlIHRvIGEgY29ubmVjdGlvbiwgYnkgb3JpZ2luIGFuZCBpZC5cclxuICAgKiBJZ25vcmVzIHVua25vd24gb3JpZ2lucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgY29ubmVjdGlvbidzIG9yaWdpbiBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGNvbm5lY3Rpb24ncyBpZCwgYXMgcmV0dXJuZWQgZnJvbSBhZGRDb25uZWN0aW9uLlxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBpZCkge1xyXG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl07XHJcbiAgICBpZiAoIWNvbm5lY3Rpb25zKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGUgY29ubmVjdGlvbnNbaWRdO1xyXG5cclxuICAgIGlmIChPYmplY3Qua2V5cyhjb25uZWN0aW9ucykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9zZXMgYWxsIGNvbm5lY3Rpb25zIGZvciB0aGUgZ2l2ZW4gb3JpZ2luLCBhbmQgcmVtb3ZlcyB0aGUgcmVmZXJlbmNlc1xyXG4gICAqIHRvIHRoZW0uXHJcbiAgICogSWdub3JlcyB1bmtub3duIG9yaWdpbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiBzdHJpbmcuXHJcbiAgICovXHJcbiAgcmVtb3ZlQWxsQ29ubmVjdGlvbnMob3JpZ2luKSB7XHJcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXTtcclxuICAgIGlmICghY29ubmVjdGlvbnMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIE9iamVjdC5rZXlzKGNvbm5lY3Rpb25zKS5mb3JFYWNoKChpZCkgPT4ge1xyXG4gICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBpZCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhdXNlcyB0aGUgUlBDIGVuZ2luZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9ucyB0byB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAgICogdG8gZW1pdCBhIG5vdGlmaWNhdGlvbiBldmVudCB3aXRoIHRoZSBnaXZlbiBwYXlsb2FkLlxyXG4gICAqXHJcbiAgICogVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgdGhhdCBvbmx5IHBlcm1pdHRlZCBub3RpZmljYXRpb25zXHJcbiAgICogYXJlIHNlbnQuXHJcbiAgICpcclxuICAgKiBJZ25vcmVzIHVua25vd24gb3JpZ2lucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgY29ubmVjdGlvbidzIG9yaWdpbiBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXlsb2FkIC0gVGhlIGV2ZW50IHBheWxvYWQuXHJcbiAgICovXHJcbiAgbm90aWZ5Q29ubmVjdGlvbnMob3JpZ2luLCBwYXlsb2FkKSB7XHJcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXTtcclxuXHJcbiAgICBpZiAoY29ubmVjdGlvbnMpIHtcclxuICAgICAgT2JqZWN0LnZhbHVlcyhjb25uZWN0aW9ucykuZm9yRWFjaCgoY29ubikgPT4ge1xyXG4gICAgICAgIGlmIChjb25uLmVuZ2luZSkge1xyXG4gICAgICAgICAgY29ubi5lbmdpbmUuZW1pdCgnbm90aWZpY2F0aW9uJywgcGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhdXNlcyB0aGUgUlBDIGVuZ2luZXMgYXNzb2NpYXRlZCB3aXRoIGFsbCBjb25uZWN0aW9ucyB0byBlbWl0IGFcclxuICAgKiBub3RpZmljYXRpb24gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gcGF5bG9hZC5cclxuICAgKlxyXG4gICAqIElmIHRoZSBcInBheWxvYWRcIiBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiwgdGhlIHBheWxvYWQgZm9yIGVhY2ggY29ubmVjdGlvblxyXG4gICAqIHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGF0IGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBjb25uZWN0aW9uJ3NcclxuICAgKiBvcmlnaW4uXHJcbiAgICpcclxuICAgKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IG9ubHkgcGVybWl0dGVkIG5vdGlmaWNhdGlvbnNcclxuICAgKiBhcmUgc2VudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGF5bG9hZCAtIFRoZSBldmVudCBwYXlsb2FkLCBvciBwYXlsb2FkIGdldHRlciBmdW5jdGlvbi5cclxuICAgKi9cclxuICBub3RpZnlBbGxDb25uZWN0aW9ucyhwYXlsb2FkKSB7XHJcbiAgICBjb25zdCBnZXRQYXlsb2FkID1cclxuICAgICAgdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IChvcmlnaW4pID0+IHBheWxvYWQob3JpZ2luKVxyXG4gICAgICAgIDogKCkgPT4gcGF5bG9hZDtcclxuXHJcbiAgICBPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKS5mb3JFYWNoKChvcmlnaW4pID0+IHtcclxuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl0pLmZvckVhY2goYXN5bmMgKGNvbm4pID0+IHtcclxuICAgICAgICBpZiAoY29ubi5lbmdpbmUpIHtcclxuICAgICAgICAgIGNvbm4uZW5naW5lLmVtaXQoJ25vdGlmaWNhdGlvbicsIGF3YWl0IGdldFBheWxvYWQob3JpZ2luKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gaGFuZGxlcnNcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGEgS2V5cmluZ0NvbnRyb2xsZXIgdXBkYXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSB0aGUgS0Mgc3RhdGVcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGFzeW5jIF9vbktleXJpbmdDb250cm9sbGVyVXBkYXRlKHN0YXRlKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGtleXJpbmdzLFxyXG4gICAgICBlbmNyeXB0aW9uS2V5OiBsb2dpblRva2VuLFxyXG4gICAgICBlbmNyeXB0aW9uU2FsdDogbG9naW5TYWx0LFxyXG4gICAgfSA9IHN0YXRlO1xyXG4gICAgY29uc3QgYWRkcmVzc2VzID0ga2V5cmluZ3MucmVkdWNlKFxyXG4gICAgICAoYWNjLCB7IGFjY291bnRzIH0pID0+IGFjYy5jb25jYXQoYWNjb3VudHMpLFxyXG4gICAgICBbXSxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGlzTWFuaWZlc3RWMykge1xyXG4gICAgICBhd2FpdCB0aGlzLmV4dGVuc2lvbi5zdG9yYWdlLnNlc3Npb24uc2V0KHsgbG9naW5Ub2tlbiwgbG9naW5TYWx0IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYWRkcmVzc2VzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRW5zdXJlIHByZWZlcmVuY2VzICsgaWRlbnRpdGllcyBjb250cm9sbGVyIGtub3cgYWJvdXQgYWxsIGFkZHJlc3Nlc1xyXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3luY0FkZHJlc3NlcyhhZGRyZXNzZXMpO1xyXG4gICAgdGhpcy5hY2NvdW50VHJhY2tlci5zeW5jV2l0aEFkZHJlc3NlcyhhZGRyZXNzZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGdsb2JhbCBhcHBsaWNhdGlvbiB1bmxvY2suXHJcbiAgICogTm90aWZpZXMgYWxsIGNvbm5lY3Rpb25zIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZCwgYW5kIHdoaWNoXHJcbiAgICogYWNjb3VudChzKSBhcmUgY3VycmVudGx5IGFjY2Vzc2libGUsIGlmIGFueS5cclxuICAgKi9cclxuICBfb25VbmxvY2soKSB7XHJcbiAgICB0aGlzLm5vdGlmeUFsbENvbm5lY3Rpb25zKGFzeW5jIChvcmlnaW4pID0+IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy51bmxvY2tTdGF0ZUNoYW5nZWQsXHJcbiAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICBpc1VubG9ja2VkOiB0cnVlLFxyXG4gICAgICAgICAgYWNjb3VudHM6IGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy51bk1hcmtQYXNzd29yZEZvcmdvdHRlbigpO1xyXG5cclxuICAgIC8vIEluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uLCB0aGlzIGhhbmRsZXIgaXMgdHJpZ2dlcmVkIGJ5IGFcclxuICAgIC8vIEtleXJpbmdDb250cm9sbGVyIGV2ZW50LiBPdGhlciBjb250cm9sbGVycyBzdWJzY3JpYmUgdG8gdGhlICd1bmxvY2snXHJcbiAgICAvLyBldmVudCBvZiB0aGUgTWV0YU1hc2tDb250cm9sbGVyIGl0c2VsZi5cclxuICAgIHRoaXMuZW1pdCgndW5sb2NrJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgZ2xvYmFsIGFwcGxpY2F0aW9uIGxvY2suXHJcbiAgICogTm90aWZpZXMgYWxsIGNvbm5lY3Rpb25zIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyBsb2NrZWQuXHJcbiAgICovXHJcbiAgX29uTG9jaygpIHtcclxuICAgIHRoaXMubm90aWZ5QWxsQ29ubmVjdGlvbnMoe1xyXG4gICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy51bmxvY2tTdGF0ZUNoYW5nZWQsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24sIHRoaXMgaGFuZGxlciBpcyB0cmlnZ2VyZWQgYnkgYVxyXG4gICAgLy8gS2V5cmluZ0NvbnRyb2xsZXIgZXZlbnQuIE90aGVyIGNvbnRyb2xsZXJzIHN1YnNjcmliZSB0byB0aGUgJ2xvY2snXHJcbiAgICAvLyBldmVudCBvZiB0aGUgTWV0YU1hc2tDb250cm9sbGVyIGl0c2VsZi5cclxuICAgIHRoaXMuZW1pdCgnbG9jaycpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIG1lbW9yeSBzdGF0ZSB1cGRhdGVzLlxyXG4gICAqIC0gRW5zdXJlIGlzQ2xpZW50T3BlbkFuZFVubG9ja2VkIGlzIHVwZGF0ZWRcclxuICAgKiAtIE5vdGlmaWVzIGFsbCBjb25uZWN0aW9ucyB3aXRoIHRoZSBuZXcgcHJvdmlkZXIgbmV0d29yayBzdGF0ZVxyXG4gICAqICAgLSBUaGUgZXh0ZXJuYWwgcHJvdmlkZXJzIGhhbmRsZSBkaWZmaW5nIHRoZSBzdGF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5ld1N0YXRlXHJcbiAgICovXHJcbiAgX29uU3RhdGVVcGRhdGUobmV3U3RhdGUpIHtcclxuICAgIHRoaXMuaXNDbGllbnRPcGVuQW5kVW5sb2NrZWQgPSBuZXdTdGF0ZS5pc1VubG9ja2VkICYmIHRoaXMuX2lzQ2xpZW50T3BlbjtcclxuICAgIHRoaXMubm90aWZ5QWxsQ29ubmVjdGlvbnMoe1xyXG4gICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy5jaGFpbkNoYW5nZWQsXHJcbiAgICAgIHBhcmFtczogdGhpcy5nZXRQcm92aWRlck5ldHdvcmtTdGF0ZShuZXdTdGF0ZSksXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIG1pc2NcclxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgZm9yIGVtaXR0aW5nIHRoZSBmdWxsIE1ldGFNYXNrIHN0YXRlIHRvIGFsbCByZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgcHJpdmF0ZVNlbmRVcGRhdGUoKSB7XHJcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0U3RhdGUoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXh0ZW5zaW9uIGlzIHVubG9ja2VkLlxyXG4gICAqL1xyXG4gIGlzVW5sb2NrZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZS5nZXRTdGF0ZSgpLmlzVW5sb2NrZWQ7XHJcbiAgfVxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gTUlTQ0VMTEFORU9VU1xyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgZ2V0RXh0ZXJuYWxQZW5kaW5nVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcclxuICAgIHJldHVybiB0aGlzLnNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5nZXRUcmFuc2FjdGlvbnMoe1xyXG4gICAgICBhZGRyZXNzRnJvbTogYWRkcmVzcyxcclxuICAgICAgc3RhdHVzOiAncGVuZGluZycsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG5vbmNlIHRoYXQgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggYSB0cmFuc2FjdGlvbiBvbmNlIGFwcHJvdmVkXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBoZXggc3RyaW5nIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvblxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0UGVuZGluZ05vbmNlKGFkZHJlc3MpIHtcclxuICAgIGNvbnN0IHsgbm9uY2VEZXRhaWxzLCByZWxlYXNlTG9jayB9ID1cclxuICAgICAgYXdhaXQgdGhpcy50eENvbnRyb2xsZXIubm9uY2VUcmFja2VyLmdldE5vbmNlTG9jayhhZGRyZXNzKTtcclxuICAgIGNvbnN0IHBlbmRpbmdOb25jZSA9IG5vbmNlRGV0YWlscy5wYXJhbXMuaGlnaGVzdFN1Z2dlc3RlZDtcclxuXHJcbiAgICByZWxlYXNlTG9jaygpO1xyXG4gICAgcmV0dXJuIHBlbmRpbmdOb25jZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG5leHQgbm9uY2UgYWNjb3JkaW5nIHRvIHRoZSBub25jZS10cmFja2VyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBoZXggc3RyaW5nIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvblxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0TmV4dE5vbmNlKGFkZHJlc3MpIHtcclxuICAgIGNvbnN0IG5vbmNlTG9jayA9IGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soXHJcbiAgICAgIGFkZHJlc3MsXHJcbiAgICApO1xyXG4gICAgbm9uY2VMb2NrLnJlbGVhc2VMb2NrKCk7XHJcbiAgICByZXR1cm4gbm9uY2VMb2NrLm5leHROb25jZTtcclxuICB9XHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBDT05GSUdcclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG5ldHdvcmsgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCBtYXRjaGVzIGF0IGxlYXN0IG9uZSBmaWVsZCBvZiB0aGVcclxuICAgKiBwcm92aWRlZCBzZWFyY2ggY3JpdGVyaWEuIFJldHVybnMgbnVsbCBpZiBubyBtYXRjaCBpcyBmb3VuZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHJwY0luZm8gLSBUaGUgUlBDIGVuZHBvaW50IHByb3BlcnRpZXMgYW5kIHZhbHVlcyB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBycGNJbmZvIGZvdW5kIGluIHRoZSBuZXR3b3JrIGNvbmZpZ3VyYXRpb25zIGxpc3RcclxuICAgKi9cclxuICBmaW5kTmV0d29ya0NvbmZpZ3VyYXRpb25CeShycGNJbmZvKSB7XHJcbiAgICBjb25zdCB7IG5ldHdvcmtDb25maWd1cmF0aW9ucyB9ID0gdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb24gPSBPYmplY3QudmFsdWVzKG5ldHdvcmtDb25maWd1cmF0aW9ucykuZmluZChcclxuICAgICAgKGNvbmZpZ3VyYXRpb24pID0+IHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocnBjSW5mbykuc29tZSgoa2V5KSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvbltrZXldID09PSBycGNJbmZvW2tleV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBuZXR3b3JrQ29uZmlndXJhdGlvbiB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgTGVkZ2VyIExpdmUgcHJlZmVyZW5jZSB0byB1c2UgZm9yIExlZGdlciBoYXJkd2FyZSB3YWxsZXQgc3VwcG9ydFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zcG9ydFR5cGUgLSBUaGUgTGVkZ2VyIHRyYW5zcG9ydCB0eXBlLlxyXG4gICAqL1xyXG4gIGFzeW5jIHNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0VHlwZSkge1xyXG4gICAgaWYgKCF0aGlzLmNhblVzZUhhcmR3YXJlV2FsbGV0cygpKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY3VycmVudFZhbHVlID1cclxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xyXG4gICAgY29uc3QgbmV3VmFsdWUgPVxyXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydFR5cGUpO1xyXG5cclxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoSGFyZHdhcmVEZXZpY2VOYW1lcy5sZWRnZXIpO1xyXG4gICAgaWYgKGtleXJpbmc/LnVwZGF0ZVRyYW5zcG9ydE1ldGhvZCkge1xyXG4gICAgICByZXR1cm4ga2V5cmluZy51cGRhdGVUcmFuc3BvcnRNZXRob2QobmV3VmFsdWUpLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHVwZGF0aW5nIHRoZSB0cmFuc3BvcnQsIHdlIHNob3VsZFxyXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWVcclxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKGN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWV0aG9kIGZvciBpbml0aWFsaXppbmcgc3RvcmFnZSB0aGUgZmlyc3QgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbml0U3RhdGUgLSBUaGUgZGVmYXVsdCBzdGF0ZSB0byBpbml0aWFsaXplIHdpdGguXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICByZWNvcmRGaXJzdFRpbWVJbmZvKGluaXRTdGF0ZSkge1xyXG4gICAgaWYgKCEoJ2ZpcnN0VGltZUluZm8nIGluIGluaXRTdGF0ZSkpIHtcclxuICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucGxhdGZvcm0uZ2V0VmVyc2lvbigpO1xyXG4gICAgICBpbml0U3RhdGUuZmlyc3RUaW1lSW5mbyA9IHtcclxuICAgICAgICB2ZXJzaW9uLFxyXG4gICAgICAgIGRhdGU6IERhdGUubm93KCksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBSZXBsYWNlIGlzQ2xpZW50T3BlbiBtZXRob2RzIHdpdGggYGNvbnRyb2xsZXJDb25uZWN0aW9uQ2hhbmdlZGAgZXZlbnRzLlxyXG4gIC8qIGVzbGludC1kaXNhYmxlIGFjY2Vzc29yLXBhaXJzICovXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgZm9yIHJlY29yZGluZyB3aGV0aGVyIHRoZSBNZXRhTWFzayB1c2VyIGludGVyZmFjZSBpcyBvcGVuIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3BlblxyXG4gICAqL1xyXG4gIHNldCBpc0NsaWVudE9wZW4ob3Blbikge1xyXG4gICAgdGhpcy5faXNDbGllbnRPcGVuID0gb3BlbjtcclxuICAgIHRoaXMuZGV0ZWN0VG9rZW5zQ29udHJvbGxlci5pc09wZW4gPSBvcGVuO1xyXG4gIH1cclxuICAvKiBlc2xpbnQtZW5hYmxlIGFjY2Vzc29yLXBhaXJzICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIGJ5IHRoZSBiYWNrZ3JvdW5kIHdoZW4gYWxsIGluc3RhbmNlcyBvZiBtZXRhbWFzayBhcmUgY2xvc2VkLlxyXG4gICAqIEN1cnJlbnRseSB1c2VkIHRvIHN0b3AgcG9sbGluZyBpbiB0aGUgZ2FzRmVlQ29udHJvbGxlci5cclxuICAgKi9cclxuICBvbkNsaWVudENsb3NlZCgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlci5zdG9wUG9sbGluZygpO1xyXG4gICAgICB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5jbGVhclBvbGxpbmdUb2tlbnMoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGJhY2tncm91bmQgd2hlbiBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgdHlwZSBpcyBjbG9zZWQgKGZ1bGxzY3JlZW4sIHBvcHVwLCBub3RpZmljYXRpb24pLlxyXG4gICAqIEN1cnJlbnRseSB1c2VkIHRvIHN0b3AgcG9sbGluZyBpbiB0aGUgZ2FzRmVlQ29udHJvbGxlciBmb3Igb25seSB0aGF0IGVudmlyb25lbWVudCB0eXBlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZW52aXJvbm1lbnRUeXBlXHJcbiAgICovXHJcbiAgb25FbnZpcm9ubWVudFR5cGVDbG9zZWQoZW52aXJvbm1lbnRUeXBlKSB7XHJcbiAgICBjb25zdCBhcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGUgPVxyXG4gICAgICBQT0xMSU5HX1RPS0VOX0VOVklST05NRU5UX1RZUEVTW2Vudmlyb25tZW50VHlwZV07XHJcbiAgICBjb25zdCBwb2xsaW5nVG9rZW5zVG9EaXNjb25uZWN0ID1cclxuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVthcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGVdO1xyXG4gICAgcG9sbGluZ1Rva2Vuc1RvRGlzY29ubmVjdC5mb3JFYWNoKChwb2xsaW5nVG9rZW4pID0+IHtcclxuICAgICAgdGhpcy5nYXNGZWVDb250cm9sbGVyLmRpc2Nvbm5lY3RQb2xsZXIocG9sbGluZ1Rva2VuKTtcclxuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIucmVtb3ZlUG9sbGluZ1Rva2VuKFxyXG4gICAgICAgIHBvbGxpbmdUb2tlbixcclxuICAgICAgICBhcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGUsXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBkb21haW4gdG8gdGhlIFBoaXNoaW5nQ29udHJvbGxlciBzYWZlbGlzdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lIC0gdGhlIGRvbWFpbiB0byBzYWZlbGlzdFxyXG4gICAqL1xyXG4gIHNhZmVsaXN0UGhpc2hpbmdEb21haW4oaG9zdG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLnBoaXNoaW5nQ29udHJvbGxlci5ieXBhc3MoaG9zdG5hbWUpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYmFja1RvU2FmZXR5UGhpc2hpbmdXYXJuaW5nKCkge1xyXG4gICAgY29uc3QgZXh0ZW5zaW9uVVJMID0gdGhpcy5wbGF0Zm9ybS5nZXRFeHRlbnNpb25VUkwoKTtcclxuICAgIGF3YWl0IHRoaXMucGxhdGZvcm0uc3dpdGNoVG9Bbm90aGVyVVJMKHVuZGVmaW5lZCwgZXh0ZW5zaW9uVVJMKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvY2tzIE1ldGFNYXNrXHJcbiAgICovXHJcbiAgc2V0TG9ja2VkKCkge1xyXG4gICAgY29uc3QgW3RyZXpvcktleXJpbmddID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZShcclxuICAgICAgS2V5cmluZ1R5cGUudHJlem9yLFxyXG4gICAgKTtcclxuICAgIGlmICh0cmV6b3JLZXlyaW5nKSB7XHJcbiAgICAgIHRyZXpvcktleXJpbmcuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFtsZWRnZXJLZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXHJcbiAgICAgIEtleXJpbmdUeXBlLmxlZGdlcixcclxuICAgICk7XHJcbiAgICBsZWRnZXJLZXlyaW5nPy5kZXN0cm95Py4oKTtcclxuXHJcbiAgICBpZiAoaXNNYW5pZmVzdFYzKSB7XHJcbiAgICAgIHRoaXMuY2xlYXJMb2dpbkFydGlmYWN0cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmtleXJpbmdDb250cm9sbGVyLnNldExvY2tlZCgpO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlUGVybWlzc2lvbnNGb3IgPSAoc3ViamVjdHMpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIucmV2b2tlUGVybWlzc2lvbnMoc3ViamVjdHMpO1xyXG4gICAgfSBjYXRjaCAoZXhwKSB7XHJcbiAgICAgIGlmICghKGV4cCBpbnN0YW5jZW9mIFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IpKSB7XHJcbiAgICAgICAgdGhyb3cgZXhwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxuXHJcbiAgcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0ID0gKHJlcXVlc3RJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3QocmVxdWVzdElkKTtcclxuICAgIH0gY2F0Y2ggKGV4cCkge1xyXG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBQZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xyXG4gICAgICAgIHRocm93IGV4cDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH0gY2F0Y2ggKGV4cCkge1xyXG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBQZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xyXG4gICAgICAgIHRocm93IGV4cDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJlc29sdmVQZW5kaW5nQXBwcm92YWwgPSAoaWQsIHZhbHVlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5hY2NlcHQoaWQsIHZhbHVlKTtcclxuICAgIH0gY2F0Y2ggKGV4cCkge1xyXG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBBcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xyXG4gICAgICAgIHRocm93IGV4cDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJlamVjdFBlbmRpbmdBcHByb3ZhbCA9IChpZCwgZXJyb3IpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuYXBwcm92YWxDb250cm9sbGVyLnJlamVjdChcclxuICAgICAgICBpZCxcclxuICAgICAgICBuZXcgRXRoZXJldW1ScGNFcnJvcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlLCBlcnJvci5kYXRhKSxcclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGV4cCkge1xyXG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBBcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xyXG4gICAgICAgIHRocm93IGV4cDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGFzeW5jIHNlY3VyaXR5UHJvdmlkZXJSZXF1ZXN0KHJlcXVlc3REYXRhLCBtZXRob2ROYW1lKSB7XHJcbiAgICBjb25zdCB7IGN1cnJlbnRMb2NhbGUsIHRyYW5zYWN0aW9uU2VjdXJpdHlDaGVja0VuYWJsZWQgfSA9XHJcbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgaWYgKHRyYW5zYWN0aW9uU2VjdXJpdHlDaGVja0VuYWJsZWQpIHtcclxuICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihcclxuICAgICAgICBoZXhUb0RlY2ltYWwoXHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcclxuICAgICAgICApLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzZWN1cml0eVByb3ZpZGVyUmVzcG9uc2UgPSBhd2FpdCBzZWN1cml0eVByb3ZpZGVyQ2hlY2soXHJcbiAgICAgICAgICByZXF1ZXN0RGF0YSxcclxuICAgICAgICAgIG1ldGhvZE5hbWUsXHJcbiAgICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgICAgY3VycmVudExvY2FsZSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gc2VjdXJpdHlQcm92aWRlclJlc3BvbnNlO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBsb2cuZXJyb3IoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh2ZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgPT09ICdldGhlcnNjYW4nKSB7XHJcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci50eXBlID0gJ3JwYyc7XHJcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPVxyXG4gICAgICAgICAgJ2h0dHBzOi8vcnBjLm1ldGFtYXNrLmlvLyc7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgLy8gZW1wdHlcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzO1xyXG5jb25zdCBvbGRUZXN0UnBjID0gJ2h0dHBzOi8vcmF3dGVzdHJwYy5tZXRhbWFzay5pby8nO1xyXG5jb25zdCBuZXdUZXN0UnBjID0gJ2h0dHBzOi8vdGVzdHJwYy5tZXRhbWFzay5pby8nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPT09IG9sZFRlc3RScGMpIHtcclxuICAgICAgICB2ZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnJwY1RhcmdldCA9IG5ld1Rlc3RScGM7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgLy8gZW1wdHlcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUodmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3Qgc2FmZVZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAodmVyc2lvbmVkRGF0YSk7XHJcbiAgICBzYWZlVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgIT09ICdycGMnKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzYWZlVmVyc2lvbmVkRGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQpIHtcclxuICAgICAgICBjYXNlICdodHRwczovL3Rlc3RycGMubWV0YW1hc2suaW8vJzpcclxuICAgICAgICAgIHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAndGVzdG5ldCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaHR0cHM6Ly9ycGMubWV0YW1hc2suaW8vJzpcclxuICAgICAgICAgIHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnbWFpbm5ldCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gTm8gZGVmYXVsdFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgIC8vIGVtcHR5XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNhZmVWZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gbW92ZXMgc3RhdGUgZnJvbSB0aGUgZmxhdCBzdGF0ZSB0cmllIGludG8gS2V5cmluZ0NvbnRyb2xsZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHNlbGVjdFN1YnN0YXRlRm9yS2V5cmluZ0NvbnRyb2xsZXIoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjNSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2VsZWN0U3Vic3RhdGVGb3JLZXlyaW5nQ29udHJvbGxlcihzdGF0ZSkge1xyXG4gIGNvbnN0IHsgY29uZmlnIH0gPSBzdGF0ZTtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgS2V5cmluZ0NvbnRyb2xsZXI6IHtcclxuICAgICAgdmF1bHQ6IHN0YXRlLnZhdWx0LFxyXG4gICAgICBzZWxlY3RlZEFjY291bnQ6IGNvbmZpZy5zZWxlY3RlZEFjY291bnQsXHJcbiAgICAgIHdhbGxldE5pY2tuYW1lczogc3RhdGUud2FsbGV0Tmlja25hbWVzLFxyXG4gICAgfSxcclxuICB9O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS52YXVsdDtcclxuICBkZWxldGUgbmV3U3RhdGUud2FsbGV0Tmlja25hbWVzO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcuc2VsZWN0ZWRBY2NvdW50O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vdmVzIEtleXJpbmdDb250cm9sbGVyLnNlbGVjdGVkQWRkcmVzcyB0byBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2VsZWN0ZWRBZGRyZXNzXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSBtaWdyYXRlU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gbWlncmF0ZVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3Qga2V5cmluZ1N1YnN0YXRlID0gc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXI7XHJcblxyXG4gIC8vIGFkZCBuZXcgc3RhdGVcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIHNlbGVjdGVkQWRkcmVzczoga2V5cmluZ1N1YnN0YXRlLnNlbGVjdGVkQWNjb3VudCxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gcm0gb2xkIHN0YXRlXHJcbiAgZGVsZXRlIG5ld1N0YXRlLktleXJpbmdDb250cm9sbGVyLnNlbGVjdGVkQWNjb3VudDtcclxuXHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBicmVha3Mgb3V0IHRoZSBUcmFuc2FjdGlvbk1hbmFnZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFRyYW5zYWN0aW9uTWFuYWdlcjoge1xyXG4gICAgICB0cmFuc2FjdGlvbnM6IHN0YXRlLnRyYW5zYWN0aW9ucyB8fCBbXSxcclxuICAgICAgZ2FzTXVsdGlwbGllcjogc3RhdGUuZ2FzTXVsdGlwbGllciB8fCAxLFxyXG4gICAgfSxcclxuICB9O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS50cmFuc2FjdGlvbnM7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLmdhc011bHRpcGxpZXI7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgTm90aWNlQ29udHJvbGxlciBzdWJzdGF0ZVxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gODtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgTm90aWNlQ29udHJvbGxlcjoge1xyXG4gICAgICBub3RpY2VzTGlzdDogc3RhdGUubm90aWNlc0xpc3QgfHwgW10sXHJcbiAgICB9LFxyXG4gIH07XHJcbiAgZGVsZXRlIG5ld1N0YXRlLm5vdGljZXNMaXN0O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGJyZWFrcyBvdXQgdGhlIEN1cnJlbmN5Q29udHJvbGxlciBzdWJzdGF0ZVxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCwgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBtZXJnZSh7fSwgc3RhdGUsIHtcclxuICAgIEN1cnJlbmN5Q29udHJvbGxlcjoge1xyXG4gICAgICBjdXJyZW50Q3VycmVuY3k6IHN0YXRlLmN1cnJlbnRGaWF0IHx8IHN0YXRlLmZpYXRDdXJyZW5jeSB8fCAnVVNEJyxcclxuICAgICAgY29udmVyc2lvblJhdGU6IHN0YXRlLmNvbnZlcnNpb25SYXRlLFxyXG4gICAgICBjb252ZXJzaW9uRGF0ZTogc3RhdGUuY29udmVyc2lvbkRhdGUsXHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jdXJyZW50RmlhdDtcclxuICBkZWxldGUgbmV3U3RhdGUuZmlhdEN1cnJlbmN5O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb252ZXJzaW9uUmF0ZTtcclxuICBkZWxldGUgbmV3U3RhdGUuY29udmVyc2lvbkRhdGU7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgU2hhcGVTaGlmdENvbnRyb2xsZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IG1lcmdlKHt9LCBzdGF0ZSwge1xyXG4gICAgU2hhcGVTaGlmdENvbnRyb2xsZXI6IHtcclxuICAgICAgc2hhcGVTaGlmdFR4TGlzdDogc3RhdGUuc2hhcGVTaGlmdFR4TGlzdCB8fCBbXSxcclxuICAgIH0sXHJcbiAgfSk7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLnNoYXBlU2hpZnRUeExpc3Q7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgZGlzY2FpbWVyIHN0YXRlIGZyb20gb3VyIGFwcCwgd2hpY2ggd2FzIGludGVncmF0ZWQgaW50byBvdXIgbm90aWNlcy5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDExO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLlRPU0hhc2g7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLmlzRGlzY2xhaW1lckNvbmZpcm1lZDtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIG91ciBub3RpY2VzIHRvIGRlbGV0ZSB0aGVpciBib2R5IGFmdGVyIGJlaW5nIHJlYWQuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIG5ld1N0YXRlLk5vdGljZUNvbnRyb2xsZXIubm90aWNlc0xpc3QuZm9yRWFjaCgobm90aWNlKSA9PiB7XHJcbiAgICBpZiAobm90aWNlLnJlYWQpIHtcclxuICAgICAgbm90aWNlLmJvZHkgPSAnJztcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIHRoZSBuZXR3b3JrIGNvbmZpZyBmcm9tIGFtYmlndW91cyAndGVzdG5ldCcgdG8gZXhwbGljaXQgJ3JvcHN0ZW4nXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIGNvbnN0IHsgY29uZmlnIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5wcm92aWRlcikge1xyXG4gICAgaWYgKGNvbmZpZy5wcm92aWRlci50eXBlID09PSAndGVzdG5ldCcpIHtcclxuICAgICAgbmV3U3RhdGUuY29uZmlnLnByb3ZpZGVyLnR5cGUgPSAncm9wc3Rlbic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyBwcm92aWRlciBmcm9tIGNvbmZpZyBhbmQgbW92ZXMgaXQgdG9vIE5ldHdvcmtDb250cm9sbGVyLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlciA9IHt9O1xyXG4gIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0gbmV3U3RhdGUuY29uZmlnLnByb3ZpZGVyO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXI7XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyB3aXRoIHRoZSAnR2F2ZSB1cCBzdWJtaXR0aW5nIHR4LicgZXJyIG1lc3NhZ2VcclxudG8gYSAnZmFpbGVkJyBzdGF0ZWRcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDE1O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xyXG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKCF0eE1ldGEuZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfSBlbHNlIGlmICh0eE1ldGEuZXJyLm1lc3NhZ2UgPT09ICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJykge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdpdGggdGhlICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJyBlcnIgbWVzc2FnZVxyXG50byBhICdmYWlsZWQnIHN0YXRlZFxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTY7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKCF0eE1ldGEuZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHhNZXRhLmVyciA9PT0gJ3RyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC4nXHJcbiAgICAgICkge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XHJcbiAgICAgICAgZGVsZXRlIHR4TWV0YS5lcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdobyB3ZXJlIHJldHJpZWQgYW5kIG1hcmtlZCBhcyBmYWlsZWQgdG8gc3VibWl0dGVkXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxNztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XHJcbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XHJcbiAgICAgIGlmICghdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHhNZXRhLnJldHJ5Q291bnQgPiAwICYmIHR4TWV0YS5yZXRyeUNvdW50IDwgMikge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XHJcbiAgICAgICAgZGVsZXRlIHR4TWV0YS5lcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHVwZGF0ZXMgXCJ0cmFuc2FjdGlvbiBzdGF0ZSBoaXN0b3J5XCIgdG8gZGlmZnMgc3R5bGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQge1xyXG4gIHNuYXBzaG90RnJvbVR4TWV0YSxcclxuICBtaWdyYXRlRnJvbVNuYXBzaG90c1RvRGlmZnMsXHJcbn0gZnJvbSAnLi4vY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zL2xpYi90eC1zdGF0ZS1oaXN0b3J5LWhlbHBlcnMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDE4O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xyXG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgLy8gbm8gaGlzdG9yeTogaW5pdGlhbGl6ZVxyXG4gICAgICBpZiAoIXR4TWV0YS5oaXN0b3J5IHx8IHR4TWV0YS5oaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSk7XHJcbiAgICAgICAgdHhNZXRhLmhpc3RvcnkgPSBbc25hcHNob3RdO1xyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaGFzIGhpc3Rvcnk6IG1pZ3JhdGVcclxuICAgICAgY29uc3QgbmV3SGlzdG9yeSA9IG1pZ3JhdGVGcm9tU25hcHNob3RzVG9EaWZmcyh0eE1ldGEuaGlzdG9yeSlcclxuICAgICAgICAvLyByZW1vdmUgZW1wdHkgZGlmZnNcclxuICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCBlbnRyeS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB0eE1ldGEuaGlzdG9yeSA9IG5ld0hpc3Rvcnk7XHJcbiAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyBhcyBmYWlsZWRcclxud2hvcyBub25jZSBpcyB0b28gaGlnaFxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKFxyXG4gICAgICAodHhNZXRhLCBfLCB0eExpc3QpID0+IHtcclxuICAgICAgICBpZiAodHhNZXRhLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29uZmlybWVkVHhzID0gdHhMaXN0XHJcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHguc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQpXHJcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHgudHhQYXJhbXMuZnJvbSA9PT0gdHhNZXRhLnR4UGFyYW1zLmZyb20pXHJcbiAgICAgICAgICAuZmlsdGVyKFxyXG4gICAgICAgICAgICAodHgpID0+IHR4Lm1ldGFtYXNrTmV0d29ya0lkLmZyb20gPT09IHR4TWV0YS5tZXRhbWFza05ldHdvcmtJZC5mcm9tLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBoaWdoZXN0Q29uZmlybWVkTm9uY2UgPSBnZXRIaWdoZXN0Tm9uY2UoY29uZmlybWVkVHhzKTtcclxuXHJcbiAgICAgICAgY29uc3QgcGVuZGluZ1R4cyA9IHR4TGlzdFxyXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkKVxyXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnR4UGFyYW1zLmZyb20gPT09IHR4TWV0YS50eFBhcmFtcy5mcm9tKVxyXG4gICAgICAgICAgLmZpbHRlcihcclxuICAgICAgICAgICAgKHR4KSA9PiB0eC5tZXRhbWFza05ldHdvcmtJZC5mcm9tID09PSB0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQuZnJvbSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgaGlnaGVzdENvbnRpbnVvdXNOb25jZSA9IGdldEhpZ2hlc3RDb250aW51b3VzRnJvbShcclxuICAgICAgICAgIHBlbmRpbmdUeHMsXHJcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4Tm9uY2UgPSBNYXRoLm1heChcclxuICAgICAgICAgIGhpZ2hlc3RDb250aW51b3VzTm9uY2UsXHJcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKHBhcnNlSW50KHR4TWV0YS50eFBhcmFtcy5ub25jZSwgMTYpID4gbWF4Tm9uY2UgKyAxKSB7XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkO1xyXG4gICAgICAgICAgdHhNZXRhLmVyciA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZTogJ25vbmNlIHRvbyBoaWdoJyxcclxuICAgICAgICAgICAgbm90ZTogJ21pZ3JhdGlvbiAwMTkgY3VzdG9tIGVycm9yJyxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hlc3RDb250aW51b3VzRnJvbSh0eExpc3QsIHN0YXJ0UG9pbnQpIHtcclxuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcclxuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcclxuICAgIHJldHVybiBwYXJzZUludChub25jZSwgMTYpO1xyXG4gIH0pO1xyXG5cclxuICBsZXQgaGlnaGVzdCA9IHN0YXJ0UG9pbnQ7XHJcbiAgd2hpbGUgKG5vbmNlcy5pbmNsdWRlcyhoaWdoZXN0KSkge1xyXG4gICAgaGlnaGVzdCArPSAxO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGhpZ2hlc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hlc3ROb25jZSh0eExpc3QpIHtcclxuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcclxuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcclxuICAgIHJldHVybiBwYXJzZUludChub25jZSB8fCAnMHgwJywgMTYpO1xyXG4gIH0pO1xyXG4gIGNvbnN0IGhpZ2hlc3ROb25jZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG5vbmNlcyk7XHJcbiAgcmV0dXJuIGhpZ2hlc3ROb25jZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gZW5zdXJlcyBwcmV2aW91cyBpbnN0YWxsYXRpb25zXHJcbmdldCBhIGBmaXJzdFRpbWVJbmZvYCBrZXkgb24gdGhlIG1ldGFtYXNrIHN0YXRlLFxyXG5zbyB0aGF0IHdlIGNhbiB2ZXJzaW9uIG5vdGljZXMgaW4gdGhlIGZ1dHVyZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgaWYgKCdtZXRhbWFzaycgaW4gbmV3U3RhdGUgJiYgISgnZmlyc3RUaW1lSW5mbycgaW4gbmV3U3RhdGUubWV0YW1hc2spKSB7XHJcbiAgICBuZXdTdGF0ZS5tZXRhbWFzay5maXJzdFRpbWVJbmZvID0ge1xyXG4gICAgICB2ZXJzaW9uOiAnMy4xMi4wJyxcclxuICAgICAgZGF0ZTogRGF0ZS5ub3coKSxcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgQmxhY2tMaXN0Q29udHJvbGxlciBmcm9tIGRpc2sgc3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIxO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLkJsYWNrbGlzdENvbnRyb2xsZXI7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLlJlY2VudEJsb2NrcztcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGFkZHMgc3VibWl0dGVkVGltZSB0byB0aGUgdHhNZXRhIGlmIGl0IGlzIG5vdCB0aGVpclxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgIT09IFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCB8fFxyXG4gICAgICAgIHR4TWV0YS5zdWJtaXR0ZWRUaW1lXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH1cclxuICAgICAgdHhNZXRhLnN1Ym1pdHRlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHJlbW92ZXMgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VmdWxsIGRvd24gdG8gNDAgdG90YWxcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcblxyXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XHJcblxyXG4gICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPD0gNDApIHtcclxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJldmVyc2VUeExpc3QgPSB0cmFuc2FjdGlvbnMucmV2ZXJzZSgpO1xyXG4gICAgbGV0IHN0cmlwcGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAocmV2ZXJzZVR4TGlzdC5sZW5ndGggPiA0MCAmJiBzdHJpcHBpbmcpIHtcclxuICAgICAgY29uc3QgdHhJbmRleCA9IHJldmVyc2VUeExpc3QuZmluZEluZGV4KCh0eE1ldGEpID0+IHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkIHx8XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5yZWplY3RlZCB8fFxyXG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5kcm9wcGVkXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICh0eEluZGV4IDwgMCkge1xyXG4gICAgICAgIHN0cmlwcGluZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldmVyc2VUeExpc3Quc3BsaWNlKHR4SW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHJldmVyc2VUeExpc3QucmV2ZXJzZSgpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGVuc3VyZXMgdGhhdCB0aGUgZnJvbSBhZGRyZXNzIGluIHR4UGFyYW1zIGlzIHRvIGxvd2VyIGNhc2UgZm9yXHJcbmFsbCB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uc1xyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgaWYgKCFuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIpIHtcclxuICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICB9XHJcbiAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcChcclxuICAgICh0eE1ldGEsIF8pID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQgJiZcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMgJiZcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbVxyXG4gICAgICApIHtcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbSA9IHR4TWV0YS50eFBhcmFtcy5mcm9tLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0sXHJcbiAgKTtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uL2xpYi91dGlsJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyNTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xyXG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoXHJcbiAgICAgICAgKHR4TWV0YSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHR4TWV0YS5zdGF0dXMgIT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHR4TWV0YS50eFBhcmFtcyA9IG5vcm1hbGl6ZVR4UGFyYW1zKHR4TWV0YS50eFBhcmFtcyk7XHJcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVR4UGFyYW1zKHR4UGFyYW1zKSB7XHJcbiAgLy8gZnVuY3Rpb25zIHRoYXQgaGFuZGxlIG5vcm1hbGl6aW5nIG9mIHRoYXQga2V5IGluIHR4UGFyYW1zXHJcbiAgY29uc3Qgd2hpdGVMaXN0ID0ge1xyXG4gICAgZnJvbTogKGZyb20pID0+IGFkZEhleFByZWZpeChmcm9tKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgdG86ICgpID0+IGFkZEhleFByZWZpeCh0eFBhcmFtcy50bykudG9Mb3dlckNhc2UoKSxcclxuICAgIG5vbmNlOiAobm9uY2UpID0+IGFkZEhleFByZWZpeChub25jZSksXHJcbiAgICB2YWx1ZTogKHZhbHVlKSA9PiBhZGRIZXhQcmVmaXgodmFsdWUpLFxyXG4gICAgZGF0YTogKGRhdGEpID0+IGFkZEhleFByZWZpeChkYXRhKSxcclxuICAgIGdhczogKGdhcykgPT4gYWRkSGV4UHJlZml4KGdhcyksXHJcbiAgICBnYXNQcmljZTogKGdhc1ByaWNlKSA9PiBhZGRIZXhQcmVmaXgoZ2FzUHJpY2UpLFxyXG4gIH07XHJcblxyXG4gIC8vIGFwcGx5IG9ubHkga2V5cyBpbiB0aGUgd2hpdGVMaXN0XHJcbiAgY29uc3Qgbm9ybWFsaXplZFR4UGFyYW1zID0ge307XHJcbiAgT2JqZWN0LmtleXMod2hpdGVMaXN0KS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgIGlmICh0eFBhcmFtc1trZXldKSB7XHJcbiAgICAgIG5vcm1hbGl6ZWRUeFBhcmFtc1trZXldID0gd2hpdGVMaXN0W2tleV0odHhQYXJhbXNba2V5XSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBub3JtYWxpemVkVHhQYXJhbXM7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vdmVzIHRoZSBpZGVudGl0aWVzIHN0b3JlZCBpbiB0aGUgS2V5cmluZ0NvbnRyb2xsZXJcclxuIGludG8gdGhlIFByZWZlcmVuY2VzQ29udHJvbGxlclxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjY7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKCFzdGF0ZS5LZXlyaW5nQ29udHJvbGxlciB8fCAhc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcykge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmlkZW50aXRpZXMgPSBPYmplY3Qua2V5cyhcclxuICAgIHN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcyxcclxuICApLnJlZHVjZSgoaWRlbnRpdGllcywgYWRkcmVzcykgPT4ge1xyXG4gICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IHtcclxuICAgICAgbmFtZTogc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzW2FkZHJlc3NdLFxyXG4gICAgICBhZGRyZXNzLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBpZGVudGl0aWVzO1xyXG4gIH0sIHt9KTtcclxuICBkZWxldGUgc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXHJcbi8qXHJcblxyXG5ub3JtYWxpemVzIHR4UGFyYW1zIG9uIHVuY29uZmlybWVkIHR4c1xyXG5cclxuKi9cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyNztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xyXG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5maWx0ZXIoXHJcbiAgICAgICAgKHR4TWV0YSkgPT4gdHhNZXRhLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjg7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcblxyXG4gIGlmIChuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIGlmIChcclxuICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyAmJlxyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaWRlbnRpdGllc1xyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IHsgaWRlbnRpdGllcywgdG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XHJcbiAgICAgIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0ge307XHJcbiAgICAgIE9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmZvckVhY2goKGlkZW50aXR5KSA9PiB7XHJcbiAgICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbaWRlbnRpdHldID0ge1xyXG4gICAgICAgICAgbWFpbm5ldDogdG9rZW5zLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5pbXBvcnQgZmFpbFR4c1RoYXQgZnJvbSAnLi9mYWlsLXR4JztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyOTtcclxuXHJcbi8vIHRpbWVcclxuY29uc3Qgc2Vjb25kcyA9IDEwMDA7XHJcbmNvbnN0IG1pbnV0ZXMgPSA2MCAqIHNlY29uZHM7XHJcbmNvbnN0IGhvdXJzID0gNjAgKiBtaW51dGVzO1xyXG5jb25zdCB1bmFjY2VwdGFibGVEZWxheSA9IDEyICogaG91cnM7XHJcblxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZTogZmFpbFR4c1RoYXQoXHJcbiAgICB2ZXJzaW9uLFxyXG4gICAgJ1N0dWNrIGluIGFwcHJvdmVkIHN0YXRlIGZvciB0b28gbG9uZy4nLFxyXG4gICAgKHR4TWV0YSkgPT4ge1xyXG4gICAgICBjb25zdCBpc0FwcHJvdmVkID0gdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuYXBwcm92ZWQ7XHJcbiAgICAgIGNvbnN0IGNyZWF0ZWRUaW1lID0gdHhNZXRhLnN1Ym1pdHRlZFRpbWU7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIHJldHVybiBpc0FwcHJvdmVkICYmIG5vdyAtIGNyZWF0ZWRUaW1lID4gdW5hY2NlcHRhYmxlRGVsYXk7XHJcbiAgICB9LFxyXG4gICksXHJcbn07XHJcbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcclxuLypcclxuXHJcbnJlbW92ZXMgaW52YWxpZCBjaGFpZHMgZnJvbSBwcmVmZXJlbmNlcyBhbmQgbmV0d29ya0NvbnRyb2xsZXIgZm9yIGN1c3RvbSBycGNzXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzMDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdERldGFpbCB9ID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xyXG4gICAgaWYgKGZyZXF1ZW50UnBjTGlzdERldGFpbCkge1xyXG4gICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgocnBjLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICAgIGlmIChCb29sZWFuKHJwYy5jaGFpbklkKSAmJiBOdW1iZXIuaXNOYU4ocGFyc2VJbnQocnBjLmNoYWluSWQpKSkge1xyXG4gICAgICAgICAgZGVsZXRlIGZyZXF1ZW50UnBjTGlzdERldGFpbFtpbmRleF0uY2hhaW5JZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID1cclxuICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikge1xyXG4gICAgaWYgKFxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrICYmXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29yaykpXHJcbiAgICApIHtcclxuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciAmJlxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5jaGFpbklkICYmXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIuY2hhaW5JZCkpXHJcbiAgICApIHtcclxuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDMxO1xyXG5cclxuLypcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gcHJvcGVybHkgc2V0IHRoZSBjb21wbGV0ZWRPbmJvYXJkaW5nIGZsYWcgYmFzZWQgb24gdGhlIHN0YXRlXHJcbiAqIG9mIHRoZSBLZXlyaW5nQ29udHJvbGxlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBLZXlyaW5nQ29udHJvbGxlciwgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgaWYgKEtleXJpbmdDb250cm9sbGVyICYmIFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgeyB2YXVsdCB9ID0gS2V5cmluZ0NvbnRyb2xsZXI7XHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZyA9IEJvb2xlYW4odmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzI7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gc2V0IHRoZSB7QGNvZGUgY29tcGxldGVkVWlNaWdyYXRpb259IGZsYWcgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBwcmVmZXJlbmNlc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGJldGFVSSB9ID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcclxuICAgIC8vIFVzZXJzIHdobyBoYXZlIGJlZW4gdXNpbmcgdGhlIFwiYmV0YVwiIFVJIGFyZSBjb25zaWRlcmVkIHRvIGhhdmUgY29tcGxldGVkIHRoZSBtaWdyYXRpb25cclxuICAgIC8vIGFzIHRoZXknbGwgc2VlIG5vIGRpZmZlcmVuY2UgaW4gdGhpcyB2ZXJzaW9uXHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkVWlNaWdyYXRpb24gPSBiZXRhVUk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxuQ2xlYW5zIHVwIG5vdGljZXMgYW5kIGFzc29jYXRlZCBub3RpY2UgY29udHJvbGxlciBjb2RlXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzMztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICAvLyB0cmFuc2Zvcm0gc3RhdGUgaGVyZVxyXG4gIGlmIChzdGF0ZS5Ob3RpY2VDb250cm9sbGVyKSB7XHJcbiAgICBkZWxldGUgbmV3U3RhdGUuTm90aWNlQ29udHJvbGxlcjtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzQ7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gZW5hYmxlIHRoZSB7QGNvZGUgcHJpdmFjeU1vZGV9IGZlYXR1cmUgZmxhZyBhbmQgc2V0IHRoZSB1c2VyIGFzIGJlaW5nIG1pZ3JhdGVkXHJcbiAqIGlmIGl0IHdhcyB7QGNvZGUgZmFsc2V9LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCBmZWF0dXJlRmxhZ3MgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmVhdHVyZUZsYWdzIHx8IHt9O1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIWZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAmJlxyXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLm1pZ3JhdGVkUHJpdmFjeU1vZGUgPT09ICd1bmRlZmluZWQnXHJcbiAgICApIHtcclxuICAgICAgLy8gTWFyayB0aGUgc3RhdGUgaGFzIGJlaW5nIG1pZ3JhdGVkIGFuZCBlbmFibGUgUHJpdmFjeSBNb2RlXHJcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5taWdyYXRlZFByaXZhY3lNb2RlID0gdHJ1ZTtcclxuICAgICAgZmVhdHVyZUZsYWdzLnByaXZhY3lNb2RlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXHJcbi8qXHJcblxyXG5SZW1vdmVzIHRoZSBkZXByZWNhdGVkICdzZWVkV29yZHMnIHN0YXRlXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzNTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlciAmJlxyXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcyAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcztcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzY7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gcmVtb3ZlIHRoZSB7QGNvZGUgcHJpdmFjeU1vZGV9IGZlYXR1cmUgZmxhZy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgZmVhdHVyZUZsYWdzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZGVsZXRlIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBub3JtYWxpemVFbnNOYW1lIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDM3O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHVwZGF0ZSB0aGUgYWRkcmVzcyBib29rIHN0YXRlXHJcbiAqIHRvIHRoZSBuZXcgc2NoZW1hIHdpdGggY2hhaW5JZCBhcyBhIGtleS5cclxuICogYW5kIHRvIGFkZCB0aGUgaXNFbnMgZmxhZyB0byBhbGwgZW50cmllc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgYWIgPSBzdGF0ZS5BZGRyZXNzQm9va0NvbnRyb2xsZXIuYWRkcmVzc0Jvb2s7XHJcblxyXG4gICAgY29uc3QgY2hhaW5JZHMgPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBuZXdBZGRyZXNzQm9vayA9IHt9O1xyXG5cclxuICAgIC8vIGFkZCBhbGwgb2YgdGhlIGNoYWluSWRzIHRvIGEgc2V0XHJcbiAgICBPYmplY3QudmFsdWVzKGFiKS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgIGNoYWluSWRzLmFkZCh2LmNoYWluSWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZmlsbCB0aGUgY2hhaW5JZCBvYmplY3Qgd2l0aCB0aGUgZW50cmllcyB3aXRoIHRoZSBtYXRjaGluZyBjaGFpbklkXHJcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGNoYWluSWRzLnZhbHVlcygpKSB7XHJcbiAgICAgIC8vIG1ha2UgYW4gZW1wdHkgb2JqZWN0IGVudHJ5IGZvciBlYWNoIGNoYWluSWRcclxuICAgICAgbmV3QWRkcmVzc0Jvb2tbaWRdID0ge307XHJcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBpbiBhYikge1xyXG4gICAgICAgIGlmIChhYlthZGRyZXNzXS5jaGFpbklkID09PSBpZCkge1xyXG4gICAgICAgICAgYWJbYWRkcmVzc10uaXNFbnMgPSBmYWxzZTtcclxuICAgICAgICAgIGlmIChub3JtYWxpemVFbnNOYW1lKGFiW2FkZHJlc3NdLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIGFiW2FkZHJlc3NdLmlzRW5zID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5ld0FkZHJlc3NCb29rW2lkXVthZGRyZXNzXSA9IGFiW2FkZHJlc3NdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlci5hZGRyZXNzQm9vayA9IG5ld0FkZHJlc3NCb29rO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzg7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gYXNzaWduIGFsbCB1c2VycyB0byBhIHRlc3QgZ3JvdXAgZm9yIHRoZSBmdWxsU2NyZWVuVnNQb3B1cCBhL2IgdGVzdFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBBQlRlc3RDb250cm9sbGVyOiBBQlRlc3RDb250cm9sbGVyU3RhdGUgPSB7fSB9ID0gc3RhdGU7XHJcbiAgY29uc3QgeyBhYlRlc3RzID0ge30gfSA9IEFCVGVzdENvbnRyb2xsZXJTdGF0ZTtcclxuXHJcbiAgaWYgKGFiVGVzdHMuZnVsbFNjcmVlblZzUG9wdXApIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIEFCVGVzdENvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uQUJUZXN0Q29udHJvbGxlclN0YXRlLFxyXG4gICAgICBhYlRlc3RzOiB7XHJcbiAgICAgICAgLi4uYWJUZXN0cyxcclxuICAgICAgICBmdWxsU2NyZWVuVnNQb3B1cDogJ2NvbnRyb2wnLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IHRvQ2hlY2tzdW1IZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzOTtcclxuXHJcbmNvbnN0IERBSV9WMV9DT05UUkFDVF9BRERSRVNTID0gJzB4ODlkMjRBNmI0Q2NCMUI2ZkFBMjYyNWZFNTYyYkREOWEyMzI2MDM1OSc7XHJcbmNvbnN0IERBSV9WMV9UT0tFTl9TWU1CT0wgPSAnREFJJztcclxuY29uc3QgU0FJX1RPS0VOX1NZTUJPTCA9ICdTQUknO1xyXG5cclxuZnVuY3Rpb24gaXNPbGREYWkodG9rZW4gPSB7fSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0b2tlbiAmJlxyXG4gICAgdHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJlxyXG4gICAgdG9rZW4uc3ltYm9sID09PSBEQUlfVjFfVE9LRU5fU1lNQk9MICYmXHJcbiAgICB0b0NoZWNrc3VtSGV4QWRkcmVzcyh0b2tlbi5hZGRyZXNzKSA9PT0gREFJX1YxX0NPTlRSQUNUX0FERFJFU1NcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtaWdyYXRpb24gcmVuYW1lcyB0aGUgRGFpIHRva2VuIHRvIFNhaS5cclxuICpcclxuICogQXMgb2YgMjAxOS0xMS0xOCBEYWkgaXMgbm93IGNhbGxlZCBTYWkgKHJlZnMgaHR0cHM6Ly9naXQuaW8vSmVvb1ApIHRvIGZhY2lsaXRhdGVcclxuICogTWFrZXIncyB1cGdyYWRlIHRvIE11bHRpLUNvbGxhdGVyYWwgRGFpIGFuZCB0aGlzIG1pZ3JhdGlvbiByZW5hbWVzIHRoZSB0b2tlblxyXG4gKiBhdCB0aGUgb2xkIGFkZHJlc3MuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XHJcblxyXG4gIGlmIChQcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgfHwgW107XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XHJcbiAgICAgICAgaWYgKGlzT2xkRGFpKHRva2VuKSkge1xyXG4gICAgICAgICAgdG9rZW4uc3ltYm9sID0gU0FJX1RPS0VOX1NZTUJPTDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhY2NvdW50VG9rZW5zID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgfHwge307XHJcbiAgICBpZiAoYWNjb3VudFRva2VucyAmJiB0eXBlb2YgYWNjb3VudFRva2VucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XHJcbiAgICAgICAgaWYgKG5ldHdvcmtUb2tlbnMgJiYgdHlwZW9mIG5ldHdvcmtUb2tlbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgT2JqZWN0LmtleXMobmV0d29ya1Rva2VucykpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zT25OZXR3b3JrKSkge1xyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zT25OZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbGREYWkodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRva2VuLnN5bWJvbCA9IFNBSV9UT0tFTl9TWU1CT0w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0MDtcclxuXHJcbi8qKlxyXG4gKiBTaXRlIGNvbm5lY3Rpb25zIGFyZSBub3cgbWFuYWdlZCBieSB0aGUgUGVybWlzc2lvbnNDb250cm9sbGVyLCBhbmQgdGhlXHJcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIGlzIHJlbW92ZWQuIFRoaXMgbWlncmF0aW9uIGRlbGV0ZXMgYWxsXHJcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgZGVsZXRlIHN0YXRlLlByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQxO1xyXG5cclxuLyoqXHJcbiAqIFByZWZlcmVuY2VzQ29udHJvbGxlci5hdXRvTG9nb3V0VGltZUxpbWl0IC0+IGF1dG9Mb2NrVGltZUxpbWl0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyICYmIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcykge1xyXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2NrVGltZUxpbWl0ID1cclxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2dvdXRUaW1lTGltaXQ7XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2dvdXRUaW1lTGltaXQ7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQyO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd25gIHRvIGBmYWxzZWAgaWYgaXQgaGFzbid0IHlldCBiZWVuIHNldCxcclxuICogc28gdGhhdCBleGlzdGluZyB1c2VycyBhcmUgaW50cm9kdWNlZCB0byB0aGUgbmV3IGNvbm5lY3RlZCBzdGF0dXMgaW5kaWNhdG9yXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIuY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93biA9IGZhbHNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIgPSB7XHJcbiAgICAgIGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd246IGZhbHNlLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNDM7XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHVudXNlZCAnY3VycmVudEFjY291bnRUYWInIHN0YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uY3VycmVudEFjY291bnRUYWIpIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY3VycmVudEFjY291bnRUYWI7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ0O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB1bnVzZWQgJ21rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wJyBzdGF0ZSBmcm9tIHRoZSBgQXBwU3RhdGVDb250cm9sbGVyYFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKFxyXG4gICAgdHlwZW9mIHN0YXRlPy5BcHBTdGF0ZUNvbnRyb2xsZXI/Lm1rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wICE9PVxyXG4gICAgJ3VuZGVmaW5lZCdcclxuICApIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIubWtyTWlncmF0aW9uUmVtaW5kZXJUaW1lc3RhbXA7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ1O1xyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIHtAY29kZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuaXBmc0dhdGV3YXl9IHdpdGggJ2R3ZWIubGluaycgaWYgc2V0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3Qgb3V0ZGF0ZWRHYXRld2F5cyA9IFsnaXBmcy5pbycsICdpcGZzLmR3ZWIubGluayddO1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAob3V0ZGF0ZWRHYXRld2F5cy5pbmNsdWRlcyhzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5pcGZzR2F0ZXdheSkpIHtcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5pcGZzR2F0ZXdheSA9ICdkd2ViLmxpbmsnO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0NjtcclxuXHJcbi8qKlxyXG4gKiBEZWxldGUge0Bjb2RlIEFCVGVzdENvbnRyb2xsZXJ9IHN0YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAodHlwZW9mIHN0YXRlPy5BQlRlc3RDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZGVsZXRlIHN0YXRlLkFCVGVzdENvbnRyb2xsZXI7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ3O1xyXG5cclxuLyoqXHJcbiAqIFN0cmluZ2lmeSB0aGUgYG1ldGFtYXNrTmV0d29ya0lkYCBwcm9wZXJ0eSBvZiBhbGwgdHJhbnNhY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPVxyXG4gICAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ4O1xyXG5cclxuLyoqXHJcbiAqIDEuICBEZWxldGUgTmV0d29ya0NvbnRyb2xsZXIuc2V0dGluZ3NcclxuICogMmEuIE1pZ3JhdGUgTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgdG8gUmlua2VieSBpZiBzZXQgdG8gdHlwZSAncnBjJyBvclxyXG4gKiAgICAgJ2xvY2FsaG9zdCcuXHJcbiAqIDJiLiBSZS1rZXkgcHJvdmlkZXIucnBjVGFyZ2V0IHRvIHByb3ZpZGVyLnJwY1VybFxyXG4gKiAzLiAgQWRkIGxvY2FsaG9zdCBuZXR3b3JrIHRvIGZyZXF1ZW50UnBjTGlzdERldGFpbC5cclxuICogNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcclxuICogNS4gIENvbnZlcnQgdHJhbnNhY3Rpb25zIG1ldGFtYXNrTmV0d29ya0lkIHRvIGRlY2ltYWwgaWYgdGhleSBhcmUgaGV4XHJcbiAqIDYuICBDb252ZXJ0IGFkZHJlc3MgYm9vayBrZXlzIGZyb20gZGVjaW1hbCB0byBoZXhcclxuICogNy4gIERlbGV0ZSBsb2NhbGhvc3Qga2V5IGluIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxyXG4gKiA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3QgaGV4UmVnRXggPSAvXjB4WzAtOWEtZl0rJC9pdTtcclxuY29uc3QgY2hhaW5JZFJlZ0V4ID0gL14weFsxLTlhLWZdK1swLTlhLWZdKiQvaXU7XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XHJcbiAgLy8gMS4gRGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLnNldHRpbmdzXHJcbiAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyPy5zZXR0aW5ncztcclxuXHJcbiAgLy8gMi4gTWlncmF0ZSBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciB0byBSaW5rZWJ5IG9yIHJlbmFtZSBycGNUYXJnZXQga2V5XHJcbiAgY29uc3QgcHJvdmlkZXIgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIgfHwge307XHJcbiAgY29uc3QgaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgPVxyXG4gICAgcHJvdmlkZXIudHlwZSA9PT0gJ3JwYycgJiZcclxuICAgICh0eXBlb2YgcHJvdmlkZXIuY2hhaW5JZCAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgIWNoYWluSWRSZWdFeC50ZXN0KHByb3ZpZGVyLmNoYWluSWQpKTtcclxuICBpZiAoaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgfHwgcHJvdmlkZXIudHlwZSA9PT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0ge1xyXG4gICAgICB0eXBlOiAncmlua2VieScsXHJcbiAgICAgIHJwY1VybDogJycsXHJcbiAgICAgIGNoYWluSWQ6ICcweDQnLFxyXG4gICAgICBuaWNrbmFtZTogJycsXHJcbiAgICAgIHJwY1ByZWZzOiB7fSxcclxuICAgICAgdGlja2VyOiAnRVRIJyxcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIpIHtcclxuICAgIGlmICgncnBjVGFyZ2V0JyBpbiBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlcikge1xyXG4gICAgICBjb25zdCBycGNVcmwgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5ycGNUYXJnZXQ7XHJcbiAgICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLnJwY1VybCA9IHJwY1VybDtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXI/LnJwY1RhcmdldDtcclxuICB9XHJcblxyXG4gIC8vIDMuICBBZGQgbG9jYWxob3N0IG5ldHdvcmsgdG8gZnJlcXVlbnRScGNMaXN0RGV0YWlsLlxyXG4gIGlmICghc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSB7fTtcclxuICB9XHJcbiAgaWYgKCFzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB7XHJcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gW107XHJcbiAgfVxyXG4gIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwudW5zaGlmdCh7XHJcbiAgICBycGNVcmw6ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnLFxyXG4gICAgY2hhaW5JZDogJzB4NTM5JyxcclxuICAgIHRpY2tlcjogJ0VUSCcsXHJcbiAgICBuaWNrbmFtZTogJ0xvY2FsaG9zdCA4NTQ1JyxcclxuICAgIHJwY1ByZWZzOiB7fSxcclxuICB9KTtcclxuXHJcbiAgLy8gNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcclxuICBkZWxldGUgc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcztcclxuXHJcbiAgLy8gNS4gIENvbnZlcnQgdHJhbnNhY3Rpb25zIG1ldGFtYXNrTmV0d29ya0lkIHRvIGRlY2ltYWwgaWYgdGhleSBhcmUgaGV4XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1ldGFtYXNrTmV0d29ya0lkID0gdHJhbnNhY3Rpb24/Lm1ldGFtYXNrTmV0d29ya0lkO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIG1ldGFtYXNrTmV0d29ya0lkID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGhleFJlZ0V4LnRlc3QobWV0YW1hc2tOZXR3b3JrSWQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID0gcGFyc2VJbnQoXHJcbiAgICAgICAgICBtZXRhbWFza05ldHdvcmtJZCxcclxuICAgICAgICAgIDE2LFxyXG4gICAgICAgICkudG9TdHJpbmcoMTApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIDYuICBDb252ZXJ0IGFkZHJlc3MgYm9vayBrZXlzIGZyb20gZGVjaW1hbCB0byBoZXhcclxuICBjb25zdCBhZGRyZXNzQm9vayA9IHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlcj8uYWRkcmVzc0Jvb2sgfHwge307XHJcbiAgT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2spLmZvckVhY2goKG5ldHdvcmtLZXkpID0+IHtcclxuICAgIGlmICgvXlxcZCskL2l1LnRlc3QobmV0d29ya0tleSkpIHtcclxuICAgICAgY29uc3QgY2hhaW5JZCA9IGAweCR7cGFyc2VJbnQobmV0d29ya0tleSwgMTApLnRvU3RyaW5nKDE2KX1gO1xyXG4gICAgICB1cGRhdGVDaGFpbklkcyhhZGRyZXNzQm9va1tuZXR3b3JrS2V5XSwgY2hhaW5JZCk7XHJcblxyXG4gICAgICBpZiAoYWRkcmVzc0Jvb2tbY2hhaW5JZF0pIHtcclxuICAgICAgICBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkcmVzc0Jvb2tbY2hhaW5JZF0gPSBhZGRyZXNzQm9va1tuZXR3b3JrS2V5XTtcclxuICAgICAgfVxyXG4gICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbbmV0d29ya0tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIDcuICBEZWxldGUgbG9jYWxob3N0IGtleSBpbiBJbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcclxuICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXHJcbiAgICA/LmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yaz8ubG9jYWxob3N0O1xyXG5cclxuICAvLyA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXHJcbiAgY29uc3QgYWNjb3VudFRva2VucyA9IHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudFRva2VucztcclxuICBpZiAoYWNjb3VudFRva2Vucykge1xyXG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xyXG4gICAgICBjb25zdCBsb2NhbGhvc3RUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3QgfHwgW107XHJcblxyXG4gICAgICBpZiAobG9jYWxob3N0VG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBycGNUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyB8fCBbXTtcclxuXHJcbiAgICAgICAgaWYgKHJwY1Rva2Vucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyA9IG1lcmdlVG9rZW5BcnJheXMoXHJcbiAgICAgICAgICAgIGxvY2FsaG9zdFRva2VucyxcclxuICAgICAgICAgICAgcnBjVG9rZW5zLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgPSBsb2NhbGhvc3RUb2tlbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGRlbGV0ZSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3Q7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0aGUgdHdvIGdpdmVuIGtleXMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzIGJvb2sgaW4gcGxhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBhZGRyZXNzQm9va1xyXG4gKiBAcGFyYW0gbmV0d29ya0tleVxyXG4gKiBAcGFyYW0gY2hhaW5JZEtleVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBZGRyZXNzQm9va0tleXMoYWRkcmVzc0Jvb2ssIG5ldHdvcmtLZXksIGNoYWluSWRLZXkpIHtcclxuICBjb25zdCBuZXR3b3JrS2V5RW50cmllcyA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldIHx8IHt9O1xyXG4gIC8vIEZvciB0aGUgbmV3IGVudHJpZXMsIHN0YXJ0IGJ5IGNvcHlpbmcgdGhlIGV4aXN0aW5nIGVudHJpZXMgZm9yIHRoZSBjaGFpbklkXHJcbiAgY29uc3QgbmV3RW50cmllcyA9IHsgLi4uYWRkcmVzc0Jvb2tbY2hhaW5JZEtleV0gfTtcclxuXHJcbiAgLy8gRm9yIGVhY2ggYWRkcmVzcyBvZiB0aGUgb2xkL25ldHdvcmtJZCBrZXkgZW50cmllc1xyXG4gIE9iamVjdC5rZXlzKG5ldHdvcmtLZXlFbnRyaWVzKS5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XHJcbiAgICBpZiAobmV3RW50cmllc1thZGRyZXNzXSAmJiB0eXBlb2YgbmV3RW50cmllc1thZGRyZXNzXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgY29uc3QgbWVyZ2VkRW50cnkgPSB7fTtcclxuXHJcbiAgICAgIC8vIENvbGxlY3QgYWxsIGtleXMgZnJvbSBib3RoIGVudHJpZXMgYW5kIG1lcmdlIHRoZSBjb3JyZXNwb25kaW5nIGNoYWluSWRcclxuICAgICAgLy8gZW50cnkgd2l0aCB0aGUgbmV0d29ya0lkIGVudHJ5XHJcbiAgICAgIG5ldyBTZXQoW1xyXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ld0VudHJpZXNbYWRkcmVzc10pLFxyXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdIHx8IHt9KSxcclxuICAgICAgXSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgLy8gVXNlIG5vbi1lbXB0eSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQga2V5LCBpZiBhbnlcclxuICAgICAgICBtZXJnZWRFbnRyeVtrZXldID1cclxuICAgICAgICAgIG5ld0VudHJpZXNbYWRkcmVzc11ba2V5XSB8fCBuZXR3b3JrS2V5RW50cmllc1thZGRyZXNzXT8uW2tleV0gfHwgJyc7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbmV3RW50cmllc1thZGRyZXNzXSA9IG1lcmdlZEVudHJ5O1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc10gJiZcclxuICAgICAgdHlwZW9mIG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdID09PSAnb2JqZWN0J1xyXG4gICAgKSB7XHJcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY2hhaW5JZCBlbnRyeSwganVzdCB1c2UgdGhlIG5ldHdvcmtJZCBlbnRyeVxyXG4gICAgICAvLyBkaXJlY3RseVxyXG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc107XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGFkZHJlc3NCb29rW2NoYWluSWRLZXldID0gbmV3RW50cmllcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIGNoYWluSWQga2V5IHZhbHVlcyB0byB0aGUgZ2l2ZW4gY2hhaW5JZCBpbiBwbGFjZSBmb3IgYWxsIHZhbHVlc1xyXG4gKiBvZiB0aGUgZ2l2ZW4gbmV0d29ya0VudHJpZXMgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gbmV0d29ya0VudHJpZXNcclxuICogQHBhcmFtIGNoYWluSWRcclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZUNoYWluSWRzKG5ldHdvcmtFbnRyaWVzLCBjaGFpbklkKSB7XHJcbiAgT2JqZWN0LnZhbHVlcyhuZXR3b3JrRW50cmllcykuZm9yRWFjaCgoZW50cnkpID0+IHtcclxuICAgIGlmIChlbnRyeSAmJiB0eXBlb2YgZW50cnkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGVudHJ5LmNoYWluSWQgPSBjaGFpbklkO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHRoZSB0d28gZ2l2ZW4sIG5vbi1lbXB0eSBhcnJheXMgb2YgdG9rZW4gb2JqZWN0cyBhbmQgcmV0dXJucyBhIG5ld1xyXG4gKiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGxvY2FsaG9zdFRva2Vuc1xyXG4gKiBAcGFyYW0gcnBjVG9rZW5zXHJcbiAqIEByZXR1cm5zIHtBcnJheTxvYmplY3Q+fVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VUb2tlbkFycmF5cyhsb2NhbGhvc3RUb2tlbnMsIHJwY1Rva2Vucykge1xyXG4gIGNvbnN0IGxvY2FsaG9zdFRva2Vuc01hcCA9IHRva2VuQXJyYXlUb01hcChsb2NhbGhvc3RUb2tlbnMpO1xyXG4gIGNvbnN0IHJwY1Rva2Vuc01hcCA9IHRva2VuQXJyYXlUb01hcChycGNUb2tlbnMpO1xyXG5cclxuICBjb25zdCBtZXJnZWRUb2tlbnMgPSBbXTtcclxuICBuZXcgU2V0KFtcclxuICAgIC4uLk9iamVjdC5rZXlzKGxvY2FsaG9zdFRva2Vuc01hcCksXHJcbiAgICAuLi5PYmplY3Qua2V5cyhycGNUb2tlbnNNYXApLFxyXG4gIF0pLmZvckVhY2goKHRva2VuQWRkcmVzcykgPT4ge1xyXG4gICAgbWVyZ2VkVG9rZW5zLnB1c2goe1xyXG4gICAgICAuLi5sb2NhbGhvc3RUb2tlbnNNYXBbdG9rZW5BZGRyZXNzXSxcclxuICAgICAgLi4ucnBjVG9rZW5zTWFwW3Rva2VuQWRkcmVzc10sXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG1lcmdlZFRva2VucztcclxuXHJcbiAgZnVuY3Rpb24gdG9rZW5BcnJheVRvTWFwKGFycmF5KSB7XHJcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChtYXAsIHRva2VuKSA9PiB7XHJcbiAgICAgIGlmICh0b2tlbj8uYWRkcmVzcyAmJiB0eXBlb2YgdG9rZW4/LmFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbWFwW3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH0sIHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0OTtcclxuXHJcbi8qKlxyXG4gKiBNaWdyYXRlIG1ldGFNZXRyaWNzIHN0YXRlIHRvIHRoZSBuZXcgTWV0YU1ldHJpY3MgY29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlID0ge30pIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IG1ldGFNZXRyaWNzSWQsIHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcywgbWV0YU1ldHJpY3NTZW5kQ291bnQgfSA9XHJcbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcclxuICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA9IHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA/PyB7fTtcclxuXHJcbiAgICBpZiAobWV0YU1ldHJpY3NJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkID0gbWV0YU1ldHJpY3NJZDtcclxuICAgICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzID1cclxuICAgICAgICBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtZXRhTWV0cmljc1NlbmRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc1NlbmRDb3VudCA9IG1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1MDtcclxuXHJcbmNvbnN0IExFR0FDWV9MT0NBTF9TVE9SQUdFX0tFWVMgPSBbXHJcbiAgJ01FVEFTV0FQX0dBU19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdNRVRBU1dBUF9HQVNfUFJJQ0VfRVNUSU1BVEVTJyxcclxuICAnY2FjaGVkRmV0Y2gnLFxyXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVMnLFxyXG4gICdCQVNJQ19HQVNfQU5EX1RJTUVfQVBJX0VTVElNQVRFUycsXHJcbiAgJ0JBU0lDX0dBU19BTkRfVElNRV9BUElfRVNUSU1BVEVTX0xBU1RfUkVUUklFVkVEJyxcclxuICAnR0FTX0FQSV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdHQVNfQVBJX0VTVElNQVRFUycsXHJcbl07XHJcblxyXG4vKipcclxuICogTWlncmF0ZSBtZXRhTWV0cmljcyBzdGF0ZSB0byB0aGUgbmV3IE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcblxyXG4gICAgTEVHQUNZX0xPQ0FMX1NUT1JBR0VfS0VZUy5mb3JFYWNoKChrZXkpID0+XHJcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2U/LnJlbW92ZUl0ZW0oa2V5KSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgQlVJTFRfSU5fTkVUV09SS1MgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDUxO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY2hhaW5JZCBpbiB0aGUgTmV0d29yayBDb250cm9sbGVyIHByb3ZpZGVyIGRhdGEgZm9yIGFsbCBpbmZ1cmEgbmV0d29ya3NcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHsgY2hhaW5JZCwgdHlwZSB9ID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlciB8fCB7fTtcclxuICBjb25zdCBlbnVtQ2hhaW5JZCA9IEJVSUxUX0lOX05FVFdPUktTW3R5cGVdPy5jaGFpbklkO1xyXG5cclxuICBpZiAoZW51bUNoYWluSWQgJiYgY2hhaW5JZCAhPT0gZW51bUNoYWluSWQpIHtcclxuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQgPSBlbnVtQ2hhaW5JZDtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IENIQUlOX0lEUywgTkVUV09SS19UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTI7XHJcblxyXG4vKipcclxuICogTWlncmF0ZSB0b2tlbnMgaW4gUHJlZmVyZW5jZXMgdG8gYmUga2V5ZWQgYnkgY2hhaW5JZCBpbnN0ZWFkIG9mXHJcbiAqIHByb3ZpZGVyVHlwZS4gVG8gcHJldmVudCBicmVha2luZyB1c2VyJ3MgTWV0YU1hc2sgYW5kIHNlbGVjdGVkXHJcbiAqIHRva2VucywgdGhpcyBtaWdyYXRpb24gY29waWVzIHRoZSBSUEMgZW50cnkgaW50byAqZXZlcnkqIGN1c3RvbSBSUENcclxuICogY2hhaW5JZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XHJcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgeyBhY2NvdW50VG9rZW5zLCBhY2NvdW50SGlkZGVuVG9rZW5zLCBmcmVxdWVudFJwY0xpc3REZXRhaWwgfSA9XHJcbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcclxuXHJcbiAgICBjb25zdCBuZXdBY2NvdW50VG9rZW5zID0ge307XHJcbiAgICBjb25zdCBuZXdBY2NvdW50SGlkZGVuVG9rZW5zID0ge307XHJcblxyXG4gICAgaWYgKGFjY291bnRUb2tlbnMgJiYgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykubGVuZ3RoID4gMCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykpIHtcclxuICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdID0ge307XHJcbiAgICAgICAgaWYgKGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5SUENdKSB7XHJcbiAgICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgoZGV0YWlsKSA9PiB7XHJcbiAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bZGV0YWlsLmNoYWluSWRdID1cclxuICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuUlBDXTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyVHlwZSBvZiBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zW2FkZHJlc3NdKSkge1xyXG4gICAgICAgICAgc3dpdGNoIChwcm92aWRlclR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBORVRXT1JLX1RZUEVTLk1BSU5ORVQ6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtDSEFJTl9JRFMuTUFJTk5FVF0gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLk1BSU5ORVRdO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyb3BzdGVuJzpcclxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdWycweDMnXSA9IGFjY291bnRUb2tlbnNbYWRkcmVzc10ucm9wc3RlbjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVsnMHg0J10gPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdLnJpbmtlYnk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTkVUV09SS19UWVBFUy5HT0VSTEk6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtDSEFJTl9JRFMuR09FUkxJXSA9XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuR09FUkxJXTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAna292YW4nOlxyXG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bJzB4MmEnXSA9IGFjY291bnRUb2tlbnNbYWRkcmVzc10ua292YW47XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0gbmV3QWNjb3VudFRva2VucztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWNjb3VudEhpZGRlblRva2VucyAmJiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKSkge1xyXG4gICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10gPSB7fTtcclxuICAgICAgICBpZiAoYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLlJQQ10pIHtcclxuICAgICAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbC5mb3JFYWNoKChkZXRhaWwpID0+IHtcclxuICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtkZXRhaWwuY2hhaW5JZF0gPVxyXG4gICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5SUENdO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcHJvdmlkZXJUeXBlIG9mIE9iamVjdC5rZXlzKGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10pKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIE5FVFdPUktfVFlQRVMuTUFJTk5FVDpcclxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW0NIQUlOX0lEUy5NQUlOTkVUXSA9XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuTUFJTk5FVF07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JvcHN0ZW4nOlxyXG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bJzB4MyddID1cclxuICAgICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10ucm9wc3RlbjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVsnMHg0J10gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXS5yaW5rZWJ5O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE5FVFdPUktfVFlQRVMuR09FUkxJOlxyXG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bQ0hBSU5fSURTLkdPRVJMSV0gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLkdPRVJMSV07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2tvdmFuJzpcclxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdWycweDJhJ10gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXS5rb3ZhbjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRIaWRkZW5Ub2tlbnMgPSBuZXdBY2NvdW50SGlkZGVuVG9rZW5zO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTM7XHJcblxyXG4vKipcclxuICogRGVwcmVjYXRlIHRyYW5zYWN0aW9uQ2F0ZWdvcnkgYW5kIGNvbnNvbGlkYXRlIG9uICd0eXBlJ1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xyXG4gIGNvbnN0IGluY29taW5nVHJhbnNhY3Rpb25zID1cclxuICAgIHN0YXRlPy5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXI/LmluY29taW5nVHJhbnNhY3Rpb25zO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykpIHtcclxuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbikgPT4ge1xyXG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi50eXBlICE9PSBUcmFuc2FjdGlvblR5cGUucmV0cnkgJiZcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5jYW5jZWxcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChpbmNvbWluZ1RyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgaW5jb21pbmdUcmFuc2FjdGlvbnNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoaW5jb21pbmdUcmFuc2FjdGlvbnMpO1xyXG4gICAgaW5jb21pbmdUcmFuc2FjdGlvbnNFbnRyaWVzLmZvckVhY2goKFtrZXksIHRyYW5zYWN0aW9uXSkgPT4ge1xyXG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcclxuICAgICAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuaW5jb21pbmdUcmFuc2FjdGlvbnNba2V5XSA9IHtcclxuICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxyXG4gICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLmluY29taW5nLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1NDtcclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscykge1xyXG4gIHJldHVybiAoXHJcbiAgICB0eXBlb2YgZGVjaW1hbHMgPT09ICdudW1iZXInIHx8XHJcbiAgICAodHlwZW9mIGRlY2ltYWxzID09PSAnc3RyaW5nJyAmJiBkZWNpbWFscy5tYXRjaCgvXigweCk/XFxkKyQvdSkpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGVzIHByZWZlcmVuY2UgdG9rZW5zIHdpdGggZGVjaW1hbHMgdHlwZWQgYXMgc3RyaW5nIHRvIG51bWJlci5cclxuICogSXQgYWxzbyByZW1vdmVzIGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgb3IgaW5jb252ZXJ0aWJsZSBkZWNpbWFsIHZhbHVlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG5cclxuICBpZiAoIW5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdG9rZW5zID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyB8fCBbXTtcclxuICAvLyBGaWx0ZXIgb3V0IGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgZGVjaW1hbCB2YWx1ZXNcclxuICBjb25zdCB2YWxpZFRva2VucyA9IHRva2Vucy5maWx0ZXIoKHsgZGVjaW1hbHMgfSkgPT5cclxuICAgIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscyksXHJcbiAgKTtcclxuICBmb3IgKGNvbnN0IHRva2VuIG9mIHZhbGlkVG9rZW5zKSB7XHJcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIGRlY2ltYWwgdmFsdWUgdHlwZSBzdHJpbmcsIGNvbnZlcnQgdG8gYSBudW1iZXIuXHJcbiAgICBpZiAodHlwZW9mIHRva2VuLmRlY2ltYWxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmFkaXhcclxuICAgICAgdG9rZW4uZGVjaW1hbHMgPSBwYXJzZUludCh0b2tlbi5kZWNpbWFscyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgPSB2YWxpZFRva2VucztcclxuXHJcbiAgY29uc3QgeyBhY2NvdW50VG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XHJcbiAgaWYgKGFjY291bnRUb2tlbnMgJiYgdHlwZW9mIGFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykpIHtcclxuICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XHJcbiAgICAgIGlmIChuZXR3b3JrVG9rZW5zICYmIHR5cGVvZiBuZXR3b3JrVG9rZW5zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmV0d29yayBvZiBPYmplY3Qua2V5cyhuZXR3b3JrVG9rZW5zKSkge1xyXG4gICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXSB8fCBbXTtcclxuICAgICAgICAgIC8vIEZpbHRlciBvdXQgYW55IHRva2VucyB3aXRoIGNvcnJ1cHRlZCBkZWNpbWFsIHZhbHVlc1xyXG4gICAgICAgICAgY29uc3QgdmFsaWRUb2tlbnNPbk5ldHdvcmsgPSB0b2tlbnNPbk5ldHdvcmsuZmlsdGVyKCh7IGRlY2ltYWxzIH0pID0+XHJcbiAgICAgICAgICAgIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscyksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBkZWNpbWFsIHZhbHVlIHR5cGUgc3RyaW5nLCBjb252ZXJ0IHRvIGEgbnVtYmVyLlxyXG4gICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB2YWxpZFRva2Vuc09uTmV0d29yaykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuLmRlY2ltYWxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICAgICAgICAgIHRva2VuLmRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW4uZGVjaW1hbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBuZXR3b3JrVG9rZW5zW25ldHdvcmtdID0gdmFsaWRUb2tlbnNPbk5ldHdvcms7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0gYWNjb3VudFRva2VucztcclxuXHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCwgbWFwS2V5cyB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IEJVSUxUX0lOX05FVFdPUktTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1NTtcclxuXHJcbi8qKlxyXG4gKiByZXBsYWNlICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmsnIHdpdGggJ2luY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkJ1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmNvbnN0IFVOS05PV05fQ0hBSU5fSURfS0VZID0gJ1VOS05PV04nO1xyXG5cclxuQlVJTFRfSU5fTkVUV09SS1Mucmlua2VieSA9IHtcclxuICBuZXR3b3JrSWQ6ICc0JyxcclxuICBjaGFpbklkOiAnMHg0JyxcclxuICB0aWNrZXI6ICdFVEgnLFxyXG59O1xyXG5CVUlMVF9JTl9ORVRXT1JLUy5yb3BzdGVuID0ge1xyXG4gIG5ldHdvcmtJZDogJzMnLFxyXG4gIGNoYWluSWQ6ICcweDMnLFxyXG4gIHRpY2tlcjogJ0VUSCcsXHJcbn07XHJcbkJVSUxUX0lOX05FVFdPUktTLmtvdmFuID0ge1xyXG4gIG5ldHdvcmtJZDogJzQyJyxcclxuICBjaGFpbklkOiAnMHgyYScsXHJcbiAgdGlja2VyOiAnRVRIJyxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKFxyXG4gICAgc3RhdGU/LkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcj8uaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrXHJcbiAgKSB7XHJcbiAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWQgPVxyXG4gICAgICBtYXBLZXlzKFxyXG4gICAgICAgIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxyXG4gICAgICAgICAgLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yayxcclxuICAgICAgICAvLyB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBpbiBjYXNlIHVzZXIncyBzdGF0ZSBoYXMgZmV0Y2hlZCBibG9ja3MgZm9yXHJcbiAgICAgICAgLy8gUlBDIG5ldHdvcmsgdHlwZXMgKHdoaWNoIGRvbid0IG1hcCB0byBhIHNpbmdsZSBjaGFpbklkKS4gVGhpcyBzaG91bGRcclxuICAgICAgICAvLyBub3QgYmUgcG9zc2libGUsIGJ1dCBpdCdzIHNhZmVyXHJcbiAgICAgICAgKF8sIGtleSkgPT4gQlVJTFRfSU5fTkVUV09SS1Nba2V5XT8uY2hhaW5JZCA/PyBVTktOT1dOX0NIQUlOX0lEX0tFWSxcclxuICAgICAgKTtcclxuICAgIC8vIE5vdyB0aGF0IG1haW5uZXQgYW5kIHRlc3QgbmV0IGxhc3QgZmV0Y2hlZCBibG9ja3MgYXJlIGtleWVkIGJ5IHRoZWlyXHJcbiAgICAvLyByZXNwZWN0aXZlIGNoYWluSWRzLCB3ZSBjYW4gc2FmZWx5IGRlbGV0ZSBhbnl0aGluZyB3ZSBoYWQgZm9yIGN1c3RvbVxyXG4gICAgLy8gbmV0d29ya3MuIEFueSBjdXN0b20gbmV0d29yayB0aGF0IHNoYXJlcyBhIGNoYWluSWQgd2l0aCBvbmUgb2YgdGhlXHJcbiAgICAvLyBhZm9yZW1lbnRpb25lZCBuZXR3b3JrcyB3aWxsIHVzZSB0aGUgdmFsdWUgc3RvcmVkIGJ5IGNoYWluSWQuXHJcbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXHJcbiAgICAgIC5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZFtVTktOT1dOX0NIQUlOX0lEX0tFWV07XHJcbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXHJcbiAgICAgIC5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcms7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU2O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0b2tlbnMgdGhhdCBkb24ndCBoYXZlIGFuIGFkZHJlc3MgZHVlIHRvXHJcbiAqIGxhY2sgb2YgcHJldmlvdXMgYWRkVG9rZW4gdmFsaWRhdGlvbi4gIEFsc28gcmVtb3Zlc1xyXG4gKiBhbiB1bndhbnRlZCwgdW5kZWZpbmVkIGltYWdlIHByb3BlcnR5XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG5cclxuICAgIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnMpKSB7XHJcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zLmZpbHRlcihcclxuICAgICAgICAoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnMgJiZcclxuICAgICAgdHlwZW9mIFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID09PSAnb2JqZWN0J1xyXG4gICAgKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zKS5mb3JFYWNoKChhY2NvdW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhaW5zID0gT2JqZWN0LmtleXMoXHJcbiAgICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNoYWlucy5mb3JFYWNoKChjaGFpbikgPT4ge1xyXG4gICAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbYWNjb3VudF1bY2hhaW5dID1cclxuICAgICAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbYWNjb3VudF1bY2hhaW5dLmZpbHRlcihcclxuICAgICAgICAgICAgICAoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcclxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcyAmJlxyXG4gICAgICAndW5kZWZpbmVkJyBpbiBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYXNzZXRJbWFnZXNcclxuICAgICkge1xyXG4gICAgICBkZWxldGUgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzLnVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGtleUJ5IH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTc7XHJcblxyXG4vKipcclxuICogcmVwbGFjZSAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrJyB3aXRoICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCdcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChcclxuICAgIHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucyAmJlxyXG4gICAgQXJyYXkuaXNBcnJheShzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSAmJlxyXG4gICAgIXN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMuc29tZShcclxuICAgICAgKGl0ZW0pID0+XHJcbiAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8IHR5cGVvZiBpdGVtLnR4UGFyYW1zID09PSAndW5kZWZpbmVkJyxcclxuICAgIClcclxuICApIHtcclxuICAgIHN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSBrZXlCeShcclxuICAgICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyxcclxuICAgICAgLy8gSW4gY2FzZSBmb3Igc29tZSByZWFzb24gYW55IG9mIGEgdXNlcidzIHRyYW5zYWN0aW9ucyBkbyBub3QgaGF2ZSBhbiBpZFxyXG4gICAgICAvLyBnZW5lcmF0ZSBhIG5ldyBvbmUgZm9yIHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICAgKHR4KSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0eC5pZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHguaWQgPT09IG51bGwpIHtcclxuICAgICAgICAgIC8vIFRoaXMgbXV0YXRlcyB0aGUgaXRlbSBpbiB0aGUgYXJyYXksIHNvIHdpbGwgcmVzdWx0IGluIGEgY2hhbmdlIHRvXHJcbiAgICAgICAgICAvLyB0aGUgc3RhdGUuXHJcbiAgICAgICAgICB0eC5pZCA9IGNyZWF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eC5pZDtcclxuICAgICAgfSxcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU4O1xyXG5cclxuLyoqXHJcbiAqIERlbGV0ZXMgdGhlIHN3YXBzV2VsY29tZU1lc3NhZ2VIYXNCZWVuU2hvd24gcHJvcGVydHkgZnJvbSBzdGF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgZGVsZXRlIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcj8uc3dhcHNXZWxjb21lTWVzc2FnZUhhc0JlZW5TaG93bjtcclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgY2xvbmVEZWVwLFxyXG4gIGNvbmNhdCxcclxuICBncm91cEJ5LFxyXG4gIGtleUJ5LFxyXG4gIHBpY2tCeSxcclxuICBpc1BsYWluT2JqZWN0LFxyXG59IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU5O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgb3JwaGFuZWQgY2FuY2VsIGFuZCByZXRyeSB0cmFuc2FjdGlvbnMgdGhhdCBubyBsb25nZXIgaGF2ZSB0aGVcclxuICogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaW4gc3RhdGUsIHdoaWNoIHJlc3VsdHMgaW4gYnVncy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucztcclxuICBpZiAoaXNQbGFpbk9iamVjdCh0cmFuc2FjdGlvbnMpKSB7XHJcbiAgICBjb25zdCBub25jZU5ldHdvcmtHcm91cGVkT2JqZWN0ID0gZ3JvdXBCeShcclxuICAgICAgT2JqZWN0LnZhbHVlcyh0cmFuc2FjdGlvbnMpLFxyXG4gICAgICAodHgpID0+IHtcclxuICAgICAgICByZXR1cm4gYCR7dHgudHhQYXJhbXM/Lm5vbmNlfS0ke3R4LmNoYWluSWQgPz8gdHgubWV0YW1hc2tOZXR3b3JrSWR9YDtcclxuICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgd2l0aG91dE9ycGhhbnMgPSBwaWNrQnkobm9uY2VOZXR3b3JrR3JvdXBlZE9iamVjdCwgKGdyb3VwKSA9PiB7XHJcbiAgICAgIHJldHVybiBncm91cC5zb21lKFxyXG4gICAgICAgICh0eCkgPT5cclxuICAgICAgICAgIHR4LnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5jYW5jZWwgJiZcclxuICAgICAgICAgIHR4LnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5yZXRyeSxcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IGtleUJ5KFxyXG4gICAgICBjb25jYXQoLi4uT2JqZWN0LnZhbHVlcyh3aXRob3V0T3JwaGFucykpLFxyXG4gICAgICAodHgpID0+IHR4LmlkLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDYwO1xyXG5jb25zdCBTVVBQT1JUX05PVElGSUNBVElPTl9LRVkgPSAyO1xyXG5jb25zdCBTVVBQT1JUX05PVElGSUNBVElPTl9EQVRFID0gJzIwMjAtMDgtMzEnO1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIHN1cHBvcnQgc3VydmV5IG5vdGlmaWNhdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBzdGF0ZT8uTm90aWZpY2F0aW9uQ29udHJvbGxlcj8ubm90aWZpY2F0aW9ucztcclxuICBpZiAoaXNQbGFpbk9iamVjdChub3RpZmljYXRpb25zKSkge1xyXG4gICAgaWYgKFxyXG4gICAgICBub3RpZmljYXRpb25zW1NVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWV0/LmRhdGUgPT09XHJcbiAgICAgIFNVUFBPUlRfTk9USUZJQ0FUSU9OX0RBVEVcclxuICAgICkge1xyXG4gICAgICBkZWxldGUgc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlci5ub3RpZmljYXRpb25zW1xyXG4gICAgICAgIFNVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2MTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGF0dHJpYnV0ZXMgcmVsYXRlZCB0byByZWNvdmVyeSBzZWVkIHBocmFzZSByZW1pbmRlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgaWYgKHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcikge1xyXG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLnJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd24gPSBmYWxzZTtcclxuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlci5yZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duID0gY3VycmVudFRpbWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlciA9IHtcclxuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93bjogZmFsc2UsXHJcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJMYXN0U2hvd246IGN1cnJlbnRUaW1lLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjI7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IG1ldGFNZXRyaWNzU2VuZENvdW50IH0gPSBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXI7XHJcbiAgICBpZiAobWV0YU1ldHJpY3NTZW5kQ291bnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBkZWxldGUgc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2MztcclxuXHJcbi8qKlxyXG4gKiBNb3ZlcyB0b2tlbiBzdGF0ZSBmcm9tIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgdG8gVG9rZW5zQ29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IGFjY291bnRUb2tlbnMgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zO1xyXG4gIGNvbnN0IGFjY291bnRIaWRkZW5Ub2tlbnMgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50SGlkZGVuVG9rZW5zO1xyXG5cclxuICBjb25zdCBuZXdBbGxUb2tlbnMgPSB7fTtcclxuICBpZiAoYWNjb3VudFRva2Vucykge1xyXG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudEFkZHJlc3MpID0+IHtcclxuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2Vuc1thY2NvdW50QWRkcmVzc10pLmZvckVhY2goKGNoYWluSWQpID0+IHtcclxuICAgICAgICBjb25zdCB0b2tlbnNBcnJheSA9IGFjY291bnRUb2tlbnNbYWNjb3VudEFkZHJlc3NdW2NoYWluSWRdO1xyXG4gICAgICAgIGlmIChuZXdBbGxUb2tlbnNbY2hhaW5JZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbmV3QWxsVG9rZW5zW2NoYWluSWRdID0geyBbYWNjb3VudEFkZHJlc3NdOiB0b2tlbnNBcnJheSB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdBbGxUb2tlbnNbY2hhaW5JZF0gPSB7XHJcbiAgICAgICAgICAgIC4uLm5ld0FsbFRva2Vuc1tjaGFpbklkXSxcclxuICAgICAgICAgICAgW2FjY291bnRBZGRyZXNzXTogdG9rZW5zQXJyYXksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5ld0FsbElnbm9yZWRUb2tlbnMgPSB7fTtcclxuICBpZiAoYWNjb3VudEhpZGRlblRva2Vucykge1xyXG4gICAgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2VucykuZm9yRWFjaCgoYWNjb3VudEFkZHJlc3MpID0+IHtcclxuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2Vuc1thY2NvdW50QWRkcmVzc10pLmZvckVhY2goKGNoYWluSWQpID0+IHtcclxuICAgICAgICBjb25zdCBpZ25vcmVkVG9rZW5zQXJyYXkgPSBhY2NvdW50SGlkZGVuVG9rZW5zW2FjY291bnRBZGRyZXNzXVtjaGFpbklkXTtcclxuICAgICAgICBpZiAobmV3QWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID0ge1xyXG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiBpZ25vcmVkVG9rZW5zQXJyYXksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID0ge1xyXG4gICAgICAgICAgICAuLi5uZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdLFxyXG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiBpZ25vcmVkVG9rZW5zQXJyYXksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmIChzdGF0ZS5Ub2tlbnNDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5Ub2tlbnNDb250cm9sbGVyLmFsbFRva2VucyA9IG5ld0FsbFRva2VucztcclxuICAgIHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIuYWxsSWdub3JlZFRva2VucyA9IG5ld0FsbElnbm9yZWRUb2tlbnM7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIgPSB7XHJcbiAgICAgIGFsbFRva2VuczogbmV3QWxsVG9rZW5zLFxyXG4gICAgICBhbGxJZ25vcmVkVG9rZW5zOiBuZXdBbGxJZ25vcmVkVG9rZW5zLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50SGlkZGVuVG9rZW5zO1xyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zO1xyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcztcclxuICBkZWxldGUgc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uaGlkZGVuVG9rZW5zO1xyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnM7XHJcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnN1Z2dlc3RlZFRva2VucztcclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCwgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDY0O1xyXG5cclxuY29uc3QgU0VOVF9FVEhFUiA9ICdzZW50RXRoZXInOyAvLyB0aGUgbGVnYWN5IHRyYW5zYWN0aW9uIHR5cGUgYmVpbmcgcmVwbGFjZWQgaW4gdGhpcyBtaWdyYXRpb24gd2l0aCBUcmFuc2FjdGlvblR5cGUuc2ltcGxlU2VuZFxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgbWV0YU1ldHJpY3NTZW5kQ291bnQgZnJvbSBNZXRhTWV0cmljcyBjb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xyXG4gIGlmIChpc1BsYWluT2JqZWN0KHRyYW5zYWN0aW9ucykpIHtcclxuICAgIGZvciAoY29uc3QgdHggb2YgT2JqZWN0LnZhbHVlcyh0cmFuc2FjdGlvbnMpKSB7XHJcbiAgICAgIGlmICh0eC50eXBlID09PSBTRU5UX0VUSEVSKSB7XHJcbiAgICAgICAgdHgudHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eC5oaXN0b3J5KSB7XHJcbiAgICAgICAgdHguaGlzdG9yeS5tYXAoKHR4RXZlbnQpID0+IHtcclxuICAgICAgICAgIGlmICh0eEV2ZW50LnR5cGUgJiYgdHhFdmVudC50eXBlID09PSBTRU5UX0VUSEVSKSB7XHJcbiAgICAgICAgICAgIHR4RXZlbnQudHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHR4RXZlbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjU7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGNvbXBsZXRlZE9uYm9hcmRpbmcsIGZpcnN0VGltZUZsb3dUeXBlIH0gPVxyXG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XHJcbiAgICBzdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlciA9IHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyID8/IHt9O1xyXG5cclxuICAgIGlmIChjb21wbGV0ZWRPbmJvYXJkaW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgc3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZyA9IGNvbXBsZXRlZE9uYm9hcmRpbmc7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZztcclxuICAgIH1cclxuICAgIGlmIChmaXJzdFRpbWVGbG93VHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlID0gZmlyc3RUaW1lRmxvd1R5cGU7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmlyc3RUaW1lRmxvd1R5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgTGVkZ2VyVHJhbnNwb3J0VHlwZXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDY2O1xyXG5cclxuLyoqXHJcbiAqIENoYW5nZXMgdGhlIHVzZUxlZGdlckxpdmUgYm9vbGVhbiBwcm9wZXJ0eSB0byB0aGUgbGVkZ2VyVHJhbnNwb3J0VHlwZSBlbnVtXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgZGVmYXVsdFRyYW5zcG9ydFR5cGUgPSB3aW5kb3cubmF2aWdhdG9yLmhpZFxyXG4gICAgPyBMZWRnZXJUcmFuc3BvcnRUeXBlcy53ZWJoaWRcclxuICAgIDogTGVkZ2VyVHJhbnNwb3J0VHlwZXMudTJmO1xyXG4gIGNvbnN0IHVzZUxlZGdlckxpdmUgPSBCb29sZWFuKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8udXNlTGVkZ2VyTGl2ZSk7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5zdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICBsZWRnZXJUcmFuc3BvcnRUeXBlOiB1c2VMZWRnZXJMaXZlXHJcbiAgICAgICAgPyBMZWRnZXJUcmFuc3BvcnRUeXBlcy5saXZlXHJcbiAgICAgICAgOiBkZWZhdWx0VHJhbnNwb3J0VHlwZSxcclxuICAgIH0sXHJcbiAgfTtcclxuICBkZWxldGUgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnVzZUxlZGdlckxpdmU7XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuaW1wb3J0IHsgVEVTVF9DSEFJTlMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuY29uc3QgaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8gPSAoaGV4TnVtYmVyKSA9PlxyXG4gIG5ldyBCaWdOdW1iZXIoaGV4TnVtYmVyIHx8ICcweDAnLCAxNikuZ3QoMCk7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjc7XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgc2hvd1Rlc3ROZXR3b3JrcyBwcm9wZXJ0eSB0byB0cnVlIGlmIGl0IHdhcyBmYWxzZSBvciB1bmRlZmluZWQsIGFuZCB0aGVyZSBpcyBldmlkZW5jZVxyXG4gKiB0aGF0IHRoZSB1c2VyIGhhcyB1c2VkIGEgdGVzdCBuZXRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xyXG4gIGNvbnN0IHByZWZlcmVuY2VzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzIHx8IHt9O1xyXG5cclxuICBpZiAocHJlZmVyZW5jZXMuc2hvd1Rlc3ROZXR3b3Jrcykge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zIHx8IHt9O1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xyXG4gIGNvbnN0IGNhY2hlZEJhbGFuY2VzID0gc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcyB8fCB7fTtcclxuXHJcbiAgY29uc3QgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCA9IFRFU1RfQ0hBSU5TLmluY2x1ZGVzKHByb3ZpZGVyPy5jaGFpbklkKTtcclxuICBjb25zdCB1c2VySGFzTWFkZUFUZXN0TmV0VHJhbnNhY3Rpb24gPSBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucykuc29tZShcclxuICAgICh7IGNoYWluSWQgfSkgPT4gVEVTVF9DSEFJTlMuaW5jbHVkZXMoY2hhaW5JZCksXHJcbiAgKTtcclxuICBjb25zdCB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0ID0gVEVTVF9DSEFJTlMuc29tZSgoY2hhaW5JZCkgPT4ge1xyXG4gICAgY29uc3QgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbiA9IE9iamVjdC52YWx1ZXMoY2FjaGVkQmFsYW5jZXNbY2hhaW5JZF0gfHwge30pO1xyXG4gICAgY29uc3QgdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW4gPVxyXG4gICAgICBjYWNoZWRCYWxhbmNlc0ZvckNoYWluLnNvbWUoaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8pO1xyXG4gICAgcmV0dXJuIHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluO1xyXG4gIH0pO1xyXG4gIGNvbnN0IHVzZXJIYXNVc2VkQVRlc3RuZXQgPVxyXG4gICAgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCB8fFxyXG4gICAgdXNlckhhc01hZGVBVGVzdE5ldFRyYW5zYWN0aW9uIHx8XHJcbiAgICB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0O1xyXG5cclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgcHJlZmVyZW5jZXM6IHtcclxuICAgICAgICAuLi5wcmVmZXJlbmNlcyxcclxuICAgICAgICBzaG93VGVzdE5ldHdvcmtzOiB1c2VySGFzVXNlZEFUZXN0bmV0LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2ODtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSBQZXJtaXNzaW9uc0NvbnRyb2xsZXIgYW5kIFBlcm1pc3Npb25zTWV0YWRhdGEgc3Vic3RhdGVzXHJcbiAqIHRvIG1hdGNoIHRoZSBuZXcgcGVybWlzc2lvbiBzeXN0ZW0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgUGVybWlzc2lvbnNDb250cm9sbGVyID0ge30sXHJcbiAgICBQZXJtaXNzaW9uc01ldGFkYXRhID0ge30sXHJcbiAgICAuLi5yZW1haW5pbmdTdGF0ZVxyXG4gIH0gPSBzdGF0ZTtcclxuXHJcbiAgY29uc3Qge1xyXG4gICAgZG9tYWluTWV0YWRhdGEgPSB7fSxcclxuICAgIHBlcm1pc3Npb25zSGlzdG9yeSA9IHt9LFxyXG4gICAgcGVybWlzc2lvbnNMb2cgPSBbXSxcclxuICB9ID0gUGVybWlzc2lvbnNNZXRhZGF0YTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnJlbWFpbmluZ1N0YXRlLFxyXG4gICAgUGVybWlzc2lvbkNvbnRyb2xsZXI6IGdldFBlcm1pc3Npb25Db250cm9sbGVyU3RhdGUoUGVybWlzc2lvbnNDb250cm9sbGVyKSxcclxuICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7XHJcbiAgICAgIHBlcm1pc3Npb25BY3Rpdml0eUxvZzogcGVybWlzc2lvbnNMb2csXHJcbiAgICAgIHBlcm1pc3Npb25IaXN0b3J5OiBwZXJtaXNzaW9uc0hpc3RvcnksXHJcbiAgICB9LFxyXG4gICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjpcclxuICAgICAgZ2V0U3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclN0YXRlKGRvbWFpbk1ldGFkYXRhKSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uQ29udHJvbGxlclN0YXRlKFBlcm1pc3Npb25zQ29udHJvbGxlcikge1xyXG4gIGNvbnN0IHsgZG9tYWlucyA9IHt9IH0gPSBQZXJtaXNzaW9uc0NvbnRyb2xsZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4YW1wbGUgZXhpc3RpbmcgZG9tYWluIGVudHJ5LiBFdmVyeSBleGlzdGluZyBkb21haW4gd2lsbCBoYXZlIGEgc2luZ2xlXHJcbiAgICogZXRoX2FjY291bnRzIHBlcm1pc3Npb24sIHdoaWNoIHNpbXBsaWZpZXMgdGhlIHRyYW5zZm9ybS5cclxuICAgKlxyXG4gICAqICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbyc6IHtcclxuICAgKiAgIHBlcm1pc3Npb25zOiBbXHJcbiAgICogICAgIHtcclxuICAgKiAgICAgICAnQGNvbnRleHQnOiBbJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ycGMtY2FwJ10sXHJcbiAgICogICAgICAgJ2NhdmVhdHMnOiBbXHJcbiAgICogICAgICAgICB7XHJcbiAgICogICAgICAgICAgIG5hbWU6ICdwcmltYXJ5QWNjb3VudE9ubHknLFxyXG4gICAqICAgICAgICAgICB0eXBlOiAnbGltaXRSZXNwb25zZUxlbmd0aCcsXHJcbiAgICogICAgICAgICAgIHZhbHVlOiAxLFxyXG4gICAqICAgICAgICAgfSxcclxuICAgKiAgICAgICAgIHtcclxuICAgKiAgICAgICAgICAgbmFtZTogJ2V4cG9zZWRBY2NvdW50cycsXHJcbiAgICogICAgICAgICAgIHR5cGU6ICdmaWx0ZXJSZXNwb25zZScsXHJcbiAgICogICAgICAgICAgIHZhbHVlOiBbJzB4MGM5N2E1YzgxZTUwYTAyZmY4YmU3M2NjM2YwYTA1NjllNjFmNGVkOCddLFxyXG4gICAqICAgICAgICAgfSxcclxuICAgKiAgICAgICBdLFxyXG4gICAqICAgICAgICdkYXRlJzogMTYxNjAwNjM2OTQ5OCxcclxuICAgKiAgICAgICAnaWQnOiAnM2QwYmRjMjctZThlNC00ZmIwLWEyNGItMzQwZDYxZjZhM2ZhJyxcclxuICAgKiAgICAgICAnaW52b2tlcic6ICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbycsXHJcbiAgICogICAgICAgJ3BhcmVudENhcGFiaWxpdHknOiAnZXRoX2FjY291bnRzJyxcclxuICAgKiAgICAgfSxcclxuICAgKiAgIF0sXHJcbiAgICogfSxcclxuICAgKi9cclxuXHJcbiAgY29uc3QgRVRIX0FDQ09VTlRTID0gJ2V0aF9hY2NvdW50cyc7XHJcbiAgY29uc3QgTkVXX0NBVkVBVF9UWVBFID0gJ3Jlc3RyaWN0UmV0dXJuZWRBY2NvdW50cyc7XHJcbiAgY29uc3QgT0xEX0NBVkVBVF9OQU1FID0gJ2V4cG9zZWRBY2NvdW50cyc7XHJcblxyXG4gIGNvbnN0IHN1YmplY3RzID0gT2JqZWN0LmVudHJpZXMoZG9tYWlucykucmVkdWNlKFxyXG4gICAgKHRyYW5zZm9ybWVkLCBbb3JpZ2luLCBkb21haW5FbnRyeV0pID0+IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHBlcm1pc3Npb25zOiBbZXRoQWNjb3VudHNQZXJtaXNzaW9uXSxcclxuICAgICAgfSA9IGRvbWFpbkVudHJ5O1xyXG5cclxuICAgICAgLy8gVGhlcmUgYXJlIHR3byBjYXZlYXRzIGZvciBlYWNoIGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLCBidXQgd2Ugb25seVxyXG4gICAgICAvLyBuZWVkIHRoZSB2YWx1ZSBvZiBvbmUgb2YgdGhlbSBpbiB0aGUgbmV3IHBlcm1pc3Npb24gc3lzdGVtLlxyXG4gICAgICBjb25zdCBvbGRDYXZlYXQgPSBldGhBY2NvdW50c1Blcm1pc3Npb24uY2F2ZWF0cy5maW5kKFxyXG4gICAgICAgIChjYXZlYXQpID0+IGNhdmVhdC5uYW1lID09PSBPTERfQ0FWRUFUX05BTUUsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBuZXdQZXJtaXNzaW9uID0ge1xyXG4gICAgICAgIC4uLmV0aEFjY291bnRzUGVybWlzc2lvbixcclxuICAgICAgICBjYXZlYXRzOiBbeyB0eXBlOiBORVdfQ0FWRUFUX1RZUEUsIHZhbHVlOiBvbGRDYXZlYXQudmFsdWUgfV0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBXZSBuZXZlciB1c2VkIHRoaXMsIGFuZCBqdXN0IG9taXQgaXQgaW4gdGhlIG5ldyBzeXN0ZW0uXHJcbiAgICAgIGRlbGV0ZSBuZXdQZXJtaXNzaW9uWydAY29udGV4dCddO1xyXG5cclxuICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcclxuICAgICAgICBvcmlnaW4sXHJcbiAgICAgICAgcGVybWlzc2lvbnM6IHtcclxuICAgICAgICAgIFtFVEhfQUNDT1VOVFNdOiBuZXdQZXJtaXNzaW9uLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH0sXHJcbiAgICB7fSxcclxuICApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3ViamVjdHMsXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclN0YXRlKGRvbWFpbk1ldGFkYXRhKSB7XHJcbiAgLyoqXHJcbiAgICogRXhhbXBsZSBleGlzdGluZyBkb21haW5NZXRhZGF0YSBlbnRyeS5cclxuICAgKlxyXG4gICAqIFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIjoge1xyXG4gICAqICAgXCJob3N0XCI6IFwid3d3LnlvdXR1YmUuY29tXCIsXHJcbiAgICogICBcImljb25cIjogbnVsbCxcclxuICAgKiAgIFwibGFzdFVwZGF0ZWRcIjogMTYzNzY5NzkxNDkwOCxcclxuICAgKiAgIFwibmFtZVwiOiBcIllvdVR1YmVcIlxyXG4gICAqIH1cclxuICAgKi9cclxuXHJcbiAgY29uc3Qgc3ViamVjdE1ldGFkYXRhID0gT2JqZWN0LmVudHJpZXMoZG9tYWluTWV0YWRhdGEpLnJlZHVjZShcclxuICAgICh0cmFuc2Zvcm1lZCwgW29yaWdpbiwgbWV0YWRhdGFdKSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBuYW1lID0gbnVsbCxcclxuICAgICAgICBpY29uID0gbnVsbCxcclxuICAgICAgICBleHRlbnNpb25JZCA9IG51bGwsXHJcbiAgICAgICAgLi4ub3RoZXJcclxuICAgICAgfSA9IG1ldGFkYXRhO1xyXG5cclxuICAgICAgLy8gV2UncmUgZ2V0dGluZyByaWQgb2YgdGhlc2UuXHJcbiAgICAgIGRlbGV0ZSBvdGhlci5sYXN0VXBkYXRlZDtcclxuICAgICAgZGVsZXRlIG90aGVyLmhvc3Q7XHJcblxyXG4gICAgICBpZiAob3JpZ2luKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBpY29uVXJsOiBpY29uLFxyXG4gICAgICAgICAgZXh0ZW5zaW9uSWQsXHJcbiAgICAgICAgICAuLi5vdGhlcixcclxuICAgICAgICAgIG9yaWdpbixcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH0sXHJcbiAgICB7fSxcclxuICApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3ViamVjdE1ldGFkYXRhLFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgU3ViamVjdFR5cGUgfSBmcm9tICdAbWV0YW1hc2svc3ViamVjdC1tZXRhZGF0YS1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2OTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBgc3ViamVjdFR5cGVgIHByb3BlcnR5IHRvIGFsbCBzdWJqZWN0IG1ldGFkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmICh0eXBlb2Ygc3RhdGU/LlN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI/LnN1YmplY3RNZXRhZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogeyBzdWJqZWN0TWV0YWRhdGEgfSxcclxuICAgIH0gPSBzdGF0ZTtcclxuXHJcbiAgICAvLyBtdXRhdGUgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5zdWJqZWN0TWV0YWRhdGEgaW4gcGxhY2VcclxuICAgIE9iamVjdC52YWx1ZXMoc3ViamVjdE1ldGFkYXRhKS5mb3JFYWNoKChtZXRhZGF0YSkgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgbWV0YWRhdGEgJiZcclxuICAgICAgICB0eXBlb2YgbWV0YWRhdGEgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgIUFycmF5LmlzQXJyYXkobWV0YWRhdGEpXHJcbiAgICAgICkge1xyXG4gICAgICAgIG1ldGFkYXRhLnN1YmplY3RUeXBlID0gbWV0YWRhdGEuZXh0ZW5zaW9uSWRcclxuICAgICAgICAgID8gU3ViamVjdFR5cGUuRXh0ZW5zaW9uXHJcbiAgICAgICAgICA6IFN1YmplY3RUeXBlLldlYnNpdGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3MDtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBgcmVxdWVzdGAgYW5kIGByZXNwb25zZWAgcHJvcGVydGllcyBmcm9tXHJcbiAqIGBQZXJtaXNzaW9uTG9nQ29udHJvbGxlci5wZXJtaXNzaW9uQWN0aXZpdHlMb2dgIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGU/LlBlcm1pc3Npb25Mb2dDb250cm9sbGVyPy5wZXJtaXNzaW9uQWN0aXZpdHlMb2cpKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7IHBlcm1pc3Npb25BY3Rpdml0eUxvZyB9LFxyXG4gICAgfSA9IHN0YXRlO1xyXG5cclxuICAgIC8vIG11dGF0ZSBhY3Rpdml0eSBsb2cgZW50cmllcyBpbiBwbGFjZVxyXG4gICAgcGVybWlzc2lvbkFjdGl2aXR5TG9nLmZvckVhY2goKGxvZ0VudHJ5KSA9PiB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBsb2dFbnRyeSAmJlxyXG4gICAgICAgIHR5cGVvZiBsb2dFbnRyeSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAhQXJyYXkuaXNBcnJheShsb2dFbnRyeSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgZGVsZXRlIGxvZ0VudHJ5LnJlcXVlc3Q7XHJcbiAgICAgICAgZGVsZXRlIGxvZ0VudHJ5LnJlc3BvbnNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzE7XHJcblxyXG4vKipcclxuICogUmVuYW1lcyBOb3RpZmljYXRpb25Db250cm9sbGVyIHRvIEFubm91bmNlbWVudENvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlcikge1xyXG4gICAgc3RhdGUuQW5ub3VuY2VtZW50Q29udHJvbGxlciA9IHtcclxuICAgICAgYW5ub3VuY2VtZW50czogc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlci5ub3RpZmljYXRpb25zLFxyXG4gICAgfTtcclxuICAgIGRlbGV0ZSBzdGF0ZS5Ob3RpZmljYXRpb25Db250cm9sbGVyO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3MjtcclxuXHJcbi8qKlxyXG4gKiBTaG91bGQgZW1wdHkgdGhlIGBrbm93bk1ldGhvZERhdGFgIG9iamVjdCBpbiBQcmVmZXJlbmNlc0NvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICBrbm93bk1ldGhvZERhdGE6IHt9LFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzM7XHJcblxyXG4vKipcclxuICogU2hvdWxkIGVtcHR5IHRoZSBga25vd25NZXRob2REYXRhYCBvYmplY3QgaW4gUHJlZmVyZW5jZXNDb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgUHJlZmVyZW5jZXNDb250cm9sbGVyID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlciB8fCB7fTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAga25vd25NZXRob2REYXRhOiB7fSxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIHVuaXEgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCB7IGdldFJwY1VybCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzQ7XHJcblxyXG5jb25zdCBoZXhOdW1iZXJJc0dyZWF0ZXJUaGFuWmVybyA9IChoZXhOdW1iZXIpID0+XHJcbiAgbmV3IEJpZ051bWJlcihoZXhOdW1iZXIgfHwgJzB4MCcsIDE2KS5ndCgwKTtcclxuXHJcbmNvbnN0IERFUFJFQ0FURURfVEVTVF9ORVRfQ0hBSU5JRFMgPSBbJzB4MycsICcweDJhJywgJzB4NCddO1xyXG5jb25zdCBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFMgPSB7XHJcbiAgJzB4Myc6IHtcclxuICAgIHJwY1VybDogZ2V0UnBjVXJsKHsgbmV0d29yazogJ3JvcHN0ZW4nIH0pLFxyXG4gICAgbmlja25hbWU6ICdSb3BzdGVuJyxcclxuICAgIHRpY2tlcjogJ1JvcHN0ZW5FVEgnLFxyXG4gIH0sXHJcbiAgJzB4MmEnOiB7XHJcbiAgICBycGNVcmw6IGdldFJwY1VybCh7IG5ldHdvcms6ICdrb3ZhbicgfSksXHJcbiAgICBuaWNrbmFtZTogJ0tvdmFuJyxcclxuICAgIHRpY2tlcjogJ0tvdmFuRVRIJyxcclxuICB9LFxyXG4gICcweDQnOiB7XHJcbiAgICBycGNVcmw6IGdldFJwY1VybCh7IG5ldHdvcms6ICdyaW5rZWJ5JyB9KSxcclxuICAgIG5pY2tuYW1lOiAnUmlua2VieScsXHJcbiAgICB0aWNrZXI6ICdSaW5rZWJ5RVRIJyxcclxuICB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGVzIHRoZSB1c2VyIGRlZmF1bHQgYnV0IGRlcHJlY2F0ZWQgdGVzdG5ldCBuZXR3b3JrcyB0byBjdXN0b20gbmV0d29ya3MsIGFuZFxyXG4gKiBpZiB0aGUgY3VycmVudCBuZXR3b3JrIGlzIG9uZSBzdWNoIG5ldHdvcmssIHVwZGF0ZXMgdGhlIG5ldHdvcmsgcHJvdmlkZXIgZGV0YWlscyBzbyB0aGF0IGl0XHJcbiAqIHdpbGwgd29yayBhcyBhIGN1c3RvbSBycGNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xyXG4gIGNvbnN0IHByZWZlcmVuY2VzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzIHx8IHt9O1xyXG4gIGNvbnN0IE5ldHdvcmtDb250cm9sbGVyID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyIHx8IHt9O1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xyXG5cclxuICBjb25zdCBjdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrID0gREVQUkVDQVRFRF9URVNUX05FVF9DSEFJTklEUy5maWx0ZXIoXHJcbiAgICAoY2hhaW5JZCkgPT4gY2hhaW5JZCA9PT0gcHJvdmlkZXI/LmNoYWluSWQsXHJcbiAgKTtcclxuXHJcbiAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3Qgd2FudCB0byBzZWUgdGVzdCBuZXR3b3JrcywgYW5kIGlmIHRoZSB0aGUgdXNlciBpcyBub3Qgb24gYSBkZXByZWNhdGVkIHRlc3QgbmV0d29yaywgdGhlblxyXG4gIC8vIG5vIG5lZWQgdG8gbWlncmF0ZSB0aGUgdGVzdCBuZXR3b3JrIGRhdGEgdG8gYSBjdXN0b20gbmV0d29ya1xyXG4gIGlmIChcclxuICAgICFwcmVmZXJlbmNlcy5zaG93VGVzdE5ldHdvcmtzICYmXHJcbiAgICBjdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrLmxlbmd0aCA9PT0gMFxyXG4gICkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zIHx8IHt9O1xyXG4gIGNvbnN0IGNhY2hlZEJhbGFuY2VzID0gc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcyB8fCB7fTtcclxuXHJcbiAgY29uc3QgZGVwcmVjYXRlZFRlc3RuZXRzT25XaGljaFRoZVVzZXJIYXNNYWRlQVRyYW5zYWN0aW9uID0gT2JqZWN0LnZhbHVlcyhcclxuICAgIHRyYW5zYWN0aW9ucyxcclxuICApXHJcbiAgICAuZmlsdGVyKCh7IGNoYWluSWQgfSkgPT4gREVQUkVDQVRFRF9URVNUX05FVF9DSEFJTklEUy5pbmNsdWRlcyhjaGFpbklkKSlcclxuICAgIC5tYXAoKHsgY2hhaW5JZCB9KSA9PiBjaGFpbklkKTtcclxuICBjb25zdCBkZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc0NhY2hlZEJhbGFuY2UgPVxyXG4gICAgREVQUkVDQVRFRF9URVNUX05FVF9DSEFJTklEUy5maWx0ZXIoKGNoYWluSWQpID0+IHtcclxuICAgICAgY29uc3QgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbiA9IE9iamVjdC52YWx1ZXMoXHJcbiAgICAgICAgY2FjaGVkQmFsYW5jZXNbY2hhaW5JZF0gfHwge30sXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluID1cclxuICAgICAgICBjYWNoZWRCYWxhbmNlc0ZvckNoYWluLnNvbWUoaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8pO1xyXG4gICAgICByZXR1cm4gdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW47XHJcbiAgICB9KTtcclxuICBjb25zdCBkZXByZWNhdGVkVGVzdG5ldHNUaGF0SGF2ZUJlZW5Vc2VkID0gdW5pcShbXHJcbiAgICAuLi5kZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc0NhY2hlZEJhbGFuY2UsXHJcbiAgICAuLi5kZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc01hZGVBVHJhbnNhY3Rpb24sXHJcbiAgICAuLi5jdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrLFxyXG4gIF0pO1xyXG5cclxuICBjb25zdCBuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwgPVxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmZyZXF1ZW50UnBjTGlzdERldGFpbCA/PyBbXTtcclxuXHJcbiAgZGVwcmVjYXRlZFRlc3RuZXRzVGhhdEhhdmVCZWVuVXNlZC5mb3JFYWNoKChjaGFpbklkKSA9PiB7XHJcbiAgICBpZiAoXHJcbiAgICAgICFuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwuZmluZChcclxuICAgICAgICAocnBjRGV0YWlscykgPT4gcnBjRGV0YWlscy5jaGFpbklkID09PSBjaGFpbklkLFxyXG4gICAgICApXHJcbiAgICApIHtcclxuICAgICAgbmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsLnVuc2hpZnQoe1xyXG4gICAgICAgIHJwY1VybDogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW2NoYWluSWRdLnJwY1VybCxcclxuICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgIHRpY2tlcjogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW2NoYWluSWRdLnRpY2tlcixcclxuICAgICAgICBuaWNrbmFtZTogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW2NoYWluSWRdLm5pY2tuYW1lLFxyXG4gICAgICAgIHJwY1ByZWZzOiB7fSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwubGVuZ3RoKSB7XHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gbmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGN1cnJlbnRseU9uRGVwcmVjYXRlZE5ldHdvcmsubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZE5ldHdvcmtDaGFpbklkID0gY3VycmVudGx5T25EZXByZWNhdGVkTmV0d29ya1swXTtcclxuICAgIE5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0ge1xyXG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlcixcclxuICAgICAgdHlwZTogJ3JwYycsXHJcbiAgICAgIHJwY1VybDogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW3NlbGVjdGVkTmV0d29ya0NoYWluSWRdLnJwY1VybCxcclxuICAgICAgY2hhaW5JZDogc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZCxcclxuICAgICAgbmlja25hbWU6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tzZWxlY3RlZE5ldHdvcmtDaGFpbklkXS5uaWNrbmFtZSxcclxuICAgICAgdGlja2VyOiBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFNbc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZF0udGlja2VyLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICB9LFxyXG4gICAgTmV0d29ya0NvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uTmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3NTtcclxuXHJcbi8qKlxyXG4gKiBEZWxldGUgdGhlIFRocmVlQm94Q29udHJvbGxlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBkZWxldGUgc3RhdGUuVGhyZWVCb3hDb250cm9sbGVyO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDc2O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0byBgQG1ldGFtYXNrL2NvbnRyb2xsZXJzQDMzLjAuMGAgKHJlbmFtZSBcIkNvbGxlY3RpYmxlXCIgdG8gXCJORlRcIikuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKHN0YXRlLkNvbGxlY3RpYmxlc0NvbnRyb2xsZXIpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgYWxsQ29sbGVjdGlibGVDb250cmFjdHMsXHJcbiAgICAgIGFsbENvbGxlY3RpYmxlcyxcclxuICAgICAgaWdub3JlZENvbGxlY3RpYmxlcyxcclxuICAgICAgLi4ucmVtYWluaW5nU3RhdGVcclxuICAgIH0gPSBzdGF0ZS5Db2xsZWN0aWJsZXNDb250cm9sbGVyO1xyXG4gICAgc3RhdGUuTmZ0Q29udHJvbGxlciA9IHtcclxuICAgICAgLi4uKGFsbENvbGxlY3RpYmxlQ29udHJhY3RzXHJcbiAgICAgICAgPyB7IGFsbE5mdENvbnRyYWN0czogYWxsQ29sbGVjdGlibGVDb250cmFjdHMgfVxyXG4gICAgICAgIDoge30pLFxyXG4gICAgICAuLi4oYWxsQ29sbGVjdGlibGVzID8geyBhbGxOZnRzOiBhbGxDb2xsZWN0aWJsZXMgfSA6IHt9KSxcclxuICAgICAgLi4uKGlnbm9yZWRDb2xsZWN0aWJsZXMgPyB7IGlnbm9yZWROZnRzOiBpZ25vcmVkQ29sbGVjdGlibGVzIH0gOiB7fSksXHJcbiAgICAgIC4uLnJlbWFpbmluZ1N0YXRlLFxyXG4gICAgfTtcclxuICAgIGRlbGV0ZSBzdGF0ZS5Db2xsZWN0aWJsZXNDb250cm9sbGVyO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8udXNlQ29sbGVjdGlibGVEZXRlY3Rpb24pIHtcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci51c2VOZnREZXRlY3Rpb24gPVxyXG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudXNlQ29sbGVjdGlibGVEZXRlY3Rpb247XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzc7XHJcblxyXG4vKipcclxuICogUHJpb3IgdG8gdG9rZW4gZGV0ZWN0aW9uIHYyIHRoZSBkYXRhIHByb3BlcnR5IGluIHRva2Vuc0NoYWluc0NhY2hlIHdhcyBhbiBhcnJheSxcclxuICogaW4gdjIgd2UgY2hhbmdlcyB0aGF0IHRvIGFuIG9iamVjdC4gSW4gdGhpcyBtaWdyYXRpb24gd2UgYXJlIGNvbnZlcnRpbmcgdGhlIGRhdGEgYXMgYXJyYXkgdG8gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IFRva2VuTGlzdENvbnRyb2xsZXIgPSBzdGF0ZT8uVG9rZW5MaXN0Q29udHJvbGxlciB8fCB7fTtcclxuXHJcbiAgY29uc3QgeyB0b2tlbnNDaGFpbnNDYWNoZSB9ID0gVG9rZW5MaXN0Q29udHJvbGxlcjtcclxuXHJcbiAgbGV0IGRhdGFDYWNoZTtcclxuICBsZXQgZGF0YU9iamVjdDtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICBmb3IgKGNvbnN0IGNoYWluSWQgaW4gdG9rZW5zQ2hhaW5zQ2FjaGUpIHtcclxuICAgIGRhdGFDYWNoZSA9IHRva2Vuc0NoYWluc0NhY2hlW2NoYWluSWRdLmRhdGE7XHJcbiAgICBkYXRhT2JqZWN0ID0ge307XHJcbiAgICAvLyBpZiB0aGUgZGF0YSBpcyBhcnJheSBjb252ZXIgdGhhdCB0byBvYmplY3RcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFDYWNoZSkpIHtcclxuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBkYXRhQ2FjaGUpIHtcclxuICAgICAgICBkYXRhT2JqZWN0W3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIE9iamVjdC5rZXlzKGRhdGFDYWNoZSlbMF0udG9Mb3dlckNhc2UoKSAhPT1cclxuICAgICAgZGF0YUNhY2hlW09iamVjdC5rZXlzKGRhdGFDYWNoZSlbMF1dLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIGZvciB0aGUgdXNlcnMgd2hvIGFscmVhZHkgdXBkYXRlZCB0byB0aGUgcmVjZW50IHZlcnNpb25cclxuICAgICAgLy8gYW5kIHRoZSBkYXRhQ2FjaGUgaXMgYWxyZWFkeSBhbiBvYmplY3Qga2V5ZWQgd2l0aCAwLDEsMiwzIGV0Y1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgZm9yIChjb25zdCB0b2tlbkFkZHJlc3MgaW4gZGF0YUNhY2hlKSB7XHJcbiAgICAgICAgZGF0YU9iamVjdFtkYXRhQ2FjaGVbdG9rZW5BZGRyZXNzXS5hZGRyZXNzXSA9IGRhdGFDYWNoZVt0b2tlbkFkZHJlc3NdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0b2tlbnNDaGFpbnNDYWNoZVtjaGFpbklkXS5kYXRhID1cclxuICAgICAgT2JqZWN0LmtleXMoZGF0YU9iamVjdCkubGVuZ3RoID4gMCA/IGRhdGFPYmplY3QgOiBkYXRhQ2FjaGU7XHJcbiAgfVxyXG4gIFRva2VuTGlzdENvbnRyb2xsZXIudG9rZW5zQ2hhaW5zQ2FjaGUgPSB0b2tlbnNDaGFpbnNDYWNoZTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgVG9rZW5MaXN0Q29udHJvbGxlcjoge1xyXG4gICAgICAuLi5Ub2tlbkxpc3RDb250cm9sbGVyLFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDc4O1xyXG5cclxuLyoqXHJcbiAqIFRoZWBAbWV0YW1hc2svcGhpc2hpbmctY29udHJvbGxlcmAgc3RhdGUgd2FzIHVwZGF0ZWQgaW4gdjIuMC4wLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLCAnUGhpc2hpbmdDb250cm9sbGVyJykgfHxcclxuICAgICFpc09iamVjdChzdGF0ZS5QaGlzaGluZ0NvbnRyb2xsZXIpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGNvbnN0IHsgUGhpc2hpbmdDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgZGVsZXRlIFBoaXNoaW5nQ29udHJvbGxlci5waGlzaGluZztcclxuICBkZWxldGUgUGhpc2hpbmdDb250cm9sbGVyLmxhc3RGZXRjaGVkO1xyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3OTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgY29sbGVjdGlibGVzRHJvcGRvd25TdGF0ZSBhbmQgY29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkOi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoXHJcbiAgICBzdGF0ZT8uQXBwU3RhdGVDb250cm9sbGVyPy5jb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQgIT09XHJcbiAgICB1bmRlZmluZWRcclxuICApIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIuY29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkO1xyXG4gIH1cclxuICBpZiAoc3RhdGU/Lm1ldGFtYXNrPy5jb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5tZXRhbWFzay5jb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA4MDtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcG9ydGZvbGlvIHRvb2x0aXAgaGFzIGJlZW4gbW92ZWQgdG8gYSBidXR0b24gb24gdGhlIGhvbWUgc2NyZWVuIHNvXHJcbiAqIHRoaXMgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBzdGF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChzdGF0ZT8ubWV0YW1hc2s/LnNob3dQb3J0Zm9saW9Ub29sdGlwICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5tZXRhbWFzay5zaG93UG9ydGZvbGlvVG9vbHRpcDtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4MTtcclxuXHJcbi8qKlxyXG4gKiBQcmlvciB0byB0aGlzIG1pZ3JhdGlvbiwgc25hcCA8PiBkYXBwIHBlcm1pc3Npb25zIHdlcmUgd2lsZGNhcmRzIGkuZS4gYHdhbGxldF9zbmFwXypgLlxyXG4gKiBOb3cgdGhlIHBlcm1pc3Npb24gaGFzIGJlZW4gY2hhbmdlZCB0byBgd2FsbGV0X3NuYXBgIGFuZCB0aGUgY3VycmVudCBzbmFwIHBlcm1pc3Npb25zXHJcbiAqIHRoYXQgYXJlIHVuZGVyIHdpbGRjYXJkcyB3aWxsIGJlIGFkZGVkIGFzIGNhdmVhdHMgdG8gYSBwYXJlbnQgYHdhbGxldF9zbmFwYCBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbn1cclxuXHJcbi8vIFdlIHJldHVybiBzdGF0ZSBBUyBJUyBpZiB0aGVyZSBpcyBhbnkgY29ycnVwdGlvblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcclxuICBpZiAoXHJcbiAgICAhaGFzUHJvcGVydHkoc3RhdGUsICdTbmFwQ29udHJvbGxlcicpIHx8XHJcbiAgICAhaGFzUHJvcGVydHkoc3RhdGUsICdQZXJtaXNzaW9uQ29udHJvbGxlcicpIHx8XHJcbiAgICAhaXNPYmplY3Qoc3RhdGUuUGVybWlzc2lvbkNvbnRyb2xsZXIpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGNvbnN0IHsgUGVybWlzc2lvbkNvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBjb25zdCB7IHN1YmplY3RzIH0gPSBQZXJtaXNzaW9uQ29udHJvbGxlcjtcclxuXHJcbiAgaWYgKCFpc09iamVjdChzdWJqZWN0cykpIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNuYXBQcmVmaXggPSAnd2FsbGV0X3NuYXBfJztcclxuXHJcbiAgZm9yIChjb25zdCBbc3ViamVjdE5hbWUsIHN1YmplY3RdIG9mIE9iamVjdC5lbnRyaWVzKHN1YmplY3RzKSkge1xyXG4gICAgaWYgKCFpc09iamVjdChzdWJqZWN0KSB8fCAhaXNPYmplY3Qoc3ViamVjdC5wZXJtaXNzaW9ucykpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGUgbGF0ZXN0IHBlcm1pc3Npb24ncyBkYXRlIGFuZCBhc3NvY2lhdGVkIGlkXHJcbiAgICAvLyB0byBhc3NpZ24gdG8gdGhlIHdhbGxldF9zbmFwIHBlcm1pc3Npb24gYWZ0ZXIgaXRlcmF0aW5nIHRocm91Z2ggYWxsIHBlcm1pc3Npb25zXHJcbiAgICBsZXQgZGF0ZSA9IDE7XHJcbiAgICBsZXQgaWQ7XHJcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBzdWJqZWN0O1xyXG4gICAgLy8gTmV3IHBlcm1pc3Npb25zIG9iamVjdCB0aGF0IHdlIHVzZSB0byB0YWNrIG9uIHRoZSBgd2FsbGV0X3NuYXBgIHBlcm1pc3Npb25cclxuICAgIGNvbnN0IHVwZGF0ZWRQZXJtaXNzaW9ucyA9IHsgLi4ucGVybWlzc2lvbnMgfTtcclxuICAgIGZvciAoY29uc3QgW3Blcm1pc3Npb25OYW1lLCBwZXJtaXNzaW9uXSBvZiBPYmplY3QuZW50cmllcyhwZXJtaXNzaW9ucykpIHtcclxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHBlcm1pc3Npb24gaXMgbmFtZXNwYWNlZFxyXG4gICAgICBpZiAocGVybWlzc2lvbk5hbWUuc3RhcnRzV2l0aChzbmFwUHJlZml4KSkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFpc09iamVjdChwZXJtaXNzaW9uKSB8fFxyXG4gICAgICAgICAgIWhhc1Byb3BlcnR5KHBlcm1pc3Npb24sICdpZCcpIHx8XHJcbiAgICAgICAgICAhaGFzUHJvcGVydHkocGVybWlzc2lvbiwgJ2RhdGUnKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBjcmVhdGUgYSB3YWxsZXRfc25hcCBrZXkgaWYgd2UgYWxyZWFkeSBkb24ndCBoYXZlIG9uZVxyXG4gICAgICAgIGlmICghaGFzUHJvcGVydHkodXBkYXRlZFBlcm1pc3Npb25zLCAnd2FsbGV0X3NuYXAnKSkge1xyXG4gICAgICAgICAgdXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwID0ge1xyXG4gICAgICAgICAgICBjYXZlYXRzOiBbeyB0eXBlOiAnc25hcElkcycsIHZhbHVlOiB7fSB9XSxcclxuICAgICAgICAgICAgaW52b2tlcjogc3ViamVjdE5hbWUsXHJcbiAgICAgICAgICAgIHBhcmVudENhcGFiaWxpdHk6ICd3YWxsZXRfc25hcCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4aXN0aW5nIHBlcm1pc3Npb24gaXMgdmFsaWRcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KHVwZGF0ZWRQZXJtaXNzaW9ucy53YWxsZXRfc25hcCkpIHtcclxuICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFpc0FycmF5KFxyXG4gICAgICAgICAgICAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5jYXZlYXRzLFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkaW5nIHRoZSBzbmFwIG5hbWUgdG8gdGhlIHdhbGxldF9zbmFwIHBlcm1pc3Npb24ncyBjYXZlYXQgdmFsdWVcclxuICAgICAgICBjb25zdCBzbmFwSWQgPSBwZXJtaXNzaW9uTmFtZS5zbGljZShzbmFwUHJlZml4Lmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY2F2ZWF0ID0gKFxyXG4gICAgICAgICAgKHVwZGF0ZWRQZXJtaXNzaW9ucy53YWxsZXRfc25hcCBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxyXG4gICAgICAgICAgICAuY2F2ZWF0cyBhcyB1bmtub3duW11cclxuICAgICAgICApWzBdO1xyXG5cclxuICAgICAgICBpZiAoIWlzT2JqZWN0KGNhdmVhdCkpIHtcclxuICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFoYXNQcm9wZXJ0eShjYXZlYXQsICd0eXBlJykgfHxcclxuICAgICAgICAgIGNhdmVhdC50eXBlICE9PSAnc25hcElkcycgfHxcclxuICAgICAgICAgICFoYXNQcm9wZXJ0eShjYXZlYXQsICd2YWx1ZScpIHx8XHJcbiAgICAgICAgICAhaXNPYmplY3QoY2F2ZWF0LnZhbHVlKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXZlYXQudmFsdWVbc25hcElkXSA9IHt9O1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0eXBlb2YgcGVybWlzc2lvbi5kYXRlICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgdHlwZW9mIHBlcm1pc3Npb24uaWQgIT09ICdzdHJpbmcnXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGluZyB0aGUgZGF0ZSAmIGlkIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCBhbGwgcGVybWlzc2lvbnNcclxuICAgICAgICBpZiAocGVybWlzc2lvbi5kYXRlID4gZGF0ZSkge1xyXG4gICAgICAgICAgZGF0ZSA9IHBlcm1pc3Npb24uZGF0ZTtcclxuICAgICAgICAgIGlkID0gcGVybWlzc2lvbi5pZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmFsbHkgZGVsZXRpbmcgdGhlIHN0YWxlIHBlcm1pc3Npb25cclxuICAgICAgICBkZWxldGUgdXBkYXRlZFBlcm1pc3Npb25zW3Blcm1pc3Npb25OYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlIHJlYXNzaWduIHRoZSBkYXRlIGFuZCBpZCBoZXJlIGFmdGVyIGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBwZXJtaXNzaW9uc1xyXG4gICAgLy8gYW5kIHVwZGF0ZSB0aGUgc3ViamVjdCB3aXRoIHRoZSB1cGRhdGVkIHBlcm1pc3Npb25zXHJcbiAgICBpZiAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwKSB7XHJcbiAgICAgICh1cGRhdGVkUGVybWlzc2lvbnMud2FsbGV0X3NuYXAgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pLmRhdGUgPSBkYXRlO1xyXG4gICAgICAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5pZCA9IGlkO1xyXG4gICAgICBzdWJqZWN0LnBlcm1pc3Npb25zID0gdXBkYXRlZFBlcm1pc3Npb25zO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XHJcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDgyO1xyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGUgdGhlIGZyZXF1ZW50UnBjTGlzdERldGFpbCBmcm9tIHRoZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgdG8gdGhlIE5ldHdvcmtDb250cm9sbGVyLCBjb252ZXJ0IGl0IGZyb20gYW4gYXJyYXkgdG8gYW4gb2JqZWN0XHJcbiAqIGtleWVkIGJ5IHJhbmRvbSB1dWlkcy5cclxuICpcclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YSAtIFZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUsIGV4YWN0bHkgd2hhdCB3ZSBwZXJzaXN0IHRvIGRpc3QuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YSAtIFN0YXRlIG1ldGFkYXRhLlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiAtIFRoZSBjdXJyZW50IHN0YXRlIHZlcnNpb24uXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEuZGF0YSAtIFRoZSBwZXJzaXN0ZWQgTWV0YU1hc2sgc3RhdGUsIGtleWVkIGJ5IGNvbnRyb2xsZXIuXHJcbiAqIEByZXR1cm5zIFVwZGF0ZWQgdmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YToge1xyXG4gIG1ldGE6IHsgdmVyc2lvbjogbnVtYmVyIH07XHJcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcbn0pIHtcclxuICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHZlcnNpb25lZERhdGEuZGF0YSk7XHJcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xyXG4gIGlmIChcclxuICAgICFoYXNQcm9wZXJ0eShzdGF0ZSwgJ1ByZWZlcmVuY2VzQ29udHJvbGxlcicpIHx8XHJcbiAgICAhaXNPYmplY3Qoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB8fFxyXG4gICAgIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSB8fFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlciwgJ2ZyZXF1ZW50UnBjTGlzdERldGFpbCcpIHx8XHJcbiAgICAhQXJyYXkuaXNBcnJheShzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB8fFxyXG4gICAgIXN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwuZXZlcnkoaXNPYmplY3QpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyLCBOZXR3b3JrQ29udHJvbGxlciB9ID0gc3RhdGU7XHJcbiAgY29uc3QgeyBmcmVxdWVudFJwY0xpc3REZXRhaWwgfSA9IFByZWZlcmVuY2VzQ29udHJvbGxlcjtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoZnJlcXVlbnRScGNMaXN0RGV0YWlsKSkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb25zID0gZnJlcXVlbnRScGNMaXN0RGV0YWlsLnJlZHVjZShcclxuICAgIChcclxuICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb25zQWNjLFxyXG4gICAgICB7IHJwY1VybCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSwgcnBjUHJlZnMgfSxcclxuICAgICkgPT4ge1xyXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlndXJhdGlvbklkID0gdjQoKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5uZXR3b3JrQ29uZmlndXJhdGlvbnNBY2MsXHJcbiAgICAgICAgW25ldHdvcmtDb25maWd1cmF0aW9uSWRdOiB7XHJcbiAgICAgICAgICBycGNVcmwsXHJcbiAgICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgICAgdGlja2VyLFxyXG4gICAgICAgICAgcnBjUHJlZnMsXHJcbiAgICAgICAgICBuaWNrbmFtZSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIHt9LFxyXG4gICk7XHJcblxyXG4gIGRlbGV0ZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBOZXR3b3JrQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlcixcclxuICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb25zLFxyXG4gICAgfSxcclxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4MztcclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhhdCBlYWNoIG5ldHdvcmtDb25maWd1cmF0aW9ucyBvYmplY3QgaW4gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0NvbmZpZ3VyYXRpb25zIGhhcyBhblxyXG4gKiBgaWRgIHByb3BlcnR5IHdoaWNoIG1hdGNoZXMgdGhlIGtleSBwb2ludGluZyB0aGF0IG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKCFpc09iamVjdChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikpIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcbiAgY29uc3QgeyBOZXR3b3JrQ29udHJvbGxlciB9ID0gc3RhdGU7XHJcblxyXG4gIGlmICghaXNPYmplY3QoTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0NvbmZpZ3VyYXRpb25zKSkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBuZXR3b3JrQ29uZmlndXJhdGlvbnMgfSA9IE5ldHdvcmtDb250cm9sbGVyO1xyXG5cclxuICBjb25zdCBuZXdOZXR3b3JrQ29uZmlndXJhdGlvbnM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IHt9O1xyXG5cclxuICBmb3IgKGNvbnN0IG5ldHdvcmtDb25maWd1cmF0aW9uSWQgb2YgT2JqZWN0LmtleXMobmV0d29ya0NvbmZpZ3VyYXRpb25zKSkge1xyXG4gICAgY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb24gPSBuZXR3b3JrQ29uZmlndXJhdGlvbnNbbmV0d29ya0NvbmZpZ3VyYXRpb25JZF07XHJcbiAgICBpZiAoIWlzT2JqZWN0KG5ldHdvcmtDb25maWd1cmF0aW9uKSkge1xyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbiAgICBuZXdOZXR3b3JrQ29uZmlndXJhdGlvbnNbbmV0d29ya0NvbmZpZ3VyYXRpb25JZF0gPSB7XHJcbiAgICAgIC4uLm5ldHdvcmtDb25maWd1cmF0aW9uLFxyXG4gICAgICBpZDogbmV0d29ya0NvbmZpZ3VyYXRpb25JZCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBOZXR3b3JrQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlcixcclxuICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb25zOiBuZXdOZXR3b3JrQ29uZmlndXJhdGlvbnMsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgaGFzUHJvcGVydHksIGlzT2JqZWN0IH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gODQ7XHJcblxyXG4vKipcclxuICogVGhlIGBuZXR3b3JrYCBwcm9wZXJ0eSBpbiBzdGF0ZSB3YXMgcmVwbGFjZWQgd2l0aCBgbmV0d29ya0lkYCBhbmQgYG5ldHdvcmtTdGF0dXNgLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLCAnTmV0d29ya0NvbnRyb2xsZXInKSB8fFxyXG4gICAgIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSB8fFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLCAnbmV0d29yaycpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBOZXR3b3JrQ29udHJvbGxlciA9IHsgLi4uc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIgfTtcclxuXHJcbiAgaWYgKE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmsgPT09ICdsb2FkaW5nJykge1xyXG4gICAgTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0lkID0gbnVsbDtcclxuICAgIE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmtTdGF0dXMgPSAndW5rbm93bic7XHJcbiAgfSBlbHNlIHtcclxuICAgIE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmtJZCA9IE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XHJcbiAgICBOZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrU3RhdHVzID0gJ2F2YWlsYWJsZSc7XHJcbiAgfVxyXG5cclxuICBkZWxldGUgTmV0d29ya0NvbnRyb2xsZXIubmV0d29yaztcclxuXHJcbiAgcmV0dXJuIHsgLi4uc3RhdGUsIE5ldHdvcmtDb250cm9sbGVyIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4NTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIG5vdy1vYnNvbGV0ZSBuZXR3b3JrIGNvbnRyb2xsZXIgYHByZXZpb3VzUHJvdmlkZXJTdG9yZWAgc3RhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEgLSBWZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLCBleGFjdGx5IHdoYXQgd2UgcGVyc2lzdCB0byBkaXN0LlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEgLSBTdGF0ZSBtZXRhZGF0YS5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gLSBUaGUgY3VycmVudCBzdGF0ZSB2ZXJzaW9uLlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLmRhdGEgLSBUaGUgcGVyc2lzdGVkIE1ldGFNYXNrIHN0YXRlLCBrZXllZCBieSBjb250cm9sbGVyLlxyXG4gKiBAcmV0dXJucyBVcGRhdGVkIHZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGE6IHtcclxuICBtZXRhOiB7IHZlcnNpb246IG51bWJlciB9O1xyXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG59KSB7XHJcbiAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZSh2ZXJzaW9uZWREYXRhLmRhdGEpO1xyXG4gIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcclxuICBpZiAoIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByZXZpb3VzUHJvdmlkZXJTdG9yZTtcclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDg2O1xyXG5cclxuLyoqXHJcbiAqIFJlbmFtZSBuZXR3b3JrIGNvbnRyb2xsZXIgYHByb3ZpZGVyYCBzdGF0ZSB0byBgcHJvdmlkZXJDb25maWdgLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKFxyXG4gICAgaGFzUHJvcGVydHkoc3RhdGUsICdOZXR3b3JrQ29udHJvbGxlcicpICYmXHJcbiAgICBpc09iamVjdChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikgJiZcclxuICAgIGhhc1Byb3BlcnR5KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLCAncHJvdmlkZXInKVxyXG4gICkge1xyXG4gICAgY29uc3QgbmV0d29ya0NvbnRyb2xsZXJTdGF0ZSA9IHN0YXRlLk5ldHdvcmtDb250cm9sbGVyO1xyXG4gICAgbmV0d29ya0NvbnRyb2xsZXJTdGF0ZS5wcm92aWRlckNvbmZpZyA9IG5ldHdvcmtDb250cm9sbGVyU3RhdGUucHJvdmlkZXI7XHJcbiAgICBkZWxldGUgbmV0d29ya0NvbnRyb2xsZXJTdGF0ZS5wcm92aWRlcjtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi5zdGF0ZSxcclxuICAgICAgTmV0d29ya0NvbnRyb2xsZXI6IG5ldHdvcmtDb250cm9sbGVyU3RhdGUsXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZhaWxUeHNUaGF0KHZlcnNpb24sIHJlYXNvbiwgY29uZGl0aW9uKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlLCBjb25kaXRpb24sIHJlYXNvbik7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlLCBjb25kaXRpb24sIHJlYXNvbikge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xyXG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuXHJcbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XHJcbiAgICAgIGlmICghY29uZGl0aW9uKHR4TWV0YSkpIHtcclxuICAgICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0eE1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkO1xyXG4gICAgICB0eE1ldGEuZXJyID0ge1xyXG4gICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcclxuICAgICAgICBub3RlOiBgVHggYXV0b21hdGljYWxseSBmYWlsZWQgYnkgbWlncmF0aW9uIGJlY2F1c2UgJHtyZWFzb259YCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8vIE1pZ3JhdGlvbnMgbXVzdCBzdGFydCBhdCB2ZXJzaW9uIDEgb3IgbGF0ZXIuXHJcbi8vIFRoZXkgYXJlIG9iamVjdHMgd2l0aCBhIGB2ZXJzaW9uYCBudW1iZXJcclxuLy8gYW5kIGEgYG1pZ3JhdGVgIGZ1bmN0aW9uLlxyXG4vL1xyXG4vLyBUaGUgYG1pZ3JhdGVgIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBwcmV2aW91c1xyXG4vLyBjb25maWcgZGF0YSBmb3JtYXQsIGFuZCByZXR1cm5zIHRoZSBuZXcgb25lLlxyXG5cclxuaW1wb3J0IG0wMDIgZnJvbSAnLi8wMDInO1xyXG5pbXBvcnQgbTAwMyBmcm9tICcuLzAwMyc7XHJcbmltcG9ydCBtMDA0IGZyb20gJy4vMDA0JztcclxuaW1wb3J0IG0wMDUgZnJvbSAnLi8wMDUnO1xyXG5pbXBvcnQgbTAwNiBmcm9tICcuLzAwNic7XHJcbmltcG9ydCBtMDA3IGZyb20gJy4vMDA3JztcclxuaW1wb3J0IG0wMDggZnJvbSAnLi8wMDgnO1xyXG5pbXBvcnQgbTAwOSBmcm9tICcuLzAwOSc7XHJcbmltcG9ydCBtMDEwIGZyb20gJy4vMDEwJztcclxuaW1wb3J0IG0wMTEgZnJvbSAnLi8wMTEnO1xyXG5pbXBvcnQgbTAxMiBmcm9tICcuLzAxMic7XHJcbmltcG9ydCBtMDEzIGZyb20gJy4vMDEzJztcclxuaW1wb3J0IG0wMTQgZnJvbSAnLi8wMTQnO1xyXG5pbXBvcnQgbTAxNSBmcm9tICcuLzAxNSc7XHJcbmltcG9ydCBtMDE2IGZyb20gJy4vMDE2JztcclxuaW1wb3J0IG0wMTcgZnJvbSAnLi8wMTcnO1xyXG5pbXBvcnQgbTAxOCBmcm9tICcuLzAxOCc7XHJcbmltcG9ydCBtMDE5IGZyb20gJy4vMDE5JztcclxuaW1wb3J0IG0wMjAgZnJvbSAnLi8wMjAnO1xyXG5pbXBvcnQgbTAyMSBmcm9tICcuLzAyMSc7XHJcbmltcG9ydCBtMDIyIGZyb20gJy4vMDIyJztcclxuaW1wb3J0IG0wMjMgZnJvbSAnLi8wMjMnO1xyXG5pbXBvcnQgbTAyNCBmcm9tICcuLzAyNCc7XHJcbmltcG9ydCBtMDI1IGZyb20gJy4vMDI1JztcclxuaW1wb3J0IG0wMjYgZnJvbSAnLi8wMjYnO1xyXG5pbXBvcnQgbTAyNyBmcm9tICcuLzAyNyc7XHJcbmltcG9ydCBtMDI4IGZyb20gJy4vMDI4JztcclxuaW1wb3J0IG0wMjkgZnJvbSAnLi8wMjknO1xyXG5pbXBvcnQgbTAzMCBmcm9tICcuLzAzMCc7XHJcbmltcG9ydCBtMDMxIGZyb20gJy4vMDMxJztcclxuaW1wb3J0IG0wMzIgZnJvbSAnLi8wMzInO1xyXG5pbXBvcnQgbTAzMyBmcm9tICcuLzAzMyc7XHJcbmltcG9ydCBtMDM0IGZyb20gJy4vMDM0JztcclxuaW1wb3J0IG0wMzUgZnJvbSAnLi8wMzUnO1xyXG5pbXBvcnQgbTAzNiBmcm9tICcuLzAzNic7XHJcbmltcG9ydCBtMDM3IGZyb20gJy4vMDM3JztcclxuaW1wb3J0IG0wMzggZnJvbSAnLi8wMzgnO1xyXG5pbXBvcnQgbTAzOSBmcm9tICcuLzAzOSc7XHJcbmltcG9ydCBtMDQwIGZyb20gJy4vMDQwJztcclxuaW1wb3J0IG0wNDEgZnJvbSAnLi8wNDEnO1xyXG5pbXBvcnQgbTA0MiBmcm9tICcuLzA0Mic7XHJcbmltcG9ydCBtMDQzIGZyb20gJy4vMDQzJztcclxuaW1wb3J0IG0wNDQgZnJvbSAnLi8wNDQnO1xyXG5pbXBvcnQgbTA0NSBmcm9tICcuLzA0NSc7XHJcbmltcG9ydCBtMDQ2IGZyb20gJy4vMDQ2JztcclxuaW1wb3J0IG0wNDcgZnJvbSAnLi8wNDcnO1xyXG5pbXBvcnQgbTA0OCBmcm9tICcuLzA0OCc7XHJcbmltcG9ydCBtMDQ5IGZyb20gJy4vMDQ5JztcclxuaW1wb3J0IG0wNTAgZnJvbSAnLi8wNTAnO1xyXG5pbXBvcnQgbTA1MSBmcm9tICcuLzA1MSc7XHJcbmltcG9ydCBtMDUyIGZyb20gJy4vMDUyJztcclxuaW1wb3J0IG0wNTMgZnJvbSAnLi8wNTMnO1xyXG5pbXBvcnQgbTA1NCBmcm9tICcuLzA1NCc7XHJcbmltcG9ydCBtMDU1IGZyb20gJy4vMDU1JztcclxuaW1wb3J0IG0wNTYgZnJvbSAnLi8wNTYnO1xyXG5pbXBvcnQgbTA1NyBmcm9tICcuLzA1Nyc7XHJcbmltcG9ydCBtMDU4IGZyb20gJy4vMDU4JztcclxuaW1wb3J0IG0wNTkgZnJvbSAnLi8wNTknO1xyXG5pbXBvcnQgbTA2MCBmcm9tICcuLzA2MCc7XHJcbmltcG9ydCBtMDYxIGZyb20gJy4vMDYxJztcclxuaW1wb3J0IG0wNjIgZnJvbSAnLi8wNjInO1xyXG5pbXBvcnQgbTA2MyBmcm9tICcuLzA2Myc7XHJcbmltcG9ydCBtMDY0IGZyb20gJy4vMDY0JztcclxuaW1wb3J0IG0wNjUgZnJvbSAnLi8wNjUnO1xyXG5pbXBvcnQgbTA2NiBmcm9tICcuLzA2Nic7XHJcbmltcG9ydCBtMDY3IGZyb20gJy4vMDY3JztcclxuaW1wb3J0IG0wNjggZnJvbSAnLi8wNjgnO1xyXG5pbXBvcnQgbTA2OSBmcm9tICcuLzA2OSc7XHJcbmltcG9ydCBtMDcwIGZyb20gJy4vMDcwJztcclxuaW1wb3J0IG0wNzEgZnJvbSAnLi8wNzEnO1xyXG5pbXBvcnQgbTA3MiBmcm9tICcuLzA3Mic7XHJcbmltcG9ydCBtMDczIGZyb20gJy4vMDczJztcclxuaW1wb3J0IG0wNzQgZnJvbSAnLi8wNzQnO1xyXG5pbXBvcnQgbTA3NSBmcm9tICcuLzA3NSc7XHJcbmltcG9ydCBtMDc2IGZyb20gJy4vMDc2JztcclxuaW1wb3J0IG0wNzcgZnJvbSAnLi8wNzcnO1xyXG5pbXBvcnQgKiBhcyBtMDc4IGZyb20gJy4vMDc4JztcclxuaW1wb3J0IG0wNzkgZnJvbSAnLi8wNzknO1xyXG5pbXBvcnQgbTA4MCBmcm9tICcuLzA4MCc7XHJcbmltcG9ydCAqIGFzIG0wODEgZnJvbSAnLi8wODEnO1xyXG5pbXBvcnQgKiBhcyBtMDgyIGZyb20gJy4vMDgyJztcclxuaW1wb3J0ICogYXMgbTA4MyBmcm9tICcuLzA4Myc7XHJcbmltcG9ydCAqIGFzIG0wODQgZnJvbSAnLi8wODQnO1xyXG5pbXBvcnQgKiBhcyBtMDg1IGZyb20gJy4vMDg1JztcclxuaW1wb3J0ICogYXMgbTA4NiBmcm9tICcuLzA4Nic7XHJcblxyXG5jb25zdCBtaWdyYXRpb25zID0gW1xyXG4gIG0wMDIsXHJcbiAgbTAwMyxcclxuICBtMDA0LFxyXG4gIG0wMDUsXHJcbiAgbTAwNixcclxuICBtMDA3LFxyXG4gIG0wMDgsXHJcbiAgbTAwOSxcclxuICBtMDEwLFxyXG4gIG0wMTEsXHJcbiAgbTAxMixcclxuICBtMDEzLFxyXG4gIG0wMTQsXHJcbiAgbTAxNSxcclxuICBtMDE2LFxyXG4gIG0wMTcsXHJcbiAgbTAxOCxcclxuICBtMDE5LFxyXG4gIG0wMjAsXHJcbiAgbTAyMSxcclxuICBtMDIyLFxyXG4gIG0wMjMsXHJcbiAgbTAyNCxcclxuICBtMDI1LFxyXG4gIG0wMjYsXHJcbiAgbTAyNyxcclxuICBtMDI4LFxyXG4gIG0wMjksXHJcbiAgbTAzMCxcclxuICBtMDMxLFxyXG4gIG0wMzIsXHJcbiAgbTAzMyxcclxuICBtMDM0LFxyXG4gIG0wMzUsXHJcbiAgbTAzNixcclxuICBtMDM3LFxyXG4gIG0wMzgsXHJcbiAgbTAzOSxcclxuICBtMDQwLFxyXG4gIG0wNDEsXHJcbiAgbTA0MixcclxuICBtMDQzLFxyXG4gIG0wNDQsXHJcbiAgbTA0NSxcclxuICBtMDQ2LFxyXG4gIG0wNDcsXHJcbiAgbTA0OCxcclxuICBtMDQ5LFxyXG4gIG0wNTAsXHJcbiAgbTA1MSxcclxuICBtMDUyLFxyXG4gIG0wNTMsXHJcbiAgbTA1NCxcclxuICBtMDU1LFxyXG4gIG0wNTYsXHJcbiAgbTA1NyxcclxuICBtMDU4LFxyXG4gIG0wNTksXHJcbiAgbTA2MCxcclxuICBtMDYxLFxyXG4gIG0wNjIsXHJcbiAgbTA2MyxcclxuICBtMDY0LFxyXG4gIG0wNjUsXHJcbiAgbTA2NixcclxuICBtMDY3LFxyXG4gIG0wNjgsXHJcbiAgbTA2OSxcclxuICBtMDcwLFxyXG4gIG0wNzEsXHJcbiAgbTA3MixcclxuICBtMDczLFxyXG4gIG0wNzQsXHJcbiAgbTA3NSxcclxuICBtMDc2LFxyXG4gIG0wNzcsXHJcbiAgbTA3OCxcclxuICBtMDc5LFxyXG4gIG0wODAsXHJcbiAgbTA4MSxcclxuICBtMDgyLFxyXG4gIG0wODMsXHJcbiAgbTA4NCxcclxuICBtMDg1LFxyXG4gIG0wODYsXHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtaWdyYXRpb25zO1xyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlTmFtZX0gQmFzZU5hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZUNvZGV9IEJhc2VDb2RlICovXG5cbi8qKlxuICogQ2xhc3MgdG8gZW5jb2RlL2RlY29kZSBpbiB0aGUgc3VwcG9ydGVkIEJhc2VzXG4gKlxuICovXG5jbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZU5hbWV9IG5hbWVcbiAgICogQHBhcmFtIHtCYXNlQ29kZX0gY29kZVxuICAgKiBAcGFyYW0ge0NvZGVjRmFjdG9yeX0gZmFjdG9yeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBmYWN0b3J5LCBhbHBoYWJldCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgdGhpcy5jb2RlQnVmID0gZW5jb2RlVGV4dCh0aGlzLmNvZGUpXG4gICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0XG4gICAgdGhpcy5jb2RlYyA9IGZhY3RvcnkoYWxwaGFiZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuY29kZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZWMuZW5jb2RlKGJ1ZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZGVjb2RlIChzdHJpbmcpIHtcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAodGhpcy5hbHBoYWJldCAmJiB0aGlzLmFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjaGFyYWN0ZXIgJyR7Y2hhcn0nIGluICcke3N0cmluZ30nYClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29kZWMuZGVjb2RlKHN0cmluZylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlWCA9IHJlcXVpcmUoJ0BtdWx0aWZvcm1hdHMvYmFzZS14JylcbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKVxuY29uc3QgeyByZmM0NjQ4IH0gPSByZXF1aXJlKCcuL3JmYzQ2NDgnKVxuY29uc3QgeyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWN9IENvZGVjICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5CYXNlTmFtZX0gQmFzZU5hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkJhc2VDb2RlfSBCYXNlQ29kZSAqL1xuXG4vKiogQHR5cGUge0NvZGVjRmFjdG9yeX0gKi9cbmNvbnN0IGlkZW50aXR5ID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZGVjb2RlVGV4dCxcbiAgICBkZWNvZGU6IGVuY29kZVRleHRcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXRcbiAqXG4gKiBAdHlwZSB7QXJyYXk8W0Jhc2VOYW1lLCBCYXNlQ29kZSwgQ29kZWNGYWN0b3J5LCBzdHJpbmddPn1cbiAqL1xuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2lkZW50aXR5JywgJ1xceDAwJywgaWRlbnRpdHksICcnXSxcbiAgWydiYXNlMicsICcwJywgcmZjNDY0OCgxKSwgJzAxJ10sXG4gIFsnYmFzZTgnLCAnNycsIHJmYzQ2NDgoMyksICcwMTIzNDU2NyddLFxuICBbJ2Jhc2UxMCcsICc5JywgYmFzZVgsICcwMTIzNDU2Nzg5J10sXG4gIFsnYmFzZTE2JywgJ2YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OWFiY2RlZiddLFxuICBbJ2Jhc2UxNnVwcGVyJywgJ0YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OUFCQ0RFRiddLFxuICBbJ2Jhc2UzMmhleCcsICd2JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4dXBwZXInLCAnVicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVViddLFxuICBbJ2Jhc2UzMmhleHBhZCcsICd0JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PSddLFxuICBbJ2Jhc2UzMmhleHBhZHVwcGVyJywgJ1QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9J10sXG4gIFsnYmFzZTMyJywgJ2InLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnXSxcbiAgWydiYXNlMzJ1cHBlcicsICdCJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9J10sXG4gIFsnYmFzZTMycGFkdXBwZXInLCAnQycsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCByZmM0NjQ4KDUpLCAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknXSxcbiAgWydiYXNlMzYnLCAnaycsIGJhc2VYLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTM2dXBwZXInLCAnSycsIGJhc2VYLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNThmbGlja3InLCAnWicsIGJhc2VYLCAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U2NCcsICdtJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSddLFxuICBbJ2Jhc2U2NHVybCcsICd1JywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nXSxcbiAgWydiYXNlNjR1cmxwYWQnLCAnVScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbi8qKiBAdHlwZSB7UmVjb3JkPEJhc2VOYW1lLEJhc2U+fSAqL1xuY29uc3QgbmFtZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMF1dID0gbmV3IEJhc2UodHVwcGxlWzBdLCB0dXBwbGVbMV0sIHR1cHBsZVsyXSwgdHVwcGxlWzNdKVxuICByZXR1cm4gcHJldlxufSwgLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZU5hbWUsQmFzZT59ICovKHt9KSlcblxuLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZUNvZGUsQmFzZT59ICovXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCAvKiogQHR5cGUge1JlY29yZDxCYXNlQ29kZSxCYXNlPn0gKi8oe30pKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZXMsXG4gIGNvZGVzXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICAvLyBCdWlsZCB0aGUgY2hhcmFjdGVyIGxvb2t1cCB0YWJsZTpcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSAqL1xuICBjb25zdCBjb2RlcyA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpXG4gIH1cblxuICAvLyBDb3VudCB0aGUgcGFkZGluZyBieXRlczpcbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGhcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmRcbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHRoZSBvdXRwdXQ6XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KChlbmQgKiBiaXRzUGVyQ2hhciAvIDgpIHwgMClcblxuICAvLyBQYXJzZSB0aGUgZGF0YTpcbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGxldCB3cml0dGVuID0gMCAvLyBOZXh0IGJ5dGUgdG8gd3JpdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIC8vIFJlYWQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJpbmc6XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgJyArIHN0cmluZ1tpXSlcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IGJpdHNQZXJDaGFyKSB8IHZhbHVlXG4gICAgYml0cyArPSBiaXRzUGVyQ2hhclxuXG4gICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDhcbiAgICAgIG91dFt3cml0dGVuKytdID0gMHhmZiAmIChidWZmZXIgPj4gYml0cylcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSdcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDFcbiAgbGV0IG91dCA9ICcnXG5cbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBkYXRhW2ldXG4gICAgYml0cyArPSA4XG5cbiAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhclxuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyID4+IGJpdHMpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldXG4gIH1cblxuICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAoKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhcikgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJGQzQ2NDggRmFjdG9yeVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge0NvZGVjRmFjdG9yeX1cbiAqL1xuY29uc3QgcmZjNDY0OCA9IChiaXRzUGVyQ2hhcikgPT4gKGFscGhhYmV0KSA9PiB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGVuY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGRlY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmZjNDY0OCB9XG4iLCIndXNlIHN0cmljdCdcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgeyBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ9IGJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBkZWNvZGVUZXh0ID0gKGJ5dGVzKSA9PiB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVUZXh0ID0gKHRleHQpID0+IHRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgVWludDhBcnJheSBjcmVhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhc3NlZCBBcnJheXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAoYXJycywgbGVuZ3RoKSB7XG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgbGV0IG9mZnNldCA9IDBcblxuICBmb3IgKGNvbnN0IGFyciBvZiBhcnJzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCwgY29uY2F0IH1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsIHx8IHNoaWZ0ID4gNDkpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIGlmIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGVuY29kZS5ieXRlcyA9IDBcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGVuY29kZSB2YXJpbnQnKVxuICB9XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZTogcmVxdWlyZSgnLi9lbmNvZGUuanMnKVxuICAsIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUuanMnKVxuICAsIGVuY29kaW5nTGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aC5qcycpXG59XG4iLCJcbnZhciBOMSA9IE1hdGgucG93KDIsICA3KVxudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpXG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSlcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KVxudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpXG52YXIgTjYgPSBNYXRoLnBvdygyLCA0MilcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KVxudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpXG52YXIgTjkgPSBNYXRoLnBvdygyLCA2MylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA8IE4xID8gMVxuICA6IHZhbHVlIDwgTjIgPyAyXG4gIDogdmFsdWUgPCBOMyA/IDNcbiAgOiB2YWx1ZSA8IE40ID8gNFxuICA6IHZhbHVlIDwgTjUgPyA1XG4gIDogdmFsdWUgPCBONiA/IDZcbiAgOiB2YWx1ZSA8IE43ID8gN1xuICA6IHZhbHVlIDwgTjggPyA4XG4gIDogdmFsdWUgPCBOOSA/IDlcbiAgOiAgICAgICAgICAgICAgMTBcbiAgKVxufVxuIiwiLy8gRE8gTk9UIENIQU5HRSBUSElTIEZJTEUuIElUIElTIEdFTkVSQVRFRCBCWSB0b29scy91cGRhdGUtdGFibGUuanNcbi8qIGVzbGludCBxdW90ZS1wcm9wczogb2ZmICovXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAdHlwZSB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5OYW1lTnVtYmVyTWFwfVxuICovXG5jb25zdCBiYXNlVGFibGUgPSBPYmplY3QuZnJlZXplKHtcbiAgJ2lkZW50aXR5JzogMHgwMCxcbiAgJ2NpZHYxJzogMHgwMSxcbiAgJ2NpZHYyJzogMHgwMixcbiAgJ2NpZHYzJzogMHgwMyxcbiAgJ2lwNCc6IDB4MDQsXG4gICd0Y3AnOiAweDA2LFxuICAnc2hhMSc6IDB4MTEsXG4gICdzaGEyLTI1Nic6IDB4MTIsXG4gICdzaGEyLTUxMic6IDB4MTMsXG4gICdzaGEzLTUxMic6IDB4MTQsXG4gICdzaGEzLTM4NCc6IDB4MTUsXG4gICdzaGEzLTI1Nic6IDB4MTYsXG4gICdzaGEzLTIyNCc6IDB4MTcsXG4gICdzaGFrZS0xMjgnOiAweDE4LFxuICAnc2hha2UtMjU2JzogMHgxOSxcbiAgJ2tlY2Nhay0yMjQnOiAweDFhLFxuICAna2VjY2FrLTI1Nic6IDB4MWIsXG4gICdrZWNjYWstMzg0JzogMHgxYyxcbiAgJ2tlY2Nhay01MTInOiAweDFkLFxuICAnYmxha2UzJzogMHgxZSxcbiAgJ2RjY3AnOiAweDIxLFxuICAnbXVybXVyMy0xMjgnOiAweDIyLFxuICAnbXVybXVyMy0zMic6IDB4MjMsXG4gICdpcDYnOiAweDI5LFxuICAnaXA2em9uZSc6IDB4MmEsXG4gICdwYXRoJzogMHgyZixcbiAgJ211bHRpY29kZWMnOiAweDMwLFxuICAnbXVsdGloYXNoJzogMHgzMSxcbiAgJ211bHRpYWRkcic6IDB4MzIsXG4gICdtdWx0aWJhc2UnOiAweDMzLFxuICAnZG5zJzogMHgzNSxcbiAgJ2RuczQnOiAweDM2LFxuICAnZG5zNic6IDB4MzcsXG4gICdkbnNhZGRyJzogMHgzOCxcbiAgJ3Byb3RvYnVmJzogMHg1MCxcbiAgJ2Nib3InOiAweDUxLFxuICAncmF3JzogMHg1NSxcbiAgJ2RibC1zaGEyLTI1Nic6IDB4NTYsXG4gICdybHAnOiAweDYwLFxuICAnYmVuY29kZSc6IDB4NjMsXG4gICdkYWctcGInOiAweDcwLFxuICAnZGFnLWNib3InOiAweDcxLFxuICAnbGlicDJwLWtleSc6IDB4NzIsXG4gICdnaXQtcmF3JzogMHg3OCxcbiAgJ3RvcnJlbnQtaW5mbyc6IDB4N2IsXG4gICd0b3JyZW50LWZpbGUnOiAweDdjLFxuICAnbGVvZmNvaW4tYmxvY2snOiAweDgxLFxuICAnbGVvZmNvaW4tdHgnOiAweDgyLFxuICAnbGVvZmNvaW4tcHInOiAweDgzLFxuICAnc2N0cCc6IDB4ODQsXG4gICdkYWctam9zZSc6IDB4ODUsXG4gICdkYWctY29zZSc6IDB4ODYsXG4gICdldGgtYmxvY2snOiAweDkwLFxuICAnZXRoLWJsb2NrLWxpc3QnOiAweDkxLFxuICAnZXRoLXR4LXRyaWUnOiAweDkyLFxuICAnZXRoLXR4JzogMHg5MyxcbiAgJ2V0aC10eC1yZWNlaXB0LXRyaWUnOiAweDk0LFxuICAnZXRoLXR4LXJlY2VpcHQnOiAweDk1LFxuICAnZXRoLXN0YXRlLXRyaWUnOiAweDk2LFxuICAnZXRoLWFjY291bnQtc25hcHNob3QnOiAweDk3LFxuICAnZXRoLXN0b3JhZ2UtdHJpZSc6IDB4OTgsXG4gICdiaXRjb2luLWJsb2NrJzogMHhiMCxcbiAgJ2JpdGNvaW4tdHgnOiAweGIxLFxuICAnYml0Y29pbi13aXRuZXNzLWNvbW1pdG1lbnQnOiAweGIyLFxuICAnemNhc2gtYmxvY2snOiAweGMwLFxuICAnemNhc2gtdHgnOiAweGMxLFxuICAnZG9jaWQnOiAweGNlLFxuICAnc3RlbGxhci1ibG9jayc6IDB4ZDAsXG4gICdzdGVsbGFyLXR4JzogMHhkMSxcbiAgJ21kNCc6IDB4ZDQsXG4gICdtZDUnOiAweGQ1LFxuICAnYm10JzogMHhkNixcbiAgJ2RlY3JlZC1ibG9jayc6IDB4ZTAsXG4gICdkZWNyZWQtdHgnOiAweGUxLFxuICAnaXBsZC1ucyc6IDB4ZTIsXG4gICdpcGZzLW5zJzogMHhlMyxcbiAgJ3N3YXJtLW5zJzogMHhlNCxcbiAgJ2lwbnMtbnMnOiAweGU1LFxuICAnemVyb25ldCc6IDB4ZTYsXG4gICdzZWNwMjU2azEtcHViJzogMHhlNyxcbiAgJ2JsczEyXzM4MS1nMS1wdWInOiAweGVhLFxuICAnYmxzMTJfMzgxLWcyLXB1Yic6IDB4ZWIsXG4gICd4MjU1MTktcHViJzogMHhlYyxcbiAgJ2VkMjU1MTktcHViJzogMHhlZCxcbiAgJ2JsczEyXzM4MS1nMWcyLXB1Yic6IDB4ZWUsXG4gICdkYXNoLWJsb2NrJzogMHhmMCxcbiAgJ2Rhc2gtdHgnOiAweGYxLFxuICAnc3dhcm0tbWFuaWZlc3QnOiAweGZhLFxuICAnc3dhcm0tZmVlZCc6IDB4ZmIsXG4gICd1ZHAnOiAweDAxMTEsXG4gICdwMnAtd2VicnRjLXN0YXInOiAweDAxMTMsXG4gICdwMnAtd2VicnRjLWRpcmVjdCc6IDB4MDExNCxcbiAgJ3AycC1zdGFyZHVzdCc6IDB4MDExNSxcbiAgJ3AycC1jaXJjdWl0JzogMHgwMTIyLFxuICAnZGFnLWpzb24nOiAweDAxMjksXG4gICd1ZHQnOiAweDAxMmQsXG4gICd1dHAnOiAweDAxMmUsXG4gICd1bml4JzogMHgwMTkwLFxuICAncDJwJzogMHgwMWE1LFxuICAnaXBmcyc6IDB4MDFhNSxcbiAgJ2h0dHBzJzogMHgwMWJiLFxuICAnb25pb24nOiAweDAxYmMsXG4gICdvbmlvbjMnOiAweDAxYmQsXG4gICdnYXJsaWM2NCc6IDB4MDFiZSxcbiAgJ2dhcmxpYzMyJzogMHgwMWJmLFxuICAndGxzJzogMHgwMWMwLFxuICAncXVpYyc6IDB4MDFjYyxcbiAgJ3dzJzogMHgwMWRkLFxuICAnd3NzJzogMHgwMWRlLFxuICAncDJwLXdlYnNvY2tldC1zdGFyJzogMHgwMWRmLFxuICAnaHR0cCc6IDB4MDFlMCxcbiAgJ2pzb24nOiAweDAyMDAsXG4gICdtZXNzYWdlcGFjayc6IDB4MDIwMSxcbiAgJ2xpYnAycC1wZWVyLXJlY29yZCc6IDB4MDMwMSxcbiAgJ3NoYTItMjU2LXRydW5jMjU0LXBhZGRlZCc6IDB4MTAxMixcbiAgJ3JpcGVtZC0xMjgnOiAweDEwNTIsXG4gICdyaXBlbWQtMTYwJzogMHgxMDUzLFxuICAncmlwZW1kLTI1Nic6IDB4MTA1NCxcbiAgJ3JpcGVtZC0zMjAnOiAweDEwNTUsXG4gICd4MTEnOiAweDExMDAsXG4gICdwMjU2LXB1Yic6IDB4MTIwMCxcbiAgJ3AzODQtcHViJzogMHgxMjAxLFxuICAncDUyMS1wdWInOiAweDEyMDIsXG4gICdlZDQ0OC1wdWInOiAweDEyMDMsXG4gICd4NDQ4LXB1Yic6IDB4MTIwNCxcbiAgJ2VkMjU1MTktcHJpdic6IDB4MTMwMCxcbiAgJ2thbmdhcm9vdHdlbHZlJzogMHgxZDAxLFxuICAnc20zLTI1Nic6IDB4NTM0ZCxcbiAgJ2JsYWtlMmItOCc6IDB4YjIwMSxcbiAgJ2JsYWtlMmItMTYnOiAweGIyMDIsXG4gICdibGFrZTJiLTI0JzogMHhiMjAzLFxuICAnYmxha2UyYi0zMic6IDB4YjIwNCxcbiAgJ2JsYWtlMmItNDAnOiAweGIyMDUsXG4gICdibGFrZTJiLTQ4JzogMHhiMjA2LFxuICAnYmxha2UyYi01Nic6IDB4YjIwNyxcbiAgJ2JsYWtlMmItNjQnOiAweGIyMDgsXG4gICdibGFrZTJiLTcyJzogMHhiMjA5LFxuICAnYmxha2UyYi04MCc6IDB4YjIwYSxcbiAgJ2JsYWtlMmItODgnOiAweGIyMGIsXG4gICdibGFrZTJiLTk2JzogMHhiMjBjLFxuICAnYmxha2UyYi0xMDQnOiAweGIyMGQsXG4gICdibGFrZTJiLTExMic6IDB4YjIwZSxcbiAgJ2JsYWtlMmItMTIwJzogMHhiMjBmLFxuICAnYmxha2UyYi0xMjgnOiAweGIyMTAsXG4gICdibGFrZTJiLTEzNic6IDB4YjIxMSxcbiAgJ2JsYWtlMmItMTQ0JzogMHhiMjEyLFxuICAnYmxha2UyYi0xNTInOiAweGIyMTMsXG4gICdibGFrZTJiLTE2MCc6IDB4YjIxNCxcbiAgJ2JsYWtlMmItMTY4JzogMHhiMjE1LFxuICAnYmxha2UyYi0xNzYnOiAweGIyMTYsXG4gICdibGFrZTJiLTE4NCc6IDB4YjIxNyxcbiAgJ2JsYWtlMmItMTkyJzogMHhiMjE4LFxuICAnYmxha2UyYi0yMDAnOiAweGIyMTksXG4gICdibGFrZTJiLTIwOCc6IDB4YjIxYSxcbiAgJ2JsYWtlMmItMjE2JzogMHhiMjFiLFxuICAnYmxha2UyYi0yMjQnOiAweGIyMWMsXG4gICdibGFrZTJiLTIzMic6IDB4YjIxZCxcbiAgJ2JsYWtlMmItMjQwJzogMHhiMjFlLFxuICAnYmxha2UyYi0yNDgnOiAweGIyMWYsXG4gICdibGFrZTJiLTI1Nic6IDB4YjIyMCxcbiAgJ2JsYWtlMmItMjY0JzogMHhiMjIxLFxuICAnYmxha2UyYi0yNzInOiAweGIyMjIsXG4gICdibGFrZTJiLTI4MCc6IDB4YjIyMyxcbiAgJ2JsYWtlMmItMjg4JzogMHhiMjI0LFxuICAnYmxha2UyYi0yOTYnOiAweGIyMjUsXG4gICdibGFrZTJiLTMwNCc6IDB4YjIyNixcbiAgJ2JsYWtlMmItMzEyJzogMHhiMjI3LFxuICAnYmxha2UyYi0zMjAnOiAweGIyMjgsXG4gICdibGFrZTJiLTMyOCc6IDB4YjIyOSxcbiAgJ2JsYWtlMmItMzM2JzogMHhiMjJhLFxuICAnYmxha2UyYi0zNDQnOiAweGIyMmIsXG4gICdibGFrZTJiLTM1Mic6IDB4YjIyYyxcbiAgJ2JsYWtlMmItMzYwJzogMHhiMjJkLFxuICAnYmxha2UyYi0zNjgnOiAweGIyMmUsXG4gICdibGFrZTJiLTM3Nic6IDB4YjIyZixcbiAgJ2JsYWtlMmItMzg0JzogMHhiMjMwLFxuICAnYmxha2UyYi0zOTInOiAweGIyMzEsXG4gICdibGFrZTJiLTQwMCc6IDB4YjIzMixcbiAgJ2JsYWtlMmItNDA4JzogMHhiMjMzLFxuICAnYmxha2UyYi00MTYnOiAweGIyMzQsXG4gICdibGFrZTJiLTQyNCc6IDB4YjIzNSxcbiAgJ2JsYWtlMmItNDMyJzogMHhiMjM2LFxuICAnYmxha2UyYi00NDAnOiAweGIyMzcsXG4gICdibGFrZTJiLTQ0OCc6IDB4YjIzOCxcbiAgJ2JsYWtlMmItNDU2JzogMHhiMjM5LFxuICAnYmxha2UyYi00NjQnOiAweGIyM2EsXG4gICdibGFrZTJiLTQ3Mic6IDB4YjIzYixcbiAgJ2JsYWtlMmItNDgwJzogMHhiMjNjLFxuICAnYmxha2UyYi00ODgnOiAweGIyM2QsXG4gICdibGFrZTJiLTQ5Nic6IDB4YjIzZSxcbiAgJ2JsYWtlMmItNTA0JzogMHhiMjNmLFxuICAnYmxha2UyYi01MTInOiAweGIyNDAsXG4gICdibGFrZTJzLTgnOiAweGIyNDEsXG4gICdibGFrZTJzLTE2JzogMHhiMjQyLFxuICAnYmxha2Uycy0yNCc6IDB4YjI0MyxcbiAgJ2JsYWtlMnMtMzInOiAweGIyNDQsXG4gICdibGFrZTJzLTQwJzogMHhiMjQ1LFxuICAnYmxha2Uycy00OCc6IDB4YjI0NixcbiAgJ2JsYWtlMnMtNTYnOiAweGIyNDcsXG4gICdibGFrZTJzLTY0JzogMHhiMjQ4LFxuICAnYmxha2Uycy03Mic6IDB4YjI0OSxcbiAgJ2JsYWtlMnMtODAnOiAweGIyNGEsXG4gICdibGFrZTJzLTg4JzogMHhiMjRiLFxuICAnYmxha2Uycy05Nic6IDB4YjI0YyxcbiAgJ2JsYWtlMnMtMTA0JzogMHhiMjRkLFxuICAnYmxha2Uycy0xMTInOiAweGIyNGUsXG4gICdibGFrZTJzLTEyMCc6IDB4YjI0ZixcbiAgJ2JsYWtlMnMtMTI4JzogMHhiMjUwLFxuICAnYmxha2Uycy0xMzYnOiAweGIyNTEsXG4gICdibGFrZTJzLTE0NCc6IDB4YjI1MixcbiAgJ2JsYWtlMnMtMTUyJzogMHhiMjUzLFxuICAnYmxha2Uycy0xNjAnOiAweGIyNTQsXG4gICdibGFrZTJzLTE2OCc6IDB4YjI1NSxcbiAgJ2JsYWtlMnMtMTc2JzogMHhiMjU2LFxuICAnYmxha2Uycy0xODQnOiAweGIyNTcsXG4gICdibGFrZTJzLTE5Mic6IDB4YjI1OCxcbiAgJ2JsYWtlMnMtMjAwJzogMHhiMjU5LFxuICAnYmxha2Uycy0yMDgnOiAweGIyNWEsXG4gICdibGFrZTJzLTIxNic6IDB4YjI1YixcbiAgJ2JsYWtlMnMtMjI0JzogMHhiMjVjLFxuICAnYmxha2Uycy0yMzInOiAweGIyNWQsXG4gICdibGFrZTJzLTI0MCc6IDB4YjI1ZSxcbiAgJ2JsYWtlMnMtMjQ4JzogMHhiMjVmLFxuICAnYmxha2Uycy0yNTYnOiAweGIyNjAsXG4gICdza2VpbjI1Ni04JzogMHhiMzAxLFxuICAnc2tlaW4yNTYtMTYnOiAweGIzMDIsXG4gICdza2VpbjI1Ni0yNCc6IDB4YjMwMyxcbiAgJ3NrZWluMjU2LTMyJzogMHhiMzA0LFxuICAnc2tlaW4yNTYtNDAnOiAweGIzMDUsXG4gICdza2VpbjI1Ni00OCc6IDB4YjMwNixcbiAgJ3NrZWluMjU2LTU2JzogMHhiMzA3LFxuICAnc2tlaW4yNTYtNjQnOiAweGIzMDgsXG4gICdza2VpbjI1Ni03Mic6IDB4YjMwOSxcbiAgJ3NrZWluMjU2LTgwJzogMHhiMzBhLFxuICAnc2tlaW4yNTYtODgnOiAweGIzMGIsXG4gICdza2VpbjI1Ni05Nic6IDB4YjMwYyxcbiAgJ3NrZWluMjU2LTEwNCc6IDB4YjMwZCxcbiAgJ3NrZWluMjU2LTExMic6IDB4YjMwZSxcbiAgJ3NrZWluMjU2LTEyMCc6IDB4YjMwZixcbiAgJ3NrZWluMjU2LTEyOCc6IDB4YjMxMCxcbiAgJ3NrZWluMjU2LTEzNic6IDB4YjMxMSxcbiAgJ3NrZWluMjU2LTE0NCc6IDB4YjMxMixcbiAgJ3NrZWluMjU2LTE1Mic6IDB4YjMxMyxcbiAgJ3NrZWluMjU2LTE2MCc6IDB4YjMxNCxcbiAgJ3NrZWluMjU2LTE2OCc6IDB4YjMxNSxcbiAgJ3NrZWluMjU2LTE3Nic6IDB4YjMxNixcbiAgJ3NrZWluMjU2LTE4NCc6IDB4YjMxNyxcbiAgJ3NrZWluMjU2LTE5Mic6IDB4YjMxOCxcbiAgJ3NrZWluMjU2LTIwMCc6IDB4YjMxOSxcbiAgJ3NrZWluMjU2LTIwOCc6IDB4YjMxYSxcbiAgJ3NrZWluMjU2LTIxNic6IDB4YjMxYixcbiAgJ3NrZWluMjU2LTIyNCc6IDB4YjMxYyxcbiAgJ3NrZWluMjU2LTIzMic6IDB4YjMxZCxcbiAgJ3NrZWluMjU2LTI0MCc6IDB4YjMxZSxcbiAgJ3NrZWluMjU2LTI0OCc6IDB4YjMxZixcbiAgJ3NrZWluMjU2LTI1Nic6IDB4YjMyMCxcbiAgJ3NrZWluNTEyLTgnOiAweGIzMjEsXG4gICdza2VpbjUxMi0xNic6IDB4YjMyMixcbiAgJ3NrZWluNTEyLTI0JzogMHhiMzIzLFxuICAnc2tlaW41MTItMzInOiAweGIzMjQsXG4gICdza2VpbjUxMi00MCc6IDB4YjMyNSxcbiAgJ3NrZWluNTEyLTQ4JzogMHhiMzI2LFxuICAnc2tlaW41MTItNTYnOiAweGIzMjcsXG4gICdza2VpbjUxMi02NCc6IDB4YjMyOCxcbiAgJ3NrZWluNTEyLTcyJzogMHhiMzI5LFxuICAnc2tlaW41MTItODAnOiAweGIzMmEsXG4gICdza2VpbjUxMi04OCc6IDB4YjMyYixcbiAgJ3NrZWluNTEyLTk2JzogMHhiMzJjLFxuICAnc2tlaW41MTItMTA0JzogMHhiMzJkLFxuICAnc2tlaW41MTItMTEyJzogMHhiMzJlLFxuICAnc2tlaW41MTItMTIwJzogMHhiMzJmLFxuICAnc2tlaW41MTItMTI4JzogMHhiMzMwLFxuICAnc2tlaW41MTItMTM2JzogMHhiMzMxLFxuICAnc2tlaW41MTItMTQ0JzogMHhiMzMyLFxuICAnc2tlaW41MTItMTUyJzogMHhiMzMzLFxuICAnc2tlaW41MTItMTYwJzogMHhiMzM0LFxuICAnc2tlaW41MTItMTY4JzogMHhiMzM1LFxuICAnc2tlaW41MTItMTc2JzogMHhiMzM2LFxuICAnc2tlaW41MTItMTg0JzogMHhiMzM3LFxuICAnc2tlaW41MTItMTkyJzogMHhiMzM4LFxuICAnc2tlaW41MTItMjAwJzogMHhiMzM5LFxuICAnc2tlaW41MTItMjA4JzogMHhiMzNhLFxuICAnc2tlaW41MTItMjE2JzogMHhiMzNiLFxuICAnc2tlaW41MTItMjI0JzogMHhiMzNjLFxuICAnc2tlaW41MTItMjMyJzogMHhiMzNkLFxuICAnc2tlaW41MTItMjQwJzogMHhiMzNlLFxuICAnc2tlaW41MTItMjQ4JzogMHhiMzNmLFxuICAnc2tlaW41MTItMjU2JzogMHhiMzQwLFxuICAnc2tlaW41MTItMjY0JzogMHhiMzQxLFxuICAnc2tlaW41MTItMjcyJzogMHhiMzQyLFxuICAnc2tlaW41MTItMjgwJzogMHhiMzQzLFxuICAnc2tlaW41MTItMjg4JzogMHhiMzQ0LFxuICAnc2tlaW41MTItMjk2JzogMHhiMzQ1LFxuICAnc2tlaW41MTItMzA0JzogMHhiMzQ2LFxuICAnc2tlaW41MTItMzEyJzogMHhiMzQ3LFxuICAnc2tlaW41MTItMzIwJzogMHhiMzQ4LFxuICAnc2tlaW41MTItMzI4JzogMHhiMzQ5LFxuICAnc2tlaW41MTItMzM2JzogMHhiMzRhLFxuICAnc2tlaW41MTItMzQ0JzogMHhiMzRiLFxuICAnc2tlaW41MTItMzUyJzogMHhiMzRjLFxuICAnc2tlaW41MTItMzYwJzogMHhiMzRkLFxuICAnc2tlaW41MTItMzY4JzogMHhiMzRlLFxuICAnc2tlaW41MTItMzc2JzogMHhiMzRmLFxuICAnc2tlaW41MTItMzg0JzogMHhiMzUwLFxuICAnc2tlaW41MTItMzkyJzogMHhiMzUxLFxuICAnc2tlaW41MTItNDAwJzogMHhiMzUyLFxuICAnc2tlaW41MTItNDA4JzogMHhiMzUzLFxuICAnc2tlaW41MTItNDE2JzogMHhiMzU0LFxuICAnc2tlaW41MTItNDI0JzogMHhiMzU1LFxuICAnc2tlaW41MTItNDMyJzogMHhiMzU2LFxuICAnc2tlaW41MTItNDQwJzogMHhiMzU3LFxuICAnc2tlaW41MTItNDQ4JzogMHhiMzU4LFxuICAnc2tlaW41MTItNDU2JzogMHhiMzU5LFxuICAnc2tlaW41MTItNDY0JzogMHhiMzVhLFxuICAnc2tlaW41MTItNDcyJzogMHhiMzViLFxuICAnc2tlaW41MTItNDgwJzogMHhiMzVjLFxuICAnc2tlaW41MTItNDg4JzogMHhiMzVkLFxuICAnc2tlaW41MTItNDk2JzogMHhiMzVlLFxuICAnc2tlaW41MTItNTA0JzogMHhiMzVmLFxuICAnc2tlaW41MTItNTEyJzogMHhiMzYwLFxuICAnc2tlaW4xMDI0LTgnOiAweGIzNjEsXG4gICdza2VpbjEwMjQtMTYnOiAweGIzNjIsXG4gICdza2VpbjEwMjQtMjQnOiAweGIzNjMsXG4gICdza2VpbjEwMjQtMzInOiAweGIzNjQsXG4gICdza2VpbjEwMjQtNDAnOiAweGIzNjUsXG4gICdza2VpbjEwMjQtNDgnOiAweGIzNjYsXG4gICdza2VpbjEwMjQtNTYnOiAweGIzNjcsXG4gICdza2VpbjEwMjQtNjQnOiAweGIzNjgsXG4gICdza2VpbjEwMjQtNzInOiAweGIzNjksXG4gICdza2VpbjEwMjQtODAnOiAweGIzNmEsXG4gICdza2VpbjEwMjQtODgnOiAweGIzNmIsXG4gICdza2VpbjEwMjQtOTYnOiAweGIzNmMsXG4gICdza2VpbjEwMjQtMTA0JzogMHhiMzZkLFxuICAnc2tlaW4xMDI0LTExMic6IDB4YjM2ZSxcbiAgJ3NrZWluMTAyNC0xMjAnOiAweGIzNmYsXG4gICdza2VpbjEwMjQtMTI4JzogMHhiMzcwLFxuICAnc2tlaW4xMDI0LTEzNic6IDB4YjM3MSxcbiAgJ3NrZWluMTAyNC0xNDQnOiAweGIzNzIsXG4gICdza2VpbjEwMjQtMTUyJzogMHhiMzczLFxuICAnc2tlaW4xMDI0LTE2MCc6IDB4YjM3NCxcbiAgJ3NrZWluMTAyNC0xNjgnOiAweGIzNzUsXG4gICdza2VpbjEwMjQtMTc2JzogMHhiMzc2LFxuICAnc2tlaW4xMDI0LTE4NCc6IDB4YjM3NyxcbiAgJ3NrZWluMTAyNC0xOTInOiAweGIzNzgsXG4gICdza2VpbjEwMjQtMjAwJzogMHhiMzc5LFxuICAnc2tlaW4xMDI0LTIwOCc6IDB4YjM3YSxcbiAgJ3NrZWluMTAyNC0yMTYnOiAweGIzN2IsXG4gICdza2VpbjEwMjQtMjI0JzogMHhiMzdjLFxuICAnc2tlaW4xMDI0LTIzMic6IDB4YjM3ZCxcbiAgJ3NrZWluMTAyNC0yNDAnOiAweGIzN2UsXG4gICdza2VpbjEwMjQtMjQ4JzogMHhiMzdmLFxuICAnc2tlaW4xMDI0LTI1Nic6IDB4YjM4MCxcbiAgJ3NrZWluMTAyNC0yNjQnOiAweGIzODEsXG4gICdza2VpbjEwMjQtMjcyJzogMHhiMzgyLFxuICAnc2tlaW4xMDI0LTI4MCc6IDB4YjM4MyxcbiAgJ3NrZWluMTAyNC0yODgnOiAweGIzODQsXG4gICdza2VpbjEwMjQtMjk2JzogMHhiMzg1LFxuICAnc2tlaW4xMDI0LTMwNCc6IDB4YjM4NixcbiAgJ3NrZWluMTAyNC0zMTInOiAweGIzODcsXG4gICdza2VpbjEwMjQtMzIwJzogMHhiMzg4LFxuICAnc2tlaW4xMDI0LTMyOCc6IDB4YjM4OSxcbiAgJ3NrZWluMTAyNC0zMzYnOiAweGIzOGEsXG4gICdza2VpbjEwMjQtMzQ0JzogMHhiMzhiLFxuICAnc2tlaW4xMDI0LTM1Mic6IDB4YjM4YyxcbiAgJ3NrZWluMTAyNC0zNjAnOiAweGIzOGQsXG4gICdza2VpbjEwMjQtMzY4JzogMHhiMzhlLFxuICAnc2tlaW4xMDI0LTM3Nic6IDB4YjM4ZixcbiAgJ3NrZWluMTAyNC0zODQnOiAweGIzOTAsXG4gICdza2VpbjEwMjQtMzkyJzogMHhiMzkxLFxuICAnc2tlaW4xMDI0LTQwMCc6IDB4YjM5MixcbiAgJ3NrZWluMTAyNC00MDgnOiAweGIzOTMsXG4gICdza2VpbjEwMjQtNDE2JzogMHhiMzk0LFxuICAnc2tlaW4xMDI0LTQyNCc6IDB4YjM5NSxcbiAgJ3NrZWluMTAyNC00MzInOiAweGIzOTYsXG4gICdza2VpbjEwMjQtNDQwJzogMHhiMzk3LFxuICAnc2tlaW4xMDI0LTQ0OCc6IDB4YjM5OCxcbiAgJ3NrZWluMTAyNC00NTYnOiAweGIzOTksXG4gICdza2VpbjEwMjQtNDY0JzogMHhiMzlhLFxuICAnc2tlaW4xMDI0LTQ3Mic6IDB4YjM5YixcbiAgJ3NrZWluMTAyNC00ODAnOiAweGIzOWMsXG4gICdza2VpbjEwMjQtNDg4JzogMHhiMzlkLFxuICAnc2tlaW4xMDI0LTQ5Nic6IDB4YjM5ZSxcbiAgJ3NrZWluMTAyNC01MDQnOiAweGIzOWYsXG4gICdza2VpbjEwMjQtNTEyJzogMHhiM2EwLFxuICAnc2tlaW4xMDI0LTUyMCc6IDB4YjNhMSxcbiAgJ3NrZWluMTAyNC01MjgnOiAweGIzYTIsXG4gICdza2VpbjEwMjQtNTM2JzogMHhiM2EzLFxuICAnc2tlaW4xMDI0LTU0NCc6IDB4YjNhNCxcbiAgJ3NrZWluMTAyNC01NTInOiAweGIzYTUsXG4gICdza2VpbjEwMjQtNTYwJzogMHhiM2E2LFxuICAnc2tlaW4xMDI0LTU2OCc6IDB4YjNhNyxcbiAgJ3NrZWluMTAyNC01NzYnOiAweGIzYTgsXG4gICdza2VpbjEwMjQtNTg0JzogMHhiM2E5LFxuICAnc2tlaW4xMDI0LTU5Mic6IDB4YjNhYSxcbiAgJ3NrZWluMTAyNC02MDAnOiAweGIzYWIsXG4gICdza2VpbjEwMjQtNjA4JzogMHhiM2FjLFxuICAnc2tlaW4xMDI0LTYxNic6IDB4YjNhZCxcbiAgJ3NrZWluMTAyNC02MjQnOiAweGIzYWUsXG4gICdza2VpbjEwMjQtNjMyJzogMHhiM2FmLFxuICAnc2tlaW4xMDI0LTY0MCc6IDB4YjNiMCxcbiAgJ3NrZWluMTAyNC02NDgnOiAweGIzYjEsXG4gICdza2VpbjEwMjQtNjU2JzogMHhiM2IyLFxuICAnc2tlaW4xMDI0LTY2NCc6IDB4YjNiMyxcbiAgJ3NrZWluMTAyNC02NzInOiAweGIzYjQsXG4gICdza2VpbjEwMjQtNjgwJzogMHhiM2I1LFxuICAnc2tlaW4xMDI0LTY4OCc6IDB4YjNiNixcbiAgJ3NrZWluMTAyNC02OTYnOiAweGIzYjcsXG4gICdza2VpbjEwMjQtNzA0JzogMHhiM2I4LFxuICAnc2tlaW4xMDI0LTcxMic6IDB4YjNiOSxcbiAgJ3NrZWluMTAyNC03MjAnOiAweGIzYmEsXG4gICdza2VpbjEwMjQtNzI4JzogMHhiM2JiLFxuICAnc2tlaW4xMDI0LTczNic6IDB4YjNiYyxcbiAgJ3NrZWluMTAyNC03NDQnOiAweGIzYmQsXG4gICdza2VpbjEwMjQtNzUyJzogMHhiM2JlLFxuICAnc2tlaW4xMDI0LTc2MCc6IDB4YjNiZixcbiAgJ3NrZWluMTAyNC03NjgnOiAweGIzYzAsXG4gICdza2VpbjEwMjQtNzc2JzogMHhiM2MxLFxuICAnc2tlaW4xMDI0LTc4NCc6IDB4YjNjMixcbiAgJ3NrZWluMTAyNC03OTInOiAweGIzYzMsXG4gICdza2VpbjEwMjQtODAwJzogMHhiM2M0LFxuICAnc2tlaW4xMDI0LTgwOCc6IDB4YjNjNSxcbiAgJ3NrZWluMTAyNC04MTYnOiAweGIzYzYsXG4gICdza2VpbjEwMjQtODI0JzogMHhiM2M3LFxuICAnc2tlaW4xMDI0LTgzMic6IDB4YjNjOCxcbiAgJ3NrZWluMTAyNC04NDAnOiAweGIzYzksXG4gICdza2VpbjEwMjQtODQ4JzogMHhiM2NhLFxuICAnc2tlaW4xMDI0LTg1Nic6IDB4YjNjYixcbiAgJ3NrZWluMTAyNC04NjQnOiAweGIzY2MsXG4gICdza2VpbjEwMjQtODcyJzogMHhiM2NkLFxuICAnc2tlaW4xMDI0LTg4MCc6IDB4YjNjZSxcbiAgJ3NrZWluMTAyNC04ODgnOiAweGIzY2YsXG4gICdza2VpbjEwMjQtODk2JzogMHhiM2QwLFxuICAnc2tlaW4xMDI0LTkwNCc6IDB4YjNkMSxcbiAgJ3NrZWluMTAyNC05MTInOiAweGIzZDIsXG4gICdza2VpbjEwMjQtOTIwJzogMHhiM2QzLFxuICAnc2tlaW4xMDI0LTkyOCc6IDB4YjNkNCxcbiAgJ3NrZWluMTAyNC05MzYnOiAweGIzZDUsXG4gICdza2VpbjEwMjQtOTQ0JzogMHhiM2Q2LFxuICAnc2tlaW4xMDI0LTk1Mic6IDB4YjNkNyxcbiAgJ3NrZWluMTAyNC05NjAnOiAweGIzZDgsXG4gICdza2VpbjEwMjQtOTY4JzogMHhiM2Q5LFxuICAnc2tlaW4xMDI0LTk3Nic6IDB4YjNkYSxcbiAgJ3NrZWluMTAyNC05ODQnOiAweGIzZGIsXG4gICdza2VpbjEwMjQtOTkyJzogMHhiM2RjLFxuICAnc2tlaW4xMDI0LTEwMDAnOiAweGIzZGQsXG4gICdza2VpbjEwMjQtMTAwOCc6IDB4YjNkZSxcbiAgJ3NrZWluMTAyNC0xMDE2JzogMHhiM2RmLFxuICAnc2tlaW4xMDI0LTEwMjQnOiAweGIzZTAsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxJzogMHhiNDAxLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMS1zYyc6IDB4YjQwMixcbiAgJ3plcm94Y2VydC1pbXByaW50LTI1Nic6IDB4Y2UxMSxcbiAgJ2ZpbC1jb21taXRtZW50LXVuc2VhbGVkJzogMHhmMTAxLFxuICAnZmlsLWNvbW1pdG1lbnQtc2VhbGVkJzogMHhmMTAyLFxuICAnaG9sb2NoYWluLWFkci12MCc6IDB4ODA3MTI0LFxuICAnaG9sb2NoYWluLWFkci12MSc6IDB4ODE3MTI0LFxuICAnaG9sb2NoYWluLWtleS12MCc6IDB4OTQ3MTI0LFxuICAnaG9sb2NoYWluLWtleS12MSc6IDB4OTU3MTI0LFxuICAnaG9sb2NoYWluLXNpZy12MCc6IDB4YTI3MTI0LFxuICAnaG9sb2NoYWluLXNpZy12MSc6IDB4YTM3MTI0LFxuICAnc2t5bmV0LW5zJzogMHhiMTk5MTBcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBiYXNlVGFibGUgfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db25zdGFudE51bWJlck1hcH0gQ29uc3RhbnROdW1iZXJNYXAgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbmNvbnN0IGNvbnN0YW50cyA9IC8qKiBAdHlwZSB7Q29uc3RhbnROdW1iZXJNYXB9ICovKHt9KVxuXG5mb3IgKGNvbnN0IFtuYW1lLCBjb2RlXSBvZiBPYmplY3QuZW50cmllcyhiYXNlVGFibGUpKSB7XG4gIGNvbnN0IGNvbnN0YW50ID0gbmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKVxuICBjb25zdGFudHNbY29uc3RhbnRdID0gY29kZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoY29uc3RhbnRzKVxuIiwiLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbXVsdGljb2RlYyBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBtb2R1bGUgbXVsdGljb2RlY1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbiAqXG4gKiBjb25zdCBwcmVmaXhlZFByb3RvYnVmID0gbXVsdGljb2RlYy5hZGRQcmVmaXgoJ3Byb3RvYnVmJywgcHJvdG9idWZCdWZmZXIpXG4gKiAvLyBwcmVmaXhlZFByb3RvYnVmIDB4NTAuLi5cbiAqXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY051bWJlcn0gQ29kZWNOdW1iZXIgKi9cblxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IGludFRhYmxlID0gcmVxdWlyZSgnLi9pbnQtdGFibGUnKVxuY29uc3QgY29kZWNOYW1lVG9Db2RlVmFyaW50ID0gcmVxdWlyZSgnLi92YXJpbnQtdGFibGUnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB1aW50OEFycmF5Q29uY2F0ID0gcmVxdWlyZSgndWludDhhcnJheXMvY29uY2F0JylcblxuLyoqXG4gKiBQcmVmaXggYSBidWZmZXIgd2l0aCBhIG11bHRpY29kZWMtcGFja2VkLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfFVpbnQ4QXJyYXl9IG11bHRpY29kZWNTdHJPckNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGFkZFByZWZpeCAobXVsdGljb2RlY1N0ck9yQ29kZSwgZGF0YSkge1xuICBsZXQgcHJlZml4XG5cbiAgaWYgKG11bHRpY29kZWNTdHJPckNvZGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcHJlZml4ID0gdXRpbC52YXJpbnRVaW50OEFycmF5RW5jb2RlKG11bHRpY29kZWNTdHJPckNvZGUpXG4gIH0gZWxzZSB7XG4gICAgaWYgKGNvZGVjTmFtZVRvQ29kZVZhcmludFttdWx0aWNvZGVjU3RyT3JDb2RlXSkge1xuICAgICAgcHJlZml4ID0gY29kZWNOYW1lVG9Db2RlVmFyaW50W211bHRpY29kZWNTdHJPckNvZGVdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGljb2RlYyBub3QgcmVjb2duaXplZCcpXG4gICAgfVxuICB9XG4gIHJldHVybiB1aW50OEFycmF5Q29uY2F0KFtwcmVmaXgsIGRhdGFdLCBwcmVmaXgubGVuZ3RoICsgZGF0YS5sZW5ndGgpXG59XG5cbi8qKlxuICogRGVjYXBzdWxhdGUgdGhlIG11bHRpY29kZWMtcGFja2VkIHByZWZpeCBmcm9tIHRoZSBkYXRhLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJtUHJlZml4IChkYXRhKSB7XG4gIHZhcmludC5kZWNvZGUoZGF0YSlcbiAgcmV0dXJuIGRhdGEuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGVjIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcHJlZml4ZWREYXRhXG4gKiBAcmV0dXJucyB7Q29kZWNOYW1lfVxuICovXG5mdW5jdGlvbiBnZXRDb2RlYyAocHJlZml4ZWREYXRhKSB7XG4gIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKHByZWZpeGVkRGF0YSlcbiAgY29uc3QgY29kZWNOYW1lID0gaW50VGFibGUuZ2V0KGNvZGUpXG4gIGlmIChjb2RlY05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29kZSAke2NvZGV9IG5vdCBmb3VuZGApXG4gIH1cbiAgcmV0dXJuIGNvZGVjTmFtZVxufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29kZWMuXG4gKlxuICogQHBhcmFtIHtDb2RlY051bWJlcn0gY29kZWNcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBnZXROYW1lIChjb2RlYykge1xuICByZXR1cm4gaW50VGFibGUuZ2V0KGNvZGVjKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgY29kZWNcbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gbmFtZVxuICogQHJldHVybnMge0NvZGVjTnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXROdW1iZXIgKG5hbWUpIHtcbiAgY29uc3QgY29kZSA9IGNvZGVjTmFtZVRvQ29kZVZhcmludFtuYW1lXVxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlYyBgJyArIG5hbWUgKyAnYCBub3QgZm91bmQnKVxuICB9XG4gIHJldHVybiB2YXJpbnQuZGVjb2RlKGNvZGUpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcHJlZml4ZWREYXRhXG4gKiBAcmV0dXJucyB7Q29kZWNOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGUgKHByZWZpeGVkRGF0YSkge1xuICByZXR1cm4gdmFyaW50LmRlY29kZShwcmVmaXhlZERhdGEpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIGFzIHZhcmludCBvZiBhIGNvZGVjIG5hbWUuXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV9IGNvZGVjTmFtZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVWYXJpbnQgKGNvZGVjTmFtZSkge1xuICBjb25zdCBjb2RlID0gY29kZWNOYW1lVG9Db2RlVmFyaW50W2NvZGVjTmFtZV1cbiAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29kZWMgYCcgKyBjb2RlY05hbWUgKyAnYCBub3QgZm91bmQnKVxuICB9XG4gIHJldHVybiBjb2RlXG59XG5cbi8qKlxuICogR2V0IHRoZSB2YXJpbnQgb2YgYSBjb2RlLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOdW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuZnVuY3Rpb24gZ2V0VmFyaW50IChjb2RlKSB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RlKGNvZGUpXG59XG5cbi8vIE1ha2UgdGhlIGNvbnN0YW50cyB0b3AtbGV2ZWwgY29uc3RhbnRzXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbi8vIEh1bWFuIGZyaWVuZGx5IG5hbWVzIGZvciBwcmludGluZywgZS5nLiBpbiBlcnJvciBtZXNzYWdlc1xuY29uc3QgcHJpbnQgPSByZXF1aXJlKCcuL3ByaW50JylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFByZWZpeCxcbiAgcm1QcmVmaXgsXG4gIGdldENvZGVjLFxuICBnZXROYW1lLFxuICBnZXROdW1iZXIsXG4gIGdldENvZGUsXG4gIGdldENvZGVWYXJpbnQsXG4gIGdldFZhcmludCxcbiAgcHJpbnQsXG4gIC4uLmNvbnN0YW50c1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTnVtYmVyfSBDb2RlY051bWJlciAqL1xuXG5jb25zdCB7IGJhc2VUYWJsZSB9ID0gcmVxdWlyZSgnLi9iYXNlLXRhYmxlJylcblxuLyoqXG4gKiBAdHlwZSB7TWFwPENvZGVjTnVtYmVyLENvZGVjTmFtZT59XG4gKi9cbmNvbnN0IG5hbWVUYWJsZSA9IG5ldyBNYXAoKVxuXG5mb3IgKGNvbnN0IGVuY29kaW5nTmFtZSBpbiBiYXNlVGFibGUpIHtcbiAgY29uc3QgY29kZSA9IGJhc2VUYWJsZVtlbmNvZGluZ05hbWVdXG4gIG5hbWVUYWJsZS5zZXQoY29kZSwgLyoqIEB0eXBlIHtDb2RlY05hbWV9ICovKGVuY29kaW5nTmFtZSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShuYW1lVGFibGUpXG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTmFtZX0gQ29kZWNOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuTnVtYmVyTmFtZU1hcH0gTnVtYmVyTmFtZU1hcCAqL1xuXG5jb25zdCB7IGJhc2VUYWJsZSB9ID0gcmVxdWlyZSgnLi9iYXNlLXRhYmxlJylcblxuY29uc3QgdGFibGVCeUNvZGUgPSAvKiogQHR5cGUge051bWJlck5hbWVNYXB9ICovKHt9KVxuXG5mb3IgKGNvbnN0IFtuYW1lLCBjb2RlXSBvZiBPYmplY3QuZW50cmllcyhiYXNlVGFibGUpKSB7XG4gIGlmICh0YWJsZUJ5Q29kZVtjb2RlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGFibGVCeUNvZGVbY29kZV0gPSAvKiogQHR5cGUge0NvZGVjTmFtZX0gKiovKG5hbWUpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAvKiogQHR5cGUge051bWJlck5hbWVNYXB9ICovKE9iamVjdC5mcmVlemUodGFibGVCeUNvZGUpKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCB1aW50OEFycmF5VG9TdHJpbmcgPSByZXF1aXJlKCd1aW50OGFycmF5cy90by1zdHJpbmcnKVxuY29uc3QgdWludDhBcnJheUZyb21TdHJpbmcgPSByZXF1aXJlKCd1aW50OGFycmF5cy9mcm9tLXN0cmluZycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBudW1iZXJUb1VpbnQ4QXJyYXksXG4gIHVpbnQ4QXJyYXlUb051bWJlcixcbiAgdmFyaW50VWludDhBcnJheUVuY29kZSxcbiAgdmFyaW50RW5jb2RlXG59XG5cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb051bWJlciAoYnVmKSB7XG4gIHJldHVybiBwYXJzZUludCh1aW50OEFycmF5VG9TdHJpbmcoYnVmLCAnYmFzZTE2JyksIDE2KVxufVxuXG5mdW5jdGlvbiBudW1iZXJUb1VpbnQ4QXJyYXkgKG51bSkge1xuICBsZXQgaGV4U3RyaW5nID0gbnVtLnRvU3RyaW5nKDE2KVxuICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICBoZXhTdHJpbmcgPSAnMCcgKyBoZXhTdHJpbmdcbiAgfVxuICByZXR1cm4gdWludDhBcnJheUZyb21TdHJpbmcoaGV4U3RyaW5nLCAnYmFzZTE2Jylcbn1cblxuZnVuY3Rpb24gdmFyaW50VWludDhBcnJheUVuY29kZSAoaW5wdXQpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh2YXJpbnQuZW5jb2RlKHVpbnQ4QXJyYXlUb051bWJlcihpbnB1dCkpKVxufVxuXG5mdW5jdGlvbiB2YXJpbnRFbmNvZGUgKG51bSkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUobnVtKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuTmFtZVVpbnQ4QXJyYXlNYXB9IE5hbWVVaW50OEFycmF5TWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuY29uc3QgdmFyaW50RW5jb2RlID0gcmVxdWlyZSgnLi91dGlsJykudmFyaW50RW5jb2RlXG5cbmNvbnN0IHZhcmludFRhYmxlID0gLyoqIEB0eXBlIHtOYW1lVWludDhBcnJheU1hcH0gKi8gKHt9KVxuXG5mb3IgKGNvbnN0IGVuY29kaW5nTmFtZSBpbiBiYXNlVGFibGUpIHtcbiAgY29uc3QgY29kZSA9IGJhc2VUYWJsZVtlbmNvZGluZ05hbWVdXG4gIHZhcmludFRhYmxlW2VuY29kaW5nTmFtZV0gPSB2YXJpbnRFbmNvZGUoY29kZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHZhcmludFRhYmxlKVxuIiwiLy8gQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvZGVjXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKFVpbnQ4QXJyYXkpOnN0cmluZ30gZW5jb2RlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHN0cmluZyk6VWludDhBcnJheX0gZGVjb2RlXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKHN0cmluZyk6Q29kZWN9IENvZGVjRmFjdG9yeVxuICovXG5cbmNsYXNzIEJhc2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICogQHBhcmFtIHtDb2RlY0ZhY3Rvcnl9IGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgdGhpcy5jb2RlQnVmID0gQnVmZmVyLmZyb20odGhpcy5jb2RlKVxuICAgIHRoaXMuYWxwaGFiZXQgPSBhbHBoYWJldFxuICAgIHRoaXMuZW5naW5lID0gaW1wbGVtZW50YXRpb24oYWxwaGFiZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuY29kZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5naW5lLmVuY29kZShidWYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgZm9yIChjb25zdCBjaGFyIG9mIHN0cmluZykge1xuICAgICAgaWYgKHRoaXMuYWxwaGFiZXQgJiYgdGhpcy5hbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY2hhcmFjdGVyICcke2NoYXJ9JyBpbiAnJHtzdHJpbmd9J2ApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZ2luZS5kZWNvZGUoc3RyaW5nKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVxuIiwiLy8gQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZVggPSByZXF1aXJlKCdiYXNlLXgnKVxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpXG5jb25zdCByZmM0NjQ4ID0gcmVxdWlyZSgnLi9yZmM0NjQ4JylcbmNvbnN0IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuY29uc3QgaWRlbnRpdHkgPSAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBkZWNvZGVUZXh0LFxuICAgIGRlY29kZTogZW5jb2RlVGV4dFxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge19faW1wb3J0X18oJy4vYmFzZScpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5XG4gKlxuICogbmFtZSwgY29kZSwgaW1wbGVtZW50YXRpb24sIGFscGhhYmV0XG4gKiBAdHlwZSB7QXJyYXk8W3N0cmluZywgc3RyaW5nLCBDb2RlY0ZhY3RvcnksIHN0cmluZ10+fVxuICovXG5jb25zdCBjb25zdGFudHMgPSBbXG4gIFsnaWRlbnRpdHknLCAnXFx4MDAnLCBpZGVudGl0eSwgJyddLFxuICBbJ2Jhc2UyJywgJzAnLCByZmM0NjQ4KDEpLCAnMDEnXSxcbiAgWydiYXNlOCcsICc3JywgcmZjNDY0OCgzKSwgJzAxMjM0NTY3J10sXG4gIFsnYmFzZTEwJywgJzknLCBiYXNlWCwgJzAxMjM0NTY3ODknXSxcbiAgWydiYXNlMTYnLCAnZicsIHJmYzQ2NDgoNCksICcwMTIzNDU2Nzg5YWJjZGVmJ10sXG4gIFsnYmFzZTE2dXBwZXInLCAnRicsIHJmYzQ2NDgoNCksICcwMTIzNDU2Nzg5QUJDREVGJ10sXG4gIFsnYmFzZTMyaGV4JywgJ3YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnXSxcbiAgWydiYXNlMzJoZXh1cHBlcicsICdWJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJ10sXG4gIFsnYmFzZTMyaGV4cGFkJywgJ3QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9J10sXG4gIFsnYmFzZTMyaGV4cGFkdXBwZXInLCAnVCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj0nXSxcbiAgWydiYXNlMzInLCAnYicsIHJmYzQ2NDgoNSksICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2NyddLFxuICBbJ2Jhc2UzMnVwcGVyJywgJ0InLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnXSxcbiAgWydiYXNlMzJwYWQnLCAnYycsIHJmYzQ2NDgoNSksICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nXSxcbiAgWydiYXNlMzJwYWR1cHBlcicsICdDJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PSddLFxuICBbJ2Jhc2UzMnonLCAnaCcsIHJmYzQ2NDgoNSksICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OSddLFxuICBbJ2Jhc2UzNicsICdrJywgYmFzZVgsICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlMzZ1cHBlcicsICdLJywgYmFzZVgsICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNThidGMnLCAneicsIGJhc2VYLCAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2U1OGZsaWNrcicsICdaJywgYmFzZVgsICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTY0JywgJ20nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLFxuICBbJ2Jhc2U2NHBhZCcsICdNJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J10sXG4gIFsnYmFzZTY0dXJsJywgJ3UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXyddLFxuICBbJ2Jhc2U2NHVybHBhZCcsICdVJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89J11cbl1cblxuY29uc3QgbmFtZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMF1dID0gbmV3IEJhc2UodHVwcGxlWzBdLCB0dXBwbGVbMV0sIHR1cHBsZVsyXSwgdHVwcGxlWzNdKVxuICByZXR1cm4gcHJldlxufSwge30pXG5cbmNvbnN0IGNvZGVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzFdXSA9IG5hbWVzW3R1cHBsZVswXV1cbiAgcmV0dXJuIHByZXZcbn0sIHt9KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZXMsXG4gIGNvZGVzXG59XG4iLCIvLyBAdHMtY2hlY2tcbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFttdWx0aWJhc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGliYXNlKSBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBtb2R1bGUgTXVsdGliYXNlXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgZGVjb2RlVGV4dCwgYXNCdWZmZXIgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vYmFzZVwiKX0gQmFzZSAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBidWZmZXIgd2l0aCB0aGUgbXVsdGliYXNlIHZhcmludCtjb2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgcHJlZml4ZWQgd2l0aCBtdWx0aWJhc2UuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gbXVsdGliYXNlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgaWYgKCFidWYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGFuIGVuY29kZWQgYnVmZmVyJylcbiAgfVxuICBjb25zdCB7IG5hbWUsIGNvZGVCdWYgfSA9IGVuY29kaW5nKG5hbWVPckNvZGUpXG4gIHZhbGlkRW5jb2RlKG5hbWUsIGJ1ZilcblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoY29kZUJ1Zi5sZW5ndGggKyBidWYubGVuZ3RoKVxuICBidWZmZXIuc2V0KGNvZGVCdWYsIDApXG4gIGJ1ZmZlci5zZXQoYnVmLCBjb2RlQnVmLmxlbmd0aClcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCB0aGUgc3BlY2lmaWVkIGJhc2UgYW5kIGFkZCB0aGUgbXVsdGliYXNlIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKG5hbWVPckNvZGUpXG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuYy5jb2RlQnVmLCBCdWZmZXIuZnJvbShlbmMuZW5jb2RlKGJ1ZikpXSlcbn1cblxuLyoqXG4gKiBUYWtlcyBhIFVpbnQ4QXJyYXkgb3Igc3RyaW5nIGVuY29kZWQgd2l0aCBtdWx0aWJhc2UgaGVhZGVyLCBkZWNvZGVzIGl0IGFuZFxuICogcmV0dXJucyB0aGUgZGVjb2RlZCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoZGF0YSkge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuICBjb25zdCBwcmVmaXggPSBkYXRhWzBdXG5cbiAgLy8gTWFrZSBhbGwgZW5jb2RpbmdzIGNhc2UtaW5zZW5zaXRpdmUgZXhjZXB0IHRoZSBvbmVzIHRoYXQgaW5jbHVkZSB1cHBlciBhbmQgbG93ZXIgY2hhcnMgaW4gdGhlIGFscGhhYmV0XG4gIGlmIChbJ2YnLCAnRicsICd2JywgJ1YnLCAndCcsICdUJywgJ2InLCAnQicsICdjJywgJ0MnLCAnaCcsICdrJywgJ0snXS5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgZGF0YSA9IGRhdGEudG9Mb3dlckNhc2UoKVxuICB9XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKGRhdGFbMF0pXG4gIHJldHVybiBhc0J1ZmZlcihlbmMuZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEpKSlcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0YSBtdWx0aWJhc2UgZW5jb2RlZD9cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7ZmFsc2V8c3RyaW5nfVxuICovXG5mdW5jdGlvbiBpc0VuY29kZWQgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuXG4gIC8vIEVuc3VyZSBidWZPclN0cmluZyBpcyBhIHN0cmluZ1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBlbmMgPSBlbmNvZGluZyhkYXRhWzBdKVxuICAgIHJldHVybiBlbmMubmFtZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGVuY29kZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiB2YWxpZEVuY29kZSAobmFtZSwgYnVmKSB7XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKG5hbWUpXG4gIGVuYy5kZWNvZGUoZGVjb2RlVGV4dChidWYpKVxufVxuXG4vKipcbiAqIEdldCB0aGUgZW5jb2RpbmcgYnkgbmFtZSBvciBjb2RlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlXG4gKiBAcmV0dXJucyB7QmFzZX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGVuY29kaW5nIChuYW1lT3JDb2RlKSB7XG4gIGlmIChjb25zdGFudHMubmFtZXNbbmFtZU9yQ29kZV0pIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLm5hbWVzW25hbWVPckNvZGVdXG4gIH0gZWxzZSBpZiAoY29uc3RhbnRzLmNvZGVzW25hbWVPckNvZGVdKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5jb2Rlc1tuYW1lT3JDb2RlXVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7bmFtZU9yQ29kZX1gKVxuICB9XG59XG5cbi8qKlxuICogR2V0IGVuY29kaW5nIGZyb20gZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtCYXNlfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RpbmdGcm9tRGF0YSAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5nKGRhdGFbMF0pXG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG11bHRpYmFzZVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlXG5leHBvcnRzLmlzRW5jb2RlZCA9IGlzRW5jb2RlZFxuZXhwb3J0cy5lbmNvZGluZyA9IGVuY29kaW5nXG5leHBvcnRzLmVuY29kaW5nRnJvbURhdGEgPSBlbmNvZGluZ0Zyb21EYXRhXG5leHBvcnRzLm5hbWVzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMubmFtZXMpXG5leHBvcnRzLmNvZGVzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMuY29kZXMpXG4iLCIvLyBAdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vYmFzZScpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBkZWNvZGUgPSAoc3RyaW5nLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgLy8gQnVpbGQgdGhlIGNoYXJhY3RlciBsb29rdXAgdGFibGU6XG4gIGNvbnN0IGNvZGVzID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7ICsraSkge1xuICAgIGNvZGVzW2FscGhhYmV0W2ldXSA9IGlcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBwYWRkaW5nIGJ5dGVzOlxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aFxuICB3aGlsZSAoc3RyaW5nW2VuZCAtIDFdID09PSAnPScpIHtcbiAgICAtLWVuZFxuICB9XG5cbiAgLy8gQWxsb2NhdGUgdGhlIG91dHB1dDpcbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoKGVuZCAqIGJpdHNQZXJDaGFyIC8gOCkgfCAwKVxuXG4gIC8vIFBhcnNlIHRoZSBkYXRhOlxuICBsZXQgYml0cyA9IDAgLy8gTnVtYmVyIG9mIGJpdHMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgbGV0IGJ1ZmZlciA9IDAgLy8gQml0cyB3YWl0aW5nIHRvIGJlIHdyaXR0ZW4gb3V0LCBNU0IgZmlyc3RcbiAgbGV0IHdyaXR0ZW4gPSAwIC8vIE5leHQgYnl0ZSB0byB3cml0ZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKytpKSB7XG4gICAgLy8gUmVhZCBvbmUgY2hhcmFjdGVyIGZyb20gdGhlIHN0cmluZzpcbiAgICBjb25zdCB2YWx1ZSA9IGNvZGVzW3N0cmluZ1tpXV1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciAnICsgc3RyaW5nW2ldKVxuICAgIH1cblxuICAgIC8vIEFwcGVuZCB0aGUgYml0cyB0byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgYml0c1BlckNoYXIpIHwgdmFsdWVcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyXG5cbiAgICAvLyBXcml0ZSBvdXQgc29tZSBiaXRzIGlmIHRoZSBidWZmZXIgaGFzIGEgYnl0ZSdzIHdvcnRoOlxuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gOFxuICAgICAgb3V0W3dyaXR0ZW4rK10gPSAweGZmICYgKGJ1ZmZlciA+PiBiaXRzKVxuICAgIH1cbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHdlIGhhdmUgcmVjZWl2ZWQganVzdCBlbm91Z2ggYml0czpcbiAgaWYgKGJpdHMgPj0gYml0c1BlckNoYXIgfHwgMHhmZiAmIChidWZmZXIgPDwgKDggLSBiaXRzKSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVuY29kZSA9IChkYXRhLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgY29uc3QgcGFkID0gYWxwaGFiZXRbYWxwaGFiZXQubGVuZ3RoIC0gMV0gPT09ICc9J1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMVxuICBsZXQgb3V0ID0gJydcblxuICBsZXQgYml0cyA9IDAgLy8gTnVtYmVyIG9mIGJpdHMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgbGV0IGJ1ZmZlciA9IDAgLy8gQml0cyB3YWl0aW5nIHRvIGJlIHdyaXR0ZW4gb3V0LCBNU0IgZmlyc3RcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gU2x1cnAgZGF0YSBpbnRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCA4KSB8IGRhdGFbaV1cbiAgICBiaXRzICs9IDhcblxuICAgIC8vIFdyaXRlIG91dCBhcyBtdWNoIGFzIHdlIGNhbjpcbiAgICB3aGlsZSAoYml0cyA+IGJpdHNQZXJDaGFyKSB7XG4gICAgICBiaXRzIC09IGJpdHNQZXJDaGFyXG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPj4gYml0cyldXG4gICAgfVxuICB9XG5cbiAgLy8gUGFydGlhbCBjaGFyYWN0ZXI6XG4gIGlmIChiaXRzKSB7XG4gICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyIDw8IChiaXRzUGVyQ2hhciAtIGJpdHMpKV1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nIGNoYXJhY3RlcnMgdW50aWwgd2UgaGl0IGEgYnl0ZSBib3VuZGFyeTpcbiAgaWYgKHBhZCkge1xuICAgIHdoaWxlICgob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyKSAmIDcpIHtcbiAgICAgIG91dCArPSAnPSdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7Q29kZWNGYWN0b3J5fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChiaXRzUGVyQ2hhcikgPT4gKGFscGhhYmV0KSA9PiB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGVuY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGRlY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld3xBcnJheUJ1ZmZlcn0gYnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGRlY29kZVRleHQgPSAoYnl0ZXMpID0+IHRleHREZWNvZGVyLmRlY29kZShieXRlcylcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVRleHQgPSAodGV4dCkgPT4gdGV4dEVuY29kZXIuZW5jb2RlKHRleHQpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGJ5dGVzXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5jb25zdCBhc0J1ZmZlciA9ICh7IGJ1ZmZlciwgYnl0ZUxlbmd0aCwgYnl0ZU9mZnNldCB9KSA9PlxuICBCdWZmZXIuZnJvbShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpXG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0LCBhc0J1ZmZlciB9XG4iLCIvKiBlc2xpbnQgcXVvdGUtcHJvcHM6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5hbWVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICdpZGVudGl0eSc6IDB4MDAsXG4gICdzaGExJzogMHgxMSxcbiAgJ3NoYTItMjU2JzogMHgxMixcbiAgJ3NoYTItNTEyJzogMHgxMyxcbiAgJ3NoYTMtNTEyJzogMHgxNCxcbiAgJ3NoYTMtMzg0JzogMHgxNSxcbiAgJ3NoYTMtMjU2JzogMHgxNixcbiAgJ3NoYTMtMjI0JzogMHgxNyxcbiAgJ3NoYWtlLTEyOCc6IDB4MTgsXG4gICdzaGFrZS0yNTYnOiAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MWEsXG4gICdrZWNjYWstMjU2JzogMHgxYixcbiAgJ2tlY2Nhay0zODQnOiAweDFjLFxuICAna2VjY2FrLTUxMic6IDB4MWQsXG4gICdibGFrZTMnOiAweDFlLFxuICAnbXVybXVyMy0xMjgnOiAweDIyLFxuICAnbXVybXVyMy0zMic6IDB4MjMsXG4gICdkYmwtc2hhMi0yNTYnOiAweDU2LFxuICAnbWQ0JzogMHhkNCxcbiAgJ21kNSc6IDB4ZDUsXG4gICdibXQnOiAweGQ2LFxuICAnc2hhMi0yNTYtdHJ1bmMyNTQtcGFkZGVkJzogMHgxMDEyLFxuICAncmlwZW1kLTEyOCc6IDB4MTA1MixcbiAgJ3JpcGVtZC0xNjAnOiAweDEwNTMsXG4gICdyaXBlbWQtMjU2JzogMHgxMDU0LFxuICAncmlwZW1kLTMyMCc6IDB4MTA1NSxcbiAgJ3gxMSc6IDB4MTEwMCxcbiAgJ3NtMy0yNTYnOiAweDUzNGQsXG4gICdibGFrZTJiLTgnOiAweGIyMDEsXG4gICdibGFrZTJiLTE2JzogMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6IDB4YjIwMyxcbiAgJ2JsYWtlMmItMzInOiAweGIyMDQsXG4gICdibGFrZTJiLTQwJzogMHhiMjA1LFxuICAnYmxha2UyYi00OCc6IDB4YjIwNixcbiAgJ2JsYWtlMmItNTYnOiAweGIyMDcsXG4gICdibGFrZTJiLTY0JzogMHhiMjA4LFxuICAnYmxha2UyYi03Mic6IDB4YjIwOSxcbiAgJ2JsYWtlMmItODAnOiAweGIyMGEsXG4gICdibGFrZTJiLTg4JzogMHhiMjBiLFxuICAnYmxha2UyYi05Nic6IDB4YjIwYyxcbiAgJ2JsYWtlMmItMTA0JzogMHhiMjBkLFxuICAnYmxha2UyYi0xMTInOiAweGIyMGUsXG4gICdibGFrZTJiLTEyMCc6IDB4YjIwZixcbiAgJ2JsYWtlMmItMTI4JzogMHhiMjEwLFxuICAnYmxha2UyYi0xMzYnOiAweGIyMTEsXG4gICdibGFrZTJiLTE0NCc6IDB4YjIxMixcbiAgJ2JsYWtlMmItMTUyJzogMHhiMjEzLFxuICAnYmxha2UyYi0xNjAnOiAweGIyMTQsXG4gICdibGFrZTJiLTE2OCc6IDB4YjIxNSxcbiAgJ2JsYWtlMmItMTc2JzogMHhiMjE2LFxuICAnYmxha2UyYi0xODQnOiAweGIyMTcsXG4gICdibGFrZTJiLTE5Mic6IDB4YjIxOCxcbiAgJ2JsYWtlMmItMjAwJzogMHhiMjE5LFxuICAnYmxha2UyYi0yMDgnOiAweGIyMWEsXG4gICdibGFrZTJiLTIxNic6IDB4YjIxYixcbiAgJ2JsYWtlMmItMjI0JzogMHhiMjFjLFxuICAnYmxha2UyYi0yMzInOiAweGIyMWQsXG4gICdibGFrZTJiLTI0MCc6IDB4YjIxZSxcbiAgJ2JsYWtlMmItMjQ4JzogMHhiMjFmLFxuICAnYmxha2UyYi0yNTYnOiAweGIyMjAsXG4gICdibGFrZTJiLTI2NCc6IDB4YjIyMSxcbiAgJ2JsYWtlMmItMjcyJzogMHhiMjIyLFxuICAnYmxha2UyYi0yODAnOiAweGIyMjMsXG4gICdibGFrZTJiLTI4OCc6IDB4YjIyNCxcbiAgJ2JsYWtlMmItMjk2JzogMHhiMjI1LFxuICAnYmxha2UyYi0zMDQnOiAweGIyMjYsXG4gICdibGFrZTJiLTMxMic6IDB4YjIyNyxcbiAgJ2JsYWtlMmItMzIwJzogMHhiMjI4LFxuICAnYmxha2UyYi0zMjgnOiAweGIyMjksXG4gICdibGFrZTJiLTMzNic6IDB4YjIyYSxcbiAgJ2JsYWtlMmItMzQ0JzogMHhiMjJiLFxuICAnYmxha2UyYi0zNTInOiAweGIyMmMsXG4gICdibGFrZTJiLTM2MCc6IDB4YjIyZCxcbiAgJ2JsYWtlMmItMzY4JzogMHhiMjJlLFxuICAnYmxha2UyYi0zNzYnOiAweGIyMmYsXG4gICdibGFrZTJiLTM4NCc6IDB4YjIzMCxcbiAgJ2JsYWtlMmItMzkyJzogMHhiMjMxLFxuICAnYmxha2UyYi00MDAnOiAweGIyMzIsXG4gICdibGFrZTJiLTQwOCc6IDB4YjIzMyxcbiAgJ2JsYWtlMmItNDE2JzogMHhiMjM0LFxuICAnYmxha2UyYi00MjQnOiAweGIyMzUsXG4gICdibGFrZTJiLTQzMic6IDB4YjIzNixcbiAgJ2JsYWtlMmItNDQwJzogMHhiMjM3LFxuICAnYmxha2UyYi00NDgnOiAweGIyMzgsXG4gICdibGFrZTJiLTQ1Nic6IDB4YjIzOSxcbiAgJ2JsYWtlMmItNDY0JzogMHhiMjNhLFxuICAnYmxha2UyYi00NzInOiAweGIyM2IsXG4gICdibGFrZTJiLTQ4MCc6IDB4YjIzYyxcbiAgJ2JsYWtlMmItNDg4JzogMHhiMjNkLFxuICAnYmxha2UyYi00OTYnOiAweGIyM2UsXG4gICdibGFrZTJiLTUwNCc6IDB4YjIzZixcbiAgJ2JsYWtlMmItNTEyJzogMHhiMjQwLFxuICAnYmxha2Uycy04JzogMHhiMjQxLFxuICAnYmxha2Uycy0xNic6IDB4YjI0MixcbiAgJ2JsYWtlMnMtMjQnOiAweGIyNDMsXG4gICdibGFrZTJzLTMyJzogMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6IDB4YjI0NSxcbiAgJ2JsYWtlMnMtNDgnOiAweGIyNDYsXG4gICdibGFrZTJzLTU2JzogMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6IDB4YjI0OCxcbiAgJ2JsYWtlMnMtNzInOiAweGIyNDksXG4gICdibGFrZTJzLTgwJzogMHhiMjRhLFxuICAnYmxha2Uycy04OCc6IDB4YjI0YixcbiAgJ2JsYWtlMnMtOTYnOiAweGIyNGMsXG4gICdibGFrZTJzLTEwNCc6IDB4YjI0ZCxcbiAgJ2JsYWtlMnMtMTEyJzogMHhiMjRlLFxuICAnYmxha2Uycy0xMjAnOiAweGIyNGYsXG4gICdibGFrZTJzLTEyOCc6IDB4YjI1MCxcbiAgJ2JsYWtlMnMtMTM2JzogMHhiMjUxLFxuICAnYmxha2Uycy0xNDQnOiAweGIyNTIsXG4gICdibGFrZTJzLTE1Mic6IDB4YjI1MyxcbiAgJ2JsYWtlMnMtMTYwJzogMHhiMjU0LFxuICAnYmxha2Uycy0xNjgnOiAweGIyNTUsXG4gICdibGFrZTJzLTE3Nic6IDB4YjI1NixcbiAgJ2JsYWtlMnMtMTg0JzogMHhiMjU3LFxuICAnYmxha2Uycy0xOTInOiAweGIyNTgsXG4gICdibGFrZTJzLTIwMCc6IDB4YjI1OSxcbiAgJ2JsYWtlMnMtMjA4JzogMHhiMjVhLFxuICAnYmxha2Uycy0yMTYnOiAweGIyNWIsXG4gICdibGFrZTJzLTIyNCc6IDB4YjI1YyxcbiAgJ2JsYWtlMnMtMjMyJzogMHhiMjVkLFxuICAnYmxha2Uycy0yNDAnOiAweGIyNWUsXG4gICdibGFrZTJzLTI0OCc6IDB4YjI1ZixcbiAgJ2JsYWtlMnMtMjU2JzogMHhiMjYwLFxuICAnc2tlaW4yNTYtOCc6IDB4YjMwMSxcbiAgJ3NrZWluMjU2LTE2JzogMHhiMzAyLFxuICAnc2tlaW4yNTYtMjQnOiAweGIzMDMsXG4gICdza2VpbjI1Ni0zMic6IDB4YjMwNCxcbiAgJ3NrZWluMjU2LTQwJzogMHhiMzA1LFxuICAnc2tlaW4yNTYtNDgnOiAweGIzMDYsXG4gICdza2VpbjI1Ni01Nic6IDB4YjMwNyxcbiAgJ3NrZWluMjU2LTY0JzogMHhiMzA4LFxuICAnc2tlaW4yNTYtNzInOiAweGIzMDksXG4gICdza2VpbjI1Ni04MCc6IDB4YjMwYSxcbiAgJ3NrZWluMjU2LTg4JzogMHhiMzBiLFxuICAnc2tlaW4yNTYtOTYnOiAweGIzMGMsXG4gICdza2VpbjI1Ni0xMDQnOiAweGIzMGQsXG4gICdza2VpbjI1Ni0xMTInOiAweGIzMGUsXG4gICdza2VpbjI1Ni0xMjAnOiAweGIzMGYsXG4gICdza2VpbjI1Ni0xMjgnOiAweGIzMTAsXG4gICdza2VpbjI1Ni0xMzYnOiAweGIzMTEsXG4gICdza2VpbjI1Ni0xNDQnOiAweGIzMTIsXG4gICdza2VpbjI1Ni0xNTInOiAweGIzMTMsXG4gICdza2VpbjI1Ni0xNjAnOiAweGIzMTQsXG4gICdza2VpbjI1Ni0xNjgnOiAweGIzMTUsXG4gICdza2VpbjI1Ni0xNzYnOiAweGIzMTYsXG4gICdza2VpbjI1Ni0xODQnOiAweGIzMTcsXG4gICdza2VpbjI1Ni0xOTInOiAweGIzMTgsXG4gICdza2VpbjI1Ni0yMDAnOiAweGIzMTksXG4gICdza2VpbjI1Ni0yMDgnOiAweGIzMWEsXG4gICdza2VpbjI1Ni0yMTYnOiAweGIzMWIsXG4gICdza2VpbjI1Ni0yMjQnOiAweGIzMWMsXG4gICdza2VpbjI1Ni0yMzInOiAweGIzMWQsXG4gICdza2VpbjI1Ni0yNDAnOiAweGIzMWUsXG4gICdza2VpbjI1Ni0yNDgnOiAweGIzMWYsXG4gICdza2VpbjI1Ni0yNTYnOiAweGIzMjAsXG4gICdza2VpbjUxMi04JzogMHhiMzIxLFxuICAnc2tlaW41MTItMTYnOiAweGIzMjIsXG4gICdza2VpbjUxMi0yNCc6IDB4YjMyMyxcbiAgJ3NrZWluNTEyLTMyJzogMHhiMzI0LFxuICAnc2tlaW41MTItNDAnOiAweGIzMjUsXG4gICdza2VpbjUxMi00OCc6IDB4YjMyNixcbiAgJ3NrZWluNTEyLTU2JzogMHhiMzI3LFxuICAnc2tlaW41MTItNjQnOiAweGIzMjgsXG4gICdza2VpbjUxMi03Mic6IDB4YjMyOSxcbiAgJ3NrZWluNTEyLTgwJzogMHhiMzJhLFxuICAnc2tlaW41MTItODgnOiAweGIzMmIsXG4gICdza2VpbjUxMi05Nic6IDB4YjMyYyxcbiAgJ3NrZWluNTEyLTEwNCc6IDB4YjMyZCxcbiAgJ3NrZWluNTEyLTExMic6IDB4YjMyZSxcbiAgJ3NrZWluNTEyLTEyMCc6IDB4YjMyZixcbiAgJ3NrZWluNTEyLTEyOCc6IDB4YjMzMCxcbiAgJ3NrZWluNTEyLTEzNic6IDB4YjMzMSxcbiAgJ3NrZWluNTEyLTE0NCc6IDB4YjMzMixcbiAgJ3NrZWluNTEyLTE1Mic6IDB4YjMzMyxcbiAgJ3NrZWluNTEyLTE2MCc6IDB4YjMzNCxcbiAgJ3NrZWluNTEyLTE2OCc6IDB4YjMzNSxcbiAgJ3NrZWluNTEyLTE3Nic6IDB4YjMzNixcbiAgJ3NrZWluNTEyLTE4NCc6IDB4YjMzNyxcbiAgJ3NrZWluNTEyLTE5Mic6IDB4YjMzOCxcbiAgJ3NrZWluNTEyLTIwMCc6IDB4YjMzOSxcbiAgJ3NrZWluNTEyLTIwOCc6IDB4YjMzYSxcbiAgJ3NrZWluNTEyLTIxNic6IDB4YjMzYixcbiAgJ3NrZWluNTEyLTIyNCc6IDB4YjMzYyxcbiAgJ3NrZWluNTEyLTIzMic6IDB4YjMzZCxcbiAgJ3NrZWluNTEyLTI0MCc6IDB4YjMzZSxcbiAgJ3NrZWluNTEyLTI0OCc6IDB4YjMzZixcbiAgJ3NrZWluNTEyLTI1Nic6IDB4YjM0MCxcbiAgJ3NrZWluNTEyLTI2NCc6IDB4YjM0MSxcbiAgJ3NrZWluNTEyLTI3Mic6IDB4YjM0MixcbiAgJ3NrZWluNTEyLTI4MCc6IDB4YjM0MyxcbiAgJ3NrZWluNTEyLTI4OCc6IDB4YjM0NCxcbiAgJ3NrZWluNTEyLTI5Nic6IDB4YjM0NSxcbiAgJ3NrZWluNTEyLTMwNCc6IDB4YjM0NixcbiAgJ3NrZWluNTEyLTMxMic6IDB4YjM0NyxcbiAgJ3NrZWluNTEyLTMyMCc6IDB4YjM0OCxcbiAgJ3NrZWluNTEyLTMyOCc6IDB4YjM0OSxcbiAgJ3NrZWluNTEyLTMzNic6IDB4YjM0YSxcbiAgJ3NrZWluNTEyLTM0NCc6IDB4YjM0YixcbiAgJ3NrZWluNTEyLTM1Mic6IDB4YjM0YyxcbiAgJ3NrZWluNTEyLTM2MCc6IDB4YjM0ZCxcbiAgJ3NrZWluNTEyLTM2OCc6IDB4YjM0ZSxcbiAgJ3NrZWluNTEyLTM3Nic6IDB4YjM0ZixcbiAgJ3NrZWluNTEyLTM4NCc6IDB4YjM1MCxcbiAgJ3NrZWluNTEyLTM5Mic6IDB4YjM1MSxcbiAgJ3NrZWluNTEyLTQwMCc6IDB4YjM1MixcbiAgJ3NrZWluNTEyLTQwOCc6IDB4YjM1MyxcbiAgJ3NrZWluNTEyLTQxNic6IDB4YjM1NCxcbiAgJ3NrZWluNTEyLTQyNCc6IDB4YjM1NSxcbiAgJ3NrZWluNTEyLTQzMic6IDB4YjM1NixcbiAgJ3NrZWluNTEyLTQ0MCc6IDB4YjM1NyxcbiAgJ3NrZWluNTEyLTQ0OCc6IDB4YjM1OCxcbiAgJ3NrZWluNTEyLTQ1Nic6IDB4YjM1OSxcbiAgJ3NrZWluNTEyLTQ2NCc6IDB4YjM1YSxcbiAgJ3NrZWluNTEyLTQ3Mic6IDB4YjM1YixcbiAgJ3NrZWluNTEyLTQ4MCc6IDB4YjM1YyxcbiAgJ3NrZWluNTEyLTQ4OCc6IDB4YjM1ZCxcbiAgJ3NrZWluNTEyLTQ5Nic6IDB4YjM1ZSxcbiAgJ3NrZWluNTEyLTUwNCc6IDB4YjM1ZixcbiAgJ3NrZWluNTEyLTUxMic6IDB4YjM2MCxcbiAgJ3NrZWluMTAyNC04JzogMHhiMzYxLFxuICAnc2tlaW4xMDI0LTE2JzogMHhiMzYyLFxuICAnc2tlaW4xMDI0LTI0JzogMHhiMzYzLFxuICAnc2tlaW4xMDI0LTMyJzogMHhiMzY0LFxuICAnc2tlaW4xMDI0LTQwJzogMHhiMzY1LFxuICAnc2tlaW4xMDI0LTQ4JzogMHhiMzY2LFxuICAnc2tlaW4xMDI0LTU2JzogMHhiMzY3LFxuICAnc2tlaW4xMDI0LTY0JzogMHhiMzY4LFxuICAnc2tlaW4xMDI0LTcyJzogMHhiMzY5LFxuICAnc2tlaW4xMDI0LTgwJzogMHhiMzZhLFxuICAnc2tlaW4xMDI0LTg4JzogMHhiMzZiLFxuICAnc2tlaW4xMDI0LTk2JzogMHhiMzZjLFxuICAnc2tlaW4xMDI0LTEwNCc6IDB4YjM2ZCxcbiAgJ3NrZWluMTAyNC0xMTInOiAweGIzNmUsXG4gICdza2VpbjEwMjQtMTIwJzogMHhiMzZmLFxuICAnc2tlaW4xMDI0LTEyOCc6IDB4YjM3MCxcbiAgJ3NrZWluMTAyNC0xMzYnOiAweGIzNzEsXG4gICdza2VpbjEwMjQtMTQ0JzogMHhiMzcyLFxuICAnc2tlaW4xMDI0LTE1Mic6IDB4YjM3MyxcbiAgJ3NrZWluMTAyNC0xNjAnOiAweGIzNzQsXG4gICdza2VpbjEwMjQtMTY4JzogMHhiMzc1LFxuICAnc2tlaW4xMDI0LTE3Nic6IDB4YjM3NixcbiAgJ3NrZWluMTAyNC0xODQnOiAweGIzNzcsXG4gICdza2VpbjEwMjQtMTkyJzogMHhiMzc4LFxuICAnc2tlaW4xMDI0LTIwMCc6IDB4YjM3OSxcbiAgJ3NrZWluMTAyNC0yMDgnOiAweGIzN2EsXG4gICdza2VpbjEwMjQtMjE2JzogMHhiMzdiLFxuICAnc2tlaW4xMDI0LTIyNCc6IDB4YjM3YyxcbiAgJ3NrZWluMTAyNC0yMzInOiAweGIzN2QsXG4gICdza2VpbjEwMjQtMjQwJzogMHhiMzdlLFxuICAnc2tlaW4xMDI0LTI0OCc6IDB4YjM3ZixcbiAgJ3NrZWluMTAyNC0yNTYnOiAweGIzODAsXG4gICdza2VpbjEwMjQtMjY0JzogMHhiMzgxLFxuICAnc2tlaW4xMDI0LTI3Mic6IDB4YjM4MixcbiAgJ3NrZWluMTAyNC0yODAnOiAweGIzODMsXG4gICdza2VpbjEwMjQtMjg4JzogMHhiMzg0LFxuICAnc2tlaW4xMDI0LTI5Nic6IDB4YjM4NSxcbiAgJ3NrZWluMTAyNC0zMDQnOiAweGIzODYsXG4gICdza2VpbjEwMjQtMzEyJzogMHhiMzg3LFxuICAnc2tlaW4xMDI0LTMyMCc6IDB4YjM4OCxcbiAgJ3NrZWluMTAyNC0zMjgnOiAweGIzODksXG4gICdza2VpbjEwMjQtMzM2JzogMHhiMzhhLFxuICAnc2tlaW4xMDI0LTM0NCc6IDB4YjM4YixcbiAgJ3NrZWluMTAyNC0zNTInOiAweGIzOGMsXG4gICdza2VpbjEwMjQtMzYwJzogMHhiMzhkLFxuICAnc2tlaW4xMDI0LTM2OCc6IDB4YjM4ZSxcbiAgJ3NrZWluMTAyNC0zNzYnOiAweGIzOGYsXG4gICdza2VpbjEwMjQtMzg0JzogMHhiMzkwLFxuICAnc2tlaW4xMDI0LTM5Mic6IDB4YjM5MSxcbiAgJ3NrZWluMTAyNC00MDAnOiAweGIzOTIsXG4gICdza2VpbjEwMjQtNDA4JzogMHhiMzkzLFxuICAnc2tlaW4xMDI0LTQxNic6IDB4YjM5NCxcbiAgJ3NrZWluMTAyNC00MjQnOiAweGIzOTUsXG4gICdza2VpbjEwMjQtNDMyJzogMHhiMzk2LFxuICAnc2tlaW4xMDI0LTQ0MCc6IDB4YjM5NyxcbiAgJ3NrZWluMTAyNC00NDgnOiAweGIzOTgsXG4gICdza2VpbjEwMjQtNDU2JzogMHhiMzk5LFxuICAnc2tlaW4xMDI0LTQ2NCc6IDB4YjM5YSxcbiAgJ3NrZWluMTAyNC00NzInOiAweGIzOWIsXG4gICdza2VpbjEwMjQtNDgwJzogMHhiMzljLFxuICAnc2tlaW4xMDI0LTQ4OCc6IDB4YjM5ZCxcbiAgJ3NrZWluMTAyNC00OTYnOiAweGIzOWUsXG4gICdza2VpbjEwMjQtNTA0JzogMHhiMzlmLFxuICAnc2tlaW4xMDI0LTUxMic6IDB4YjNhMCxcbiAgJ3NrZWluMTAyNC01MjAnOiAweGIzYTEsXG4gICdza2VpbjEwMjQtNTI4JzogMHhiM2EyLFxuICAnc2tlaW4xMDI0LTUzNic6IDB4YjNhMyxcbiAgJ3NrZWluMTAyNC01NDQnOiAweGIzYTQsXG4gICdza2VpbjEwMjQtNTUyJzogMHhiM2E1LFxuICAnc2tlaW4xMDI0LTU2MCc6IDB4YjNhNixcbiAgJ3NrZWluMTAyNC01NjgnOiAweGIzYTcsXG4gICdza2VpbjEwMjQtNTc2JzogMHhiM2E4LFxuICAnc2tlaW4xMDI0LTU4NCc6IDB4YjNhOSxcbiAgJ3NrZWluMTAyNC01OTInOiAweGIzYWEsXG4gICdza2VpbjEwMjQtNjAwJzogMHhiM2FiLFxuICAnc2tlaW4xMDI0LTYwOCc6IDB4YjNhYyxcbiAgJ3NrZWluMTAyNC02MTYnOiAweGIzYWQsXG4gICdza2VpbjEwMjQtNjI0JzogMHhiM2FlLFxuICAnc2tlaW4xMDI0LTYzMic6IDB4YjNhZixcbiAgJ3NrZWluMTAyNC02NDAnOiAweGIzYjAsXG4gICdza2VpbjEwMjQtNjQ4JzogMHhiM2IxLFxuICAnc2tlaW4xMDI0LTY1Nic6IDB4YjNiMixcbiAgJ3NrZWluMTAyNC02NjQnOiAweGIzYjMsXG4gICdza2VpbjEwMjQtNjcyJzogMHhiM2I0LFxuICAnc2tlaW4xMDI0LTY4MCc6IDB4YjNiNSxcbiAgJ3NrZWluMTAyNC02ODgnOiAweGIzYjYsXG4gICdza2VpbjEwMjQtNjk2JzogMHhiM2I3LFxuICAnc2tlaW4xMDI0LTcwNCc6IDB4YjNiOCxcbiAgJ3NrZWluMTAyNC03MTInOiAweGIzYjksXG4gICdza2VpbjEwMjQtNzIwJzogMHhiM2JhLFxuICAnc2tlaW4xMDI0LTcyOCc6IDB4YjNiYixcbiAgJ3NrZWluMTAyNC03MzYnOiAweGIzYmMsXG4gICdza2VpbjEwMjQtNzQ0JzogMHhiM2JkLFxuICAnc2tlaW4xMDI0LTc1Mic6IDB4YjNiZSxcbiAgJ3NrZWluMTAyNC03NjAnOiAweGIzYmYsXG4gICdza2VpbjEwMjQtNzY4JzogMHhiM2MwLFxuICAnc2tlaW4xMDI0LTc3Nic6IDB4YjNjMSxcbiAgJ3NrZWluMTAyNC03ODQnOiAweGIzYzIsXG4gICdza2VpbjEwMjQtNzkyJzogMHhiM2MzLFxuICAnc2tlaW4xMDI0LTgwMCc6IDB4YjNjNCxcbiAgJ3NrZWluMTAyNC04MDgnOiAweGIzYzUsXG4gICdza2VpbjEwMjQtODE2JzogMHhiM2M2LFxuICAnc2tlaW4xMDI0LTgyNCc6IDB4YjNjNyxcbiAgJ3NrZWluMTAyNC04MzInOiAweGIzYzgsXG4gICdza2VpbjEwMjQtODQwJzogMHhiM2M5LFxuICAnc2tlaW4xMDI0LTg0OCc6IDB4YjNjYSxcbiAgJ3NrZWluMTAyNC04NTYnOiAweGIzY2IsXG4gICdza2VpbjEwMjQtODY0JzogMHhiM2NjLFxuICAnc2tlaW4xMDI0LTg3Mic6IDB4YjNjZCxcbiAgJ3NrZWluMTAyNC04ODAnOiAweGIzY2UsXG4gICdza2VpbjEwMjQtODg4JzogMHhiM2NmLFxuICAnc2tlaW4xMDI0LTg5Nic6IDB4YjNkMCxcbiAgJ3NrZWluMTAyNC05MDQnOiAweGIzZDEsXG4gICdza2VpbjEwMjQtOTEyJzogMHhiM2QyLFxuICAnc2tlaW4xMDI0LTkyMCc6IDB4YjNkMyxcbiAgJ3NrZWluMTAyNC05MjgnOiAweGIzZDQsXG4gICdza2VpbjEwMjQtOTM2JzogMHhiM2Q1LFxuICAnc2tlaW4xMDI0LTk0NCc6IDB4YjNkNixcbiAgJ3NrZWluMTAyNC05NTInOiAweGIzZDcsXG4gICdza2VpbjEwMjQtOTYwJzogMHhiM2Q4LFxuICAnc2tlaW4xMDI0LTk2OCc6IDB4YjNkOSxcbiAgJ3NrZWluMTAyNC05NzYnOiAweGIzZGEsXG4gICdza2VpbjEwMjQtOTg0JzogMHhiM2RiLFxuICAnc2tlaW4xMDI0LTk5Mic6IDB4YjNkYyxcbiAgJ3NrZWluMTAyNC0xMDAwJzogMHhiM2RkLFxuICAnc2tlaW4xMDI0LTEwMDgnOiAweGIzZGUsXG4gICdza2VpbjEwMjQtMTAxNic6IDB4YjNkZixcbiAgJ3NrZWluMTAyNC0xMDI0JzogMHhiM2UwLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMSc6IDB4YjQwMSxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEtc2MnOiAweGI0MDJcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBuYW1lcyB9XG4iLCIvLyBAdHMtY2hlY2tcbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyoqXG4gKiBNdWx0aWhhc2ggaW1wbGVtZW50YXRpb24gaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11bHRpaGFzaFxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbmNvbnN0IGNvZGVzID0ge31cblxuZm9yIChjb25zdCBrZXkgaW4gbmFtZXMpIHtcbiAgY29kZXNbbmFtZXNba2V5XV0gPSBrZXlcbn1cbmV4cG9ydHMubmFtZXMgPSBuYW1lc1xuZXhwb3J0cy5jb2RlcyA9IE9iamVjdC5mcmVlemUoY29kZXMpXG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0hleFN0cmluZyA9IGZ1bmN0aW9uIHRvSGV4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihoYXNoKVxuICAgID8gaGFzaFxuICAgIDogQnVmZmVyLmZyb20oaGFzaC5idWZmZXIsIGhhc2guYnl0ZU9mZnNldCwgaGFzaC5ieXRlTGVuZ3RoKVxuXG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmZyb21IZXhTdHJpbmcgPSBmdW5jdGlvbiBmcm9tSGV4U3RyaW5nIChoYXNoKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLCAnaGV4Jylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBtdWx0aWhhc2ggdG8gYSBiYXNlNTggZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvQjU4U3RyaW5nID0gZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCEoaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIHBhc3NlZCBhIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShtdWx0aWJhc2UuZW5jb2RlKCdiYXNlNThidGMnLCBoYXNoKSkuc2xpY2UoMSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBiYXNlNTggZW5jb2RlZCBzdHJpbmcgdG8gYSBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tQjU4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUI1OFN0cmluZyAoaGFzaCkge1xuICBjb25zdCBlbmNvZGVkID0gaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICA/IHRleHREZWNvZGVyLmRlY29kZShoYXNoKVxuICAgIDogaGFzaFxuXG4gIHJldHVybiBtdWx0aWJhc2UuZGVjb2RlKCd6JyArIGVuY29kZWQpXG59XG5cbi8qKlxuICogRGVjb2RlIGEgaGFzaCBmcm9tIHRoZSBnaXZlbiBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge3tjb2RlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIsIGRpZ2VzdDogQnVmZmVyfX0gcmVzdWx0XG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChieXRlcykge1xuICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggbXVzdCBiZSBhIFVpbnQ4QXJyYXknKVxuICB9XG4gIGxldCBidWYgPSBCdWZmZXIuaXNCdWZmZXIoYnl0ZXMpXG4gICAgPyBieXRlc1xuICAgIDogQnVmZmVyLmZyb20oYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKVxuXG4gIGlmIChidWYubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIHRvbyBzaG9ydC4gbXVzdCBiZSA+IDIgYnl0ZXMuJylcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKCFleHBvcnRzLmlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggdW5rbm93biBmdW5jdGlvbiBjb2RlOiAweCR7Y29kZS50b1N0cmluZygxNil9YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBjb25zdCBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKGxlbiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCBpbnZhbGlkIGxlbmd0aDogJHtsZW59YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBpZiAoYnVmLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggbGVuZ3RoIGluY29uc2lzdGVudDogMHgke2J1Zi50b1N0cmluZygnaGV4Jyl9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBuYW1lOiBjb2Rlc1tjb2RlXSxcbiAgICBsZW5ndGg6IGxlbixcbiAgICBkaWdlc3Q6IGJ1ZlxuICB9XG59XG5cbi8qKlxuICogIEVuY29kZSBhIGhhc2ggZGlnZXN0IGFsb25nIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBjb2RlLlxuICpcbiAqID4gKipOb3RlOioqIHRoZSBsZW5ndGggaXMgZGVyaXZlZCBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2VzdCBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkaWdlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAoZGlnZXN0LCBjb2RlLCBsZW5ndGgpIHtcbiAgaWYgKCFkaWdlc3QgfHwgY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZW5jb2RlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBhcmdzOiBkaWdlc3QsIGNvZGUnKVxuICB9XG5cbiAgLy8gZW5zdXJlIGl0J3MgYSBoYXNoZnVuY3Rpb24gY29kZS5cbiAgY29uc3QgaGFzaGZuID0gZXhwb3J0cy5jb2VyY2VDb2RlKGNvZGUpXG5cbiAgaWYgKCEoZGlnZXN0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBzaG91bGQgYmUgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgIGxlbmd0aCA9IGRpZ2VzdC5sZW5ndGhcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgZGlnZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QgbGVuZ3RoIHNob3VsZCBiZSBlcXVhbCB0byBzcGVjaWZpZWQgbGVuZ3RoLicpXG4gIH1cblxuICBjb25zdCBoYXNoID0gdmFyaW50LmVuY29kZShoYXNoZm4pXG4gIGNvbnN0IGxlbiA9IHZhcmludC5lbmNvZGUobGVuZ3RoKVxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoaGFzaC5sZW5ndGggKyBsZW4ubGVuZ3RoICsgZGlnZXN0Lmxlbmd0aClcbiAgYnVmZmVyLnNldChoYXNoLCAwKVxuICBidWZmZXIuc2V0KGxlbiwgaGFzaC5sZW5ndGgpXG4gIGJ1ZmZlci5zZXQoZGlnZXN0LCBoYXNoLmxlbmd0aCArIGxlbi5sZW5ndGgpXG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhhc2ggZnVuY3Rpb24gbmFtZSBpbnRvIHRoZSBtYXRjaGluZyBjb2RlLlxuICogSWYgcGFzc2VkIGEgbnVtYmVyIGl0IHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgaWYgaXQncyBhIHZhbGlkIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuY29lcmNlQ29kZSA9IGZ1bmN0aW9uIGNvZXJjZUNvZGUgKG5hbWUpIHtcbiAgbGV0IGNvZGUgPSBuYW1lXG5cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmIChuYW1lc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBoYXNoIGZ1bmN0aW9uIG5hbWVkOiAke25hbWV9YClcbiAgICB9XG4gICAgY29kZSA9IG5hbWVzW25hbWVdXG4gIH1cblxuICBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBIYXNoIGZ1bmN0aW9uIGNvZGUgc2hvdWxkIGJlIGEgbnVtYmVyLiBHb3Q6ICR7Y29kZX1gKVxuICB9XG5cbiAgaWYgKGNvZGVzW2NvZGVdID09PSB1bmRlZmluZWQgJiYgIWV4cG9ydHMuaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZnVuY3Rpb24gY29kZTogJHtjb2RlfWApXG4gIH1cblxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIENoZWNrcyB3ZXRoZXIgYSBjb2RlIGlzIHBhcnQgb2YgdGhlIGFwcCByYW5nZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0FwcENvZGUgPSBmdW5jdGlvbiBhcHBDb2RlIChjb2RlKSB7XG4gIHJldHVybiBjb2RlID4gMCAmJiBjb2RlIDwgMHgxMFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgbXVsdGloYXNoIGNvZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRDb2RlID0gZnVuY3Rpb24gdmFsaWRDb2RlIChjb2RlKSB7XG4gIGlmIChleHBvcnRzLmlzQXBwQ29kZShjb2RlKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY29kZXNbY29kZV0pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGJ1ZmZlciBpcyBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG11bHRpaGFzaFxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUgKG11bHRpaGFzaCkge1xuICBleHBvcnRzLmRlY29kZShtdWx0aWhhc2gpIC8vIHRocm93cyBpZiBiYWQuXG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGVcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZml4IGZyb20gYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5wcmVmaXggPSBmdW5jdGlvbiBwcmVmaXggKG11bHRpaGFzaCkge1xuICB2YWxpZGF0ZShtdWx0aWhhc2gpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG11bHRpaGFzaC5idWZmZXIsIG11bHRpaGFzaC5ieXRlT2Zmc2V0LCAyKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5TGlrZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyYXlzXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJ211bHRpYmFzZS9zcmMvY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dEVuY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5jb25zdCB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogSW50ZXJwZXJldHMgZWFjaCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgYXMgYSBieXRlIGFuZFxuICogcmV0dXJucyBhIFVpbnQ4QXJyYXkgb2YgdGhvc2UgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHR1cm4gaW50byBhbiBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGFzY2lpU3RyaW5nVG9VaW50OEFycmF5IChzdHJpbmcpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShzdHJpbmcubGVuZ3RoKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuICB9XG5cbiAgcmV0dXJuIGFycmF5XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFVpbnQ4QXJyYXlgIGZyb20gdGhlIHBhc3NlZCBzdHJpbmdcbiAqXG4gKiBTdXBwb3J0cyBgdXRmOGAsIGB1dGYtOGAgYW5kIGFueSBlbmNvZGluZyBzdXBwb3J0ZWQgYnkgdGhlIG11bHRpYmFzZSBtb2R1bGUuXG4gKlxuICogQWxzbyBgYXNjaWlgIHdoaWNoIGlzIHNpbWlsYXIgdG8gbm9kZSdzICdiaW5hcnknIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9dXRmOF0gdXRmOCwgYmFzZTE2LCBiYXNlNjQsIGJhc2U2NHVybHBhZCwgZXRjXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL211bHRpYmFzZXxtdWx0aWJhc2V9IGZvciBzdXBwb3J0ZWQgZW5jb2RpbmdzIG90aGVyIHRoYW4gYHV0ZjhgXG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOEVuY29kZXIuZW5jb2RlKHN0cmluZylcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiBhc2NpaVN0cmluZ1RvVWludDhBcnJheShzdHJpbmcpXG4gIH1cblxuICBjb25zdCBjb2RlYyA9IG5hbWVzW2VuY29kaW5nXVxuXG4gIGlmICghY29kZWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmFzZScpXG4gIH1cblxuICByZXR1cm4gY29kZWMuZGVjb2RlKHN0cmluZylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tU3RyaW5nXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBuYW1lcyB9ID0gcmVxdWlyZSgnbXVsdGliYXNlL3NyYy9jb25zdGFudHMnKVxuY29uc3QgeyBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcbmNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JylcblxuLyoqXG4gKiBUdXJucyBhIFVpbnQ4QXJyYXkgb2YgYnl0ZXMgaW50byBhIHN0cmluZyB3aXRoIGVhY2hcbiAqIGNoYXJhY3RlciBiZWluZyB0aGUgY2hhciBjb2RlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGJ5dGVcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nIChhcnJheSkge1xuICBsZXQgc3RyaW5nID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pXG4gIH1cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vKipcbiAqIFR1cm5zIGEgYFVpbnQ4QXJyYXlgIGludG8gYSBzdHJpbmcuXG4gKlxuICogU3VwcG9ydHMgYHV0ZjhgLCBgdXRmLThgIGFuZCBhbnkgZW5jb2Rpbmcgc3VwcG9ydGVkIGJ5IHRoZSBtdWx0aWJhc2UgbW9kdWxlLlxuICpcbiAqIEFsc28gYGFzY2lpYCB3aGljaCBpcyBzaW1pbGFyIHRvIG5vZGUncyAnYmluYXJ5JyBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9dXRmOF0gVGhlIGVuY29kaW5nIHRvIHVzZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL211bHRpYmFzZXxtdWx0aWJhc2V9IGZvciBzdXBwb3J0ZWQgZW5jb2RpbmdzIG90aGVyIHRoYW4gYHV0ZjhgXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nIChhcnJheSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKGFycmF5KVxuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nKGFycmF5KVxuICB9XG5cbiAgY29uc3QgY29kZWMgPSBuYW1lc1tlbmNvZGluZ11cblxuICBpZiAoIWNvZGVjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UnKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVjLmVuY29kZShhcnJheSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZ1xuIiwiLypcblx0SVNDIExpY2Vuc2VcblxuXHRDb3B5cmlnaHQgKGMpIDIwMTksIFBpZXJyZS1Mb3VpcyBEZXNwYWlnbmVcblxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuXHRjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG5cdFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcblx0TUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcblx0QU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuXHRXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cblx0QUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcblx0T1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiovXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKTtcblxuLy8gTGFiZWwncyBtYXggbGVuZ3RoIGluIEROUyAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzQjcGFnZS03KVxuY29uc3QgZG5zTGFiZWxNYXhMZW5ndGggPSA2MztcblxuLyoqXG4gKiBUYWtlIGFueSBpcGZzSGFzaCBhbmQgY29udmVydCBpdCB0byBETlMtY29tcGF0aWJsZSBDSURcbiAqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBhIHJlZ3VsYXIgaXBmcyBoYXNoIGVpdGhlciBhIGNpZCB2MCBvciB2MVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGlwZnMgaGFzaCBhcyBhIGNpZCB2MVxuICovXG5jb25zdCBjaWRGb3JXZWIgPSAoaXBmc0hhc2gpID0+IHtcblx0bGV0IGNpZCA9IG5ldyBDSUQoaXBmc0hhc2gpO1xuXHRpZiAoY2lkLnZlcnNpb24gPT09IDApIHtcblx0XHRjaWQgPSBjaWQudG9WMSgpO1xuXHR9XG4gIGxldCBkbnNMYWJlbCA9IGNpZC50b1N0cmluZygnYmFzZTMyJyk7XG4gIGlmIChkbnNMYWJlbC5sZW5ndGggPiBkbnNMYWJlbE1heExlbmd0aCkge1xuICAgIGNvbnN0IGIzNiA9IGNpZC50b1N0cmluZygnYmFzZTM2Jyk7XG4gICAgaWYgKGIzNi5sZW5ndGggPD0gZG5zTGFiZWxNYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBiMzY7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdDSUQgaXMgbG9uZ2VyIHRoYW4gRE5TIGxpbWl0IG9mIDYzIGNoYXJhY3RlcnMgYW5kIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggcHVibGljIGdhdGV3YXlzJyk7XG4gIH1cblx0cmV0dXJuIGRuc0xhYmVsO1xufVxuXG5leHBvcnRzLmNpZEZvcldlYiA9IGNpZEZvcldlYjtcblxuXG4vKipcbiAqIFRha2UgYW55IGlwZnNIYXNoIGFuZCBjb252ZXJ0IGl0IHRvIGEgQ0lEIHYxIGVuY29kZWQgaW4gYmFzZTMyLlxuICogQHBhcmFtIHtzdHJpbmd9IGlwZnNIYXNoIGEgcmVndWxhciBpcGZzIGhhc2ggZWl0aGVyIGEgY2lkIHYwIG9yIHYxICh2MSB3aWxsIHJlbWFpbiB1bmNoYW5nZWQpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgaXBmcyBoYXNoIGFzIGEgY2lkIHYxXG4gKi9cbmNvbnN0IGNpZFYwVG9WMUJhc2UzMiA9IChpcGZzSGFzaCkgPT4ge1xuXHRsZXQgY2lkID0gbmV3IENJRChpcGZzSGFzaCk7XG5cdGlmIChjaWQudmVyc2lvbiA9PT0gMCkge1xuXHRcdGNpZCA9IGNpZC50b1YxKCk7XG5cdH1cblx0cmV0dXJuIGNpZC50b1N0cmluZygnYmFzZTMyJyk7XG59XG5cbmV4cG9ydHMuY2lkVjBUb1YxQmFzZTMyID0gY2lkVjBUb1YxQmFzZTMyO1xuIiwiLypcblx0SVNDIExpY2Vuc2VcblxuXHRDb3B5cmlnaHQgKGMpIDIwMTksIFBpZXJyZS1Mb3VpcyBEZXNwYWlnbmVcblxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuXHRjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG5cdFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcblx0TUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcblx0QU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuXHRXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cblx0QUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcblx0T1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiovXG5cbmNvbnN0IG11bHRpQyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKTtcbmNvbnN0IG11bHRpSCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJyk7XG5cbmNvbnN0IHsgaGV4U3RyaW5nVG9CdWZmZXIsIHByb2ZpbGVzIH0gPSByZXF1aXJlKCcuL3Byb2ZpbGVzJyk7XG5jb25zdCB7IGNpZEZvcldlYiwgY2lkVjBUb1YxQmFzZTMyIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0Ly9leHBvcnQgc29tZSBoZWxwZXJzIGZ1bmN0aW9uc1xuXHRoZWxwZXJzOiB7XG5cdFx0Y2lkRm9yV2ViLFxuXHRcdGNpZFYwVG9WMUJhc2UzMixcblx0fSxcblxuXHQvKipcblx0KiBEZWNvZGUgYSBDb250ZW50IEhhc2guXG5cdCogQHBhcmFtIHtzdHJpbmd9IGhhc2ggYW4gaGV4IHN0cmluZyBjb250YWluaW5nIGEgY29udGVudCBoYXNoXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgZGVjb2RlZCBjb250ZW50XG5cdCovXG5cdGRlY29kZTogZnVuY3Rpb24gKGNvbnRlbnRIYXNoKSB7XG5cdFx0Y29uc3QgYnVmZmVyID0gaGV4U3RyaW5nVG9CdWZmZXIoY29udGVudEhhc2gpO1xuXHRcdGNvbnN0IGNvZGVjID0gbXVsdGlDLmdldENvZGVjKGJ1ZmZlcik7XG5cdFx0Y29uc3QgdmFsdWUgPSBtdWx0aUMucm1QcmVmaXgoYnVmZmVyKTtcblx0XHRsZXQgcHJvZmlsZSA9IHByb2ZpbGVzW2NvZGVjXTtcblx0XHRpZiAoIXByb2ZpbGUpIHByb2ZpbGUgPSBwcm9maWxlc1snZGVmYXVsdCddO1xuXHRcdHJldHVybiBwcm9maWxlLmRlY29kZSh2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogRW5jb2RlIGFuIElQRlMgYWRkcmVzcyBpbnRvIGEgY29udGVudCBoYXNoXG5cdCogQHBhcmFtIHtzdHJpbmd9IGlwZnNIYXNoIHN0cmluZyBjb250YWluaW5nIGFuIElQRlMgYWRkcmVzc1xuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBjb250ZW50IGhhc2hcblx0Ki9cblx0ZnJvbUlwZnM6IGZ1bmN0aW9uIChpcGZzSGFzaCkge1xuXHRcdHJldHVybiB0aGlzLmVuY29kZSgnaXBmcy1ucycsIGlwZnNIYXNoKTtcblx0fSxcblxuXHQvKipcblx0KiBFbmNvZGUgYSBTa3lsaW5rIGludG8gYSBjb250ZW50IGhhc2hcblx0KiBAcGFyYW0ge3N0cmluZ30gc2t5bGluayBzdHJpbmcgY29udGFpbmluZyBhIFNreWxpbmtcblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgY29udGVudCBoYXNoXG5cdCovXG5cdGZyb21Ta3lsaW5rOiBmdW5jdGlvbiAoc2t5bGluaykge1xuXHRcdHJldHVybiB0aGlzLmVuY29kZSgnc2t5bmV0LW5zJywgc2t5bGluayk7XG5cdH0sXG5cblx0LyoqXG5cdCogRW5jb2RlIGEgU3dhcm0gYWRkcmVzcyBpbnRvIGEgY29udGVudCBoYXNoXG5cdCogQHBhcmFtIHtzdHJpbmd9IHN3YXJtSGFzaCBzdHJpbmcgY29udGFpbmluZyBhIFN3YXJtIGFkZHJlc3Ncblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgY29udGVudCBoYXNoXG5cdCovXG5cdGZyb21Td2FybTogZnVuY3Rpb24gKHN3YXJtSGFzaCkge1xuXHRcdHJldHVybiB0aGlzLmVuY29kZSgnc3dhcm0tbnMnLCBzd2FybUhhc2gpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEdlbmVyYWwgcHVycG9zZSBlbmNvZGluZyBmdW5jdGlvblxuICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlYyBcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG4gICovXG5cdGVuY29kZTogZnVuY3Rpb24gKGNvZGVjLCB2YWx1ZSkge1xuXHRcdGxldCBwcm9maWxlID0gcHJvZmlsZXNbY29kZWNdO1xuXHRcdGlmICghcHJvZmlsZSkgcHJvZmlsZSA9IHByb2ZpbGVzWydkZWZhdWx0J107XG5cdFx0Y29uc3QgZW5jb2RlZFZhbHVlID0gcHJvZmlsZS5lbmNvZGUodmFsdWUpO1xuXHRcdHJldHVybiBtdWx0aUgudG9IZXhTdHJpbmcobXVsdGlDLmFkZFByZWZpeChjb2RlYywgZW5jb2RlZFZhbHVlKSlcblx0fSxcblxuXHQvKipcblx0KiBFeHRyYWN0IHRoZSBjb2RlYyBvZiBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIGhleCBzdHJpbmcgY29udGFpbmluZyBhIGNvbnRlbnQgaGFzaFxuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIGV4dHJhY3RlZCBjb2RlY1xuXHQqL1xuXHRnZXRDb2RlYzogZnVuY3Rpb24gKGhhc2gpIHtcblx0XHRsZXQgYnVmZmVyID0gaGV4U3RyaW5nVG9CdWZmZXIoaGFzaCk7XG5cdFx0cmV0dXJuIG11bHRpQy5nZXRDb2RlYyhidWZmZXIpO1xuXHR9LFxufVxuIiwiLypcblx0SVNDIExpY2Vuc2VcblxuXHRDb3B5cmlnaHQgKGMpIDIwMTksIFBpZXJyZS1Mb3VpcyBEZXNwYWlnbmVcblxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuXHRjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG5cdFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcblx0TUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcblx0QU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuXHRXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cblx0QUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcblx0T1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiovXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKTtcbmNvbnN0IG11bHRpSCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJyk7XG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdqcy1iYXNlNjQnKVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgQnVmZmVyLCB0aGUgc3RyaW5nIGNhbiBzdGFydCB3aXRoIG9yIHdpdGhvdXQgJzB4J1xuICogQHBhcmFtIHtzdHJpbmd9IGhleCBhbiBoZXhhZGVjaW1hbCB2YWx1ZVxuICogQHJldHVybiB7QnVmZmVyfSB0aGUgcmVzdWx0aW5nIEJ1ZmZlclxuICovXG5jb25zdCBoZXhTdHJpbmdUb0J1ZmZlciA9IChoZXgpID0+IHtcblx0bGV0IHByZWZpeCA9IGhleC5zbGljZSgwLCAyKTtcblx0bGV0IHZhbHVlID0gaGV4LnNsaWNlKDIpO1xuXHRsZXQgcmVzID0gJyc7XG5cdGlmIChwcmVmaXggPT09ICcweCcpIHJlcyA9IHZhbHVlO1xuXHRlbHNlIHJlcyA9IGhleDtcblx0cmV0dXJuIG11bHRpSC5mcm9tSGV4U3RyaW5nKHJlcyk7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIElQTlMgaWRlbnRpZmllciAgdG8gc2FmZWd1YXJkIGFnYWluc3QgaW5zZWN1cmUgbmFtZXMuXG4gKiBAcGFyYW0ge0NJRH0gbmFtZSBpc2VkIGluIGlwbnMtbnNcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbmNvbnN0IGlzQ3J5cHRvZ3JhcGhpY0lQTlMgPSAgKGNpZCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgbXVsdGloYXNoIH0gPSBjaWRcbiAgICAvLyBBZGRpdGlvbmFsIGNoZWNrIGZvciBpZGVudGlmaWVycyBzaG9ydGVyXG4gICAgLy8gdGhhbiB3aGF0IGlubGluZWQgRUQyNTUxOSBwdWJrZXkgd291bGQgYmVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW5zZG9tYWlucy9lbnMtYXBwL2lzc3Vlcy84NDkjaXNzdWVjb21tZW50LTc3NzA4ODk1MFxuICAgIGlmIChtdWx0aWhhc2gubGVuZ3RoIDwgMzgpIHtcbiAgICAgIGNvbnN0IG1oID0gbXVsdGlILmRlY29kZShtdWx0aWhhc2gpXG4gICAgICAvLyBFRDI1NTE5IHB1YmtleXMgYXJlIGlubGluZWQgdXNpbmcgaWRlbnRpdHkgaGFzaCBmdW5jdGlvblxuICAgICAgLy8gYW5kIHdlIHNob3VsZCBub3Qgc2VlIGFueXRoaW5nIHNob3J0ZXIgdGhhbiB0aGF0XG4gICAgICBpZiAobWgubmFtZSA9PT0gJ2lkZW50aXR5JyAmJiBtaC5sZW5ndGggPCAzNikge1xuICAgICAgICAvLyBPbmUgY2FuIHJlYWQgaW5saW5lZCBzdHJpbmcgdmFsdWUgdmlhOlxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaXBucy1ucyBpZDonLCBTdHJpbmcobXVsdGlILmRlY29kZShuZXcgQ0lEKHZhbHVlKS5tdWx0aWhhc2gpLmRpZ2VzdCkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBvaywgQ0lEIGxvb2tzIGZpbmVcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChfKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiogbGlzdCBvZiBrbm93biBlbmNvZGluZyxcbiogZW5jb2Rpbmcgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGBzdHJpbmdgIGlucHV0LFxuKiBhbmQgcmV0dXJuIGEgYEJ1ZmZlcmAgcmVzdWx0XG4qL1xuY29uc3QgZW5jb2RlcyA9IHtcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBza3luZXQ6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBiYXNlNjQudG9VaW50OEFycmF5KHZhbHVlKVxuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIHN3YXJtOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBtdWx0aWhhc2ggPSBtdWx0aUguZW5jb2RlKGhleFN0cmluZ1RvQnVmZmVyKHZhbHVlKSwgJ2tlY2Nhay0yNTYnKTtcblx0XHRyZXR1cm4gbmV3IENJRCgxLCAnc3dhcm0tbWFuaWZlc3QnLCBtdWx0aWhhc2gpLmJ5dGVzO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIGlwZnM6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuZXcgQ0lEKHZhbHVlKS50b1YxKCkuYnl0ZXM7XG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgaXBuczogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSlcbiAgICBpZiAoIWlzQ3J5cHRvZ3JhcGhpY0lQTlMoY2lkKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignaXBucy1ucyBhbGxvd3Mgb25seSB2YWxpZCBjcnlwdG9ncmFwaGljIGxpYnAycC1rZXkgaWRlbnRpZmllcnMsIHRyeSB1c2luZyBFRDI1NTE5IHB1YmtleSBpbnN0ZWFkJylcbiAgICB9XG4gICAgLy8gUmVwcmVzZW50IElQTlMgbmFtZSBhcyBhIENJRCB3aXRoIGxpYnAycC1rZXkgY29kZWNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL3NwZWNzL2Jsb2IvbWFzdGVyL1JGQy8wMDAxLXRleHQtcGVlcmlkLWNpZC5tZFxuICAgIHJldHVybiBuZXcgQ0lEKDEsICdsaWJwMnAta2V5JywgY2lkLm11bHRpaGFzaCkuYnl0ZXNcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICB1dGY4OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4Jyk7XG4gIH0sXG59O1xuXG4vKiogXG4qIGxpc3Qgb2Yga25vd24gZGVjb2RpbmcsXG4qIGRlY29kaW5nIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBgQnVmZmVyYCBpbnB1dCxcbiogYW5kIHJldHVybiBhIGBzdHJpbmdgIHJlc3VsdFxuKi9cbmNvbnN0IGRlY29kZXMgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBcbiAgKi9cbiAgaGV4TXVsdGlIYXNoOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKTtcbiAgICByZXR1cm4gbXVsdGlILmRlY29kZShjaWQubXVsdGloYXNoKS5kaWdlc3QudG9TdHJpbmcoJ2hleCcpO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIGlwZnM6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQodmFsdWUpLnRvVjEoKTtcbiAgICByZXR1cm4gY2lkLnRvU3RyaW5nKGNpZC5jb2RlYyA9PT0gJ2xpYnAycC1rZXknID8gJ2Jhc2UzNicgOiAnYmFzZTMyJylcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICBpcG5zOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKS50b1YxKClcbiAgICBpZiAoIWlzQ3J5cHRvZ3JhcGhpY0lQTlMoY2lkKSkge1xuICAgICAgICAvLyBWYWx1ZSBpcyBub3QgYSBsaWJwMnAta2V5LCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nXG4gICAgICAgIGNvbnNvbGUud2FybignW2Vuc2RvbWFpbnMvY29udGVudC1oYXNoXSB1c2Ugb2Ygbm9uLWNyeXB0b2dyYXBoaWMgaWRlbnRpZmllcnMgaW4gaXBucy1ucyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQsIG1pZ3JhdGUgdG8gRUQyNTUxOSBsaWJwMnAta2V5JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyhtdWx0aUguZGVjb2RlKG5ldyBDSUQodmFsdWUpLm11bHRpaGFzaCkuZGlnZXN0KVxuICAgICAgICAvLyBUT0RPOiBzdGFydCB0aHJvd2luZyBhbiBlcnJvciAoYWZ0ZXIgc29tZSBkZXByZWNhdGlvbiBwZXJpb2QpXG4gICAgICAgIC8vIHRocm93IEVycm9yKCdpcG5zLW5zIGFsbG93cyBvbmx5IHZhbGlkIGNyeXB0b2dyYXBoaWMgbGlicDJwLWtleSBpZGVudGlmaWVycywgdHJ5IHVzaW5nIEVEMjU1MTkgcHVia2V5IGluc3RlYWQnKVxuICAgIH1cbiAgICByZXR1cm4gY2lkLnRvU3RyaW5nKCdiYXNlMzYnKVxuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIHV0Zjg6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygndXRmOCcpO1xuICB9LFxuICBiYXNlNjQ6ICh2YWx1ZSkgPT4ge1xuICAgIC8vIGB0cnVlYCBvcHRpb24gbWFrZXMgaXQgVVJMIHNhZmUgKHJlcGxhY2VzIC8gYW5kICsgd2l0aCAtIGFuZCBfIClcbiAgICByZXR1cm4gYmFzZTY0LmZyb21VaW50OEFycmF5KHZhbHVlLCB0cnVlKVxuICB9XG59O1xuXG4vKipcbiogbGlzdCBvZiBrbm93biBlbmNvZGluZy9kZWNvZGluZyBmb3IgYSBnaXZlbiBjb2RlYyxcbiogYGVuY29kZWAgc2hvdWxkIGJlIGNob3NlbiBhbW9uZyB0aGUgYGVuY29kZXNgIGZ1bmN0aW9uc1xuKiBgZGVjb2RlYCBzaG91bGQgYmUgY2hvc2VuIGFtb25nIHRoZSBgZGVjb2Rlc2AgZnVuY3Rpb25zXG4qL1xuY29uc3QgcHJvZmlsZXMgPSB7XG4gICdza3luZXQtbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnNreW5ldCxcbiAgICBkZWNvZGU6IGRlY29kZXMuYmFzZTY0LFxuICB9LFxuICAnc3dhcm0tbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnN3YXJtLFxuICAgIGRlY29kZTogZGVjb2Rlcy5oZXhNdWx0aUhhc2gsXG4gIH0sXG4gICdpcGZzLW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5pcGZzLFxuICAgIGRlY29kZTogZGVjb2Rlcy5pcGZzLFxuICB9LFxuICAnaXBucy1ucyc6IHtcbiAgICBlbmNvZGU6IGVuY29kZXMuaXBucyxcbiAgICBkZWNvZGU6IGRlY29kZXMuaXBucyxcbiAgfSxcbiAgJ2RlZmF1bHQnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnV0ZjgsXG4gICAgZGVjb2RlOiBkZWNvZGVzLnV0ZjgsXG4gIH0sXG59O1xuXG5leHBvcnRzLmhleFN0cmluZ1RvQnVmZmVyID0gaGV4U3RyaW5nVG9CdWZmZXI7XG5leHBvcnRzLnByb2ZpbGVzID0gcHJvZmlsZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgSERLZXkgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaGRrZXknKSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3V0aWwnKTtcbnZhciBybHAgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmxwJykpO1xudmFyIHR4ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKTtcbnZhciBiY1VyUmVnaXN0cnlFdGggPSByZXF1aXJlKCdAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGgnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xuXG5jb25zdCBrZXlyaW5nVHlwZSA9IFwiUVIgSGFyZHdhcmUgV2FsbGV0IERldmljZVwiO1xuY29uc3QgcGF0aEJhc2UgPSBcIm1cIjtcbmNvbnN0IE1BWF9JTkRFWCA9IDEwMDA7XG5jb25zdCBERUZBVUxUX0NISUxEUkVOX1BBVEggPSBcIjAvKlwiO1xudmFyIEtFWVJJTkdfTU9ERTtcblxuKGZ1bmN0aW9uIChLRVlSSU5HX01PREUpIHtcbiAgS0VZUklOR19NT0RFW1wiaGRcIl0gPSBcImhkXCI7XG4gIEtFWVJJTkdfTU9ERVtcInB1YmtleVwiXSA9IFwicHVia2V5XCI7XG59KShLRVlSSU5HX01PREUgfHwgKEtFWVJJTkdfTU9ERSA9IHt9KSk7XG5cbnZhciBLRVlSSU5HX0FDQ09VTlQ7XG5cbihmdW5jdGlvbiAoS0VZUklOR19BQ0NPVU5UKSB7XG4gIEtFWVJJTkdfQUNDT1VOVFtcInN0YW5kYXJkXCJdID0gXCJhY2NvdW50LnN0YW5kYXJkXCI7XG4gIEtFWVJJTkdfQUNDT1VOVFtcImxlZGdlcl9saXZlXCJdID0gXCJhY2NvdW50LmxlZGdlcl9saXZlXCI7XG4gIEtFWVJJTkdfQUNDT1VOVFtcImxlZGdlcl9sZWdhY3lcIl0gPSBcImFjY291bnQubGVkZ2VyX2xlZ2FjeVwiO1xufSkoS0VZUklOR19BQ0NPVU5UIHx8IChLRVlSSU5HX0FDQ09VTlQgPSB7fSkpO1xuXG5jbGFzcyBCYXNlS2V5cmluZyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy52ZXJzaW9uID0gMTtcblxuICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb24gPSAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZXh0ZW5kczogbWV0aG9kIGdldEludGVyYWN0aW9uIG5vdCBpbXBsZW1lbnRlZCwgcGxlYXNlIGV4dGVuZCBCYXNlS2V5cmluZyBieSBvdmVyd3JpdGluZyB0aGlzIG1ldGhvZC5cIik7XG4gICAgfTtcblxuICAgIHRoaXMudHlwZSA9IGtleXJpbmdUeXBlO1xuXG4gICAgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlID0gYXN5bmMgKF9yZXF1ZXN0SWQsIHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbikgPT4ge1xuICAgICAgY29uc3QgZXRoU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlcXVlc3RTaWduYXR1cmUoc2lnblJlcXVlc3QsIHJlcXVlc3RUaXRsZSwgcmVxdWVzdERlc2NyaXB0aW9uKTtcbiAgICAgIGNvbnN0IHJlcXVlc3RJZEJ1ZmZlciA9IGV0aFNpZ25hdHVyZS5nZXRSZXF1ZXN0SWQoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFNpZ25hdHVyZS5nZXRTaWduYXR1cmUoKTtcblxuICAgICAgaWYgKHJlcXVlc3RJZEJ1ZmZlcikge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnN0cmluZ2lmeShyZXF1ZXN0SWRCdWZmZXIpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0SWQgIT09IF9yZXF1ZXN0SWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogcmVhZCBzaWduYXR1cmUgZXJyb3I6IG1pc21hdGNoZWQgcmVxdWVzdElkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHIgPSBzaWduYXR1cmUuc2xpY2UoMCwgMzIpO1xuICAgICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICAgICAgY29uc3QgdiA9IHNpZ25hdHVyZS5zbGljZSg2NCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB2XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLl9fcmVhZENyeXB0b0hES2V5ID0gY3J5cHRvSERLZXkgPT4ge1xuICAgICAgdmFyIF9jcnlwdG9IREtleSRnZXRPcmlnaSwgX2NyeXB0b0hES2V5JGdldENoaWxkO1xuXG4gICAgICBjb25zdCBoZFBhdGggPSBgbS8ke2NyeXB0b0hES2V5LmdldE9yaWdpbigpLmdldFBhdGgoKX1gO1xuICAgICAgY29uc3QgeGZwID0gKF9jcnlwdG9IREtleSRnZXRPcmlnaSA9IGNyeXB0b0hES2V5LmdldE9yaWdpbigpLmdldFNvdXJjZUZpbmdlcnByaW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvSERLZXkkZ2V0T3JpZ2kudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICBjb25zdCBjaGlsZHJlblBhdGggPSAoKF9jcnlwdG9IREtleSRnZXRDaGlsZCA9IGNyeXB0b0hES2V5LmdldENoaWxkcmVuKCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvSERLZXkkZ2V0Q2hpbGQuZ2V0UGF0aCgpKSB8fCBERUZBVUxUX0NISUxEUkVOX1BBVEg7XG4gICAgICBjb25zdCBuYW1lID0gY3J5cHRvSERLZXkuZ2V0TmFtZSgpO1xuXG4gICAgICBpZiAoY3J5cHRvSERLZXkuZ2V0Tm90ZSgpID09PSBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQpIHtcbiAgICAgICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IEtFWVJJTkdfQUNDT1VOVC5zdGFuZGFyZDtcbiAgICAgIH0gZWxzZSBpZiAoY3J5cHRvSERLZXkuZ2V0Tm90ZSgpID09PSBLRVlSSU5HX0FDQ09VTlQubGVkZ2VyX2xlZ2FjeSkge1xuICAgICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9sZWdhY3k7XG4gICAgICB9XG5cbiAgICAgIGlmICgheGZwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1oZGtleSwgY2Fubm90IGdldCBzb3VyY2UgZmluZ2VycHJpbnRcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhwdWIgPSBjcnlwdG9IREtleS5nZXRCaXAzMktleSgpO1xuICAgICAgdGhpcy54ZnAgPSB4ZnA7XG4gICAgICB0aGlzLnhwdWIgPSB4cHViO1xuICAgICAgdGhpcy5oZFBhdGggPSBoZFBhdGg7XG4gICAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IGNoaWxkcmVuUGF0aDtcblxuICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCAmJiBuYW1lICE9PSBcIlwiKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLl9fcmVhZENyeXB0b0FjY291bnQgPSBjcnlwdG9BY2NvdW50ID0+IHtcbiAgICAgIHZhciBfY3J5cHRvQWNjb3VudCRnZXRNYXMsIF9jcnlwdG9BY2NvdW50JGdldE91dDtcblxuICAgICAgY29uc3QgeGZwID0gKF9jcnlwdG9BY2NvdW50JGdldE1hcyA9IGNyeXB0b0FjY291bnQuZ2V0TWFzdGVyRmluZ2VycHJpbnQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jcnlwdG9BY2NvdW50JGdldE1hcy50b1N0cmluZyhcImhleFwiKTtcblxuICAgICAgaWYgKCF4ZnApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIGNhbm5vdCBnZXQgbWFzdGVyIGZpbmdlcnByaW50XCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnhmcCA9IHhmcDtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBjcnlwdG9BY2NvdW50LmdldE91dHB1dERlc2NyaXB0b3JzKCk7XG5cbiAgICAgIGlmICghb3V0cHV0cyB8fCBvdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8tYWNjb3VudCwgbm8gY3J5cHRvIG91dHB1dCBmb3VuZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG91dHB1dHMubGVuZ3RoICUgNSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogb25seSBzdXBwb3J0IDV4IHB1YmtleSBhY2NvdW50cyBmb3Igbm93XCIpO1xuICAgICAgfVxuXG4gICAgICAoX2NyeXB0b0FjY291bnQkZ2V0T3V0ID0gY3J5cHRvQWNjb3VudC5nZXRPdXRwdXREZXNjcmlwdG9ycygpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0FjY291bnQkZ2V0T3V0LmZvckVhY2gob2QgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNyeXB0b0hES2V5ID0gb2QuZ2V0SERLZXkoKTtcblxuICAgICAgICAgIGlmIChjcnlwdG9IREtleSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY3J5cHRvSERLZXkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gYE0vJHtjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRQYXRoKCl9YDtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBcIjB4XCIgKyB1dGlsLnB1YmxpY1RvQWRkcmVzcyhrZXksIHRydWUpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gY3J5cHRvSERLZXkuZ2V0TmFtZSgpO1xuXG4gICAgICAgICAgICBpZiAoY3J5cHRvSERLZXkuZ2V0Tm90ZSgpID09PSBLRVlSSU5HX0FDQ09VTlQubGVkZ2VyX2xpdmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGl2ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucGF0aHNbdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wYXRoc1t1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IHBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogJHtlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH07IC8vIHByaXZhdGUgX19yZWFkTGVkZ2VyTGl2ZUFjY291bnRzID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldEludGVyYWN0aW9uKCkucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50KCk7XG4gICAgLy8gICAgIGlmIChyZXN1bHQuZ2V0UmVnaXN0cnlUeXBlKCkgPT09IGV4dGVuZC5SZWdpc3RyeVR5cGVzLkNSWVBUT19BQ0NPVU5UKSB7XG4gICAgLy8gICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50KHJlc3VsdCBhcyBDcnlwdG9BY2NvdW50KTtcbiAgICAvLyAgICAgICAgIGlmICghY2hhbmdlZCkge1xuICAgIC8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgI0tleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQubm9fbmV3X2FjY291bnRgKTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC51bmV4cGVjdGVkX3VydHlwZWApO1xuICAgIC8vICAgICB9XG4gICAgLy8gfTtcblxuXG4gICAgdGhpcy5nZXROYW1lID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRBY2NvdW50VG9VbmxvY2sgPSBpbmRleCA9PiB7XG4gICAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgfTtcblxuICAgIHRoaXMuX19nZXROb3JtYWxQYWdlID0gYXN5bmMgaW5jcmVtZW50ID0+IHtcbiAgICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnQ7XG5cbiAgICAgIGlmICh0aGlzLnBhZ2UgPD0gMCkge1xuICAgICAgICB0aGlzLnBhZ2UgPSAxO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbmRleGVzW3V0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID0gaTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH07XG5cbiAgICB0aGlzLl9fZ2V0TGVkZ2VyTGl2ZVBhZ2UgPSBhc3luYyBpbmNyZW1lbnQgPT4ge1xuICAgICAgY29uc3QgbmV4dFBhZ2UgPSB0aGlzLnBhZ2UgKyBpbmNyZW1lbnQ7XG4gICAgICBjb25zdCBmcm9tID0gKG5leHRQYWdlIC0gMSkgKiB0aGlzLnBlclBhZ2U7XG4gICAgICBjb25zdCB0byA9IGZyb20gKyB0aGlzLnBlclBhZ2U7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKTtcbiAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50O1xuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH07XG5cbiAgICB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleCA9IGFzeW5jIChwYiwgaSkgPT4ge1xuICAgICAgaWYgKHRoaXMua2V5cmluZ01vZGUgPT09IEtFWVJJTkdfTU9ERS5oZCkge1xuICAgICAgICB0aGlzLmNoZWNrS2V5cmluZygpO1xuXG4gICAgICAgIGlmICghdGhpcy5oZGspIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5oZGsgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkodGhpcy54cHViKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aCA9IHRoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoXCIqXCIsIFN0cmluZyhpKSkucmVwbGFjZSgvXFwqL2csIFwiMFwiKTtcbiAgICAgICAgY29uc3QgZGtleSA9IHRoaXMuaGRrLmRlcml2ZShgJHtwYn0vJHtjaGlsZHJlblBhdGh9YCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBcIjB4XCIgKyB1dGlsLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgIHJldHVybiB1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModGhpcy5wYXRocylbaV07XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiB1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlzdG9uZUVycm9yI3B1YmtleV9hY2NvdW50Lm5vX2V4cGVjdGVkX2FjY291bnRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vY29tbW9uIHByb3BzXG5cblxuICAgIHRoaXMucGFnZSA9IDA7XG4gICAgdGhpcy5wZXJQYWdlID0gNTtcbiAgICB0aGlzLmFjY291bnRzID0gW107XG4gICAgdGhpcy5jdXJyZW50QWNjb3VudCA9IDA7XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwO1xuICAgIHRoaXMubmFtZSA9IFwiUVIgSGFyZHdhcmVcIjtcbiAgICB0aGlzLmtleXJpbmdNb2RlID0gS0VZUklOR19NT0RFLmhkO1xuICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQ7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlOyAvL2hkIHByb3BzO1xuXG4gICAgdGhpcy54ZnAgPSBcIlwiO1xuICAgIHRoaXMueHB1YiA9IFwiXCI7XG4gICAgdGhpcy5oZFBhdGggPSBcIlwiO1xuICAgIHRoaXMuY2hpbGRyZW5QYXRoID0gREVGQVVMVF9DSElMRFJFTl9QQVRIO1xuICAgIHRoaXMuaW5kZXhlcyA9IHt9OyAvL3B1YmtleSBwcm9wcztcblxuICAgIHRoaXMucGF0aHMgPSB7fTtcbiAgICB0aGlzLmRlc2VyaWFsaXplKG9wdHMpO1xuICB9IC8vaW5pdGlhbCByZWFkXG5cblxuICBhc3luYyByZWFkS2V5cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldEludGVyYWN0aW9uKCkucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50KCk7XG4gICAgdGhpcy5zeW5jS2V5cmluZyhyZXN1bHQpO1xuICB9XG5cbiAgc3luY0tleXJpbmcoZGF0YSkge1xuICAgIGlmIChkYXRhLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFR5cGUoKSA9PT0gYmNVclJlZ2lzdHJ5RXRoLmV4dGVuZC5SZWdpc3RyeVR5cGVzLkNSWVBUT19IREtFWS5nZXRUeXBlKCkpIHtcbiAgICAgIHRoaXMua2V5cmluZ01vZGUgPSBLRVlSSU5HX01PREUuaGQ7XG5cbiAgICAgIHRoaXMuX19yZWFkQ3J5cHRvSERLZXkoZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5cmluZ01vZGUgPSBLRVlSSU5HX01PREUucHVia2V5O1xuXG4gICAgICB0aGlzLl9fcmVhZENyeXB0b0FjY291bnQoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tLZXlyaW5nKCkge1xuICAgIGlmICghdGhpcy54ZnAgfHwgIXRoaXMueHB1YiB8fCAhdGhpcy5oZFBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9rZXlyaW5nOiBrZXlyaW5nIG5vdCBmdWxmaWxsZWQsIHBsZWFzZSBjYWxsIGZ1bmN0aW9uIGByZWFkS2V5cmluZ2AgZmlyc3RseVwiKTtcbiAgICB9XG4gIH1cblxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAvL2NvbW1vblxuICAgICAgaW5pdGlhbGl6ZWQ6IHRoaXMuaW5pdGlhbGl6ZWQsXG4gICAgICBhY2NvdW50czogdGhpcy5hY2NvdW50cyxcbiAgICAgIGN1cnJlbnRBY2NvdW50OiB0aGlzLmN1cnJlbnRBY2NvdW50LFxuICAgICAgcGFnZTogdGhpcy5wYWdlLFxuICAgICAgcGVyUGFnZTogdGhpcy5wZXJQYWdlLFxuICAgICAga2V5cmluZ0FjY291bnQ6IHRoaXMua2V5cmluZ0FjY291bnQsXG4gICAgICBrZXlyaW5nTW9kZTogdGhpcy5rZXlyaW5nTW9kZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIHhmcDogdGhpcy54ZnAsXG4gICAgICAvL2hkXG4gICAgICB4cHViOiB0aGlzLnhwdWIsXG4gICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgICAgY2hpbGRyZW5QYXRoOiB0aGlzLmNoaWxkcmVuUGF0aCxcbiAgICAgIGluZGV4ZXM6IHRoaXMuaW5kZXhlcyxcbiAgICAgIC8vcHVia2V5XG4gICAgICBwYXRoczogdGhpcy5wYXRoc1xuICAgIH0pO1xuICB9XG5cbiAgZGVzZXJpYWxpemUob3B0cykge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICAvL2NvbW1vbiBwcm9wcztcbiAgICAgIHRoaXMuYWNjb3VudHMgPSBvcHRzLmFjY291bnRzO1xuICAgICAgdGhpcy5jdXJyZW50QWNjb3VudCA9IG9wdHMuY3VycmVudEFjY291bnQ7XG4gICAgICB0aGlzLnBhZ2UgPSBvcHRzLnBhZ2U7XG4gICAgICB0aGlzLnBlclBhZ2UgPSBvcHRzLnBlclBhZ2U7XG4gICAgICB0aGlzLm5hbWUgPSBvcHRzLm5hbWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gb3B0cy5pbml0aWFsaXplZDtcbiAgICAgIHRoaXMua2V5cmluZ01vZGUgPSBvcHRzLmtleXJpbmdNb2RlIHx8IEtFWVJJTkdfTU9ERS5oZDtcbiAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBvcHRzLmtleXJpbmdBY2NvdW50IHx8IEtFWVJJTkdfQUNDT1VOVC5zdGFuZGFyZDtcbiAgICAgIHRoaXMueGZwID0gb3B0cy54ZnA7IC8vaGQgcHJvcHM7XG5cbiAgICAgIHRoaXMueHB1YiA9IG9wdHMueHB1YjtcbiAgICAgIHRoaXMuaGRQYXRoID0gb3B0cy5oZFBhdGg7XG4gICAgICB0aGlzLmluZGV4ZXMgPSBvcHRzLmluZGV4ZXM7XG4gICAgICB0aGlzLnBhdGhzID0gb3B0cy5wYXRocztcbiAgICAgIHRoaXMuY2hpbGRyZW5QYXRoID0gb3B0cy5jaGlsZHJlblBhdGggfHwgREVGQVVMVF9DSElMRFJFTl9QQVRIO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnRBY2NvdW50KGluZGV4KSB7XG4gICAgdGhpcy5jdXJyZW50QWNjb3VudCA9IGluZGV4O1xuICB9XG5cbiAgZ2V0Q3VycmVudEFjY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEFjY291bnQ7XG4gIH1cblxuICBnZXRDdXJyZW50QWRkcmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50c1t0aGlzLmN1cnJlbnRBY2NvdW50XTtcbiAgfVxuXG4gIGFzeW5jIGFkZEFjY291bnRzKG4gPSAxKSB7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMudW5sb2NrZWRBY2NvdW50O1xuICAgIGNvbnN0IHRvID0gZnJvbSArIG47XG4gICAgY29uc3QgbmV3QWNjb3VudHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKTtcbiAgICAgIG5ld0FjY291bnRzLnB1c2goYWRkcmVzcyk7XG4gICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQrKztcbiAgICB9XG5cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5jb25jYXQobmV3QWNjb3VudHMpO1xuICAgIHJldHVybiB0aGlzLmFjY291bnRzO1xuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlKCkge1xuICAgIHRoaXMucGFnZSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpO1xuICB9XG5cbiAgZ2V0TmV4dFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpO1xuICB9XG5cbiAgZ2V0UHJldmlvdXNQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSk7XG4gIH1cblxuICBhc3luYyBfX2dldFBhZ2UoaW5jcmVtZW50KSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlYWRLZXlyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2V5cmluZ01vZGUgPT09IEtFWVJJTkdfTU9ERS5oZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19nZXROb3JtYWxQYWdlKGluY3JlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZ2V0TGVkZ2VyTGl2ZVBhZ2UoaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICBnZXRBY2NvdW50cygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMpO1xuICB9XG5cbiAgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRzLm1hcChhID0+IGEudG9Mb3dlckNhc2UoKSkuaW5jbHVkZXMoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO1xuICAgIH1cblxuICAgIHRoaXMuYWNjb3VudHMgPSB0aGlzLmFjY291bnRzLmZpbHRlcihhID0+IGEudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eCQxKSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eCQxLnR5cGUgPT09IDAgPyBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHJhbnNhY3Rpb24gOiBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHlwZWRUcmFuc2FjdGlvbjtcbiAgICBsZXQgbWVzc2FnZVRvU2lnbjtcblxuICAgIGlmICh0eCQxLnR5cGUgPT09IDApIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSBCdWZmZXIuZnJvbShybHAuZW5jb2RlKHR4JDEuZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZVRvU2lnbiA9IHR4JDEuZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIodHgkMS5jb21tb24uY2hhaW5JZCgpKTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnY0KCk7XG4gICAgY29uc3QgZXRoU2lnblJlcXVlc3QgPSBiY1VyUmVnaXN0cnlFdGguRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChtZXNzYWdlVG9TaWduLCBkYXRhVHlwZSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCBjaGFpbklkKTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsIFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGUgdHJhbnNhY3Rpb24sIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiB0eC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh7IC4uLnR4JDEudG9KU09OKCksXG4gICAgICB0eXBlOiB0eCQxLnR5cGUsXG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9LCB7XG4gICAgICBjb21tb246IHR4JDEuY29tbW9uXG4gICAgfSk7XG4gIH1cblxuICBzaWduTWVzc2FnZSh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpO1xuICB9XG5cbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZSh3aXRoQWNjb3VudCwgbWVzc2FnZUhleCkge1xuICAgIGNvbnN0IHVzaWduZWRIZXggPSB1dGlsLnN0cmlwSGV4UHJlZml4KG1lc3NhZ2VIZXgpO1xuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyh3aXRoQWNjb3VudCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20odXNpZ25lZEhleCwgXCJoZXhcIiksIGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS5wZXJzb25hbE1lc3NhZ2UsIGhkUGF0aCwgdGhpcy54ZnAsIHJlcXVlc3RJZCwgdW5kZWZpbmVkLCB3aXRoQWNjb3VudCk7XG4gICAgY29uc3Qge1xuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB2XG4gICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShyZXF1ZXN0SWQsIGV0aFNpZ25SZXF1ZXN0LCBcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBtZXNzYWdlLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gXCIweFwiICsgQnVmZmVyLmNvbmNhdChbciwgcywgdl0pLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG5cbiAgYXN5bmMgc2lnblR5cGVkRGF0YSh3aXRoQWNjb3VudCwgdHlwZWREYXRhKSB7XG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnY0KCk7XG4gICAgY29uc3QgZXRoU2lnblJlcXVlc3QgPSBiY1VyUmVnaXN0cnlFdGguRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh0eXBlZERhdGEpLCBcInV0Zi04XCIpLCBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHlwZWREYXRhLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIHVuZGVmaW5lZCwgd2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCAnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoaXMgZGF0YSwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7XG4gICAgcmV0dXJuIFwiMHhcIiArIEJ1ZmZlci5jb25jYXQoW3IsIHMsIHZdKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuXG4gIGFzeW5jIF9wYXRoRnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IHV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4ZXNbY2hlY2tzdW1tZWRBZGRyZXNzXTtcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9JTkRFWDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gKGF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKSkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWRkcmVzc1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGAke3RoaXMuaGRQYXRofS8ke3RoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoXCIqXCIsIGluZGV4LnRvU3RyaW5nKCkpLnJlcGxhY2UoL1xcKi9nLCBcIjBcIil9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hlY2tzdW1tZWRBZGRyZXNzID0gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGhzW2NoZWNrc3VtbWVkQWRkcmVzc107XG5cbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfVxuXG59XG5CYXNlS2V5cmluZy50eXBlID0ga2V5cmluZ1R5cGU7XG5cbmV4cG9ydHMuQmFzZUtleXJpbmcgPSBCYXNlS2V5cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtZXRoLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdCxyLGk9ZShyZXF1aXJlKFwiaGRrZXlcIikpLHM9cmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIiksbj1lKHJlcXVpcmUoXCJybHBcIikpLGE9cmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpLG89cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aFwiKSxoPXJlcXVpcmUoXCJ1dWlkXCIpOyFmdW5jdGlvbihlKXtlLmhkPVwiaGRcIixlLnB1YmtleT1cInB1YmtleVwifSh0fHwodD17fSkpLGZ1bmN0aW9uKGUpe2Uuc3RhbmRhcmQ9XCJhY2NvdW50LnN0YW5kYXJkXCIsZS5sZWRnZXJfbGl2ZT1cImFjY291bnQubGVkZ2VyX2xpdmVcIixlLmxlZGdlcl9sZWdhY3k9XCJhY2NvdW50LmxlZGdlcl9sZWdhY3lcIn0ocnx8KHI9e30pKTtjbGFzcyBje2NvbnN0cnVjdG9yKGUpe3RoaXMudmVyc2lvbj0xLHRoaXMuZ2V0SW50ZXJhY3Rpb249KCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZXh0ZW5kczogbWV0aG9kIGdldEludGVyYWN0aW9uIG5vdCBpbXBsZW1lbnRlZCwgcGxlYXNlIGV4dGVuZCBCYXNlS2V5cmluZyBieSBvdmVyd3JpdGluZyB0aGlzIG1ldGhvZC5cIil9LHRoaXMudHlwZT1cIlFSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2VcIix0aGlzLnJlcXVlc3RTaWduYXR1cmU9YXN5bmMoZSx0LHIsaSk9Pntjb25zdCBzPWF3YWl0IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXF1ZXN0U2lnbmF0dXJlKHQscixpKSxuPXMuZ2V0UmVxdWVzdElkKCksYT1zLmdldFNpZ25hdHVyZSgpO2lmKG4mJmguc3RyaW5naWZ5KG4pIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogcmVhZCBzaWduYXR1cmUgZXJyb3I6IG1pc21hdGNoZWQgcmVxdWVzdElkXCIpO3JldHVybntyOmEuc2xpY2UoMCwzMiksczphLnNsaWNlKDMyLDY0KSx2OmEuc2xpY2UoNjQpfX0sdGhpcy5fX3JlYWRDcnlwdG9IREtleT1lPT57dmFyIHQsaTtjb25zdCBzPVwibS9cIitlLmdldE9yaWdpbigpLmdldFBhdGgoKSxuPW51bGw9PSh0PWUuZ2V0T3JpZ2luKCkuZ2V0U291cmNlRmluZ2VycHJpbnQoKSk/dm9pZCAwOnQudG9TdHJpbmcoXCJoZXhcIiksYT0obnVsbD09KGk9ZS5nZXRDaGlsZHJlbigpKT92b2lkIDA6aS5nZXRQYXRoKCkpfHxcIjAvKlwiLG89ZS5nZXROYW1lKCk7aWYoZS5nZXROb3RlKCk9PT1yLnN0YW5kYXJkP3RoaXMua2V5cmluZ0FjY291bnQ9ci5zdGFuZGFyZDplLmdldE5vdGUoKT09PXIubGVkZ2VyX2xlZ2FjeSYmKHRoaXMua2V5cmluZ0FjY291bnQ9ci5sZWRnZXJfbGVnYWN5KSwhbil0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8taGRrZXksIGNhbm5vdCBnZXQgc291cmNlIGZpbmdlcnByaW50XCIpO2NvbnN0IGg9ZS5nZXRCaXAzMktleSgpO3RoaXMueGZwPW4sdGhpcy54cHViPWgsdGhpcy5oZFBhdGg9cyx0aGlzLmNoaWxkcmVuUGF0aD1hLHZvaWQgMCE9PW8mJlwiXCIhPT1vJiYodGhpcy5uYW1lPW8pLHRoaXMuaW5pdGlhbGl6ZWQ9ITB9LHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudD1lPT57dmFyIHQsaTtjb25zdCBuPW51bGw9PSh0PWUuZ2V0TWFzdGVyRmluZ2VycHJpbnQoKSk/dm9pZCAwOnQudG9TdHJpbmcoXCJoZXhcIik7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIGNhbm5vdCBnZXQgbWFzdGVyIGZpbmdlcnByaW50XCIpO3RoaXMueGZwPW4sdGhpcy5pbml0aWFsaXplZD0hMDtsZXQgYT0hMTtjb25zdCBvPWUuZ2V0T3V0cHV0RGVzY3JpcHRvcnMoKTtpZighb3x8MD09PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBubyBjcnlwdG8gb3V0cHV0IGZvdW5kXCIpO2lmKG8ubGVuZ3RoJTUhPTApdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IG9ubHkgc3VwcG9ydCA1eCBwdWJrZXkgYWNjb3VudHMgZm9yIG5vd1wiKTtyZXR1cm4gbnVsbD09KGk9ZS5nZXRPdXRwdXREZXNjcmlwdG9ycygpKXx8aS5mb3JFYWNoKGU9Pnt0cnl7Y29uc3QgdD1lLmdldEhES2V5KCk7aWYodCl7Y29uc3QgZT10LmdldEtleSgpLGk9XCJNL1wiK3QuZ2V0T3JpZ2luKCkuZ2V0UGF0aCgpLG49XCIweFwiK3MucHVibGljVG9BZGRyZXNzKGUsITApLnRvU3RyaW5nKFwiaGV4XCIpO3RoaXMubmFtZT10LmdldE5hbWUoKSx0LmdldE5vdGUoKT09PXIubGVkZ2VyX2xpdmUmJih0aGlzLmtleXJpbmdBY2NvdW50PXIubGVkZ2VyX2xpdmUpLHZvaWQgMD09PXRoaXMucGF0aHNbcy50b0NoZWNrc3VtQWRkcmVzcyhuKV0mJihhPSEwKSx0aGlzLnBhdGhzW3MudG9DaGVja3N1bUFkZHJlc3MobildPWl9fWNhdGNoKGUpe3Rocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBcIitlKX19KSxhfSx0aGlzLmdldE5hbWU9KCk9PnRoaXMubmFtZSx0aGlzLnNldEFjY291bnRUb1VubG9jaz1lPT57dGhpcy51bmxvY2tlZEFjY291bnQ9cGFyc2VJbnQoZSwxMCl9LHRoaXMuX19nZXROb3JtYWxQYWdlPWFzeW5jIGU9Pnt0aGlzLnBhZ2UrPWUsdGhpcy5wYWdlPD0wJiYodGhpcy5wYWdlPTEpO2NvbnN0IHQ9KHRoaXMucGFnZS0xKSp0aGlzLnBlclBhZ2Uscj10K3RoaXMucGVyUGFnZSxpPVtdO2ZvcihsZXQgZT10O2U8cjtlKyspe2NvbnN0IHQ9YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSk7aS5wdXNoKHthZGRyZXNzOnQsYmFsYW5jZTpudWxsLGluZGV4OmV9KSx0aGlzLmluZGV4ZXNbcy50b0NoZWNrc3VtQWRkcmVzcyh0KV09ZX1yZXR1cm4gaX0sdGhpcy5fX2dldExlZGdlckxpdmVQYWdlPWFzeW5jIGU9Pntjb25zdCB0PSh0aGlzLnBhZ2UrZS0xKSp0aGlzLnBlclBhZ2Uscj10K3RoaXMucGVyUGFnZSxpPVtdO2ZvcihsZXQgZT10O2U8cjtlKyspe2NvbnN0IHQ9YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSk7aS5wdXNoKHthZGRyZXNzOnQsYmFsYW5jZTpudWxsLGluZGV4OmV9KX1yZXR1cm4gdGhpcy5wYWdlKz1lLGl9LHRoaXMuX19hZGRyZXNzRnJvbUluZGV4PWFzeW5jKGUscik9PntpZih0aGlzLmtleXJpbmdNb2RlPT09dC5oZCl7dGhpcy5jaGVja0tleXJpbmcoKSx0aGlzLmhka3x8KHRoaXMuaGRrPWkuZnJvbUV4dGVuZGVkS2V5KHRoaXMueHB1YikpO2NvbnN0IHQ9dGhpcy5jaGlsZHJlblBhdGgucmVwbGFjZShcIipcIixTdHJpbmcocikpLnJlcGxhY2UoL1xcKi9nLFwiMFwiKSxuPXRoaXMuaGRrLmRlcml2ZShgJHtlfS8ke3R9YCksYT1cIjB4XCIrcy5wdWJsaWNUb0FkZHJlc3Mobi5wdWJsaWNLZXksITApLnRvU3RyaW5nKFwiaGV4XCIpO3JldHVybiBzLnRvQ2hlY2tzdW1BZGRyZXNzKGEpfXtjb25zdCBlPU9iamVjdC5rZXlzKHRoaXMucGF0aHMpW3JdO2lmKGUpcmV0dXJuIHMudG9DaGVja3N1bUFkZHJlc3MoZSk7dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50XCIpfX0sdGhpcy5wYWdlPTAsdGhpcy5wZXJQYWdlPTUsdGhpcy5hY2NvdW50cz1bXSx0aGlzLmN1cnJlbnRBY2NvdW50PTAsdGhpcy51bmxvY2tlZEFjY291bnQ9MCx0aGlzLm5hbWU9XCJRUiBIYXJkd2FyZVwiLHRoaXMua2V5cmluZ01vZGU9dC5oZCx0aGlzLmtleXJpbmdBY2NvdW50PXIuc3RhbmRhcmQsdGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLnhmcD1cIlwiLHRoaXMueHB1Yj1cIlwiLHRoaXMuaGRQYXRoPVwiXCIsdGhpcy5jaGlsZHJlblBhdGg9XCIwLypcIix0aGlzLmluZGV4ZXM9e30sdGhpcy5wYXRocz17fSx0aGlzLmRlc2VyaWFsaXplKGUpfWFzeW5jIHJlYWRLZXlyaW5nKCl7Y29uc3QgZT1hd2FpdCB0aGlzLmdldEludGVyYWN0aW9uKCkucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50KCk7dGhpcy5zeW5jS2V5cmluZyhlKX1zeW5jS2V5cmluZyhlKXtlLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFR5cGUoKT09PW8uZXh0ZW5kLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZLmdldFR5cGUoKT8odGhpcy5rZXlyaW5nTW9kZT10LmhkLHRoaXMuX19yZWFkQ3J5cHRvSERLZXkoZSkpOih0aGlzLmtleXJpbmdNb2RlPXQucHVia2V5LHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChlKSl9Y2hlY2tLZXlyaW5nKCl7aWYoIXRoaXMueGZwfHwhdGhpcy54cHVifHwhdGhpcy5oZFBhdGgpdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2tleXJpbmc6IGtleXJpbmcgbm90IGZ1bGZpbGxlZCwgcGxlYXNlIGNhbGwgZnVuY3Rpb24gYHJlYWRLZXlyaW5nYCBmaXJzdGx5XCIpfXNlcmlhbGl6ZSgpe3JldHVybiBQcm9taXNlLnJlc29sdmUoe2luaXRpYWxpemVkOnRoaXMuaW5pdGlhbGl6ZWQsYWNjb3VudHM6dGhpcy5hY2NvdW50cyxjdXJyZW50QWNjb3VudDp0aGlzLmN1cnJlbnRBY2NvdW50LHBhZ2U6dGhpcy5wYWdlLHBlclBhZ2U6dGhpcy5wZXJQYWdlLGtleXJpbmdBY2NvdW50OnRoaXMua2V5cmluZ0FjY291bnQsa2V5cmluZ01vZGU6dGhpcy5rZXlyaW5nTW9kZSxuYW1lOnRoaXMubmFtZSx2ZXJzaW9uOnRoaXMudmVyc2lvbix4ZnA6dGhpcy54ZnAseHB1Yjp0aGlzLnhwdWIsaGRQYXRoOnRoaXMuaGRQYXRoLGNoaWxkcmVuUGF0aDp0aGlzLmNoaWxkcmVuUGF0aCxpbmRleGVzOnRoaXMuaW5kZXhlcyxwYXRoczp0aGlzLnBhdGhzfSl9ZGVzZXJpYWxpemUoZSl7ZSYmKHRoaXMuYWNjb3VudHM9ZS5hY2NvdW50cyx0aGlzLmN1cnJlbnRBY2NvdW50PWUuY3VycmVudEFjY291bnQsdGhpcy5wYWdlPWUucGFnZSx0aGlzLnBlclBhZ2U9ZS5wZXJQYWdlLHRoaXMubmFtZT1lLm5hbWUsdGhpcy5pbml0aWFsaXplZD1lLmluaXRpYWxpemVkLHRoaXMua2V5cmluZ01vZGU9ZS5rZXlyaW5nTW9kZXx8dC5oZCx0aGlzLmtleXJpbmdBY2NvdW50PWUua2V5cmluZ0FjY291bnR8fHIuc3RhbmRhcmQsdGhpcy54ZnA9ZS54ZnAsdGhpcy54cHViPWUueHB1Yix0aGlzLmhkUGF0aD1lLmhkUGF0aCx0aGlzLmluZGV4ZXM9ZS5pbmRleGVzLHRoaXMucGF0aHM9ZS5wYXRocyx0aGlzLmNoaWxkcmVuUGF0aD1lLmNoaWxkcmVuUGF0aHx8XCIwLypcIil9c2V0Q3VycmVudEFjY291bnQoZSl7dGhpcy5jdXJyZW50QWNjb3VudD1lfWdldEN1cnJlbnRBY2NvdW50KCl7cmV0dXJuIHRoaXMuY3VycmVudEFjY291bnR9Z2V0Q3VycmVudEFkZHJlc3MoKXtyZXR1cm4gdGhpcy5hY2NvdW50c1t0aGlzLmN1cnJlbnRBY2NvdW50XX1hc3luYyBhZGRBY2NvdW50cyhlPTEpe2NvbnN0IHQ9dGhpcy51bmxvY2tlZEFjY291bnQscj10K2UsaT1bXTtmb3IobGV0IGU9dDtlPHI7ZSsrKXtjb25zdCB0PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpO2kucHVzaCh0KSx0aGlzLnBhZ2U9MCx0aGlzLnVubG9ja2VkQWNjb3VudCsrfXJldHVybiB0aGlzLmFjY291bnRzPXRoaXMuYWNjb3VudHMuY29uY2F0KGkpLHRoaXMuYWNjb3VudHN9Z2V0Rmlyc3RQYWdlKCl7cmV0dXJuIHRoaXMucGFnZT0wLHRoaXMuX19nZXRQYWdlKDEpfWdldE5leHRQYWdlKCl7cmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpfWdldFByZXZpb3VzUGFnZSgpe3JldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSl9YXN5bmMgX19nZXRQYWdlKGUpe3JldHVybiB0aGlzLmluaXRpYWxpemVkfHxhd2FpdCB0aGlzLnJlYWRLZXlyaW5nKCksdGhpcy5rZXlyaW5nTW9kZT09PXQuaGQ/dGhpcy5fX2dldE5vcm1hbFBhZ2UoZSk6dGhpcy5fX2dldExlZGdlckxpdmVQYWdlKGUpfWdldEFjY291bnRzKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzKX1yZW1vdmVBY2NvdW50KGUpe2lmKCF0aGlzLmFjY291bnRzLm1hcChlPT5lLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGUudG9Mb3dlckNhc2UoKSkpdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7ZX0gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO3RoaXMuYWNjb3VudHM9dGhpcy5hY2NvdW50cy5maWx0ZXIodD0+dC50b0xvd2VyQ2FzZSgpIT09ZS50b0xvd2VyQ2FzZSgpKX1hc3luYyBzaWduVHJhbnNhY3Rpb24oZSx0KXtjb25zdCByPTA9PT10LnR5cGU/by5EYXRhVHlwZS50cmFuc2FjdGlvbjpvLkRhdGFUeXBlLnR5cGVkVHJhbnNhY3Rpb247bGV0IGk7aT0wPT09dC50eXBlP0J1ZmZlci5mcm9tKG4uZW5jb2RlKHQuZ2V0TWVzc2FnZVRvU2lnbighMSkpKTp0LmdldE1lc3NhZ2VUb1NpZ24oITEpO2NvbnN0IHM9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLGM9TnVtYmVyKHQuY29tbW9uLmNoYWluSWQoKSksZD1oLnY0KCksdT1vLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoaSxyLHMsdGhpcy54ZnAsZCxjKSx7cjpnLHM6eSx2OnB9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShkLHUsXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtyZXR1cm4gYS5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh7Li4udC50b0pTT04oKSx0eXBlOnQudHlwZSxyOmcsczp5LHY6cH0se2NvbW1vbjp0LmNvbW1vbn0pfXNpZ25NZXNzYWdlKGUsdCl7cmV0dXJuIHRoaXMuc2lnblBlcnNvbmFsTWVzc2FnZShlLHQpfWFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2UoZSx0KXtjb25zdCByPXMuc3RyaXBIZXhQcmVmaXgodCksaT1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksbj1oLnY0KCksYT1vLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20ocixcImhleFwiKSxvLkRhdGFUeXBlLnBlcnNvbmFsTWVzc2FnZSxpLHRoaXMueGZwLG4sdm9pZCAwLGUpLHtyOmMsczpkLHY6dX09YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKG4sYSxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIG1lc3NhZ2UsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO3JldHVyblwiMHhcIitCdWZmZXIuY29uY2F0KFtjLGQsdV0pLnRvU3RyaW5nKFwiaGV4XCIpfWFzeW5jIHNpZ25UeXBlZERhdGEoZSx0KXtjb25zdCByPWF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhlKSxpPWgudjQoKSxzPW8uRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh0KSxcInV0Zi04XCIpLG8uRGF0YVR5cGUudHlwZWREYXRhLHIsdGhpcy54ZnAsaSx2b2lkIDAsZSkse3I6bixzOmEsdjpjfT1hd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUoaSxzLFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoaXMgZGF0YSwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7cmV0dXJuXCIweFwiK0J1ZmZlci5jb25jYXQoW24sYSxjXSkudG9TdHJpbmcoXCJoZXhcIil9YXN5bmMgX3BhdGhGcm9tQWRkcmVzcyhlKXtpZih0aGlzLmtleXJpbmdNb2RlPT09dC5oZCl7Y29uc3QgdD1zLnRvQ2hlY2tzdW1BZGRyZXNzKGUpO2xldCByPXRoaXMuaW5kZXhlc1t0XTtpZih2b2lkIDA9PT1yKWZvcihsZXQgZT0wO2U8MWUzO2UrKylpZih0PT09YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSkpe3I9ZTticmVha31pZih2b2lkIDA9PT1yKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWRkcmVzc1wiKTtyZXR1cm5gJHt0aGlzLmhkUGF0aH0vJHt0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLHIudG9TdHJpbmcoKSkucmVwbGFjZSgvXFwqL2csXCIwXCIpfWB9e2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKSxyPXRoaXMucGF0aHNbdF07aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuIHJ9fX1jLnR5cGU9XCJRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlXCIsZXhwb3J0cy5CYXNlS2V5cmluZz1jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1ldGgta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMubWFwXG4iLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYXNlLWV0aC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgYmNVclJlZ2lzdHJ5ID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnknKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIHV0aWwgPSByZXF1aXJlKCdAZXRoZXJldW1qcy91dGlsJyk7XG5cbmNvbnN0IEV4dGVuZGVkUmVnaXN0cnlUeXBlcyA9IHtcbiAgRVRIX1NJR05fUkVRVUVTVDogLyojX19QVVJFX18qL25ldyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlUeXBlKFwiZXRoLXNpZ24tcmVxdWVzdFwiLCA0MDEpLFxuICBFVEhfU0lHTkFUVVJFOiAvKiNfX1BVUkVfXyovbmV3IGJjVXJSZWdpc3RyeS5SZWdpc3RyeVR5cGUoXCJldGgtc2lnbmF0dXJlXCIsIDQwMiksXG4gIEVUSF9ORlRfSVRFTTogLyojX19QVVJFX18qL25ldyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlUeXBlKFwiZXRoLW5mdC1pdGVtXCIsIDQwMylcbn07XG5cbmNvbnN0IHtcbiAgZGVjb2RlVG9EYXRhSXRlbSxcbiAgUmVnaXN0cnlUeXBlc1xufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cztcblxuKGZ1bmN0aW9uIChLZXlzKSB7XG4gIEtleXNbS2V5c1tcInJlcXVlc3RJZFwiXSA9IDFdID0gXCJyZXF1ZXN0SWRcIjtcbiAgS2V5c1tLZXlzW1wic2lnbkRhdGFcIl0gPSAyXSA9IFwic2lnbkRhdGFcIjtcbiAgS2V5c1tLZXlzW1wiZGF0YVR5cGVcIl0gPSAzXSA9IFwiZGF0YVR5cGVcIjtcbiAgS2V5c1tLZXlzW1wiY2hhaW5JZFwiXSA9IDRdID0gXCJjaGFpbklkXCI7XG4gIEtleXNbS2V5c1tcImRlcml2YXRpb25QYXRoXCJdID0gNV0gPSBcImRlcml2YXRpb25QYXRoXCI7XG4gIEtleXNbS2V5c1tcImFkZHJlc3NcIl0gPSA2XSA9IFwiYWRkcmVzc1wiO1xuICBLZXlzW0tleXNbXCJvcmlnaW5cIl0gPSA3XSA9IFwib3JpZ2luXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcblxuKGZ1bmN0aW9uIChEYXRhVHlwZSkge1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInRyYW5zYWN0aW9uXCJdID0gMV0gPSBcInRyYW5zYWN0aW9uXCI7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1widHlwZWREYXRhXCJdID0gMl0gPSBcInR5cGVkRGF0YVwiO1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInBlcnNvbmFsTWVzc2FnZVwiXSA9IDNdID0gXCJwZXJzb25hbE1lc3NhZ2VcIjtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ0eXBlZFRyYW5zYWN0aW9uXCJdID0gNF0gPSBcInR5cGVkVHJhbnNhY3Rpb25cIjtcbn0pKGV4cG9ydHMuRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSB7fSkpO1xuXG5jbGFzcyBFdGhTaWduUmVxdWVzdCBleHRlbmRzIGJjVXJSZWdpc3RyeS5SZWdpc3RyeUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4gRXh0ZW5kZWRSZWdpc3RyeVR5cGVzLkVUSF9TSUdOX1JFUVVFU1Q7XG5cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9ICgpID0+IHRoaXMucmVxdWVzdElkO1xuXG4gICAgdGhpcy5nZXRTaWduRGF0YSA9ICgpID0+IHRoaXMuc2lnbkRhdGE7XG5cbiAgICB0aGlzLmdldERhdGFUeXBlID0gKCkgPT4gdGhpcy5kYXRhVHlwZTtcblxuICAgIHRoaXMuZ2V0Q2hhaW5JZCA9ICgpID0+IHRoaXMuY2hhaW5JZDtcblxuICAgIHRoaXMuZ2V0RGVyaXZhdGlvblBhdGggPSAoKSA9PiB0aGlzLmRlcml2YXRpb25QYXRoLmdldFBhdGgoKTtcblxuICAgIHRoaXMuZ2V0U291cmNlRmluZ2VycHJpbnQgPSAoKSA9PiB0aGlzLmRlcml2YXRpb25QYXRoLmdldFNvdXJjZUZpbmdlcnByaW50KCk7XG5cbiAgICB0aGlzLmdldFNpZ25SZXF1ZXN0QWRkcmVzcyA9ICgpID0+IHRoaXMuYWRkcmVzcztcblxuICAgIHRoaXMuZ2V0T3JpZ2luID0gKCkgPT4gdGhpcy5vcmlnaW47XG5cbiAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVxdWVzdElkKSB7XG4gICAgICAgIG1hcFtLZXlzLnJlcXVlc3RJZF0gPSBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLCBSZWdpc3RyeVR5cGVzLlVVSUQuZ2V0VGFnKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hZGRyZXNzKSB7XG4gICAgICAgIG1hcFtLZXlzLmFkZHJlc3NdID0gdGhpcy5hZGRyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFpbklkKSB7XG4gICAgICAgIG1hcFtLZXlzLmNoYWluSWRdID0gdGhpcy5jaGFpbklkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgICAgbWFwW0tleXMub3JpZ2luXSA9IHRoaXMub3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBtYXBbS2V5cy5zaWduRGF0YV0gPSB0aGlzLnNpZ25EYXRhO1xuICAgICAgbWFwW0tleXMuZGF0YVR5cGVdID0gdGhpcy5kYXRhVHlwZTtcbiAgICAgIGNvbnN0IGtleVBhdGggPSB0aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtcbiAgICAgIGtleVBhdGguc2V0VGFnKHRoaXMuZGVyaXZhdGlvblBhdGguZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgbWFwW0tleXMuZGVyaXZhdGlvblBhdGhdID0ga2V5UGF0aDtcbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKG1hcCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVxdWVzdElkID0gYXJncy5yZXF1ZXN0SWQ7XG4gICAgdGhpcy5zaWduRGF0YSA9IGFyZ3Muc2lnbkRhdGE7XG4gICAgdGhpcy5kYXRhVHlwZSA9IGFyZ3MuZGF0YVR5cGU7XG4gICAgdGhpcy5jaGFpbklkID0gYXJncy5jaGFpbklkO1xuICAgIHRoaXMuZGVyaXZhdGlvblBhdGggPSBhcmdzLmRlcml2YXRpb25QYXRoO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcztcbiAgICB0aGlzLm9yaWdpbiA9IGFyZ3Mub3JpZ2luO1xuICB9XG5cbiAgc3RhdGljIGNvbnN0cnVjdEVUSFJlcXVlc3Qoc2lnbkRhdGEsIHNpZ25EYXRhVHlwZSwgaGRQYXRoLCB4ZnAsIHV1aWRTdHJpbmcsIGNoYWluSWQsIGFkZHJlc3MsIG9yaWdpbikge1xuICAgIGNvbnN0IHBhdGhzID0gaGRQYXRoLnJlcGxhY2UoL1ttfE1dXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGhkcGF0aE9iamVjdCA9IG5ldyBiY1VyUmVnaXN0cnkuQ3J5cHRvS2V5cGF0aChwYXRocy5tYXAocGF0aCA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHBhdGgucmVwbGFjZShcIidcIiwgXCJcIikpO1xuICAgICAgbGV0IGlzSGFyZGVuZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHBhdGguZW5kc1dpdGgoXCInXCIpKSB7XG4gICAgICAgIGlzSGFyZGVuZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGJjVXJSZWdpc3RyeS5QYXRoQ29tcG9uZW50KHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGhhcmRlbmVkOiBpc0hhcmRlbmVkXG4gICAgICB9KTtcbiAgICB9KSwgQnVmZmVyLmZyb20oeGZwLCBcImhleFwiKSk7XG4gICAgcmV0dXJuIG5ldyBFdGhTaWduUmVxdWVzdCh7XG4gICAgICByZXF1ZXN0SWQ6IHV1aWRTdHJpbmcgPyBCdWZmZXIuZnJvbSh1dWlkLnBhcnNlKHV1aWRTdHJpbmcpKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNpZ25EYXRhLFxuICAgICAgZGF0YVR5cGU6IHNpZ25EYXRhVHlwZSxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBoZHBhdGhPYmplY3QsXG4gICAgICBjaGFpbklkLFxuICAgICAgYWRkcmVzczogYWRkcmVzcyA/IEJ1ZmZlci5mcm9tKGFkZHJlc3MucmVwbGFjZShcIjB4XCIsIFwiXCIpLCBcImhleFwiKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9yaWdpbjogb3JpZ2luIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG5cbn1cblxuRXRoU2lnblJlcXVlc3QuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25EYXRhID0gbWFwW0tleXMuc2lnbkRhdGFdO1xuICBjb25zdCBkYXRhVHlwZSA9IG1hcFtLZXlzLmRhdGFUeXBlXTtcbiAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBiY1VyUmVnaXN0cnkuQ3J5cHRvS2V5cGF0aC5mcm9tRGF0YUl0ZW0obWFwW0tleXMuZGVyaXZhdGlvblBhdGhdKTtcbiAgY29uc3QgY2hhaW5JZCA9IG1hcFtLZXlzLmNoYWluSWRdID8gbWFwW0tleXMuY2hhaW5JZF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGFkZHJlc3MgPSBtYXBbS2V5cy5hZGRyZXNzXSA/IG1hcFtLZXlzLmFkZHJlc3NdIDogdW5kZWZpbmVkO1xuICBjb25zdCByZXF1ZXN0SWQgPSBtYXBbS2V5cy5yZXF1ZXN0SWRdID8gbWFwW0tleXMucmVxdWVzdElkXS5nZXREYXRhKCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWdpbiA9IG1hcFtLZXlzLm9yaWdpbl0gPyBtYXBbS2V5cy5vcmlnaW5dIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IEV0aFNpZ25SZXF1ZXN0KHtcbiAgICByZXF1ZXN0SWQsXG4gICAgc2lnbkRhdGEsXG4gICAgZGF0YVR5cGUsXG4gICAgY2hhaW5JZCxcbiAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICBhZGRyZXNzLFxuICAgIG9yaWdpblxuICB9KTtcbn07XG5cbkV0aFNpZ25SZXF1ZXN0LmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtKF9jYm9yUGF5bG9hZCk7XG4gIHJldHVybiBFdGhTaWduUmVxdWVzdC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuY29uc3Qge1xuICBSZWdpc3RyeVR5cGVzOiBSZWdpc3RyeVR5cGVzJDEsXG4gIGRlY29kZVRvRGF0YUl0ZW06IGRlY29kZVRvRGF0YUl0ZW0kMVxufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cyQxO1xuXG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgS2V5c1tLZXlzW1wicmVxdWVzdElkXCJdID0gMV0gPSBcInJlcXVlc3RJZFwiO1xuICBLZXlzW0tleXNbXCJzaWduYXR1cmVcIl0gPSAyXSA9IFwic2lnbmF0dXJlXCI7XG4gIEtleXNbS2V5c1tcIm9yaWdpblwiXSA9IDNdID0gXCJvcmlnaW5cIjtcbn0pKEtleXMkMSB8fCAoS2V5cyQxID0ge30pKTtcblxuY2xhc3MgRVRIU2lnbmF0dXJlIGV4dGVuZHMgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5SXRlbSB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSwgcmVxdWVzdElkLCBvcmlnaW4pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMuRVRIX1NJR05BVFVSRTtcblxuICAgIHRoaXMuZ2V0UmVxdWVzdElkID0gKCkgPT4gdGhpcy5yZXF1ZXN0SWQ7XG5cbiAgICB0aGlzLmdldFNpZ25hdHVyZSA9ICgpID0+IHRoaXMuc2lnbmF0dXJlO1xuXG4gICAgdGhpcy5nZXRPcmlnaW4gPSAoKSA9PiB0aGlzLm9yaWdpbjtcblxuICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgbWFwW0tleXMkMS5yZXF1ZXN0SWRdID0gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbSh0aGlzLnJlcXVlc3RJZCwgUmVnaXN0cnlUeXBlcyQxLlVVSUQuZ2V0VGFnKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcmlnaW4pIG1hcFtLZXlzJDEub3JpZ2luXSA9IHRoaXMub3JpZ2luO1xuICAgICAgbWFwW0tleXMkMS5zaWduYXR1cmVdID0gdGhpcy5zaWduYXR1cmU7XG4gICAgICByZXR1cm4gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbShtYXApO1xuICAgIH07XG5cbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgfVxuXG59XG5cbkVUSFNpZ25hdHVyZS5mcm9tRGF0YUl0ZW0gPSBkYXRhSXRlbSA9PiB7XG4gIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gbWFwW0tleXMkMS5zaWduYXR1cmVdO1xuICBjb25zdCByZXF1ZXN0SWQgPSBtYXBbS2V5cyQxLnJlcXVlc3RJZF0gPyBtYXBbS2V5cyQxLnJlcXVlc3RJZF0uZ2V0RGF0YSgpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IEVUSFNpZ25hdHVyZShzaWduYXR1cmUsIHJlcXVlc3RJZCwgbWFwW0tleXMkMS5vcmlnaW5dKTtcbn07XG5cbkVUSFNpZ25hdHVyZS5mcm9tQ0JPUiA9IF9jYm9yUGF5bG9hZCA9PiB7XG4gIGNvbnN0IGRhdGFJdGVtID0gZGVjb2RlVG9EYXRhSXRlbSQxKF9jYm9yUGF5bG9hZCk7XG4gIHJldHVybiBFVEhTaWduYXR1cmUuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbmNvbnN0IHtcbiAgZGVjb2RlVG9EYXRhSXRlbTogZGVjb2RlVG9EYXRhSXRlbSQyXG59ID0gYmNVclJlZ2lzdHJ5LmV4dGVuZDtcbnZhciBLZXlzJDI7XG5cbihmdW5jdGlvbiAoS2V5cykge1xuICBLZXlzW0tleXNbXCJjaGFpbklkXCJdID0gMV0gPSBcImNoYWluSWRcIjtcbiAgS2V5c1tLZXlzW1wiY29udHJhY3RBZGRyZXNzXCJdID0gMl0gPSBcImNvbnRyYWN0QWRkcmVzc1wiO1xuICBLZXlzW0tleXNbXCJjb250cmFjdE5hbWVcIl0gPSAzXSA9IFwiY29udHJhY3ROYW1lXCI7XG4gIEtleXNbS2V5c1tcIm5hbWVcIl0gPSA0XSA9IFwibmFtZVwiO1xuICBLZXlzW0tleXNbXCJtZWRpYURhdGFcIl0gPSA1XSA9IFwibWVkaWFEYXRhXCI7XG59KShLZXlzJDIgfHwgKEtleXMkMiA9IHt9KSk7XG5cbmNsYXNzIEVUSE5GVEl0ZW0gZXh0ZW5kcyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlJdGVtIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfTkZUX0lURU07XG5cbiAgICB0aGlzLmdldENoYWluSWQgPSAoKSA9PiB0aGlzLmNoYWluSWQ7XG5cbiAgICB0aGlzLmdldE5hbWUgPSAoKSA9PiB0aGlzLm5hbWU7XG5cbiAgICB0aGlzLmdldG1lZGlhRGF0YSA9ICgpID0+IHRoaXMubWVkaWFEYXRhO1xuXG4gICAgdGhpcy5nZXRDb250cmFjdEFkZHJlc3MgPSAoKSA9PiB0aGlzLmNvbnRyYWN0QWRkcmVzcztcblxuICAgIHRoaXMuZ2V0Q29udHJhY3ROYW1lID0gKCkgPT4gdGhpcy5jb250cmFjdE5hbWU7XG5cbiAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgIG1hcFtLZXlzJDIuY2hhaW5JZF0gPSB0aGlzLmNoYWluSWQ7XG4gICAgICBtYXBbS2V5cyQyLm5hbWVdID0gdGhpcy5uYW1lO1xuICAgICAgbWFwW0tleXMkMi5jb250cmFjdEFkZHJlc3NdID0gdGhpcy5jb250cmFjdEFkZHJlc3M7XG4gICAgICBtYXBbS2V5cyQyLmNvbnRyYWN0TmFtZV0gPSB0aGlzLmNvbnRyYWN0TmFtZTtcbiAgICAgIG1hcFtLZXlzJDIubWVkaWFEYXRhXSA9IHRoaXMubWVkaWFEYXRhO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jaGFpbklkID0gYXJncy5jaGFpbklkO1xuICAgIHRoaXMubmFtZSA9IGFyZ3MubmFtZTtcbiAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IGFyZ3MuY29udHJhY3RBZGRyZXNzO1xuICAgIHRoaXMuY29udHJhY3ROYW1lID0gYXJncy5jb250cmFjdE5hbWU7XG4gICAgdGhpcy5tZWRpYURhdGEgPSBhcmdzLm1lZGlhRGF0YTsgLy8gcmVtb3ZlIHRoZSBkYXRhIHBlcmZpeCBmb3IgYW5kcm9pZCB1c2FnZVxuICB9XG5cbiAgc3RhdGljIGNvbnN0cnVjdEVUSE5GVEl0ZW0oY2hhaW5JZCwgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdE5hbWUsIG5hbWUsIG1lZGlhRGF0YSkge1xuICAgIHJldHVybiBuZXcgRVRITkZUSXRlbSh7XG4gICAgICBjaGFpbklkLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgbWVkaWFEYXRhLFxuICAgICAgbmFtZVxuICAgIH0pO1xuICB9XG5cbn1cblxuRVRITkZUSXRlbS5mcm9tRGF0YUl0ZW0gPSBkYXRhSXRlbSA9PiB7XG4gIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgY29uc3QgY2hhaW5JZCA9IG1hcFtLZXlzJDIuY2hhaW5JZF07XG4gIGNvbnN0IG5hbWUgPSBtYXBbS2V5cyQyLm5hbWVdO1xuICBjb25zdCBtZWRpYURhdGEgPSBtYXBbS2V5cyQyLm1lZGlhRGF0YV07XG4gIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IG1hcFtLZXlzJDIuY29udHJhY3RBZGRyZXNzXTtcbiAgY29uc3QgY29udHJhY3ROYW1lID0gbWFwW0tleXMkMi5jb250cmFjdE5hbWVdO1xuICByZXR1cm4gbmV3IEVUSE5GVEl0ZW0oe1xuICAgIGNoYWluSWQsXG4gICAgbmFtZSxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgY29udHJhY3ROYW1lLFxuICAgIG1lZGlhRGF0YVxuICB9KTtcbn07XG5cbkVUSE5GVEl0ZW0uZnJvbUNCT1IgPSBfY2JvclBheWxvYWQgPT4ge1xuICBjb25zdCBkYXRhSXRlbSA9IGRlY29kZVRvRGF0YUl0ZW0kMihfY2JvclBheWxvYWQpO1xuICByZXR1cm4gRVRITkZUSXRlbS5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgZ2VuZXJhdGVBZGRyZXNzRnJvbVhwdWIgPSAoeHB1YiwgZGVyaXZlUGF0aCkgPT4ge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG5vZGUgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkoeHB1Yik7XG4gIGNvbnN0IHB1YmxpY0tleSA9IG5vZGUuZGVyaXZlKGRlcml2ZVBhdGgpO1xuICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5LnB1YmxpY0tleSwgdHJ1ZSkudG9TdHJpbmcoXCJoZXhcIik7XG4gIHJldHVybiB1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xufTtcbmNvbnN0IGZpbmRIRFBhdGhGcm9tQWRkcmVzcyA9IChhZGRyZXNzLCB4cHViLCBudW1iZXJMaW1pdCwgcm9vdFBhdGgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJMaW1pdDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IGBNLzAvJHtpfWA7XG5cbiAgICBjb25zdCBfYWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzc0Zyb21YcHViKHhwdWIsIHBhdGgpO1xuXG4gICAgaWYgKGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PSBfYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gYCR7cm9vdFBhdGh9LzAvJHtpfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5iY1VyUmVnaXN0cnkucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMoRXh0ZW5kZWRSZWdpc3RyeVR5cGVzKS5maWx0ZXIocnQgPT4gISFydC5nZXRUYWcoKSkubWFwKHJ0ID0+IHJ0LmdldFRhZygpKSk7XG5cbk9iamVjdC5rZXlzKGJjVXJSZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICBpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmNVclJlZ2lzdHJ5W2tdO1xuICAgIH1cbiAgfSk7XG59KTtcbmV4cG9ydHMuRVRITkZUSXRlbSA9IEVUSE5GVEl0ZW07XG5leHBvcnRzLkVUSFNpZ25hdHVyZSA9IEVUSFNpZ25hdHVyZTtcbmV4cG9ydHMuRXRoU2lnblJlcXVlc3QgPSBFdGhTaWduUmVxdWVzdDtcbmV4cG9ydHMuZmluZEhEUGF0aEZyb21BZGRyZXNzID0gZmluZEhEUGF0aEZyb21BZGRyZXNzO1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3NGcm9tWHB1YiA9IGdlbmVyYXRlQWRkcmVzc0Zyb21YcHViO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB0LGU9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5XCIpLGE9cmVxdWlyZShcInV1aWRcIikscz0odD1yZXF1aXJlKFwiaGRrZXlcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJkZWZhdWx0XCJpbiB0P3QuZGVmYXVsdDp0LGk9cmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7Y29uc3Qgcj17RVRIX1NJR05fUkVRVUVTVDpuZXcgZS5SZWdpc3RyeVR5cGUoXCJldGgtc2lnbi1yZXF1ZXN0XCIsNDAxKSxFVEhfU0lHTkFUVVJFOm5ldyBlLlJlZ2lzdHJ5VHlwZShcImV0aC1zaWduYXR1cmVcIiw0MDIpLEVUSF9ORlRfSVRFTTpuZXcgZS5SZWdpc3RyeVR5cGUoXCJldGgtbmZ0LWl0ZW1cIiw0MDMpfSx7ZGVjb2RlVG9EYXRhSXRlbTpuLFJlZ2lzdHJ5VHlwZXM6ZH09ZS5leHRlbmQ7dmFyIG8saDshZnVuY3Rpb24odCl7dFt0LnJlcXVlc3RJZD0xXT1cInJlcXVlc3RJZFwiLHRbdC5zaWduRGF0YT0yXT1cInNpZ25EYXRhXCIsdFt0LmRhdGFUeXBlPTNdPVwiZGF0YVR5cGVcIix0W3QuY2hhaW5JZD00XT1cImNoYWluSWRcIix0W3QuZGVyaXZhdGlvblBhdGg9NV09XCJkZXJpdmF0aW9uUGF0aFwiLHRbdC5hZGRyZXNzPTZdPVwiYWRkcmVzc1wiLHRbdC5vcmlnaW49N109XCJvcmlnaW5cIn0ob3x8KG89e30pKSwoaD1leHBvcnRzLkRhdGFUeXBlfHwoZXhwb3J0cy5EYXRhVHlwZT17fSkpW2gudHJhbnNhY3Rpb249MV09XCJ0cmFuc2FjdGlvblwiLGhbaC50eXBlZERhdGE9Ml09XCJ0eXBlZERhdGFcIixoW2gucGVyc29uYWxNZXNzYWdlPTNdPVwicGVyc29uYWxNZXNzYWdlXCIsaFtoLnR5cGVkVHJhbnNhY3Rpb249NF09XCJ0eXBlZFRyYW5zYWN0aW9uXCI7Y2xhc3MgYyBleHRlbmRzIGUuUmVnaXN0cnlJdGVte2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5nZXRSZWdpc3RyeVR5cGU9KCk9PnIuRVRIX1NJR05fUkVRVUVTVCx0aGlzLmdldFJlcXVlc3RJZD0oKT0+dGhpcy5yZXF1ZXN0SWQsdGhpcy5nZXRTaWduRGF0YT0oKT0+dGhpcy5zaWduRGF0YSx0aGlzLmdldERhdGFUeXBlPSgpPT50aGlzLmRhdGFUeXBlLHRoaXMuZ2V0Q2hhaW5JZD0oKT0+dGhpcy5jaGFpbklkLHRoaXMuZ2V0RGVyaXZhdGlvblBhdGg9KCk9PnRoaXMuZGVyaXZhdGlvblBhdGguZ2V0UGF0aCgpLHRoaXMuZ2V0U291cmNlRmluZ2VycHJpbnQ9KCk9PnRoaXMuZGVyaXZhdGlvblBhdGguZ2V0U291cmNlRmluZ2VycHJpbnQoKSx0aGlzLmdldFNpZ25SZXF1ZXN0QWRkcmVzcz0oKT0+dGhpcy5hZGRyZXNzLHRoaXMuZ2V0T3JpZ2luPSgpPT50aGlzLm9yaWdpbix0aGlzLnRvRGF0YUl0ZW09KCk9Pntjb25zdCB0PXt9O3RoaXMucmVxdWVzdElkJiYodFtvLnJlcXVlc3RJZF09bmV3IGUuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsZC5VVUlELmdldFRhZygpKSksdGhpcy5hZGRyZXNzJiYodFtvLmFkZHJlc3NdPXRoaXMuYWRkcmVzcyksdGhpcy5jaGFpbklkJiYodFtvLmNoYWluSWRdPXRoaXMuY2hhaW5JZCksdGhpcy5vcmlnaW4mJih0W28ub3JpZ2luXT10aGlzLm9yaWdpbiksdFtvLnNpZ25EYXRhXT10aGlzLnNpZ25EYXRhLHRbby5kYXRhVHlwZV09dGhpcy5kYXRhVHlwZTtjb25zdCBhPXRoaXMuZGVyaXZhdGlvblBhdGgudG9EYXRhSXRlbSgpO3JldHVybiBhLnNldFRhZyh0aGlzLmRlcml2YXRpb25QYXRoLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKSx0W28uZGVyaXZhdGlvblBhdGhdPWEsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMucmVxdWVzdElkPXQucmVxdWVzdElkLHRoaXMuc2lnbkRhdGE9dC5zaWduRGF0YSx0aGlzLmRhdGFUeXBlPXQuZGF0YVR5cGUsdGhpcy5jaGFpbklkPXQuY2hhaW5JZCx0aGlzLmRlcml2YXRpb25QYXRoPXQuZGVyaXZhdGlvblBhdGgsdGhpcy5hZGRyZXNzPXQuYWRkcmVzcyx0aGlzLm9yaWdpbj10Lm9yaWdpbn1zdGF0aWMgY29uc3RydWN0RVRIUmVxdWVzdCh0LHMsaSxyLG4sZCxvLGgpe2NvbnN0IGc9aS5yZXBsYWNlKC9bbXxNXVxcLy8sXCJcIikuc3BsaXQoXCIvXCIpLHU9bmV3IGUuQ3J5cHRvS2V5cGF0aChnLm1hcCh0PT57Y29uc3QgYT1wYXJzZUludCh0LnJlcGxhY2UoXCInXCIsXCJcIikpO2xldCBzPSExO3JldHVybiB0LmVuZHNXaXRoKFwiJ1wiKSYmKHM9ITApLG5ldyBlLlBhdGhDb21wb25lbnQoe2luZGV4OmEsaGFyZGVuZWQ6c30pfSksQnVmZmVyLmZyb20ocixcImhleFwiKSk7cmV0dXJuIG5ldyBjKHtyZXF1ZXN0SWQ6bj9CdWZmZXIuZnJvbShhLnBhcnNlKG4pKTp2b2lkIDAsc2lnbkRhdGE6dCxkYXRhVHlwZTpzLGRlcml2YXRpb25QYXRoOnUsY2hhaW5JZDpkLGFkZHJlc3M6bz9CdWZmZXIuZnJvbShvLnJlcGxhY2UoXCIweFwiLFwiXCIpLFwiaGV4XCIpOnZvaWQgMCxvcmlnaW46aHx8dm9pZCAwfSl9fWMuZnJvbURhdGFJdGVtPXQ9Pntjb25zdCBhPXQuZ2V0RGF0YSgpLHM9YVtvLnNpZ25EYXRhXSxpPWFbby5kYXRhVHlwZV0scj1lLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKGFbby5kZXJpdmF0aW9uUGF0aF0pLG49YVtvLmNoYWluSWRdP2Fbby5jaGFpbklkXTp2b2lkIDAsZD1hW28uYWRkcmVzc10/YVtvLmFkZHJlc3NdOnZvaWQgMCxoPWFbby5yZXF1ZXN0SWRdP2Fbby5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyBjKHtyZXF1ZXN0SWQ6aCxzaWduRGF0YTpzLGRhdGFUeXBlOmksY2hhaW5JZDpuLGRlcml2YXRpb25QYXRoOnIsYWRkcmVzczpkLG9yaWdpbjphW28ub3JpZ2luXT9hW28ub3JpZ2luXTp2b2lkIDB9KX0sYy5mcm9tQ0JPUj10PT57Y29uc3QgZT1uKHQpO3JldHVybiBjLmZyb21EYXRhSXRlbShlKX07Y29uc3R7UmVnaXN0cnlUeXBlczpnLGRlY29kZVRvRGF0YUl0ZW06dX09ZS5leHRlbmQ7dmFyIG07IWZ1bmN0aW9uKHQpe3RbdC5yZXF1ZXN0SWQ9MV09XCJyZXF1ZXN0SWRcIix0W3Quc2lnbmF0dXJlPTJdPVwic2lnbmF0dXJlXCIsdFt0Lm9yaWdpbj0zXT1cIm9yaWdpblwifShtfHwobT17fSkpO2NsYXNzIEkgZXh0ZW5kcyBlLlJlZ2lzdHJ5SXRlbXtjb25zdHJ1Y3Rvcih0LGEscyl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+ci5FVEhfU0lHTkFUVVJFLHRoaXMuZ2V0UmVxdWVzdElkPSgpPT50aGlzLnJlcXVlc3RJZCx0aGlzLmdldFNpZ25hdHVyZT0oKT0+dGhpcy5zaWduYXR1cmUsdGhpcy5nZXRPcmlnaW49KCk9PnRoaXMub3JpZ2luLHRoaXMudG9EYXRhSXRlbT0oKT0+e2NvbnN0IHQ9e307cmV0dXJuIHRoaXMucmVxdWVzdElkJiYodFttLnJlcXVlc3RJZF09bmV3IGUuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsZy5VVUlELmdldFRhZygpKSksdGhpcy5vcmlnaW4mJih0W20ub3JpZ2luXT10aGlzLm9yaWdpbiksdFttLnNpZ25hdHVyZV09dGhpcy5zaWduYXR1cmUsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMuc2lnbmF0dXJlPXQsdGhpcy5yZXF1ZXN0SWQ9YSx0aGlzLm9yaWdpbj1zfX1JLmZyb21EYXRhSXRlbT10PT57Y29uc3QgZT10LmdldERhdGEoKSxhPWVbbS5zaWduYXR1cmVdLHM9ZVttLnJlcXVlc3RJZF0/ZVttLnJlcXVlc3RJZF0uZ2V0RGF0YSgpOnZvaWQgMDtyZXR1cm4gbmV3IEkoYSxzLGVbbS5vcmlnaW5dKX0sSS5mcm9tQ0JPUj10PT57Y29uc3QgZT11KHQpO3JldHVybiBJLmZyb21EYXRhSXRlbShlKX07Y29uc3R7ZGVjb2RlVG9EYXRhSXRlbTpwfT1lLmV4dGVuZDt2YXIgRDshZnVuY3Rpb24odCl7dFt0LmNoYWluSWQ9MV09XCJjaGFpbklkXCIsdFt0LmNvbnRyYWN0QWRkcmVzcz0yXT1cImNvbnRyYWN0QWRkcmVzc1wiLHRbdC5jb250cmFjdE5hbWU9M109XCJjb250cmFjdE5hbWVcIix0W3QubmFtZT00XT1cIm5hbWVcIix0W3QubWVkaWFEYXRhPTVdPVwibWVkaWFEYXRhXCJ9KER8fChEPXt9KSk7Y2xhc3MgVCBleHRlbmRzIGUuUmVnaXN0cnlJdGVte2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5nZXRSZWdpc3RyeVR5cGU9KCk9PnIuRVRIX05GVF9JVEVNLHRoaXMuZ2V0Q2hhaW5JZD0oKT0+dGhpcy5jaGFpbklkLHRoaXMuZ2V0TmFtZT0oKT0+dGhpcy5uYW1lLHRoaXMuZ2V0bWVkaWFEYXRhPSgpPT50aGlzLm1lZGlhRGF0YSx0aGlzLmdldENvbnRyYWN0QWRkcmVzcz0oKT0+dGhpcy5jb250cmFjdEFkZHJlc3MsdGhpcy5nZXRDb250cmFjdE5hbWU9KCk9PnRoaXMuY29udHJhY3ROYW1lLHRoaXMudG9EYXRhSXRlbT0oKT0+e2NvbnN0IHQ9e307cmV0dXJuIHRbRC5jaGFpbklkXT10aGlzLmNoYWluSWQsdFtELm5hbWVdPXRoaXMubmFtZSx0W0QuY29udHJhY3RBZGRyZXNzXT10aGlzLmNvbnRyYWN0QWRkcmVzcyx0W0QuY29udHJhY3ROYW1lXT10aGlzLmNvbnRyYWN0TmFtZSx0W0QubWVkaWFEYXRhXT10aGlzLm1lZGlhRGF0YSxuZXcgZS5EYXRhSXRlbSh0KX0sdGhpcy5jaGFpbklkPXQuY2hhaW5JZCx0aGlzLm5hbWU9dC5uYW1lLHRoaXMuY29udHJhY3RBZGRyZXNzPXQuY29udHJhY3RBZGRyZXNzLHRoaXMuY29udHJhY3ROYW1lPXQuY29udHJhY3ROYW1lLHRoaXMubWVkaWFEYXRhPXQubWVkaWFEYXRhfXN0YXRpYyBjb25zdHJ1Y3RFVEhORlRJdGVtKHQsZSxhLHMsaSl7cmV0dXJuIG5ldyBUKHtjaGFpbklkOnQsY29udHJhY3RBZGRyZXNzOmUsY29udHJhY3ROYW1lOmEsbWVkaWFEYXRhOmksbmFtZTpzfSl9fVQuZnJvbURhdGFJdGVtPXQ9Pntjb25zdCBlPXQuZ2V0RGF0YSgpO3JldHVybiBuZXcgVCh7Y2hhaW5JZDplW0QuY2hhaW5JZF0sbmFtZTplW0QubmFtZV0sY29udHJhY3RBZGRyZXNzOmVbRC5jb250cmFjdEFkZHJlc3NdLGNvbnRyYWN0TmFtZTplW0QuY29udHJhY3ROYW1lXSxtZWRpYURhdGE6ZVtELm1lZGlhRGF0YV19KX0sVC5mcm9tQ0JPUj10PT57Y29uc3QgZT1wKHQpO3JldHVybiBULmZyb21EYXRhSXRlbShlKX07Y29uc3QgeT0odCxlKT0+e2NvbnN0IGE9cy5mcm9tRXh0ZW5kZWRLZXkodCkuZGVyaXZlKGUpLHI9XCIweFwiK2kucHVibGljVG9BZGRyZXNzKGEucHVibGljS2V5LCEwKS50b1N0cmluZyhcImhleFwiKTtyZXR1cm4gaS50b0NoZWNrc3VtQWRkcmVzcyhyKX07ZS5wYXRjaFRhZ3MoT2JqZWN0LnZhbHVlcyhyKS5maWx0ZXIodD0+ISF0LmdldFRhZygpKS5tYXAodD0+dC5nZXRUYWcoKSkpLE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe1wiZGVmYXVsdFwiIT09dCYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsdCx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVt0XX19KX0pKSxleHBvcnRzLkVUSE5GVEl0ZW09VCxleHBvcnRzLkVUSFNpZ25hdHVyZT1JLGV4cG9ydHMuRXRoU2lnblJlcXVlc3Q9YyxleHBvcnRzLmZpbmRIRFBhdGhGcm9tQWRkcmVzcz0odCxlLGEscyk9Pntmb3IobGV0IGk9MDtpPGE7aSsrKXtjb25zdCBhPXkoZSxcIk0vMC9cIitpKTtpZih0LnRvTG93ZXJDYXNlKCk9PWEudG9Mb3dlckNhc2UoKSlyZXR1cm5gJHtzfS8wLyR7aX1gfXJldHVybiBudWxsfSxleHBvcnRzLmdlbmVyYXRlQWRkcmVzc0Zyb21YcHViPXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYy11ci1yZWdpc3RyeS1ldGguY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CeXRlcyA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNsYXNzIEJ5dGVzIGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQllURVM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RGF0YSA9ICgpID0+IHRoaXMuYnl0ZXM7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0odGhpcy5ieXRlcyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5CeXRlcyA9IEJ5dGVzO1xuQnl0ZXMuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgaWYgKCFieXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNbdXItcmVnaXN0cnldW0J5dGVzXVtmbi5mcm9tRGF0YUl0ZW1dOiBkZWNvZGVkIFtkYXRhSXRlbV1bI2RhdGFdIGlzIHVuZGVmaW5lZDogJHtkYXRhSXRlbX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XG59O1xuQnl0ZXMuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IF8xID0gcmVxdWlyZShcIi5cIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcIm1hc3RlckZpbmdlcnByaW50XCJdID0gMV0gPSBcIm1hc3RlckZpbmdlcnByaW50XCI7XG4gICAgS2V5c1tLZXlzW1wib3V0cHV0RGVzY3JpcHRvcnNcIl0gPSAyXSA9IFwib3V0cHV0RGVzY3JpcHRvcnNcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvQWNjb3VudCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IobWFzdGVyRmluZ2VycHJpbnQsIG91dHB1dERlc2NyaXB0b3JzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFzdGVyRmluZ2VycHJpbnQgPSBtYXN0ZXJGaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5vdXRwdXREZXNjcmlwdG9ycyA9IG91dHB1dERlc2NyaXB0b3JzO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19BQ0NPVU5UO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1hc3RlckZpbmdlcnByaW50ID0gKCkgPT4gdGhpcy5tYXN0ZXJGaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5nZXRPdXRwdXREZXNjcmlwdG9ycyA9ICgpID0+IHRoaXMub3V0cHV0RGVzY3JpcHRvcnM7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMubWFzdGVyRmluZ2VycHJpbnQpIHtcbiAgICAgICAgICAgICAgICBtYXBbS2V5cy5tYXN0ZXJGaW5nZXJwcmludF0gPSB0aGlzLm1hc3RlckZpbmdlcnByaW50LnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dERlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMub3V0cHV0RGVzY3JpcHRvcnNdID0gdGhpcy5vdXRwdXREZXNjcmlwdG9ycy5tYXAoKGl0ZW0pID0+IGl0ZW0udG9EYXRhSXRlbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0obWFwKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b0FjY291bnQgPSBDcnlwdG9BY2NvdW50O1xuQ3J5cHRvQWNjb3VudC5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgY29uc3QgbWFzdGVyRmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgY29uc3QgX21hc3RlckZpbmdlcnByaW50ID0gbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdO1xuICAgIGlmIChfbWFzdGVyRmluZ2VycHJpbnQpIHtcbiAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfbWFzdGVyRmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXREZXNjcmlwdG9ycyA9IG1hcFtLZXlzLm91dHB1dERlc2NyaXB0b3JzXTtcbiAgICBjb25zdCBjcnlwdG9PdXRwdXRzID0gb3V0cHV0RGVzY3JpcHRvcnMubWFwKChpdGVtKSA9PiBfMS5DcnlwdG9PdXRwdXQuZnJvbURhdGFJdGVtKGl0ZW0pKTtcbiAgICByZXR1cm4gbmV3IENyeXB0b0FjY291bnQobWFzdGVyRmluZ2VycHJpbnQsIGNyeXB0b091dHB1dHMpO1xufTtcbkNyeXB0b0FjY291bnQuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvQWNjb3VudC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0FjY291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0NvaW5JbmZvID0gZXhwb3J0cy5OZXR3b3JrID0gZXhwb3J0cy5UeXBlID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW1widHlwZVwiXSA9IFwiMVwiO1xuICAgIEtleXNbXCJuZXR3b3JrXCJdID0gXCIyXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiYml0Y29pblwiXSA9IDBdID0gXCJiaXRjb2luXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xudmFyIE5ldHdvcms7XG4oZnVuY3Rpb24gKE5ldHdvcmspIHtcbiAgICBOZXR3b3JrW05ldHdvcmtbXCJtYWlubmV0XCJdID0gMF0gPSBcIm1haW5uZXRcIjtcbiAgICBOZXR3b3JrW05ldHdvcmtbXCJ0ZXN0bmV0XCJdID0gMV0gPSBcInRlc3RuZXRcIjtcbn0pKE5ldHdvcmsgPSBleHBvcnRzLk5ldHdvcmsgfHwgKGV4cG9ydHMuTmV0d29yayA9IHt9KSk7XG5jbGFzcyBDcnlwdG9Db2luSW5mbyBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbmV0d29yaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19DT0lOX0lORk87XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgfHwgVHlwZS5iaXRjb2luO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE5ldHdvcmsgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrIHx8IE5ldHdvcmsubWFpbm5ldDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMudHlwZV0gPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMubmV0d29ya10gPSB0aGlzLm5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9Db2luSW5mbyA9IENyeXB0b0NvaW5JbmZvO1xuQ3J5cHRvQ29pbkluZm8uZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IHR5cGUgPSBtYXBbS2V5cy50eXBlXTtcbiAgICBjb25zdCBuZXR3b3JrID0gbWFwW0tleXMubmV0d29ya107XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9Db2luSW5mbyh0eXBlLCBuZXR3b3JrKTtcbn07XG5DcnlwdG9Db2luSW5mby5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9Db2luSW5mby5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0NvaW5JbmZvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9FQ0tleSA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1wiY3VydmVcIl0gPSAxXSA9IFwiY3VydmVcIjtcbiAgICBLZXlzW0tleXNbXCJwcml2YXRlXCJdID0gMl0gPSBcInByaXZhdGVcIjtcbiAgICBLZXlzW0tleXNbXCJkYXRhXCJdID0gM10gPSBcImRhdGFcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvRUNLZXkgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc0VDS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q3VydmUgPSAoKSA9PiB0aGlzLmN1cnZlIHx8IDA7XG4gICAgICAgIHRoaXMuaXNQcml2YXRlS2V5ID0gKCkgPT4gdGhpcy5wcml2YXRlS2V5IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmdldERhdGEgPSAoKSA9PiB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0VDS0VZO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnZlKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuY3VydmVdID0gdGhpcy5jdXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLnByaXZhdGVdID0gdGhpcy5wcml2YXRlS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwW0tleXMuZGF0YV0gPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhID0gYXJncy5kYXRhO1xuICAgICAgICB0aGlzLmN1cnZlID0gYXJncy5jdXJ2ZTtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gYXJncy5wcml2YXRlS2V5IHx8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b0VDS2V5ID0gQ3J5cHRvRUNLZXk7XG5DcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgY29uc3QgY3VydmUgPSBtYXBbS2V5cy5jdXJ2ZV07XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IG1hcFtLZXlzLnByaXZhdGVdO1xuICAgIGNvbnN0IGRhdGEgPSBtYXBbS2V5cy5kYXRhXTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtDcnlwdG9FQ0tleV1bZm4uZnJvbURhdGFJdGVtXTogZGVjb2RlZCBbZGF0YUl0ZW1dWyNkYXRhLmRhdGFdIGlzIHVuZGVmaW5lZDogJHtkYXRhSXRlbX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9FQ0tleSh7IGRhdGEsIGN1cnZlLCBwcml2YXRlS2V5IH0pO1xufTtcbkNyeXB0b0VDS2V5LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b0VDS2V5LmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvRUNLZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0hES2V5ID0gdm9pZCAwO1xuY29uc3QgYnM1OGNoZWNrXzEgPSByZXF1aXJlKFwiYnM1OGNoZWNrXCIpO1xuY29uc3QgQ3J5cHRvQ29pbkluZm9fMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0NvaW5JbmZvXCIpO1xuY29uc3QgQ3J5cHRvS2V5cGF0aF8xID0gcmVxdWlyZShcIi4vQ3J5cHRvS2V5cGF0aFwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1wiaXNfbWFzdGVyXCJdID0gMV0gPSBcImlzX21hc3RlclwiO1xuICAgIEtleXNbS2V5c1tcImlzX3ByaXZhdGVcIl0gPSAyXSA9IFwiaXNfcHJpdmF0ZVwiO1xuICAgIEtleXNbS2V5c1tcImtleV9kYXRhXCJdID0gM10gPSBcImtleV9kYXRhXCI7XG4gICAgS2V5c1tLZXlzW1wiY2hhaW5fY29kZVwiXSA9IDRdID0gXCJjaGFpbl9jb2RlXCI7XG4gICAgS2V5c1tLZXlzW1widXNlX2luZm9cIl0gPSA1XSA9IFwidXNlX2luZm9cIjtcbiAgICBLZXlzW0tleXNbXCJvcmlnaW5cIl0gPSA2XSA9IFwib3JpZ2luXCI7XG4gICAgS2V5c1tLZXlzW1wiY2hpbGRyZW5cIl0gPSA3XSA9IFwiY2hpbGRyZW5cIjtcbiAgICBLZXlzW0tleXNbXCJwYXJlbnRfZmluZ2VycHJpbnRcIl0gPSA4XSA9IFwicGFyZW50X2ZpbmdlcnByaW50XCI7XG4gICAgS2V5c1tLZXlzW1wibmFtZVwiXSA9IDldID0gXCJuYW1lXCI7XG4gICAgS2V5c1tLZXlzW1wibm90ZVwiXSA9IDEwXSA9IFwibm90ZVwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5jbGFzcyBDcnlwdG9IREtleSBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzRUNLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0S2V5ID0gKCkgPT4gdGhpcy5rZXk7XG4gICAgICAgIHRoaXMuZ2V0Q2hhaW5Db2RlID0gKCkgPT4gdGhpcy5jaGFpbkNvZGU7XG4gICAgICAgIHRoaXMuaXNNYXN0ZXIgPSAoKSA9PiB0aGlzLm1hc3RlcjtcbiAgICAgICAgdGhpcy5pc1ByaXZhdGVLZXkgPSAoKSA9PiAhIXRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgdGhpcy5nZXRVc2VJbmZvID0gKCkgPT4gdGhpcy51c2VJbmZvO1xuICAgICAgICB0aGlzLmdldE9yaWdpbiA9ICgpID0+IHRoaXMub3JpZ2luO1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuID0gKCkgPT4gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgdGhpcy5nZXRQYXJlbnRGaW5nZXJwcmludCA9ICgpID0+IHRoaXMucGFyZW50RmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0TmFtZSA9ICgpID0+IHRoaXMubmFtZTtcbiAgICAgICAgdGhpcy5nZXROb3RlID0gKCkgPT4gdGhpcy5ub3RlO1xuICAgICAgICB0aGlzLmdldEJpcDMyS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBsZXQgdmVyc2lvbjtcbiAgICAgICAgICAgIGxldCBkZXB0aDtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgcGFyZW50RmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCkuZmlsbCgwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWFzdGVyKCkpIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gQnVmZmVyLmZyb20oJzA0ODhBREU0JywgJ2hleCcpO1xuICAgICAgICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aCA9ICgoX2EgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q29tcG9uZW50cygpLmxlbmd0aCkgfHwgKChfYiA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXREZXB0aCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRocyA9IChfYyA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRDb21wb25lbnRzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBhdGggPSBwYXRoc1twYXRocy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBsYXN0UGF0aC5pc0hhcmRlbmVkKCkgPyBsYXN0UGF0aC5nZXRJbmRleCgpICsgMHg4MDAwMDAwMCA6IGxhc3RQYXRoLmdldEluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFBhcmVudEZpbmdlcnByaW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50ID0gdGhpcy5nZXRQYXJlbnRGaW5nZXJwcmludCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpdmF0ZUtleSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSBCdWZmZXIuZnJvbSgnMDQ4OEFERTQnLCAnaGV4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gQnVmZmVyLmZyb20oJzA0ODhCMjFFJywgJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlcHRoQnVmZmVyID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICAgICAgZGVwdGhCdWZmZXIud3JpdGVVSW50OChkZXB0aCwgMCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyLndyaXRlVUludDMyQkUoaW5kZXgsIDApO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gdGhpcy5nZXRDaGFpbkNvZGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJzNThjaGVja18xLmVuY29kZSkoQnVmZmVyLmNvbmNhdChbdmVyc2lvbiwgZGVwdGhCdWZmZXIsIHBhcmVudEZpbmdlcnByaW50LCBpbmRleEJ1ZmZlciwgY2hhaW5Db2RlLCBrZXldKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSAmJiAoKF9iID0gdGhpcy5nZXRPcmlnaW4oKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFBhdGgoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGAkeyhfZCA9IChfYyA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9TdHJpbmcoJ2hleCcpfS8keyhfZSA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5nZXRQYXRoKCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5nZXRCaXAzMktleSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgIGlmICgoX2YgPSB0aGlzLmdldENoaWxkcmVuKCkpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5nZXRQYXRoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGAvJHsoX2cgPSB0aGlzLmdldENoaWxkcmVuKCkpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5nZXRQYXRoKCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHVwTWFzdGVyS2V5ID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFzdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgICAgICAgICB0aGlzLmNoYWluQ29kZSA9IGFyZ3MuY2hhaW5Db2RlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHVwRGVyaXZlS2V5ID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFzdGVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBhcmdzLmlzUHJpdmF0ZUtleTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgICAgICAgICB0aGlzLmNoYWluQ29kZSA9IGFyZ3MuY2hhaW5Db2RlO1xuICAgICAgICAgICAgdGhpcy51c2VJbmZvID0gYXJncy51c2VJbmZvO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBhcmdzLm9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBhcmdzLmNoaWxkcmVuO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRGaW5nZXJwcmludCA9IGFyZ3MucGFyZW50RmluZ2VycHJpbnQ7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBhcmdzLm5hbWU7XG4gICAgICAgICAgICB0aGlzLm5vdGUgPSBhcmdzLm5vdGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMubWFzdGVyKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuaXNfbWFzdGVyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMua2V5X2RhdGFdID0gdGhpcy5rZXk7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuY2hhaW5fY29kZV0gPSB0aGlzLmNoYWluQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5pc19wcml2YXRlXSA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwW0tleXMua2V5X2RhdGFdID0gdGhpcy5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhaW5Db2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLmNoYWluX2NvZGVdID0gdGhpcy5jaGFpbkNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlSW5mbyA9IHRoaXMudXNlSW5mby50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIHVzZUluZm8uc2V0VGFnKHRoaXMudXNlSW5mby5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLnVzZV9pbmZvXSA9IHVzZUluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLm9yaWdpbi50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5zZXRUYWcodGhpcy5vcmlnaW4uZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5vcmlnaW5dID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zZXRUYWcodGhpcy5jaGlsZHJlbi5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLmNoaWxkcmVuXSA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRGaW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5wYXJlbnRfZmluZ2VycHJpbnRdID0gdGhpcy5wYXJlbnRGaW5nZXJwcmludC5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5uYW1lXSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm90ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLm5vdGVdID0gdGhpcy5ub3RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0obWFwKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3MuaXNNYXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBNYXN0ZXJLZXkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwRGVyaXZlS2V5KGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9IREtleSA9IENyeXB0b0hES2V5O1xuQ3J5cHRvSERLZXkuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IGlzTWFzdGVyID0gISFtYXBbS2V5cy5pc19tYXN0ZXJdO1xuICAgIGNvbnN0IGlzUHJpdmF0ZUtleSA9IG1hcFtLZXlzLmlzX3ByaXZhdGVdO1xuICAgIGNvbnN0IGtleSA9IG1hcFtLZXlzLmtleV9kYXRhXTtcbiAgICBjb25zdCBjaGFpbkNvZGUgPSBtYXBbS2V5cy5jaGFpbl9jb2RlXTtcbiAgICBjb25zdCB1c2VJbmZvID0gbWFwW0tleXMudXNlX2luZm9dXG4gICAgICAgID8gQ3J5cHRvQ29pbkluZm9fMS5DcnlwdG9Db2luSW5mby5mcm9tRGF0YUl0ZW0obWFwW0tleXMudXNlX2luZm9dKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvcmlnaW4gPSBtYXBbS2V5cy5vcmlnaW5dXG4gICAgICAgID8gQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKG1hcFtLZXlzLm9yaWdpbl0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbWFwW0tleXMuY2hpbGRyZW5dXG4gICAgICAgID8gQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKG1hcFtLZXlzLmNoaWxkcmVuXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgX3BhcmVudEZpbmdlcnByaW50ID0gbWFwW0tleXMucGFyZW50X2ZpbmdlcnByaW50XTtcbiAgICBsZXQgcGFyZW50RmluZ2VycHJpbnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKF9wYXJlbnRGaW5nZXJwcmludCkge1xuICAgICAgICBwYXJlbnRGaW5nZXJwcmludCA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfcGFyZW50RmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gbWFwW0tleXMubmFtZV07XG4gICAgY29uc3Qgbm90ZSA9IG1hcFtLZXlzLm5vdGVdO1xuICAgIHJldHVybiBuZXcgQ3J5cHRvSERLZXkoe1xuICAgICAgICBpc01hc3RlcixcbiAgICAgICAgaXNQcml2YXRlS2V5LFxuICAgICAgICBrZXksXG4gICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgdXNlSW5mbyxcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG5vdGUsXG4gICAgfSk7XG59O1xuQ3J5cHRvSERLZXkuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvSERLZXkuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9IREtleS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvS2V5cGF0aCA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUGF0aENvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vUGF0aENvbXBvbmVudFwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcImNvbXBvbmVudHNcIl0gPSAxXSA9IFwiY29tcG9uZW50c1wiO1xuICAgIEtleXNbS2V5c1tcInNvdXJjZV9maW5nZXJwcmludFwiXSA9IDJdID0gXCJzb3VyY2VfZmluZ2VycHJpbnRcIjtcbiAgICBLZXlzW0tleXNbXCJkZXB0aFwiXSA9IDNdID0gXCJkZXB0aFwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5jbGFzcyBDcnlwdG9LZXlwYXRoIGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzID0gW10sIHNvdXJjZUZpbmdlcnByaW50LCBkZXB0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLnNvdXJjZUZpbmdlcnByaW50ID0gc291cmNlRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fS0VZUEFUSDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRQYXRoID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtjb21wb25lbnQuaXNXaWxkY2FyZCgpID8gJyonIDogY29tcG9uZW50LmdldEluZGV4KCl9JHtjb21wb25lbnQuaXNIYXJkZW5lZCgpID8gXCInXCIgOiAnJ31gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50cy5qb2luKCcvJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50cyA9ICgpID0+IHRoaXMuY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VGaW5nZXJwcmludCA9ICgpID0+IHRoaXMuc291cmNlRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0RGVwdGggPSAoKSA9PiB0aGlzLmRlcHRoO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pc1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50LmdldEluZGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQuaXNIYXJkZW5lZCgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcFtLZXlzLmNvbXBvbmVudHNdID0gY29tcG9uZW50cztcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZUZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuc291cmNlX2ZpbmdlcnByaW50XSA9IHRoaXMuc291cmNlRmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmRlcHRoXSA9IHRoaXMuZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9LZXlwYXRoID0gQ3J5cHRvS2V5cGF0aDtcbkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IHBhdGhDb21wb25lbnRzID0gW107XG4gICAgY29uc3QgY29tcG9uZW50cyA9IG1hcFtLZXlzLmNvbXBvbmVudHNdO1xuICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaXNIYXJkZW5lZCA9IGNvbXBvbmVudHNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcGF0aENvbXBvbmVudHMucHVzaChuZXcgUGF0aENvbXBvbmVudF8xLlBhdGhDb21wb25lbnQoeyBpbmRleDogcGF0aCwgaGFyZGVuZWQ6IGlzSGFyZGVuZWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aENvbXBvbmVudHMucHVzaChuZXcgUGF0aENvbXBvbmVudF8xLlBhdGhDb21wb25lbnQoeyBoYXJkZW5lZDogaXNIYXJkZW5lZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgX3NvdXJjZUZpbmdlcnByaW50ID0gbWFwW0tleXMuc291cmNlX2ZpbmdlcnByaW50XTtcbiAgICBsZXQgc291cmNlRmluZ2VycHJpbnQ7XG4gICAgaWYgKF9zb3VyY2VGaW5nZXJwcmludCkge1xuICAgICAgICBzb3VyY2VGaW5nZXJwcmludCA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgc291cmNlRmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfc291cmNlRmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBkZXB0aCA9IG1hcFtLZXlzLmRlcHRoXTtcbiAgICByZXR1cm4gbmV3IENyeXB0b0tleXBhdGgocGF0aENvbXBvbmVudHMsIHNvdXJjZUZpbmdlcnByaW50LCBkZXB0aCk7XG59O1xuQ3J5cHRvS2V5cGF0aC5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvS2V5cGF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvT3V0cHV0ID0gdm9pZCAwO1xuY29uc3QgQ3J5cHRvRUNLZXlfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0VDS2V5XCIpO1xuY29uc3QgQ3J5cHRvSERLZXlfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0hES2V5XCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBNdWx0aUtleV8xID0gcmVxdWlyZShcIi4vTXVsdGlLZXlcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgU2NyaXB0RXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vU2NyaXB0RXhwcmVzc2lvblwiKTtcbmNsYXNzIENyeXB0b091dHB1dCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3Ioc2NyaXB0RXhwcmVzc2lvbnMsIGNyeXB0b0tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjcmlwdEV4cHJlc3Npb25zID0gc2NyaXB0RXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMuY3J5cHRvS2V5ID0gY3J5cHRvS2V5O1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19PVVRQVVQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q3J5cHRvS2V5ID0gKCkgPT4gdGhpcy5jcnlwdG9LZXk7XG4gICAgICAgIHRoaXMuZ2V0SERLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jcnlwdG9LZXkgaW5zdGFuY2VvZiBDcnlwdG9IREtleV8xLkNyeXB0b0hES2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFQ0tleSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIENyeXB0b0VDS2V5XzEuQ3J5cHRvRUNLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9LZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE11bHRpS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgTXVsdGlLZXlfMS5NdWx0aUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyeXB0b0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0U2NyaXB0RXhwcmVzc2lvbnMgPSAoKSA9PiB0aGlzLnNjcmlwdEV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLl90b091dHB1dERlc2NyaXB0b3IgPSAoc2VJbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlSW5kZXggPj0gdGhpcy5zY3JpcHRFeHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9LZXkuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnNjcmlwdEV4cHJlc3Npb25zW3NlSW5kZXhdLmdldEV4cHJlc3Npb24oKX0oJHt0aGlzLl90b091dHB1dERlc2NyaXB0b3Ioc2VJbmRleCArIDEpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvT3V0cHV0RGVzY3JpcHRvcigwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGFJdGVtID0gdGhpcy5jcnlwdG9LZXkudG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleSkge1xuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyh0aGlzLmNyeXB0b0tleS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbG9uZWRTZSA9IFsuLi50aGlzLnNjcmlwdEV4cHJlc3Npb25zXTtcbiAgICAgICAgICAgIGNsb25lZFNlLnJldmVyc2UoKS5mb3JFYWNoKChzZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ1ZhbHVlID0gc2UuZ2V0VGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtLmdldFRhZygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0VGFnKHRhZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtID0gbmV3IGxpYl8xLkRhdGFJdGVtKGRhdGFJdGVtLCB0YWdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9PdXRwdXQgPSBDcnlwdG9PdXRwdXQ7XG5DcnlwdG9PdXRwdXQuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3Qgc2NyaXB0RXhwcmVzc2lvbnMgPSBbXTtcbiAgICBsZXQgX2RhdGFJdGVtID0gZGF0YUl0ZW07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IF90YWcgPSBfZGF0YUl0ZW0uZ2V0VGFnKCk7XG4gICAgICAgIGNvbnN0IHNlID0gU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb24uZnJvbVRhZyhfdGFnKTtcbiAgICAgICAgaWYgKHNlKSB7XG4gICAgICAgICAgICBzY3JpcHRFeHByZXNzaW9ucy5wdXNoKHNlKTtcbiAgICAgICAgICAgIGlmIChfZGF0YUl0ZW0uZ2V0RGF0YSgpIGluc3RhbmNlb2YgbGliXzEuRGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBfZGF0YUl0ZW0gPSBfZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIF90YWcgPSBfZGF0YUl0ZW0uZ2V0VGFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNlTGVuZ3RoID0gc2NyaXB0RXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgIGNvbnN0IGlzTXVsdGlLZXkgPSBzZUxlbmd0aCA+IDAgJiZcbiAgICAgICAgKHNjcmlwdEV4cHJlc3Npb25zW3NlTGVuZ3RoIC0gMV0uZ2V0RXhwcmVzc2lvbigpID09PVxuICAgICAgICAgICAgU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zLk1VTFRJU0lHLmdldEV4cHJlc3Npb24oKSB8fFxuICAgICAgICAgICAgc2NyaXB0RXhwcmVzc2lvbnNbc2VMZW5ndGggLSAxXS5nZXRFeHByZXNzaW9uKCkgPT09XG4gICAgICAgICAgICAgICAgU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zLlNPUlRFRF9NVUxUSVNJRy5nZXRFeHByZXNzaW9uKCkpO1xuICAgIGlmIChpc011bHRpS2V5KSB7XG4gICAgICAgIGNvbnN0IG11bHRpS2V5ID0gTXVsdGlLZXlfMS5NdWx0aUtleS5mcm9tRGF0YUl0ZW0oX2RhdGFJdGVtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDcnlwdG9PdXRwdXQoc2NyaXB0RXhwcmVzc2lvbnMsIG11bHRpS2V5KTtcbiAgICB9XG4gICAgaWYgKF9kYXRhSXRlbS5nZXRUYWcoKSA9PT0gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VGFnKCkpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvSERLZXkgPSBDcnlwdG9IREtleV8xLkNyeXB0b0hES2V5LmZyb21EYXRhSXRlbShfZGF0YUl0ZW0pO1xuICAgICAgICByZXR1cm4gbmV3IENyeXB0b091dHB1dChzY3JpcHRFeHByZXNzaW9ucywgY3J5cHRvSERLZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY3J5cHRvRUNLZXkgPSBDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5LmZyb21EYXRhSXRlbShfZGF0YUl0ZW0pO1xuICAgICAgICByZXR1cm4gbmV3IENyeXB0b091dHB1dChzY3JpcHRFeHByZXNzaW9ucywgY3J5cHRvRUNLZXkpO1xuICAgIH1cbn07XG5DcnlwdG9PdXRwdXQuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvT3V0cHV0LmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvT3V0cHV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9QU0JUID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xuY2xhc3MgQ3J5cHRvUFNCVCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IocHNidCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBzYnQgPSBwc2J0O1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX1BTQlQ7XG4gICAgICAgIHRoaXMuZ2V0UFNCVCA9ICgpID0+IHRoaXMucHNidDtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbSh0aGlzLnBzYnQpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvUFNCVCA9IENyeXB0b1BTQlQ7XG5DcnlwdG9QU0JULmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IHBzYnQgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgaWYgKCFwc2J0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgI1t1ci1yZWdpc3RyeV1bQ3J5cHRvUFNCVF1bZm4uZnJvbURhdGFJdGVtXTogZGVjb2RlZCBbZGF0YUl0ZW1dWyNkYXRhXSBpcyB1bmRlZmluZWQ6ICR7ZGF0YUl0ZW19YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3J5cHRvUFNCVChwc2J0KTtcbn07XG5DcnlwdG9QU0JULmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b1BTQlQuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9QU0JULmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VUlJlZ2lzdHJ5RGVjb2RlciA9IHZvaWQgMDtcbmNvbnN0IGJjX3VyXzEgPSByZXF1aXJlKFwiQG5ncmF2ZWlvL2JjLXVyXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY2xhc3MgVVJSZWdpc3RyeURlY29kZXIgZXh0ZW5kcyBiY191cl8xLlVSRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVzdWx0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXIgPSB0aGlzLnJlc3VsdFVSKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVyLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQllURVMuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkJ5dGVzLmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0hES2V5LmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fS0VZUEFUSC5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvS2V5cGF0aC5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0NPSU5fSU5GTy5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvQ29pbkluZm8uZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19FQ0tFWS5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvRUNLZXkuZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19PVVRQVVQuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b091dHB1dC5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX1BTQlQuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b1BTQlQuZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19BQ0NPVU5ULmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9BY2NvdW50LmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Vbmtub3duVVJUeXBlRXJyb3IoYCNbdXItcmVnaXN0cnldW0RlY29kZXJdW2ZuLnJlc3VsdFJlZ2lzdHJ5VHlwZV06IHJlZ2lzdHJ5IHR5cGUgJHt1ci50eXBlfSBpcyBub3Qgc3VwcG9ydGVkIG5vd2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVVJSZWdpc3RyeURlY29kZXIgPSBVUlJlZ2lzdHJ5RGVjb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdWx0aUtleSA9IHZvaWQgMDtcbmNvbnN0IENyeXB0b0VDS2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9FQ0tleVwiKTtcbmNvbnN0IENyeXB0b0hES2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9IREtleVwiKTtcbmNvbnN0IERhdGFJdGVtXzEgPSByZXF1aXJlKFwiLi9saWIvRGF0YUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJ0aHJlc2hvbGRcIl0gPSAxXSA9IFwidGhyZXNob2xkXCI7XG4gICAgS2V5c1tLZXlzW1wia2V5c1wiXSA9IDJdID0gXCJrZXlzXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIE11bHRpS2V5IGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcih0aHJlc2hvbGQsIGtleXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIHRoaXMuZ2V0VGhyZXNob2xkID0gKCkgPT4gdGhpcy50aHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuZ2V0S2V5cyA9ICgpID0+IHRoaXMua2V5cztcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBtYXBbS2V5cy50aHJlc2hvbGRdID0gdGhpcy50aHJlc2hvbGQ7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5rZXlzLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gay50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0VGFnKGsuZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFwW0tleXMua2V5c10gPSBrZXlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhSXRlbV8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2V0VGhyZXNob2xkKCksXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzLm1hcChrID0+IGsuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQoKSkuam9pbignLCcpLFxuICAgICAgICAgICAgXS5qb2luKCcsJyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5NdWx0aUtleSA9IE11bHRpS2V5O1xuTXVsdGlLZXkuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IG1hcFtLZXlzLnRocmVzaG9sZF07XG4gICAgY29uc3QgX2tleXMgPSBtYXBbS2V5cy5rZXlzXTtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgX2tleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICBpZiAoay5nZXRUYWcoKSA9PT0gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VGFnKCkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChDcnlwdG9IREtleV8xLkNyeXB0b0hES2V5LmZyb21EYXRhSXRlbShrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoay5nZXRUYWcoKSA9PT0gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fRUNLRVkuZ2V0VGFnKCkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5LmZyb21EYXRhSXRlbShrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE11bHRpS2V5KHRocmVzaG9sZCwga2V5cyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlLZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGhDb21wb25lbnQgPSB2b2lkIDA7XG5jbGFzcyBQYXRoQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHRoaXMuZ2V0SW5kZXggPSAoKSA9PiB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmlzV2lsZGNhcmQgPSAoKSA9PiB0aGlzLndpbGRjYXJkO1xuICAgICAgICB0aGlzLmlzSGFyZGVuZWQgPSAoKSA9PiB0aGlzLmhhcmRlbmVkO1xuICAgICAgICB0aGlzLmluZGV4ID0gYXJncy5pbmRleDtcbiAgICAgICAgdGhpcy5oYXJkZW5lZCA9IGFyZ3MuaGFyZGVuZWQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2lsZGNhcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2lsZGNhcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGV4ICYmICh0aGlzLmluZGV4ICYgUGF0aENvbXBvbmVudC5IQVJERU5FRF9CSVQpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNbdXItcmVnaXN0cnldW1BhdGhDb21wb25lbnRdW2ZuLmNvbnN0cnVjdG9yXTogSW52YWxpZCBpbmRleCAke3RoaXMuaW5kZXh9IC0gbW9zdCBzaWduaWZpY2FudCBiaXQgY2Fubm90IGJlIHNldGApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoQ29tcG9uZW50ID0gUGF0aENvbXBvbmVudDtcblBhdGhDb21wb25lbnQuSEFSREVORURfQklUID0gMHg4MDAwMDAwMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGhDb21wb25lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlZ2lzdHJ5SXRlbSA9IHZvaWQgMDtcbmNvbnN0IGJjX3VyXzEgPSByZXF1aXJlKFwiQG5ncmF2ZWlvL2JjLXVyXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jbGFzcyBSZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRvQ0JPUiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRvRGF0YUl0ZW0oKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtSZWdpc3RyeUl0ZW1dW2ZuLnRvQ0JPUl06IHJlZ2lzdHJ5ICR7dGhpcy5nZXRSZWdpc3RyeVR5cGUoKX0ncyBtZXRob2QgdG9EYXRhSXRlbSByZXR1cm5zIHVuZGVmaW5lZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBsaWJfMS5lbmNvZGVEYXRhSXRlbSkodGhpcy50b0RhdGFJdGVtKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvVVIgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJjX3VyXzEuVVIodGhpcy50b0NCT1IoKSwgdGhpcy5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUeXBlKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvVVJFbmNvZGVyID0gKG1heEZyYWdtZW50TGVuZ3RoLCBmaXJzdFNlcU51bSwgbWluRnJhZ21lbnRMZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVyID0gdGhpcy50b1VSKCk7XG4gICAgICAgICAgICBjb25zdCB1ckVuY29kZXIgPSBuZXcgYmNfdXJfMS5VUkVuY29kZXIodXIsIG1heEZyYWdtZW50TGVuZ3RoLCBmaXJzdFNlcU51bSwgbWluRnJhZ21lbnRMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHVyRW5jb2RlcjtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJ5SXRlbSA9IFJlZ2lzdHJ5SXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZ2lzdHJ5SXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVnaXN0cnlUeXBlcyA9IGV4cG9ydHMuUmVnaXN0cnlUeXBlID0gdm9pZCAwO1xuY2xhc3MgUmVnaXN0cnlUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB0YWcpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuZ2V0VGFnID0gKCkgPT4gdGhpcy50YWc7XG4gICAgICAgIHRoaXMuZ2V0VHlwZSA9ICgpID0+IHRoaXMudHlwZTtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJ5VHlwZSA9IFJlZ2lzdHJ5VHlwZTtcbmV4cG9ydHMuUmVnaXN0cnlUeXBlcyA9IHtcbiAgICBVVUlEOiBuZXcgUmVnaXN0cnlUeXBlKCd1dWlkJywgMzcpLFxuICAgIEJZVEVTOiBuZXcgUmVnaXN0cnlUeXBlKCdieXRlcycsIHVuZGVmaW5lZCksXG4gICAgQ1JZUFRPX0hES0VZOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8taGRrZXknLCAzMDMpLFxuICAgIENSWVBUT19LRVlQQVRIOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8ta2V5cGF0aCcsIDMwNCksXG4gICAgQ1JZUFRPX0NPSU5fSU5GTzogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWNvaW4taW5mbycsIDMwNSksXG4gICAgQ1JZUFRPX0VDS0VZOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tZWNrZXknLCAzMDYpLFxuICAgIENSWVBUT19PVVRQVVQ6IG5ldyBSZWdpc3RyeVR5cGUoJ2NyeXB0by1vdXRwdXQnLCAzMDgpLFxuICAgIENSWVBUT19QU0JUOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tcHNidCcsIDMxMCksXG4gICAgQ1JZUFRPX0FDQ09VTlQ6IG5ldyBSZWdpc3RyeVR5cGUoJ2NyeXB0by1hY2NvdW50JywgMzExKSxcbiAgICBDUllQVE9fTVVMVElfQUNDT1VOVFM6IG5ldyBSZWdpc3RyeVR5cGUoXCJjcnlwdG8tbXVsdGktYWNjb3VudHNcIiwgMTEwMyksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVnaXN0cnlUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY3JpcHRFeHByZXNzaW9ucyA9IGV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbiA9IHZvaWQgMDtcbmNsYXNzIFNjcmlwdEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5nZXRUYWcgPSAoKSA9PiB0aGlzLnRhZztcbiAgICAgICAgdGhpcy5nZXRFeHByZXNzaW9uID0gKCkgPT4gdGhpcy5leHByZXNzaW9uO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbiA9IFNjcmlwdEV4cHJlc3Npb247XG5TY3JpcHRFeHByZXNzaW9uLmZyb21UYWcgPSAodGFnKSA9PiB7XG4gICAgY29uc3Qgc2UgPSBPYmplY3QudmFsdWVzKGV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbnMpLmZpbmQoKHNlKSA9PiBzZS5nZXRUYWcoKSA9PT0gdGFnKTtcbiAgICByZXR1cm4gc2U7XG59O1xuZXhwb3J0cy5TY3JpcHRFeHByZXNzaW9ucyA9IHtcbiAgICBTQ1JJUFRfSEFTSDogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAwLCAnc2gnKSxcbiAgICBXSVRORVNTX1NDUklQVF9IQVNIOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDEsICd3c2gnKSxcbiAgICBQVUJMSUNfS0VZOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDIsICdwaycpLFxuICAgIFBVQkxJQ19LRVlfSEFTSDogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAzLCAncGtoJyksXG4gICAgV0lUTkVTU19QVUJMSUNfS0VZX0hBU0g6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNCwgJ3dwa2gnKSxcbiAgICBDT01CTzogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDA1LCAnY29tYm8nKSxcbiAgICBNVUxUSVNJRzogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDA2LCAnbXVsdGknKSxcbiAgICBTT1JURURfTVVMVElTSUc6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNywgJ3NvcnRlZG11bHRpJyksXG4gICAgQUREUkVTUzogbmV3IFNjcmlwdEV4cHJlc3Npb24oMzA3LCAnYWRkcicpLFxuICAgIFJBV19TQ1JJUFQ6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwOCwgJ3JhdycpLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjcmlwdEV4cHJlc3Npb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVua25vd25VUlR5cGVFcnJvciA9IHZvaWQgMDtcbmNsYXNzIFVua25vd25VUlR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5rbm93blVSVHlwZUVycm9yID0gVW5rbm93blVSVHlwZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b011bHRpQWNjb3VudHMgPSB2b2lkIDA7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9SZWdpc3RyeVR5cGVcIik7XG5jb25zdCBDcnlwdG9IREtleV8xID0gcmVxdWlyZShcIi4uL0NyeXB0b0hES2V5XCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi4vbGliXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJtYXN0ZXJGaW5nZXJwcmludFwiXSA9IDFdID0gXCJtYXN0ZXJGaW5nZXJwcmludFwiO1xuICAgIEtleXNbS2V5c1tcImtleXNcIl0gPSAyXSA9IFwia2V5c1wiO1xuICAgIEtleXNbS2V5c1tcImRldmljZVwiXSA9IDNdID0gXCJkZXZpY2VcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvTXVsdGlBY2NvdW50cyBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IobWFzdGVyRmluZ2VycHJpbnQsIGtleXMsIGRldmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hc3RlckZpbmdlcnByaW50ID0gbWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gZGV2aWNlO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX01VTFRJX0FDQ09VTlRTO1xuICAgICAgICB0aGlzLmdldE1hc3RlckZpbmdlcnByaW50ID0gKCkgPT4gdGhpcy5tYXN0ZXJGaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5nZXRLZXlzID0gKCkgPT4gdGhpcy5rZXlzO1xuICAgICAgICB0aGlzLmdldERldmljZSA9ICgpID0+IHRoaXMuZGV2aWNlO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdID0gdGhpcy5tYXN0ZXJGaW5nZXJwcmludC5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMua2V5c10gPSB0aGlzLmtleXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gaXRlbS50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyhpdGVtLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuZGV2aWNlXSA9IHRoaXMuZGV2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvTXVsdGlBY2NvdW50cyA9IENyeXB0b011bHRpQWNjb3VudHM7XG5DcnlwdG9NdWx0aUFjY291bnRzLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCBtYXN0ZXJGaW5nZXJwcmludCA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICBjb25zdCBfbWFzdGVyRmluZ2VycHJpbnQgPSBtYXBbS2V5cy5tYXN0ZXJGaW5nZXJwcmludF07XG4gICAgaWYgKF9tYXN0ZXJGaW5nZXJwcmludCkge1xuICAgICAgICBtYXN0ZXJGaW5nZXJwcmludC53cml0ZVVJbnQzMkJFKF9tYXN0ZXJGaW5nZXJwcmludCwgMCk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBtYXBbS2V5cy5rZXlzXTtcbiAgICBjb25zdCBjcnlwdG9IREtleXMgPSBrZXlzLm1hcCgoaXRlbSkgPT4gQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleS5mcm9tRGF0YUl0ZW0oaXRlbSkpO1xuICAgIGNvbnN0IGRldmljZSA9IG1hcFtLZXlzLmRldmljZV07XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9NdWx0aUFjY291bnRzKG1hc3RlckZpbmdlcnByaW50LCBjcnlwdG9IREtleXMsIGRldmljZSk7XG59O1xuQ3J5cHRvTXVsdGlBY2NvdW50cy5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9NdWx0aUFjY291bnRzLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvTXVsdGlBY2NvdW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnVmZmVyID0gZXhwb3J0cy5leHRlbmQgPSBleHBvcnRzLlBhdGhDb21wb25lbnQgPSBleHBvcnRzLlNjcmlwdEV4cHJlc3Npb25zID0gZXhwb3J0cy5NdWx0aUtleSA9IGV4cG9ydHMuQ3J5cHRvUFNCVCA9IGV4cG9ydHMuQ3J5cHRvT3V0cHV0ID0gZXhwb3J0cy5DcnlwdG9FQ0tleSA9IGV4cG9ydHMuQ3J5cHRvQ29pbkluZm9OZXR3b3JrID0gZXhwb3J0cy5DcnlwdG9Db2luSW5mb1R5cGUgPSBleHBvcnRzLkNyeXB0b0NvaW5JbmZvID0gZXhwb3J0cy5DcnlwdG9LZXlwYXRoID0gZXhwb3J0cy5DcnlwdG9NdWx0aUFjY291bnRzID0gZXhwb3J0cy5DcnlwdG9IREtleSA9IGV4cG9ydHMuQ3J5cHRvQWNjb3VudCA9IGV4cG9ydHMuQnl0ZXMgPSBleHBvcnRzLlVSUmVnaXN0cnlEZWNvZGVyID0gZXhwb3J0cy5EYXRhSXRlbSA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5yZXF1aXJlKFwiLi9wYXRjaENCT1JcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfMS5CdWZmZXI7IH0gfSk7XG5jb25zdCBDcnlwdG9IREtleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvSERLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9IREtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleTsgfSB9KTtcbmNvbnN0IENyeXB0b0tleXBhdGhfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0tleXBhdGhcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9LZXlwYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9LZXlwYXRoXzEuQ3J5cHRvS2V5cGF0aDsgfSB9KTtcbmNvbnN0IENyeXB0b0NvaW5JbmZvXzEgPSByZXF1aXJlKFwiLi9DcnlwdG9Db2luSW5mb1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0NvaW5JbmZvXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9Db2luSW5mb18xLkNyeXB0b0NvaW5JbmZvOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvQ29pbkluZm9UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9Db2luSW5mb18xLlR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9Db2luSW5mb05ldHdvcmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b0NvaW5JbmZvXzEuTmV0d29yazsgfSB9KTtcbmNvbnN0IENyeXB0b0VDS2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9FQ0tleVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0VDS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5OyB9IH0pO1xuY29uc3QgQnl0ZXNfMSA9IHJlcXVpcmUoXCIuL0J5dGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJ5dGVzXzEuQnl0ZXM7IH0gfSk7XG5jb25zdCBDcnlwdG9PdXRwdXRfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b091dHB1dFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b091dHB1dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvT3V0cHV0XzEuQ3J5cHRvT3V0cHV0OyB9IH0pO1xuY29uc3QgQ3J5cHRvUFNCVF8xID0gcmVxdWlyZShcIi4vQ3J5cHRvUFNCVFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b1BTQlRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b1BTQlRfMS5DcnlwdG9QU0JUOyB9IH0pO1xuY29uc3QgQ3J5cHRvQWNjb3VudF8xID0gcmVxdWlyZShcIi4vQ3J5cHRvQWNjb3VudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0FjY291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b0FjY291bnRfMS5DcnlwdG9BY2NvdW50OyB9IH0pO1xuY29uc3QgRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vRGVjb2RlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVSUmVnaXN0cnlEZWNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZWNvZGVyXzEuVVJSZWdpc3RyeURlY29kZXI7IH0gfSk7XG5jb25zdCBNdWx0aUtleV8xID0gcmVxdWlyZShcIi4vTXVsdGlLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aUtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTXVsdGlLZXlfMS5NdWx0aUtleTsgfSB9KTtcbmNvbnN0IFNjcmlwdEV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL1NjcmlwdEV4cHJlc3Npb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY3JpcHRFeHByZXNzaW9uc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zOyB9IH0pO1xuY29uc3QgUGF0aENvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vUGF0aENvbXBvbmVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhdGhDb21wb25lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50OyB9IH0pO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xudmFyIGxpYl8yID0gcmVxdWlyZShcIi4vbGliXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYl8yLkRhdGFJdGVtOyB9IH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgQ3J5cHRvTXVsdGlBY2NvdW50c18xID0gcmVxdWlyZShcIi4vZXh0ZW5kZWQvQ3J5cHRvTXVsdGlBY2NvdW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b011bHRpQWNjb3VudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b011bHRpQWNjb3VudHNfMS5DcnlwdG9NdWx0aUFjY291bnRzOyB9IH0pO1xuY29uc3QgVVJsaWIgPSB7XG4gICAgVVJSZWdpc3RyeURlY29kZXI6IERlY29kZXJfMS5VUlJlZ2lzdHJ5RGVjb2RlcixcbiAgICBCeXRlczogQnl0ZXNfMS5CeXRlcyxcbiAgICBDcnlwdG9BY2NvdW50OiBDcnlwdG9BY2NvdW50XzEuQ3J5cHRvQWNjb3VudCxcbiAgICBDcnlwdG9IREtleTogQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleSxcbiAgICBDcnlwdG9NdWx0aUFjY291bnRzOiBDcnlwdG9NdWx0aUFjY291bnRzXzEuQ3J5cHRvTXVsdGlBY2NvdW50cyxcbiAgICBDcnlwdG9LZXlwYXRoOiBDcnlwdG9LZXlwYXRoXzEuQ3J5cHRvS2V5cGF0aCxcbiAgICBDcnlwdG9Db2luSW5mbzogQ3J5cHRvQ29pbkluZm9fMS5DcnlwdG9Db2luSW5mbyxcbiAgICBDcnlwdG9Db2luSW5mb1R5cGU6IENyeXB0b0NvaW5JbmZvXzEuVHlwZSxcbiAgICBDcnlwdG9Db2luSW5mb05ldHdvcms6IENyeXB0b0NvaW5JbmZvXzEuTmV0d29yayxcbiAgICBDcnlwdG9FQ0tleTogQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleSxcbiAgICBDcnlwdG9PdXRwdXQ6IENyeXB0b091dHB1dF8xLkNyeXB0b091dHB1dCxcbiAgICBDcnlwdG9QU0JUOiBDcnlwdG9QU0JUXzEuQ3J5cHRvUFNCVCxcbiAgICBNdWx0aUtleTogTXVsdGlLZXlfMS5NdWx0aUtleSxcbiAgICBTY3JpcHRFeHByZXNzaW9uczogU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zLFxuICAgIFBhdGhDb21wb25lbnQ6IFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50LFxufTtcbmNvbnN0IGNib3IgPSB7XG4gICAgYWRkUmVhZGVyOiBsaWJfMS5hZGRSZWFkZXIsXG4gICAgYWRkU2VtYW50aWNEZWNvZGU6IGxpYl8xLmFkZFNlbWFudGljRGVjb2RlLFxuICAgIGFkZFNlbWFudGljRW5jb2RlOiBsaWJfMS5hZGRTZW1hbnRpY0VuY29kZSxcbiAgICBhZGRXcml0ZXI6IGxpYl8xLmFkZFdyaXRlcixcbiAgICBwYXRjaFRhZ3M6IHV0aWxzXzEucGF0Y2hUYWdzLFxufTtcbmNvbnN0IGV4dGVuZCA9IHtcbiAgICBSZWdpc3RyeVR5cGVzOiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLFxuICAgIFJlZ2lzdHJ5SXRlbTogUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtLFxuICAgIFJlZ2lzdHJ5VHlwZTogUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlLFxuICAgIGRlY29kZVRvRGF0YUl0ZW06IGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0sXG4gICAgZW5jb2RlRGF0YUl0ZW06IGxpYl8xLmVuY29kZURhdGFJdGVtLFxuICAgIGNib3IsXG59O1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0RlY29kZXJcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9saWJcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9BY2NvdW50XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vQ3J5cHRvUFNCVFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0hES2V5XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vZXh0ZW5kZWQvQ3J5cHRvTXVsdGlBY2NvdW50c1wiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b091dHB1dFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0NvaW5JbmZvXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vQ3J5cHRvRUNLZXlcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9NdWx0aUtleVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0tleXBhdGhcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9wYXRjaENCT1JcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9QYXRoQ29tcG9uZW50XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi91dGlsc1wiKSwgZXhwb3J0cyk7XG5leHBvcnRzLmRlZmF1bHQgPSBVUmxpYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhSXRlbSA9IHZvaWQgMDtcbmNsYXNzIERhdGFJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB0YWcpIHtcbiAgICAgICAgdGhpcy5zZXRUYWcgPSAodGFnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhclRhZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFRhZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhSXRlbSA9IERhdGFJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWwuQ0JPUiA9IGZhY3RvcnkoKTtcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeyBEYXRhSXRlbSB9ID0gcmVxdWlyZSgnLi9EYXRhSXRlbScpO1xuICAgIHZhciBDQk9SID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQmluYXJ5SGV4KGhleCkge1xuICAgICAgICAgICAgdGhpcy4kaGV4ID0gaGV4O1xuICAgICAgICB9XG4gICAgICAgIEJpbmFyeUhleC5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaGV4Lmxlbmd0aCAvIDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdCB8fCBmb3JtYXQgPT09ICdoZXgnIHx8IGZvcm1hdCA9PT0gMTYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRoZXg7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3V0Zi04Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZCArPSAnJScgKyB0aGlzLiRoZXguc3Vic3RyaW5nKGksIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnbGF0aW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkLnB1c2gocGFyc2VJbnQodGhpcy4kaGV4LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBlbmNvZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbmlzZWQgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIEJpbmFyeUhleC5mcm9tTGF0aW5TdHJpbmcgPSBmdW5jdGlvbiAobGF0aW5TdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBoZXggPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW5TdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGxhdGluU3RyaW5nLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwYWlyLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcGFpciA9ICcwJyArIHBhaXI7XG4gICAgICAgICAgICAgICAgaGV4ICs9IHBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleChoZXgpO1xuICAgICAgICB9O1xuICAgICAgICBCaW5hcnlIZXguZnJvbVV0ZjhTdHJpbmcgPSBmdW5jdGlvbiAodXRmOFN0cmluZykge1xuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cmluZyk7XG4gICAgICAgICAgICB2YXIgaGV4ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RlZC5jaGFyQXQoaSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICBoZXggKz0gZW5jb2RlZC5zdWJzdHJpbmcoaSArIDEsIGkgKyAzKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhleFBhaXIgPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGV4UGFpci5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4UGFpciA9ICcwJyArIGhleFBhaXI7XG4gICAgICAgICAgICAgICAgICAgIGhleCArPSBoZXhQYWlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5SGV4KGhleCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZW1hbnRpY0VuY29kZXJzID0gW107XG4gICAgICAgIHZhciBzZW1hbnRpY0RlY29kZXJzID0ge307XG4gICAgICAgIHZhciBub3RJbXBsZW1lbnRlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobGFiZWwgKyAnIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gUmVhZGVyKCkgeyB9XG4gICAgICAgIFJlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBwZWVrQnl0ZTogbm90SW1wbGVtZW50ZWQoJ3BlZWtCeXRlJyksXG4gICAgICAgICAgICByZWFkQnl0ZTogbm90SW1wbGVtZW50ZWQoJ3JlYWRCeXRlJyksXG4gICAgICAgICAgICByZWFkQ2h1bms6IG5vdEltcGxlbWVudGVkKCdyZWFkQ2h1bmsnKSxcbiAgICAgICAgICAgIHJlYWRGbG9hdDE2OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbGYgPSB0aGlzLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSAoaGFsZiAmIDB4N2ZmZikgPj4gMTA7XG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhID0gaGFsZiAmIDB4M2ZmO1xuICAgICAgICAgICAgICAgIHZhciBuZWdhdGl2ZSA9IGhhbGYgJiAweDgwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAweDFmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW50aXNzYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IGV4cG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5wb3coMiwgZXhwb25lbnQgLSAyNSkgKiAoMTAyNCArIG1hbnRpc3NhKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucG93KDIsIC0yNCkgKiBtYW50aXNzYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAtbWFnbml0dWRlIDogbWFnbml0dWRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRGbG9hdDMyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludFZhbHVlID0gdGhpcy5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gKGludFZhbHVlICYgMHg3ZmZmZmZmZikgPj4gMjM7XG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhID0gaW50VmFsdWUgJiAweDdmZmZmZjtcbiAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBpbnRWYWx1ZSAmIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAweGZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW50aXNzYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IGV4cG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5wb3coMiwgZXhwb25lbnQgLSAyMyAtIDEyNykgKiAoODM4ODYwOCArIG1hbnRpc3NhKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucG93KDIsIC0yMyAtIDEyNikgKiBtYW50aXNzYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAtbWFnbml0dWRlIDogbWFnbml0dWRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRGbG9hdDY0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludDEgPSB0aGlzLnJlYWRVaW50MzIoKSwgaW50MiA9IHRoaXMucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IChpbnQxID4+IDIwKSAmIDB4N2ZmO1xuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYSA9IChpbnQxICYgMHhmZmZmZikgKiA0Mjk0OTY3Mjk2ICsgaW50MjtcbiAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBpbnQxICYgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDB4N2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW50aXNzYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IGV4cG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5wb3coMiwgZXhwb25lbnQgLSA1MiAtIDEwMjMpICogKDQ1MDM1OTk2MjczNzA0OTYgKyBtYW50aXNzYSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCAtNTIgLSAxMDIyKSAqIG1hbnRpc3NhO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1tYWduaXR1ZGUgOiBtYWduaXR1ZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZFVpbnQxNjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRCeXRlKCkgKiAyNTYgKyB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZFVpbnQzMjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50MTYoKSAqIDY1NTM2ICsgdGhpcy5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZFVpbnQ2NDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50MzIoKSAqIDQyOTQ5NjcyOTYgKyB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIFdyaXRlcigpIHsgfVxuICAgICAgICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgd3JpdGVCeXRlOiBub3RJbXBsZW1lbnRlZCgnd3JpdGVCeXRlJyksXG4gICAgICAgICAgICByZXN1bHQ6IG5vdEltcGxlbWVudGVkKCdyZXN1bHQnKSxcbiAgICAgICAgICAgIHdyaXRlRmxvYXQxNjogbm90SW1wbGVtZW50ZWQoJ3dyaXRlRmxvYXQxNicpLFxuICAgICAgICAgICAgd3JpdGVGbG9hdDMyOiBub3RJbXBsZW1lbnRlZCgnd3JpdGVGbG9hdDMyJyksXG4gICAgICAgICAgICB3cml0ZUZsb2F0NjQ6IG5vdEltcGxlbWVudGVkKCd3cml0ZUZsb2F0NjQnKSxcbiAgICAgICAgICAgIHdyaXRlVWludDE2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZSgodmFsdWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZSh2YWx1ZSAmIDB4ZmYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlVWludDMyOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVWludDE2KCh2YWx1ZSA+PiAxNikgJiAweGZmZmYpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVaW50MTYodmFsdWUgJiAweGZmZmYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlVWludDY0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gOTAwNzE5OTI1NDc0MDk5MiB8fCB2YWx1ZSA8PSAtOTAwNzE5OTI1NDc0MDk5Mikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNvZGUgVWludDY0IG9mOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbWFnbml0dWRlIHRvIGJpZyAoZmxvYXRpbmcgcG9pbnQgZXJyb3JzKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVWludDMyKE1hdGguZmxvb3IodmFsdWUgLyA0Mjk0OTY3Mjk2KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVVpbnQzMih2YWx1ZSAlIDQyOTQ5NjcyOTYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlU3RyaW5nOiBub3RJbXBsZW1lbnRlZCgnd3JpdGVTdHJpbmcnKSxcbiAgICAgICAgICAgIGNhbldyaXRlQmluYXJ5OiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JpdGVCaW5hcnk6IG5vdEltcGxlbWVudGVkKCd3cml0ZUNodW5rJyksXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRIZWFkZXJSYXcocmVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gcmVhZGVyLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICB2YXIgbWFqb3JUeXBlID0gZmlyc3RCeXRlID4+IDUsIHZhbHVlID0gZmlyc3RCeXRlICYgMHgxZjtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IG1ham9yVHlwZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXIudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAyNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDI0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gMjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDI2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSAyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZFVpbnQ2NCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gMzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vdEltcGxlbWVudGVkKCdBZGRpdGlvbmFsIGluZm86ICcgKyB2YWx1ZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZUhlYWRlclJhdyh0eXBlLCB2YWx1ZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKCh0eXBlIDw8IDUpIHwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlSGVhZGVyKHR5cGUsIHZhbHVlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSB0eXBlIDw8IDU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAyNCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJ5dGUoZmlyc3RCeXRlIHwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IDI0KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgNjU1MzYpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IDI1KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVaW50MTYodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZShmaXJzdEJ5dGUgfCAyNik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVWludDMyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJ5dGUoZmlyc3RCeXRlIHwgMjcpO1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVVpbnQ2NCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3BDb2RlID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZVJlYWRlcihyZWFkZXIpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkSGVhZGVyUmF3KHJlYWRlcik7XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlci50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSAtIHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRDaHVuayh2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSByZWFkZXIucmVhZENodW5rKHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheUxlbmd0aCA9IHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnR5cGUgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCAqPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZGVjb2RlUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaXRlbSA9IGRlY29kZVJlYWRlcihyZWFkZXIpKSAhPT0gc3RvcENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnR5cGUgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpSZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqUmVzdWx0W3Jlc3VsdFtpXV0gPSByZXN1bHRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSB2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb2RlciA9IHNlbWFudGljRGVjb2RlcnNbdGFnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRlY29kZVJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlciA/IGRlY29kZXIocmVzdWx0KSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXIudmFsdWUgPT09IDI1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGbG9hdDE2KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyLnZhbHVlID09PSAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRmxvYXQzMigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlYWRlci52YWx1ZSA9PT0gMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEZsb2F0NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3BDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZml4ZWQgdmFsdWU6ICcgKyBoZWFkZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBoZWFkZXI6ICcgKyBKU09OLnN0cmluZ2lmeShoZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZVdyaXRlcihkYXRhLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VtYW50aWNFbmNvZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHNlbWFudGljRW5jb2RlcnNbaV0uZm4oZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNiwgc2VtYW50aWNFbmNvZGVyc1tpXS50YWcsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVXcml0ZXIocmVwbGFjZW1lbnQsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEudG9DQk9SID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9DQk9SKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMCwgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMSwgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMiwgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDcsIDIzLCB3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoZGF0YSkgPT09IGRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA8IDkwMDcxOTkyNTQ3NDA5OTIgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA+IC05MDA3MTk5MjU0NzQwOTkyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMSwgLTEgLSBkYXRhLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMCwgZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXJSYXcoNywgMjcsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUZsb2F0NjQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlU3RyaW5nKGRhdGEsIGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMywgbGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod3JpdGVyLmNhbldyaXRlQmluYXJ5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQmluYXJ5KGRhdGEsIGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMiwgbGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwaS5jb25maWcudXNlVG9KU09OICYmIHR5cGVvZiBkYXRhLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNCwgZGF0YS5sZW5ndGgsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGFbaV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDUsIGtleXMubGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoa2V5c1tpXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoZGF0YVtrZXlzW2ldXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihudW1iZXIsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGFba2V5c1tpXV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NCT1IgZW5jb2Rpbmcgbm90IHN1cHBvcnRlZDogJyArIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWFkZXJGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHdyaXRlckZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgdXNlVG9KU09OOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFdyaXRlcjogZnVuY3Rpb24gKGZvcm1hdCwgd3JpdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IGYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlckZ1bmN0aW9uKGYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlckZ1bmN0aW9ucy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFJlYWRlcjogZnVuY3Rpb24gKGZvcm1hdCwgcmVhZGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKGRhdGEsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IGYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlckZ1bmN0aW9uKGRhdGEsIGYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlckZ1bmN0aW9ucy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY29kZTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3JpdGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gd3JpdGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVyID0gZnVuYyhmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXIucmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvdXRwdXQgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNvZGVEYXRhSXRlbTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3JpdGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gd3JpdGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVyID0gZnVuYyhmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5nZXRUYWcoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGEsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5yZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhLmdldERhdGEoKSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyLnJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3V0cHV0IGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkZXJGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSByZWFkZXJGdW5jdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBmdW5jKGRhdGEsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGlucHV0IGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlVG9EYXRhSXRlbTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVhZGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gcmVhZGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gZnVuYyhkYXRhLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGFJdGVtKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBpbnB1dCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFNlbWFudGljRW5jb2RlOiBmdW5jdGlvbiAodGFnLCBmbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAnbnVtYmVyJyB8fCB0YWcgJSAxICE9PSAwIHx8IHRhZyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWcgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VtYW50aWNFbmNvZGVycy5wdXNoKHsgdGFnOiB0YWcsIGZuOiBmbiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRTZW1hbnRpY0RlY29kZTogZnVuY3Rpb24gKHRhZywgZm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZyAhPT0gJ251bWJlcicgfHwgdGFnICUgMSAhPT0gMCB8fCB0YWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFnIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbWFudGljRGVjb2RlcnNbdGFnXSA9IGZuO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUucGVla0J5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZFVJbnQxNkJFKHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkJFKHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRGbG9hdEJFKHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWREb3VibGVCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5jb3B5KHJlc3VsdCwgMCwgdGhpcy5wb3MsICh0aGlzLnBvcyArPSBsZW5ndGgpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcldyaXRlcihzdHJpbmdGb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGggPSAxNjM4NDtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdGb3JtYXQgPSBzdHJpbmdGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlclt0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID49IHRoaXMubGF0ZXN0QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2godGhpcy5sYXRlc3RCdWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoKys7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXRCRSh2YWx1ZSwgMCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRG91YmxlQkUodmFsdWUsIDApO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZywgbGVuZ3RoRnVuYykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0cmluZywgJ3V0Zi04Jyk7XG4gICAgICAgICAgICBsZW5ndGhGdW5jKGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLmNhbldyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQnVmZmVyO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGJ1ZmZlciwgbGVuZ3RoRnVuYykge1xuICAgICAgICAgICAgbGVuZ3RoRnVuYyhidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgaWYgKCEoY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlcldyaXRlciBvbmx5IGFjY2VwdHMgQnVmZmVycycpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXRlc3RCdWZmZXIubGVuZ3RoIC0gdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPj1cbiAgICAgICAgICAgICAgICBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5jb3B5KHRoaXMubGF0ZXN0QnVmZmVyLCB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA+PSB0aGlzLmxhdGVzdEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMucHVzaCh0aGlzLmxhdGVzdEJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKHRoaXMubGF0ZXN0QnVmZmVyLnNsaWNlKDAsIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5kZWZhdWx0QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2ModGhpcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBsZXRlQnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmNvbXBsZXRlQnVmZmVyc1tpXTtcbiAgICAgICAgICAgICAgICBidWZmZXIuY29weShyZXN1bHQsIG9mZnNldCwgMCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlci5jb3B5KHJlc3VsdCwgb2Zmc2V0LCAwLCB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJpbmdGb3JtYXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZyh0aGlzLnN0cmluZ0Zvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXBpLmFkZFJlYWRlcihmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2hleCcgfHwgZm9ybWF0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFwaS5hZGRXcml0ZXIoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9ybWF0IHx8IGZvcm1hdCA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSAnaGV4JyB8fCBmb3JtYXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gSGV4UmVhZGVyKGhleCkge1xuICAgICAgICAgICAgdGhpcy5oZXggPSBoZXg7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgSGV4UmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEhleFJlYWRlci5wcm90b3R5cGUucGVla0J5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHRoaXMuaGV4LnN1YnN0cmluZyh0aGlzLnBvcywgMik7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQocGFpciwgMTYpO1xuICAgICAgICB9O1xuICAgICAgICBIZXhSZWFkZXIucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLmhleC5zdWJzdHJpbmcodGhpcy5wb3MsIHRoaXMucG9zICsgMik7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhaXIsIDE2KTtcbiAgICAgICAgfTtcbiAgICAgICAgSGV4UmVhZGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaGV4ID0gdGhpcy5oZXguc3Vic3RyaW5nKHRoaXMucG9zLCB0aGlzLnBvcyArIGxlbmd0aCAqIDIpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoICogMjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5SGV4KGhleCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIEhleFdyaXRlcihmaW5hbEZvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy4kaGV4ID0gJyc7XG4gICAgICAgICAgICB0aGlzLmZpbmFsRm9ybWF0ID0gZmluYWxGb3JtYXQgfHwgJ2hleCc7XG4gICAgICAgIH1cbiAgICAgICAgSGV4V3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMjU1KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnl0ZSB2YWx1ZSBvdXQgb2YgcmFuZ2U6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGhleCArPSBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUuY2FuV3JpdGVCaW5hcnkgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiAoY2h1bmsgaW5zdGFuY2VvZiBCaW5hcnlIZXggfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikpO1xuICAgICAgICB9O1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLndyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGNodW5rLCBsZW5ndGhGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgQmluYXJ5SGV4KSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoRnVuY3Rpb24oY2h1bmsubGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGhleCArPSBjaHVuay4kaGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGxlbmd0aEZ1bmN0aW9uKGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaGV4ICs9IGNodW5rLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hleFdyaXRlciBvbmx5IGFjY2VwdHMgQmluYXJ5SGV4IG9yIEJ1ZmZlcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgSGV4V3JpdGVyLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbEZvcm1hdCA9PT0gJ2J1ZmZlcicgJiYgdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLiRoZXgsICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5SGV4KHRoaXMuJGhleCkudG9TdHJpbmcodGhpcy5maW5hbEZvcm1hdCk7XG4gICAgICAgIH07XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nLCBsZW5ndGhGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJpbmFyeUhleC5mcm9tVXRmOFN0cmluZyhzdHJpbmcpO1xuICAgICAgICAgICAgbGVuZ3RoRnVuY3Rpb24oYnVmZmVyLmxlbmd0aCgpKTtcbiAgICAgICAgICAgIHRoaXMuJGhleCArPSBidWZmZXIuJGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgYXBpLmFkZFJlYWRlcihmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJpbmFyeUhleCB8fCBkYXRhLiRoZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhleFJlYWRlcihkYXRhLiRoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhleFJlYWRlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5hZGRXcml0ZXIoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhleFdyaXRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9KSgpO1xuICAgIENCT1IuYWRkU2VtYW50aWNFbmNvZGUoMCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmFkZFNlbWFudGljRGVjb2RlKDAsIGZ1bmN0aW9uIChpc29TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGlzb1N0cmluZyk7XG4gICAgfSlcbiAgICAgICAgLmFkZFNlbWFudGljRGVjb2RlKDEsIGZ1bmN0aW9uIChpc29TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGlzb1N0cmluZyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIENCT1I7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNib3Itc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YUl0ZW0gPSBleHBvcnRzLmFkZFdyaXRlciA9IGV4cG9ydHMuYWRkUmVhZGVyID0gZXhwb3J0cy5hZGRTZW1hbnRpY0VuY29kZSA9IGV4cG9ydHMuYWRkU2VtYW50aWNEZWNvZGUgPSBleHBvcnRzLmRlY29kZVRvRGF0YUl0ZW0gPSBleHBvcnRzLmVuY29kZURhdGFJdGVtID0gdm9pZCAwO1xudmFyIGNib3Jfc3luY18xID0gcmVxdWlyZShcIi4vY2Jvci1zeW5jXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNib3Jfc3luY18xLmVuY29kZURhdGFJdGVtOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlVG9EYXRhSXRlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuZGVjb2RlVG9EYXRhSXRlbTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFNlbWFudGljRGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5hZGRTZW1hbnRpY0RlY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFNlbWFudGljRW5jb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5hZGRTZW1hbnRpY0VuY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFJlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkUmVhZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkV3JpdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5hZGRXcml0ZXI7IH0gfSk7XG52YXIgRGF0YUl0ZW1fMSA9IHJlcXVpcmUoXCIuL0RhdGFJdGVtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGFJdGVtXzEuRGF0YUl0ZW07IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgU2NyaXB0RXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vU2NyaXB0RXhwcmVzc2lvblwiKTtcbmNvbnN0IHJlZ2lzdHJ5VGFncyA9IE9iamVjdC52YWx1ZXMoUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcylcbiAgICAuZmlsdGVyKChyKSA9PiAhIXIuZ2V0VGFnKCkpXG4gICAgLm1hcCgocikgPT4gci5nZXRUYWcoKSk7XG5jb25zdCBzY3JpcHRFeHByZXNzaW9uVGFncyA9IE9iamVjdC52YWx1ZXMoU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zKS5tYXAoKHNlKSA9PiBzZS5nZXRUYWcoKSk7XG4oMCwgdXRpbHNfMS5wYXRjaFRhZ3MpKHJlZ2lzdHJ5VGFncy5jb25jYXQoc2NyaXB0RXhwcmVzc2lvblRhZ3MpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGNoQ0JPUi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXRjaFRhZ3MgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IGFscmVhZHlQYXRjaGVkVGFnID0gW107XG5jb25zdCBwYXRjaFRhZ3MgPSAodGFncykgPT4ge1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgIGlmIChhbHJlYWR5UGF0Y2hlZFRhZy5maW5kKChpKSA9PiBpID09PSB0YWcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoMCwgbGliXzEuYWRkU2VtYW50aWNFbmNvZGUpKHRhZywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgbGliXzEuRGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5nZXRUYWcoKSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgbGliXzEuYWRkU2VtYW50aWNEZWNvZGUpKHRhZywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0oZGF0YSwgdGFnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFscmVhZHlQYXRjaGVkVGFnLnB1c2godGFnKTtcbiAgICB9KTtcbn07XG5leHBvcnRzLnBhdGNoVGFncyA9IHBhdGNoVGFncztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG4vKipcbiAqIFJMUCBFbmNvZGluZyBiYXNlZCBvbiBodHRwczovL2V0aC53aWtpL2VuL2Z1bmRhbWVudGFscy9ybHBcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gZGF0YSwgY29udmVydHMgaXQgdG8gVWludDhBcnJheSBpZiBub3QsXG4gKiBhbmQgYWRkcyBhIGxlbmd0aCBmb3IgcmVjdXJzaW9uLlxuICogQHBhcmFtIGlucHV0IFdpbGwgYmUgY29udmVydGVkIHRvIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm5zIFVpbnQ4QXJyYXkgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVuY29kZShpbnB1dFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdEJ5dGVzKC4uLm91dHB1dCk7XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhlbmNvZGVMZW5ndGgoYnVmLmxlbmd0aCwgMTkyKSwgYnVmKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRCdWYgPSB0b0J5dGVzKGlucHV0KTtcbiAgICBpZiAoaW5wdXRCdWYubGVuZ3RoID09PSAxICYmIGlucHV0QnVmWzBdIDwgMTI4KSB7XG4gICAgICAgIHJldHVybiBpbnB1dEJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzKGVuY29kZUxlbmd0aChpbnB1dEJ1Zi5sZW5ndGgsIDEyOCksIGlucHV0QnVmKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBTbGljZXMgYSBVaW50OEFycmF5LCB0aHJvd3MgaWYgdGhlIHNsaWNlIGdvZXMgb3V0LW9mLWJvdW5kcyBvZiB0aGUgVWludDhBcnJheS5cbiAqIEUuZy4gYHNhZmVTbGljZShoZXhUb0J5dGVzKCdhYScpLCAxLCAyKWAgd2lsbCB0aHJvdy5cbiAqIEBwYXJhbSBpbnB1dFxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKi9cbmZ1bmN0aW9uIHNhZmVTbGljZShpbnB1dCwgc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUCAoc2FmZVNsaWNlKTogZW5kIHNsaWNlIG9mIFVpbnQ4QXJyYXkgb3V0LW9mLWJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG4vKipcbiAqIFBhcnNlIGludGVnZXJzLiBDaGVjayBpZiB0aGVyZSBpcyBubyBsZWFkaW5nIHplcm9zXG4gKiBAcGFyYW0gdiBUaGUgdmFsdWUgdG8gcGFyc2VcbiAqL1xuZnVuY3Rpb24gZGVjb2RlTGVuZ3RoKHYpIHtcbiAgICBpZiAodlswXSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHRyYSB6ZXJvcycpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VIZXhCeXRlKGJ5dGVzVG9IZXgodikpO1xufVxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKGxlbiwgb2Zmc2V0KSB7XG4gICAgaWYgKGxlbiA8IDU2KSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW2xlbiArIG9mZnNldF0pO1xuICAgIH1cbiAgICBjb25zdCBoZXhMZW5ndGggPSBudW1iZXJUb0hleChsZW4pO1xuICAgIGNvbnN0IGxMZW5ndGggPSBoZXhMZW5ndGgubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBudW1iZXJUb0hleChvZmZzZXQgKyA1NSArIGxMZW5ndGgpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGV4VG9CeXRlcyhmaXJzdEJ5dGUgKyBoZXhMZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCwgc3RyZWFtID0gZmFsc2UpIHtcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRCeXRlcyA9IHRvQnl0ZXMoaW5wdXQpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGlucHV0Qnl0ZXMpO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfVxuICAgIGlmIChkZWNvZGVkLnJlbWFpbmRlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogcmVtYWluZGVyIG11c3QgYmUgemVybycpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZC5kYXRhO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKiogRGVjb2RlIGFuIGlucHV0IHdpdGggUkxQICovXG5mdW5jdGlvbiBfZGVjb2RlKGlucHV0KSB7XG4gICAgbGV0IGxlbmd0aCwgbGxlbmd0aCwgZGF0YSwgaW5uZXJSZW1haW5kZXIsIGQ7XG4gICAgY29uc3QgZGVjb2RlZCA9IFtdO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGlucHV0WzBdO1xuICAgIGlmIChmaXJzdEJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAvLyBhIHNpbmdsZSBieXRlIHdob3NlIHZhbHVlIGlzIGluIHRoZSBbMHgwMCwgMHg3Zl0gcmFuZ2UsIHRoYXQgYnl0ZSBpcyBpdHMgb3duIFJMUCBlbmNvZGluZy5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LnNsaWNlKDAsIDEpLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSgxKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcbiAgICAgICAgLy8gc3RyaW5nIGlzIDAtNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHZhbHVlIDB4ODAgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgICAgICAvLyBUaGUgcmFuZ2Ugb2YgdGhlIGZpcnN0IGJ5dGUgaXMgWzB4ODAsIDB4YjddXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4N2Y7XG4gICAgICAgIC8vIHNldCAweDgwIG51bGwgdG8gMFxuICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAweDgwKSB7XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBzYWZlU2xpY2UoaW5wdXQsIDEsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMiAmJiBkYXRhWzBdIDwgMHg4MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUCBlbmNvZGluZzogaW52YWxpZCBwcmVmaXgsIHNpbmdsZSBieXRlIDwgMHg4MCBhcmUgbm90IHByZWZpeGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyBncmVhdGVyIHRoYW4gNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHRoZSB2YWx1ZSAoMHhiNyBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIGxlbmd0aCksXG4gICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBsZW5ndGgsIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YjY7XG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGggLSAxIDwgbGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogbm90IGVub3VnaCBieXRlcyBmb3Igc3RyaW5nIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IGRlY29kZUxlbmd0aChzYWZlU2xpY2UoaW5wdXQsIDEsIGxsZW5ndGgpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXhwZWN0ZWQgc3RyaW5nIGxlbmd0aCB0byBiZSBncmVhdGVyIHRoYW4gNTUnKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gc2FmZVNsaWNlKGlucHV0LCBsbGVuZ3RoLCBsZW5ndGggKyBsbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCArIGxsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgICAgICAvLyBhIGxpc3QgYmV0d2VlbiAwLTU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBzYWZlU2xpY2UoaW5wdXQsIDEsIGxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGEgbGlzdCBvdmVyIDU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjY7XG4gICAgICAgIGxlbmd0aCA9IGRlY29kZUxlbmd0aChzYWZlU2xpY2UoaW5wdXQsIDEsIGxsZW5ndGgpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDU2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBlbmNvZGVkIGxpc3QgdG9vIHNob3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSBsbGVuZ3RoICsgbGVuZ3RoO1xuICAgICAgICBpZiAodG90YWxMZW5ndGggPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IHRvdGFsIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiB0aGUgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gc2FmZVNsaWNlKGlucHV0LCBsbGVuZ3RoLCB0b3RhbExlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UodG90YWxMZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IGNhY2hlZEhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIFByZS1jYWNoaW5nIGNoYXJzIHdpdGggYGNhY2hlZEhleGVzYCBzcGVlZHMgdGhpcyB1cCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gY2FjaGVkSGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZShoZXhCeXRlKSB7XG4gICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihieXRlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICByZXR1cm4gYnl0ZTtcbn1cbi8vIENhY2hpbmcgc2xvd3MgaXQgZG93biAyLTN4XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBhcnJheVtpXSA9IHBhcnNlSGV4Qnl0ZShoZXguc2xpY2UoaiwgaiArIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqIENvbmNhdGVuYXRlcyB0d28gVWludDhBcnJheXMgaW50byBvbmUuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXRmOFRvQnl0ZXModXRmKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh1dGYpO1xufVxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gaXRzIGhleGFkZWNpbWFsIHZhbHVlICovXG5mdW5jdGlvbiBudW1iZXJUb0hleChpbnRlZ2VyKSB7XG4gICAgaWYgKGludGVnZXIgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGFzIGFyZ3VtZW50LCBtdXN0IGJlIHVuc2lnbmVkIScpO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG4vKiogUGFkIGEgc3RyaW5nIHRvIGJlIGV2ZW4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbihhKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoICUgMiA/IGAwJHthfWAgOiBhO1xufVxuLyoqIENoZWNrIGlmIGEgc3RyaW5nIGlzIHByZWZpeGVkIGJ5IDB4ICovXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICAgIHJldHVybiBzdHIubGVuZ3RoID49IDIgJiYgc3RyWzBdID09PSAnMCcgJiYgc3RyWzFdID09PSAneCc7XG59XG4vKiogUmVtb3ZlcyAweCBmcm9tIGEgZ2l2ZW4gU3RyaW5nICovXG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbi8qKiBUcmFuc2Zvcm0gYW55dGhpbmcgaW50byBhIFVpbnQ4QXJyYXkgKi9cbmZ1bmN0aW9uIHRvQnl0ZXModikge1xuICAgIGlmICh2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaXNIZXhQcmVmaXhlZCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KHYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4KHYpKTtcbiAgICB9XG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvQnl0ZXM6IHJlY2VpdmVkIHVuc3VwcG9ydGVkIHR5cGUgJyArIHR5cGVvZiB2KTtcbn1cbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBjb25jYXRCeXRlcyxcbiAgICBoZXhUb0J5dGVzLFxuICAgIHV0ZjhUb0J5dGVzLFxufTtcbmNvbnN0IFJMUCA9IHsgZW5jb2RlLCBkZWNvZGUgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJMUDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChcImRldmVsb3BtZW50XCIgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIGJhc2VFdGhLZXlyaW5nID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZycpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIG9ic1N0b3JlID0gcmVxdWlyZSgnQG1ldGFtYXNrL29icy1zdG9yZScpO1xudmFyIGJjVXJSZWdpc3RyeUV0aCA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aCcpO1xudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XG52YXIgdHggPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpO1xudmFyIHJscCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdybHAnKSk7XG5cbmNsYXNzIE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlciBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jbGVhblN5bmNMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIik7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFuU2lnbkxpc3RlbmVycyA9IHJlcXVlc3RJZCA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhgJHtyZXF1ZXN0SWR9LXNpZ25lZGApO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoYCR7cmVxdWVzdElkfS1jYW5jZWxlZGApO1xuICAgIH07XG5cbiAgICB0aGlzLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHN5bmM6IHtcbiAgICAgICAgICAgIHJlYWRpbmc6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWhka2V5XCIsIGNib3IgPT4ge1xuICAgICAgICAgIGNvbnN0IGNyeXB0b0hES2V5ID0gYmNVclJlZ2lzdHJ5RXRoLkNyeXB0b0hES2V5LmZyb21DQk9SKEJ1ZmZlci5mcm9tKGNib3IsIFwiaGV4XCIpKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKGNyeXB0b0hES2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudFwiLCBjYm9yID0+IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9BY2NvdW50ID0gYmNVclJlZ2lzdHJ5RXRoLkNyeXB0b0FjY291bnQuZnJvbUNCT1IoQnVmZmVyLmZyb20oY2JvciwgXCJoZXhcIikpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoY3J5cHRvQWNjb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKFwia2V5c3RvbmUtc3luY19jYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI3N5bmNfY2FuY2VsLiBTeW5jIHByb2Nlc3MgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0Q3J5cHRvSERLZXkgPSBjYm9yID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLCBjYm9yKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRDcnlwdG9BY2NvdW50ID0gY2JvciA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudFwiLCBjYm9yKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWxTeW5jID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwia2V5c3RvbmUtc3luY19jYW5jZWxcIik7XG4gICAgfTtcblxuICAgIHRoaXMucmVxdWVzdFNpZ25hdHVyZSA9IChzaWduUmVxdWVzdCwgcmVxdWVzdFRpdGxlLCByZXF1ZXN0RGVzY3JpcHRpb24pID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVyID0gc2lnblJlcXVlc3QudG9VUigpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWRCdWZmZXIgPSBzaWduUmVxdWVzdC5nZXRSZXF1ZXN0SWQoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC5zdHJpbmdpZnkocmVxdWVzdElkQnVmZmVyKTtcbiAgICAgICAgY29uc3Qgc2lnblBheWxvYWQgPSB7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IHVyLnR5cGUsXG4gICAgICAgICAgICBjYm9yOiB1ci5jYm9yLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZTogcmVxdWVzdFRpdGxlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiByZXF1ZXN0RGVzY3JpcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgc2lnbjoge1xuICAgICAgICAgICAgcmVxdWVzdDogc2lnblBheWxvYWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uY2UoYCR7cmVxdWVzdElkfS1zaWduZWRgLCBjYm9yID0+IHtcbiAgICAgICAgICBjb25zdCBldGhTaWduYXR1cmUgPSBiY1VyUmVnaXN0cnlFdGguRVRIU2lnbmF0dXJlLmZyb21DQk9SKEJ1ZmZlci5mcm9tKGNib3IsIFwiaGV4XCIpKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKGV0aFNpZ25hdHVyZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uY2UoYCR7cmVxdWVzdElkfS1jYW5jZWxlZGAsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNUeF9jYW5jZWxlZC4gU2lnbmluZyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRTaWduYXR1cmUgPSAocmVxdWVzdElkLCBjYm9yKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoYCR7cmVxdWVzdElkfS1zaWduZWRgLCBjYm9yKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2lnblBheWxvYWQgPSB0aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O1xuXG4gICAgICBpZiAoc2lnblBheWxvYWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICB9ID0gc2lnblBheWxvYWQ7XG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHNpZ246IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoYCR7cmVxdWVzdElkfS1jYW5jZWxlZGApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhblN5bmNMaXN0ZW5lcnMoKTtcbiAgICAgIGNvbnN0IHNpZ25QYXlsb2FkID0gdGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpLnNpZ24ucmVxdWVzdDtcblxuICAgICAgaWYgKHNpZ25QYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfSA9IHNpZ25QYXlsb2FkO1xuICAgICAgICB0aGlzLmNsZWFuU2lnbkxpc3RlbmVycyhyZXF1ZXN0SWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldFN0YXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgIHN5bmM6IHtcbiAgICAgICAgICByZWFkaW5nOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzaWduOiB7fVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChNZXRhbWFza0ludGVyYWN0aW9uUHJvdmlkZXIuaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBNZXRhbWFza0ludGVyYWN0aW9uUHJvdmlkZXIuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBvYnNTdG9yZS5PYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgc3luYzoge1xuICAgICAgICByZWFkaW5nOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNpZ246IHt9LFxuICAgICAgX3ZlcnNpb246IDFcbiAgICB9KTtcbiAgICBNZXRhbWFza0ludGVyYWN0aW9uUHJvdmlkZXIuaW5zdGFuY2UgPSB0aGlzO1xuICB9XG5cbn1cblxuY2xhc3MgTWV0YU1hc2tLZXlyaW5nIGV4dGVuZHMgYmFzZUV0aEtleXJpbmcuQmFzZUtleXJpbmcge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICB0aGlzLmdldEludGVyYWN0aW9uID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBNZXRhbWFza0ludGVyYWN0aW9uUHJvdmlkZXIoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldFN0b3JlID0gKCkgPT4ge1xuICAgICAgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0TWVtU3RvcmUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmFjdGlvbigpLm1lbVN0b3JlO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUFjY291bnQgPSBhZGRyZXNzID0+IHtcbiAgICAgIGlmICghdGhpcy5hY2NvdW50cy5tYXAoYSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoYSA9PiBhLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgfTtcblxuICAgIHRoaXMuZm9yZ2V0RGV2aWNlID0gKCkgPT4ge1xuICAgICAgLy9jb21tb24gcHJvcHNcbiAgICAgIHRoaXMucGFnZSA9IDA7XG4gICAgICB0aGlzLnBlclBhZ2UgPSA1O1xuICAgICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50QWNjb3VudCA9IDA7XG4gICAgICB0aGlzLm5hbWUgPSBcIlFSIEhhcmR3YXJlXCI7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7IC8vaGQgcHJvcHM7XG5cbiAgICAgIHRoaXMueGZwID0gXCJcIjtcbiAgICAgIHRoaXMueHB1YiA9IFwiXCI7XG4gICAgICB0aGlzLmhkUGF0aCA9IFwiXCI7XG4gICAgICB0aGlzLmluZGV4ZXMgPSB7fTtcbiAgICAgIHRoaXMuaGRrID0gdW5kZWZpbmVkOyAvL3B1YmtleSBwcm9wcztcblxuICAgICAgdGhpcy5wYXRocyA9IHt9O1xuICAgIH07XG5cbiAgICB0aGlzLnN1Ym1pdENyeXB0b0hES2V5ID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0hES2V5O1xuICAgIHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRDcnlwdG9BY2NvdW50O1xuICAgIHRoaXMuc3VibWl0U2lnbmF0dXJlID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdFNpZ25hdHVyZTtcbiAgICB0aGlzLmNhbmNlbFN5bmMgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsU3luYztcbiAgICB0aGlzLmNhbmNlbFNpZ25SZXF1ZXN0ID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLmNhbmNlbFJlcXVlc3RTaWduYXR1cmU7XG5cbiAgICBpZiAoTWV0YU1hc2tLZXlyaW5nLmluc3RhbmNlKSB7XG4gICAgICBNZXRhTWFza0tleXJpbmcuaW5zdGFuY2UuZGVzZXJpYWxpemUob3B0cyk7XG4gICAgICByZXR1cm4gTWV0YU1hc2tLZXlyaW5nLmluc3RhbmNlO1xuICAgIH1cblxuICAgIE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZSA9IHRoaXM7XG4gIH1cblxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgdHgkMSkge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdHgkMS50eXBlID09PSAwID8gYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnRyYW5zYWN0aW9uIDogYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnR5cGVkVHJhbnNhY3Rpb247XG4gICAgbGV0IG1lc3NhZ2VUb1NpZ247XG5cbiAgICBpZiAodHgkMS50eXBlID09PSAwKSB7XG4gICAgICBtZXNzYWdlVG9TaWduID0gcmxwLmVuY29kZSh0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZVRvU2lnbiA9IHR4JDEuZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGNoYWluSWQgPSB0eCQxLmNvbW1vbi5jaGFpbklkKCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QobWVzc2FnZVRvU2lnbiwgZGF0YVR5cGUsIGhkUGF0aCwgdGhpcy54ZnAsIHJlcXVlc3RJZCwgY2hhaW5JZCwgYWRkcmVzcyk7XG4gICAgY29uc3Qge1xuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB2XG4gICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShyZXF1ZXN0SWQsIGV0aFNpZ25SZXF1ZXN0LCBcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eCQxLnRvSlNPTigpO1xuICAgIHR4SnNvbi52ID0gdjtcbiAgICB0eEpzb24ucyA9IHM7XG4gICAgdHhKc29uLnIgPSByO1xuICAgIHR4SnNvbi50eXBlID0gdHgkMS50eXBlO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHguVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhKc29uLCB7XG4gICAgICBjb21tb246IHR4JDEuY29tbW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbn1cbk1ldGFNYXNrS2V5cmluZy50eXBlID0gYmFzZUV0aEtleXJpbmcuQmFzZUtleXJpbmcudHlwZTtcblxuZXhwb3J0cy5NZXRhTWFza0tleXJpbmcgPSBNZXRhTWFza0tleXJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZSx0PXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nXCIpLHM9cmVxdWlyZShcImV2ZW50c1wiKSxuPXJlcXVpcmUoXCJAbWV0YW1hc2svb2JzLXN0b3JlXCIpLGk9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aFwiKSxyPXJlcXVpcmUoXCJ1dWlkXCIpLGM9cmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpLG89KGU9cmVxdWlyZShcInJscFwiKSkmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmU7Y2xhc3MgYSBleHRlbmRzIHMuRXZlbnRFbWl0dGVye2NvbnN0cnVjdG9yKCl7aWYoc3VwZXIoKSx0aGlzLmNsZWFuU3luY0xpc3RlbmVycz0oKT0+e3RoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWhka2V5XCIpLHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIiksdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiKX0sdGhpcy5jbGVhblNpZ25MaXN0ZW5lcnM9ZT0+e3RoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGUrXCItc2lnbmVkXCIpLHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGUrXCItY2FuY2VsZWRcIil9LHRoaXMucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50PSgpPT5uZXcgUHJvbWlzZSgoZSx0KT0+e3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3N5bmM6e3JlYWRpbmc6ITB9fSksdGhpcy5vbihcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLHQ9Pntjb25zdCBzPWkuQ3J5cHRvSERLZXkuZnJvbUNCT1IoQnVmZmVyLmZyb20odCxcImhleFwiKSk7dGhpcy5yZXNldFN0YXRlKCksZShzKX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudFwiLHQ9Pntjb25zdCBzPWkuQ3J5cHRvQWNjb3VudC5mcm9tQ0JPUihCdWZmZXIuZnJvbSh0LFwiaGV4XCIpKTt0aGlzLnJlc2V0U3RhdGUoKSxlKHMpfSksdGhpcy5vbihcImtleXN0b25lLXN5bmNfY2FuY2VsXCIsKCk9Pnt0aGlzLnJlc2V0U3RhdGUoKSx0KG5ldyBFcnJvcihcIktleXN0b25lRXJyb3Ijc3luY19jYW5jZWwuIFN5bmMgcHJvY2VzcyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5XCIpKX0pfSksdGhpcy5zdWJtaXRDcnlwdG9IREtleT1lPT57dGhpcy5lbWl0KFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWhka2V5XCIsZSl9LHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudD1lPT57dGhpcy5lbWl0KFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIixlKX0sdGhpcy5jYW5jZWxTeW5jPSgpPT57dGhpcy5lbWl0KFwia2V5c3RvbmUtc3luY19jYW5jZWxcIil9LHRoaXMucmVxdWVzdFNpZ25hdHVyZT0oZSx0LHMpPT5uZXcgUHJvbWlzZSgobixjKT0+e2NvbnN0IG89ZS50b1VSKCksYT1lLmdldFJlcXVlc3RJZCgpLGg9ci5zdHJpbmdpZnkoYSksdT17cmVxdWVzdElkOmgscGF5bG9hZDp7dHlwZTpvLnR5cGUsY2JvcjpvLmNib3IudG9TdHJpbmcoXCJoZXhcIil9LHRpdGxlOnQsZGVzY3JpcHRpb246c307dGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7c2lnbjp7cmVxdWVzdDp1fX0pLHRoaXMub25jZShoK1wiLXNpZ25lZFwiLGU9Pntjb25zdCB0PWkuRVRIU2lnbmF0dXJlLmZyb21DQk9SKEJ1ZmZlci5mcm9tKGUsXCJoZXhcIikpO3RoaXMucmVzZXRTdGF0ZSgpLG4odCl9KSx0aGlzLm9uY2UoaCtcIi1jYW5jZWxlZFwiLCgpPT57dGhpcy5yZXNldFN0YXRlKCksYyhuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI1R4X2NhbmNlbGVkLiBTaWduaW5nIGNhbmNlbGVkLCBwbGVhc2UgcmV0cnlcIikpfSl9KSx0aGlzLnN1Ym1pdFNpZ25hdHVyZT0oZSx0KT0+e3RoaXMuZW1pdChlK1wiLXNpZ25lZFwiLHQpfSx0aGlzLmNhbmNlbFJlcXVlc3RTaWduYXR1cmU9KCk9Pntjb25zdCBlPXRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKS5zaWduLnJlcXVlc3Q7aWYoZSl7Y29uc3R7cmVxdWVzdElkOnR9PWU7dGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7c2lnbjp7fX0pLHRoaXMuZW1pdCh0K1wiLWNhbmNlbGVkXCIpfX0sdGhpcy5yZXNldD0oKT0+e3RoaXMuY2xlYW5TeW5jTGlzdGVuZXJzKCk7Y29uc3QgZT10aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O2lmKGUpe2NvbnN0e3JlcXVlc3RJZDp0fT1lO3RoaXMuY2xlYW5TaWduTGlzdGVuZXJzKHQpfXRoaXMucmVzZXRTdGF0ZSgpfSx0aGlzLnJlc2V0U3RhdGU9KCk9Pnt0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtzeW5jOntyZWFkaW5nOiExfSxzaWduOnt9fSl9LGEuaW5zdGFuY2UpcmV0dXJuIGEuaW5zdGFuY2U7dGhpcy5tZW1TdG9yZT1uZXcgbi5PYnNlcnZhYmxlU3RvcmUoe3N5bmM6e3JlYWRpbmc6ITF9LHNpZ246e30sX3ZlcnNpb246MX0pLGEuaW5zdGFuY2U9dGhpc319Y2xhc3MgaCBleHRlbmRzIHQuQmFzZUtleXJpbmd7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoZSksdGhpcy5nZXRJbnRlcmFjdGlvbj0oKT0+bmV3IGEsdGhpcy5yZXNldFN0b3JlPSgpPT57dGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlc2V0KCl9LHRoaXMuZ2V0TWVtU3RvcmU9KCk9PnRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5tZW1TdG9yZSx0aGlzLnJlbW92ZUFjY291bnQ9ZT0+e2lmKCF0aGlzLmFjY291bnRzLm1hcChlPT5lLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGUudG9Mb3dlckNhc2UoKSkpdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7ZX0gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO3RoaXMuYWNjb3VudHM9dGhpcy5hY2NvdW50cy5maWx0ZXIodD0+dC50b0xvd2VyQ2FzZSgpIT09ZS50b0xvd2VyQ2FzZSgpKX0sdGhpcy5mb3JnZXREZXZpY2U9KCk9Pnt0aGlzLnBhZ2U9MCx0aGlzLnBlclBhZ2U9NSx0aGlzLmFjY291bnRzPVtdLHRoaXMuY3VycmVudEFjY291bnQ9MCx0aGlzLm5hbWU9XCJRUiBIYXJkd2FyZVwiLHRoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy54ZnA9XCJcIix0aGlzLnhwdWI9XCJcIix0aGlzLmhkUGF0aD1cIlwiLHRoaXMuaW5kZXhlcz17fSx0aGlzLmhkaz12b2lkIDAsdGhpcy5wYXRocz17fX0sdGhpcy5zdWJtaXRDcnlwdG9IREtleT10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvSERLZXksdGhpcy5zdWJtaXRDcnlwdG9BY2NvdW50PXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRDcnlwdG9BY2NvdW50LHRoaXMuc3VibWl0U2lnbmF0dXJlPXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRTaWduYXR1cmUsdGhpcy5jYW5jZWxTeW5jPXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxTeW5jLHRoaXMuY2FuY2VsU2lnblJlcXVlc3Q9dGhpcy5nZXRJbnRlcmFjdGlvbigpLmNhbmNlbFJlcXVlc3RTaWduYXR1cmUsaC5pbnN0YW5jZSlyZXR1cm4gaC5pbnN0YW5jZS5kZXNlcmlhbGl6ZShlKSxoLmluc3RhbmNlO2guaW5zdGFuY2U9dGhpc31hc3luYyBzaWduVHJhbnNhY3Rpb24oZSx0KXtjb25zdCBzPTA9PT10LnR5cGU/aS5EYXRhVHlwZS50cmFuc2FjdGlvbjppLkRhdGFUeXBlLnR5cGVkVHJhbnNhY3Rpb247bGV0IG47bj0wPT09dC50eXBlP28uZW5jb2RlKHQuZ2V0TWVzc2FnZVRvU2lnbighMSkpOnQuZ2V0TWVzc2FnZVRvU2lnbighMSk7Y29uc3QgYT1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksaD10LmNvbW1vbi5jaGFpbklkKCksdT1yLnY0KCkseT1pLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QobixzLGEsdGhpcy54ZnAsdSxoLGUpLHtyOm0sczpnLHY6ZH09YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHUseSxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGUgdHJhbnNhY3Rpb24sIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpLFM9dC50b0pTT04oKTtyZXR1cm4gUy52PWQsUy5zPWcsUy5yPW0sUy50eXBlPXQudHlwZSxjLlRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKFMse2NvbW1vbjp0LmNvbW1vbn0pfX1oLnR5cGU9dC5CYXNlS2V5cmluZy50eXBlLGV4cG9ydHMuTWV0YU1hc2tLZXlyaW5nPWg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgYmNVclJlZ2lzdHJ5ID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnknKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIHV0aWwgPSByZXF1aXJlKCdAZXRoZXJldW1qcy91dGlsJyk7XG5cbmNvbnN0IEV4dGVuZGVkUmVnaXN0cnlUeXBlcyA9IHtcbiAgRVRIX1NJR05fUkVRVUVTVDogLyojX19QVVJFX18qL25ldyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlUeXBlKFwiZXRoLXNpZ24tcmVxdWVzdFwiLCA0MDEpLFxuICBFVEhfU0lHTkFUVVJFOiAvKiNfX1BVUkVfXyovbmV3IGJjVXJSZWdpc3RyeS5SZWdpc3RyeVR5cGUoXCJldGgtc2lnbmF0dXJlXCIsIDQwMiksXG4gIEVUSF9ORlRfSVRFTTogLyojX19QVVJFX18qL25ldyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlUeXBlKFwiZXRoLW5mdC1pdGVtXCIsIDQwMylcbn07XG5cbmNvbnN0IHtcbiAgZGVjb2RlVG9EYXRhSXRlbSxcbiAgUmVnaXN0cnlUeXBlc1xufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cztcblxuKGZ1bmN0aW9uIChLZXlzKSB7XG4gIEtleXNbS2V5c1tcInJlcXVlc3RJZFwiXSA9IDFdID0gXCJyZXF1ZXN0SWRcIjtcbiAgS2V5c1tLZXlzW1wic2lnbkRhdGFcIl0gPSAyXSA9IFwic2lnbkRhdGFcIjtcbiAgS2V5c1tLZXlzW1wiZGF0YVR5cGVcIl0gPSAzXSA9IFwiZGF0YVR5cGVcIjtcbiAgS2V5c1tLZXlzW1wiY2hhaW5JZFwiXSA9IDRdID0gXCJjaGFpbklkXCI7XG4gIEtleXNbS2V5c1tcImRlcml2YXRpb25QYXRoXCJdID0gNV0gPSBcImRlcml2YXRpb25QYXRoXCI7XG4gIEtleXNbS2V5c1tcImFkZHJlc3NcIl0gPSA2XSA9IFwiYWRkcmVzc1wiO1xuICBLZXlzW0tleXNbXCJvcmlnaW5cIl0gPSA3XSA9IFwib3JpZ2luXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcblxuKGZ1bmN0aW9uIChEYXRhVHlwZSkge1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInRyYW5zYWN0aW9uXCJdID0gMV0gPSBcInRyYW5zYWN0aW9uXCI7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1widHlwZWREYXRhXCJdID0gMl0gPSBcInR5cGVkRGF0YVwiO1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInBlcnNvbmFsTWVzc2FnZVwiXSA9IDNdID0gXCJwZXJzb25hbE1lc3NhZ2VcIjtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ0eXBlZFRyYW5zYWN0aW9uXCJdID0gNF0gPSBcInR5cGVkVHJhbnNhY3Rpb25cIjtcbn0pKGV4cG9ydHMuRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSB7fSkpO1xuXG5jbGFzcyBFdGhTaWduUmVxdWVzdCBleHRlbmRzIGJjVXJSZWdpc3RyeS5SZWdpc3RyeUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4gRXh0ZW5kZWRSZWdpc3RyeVR5cGVzLkVUSF9TSUdOX1JFUVVFU1Q7XG5cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9ICgpID0+IHRoaXMucmVxdWVzdElkO1xuXG4gICAgdGhpcy5nZXRTaWduRGF0YSA9ICgpID0+IHRoaXMuc2lnbkRhdGE7XG5cbiAgICB0aGlzLmdldERhdGFUeXBlID0gKCkgPT4gdGhpcy5kYXRhVHlwZTtcblxuICAgIHRoaXMuZ2V0Q2hhaW5JZCA9ICgpID0+IHRoaXMuY2hhaW5JZDtcblxuICAgIHRoaXMuZ2V0RGVyaXZhdGlvblBhdGggPSAoKSA9PiB0aGlzLmRlcml2YXRpb25QYXRoLmdldFBhdGgoKTtcblxuICAgIHRoaXMuZ2V0U291cmNlRmluZ2VycHJpbnQgPSAoKSA9PiB0aGlzLmRlcml2YXRpb25QYXRoLmdldFNvdXJjZUZpbmdlcnByaW50KCk7XG5cbiAgICB0aGlzLmdldFNpZ25SZXF1ZXN0QWRkcmVzcyA9ICgpID0+IHRoaXMuYWRkcmVzcztcblxuICAgIHRoaXMuZ2V0T3JpZ2luID0gKCkgPT4gdGhpcy5vcmlnaW47XG5cbiAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVxdWVzdElkKSB7XG4gICAgICAgIG1hcFtLZXlzLnJlcXVlc3RJZF0gPSBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLCBSZWdpc3RyeVR5cGVzLlVVSUQuZ2V0VGFnKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hZGRyZXNzKSB7XG4gICAgICAgIG1hcFtLZXlzLmFkZHJlc3NdID0gdGhpcy5hZGRyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFpbklkKSB7XG4gICAgICAgIG1hcFtLZXlzLmNoYWluSWRdID0gdGhpcy5jaGFpbklkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgICAgbWFwW0tleXMub3JpZ2luXSA9IHRoaXMub3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBtYXBbS2V5cy5zaWduRGF0YV0gPSB0aGlzLnNpZ25EYXRhO1xuICAgICAgbWFwW0tleXMuZGF0YVR5cGVdID0gdGhpcy5kYXRhVHlwZTtcbiAgICAgIGNvbnN0IGtleVBhdGggPSB0aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtcbiAgICAgIGtleVBhdGguc2V0VGFnKHRoaXMuZGVyaXZhdGlvblBhdGguZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgbWFwW0tleXMuZGVyaXZhdGlvblBhdGhdID0ga2V5UGF0aDtcbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKG1hcCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVxdWVzdElkID0gYXJncy5yZXF1ZXN0SWQ7XG4gICAgdGhpcy5zaWduRGF0YSA9IGFyZ3Muc2lnbkRhdGE7XG4gICAgdGhpcy5kYXRhVHlwZSA9IGFyZ3MuZGF0YVR5cGU7XG4gICAgdGhpcy5jaGFpbklkID0gYXJncy5jaGFpbklkO1xuICAgIHRoaXMuZGVyaXZhdGlvblBhdGggPSBhcmdzLmRlcml2YXRpb25QYXRoO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcztcbiAgICB0aGlzLm9yaWdpbiA9IGFyZ3Mub3JpZ2luO1xuICB9XG5cbiAgc3RhdGljIGNvbnN0cnVjdEVUSFJlcXVlc3Qoc2lnbkRhdGEsIHNpZ25EYXRhVHlwZSwgaGRQYXRoLCB4ZnAsIHV1aWRTdHJpbmcsIGNoYWluSWQsIGFkZHJlc3MsIG9yaWdpbikge1xuICAgIGNvbnN0IHBhdGhzID0gaGRQYXRoLnJlcGxhY2UoL1ttfE1dXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGhkcGF0aE9iamVjdCA9IG5ldyBiY1VyUmVnaXN0cnkuQ3J5cHRvS2V5cGF0aChwYXRocy5tYXAocGF0aCA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHBhdGgucmVwbGFjZShcIidcIiwgXCJcIikpO1xuICAgICAgbGV0IGlzSGFyZGVuZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHBhdGguZW5kc1dpdGgoXCInXCIpKSB7XG4gICAgICAgIGlzSGFyZGVuZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGJjVXJSZWdpc3RyeS5QYXRoQ29tcG9uZW50KHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGhhcmRlbmVkOiBpc0hhcmRlbmVkXG4gICAgICB9KTtcbiAgICB9KSwgQnVmZmVyLmZyb20oeGZwLCBcImhleFwiKSk7XG4gICAgcmV0dXJuIG5ldyBFdGhTaWduUmVxdWVzdCh7XG4gICAgICByZXF1ZXN0SWQ6IHV1aWRTdHJpbmcgPyBCdWZmZXIuZnJvbSh1dWlkLnBhcnNlKHV1aWRTdHJpbmcpKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNpZ25EYXRhLFxuICAgICAgZGF0YVR5cGU6IHNpZ25EYXRhVHlwZSxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBoZHBhdGhPYmplY3QsXG4gICAgICBjaGFpbklkLFxuICAgICAgYWRkcmVzczogYWRkcmVzcyA/IEJ1ZmZlci5mcm9tKGFkZHJlc3MucmVwbGFjZShcIjB4XCIsIFwiXCIpLCBcImhleFwiKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9yaWdpbjogb3JpZ2luIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG5cbn1cblxuRXRoU2lnblJlcXVlc3QuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25EYXRhID0gbWFwW0tleXMuc2lnbkRhdGFdO1xuICBjb25zdCBkYXRhVHlwZSA9IG1hcFtLZXlzLmRhdGFUeXBlXTtcbiAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBiY1VyUmVnaXN0cnkuQ3J5cHRvS2V5cGF0aC5mcm9tRGF0YUl0ZW0obWFwW0tleXMuZGVyaXZhdGlvblBhdGhdKTtcbiAgY29uc3QgY2hhaW5JZCA9IG1hcFtLZXlzLmNoYWluSWRdID8gbWFwW0tleXMuY2hhaW5JZF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGFkZHJlc3MgPSBtYXBbS2V5cy5hZGRyZXNzXSA/IG1hcFtLZXlzLmFkZHJlc3NdIDogdW5kZWZpbmVkO1xuICBjb25zdCByZXF1ZXN0SWQgPSBtYXBbS2V5cy5yZXF1ZXN0SWRdID8gbWFwW0tleXMucmVxdWVzdElkXS5nZXREYXRhKCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWdpbiA9IG1hcFtLZXlzLm9yaWdpbl0gPyBtYXBbS2V5cy5vcmlnaW5dIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IEV0aFNpZ25SZXF1ZXN0KHtcbiAgICByZXF1ZXN0SWQsXG4gICAgc2lnbkRhdGEsXG4gICAgZGF0YVR5cGUsXG4gICAgY2hhaW5JZCxcbiAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICBhZGRyZXNzLFxuICAgIG9yaWdpblxuICB9KTtcbn07XG5cbkV0aFNpZ25SZXF1ZXN0LmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtKF9jYm9yUGF5bG9hZCk7XG4gIHJldHVybiBFdGhTaWduUmVxdWVzdC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuY29uc3Qge1xuICBSZWdpc3RyeVR5cGVzOiBSZWdpc3RyeVR5cGVzJDEsXG4gIGRlY29kZVRvRGF0YUl0ZW06IGRlY29kZVRvRGF0YUl0ZW0kMVxufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cyQxO1xuXG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgS2V5c1tLZXlzW1wicmVxdWVzdElkXCJdID0gMV0gPSBcInJlcXVlc3RJZFwiO1xuICBLZXlzW0tleXNbXCJzaWduYXR1cmVcIl0gPSAyXSA9IFwic2lnbmF0dXJlXCI7XG4gIEtleXNbS2V5c1tcIm9yaWdpblwiXSA9IDNdID0gXCJvcmlnaW5cIjtcbn0pKEtleXMkMSB8fCAoS2V5cyQxID0ge30pKTtcblxuY2xhc3MgRVRIU2lnbmF0dXJlIGV4dGVuZHMgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5SXRlbSB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSwgcmVxdWVzdElkLCBvcmlnaW4pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMuRVRIX1NJR05BVFVSRTtcblxuICAgIHRoaXMuZ2V0UmVxdWVzdElkID0gKCkgPT4gdGhpcy5yZXF1ZXN0SWQ7XG5cbiAgICB0aGlzLmdldFNpZ25hdHVyZSA9ICgpID0+IHRoaXMuc2lnbmF0dXJlO1xuXG4gICAgdGhpcy5nZXRPcmlnaW4gPSAoKSA9PiB0aGlzLm9yaWdpbjtcblxuICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgbWFwW0tleXMkMS5yZXF1ZXN0SWRdID0gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbSh0aGlzLnJlcXVlc3RJZCwgUmVnaXN0cnlUeXBlcyQxLlVVSUQuZ2V0VGFnKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcmlnaW4pIG1hcFtLZXlzJDEub3JpZ2luXSA9IHRoaXMub3JpZ2luO1xuICAgICAgbWFwW0tleXMkMS5zaWduYXR1cmVdID0gdGhpcy5zaWduYXR1cmU7XG4gICAgICByZXR1cm4gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbShtYXApO1xuICAgIH07XG5cbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgfVxuXG59XG5cbkVUSFNpZ25hdHVyZS5mcm9tRGF0YUl0ZW0gPSBkYXRhSXRlbSA9PiB7XG4gIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gbWFwW0tleXMkMS5zaWduYXR1cmVdO1xuICBjb25zdCByZXF1ZXN0SWQgPSBtYXBbS2V5cyQxLnJlcXVlc3RJZF0gPyBtYXBbS2V5cyQxLnJlcXVlc3RJZF0uZ2V0RGF0YSgpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IEVUSFNpZ25hdHVyZShzaWduYXR1cmUsIHJlcXVlc3RJZCwgbWFwW0tleXMkMS5vcmlnaW5dKTtcbn07XG5cbkVUSFNpZ25hdHVyZS5mcm9tQ0JPUiA9IF9jYm9yUGF5bG9hZCA9PiB7XG4gIGNvbnN0IGRhdGFJdGVtID0gZGVjb2RlVG9EYXRhSXRlbSQxKF9jYm9yUGF5bG9hZCk7XG4gIHJldHVybiBFVEhTaWduYXR1cmUuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbmNvbnN0IHtcbiAgZGVjb2RlVG9EYXRhSXRlbTogZGVjb2RlVG9EYXRhSXRlbSQyXG59ID0gYmNVclJlZ2lzdHJ5LmV4dGVuZDtcbnZhciBLZXlzJDI7XG5cbihmdW5jdGlvbiAoS2V5cykge1xuICBLZXlzW0tleXNbXCJjaGFpbklkXCJdID0gMV0gPSBcImNoYWluSWRcIjtcbiAgS2V5c1tLZXlzW1wiY29udHJhY3RBZGRyZXNzXCJdID0gMl0gPSBcImNvbnRyYWN0QWRkcmVzc1wiO1xuICBLZXlzW0tleXNbXCJjb250cmFjdE5hbWVcIl0gPSAzXSA9IFwiY29udHJhY3ROYW1lXCI7XG4gIEtleXNbS2V5c1tcIm5hbWVcIl0gPSA0XSA9IFwibmFtZVwiO1xuICBLZXlzW0tleXNbXCJtZWRpYURhdGFcIl0gPSA1XSA9IFwibWVkaWFEYXRhXCI7XG59KShLZXlzJDIgfHwgKEtleXMkMiA9IHt9KSk7XG5cbmNsYXNzIEVUSE5GVEl0ZW0gZXh0ZW5kcyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlJdGVtIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfTkZUX0lURU07XG5cbiAgICB0aGlzLmdldENoYWluSWQgPSAoKSA9PiB0aGlzLmNoYWluSWQ7XG5cbiAgICB0aGlzLmdldE5hbWUgPSAoKSA9PiB0aGlzLm5hbWU7XG5cbiAgICB0aGlzLmdldG1lZGlhRGF0YSA9ICgpID0+IHRoaXMubWVkaWFEYXRhO1xuXG4gICAgdGhpcy5nZXRDb250cmFjdEFkZHJlc3MgPSAoKSA9PiB0aGlzLmNvbnRyYWN0QWRkcmVzcztcblxuICAgIHRoaXMuZ2V0Q29udHJhY3ROYW1lID0gKCkgPT4gdGhpcy5jb250cmFjdE5hbWU7XG5cbiAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgIG1hcFtLZXlzJDIuY2hhaW5JZF0gPSB0aGlzLmNoYWluSWQ7XG4gICAgICBtYXBbS2V5cyQyLm5hbWVdID0gdGhpcy5uYW1lO1xuICAgICAgbWFwW0tleXMkMi5jb250cmFjdEFkZHJlc3NdID0gdGhpcy5jb250cmFjdEFkZHJlc3M7XG4gICAgICBtYXBbS2V5cyQyLmNvbnRyYWN0TmFtZV0gPSB0aGlzLmNvbnRyYWN0TmFtZTtcbiAgICAgIG1hcFtLZXlzJDIubWVkaWFEYXRhXSA9IHRoaXMubWVkaWFEYXRhO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jaGFpbklkID0gYXJncy5jaGFpbklkO1xuICAgIHRoaXMubmFtZSA9IGFyZ3MubmFtZTtcbiAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IGFyZ3MuY29udHJhY3RBZGRyZXNzO1xuICAgIHRoaXMuY29udHJhY3ROYW1lID0gYXJncy5jb250cmFjdE5hbWU7XG4gICAgdGhpcy5tZWRpYURhdGEgPSBhcmdzLm1lZGlhRGF0YTsgLy8gcmVtb3ZlIHRoZSBkYXRhIHBlcmZpeCBmb3IgYW5kcm9pZCB1c2FnZVxuICB9XG5cbiAgc3RhdGljIGNvbnN0cnVjdEVUSE5GVEl0ZW0oY2hhaW5JZCwgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdE5hbWUsIG5hbWUsIG1lZGlhRGF0YSkge1xuICAgIHJldHVybiBuZXcgRVRITkZUSXRlbSh7XG4gICAgICBjaGFpbklkLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgbWVkaWFEYXRhLFxuICAgICAgbmFtZVxuICAgIH0pO1xuICB9XG5cbn1cblxuRVRITkZUSXRlbS5mcm9tRGF0YUl0ZW0gPSBkYXRhSXRlbSA9PiB7XG4gIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgY29uc3QgY2hhaW5JZCA9IG1hcFtLZXlzJDIuY2hhaW5JZF07XG4gIGNvbnN0IG5hbWUgPSBtYXBbS2V5cyQyLm5hbWVdO1xuICBjb25zdCBtZWRpYURhdGEgPSBtYXBbS2V5cyQyLm1lZGlhRGF0YV07XG4gIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IG1hcFtLZXlzJDIuY29udHJhY3RBZGRyZXNzXTtcbiAgY29uc3QgY29udHJhY3ROYW1lID0gbWFwW0tleXMkMi5jb250cmFjdE5hbWVdO1xuICByZXR1cm4gbmV3IEVUSE5GVEl0ZW0oe1xuICAgIGNoYWluSWQsXG4gICAgbmFtZSxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgY29udHJhY3ROYW1lLFxuICAgIG1lZGlhRGF0YVxuICB9KTtcbn07XG5cbkVUSE5GVEl0ZW0uZnJvbUNCT1IgPSBfY2JvclBheWxvYWQgPT4ge1xuICBjb25zdCBkYXRhSXRlbSA9IGRlY29kZVRvRGF0YUl0ZW0kMihfY2JvclBheWxvYWQpO1xuICByZXR1cm4gRVRITkZUSXRlbS5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgZ2VuZXJhdGVBZGRyZXNzRnJvbVhwdWIgPSAoeHB1YiwgZGVyaXZlUGF0aCkgPT4ge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG5vZGUgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkoeHB1Yik7XG4gIGNvbnN0IHB1YmxpY0tleSA9IG5vZGUuZGVyaXZlKGRlcml2ZVBhdGgpO1xuICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5LnB1YmxpY0tleSwgdHJ1ZSkudG9TdHJpbmcoXCJoZXhcIik7XG4gIHJldHVybiB1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xufTtcbmNvbnN0IGZpbmRIRFBhdGhGcm9tQWRkcmVzcyA9IChhZGRyZXNzLCB4cHViLCBudW1iZXJMaW1pdCwgcm9vdFBhdGgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJMaW1pdDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IGBNLzAvJHtpfWA7XG5cbiAgICBjb25zdCBfYWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzc0Zyb21YcHViKHhwdWIsIHBhdGgpO1xuXG4gICAgaWYgKGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PSBfYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gYCR7cm9vdFBhdGh9LzAvJHtpfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5iY1VyUmVnaXN0cnkucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMoRXh0ZW5kZWRSZWdpc3RyeVR5cGVzKS5maWx0ZXIocnQgPT4gISFydC5nZXRUYWcoKSkubWFwKHJ0ID0+IHJ0LmdldFRhZygpKSk7XG5cbk9iamVjdC5rZXlzKGJjVXJSZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICBpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmNVclJlZ2lzdHJ5W2tdO1xuICAgIH1cbiAgfSk7XG59KTtcbmV4cG9ydHMuRVRITkZUSXRlbSA9IEVUSE5GVEl0ZW07XG5leHBvcnRzLkVUSFNpZ25hdHVyZSA9IEVUSFNpZ25hdHVyZTtcbmV4cG9ydHMuRXRoU2lnblJlcXVlc3QgPSBFdGhTaWduUmVxdWVzdDtcbmV4cG9ydHMuZmluZEhEUGF0aEZyb21BZGRyZXNzID0gZmluZEhEUGF0aEZyb21BZGRyZXNzO1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3NGcm9tWHB1YiA9IGdlbmVyYXRlQWRkcmVzc0Zyb21YcHViO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB0LGU9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5XCIpLGE9cmVxdWlyZShcInV1aWRcIikscz0odD1yZXF1aXJlKFwiaGRrZXlcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJkZWZhdWx0XCJpbiB0P3QuZGVmYXVsdDp0LGk9cmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7Y29uc3Qgcj17RVRIX1NJR05fUkVRVUVTVDpuZXcgZS5SZWdpc3RyeVR5cGUoXCJldGgtc2lnbi1yZXF1ZXN0XCIsNDAxKSxFVEhfU0lHTkFUVVJFOm5ldyBlLlJlZ2lzdHJ5VHlwZShcImV0aC1zaWduYXR1cmVcIiw0MDIpLEVUSF9ORlRfSVRFTTpuZXcgZS5SZWdpc3RyeVR5cGUoXCJldGgtbmZ0LWl0ZW1cIiw0MDMpfSx7ZGVjb2RlVG9EYXRhSXRlbTpuLFJlZ2lzdHJ5VHlwZXM6ZH09ZS5leHRlbmQ7dmFyIG8saDshZnVuY3Rpb24odCl7dFt0LnJlcXVlc3RJZD0xXT1cInJlcXVlc3RJZFwiLHRbdC5zaWduRGF0YT0yXT1cInNpZ25EYXRhXCIsdFt0LmRhdGFUeXBlPTNdPVwiZGF0YVR5cGVcIix0W3QuY2hhaW5JZD00XT1cImNoYWluSWRcIix0W3QuZGVyaXZhdGlvblBhdGg9NV09XCJkZXJpdmF0aW9uUGF0aFwiLHRbdC5hZGRyZXNzPTZdPVwiYWRkcmVzc1wiLHRbdC5vcmlnaW49N109XCJvcmlnaW5cIn0ob3x8KG89e30pKSwoaD1leHBvcnRzLkRhdGFUeXBlfHwoZXhwb3J0cy5EYXRhVHlwZT17fSkpW2gudHJhbnNhY3Rpb249MV09XCJ0cmFuc2FjdGlvblwiLGhbaC50eXBlZERhdGE9Ml09XCJ0eXBlZERhdGFcIixoW2gucGVyc29uYWxNZXNzYWdlPTNdPVwicGVyc29uYWxNZXNzYWdlXCIsaFtoLnR5cGVkVHJhbnNhY3Rpb249NF09XCJ0eXBlZFRyYW5zYWN0aW9uXCI7Y2xhc3MgYyBleHRlbmRzIGUuUmVnaXN0cnlJdGVte2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5nZXRSZWdpc3RyeVR5cGU9KCk9PnIuRVRIX1NJR05fUkVRVUVTVCx0aGlzLmdldFJlcXVlc3RJZD0oKT0+dGhpcy5yZXF1ZXN0SWQsdGhpcy5nZXRTaWduRGF0YT0oKT0+dGhpcy5zaWduRGF0YSx0aGlzLmdldERhdGFUeXBlPSgpPT50aGlzLmRhdGFUeXBlLHRoaXMuZ2V0Q2hhaW5JZD0oKT0+dGhpcy5jaGFpbklkLHRoaXMuZ2V0RGVyaXZhdGlvblBhdGg9KCk9PnRoaXMuZGVyaXZhdGlvblBhdGguZ2V0UGF0aCgpLHRoaXMuZ2V0U291cmNlRmluZ2VycHJpbnQ9KCk9PnRoaXMuZGVyaXZhdGlvblBhdGguZ2V0U291cmNlRmluZ2VycHJpbnQoKSx0aGlzLmdldFNpZ25SZXF1ZXN0QWRkcmVzcz0oKT0+dGhpcy5hZGRyZXNzLHRoaXMuZ2V0T3JpZ2luPSgpPT50aGlzLm9yaWdpbix0aGlzLnRvRGF0YUl0ZW09KCk9Pntjb25zdCB0PXt9O3RoaXMucmVxdWVzdElkJiYodFtvLnJlcXVlc3RJZF09bmV3IGUuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsZC5VVUlELmdldFRhZygpKSksdGhpcy5hZGRyZXNzJiYodFtvLmFkZHJlc3NdPXRoaXMuYWRkcmVzcyksdGhpcy5jaGFpbklkJiYodFtvLmNoYWluSWRdPXRoaXMuY2hhaW5JZCksdGhpcy5vcmlnaW4mJih0W28ub3JpZ2luXT10aGlzLm9yaWdpbiksdFtvLnNpZ25EYXRhXT10aGlzLnNpZ25EYXRhLHRbby5kYXRhVHlwZV09dGhpcy5kYXRhVHlwZTtjb25zdCBhPXRoaXMuZGVyaXZhdGlvblBhdGgudG9EYXRhSXRlbSgpO3JldHVybiBhLnNldFRhZyh0aGlzLmRlcml2YXRpb25QYXRoLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKSx0W28uZGVyaXZhdGlvblBhdGhdPWEsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMucmVxdWVzdElkPXQucmVxdWVzdElkLHRoaXMuc2lnbkRhdGE9dC5zaWduRGF0YSx0aGlzLmRhdGFUeXBlPXQuZGF0YVR5cGUsdGhpcy5jaGFpbklkPXQuY2hhaW5JZCx0aGlzLmRlcml2YXRpb25QYXRoPXQuZGVyaXZhdGlvblBhdGgsdGhpcy5hZGRyZXNzPXQuYWRkcmVzcyx0aGlzLm9yaWdpbj10Lm9yaWdpbn1zdGF0aWMgY29uc3RydWN0RVRIUmVxdWVzdCh0LHMsaSxyLG4sZCxvLGgpe2NvbnN0IGc9aS5yZXBsYWNlKC9bbXxNXVxcLy8sXCJcIikuc3BsaXQoXCIvXCIpLHU9bmV3IGUuQ3J5cHRvS2V5cGF0aChnLm1hcCh0PT57Y29uc3QgYT1wYXJzZUludCh0LnJlcGxhY2UoXCInXCIsXCJcIikpO2xldCBzPSExO3JldHVybiB0LmVuZHNXaXRoKFwiJ1wiKSYmKHM9ITApLG5ldyBlLlBhdGhDb21wb25lbnQoe2luZGV4OmEsaGFyZGVuZWQ6c30pfSksQnVmZmVyLmZyb20ocixcImhleFwiKSk7cmV0dXJuIG5ldyBjKHtyZXF1ZXN0SWQ6bj9CdWZmZXIuZnJvbShhLnBhcnNlKG4pKTp2b2lkIDAsc2lnbkRhdGE6dCxkYXRhVHlwZTpzLGRlcml2YXRpb25QYXRoOnUsY2hhaW5JZDpkLGFkZHJlc3M6bz9CdWZmZXIuZnJvbShvLnJlcGxhY2UoXCIweFwiLFwiXCIpLFwiaGV4XCIpOnZvaWQgMCxvcmlnaW46aHx8dm9pZCAwfSl9fWMuZnJvbURhdGFJdGVtPXQ9Pntjb25zdCBhPXQuZ2V0RGF0YSgpLHM9YVtvLnNpZ25EYXRhXSxpPWFbby5kYXRhVHlwZV0scj1lLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKGFbby5kZXJpdmF0aW9uUGF0aF0pLG49YVtvLmNoYWluSWRdP2Fbby5jaGFpbklkXTp2b2lkIDAsZD1hW28uYWRkcmVzc10/YVtvLmFkZHJlc3NdOnZvaWQgMCxoPWFbby5yZXF1ZXN0SWRdP2Fbby5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyBjKHtyZXF1ZXN0SWQ6aCxzaWduRGF0YTpzLGRhdGFUeXBlOmksY2hhaW5JZDpuLGRlcml2YXRpb25QYXRoOnIsYWRkcmVzczpkLG9yaWdpbjphW28ub3JpZ2luXT9hW28ub3JpZ2luXTp2b2lkIDB9KX0sYy5mcm9tQ0JPUj10PT57Y29uc3QgZT1uKHQpO3JldHVybiBjLmZyb21EYXRhSXRlbShlKX07Y29uc3R7UmVnaXN0cnlUeXBlczpnLGRlY29kZVRvRGF0YUl0ZW06dX09ZS5leHRlbmQ7dmFyIG07IWZ1bmN0aW9uKHQpe3RbdC5yZXF1ZXN0SWQ9MV09XCJyZXF1ZXN0SWRcIix0W3Quc2lnbmF0dXJlPTJdPVwic2lnbmF0dXJlXCIsdFt0Lm9yaWdpbj0zXT1cIm9yaWdpblwifShtfHwobT17fSkpO2NsYXNzIEkgZXh0ZW5kcyBlLlJlZ2lzdHJ5SXRlbXtjb25zdHJ1Y3Rvcih0LGEscyl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+ci5FVEhfU0lHTkFUVVJFLHRoaXMuZ2V0UmVxdWVzdElkPSgpPT50aGlzLnJlcXVlc3RJZCx0aGlzLmdldFNpZ25hdHVyZT0oKT0+dGhpcy5zaWduYXR1cmUsdGhpcy5nZXRPcmlnaW49KCk9PnRoaXMub3JpZ2luLHRoaXMudG9EYXRhSXRlbT0oKT0+e2NvbnN0IHQ9e307cmV0dXJuIHRoaXMucmVxdWVzdElkJiYodFttLnJlcXVlc3RJZF09bmV3IGUuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsZy5VVUlELmdldFRhZygpKSksdGhpcy5vcmlnaW4mJih0W20ub3JpZ2luXT10aGlzLm9yaWdpbiksdFttLnNpZ25hdHVyZV09dGhpcy5zaWduYXR1cmUsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMuc2lnbmF0dXJlPXQsdGhpcy5yZXF1ZXN0SWQ9YSx0aGlzLm9yaWdpbj1zfX1JLmZyb21EYXRhSXRlbT10PT57Y29uc3QgZT10LmdldERhdGEoKSxhPWVbbS5zaWduYXR1cmVdLHM9ZVttLnJlcXVlc3RJZF0/ZVttLnJlcXVlc3RJZF0uZ2V0RGF0YSgpOnZvaWQgMDtyZXR1cm4gbmV3IEkoYSxzLGVbbS5vcmlnaW5dKX0sSS5mcm9tQ0JPUj10PT57Y29uc3QgZT11KHQpO3JldHVybiBJLmZyb21EYXRhSXRlbShlKX07Y29uc3R7ZGVjb2RlVG9EYXRhSXRlbTpwfT1lLmV4dGVuZDt2YXIgRDshZnVuY3Rpb24odCl7dFt0LmNoYWluSWQ9MV09XCJjaGFpbklkXCIsdFt0LmNvbnRyYWN0QWRkcmVzcz0yXT1cImNvbnRyYWN0QWRkcmVzc1wiLHRbdC5jb250cmFjdE5hbWU9M109XCJjb250cmFjdE5hbWVcIix0W3QubmFtZT00XT1cIm5hbWVcIix0W3QubWVkaWFEYXRhPTVdPVwibWVkaWFEYXRhXCJ9KER8fChEPXt9KSk7Y2xhc3MgVCBleHRlbmRzIGUuUmVnaXN0cnlJdGVte2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5nZXRSZWdpc3RyeVR5cGU9KCk9PnIuRVRIX05GVF9JVEVNLHRoaXMuZ2V0Q2hhaW5JZD0oKT0+dGhpcy5jaGFpbklkLHRoaXMuZ2V0TmFtZT0oKT0+dGhpcy5uYW1lLHRoaXMuZ2V0bWVkaWFEYXRhPSgpPT50aGlzLm1lZGlhRGF0YSx0aGlzLmdldENvbnRyYWN0QWRkcmVzcz0oKT0+dGhpcy5jb250cmFjdEFkZHJlc3MsdGhpcy5nZXRDb250cmFjdE5hbWU9KCk9PnRoaXMuY29udHJhY3ROYW1lLHRoaXMudG9EYXRhSXRlbT0oKT0+e2NvbnN0IHQ9e307cmV0dXJuIHRbRC5jaGFpbklkXT10aGlzLmNoYWluSWQsdFtELm5hbWVdPXRoaXMubmFtZSx0W0QuY29udHJhY3RBZGRyZXNzXT10aGlzLmNvbnRyYWN0QWRkcmVzcyx0W0QuY29udHJhY3ROYW1lXT10aGlzLmNvbnRyYWN0TmFtZSx0W0QubWVkaWFEYXRhXT10aGlzLm1lZGlhRGF0YSxuZXcgZS5EYXRhSXRlbSh0KX0sdGhpcy5jaGFpbklkPXQuY2hhaW5JZCx0aGlzLm5hbWU9dC5uYW1lLHRoaXMuY29udHJhY3RBZGRyZXNzPXQuY29udHJhY3RBZGRyZXNzLHRoaXMuY29udHJhY3ROYW1lPXQuY29udHJhY3ROYW1lLHRoaXMubWVkaWFEYXRhPXQubWVkaWFEYXRhfXN0YXRpYyBjb25zdHJ1Y3RFVEhORlRJdGVtKHQsZSxhLHMsaSl7cmV0dXJuIG5ldyBUKHtjaGFpbklkOnQsY29udHJhY3RBZGRyZXNzOmUsY29udHJhY3ROYW1lOmEsbWVkaWFEYXRhOmksbmFtZTpzfSl9fVQuZnJvbURhdGFJdGVtPXQ9Pntjb25zdCBlPXQuZ2V0RGF0YSgpO3JldHVybiBuZXcgVCh7Y2hhaW5JZDplW0QuY2hhaW5JZF0sbmFtZTplW0QubmFtZV0sY29udHJhY3RBZGRyZXNzOmVbRC5jb250cmFjdEFkZHJlc3NdLGNvbnRyYWN0TmFtZTplW0QuY29udHJhY3ROYW1lXSxtZWRpYURhdGE6ZVtELm1lZGlhRGF0YV19KX0sVC5mcm9tQ0JPUj10PT57Y29uc3QgZT1wKHQpO3JldHVybiBULmZyb21EYXRhSXRlbShlKX07Y29uc3QgeT0odCxlKT0+e2NvbnN0IGE9cy5mcm9tRXh0ZW5kZWRLZXkodCkuZGVyaXZlKGUpLHI9XCIweFwiK2kucHVibGljVG9BZGRyZXNzKGEucHVibGljS2V5LCEwKS50b1N0cmluZyhcImhleFwiKTtyZXR1cm4gaS50b0NoZWNrc3VtQWRkcmVzcyhyKX07ZS5wYXRjaFRhZ3MoT2JqZWN0LnZhbHVlcyhyKS5maWx0ZXIodD0+ISF0LmdldFRhZygpKS5tYXAodD0+dC5nZXRUYWcoKSkpLE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe1wiZGVmYXVsdFwiIT09dCYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsdCx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVt0XX19KX0pKSxleHBvcnRzLkVUSE5GVEl0ZW09VCxleHBvcnRzLkVUSFNpZ25hdHVyZT1JLGV4cG9ydHMuRXRoU2lnblJlcXVlc3Q9YyxleHBvcnRzLmZpbmRIRFBhdGhGcm9tQWRkcmVzcz0odCxlLGEscyk9Pntmb3IobGV0IGk9MDtpPGE7aSsrKXtjb25zdCBhPXkoZSxcIk0vMC9cIitpKTtpZih0LnRvTG93ZXJDYXNlKCk9PWEudG9Mb3dlckNhc2UoKSlyZXR1cm5gJHtzfS8wLyR7aX1gfXJldHVybiBudWxsfSxleHBvcnRzLmdlbmVyYXRlQWRkcmVzc0Zyb21YcHViPXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYy11ci1yZWdpc3RyeS1ldGguY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CeXRlcyA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNsYXNzIEJ5dGVzIGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQllURVM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RGF0YSA9ICgpID0+IHRoaXMuYnl0ZXM7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0odGhpcy5ieXRlcyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5CeXRlcyA9IEJ5dGVzO1xuQnl0ZXMuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgaWYgKCFieXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNbdXItcmVnaXN0cnldW0J5dGVzXVtmbi5mcm9tRGF0YUl0ZW1dOiBkZWNvZGVkIFtkYXRhSXRlbV1bI2RhdGFdIGlzIHVuZGVmaW5lZDogJHtkYXRhSXRlbX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XG59O1xuQnl0ZXMuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IF8xID0gcmVxdWlyZShcIi5cIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcIm1hc3RlckZpbmdlcnByaW50XCJdID0gMV0gPSBcIm1hc3RlckZpbmdlcnByaW50XCI7XG4gICAgS2V5c1tLZXlzW1wib3V0cHV0RGVzY3JpcHRvcnNcIl0gPSAyXSA9IFwib3V0cHV0RGVzY3JpcHRvcnNcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvQWNjb3VudCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IobWFzdGVyRmluZ2VycHJpbnQsIG91dHB1dERlc2NyaXB0b3JzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFzdGVyRmluZ2VycHJpbnQgPSBtYXN0ZXJGaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5vdXRwdXREZXNjcmlwdG9ycyA9IG91dHB1dERlc2NyaXB0b3JzO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19BQ0NPVU5UO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1hc3RlckZpbmdlcnByaW50ID0gKCkgPT4gdGhpcy5tYXN0ZXJGaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5nZXRPdXRwdXREZXNjcmlwdG9ycyA9ICgpID0+IHRoaXMub3V0cHV0RGVzY3JpcHRvcnM7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMubWFzdGVyRmluZ2VycHJpbnQpIHtcbiAgICAgICAgICAgICAgICBtYXBbS2V5cy5tYXN0ZXJGaW5nZXJwcmludF0gPSB0aGlzLm1hc3RlckZpbmdlcnByaW50LnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dERlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMub3V0cHV0RGVzY3JpcHRvcnNdID0gdGhpcy5vdXRwdXREZXNjcmlwdG9ycy5tYXAoKGl0ZW0pID0+IGl0ZW0udG9EYXRhSXRlbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0obWFwKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b0FjY291bnQgPSBDcnlwdG9BY2NvdW50O1xuQ3J5cHRvQWNjb3VudC5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgY29uc3QgbWFzdGVyRmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgY29uc3QgX21hc3RlckZpbmdlcnByaW50ID0gbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdO1xuICAgIGlmIChfbWFzdGVyRmluZ2VycHJpbnQpIHtcbiAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfbWFzdGVyRmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXREZXNjcmlwdG9ycyA9IG1hcFtLZXlzLm91dHB1dERlc2NyaXB0b3JzXTtcbiAgICBjb25zdCBjcnlwdG9PdXRwdXRzID0gb3V0cHV0RGVzY3JpcHRvcnMubWFwKChpdGVtKSA9PiBfMS5DcnlwdG9PdXRwdXQuZnJvbURhdGFJdGVtKGl0ZW0pKTtcbiAgICByZXR1cm4gbmV3IENyeXB0b0FjY291bnQobWFzdGVyRmluZ2VycHJpbnQsIGNyeXB0b091dHB1dHMpO1xufTtcbkNyeXB0b0FjY291bnQuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvQWNjb3VudC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0FjY291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0NvaW5JbmZvID0gZXhwb3J0cy5OZXR3b3JrID0gZXhwb3J0cy5UeXBlID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW1widHlwZVwiXSA9IFwiMVwiO1xuICAgIEtleXNbXCJuZXR3b3JrXCJdID0gXCIyXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiYml0Y29pblwiXSA9IDBdID0gXCJiaXRjb2luXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xudmFyIE5ldHdvcms7XG4oZnVuY3Rpb24gKE5ldHdvcmspIHtcbiAgICBOZXR3b3JrW05ldHdvcmtbXCJtYWlubmV0XCJdID0gMF0gPSBcIm1haW5uZXRcIjtcbiAgICBOZXR3b3JrW05ldHdvcmtbXCJ0ZXN0bmV0XCJdID0gMV0gPSBcInRlc3RuZXRcIjtcbn0pKE5ldHdvcmsgPSBleHBvcnRzLk5ldHdvcmsgfHwgKGV4cG9ydHMuTmV0d29yayA9IHt9KSk7XG5jbGFzcyBDcnlwdG9Db2luSW5mbyBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbmV0d29yaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19DT0lOX0lORk87XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgfHwgVHlwZS5iaXRjb2luO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE5ldHdvcmsgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrIHx8IE5ldHdvcmsubWFpbm5ldDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMudHlwZV0gPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMubmV0d29ya10gPSB0aGlzLm5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9Db2luSW5mbyA9IENyeXB0b0NvaW5JbmZvO1xuQ3J5cHRvQ29pbkluZm8uZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IHR5cGUgPSBtYXBbS2V5cy50eXBlXTtcbiAgICBjb25zdCBuZXR3b3JrID0gbWFwW0tleXMubmV0d29ya107XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9Db2luSW5mbyh0eXBlLCBuZXR3b3JrKTtcbn07XG5DcnlwdG9Db2luSW5mby5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9Db2luSW5mby5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0NvaW5JbmZvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9FQ0tleSA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1wiY3VydmVcIl0gPSAxXSA9IFwiY3VydmVcIjtcbiAgICBLZXlzW0tleXNbXCJwcml2YXRlXCJdID0gMl0gPSBcInByaXZhdGVcIjtcbiAgICBLZXlzW0tleXNbXCJkYXRhXCJdID0gM10gPSBcImRhdGFcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvRUNLZXkgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc0VDS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q3VydmUgPSAoKSA9PiB0aGlzLmN1cnZlIHx8IDA7XG4gICAgICAgIHRoaXMuaXNQcml2YXRlS2V5ID0gKCkgPT4gdGhpcy5wcml2YXRlS2V5IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmdldERhdGEgPSAoKSA9PiB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0VDS0VZO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnZlKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuY3VydmVdID0gdGhpcy5jdXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLnByaXZhdGVdID0gdGhpcy5wcml2YXRlS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwW0tleXMuZGF0YV0gPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhID0gYXJncy5kYXRhO1xuICAgICAgICB0aGlzLmN1cnZlID0gYXJncy5jdXJ2ZTtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gYXJncy5wcml2YXRlS2V5IHx8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b0VDS2V5ID0gQ3J5cHRvRUNLZXk7XG5DcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgY29uc3QgY3VydmUgPSBtYXBbS2V5cy5jdXJ2ZV07XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IG1hcFtLZXlzLnByaXZhdGVdO1xuICAgIGNvbnN0IGRhdGEgPSBtYXBbS2V5cy5kYXRhXTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtDcnlwdG9FQ0tleV1bZm4uZnJvbURhdGFJdGVtXTogZGVjb2RlZCBbZGF0YUl0ZW1dWyNkYXRhLmRhdGFdIGlzIHVuZGVmaW5lZDogJHtkYXRhSXRlbX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9FQ0tleSh7IGRhdGEsIGN1cnZlLCBwcml2YXRlS2V5IH0pO1xufTtcbkNyeXB0b0VDS2V5LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b0VDS2V5LmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvRUNLZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0hES2V5ID0gdm9pZCAwO1xuY29uc3QgYnM1OGNoZWNrXzEgPSByZXF1aXJlKFwiYnM1OGNoZWNrXCIpO1xuY29uc3QgQ3J5cHRvQ29pbkluZm9fMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0NvaW5JbmZvXCIpO1xuY29uc3QgQ3J5cHRvS2V5cGF0aF8xID0gcmVxdWlyZShcIi4vQ3J5cHRvS2V5cGF0aFwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1wiaXNfbWFzdGVyXCJdID0gMV0gPSBcImlzX21hc3RlclwiO1xuICAgIEtleXNbS2V5c1tcImlzX3ByaXZhdGVcIl0gPSAyXSA9IFwiaXNfcHJpdmF0ZVwiO1xuICAgIEtleXNbS2V5c1tcImtleV9kYXRhXCJdID0gM10gPSBcImtleV9kYXRhXCI7XG4gICAgS2V5c1tLZXlzW1wiY2hhaW5fY29kZVwiXSA9IDRdID0gXCJjaGFpbl9jb2RlXCI7XG4gICAgS2V5c1tLZXlzW1widXNlX2luZm9cIl0gPSA1XSA9IFwidXNlX2luZm9cIjtcbiAgICBLZXlzW0tleXNbXCJvcmlnaW5cIl0gPSA2XSA9IFwib3JpZ2luXCI7XG4gICAgS2V5c1tLZXlzW1wiY2hpbGRyZW5cIl0gPSA3XSA9IFwiY2hpbGRyZW5cIjtcbiAgICBLZXlzW0tleXNbXCJwYXJlbnRfZmluZ2VycHJpbnRcIl0gPSA4XSA9IFwicGFyZW50X2ZpbmdlcnByaW50XCI7XG4gICAgS2V5c1tLZXlzW1wibmFtZVwiXSA9IDldID0gXCJuYW1lXCI7XG4gICAgS2V5c1tLZXlzW1wibm90ZVwiXSA9IDEwXSA9IFwibm90ZVwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5jbGFzcyBDcnlwdG9IREtleSBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzRUNLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0S2V5ID0gKCkgPT4gdGhpcy5rZXk7XG4gICAgICAgIHRoaXMuZ2V0Q2hhaW5Db2RlID0gKCkgPT4gdGhpcy5jaGFpbkNvZGU7XG4gICAgICAgIHRoaXMuaXNNYXN0ZXIgPSAoKSA9PiB0aGlzLm1hc3RlcjtcbiAgICAgICAgdGhpcy5pc1ByaXZhdGVLZXkgPSAoKSA9PiAhIXRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgdGhpcy5nZXRVc2VJbmZvID0gKCkgPT4gdGhpcy51c2VJbmZvO1xuICAgICAgICB0aGlzLmdldE9yaWdpbiA9ICgpID0+IHRoaXMub3JpZ2luO1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuID0gKCkgPT4gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgdGhpcy5nZXRQYXJlbnRGaW5nZXJwcmludCA9ICgpID0+IHRoaXMucGFyZW50RmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0TmFtZSA9ICgpID0+IHRoaXMubmFtZTtcbiAgICAgICAgdGhpcy5nZXROb3RlID0gKCkgPT4gdGhpcy5ub3RlO1xuICAgICAgICB0aGlzLmdldEJpcDMyS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBsZXQgdmVyc2lvbjtcbiAgICAgICAgICAgIGxldCBkZXB0aDtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgcGFyZW50RmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCkuZmlsbCgwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWFzdGVyKCkpIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gQnVmZmVyLmZyb20oJzA0ODhBREU0JywgJ2hleCcpO1xuICAgICAgICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aCA9ICgoX2EgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q29tcG9uZW50cygpLmxlbmd0aCkgfHwgKChfYiA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXREZXB0aCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRocyA9IChfYyA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRDb21wb25lbnRzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBhdGggPSBwYXRoc1twYXRocy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBsYXN0UGF0aC5pc0hhcmRlbmVkKCkgPyBsYXN0UGF0aC5nZXRJbmRleCgpICsgMHg4MDAwMDAwMCA6IGxhc3RQYXRoLmdldEluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFBhcmVudEZpbmdlcnByaW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50ID0gdGhpcy5nZXRQYXJlbnRGaW5nZXJwcmludCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpdmF0ZUtleSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSBCdWZmZXIuZnJvbSgnMDQ4OEFERTQnLCAnaGV4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gQnVmZmVyLmZyb20oJzA0ODhCMjFFJywgJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlcHRoQnVmZmVyID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICAgICAgZGVwdGhCdWZmZXIud3JpdGVVSW50OChkZXB0aCwgMCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyLndyaXRlVUludDMyQkUoaW5kZXgsIDApO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gdGhpcy5nZXRDaGFpbkNvZGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJzNThjaGVja18xLmVuY29kZSkoQnVmZmVyLmNvbmNhdChbdmVyc2lvbiwgZGVwdGhCdWZmZXIsIHBhcmVudEZpbmdlcnByaW50LCBpbmRleEJ1ZmZlciwgY2hhaW5Db2RlLCBrZXldKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSAmJiAoKF9iID0gdGhpcy5nZXRPcmlnaW4oKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFBhdGgoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGAkeyhfZCA9IChfYyA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9TdHJpbmcoJ2hleCcpfS8keyhfZSA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5nZXRQYXRoKCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5nZXRCaXAzMktleSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgIGlmICgoX2YgPSB0aGlzLmdldENoaWxkcmVuKCkpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5nZXRQYXRoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGAvJHsoX2cgPSB0aGlzLmdldENoaWxkcmVuKCkpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5nZXRQYXRoKCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHVwTWFzdGVyS2V5ID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFzdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgICAgICAgICB0aGlzLmNoYWluQ29kZSA9IGFyZ3MuY2hhaW5Db2RlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHVwRGVyaXZlS2V5ID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFzdGVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBhcmdzLmlzUHJpdmF0ZUtleTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgICAgICAgICB0aGlzLmNoYWluQ29kZSA9IGFyZ3MuY2hhaW5Db2RlO1xuICAgICAgICAgICAgdGhpcy51c2VJbmZvID0gYXJncy51c2VJbmZvO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBhcmdzLm9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBhcmdzLmNoaWxkcmVuO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRGaW5nZXJwcmludCA9IGFyZ3MucGFyZW50RmluZ2VycHJpbnQ7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBhcmdzLm5hbWU7XG4gICAgICAgICAgICB0aGlzLm5vdGUgPSBhcmdzLm5vdGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMubWFzdGVyKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuaXNfbWFzdGVyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMua2V5X2RhdGFdID0gdGhpcy5rZXk7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuY2hhaW5fY29kZV0gPSB0aGlzLmNoYWluQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5pc19wcml2YXRlXSA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwW0tleXMua2V5X2RhdGFdID0gdGhpcy5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhaW5Db2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLmNoYWluX2NvZGVdID0gdGhpcy5jaGFpbkNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlSW5mbyA9IHRoaXMudXNlSW5mby50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIHVzZUluZm8uc2V0VGFnKHRoaXMudXNlSW5mby5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLnVzZV9pbmZvXSA9IHVzZUluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLm9yaWdpbi50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5zZXRUYWcodGhpcy5vcmlnaW4uZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5vcmlnaW5dID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zZXRUYWcodGhpcy5jaGlsZHJlbi5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLmNoaWxkcmVuXSA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRGaW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5wYXJlbnRfZmluZ2VycHJpbnRdID0gdGhpcy5wYXJlbnRGaW5nZXJwcmludC5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5uYW1lXSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm90ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtLZXlzLm5vdGVdID0gdGhpcy5ub3RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0obWFwKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3MuaXNNYXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBNYXN0ZXJLZXkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwRGVyaXZlS2V5KGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9IREtleSA9IENyeXB0b0hES2V5O1xuQ3J5cHRvSERLZXkuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IGlzTWFzdGVyID0gISFtYXBbS2V5cy5pc19tYXN0ZXJdO1xuICAgIGNvbnN0IGlzUHJpdmF0ZUtleSA9IG1hcFtLZXlzLmlzX3ByaXZhdGVdO1xuICAgIGNvbnN0IGtleSA9IG1hcFtLZXlzLmtleV9kYXRhXTtcbiAgICBjb25zdCBjaGFpbkNvZGUgPSBtYXBbS2V5cy5jaGFpbl9jb2RlXTtcbiAgICBjb25zdCB1c2VJbmZvID0gbWFwW0tleXMudXNlX2luZm9dXG4gICAgICAgID8gQ3J5cHRvQ29pbkluZm9fMS5DcnlwdG9Db2luSW5mby5mcm9tRGF0YUl0ZW0obWFwW0tleXMudXNlX2luZm9dKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvcmlnaW4gPSBtYXBbS2V5cy5vcmlnaW5dXG4gICAgICAgID8gQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKG1hcFtLZXlzLm9yaWdpbl0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbWFwW0tleXMuY2hpbGRyZW5dXG4gICAgICAgID8gQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKG1hcFtLZXlzLmNoaWxkcmVuXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgX3BhcmVudEZpbmdlcnByaW50ID0gbWFwW0tleXMucGFyZW50X2ZpbmdlcnByaW50XTtcbiAgICBsZXQgcGFyZW50RmluZ2VycHJpbnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKF9wYXJlbnRGaW5nZXJwcmludCkge1xuICAgICAgICBwYXJlbnRGaW5nZXJwcmludCA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfcGFyZW50RmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gbWFwW0tleXMubmFtZV07XG4gICAgY29uc3Qgbm90ZSA9IG1hcFtLZXlzLm5vdGVdO1xuICAgIHJldHVybiBuZXcgQ3J5cHRvSERLZXkoe1xuICAgICAgICBpc01hc3RlcixcbiAgICAgICAgaXNQcml2YXRlS2V5LFxuICAgICAgICBrZXksXG4gICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgdXNlSW5mbyxcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG5vdGUsXG4gICAgfSk7XG59O1xuQ3J5cHRvSERLZXkuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvSERLZXkuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9IREtleS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvS2V5cGF0aCA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUGF0aENvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vUGF0aENvbXBvbmVudFwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcImNvbXBvbmVudHNcIl0gPSAxXSA9IFwiY29tcG9uZW50c1wiO1xuICAgIEtleXNbS2V5c1tcInNvdXJjZV9maW5nZXJwcmludFwiXSA9IDJdID0gXCJzb3VyY2VfZmluZ2VycHJpbnRcIjtcbiAgICBLZXlzW0tleXNbXCJkZXB0aFwiXSA9IDNdID0gXCJkZXB0aFwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5jbGFzcyBDcnlwdG9LZXlwYXRoIGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzID0gW10sIHNvdXJjZUZpbmdlcnByaW50LCBkZXB0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLnNvdXJjZUZpbmdlcnByaW50ID0gc291cmNlRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fS0VZUEFUSDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRQYXRoID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtjb21wb25lbnQuaXNXaWxkY2FyZCgpID8gJyonIDogY29tcG9uZW50LmdldEluZGV4KCl9JHtjb21wb25lbnQuaXNIYXJkZW5lZCgpID8gXCInXCIgOiAnJ31gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50cy5qb2luKCcvJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50cyA9ICgpID0+IHRoaXMuY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VGaW5nZXJwcmludCA9ICgpID0+IHRoaXMuc291cmNlRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0RGVwdGggPSAoKSA9PiB0aGlzLmRlcHRoO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pc1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50LmdldEluZGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQuaXNIYXJkZW5lZCgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcFtLZXlzLmNvbXBvbmVudHNdID0gY29tcG9uZW50cztcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZUZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuc291cmNlX2ZpbmdlcnByaW50XSA9IHRoaXMuc291cmNlRmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmRlcHRoXSA9IHRoaXMuZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9LZXlwYXRoID0gQ3J5cHRvS2V5cGF0aDtcbkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IHBhdGhDb21wb25lbnRzID0gW107XG4gICAgY29uc3QgY29tcG9uZW50cyA9IG1hcFtLZXlzLmNvbXBvbmVudHNdO1xuICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaXNIYXJkZW5lZCA9IGNvbXBvbmVudHNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcGF0aENvbXBvbmVudHMucHVzaChuZXcgUGF0aENvbXBvbmVudF8xLlBhdGhDb21wb25lbnQoeyBpbmRleDogcGF0aCwgaGFyZGVuZWQ6IGlzSGFyZGVuZWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aENvbXBvbmVudHMucHVzaChuZXcgUGF0aENvbXBvbmVudF8xLlBhdGhDb21wb25lbnQoeyBoYXJkZW5lZDogaXNIYXJkZW5lZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgX3NvdXJjZUZpbmdlcnByaW50ID0gbWFwW0tleXMuc291cmNlX2ZpbmdlcnByaW50XTtcbiAgICBsZXQgc291cmNlRmluZ2VycHJpbnQ7XG4gICAgaWYgKF9zb3VyY2VGaW5nZXJwcmludCkge1xuICAgICAgICBzb3VyY2VGaW5nZXJwcmludCA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgc291cmNlRmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfc291cmNlRmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBkZXB0aCA9IG1hcFtLZXlzLmRlcHRoXTtcbiAgICByZXR1cm4gbmV3IENyeXB0b0tleXBhdGgocGF0aENvbXBvbmVudHMsIHNvdXJjZUZpbmdlcnByaW50LCBkZXB0aCk7XG59O1xuQ3J5cHRvS2V5cGF0aC5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvS2V5cGF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvT3V0cHV0ID0gdm9pZCAwO1xuY29uc3QgQ3J5cHRvRUNLZXlfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0VDS2V5XCIpO1xuY29uc3QgQ3J5cHRvSERLZXlfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0hES2V5XCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBNdWx0aUtleV8xID0gcmVxdWlyZShcIi4vTXVsdGlLZXlcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgU2NyaXB0RXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vU2NyaXB0RXhwcmVzc2lvblwiKTtcbmNsYXNzIENyeXB0b091dHB1dCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3Ioc2NyaXB0RXhwcmVzc2lvbnMsIGNyeXB0b0tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjcmlwdEV4cHJlc3Npb25zID0gc2NyaXB0RXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMuY3J5cHRvS2V5ID0gY3J5cHRvS2V5O1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19PVVRQVVQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q3J5cHRvS2V5ID0gKCkgPT4gdGhpcy5jcnlwdG9LZXk7XG4gICAgICAgIHRoaXMuZ2V0SERLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jcnlwdG9LZXkgaW5zdGFuY2VvZiBDcnlwdG9IREtleV8xLkNyeXB0b0hES2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFQ0tleSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIENyeXB0b0VDS2V5XzEuQ3J5cHRvRUNLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9LZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE11bHRpS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgTXVsdGlLZXlfMS5NdWx0aUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyeXB0b0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0U2NyaXB0RXhwcmVzc2lvbnMgPSAoKSA9PiB0aGlzLnNjcmlwdEV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLl90b091dHB1dERlc2NyaXB0b3IgPSAoc2VJbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlSW5kZXggPj0gdGhpcy5zY3JpcHRFeHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9LZXkuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnNjcmlwdEV4cHJlc3Npb25zW3NlSW5kZXhdLmdldEV4cHJlc3Npb24oKX0oJHt0aGlzLl90b091dHB1dERlc2NyaXB0b3Ioc2VJbmRleCArIDEpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvT3V0cHV0RGVzY3JpcHRvcigwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGFJdGVtID0gdGhpcy5jcnlwdG9LZXkudG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleSkge1xuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyh0aGlzLmNyeXB0b0tleS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbG9uZWRTZSA9IFsuLi50aGlzLnNjcmlwdEV4cHJlc3Npb25zXTtcbiAgICAgICAgICAgIGNsb25lZFNlLnJldmVyc2UoKS5mb3JFYWNoKChzZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ1ZhbHVlID0gc2UuZ2V0VGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtLmdldFRhZygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0VGFnKHRhZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtID0gbmV3IGxpYl8xLkRhdGFJdGVtKGRhdGFJdGVtLCB0YWdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9PdXRwdXQgPSBDcnlwdG9PdXRwdXQ7XG5DcnlwdG9PdXRwdXQuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3Qgc2NyaXB0RXhwcmVzc2lvbnMgPSBbXTtcbiAgICBsZXQgX2RhdGFJdGVtID0gZGF0YUl0ZW07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IF90YWcgPSBfZGF0YUl0ZW0uZ2V0VGFnKCk7XG4gICAgICAgIGNvbnN0IHNlID0gU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb24uZnJvbVRhZyhfdGFnKTtcbiAgICAgICAgaWYgKHNlKSB7XG4gICAgICAgICAgICBzY3JpcHRFeHByZXNzaW9ucy5wdXNoKHNlKTtcbiAgICAgICAgICAgIGlmIChfZGF0YUl0ZW0uZ2V0RGF0YSgpIGluc3RhbmNlb2YgbGliXzEuRGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBfZGF0YUl0ZW0gPSBfZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIF90YWcgPSBfZGF0YUl0ZW0uZ2V0VGFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNlTGVuZ3RoID0gc2NyaXB0RXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgIGNvbnN0IGlzTXVsdGlLZXkgPSBzZUxlbmd0aCA+IDAgJiZcbiAgICAgICAgKHNjcmlwdEV4cHJlc3Npb25zW3NlTGVuZ3RoIC0gMV0uZ2V0RXhwcmVzc2lvbigpID09PVxuICAgICAgICAgICAgU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zLk1VTFRJU0lHLmdldEV4cHJlc3Npb24oKSB8fFxuICAgICAgICAgICAgc2NyaXB0RXhwcmVzc2lvbnNbc2VMZW5ndGggLSAxXS5nZXRFeHByZXNzaW9uKCkgPT09XG4gICAgICAgICAgICAgICAgU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zLlNPUlRFRF9NVUxUSVNJRy5nZXRFeHByZXNzaW9uKCkpO1xuICAgIGlmIChpc011bHRpS2V5KSB7XG4gICAgICAgIGNvbnN0IG11bHRpS2V5ID0gTXVsdGlLZXlfMS5NdWx0aUtleS5mcm9tRGF0YUl0ZW0oX2RhdGFJdGVtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDcnlwdG9PdXRwdXQoc2NyaXB0RXhwcmVzc2lvbnMsIG11bHRpS2V5KTtcbiAgICB9XG4gICAgaWYgKF9kYXRhSXRlbS5nZXRUYWcoKSA9PT0gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VGFnKCkpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvSERLZXkgPSBDcnlwdG9IREtleV8xLkNyeXB0b0hES2V5LmZyb21EYXRhSXRlbShfZGF0YUl0ZW0pO1xuICAgICAgICByZXR1cm4gbmV3IENyeXB0b091dHB1dChzY3JpcHRFeHByZXNzaW9ucywgY3J5cHRvSERLZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY3J5cHRvRUNLZXkgPSBDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5LmZyb21EYXRhSXRlbShfZGF0YUl0ZW0pO1xuICAgICAgICByZXR1cm4gbmV3IENyeXB0b091dHB1dChzY3JpcHRFeHByZXNzaW9ucywgY3J5cHRvRUNLZXkpO1xuICAgIH1cbn07XG5DcnlwdG9PdXRwdXQuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvT3V0cHV0LmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvT3V0cHV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9QU0JUID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xuY2xhc3MgQ3J5cHRvUFNCVCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IocHNidCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBzYnQgPSBwc2J0O1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX1BTQlQ7XG4gICAgICAgIHRoaXMuZ2V0UFNCVCA9ICgpID0+IHRoaXMucHNidDtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbSh0aGlzLnBzYnQpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvUFNCVCA9IENyeXB0b1BTQlQ7XG5DcnlwdG9QU0JULmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IHBzYnQgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgaWYgKCFwc2J0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgI1t1ci1yZWdpc3RyeV1bQ3J5cHRvUFNCVF1bZm4uZnJvbURhdGFJdGVtXTogZGVjb2RlZCBbZGF0YUl0ZW1dWyNkYXRhXSBpcyB1bmRlZmluZWQ6ICR7ZGF0YUl0ZW19YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3J5cHRvUFNCVChwc2J0KTtcbn07XG5DcnlwdG9QU0JULmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b1BTQlQuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9QU0JULmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VUlJlZ2lzdHJ5RGVjb2RlciA9IHZvaWQgMDtcbmNvbnN0IGJjX3VyXzEgPSByZXF1aXJlKFwiQG5ncmF2ZWlvL2JjLXVyXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY2xhc3MgVVJSZWdpc3RyeURlY29kZXIgZXh0ZW5kcyBiY191cl8xLlVSRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVzdWx0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXIgPSB0aGlzLnJlc3VsdFVSKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVyLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQllURVMuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkJ5dGVzLmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0hES2V5LmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fS0VZUEFUSC5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvS2V5cGF0aC5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0NPSU5fSU5GTy5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvQ29pbkluZm8uZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19FQ0tFWS5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvRUNLZXkuZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19PVVRQVVQuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b091dHB1dC5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX1BTQlQuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b1BTQlQuZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19BQ0NPVU5ULmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9BY2NvdW50LmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Vbmtub3duVVJUeXBlRXJyb3IoYCNbdXItcmVnaXN0cnldW0RlY29kZXJdW2ZuLnJlc3VsdFJlZ2lzdHJ5VHlwZV06IHJlZ2lzdHJ5IHR5cGUgJHt1ci50eXBlfSBpcyBub3Qgc3VwcG9ydGVkIG5vd2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVVJSZWdpc3RyeURlY29kZXIgPSBVUlJlZ2lzdHJ5RGVjb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdWx0aUtleSA9IHZvaWQgMDtcbmNvbnN0IENyeXB0b0VDS2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9FQ0tleVwiKTtcbmNvbnN0IENyeXB0b0hES2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9IREtleVwiKTtcbmNvbnN0IERhdGFJdGVtXzEgPSByZXF1aXJlKFwiLi9saWIvRGF0YUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJ0aHJlc2hvbGRcIl0gPSAxXSA9IFwidGhyZXNob2xkXCI7XG4gICAgS2V5c1tLZXlzW1wia2V5c1wiXSA9IDJdID0gXCJrZXlzXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIE11bHRpS2V5IGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcih0aHJlc2hvbGQsIGtleXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIHRoaXMuZ2V0VGhyZXNob2xkID0gKCkgPT4gdGhpcy50aHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuZ2V0S2V5cyA9ICgpID0+IHRoaXMua2V5cztcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBtYXBbS2V5cy50aHJlc2hvbGRdID0gdGhpcy50aHJlc2hvbGQ7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5rZXlzLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gay50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0VGFnKGsuZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFwW0tleXMua2V5c10gPSBrZXlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhSXRlbV8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2V0VGhyZXNob2xkKCksXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzLm1hcChrID0+IGsuZ2V0T3V0cHV0RGVzY3JpcHRvckNvbnRlbnQoKSkuam9pbignLCcpLFxuICAgICAgICAgICAgXS5qb2luKCcsJyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5NdWx0aUtleSA9IE11bHRpS2V5O1xuTXVsdGlLZXkuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IG1hcFtLZXlzLnRocmVzaG9sZF07XG4gICAgY29uc3QgX2tleXMgPSBtYXBbS2V5cy5rZXlzXTtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgX2tleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICBpZiAoay5nZXRUYWcoKSA9PT0gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VGFnKCkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChDcnlwdG9IREtleV8xLkNyeXB0b0hES2V5LmZyb21EYXRhSXRlbShrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoay5nZXRUYWcoKSA9PT0gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fRUNLRVkuZ2V0VGFnKCkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5LmZyb21EYXRhSXRlbShrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE11bHRpS2V5KHRocmVzaG9sZCwga2V5cyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlLZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGhDb21wb25lbnQgPSB2b2lkIDA7XG5jbGFzcyBQYXRoQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHRoaXMuZ2V0SW5kZXggPSAoKSA9PiB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmlzV2lsZGNhcmQgPSAoKSA9PiB0aGlzLndpbGRjYXJkO1xuICAgICAgICB0aGlzLmlzSGFyZGVuZWQgPSAoKSA9PiB0aGlzLmhhcmRlbmVkO1xuICAgICAgICB0aGlzLmluZGV4ID0gYXJncy5pbmRleDtcbiAgICAgICAgdGhpcy5oYXJkZW5lZCA9IGFyZ3MuaGFyZGVuZWQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2lsZGNhcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2lsZGNhcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGV4ICYmICh0aGlzLmluZGV4ICYgUGF0aENvbXBvbmVudC5IQVJERU5FRF9CSVQpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNbdXItcmVnaXN0cnldW1BhdGhDb21wb25lbnRdW2ZuLmNvbnN0cnVjdG9yXTogSW52YWxpZCBpbmRleCAke3RoaXMuaW5kZXh9IC0gbW9zdCBzaWduaWZpY2FudCBiaXQgY2Fubm90IGJlIHNldGApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoQ29tcG9uZW50ID0gUGF0aENvbXBvbmVudDtcblBhdGhDb21wb25lbnQuSEFSREVORURfQklUID0gMHg4MDAwMDAwMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGhDb21wb25lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlZ2lzdHJ5SXRlbSA9IHZvaWQgMDtcbmNvbnN0IGJjX3VyXzEgPSByZXF1aXJlKFwiQG5ncmF2ZWlvL2JjLXVyXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jbGFzcyBSZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRvQ0JPUiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRvRGF0YUl0ZW0oKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtSZWdpc3RyeUl0ZW1dW2ZuLnRvQ0JPUl06IHJlZ2lzdHJ5ICR7dGhpcy5nZXRSZWdpc3RyeVR5cGUoKX0ncyBtZXRob2QgdG9EYXRhSXRlbSByZXR1cm5zIHVuZGVmaW5lZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBsaWJfMS5lbmNvZGVEYXRhSXRlbSkodGhpcy50b0RhdGFJdGVtKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvVVIgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJjX3VyXzEuVVIodGhpcy50b0NCT1IoKSwgdGhpcy5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUeXBlKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvVVJFbmNvZGVyID0gKG1heEZyYWdtZW50TGVuZ3RoLCBmaXJzdFNlcU51bSwgbWluRnJhZ21lbnRMZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVyID0gdGhpcy50b1VSKCk7XG4gICAgICAgICAgICBjb25zdCB1ckVuY29kZXIgPSBuZXcgYmNfdXJfMS5VUkVuY29kZXIodXIsIG1heEZyYWdtZW50TGVuZ3RoLCBmaXJzdFNlcU51bSwgbWluRnJhZ21lbnRMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHVyRW5jb2RlcjtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJ5SXRlbSA9IFJlZ2lzdHJ5SXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZ2lzdHJ5SXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVnaXN0cnlUeXBlcyA9IGV4cG9ydHMuUmVnaXN0cnlUeXBlID0gdm9pZCAwO1xuY2xhc3MgUmVnaXN0cnlUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB0YWcpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuZ2V0VGFnID0gKCkgPT4gdGhpcy50YWc7XG4gICAgICAgIHRoaXMuZ2V0VHlwZSA9ICgpID0+IHRoaXMudHlwZTtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJ5VHlwZSA9IFJlZ2lzdHJ5VHlwZTtcbmV4cG9ydHMuUmVnaXN0cnlUeXBlcyA9IHtcbiAgICBVVUlEOiBuZXcgUmVnaXN0cnlUeXBlKCd1dWlkJywgMzcpLFxuICAgIEJZVEVTOiBuZXcgUmVnaXN0cnlUeXBlKCdieXRlcycsIHVuZGVmaW5lZCksXG4gICAgQ1JZUFRPX0hES0VZOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8taGRrZXknLCAzMDMpLFxuICAgIENSWVBUT19LRVlQQVRIOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8ta2V5cGF0aCcsIDMwNCksXG4gICAgQ1JZUFRPX0NPSU5fSU5GTzogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWNvaW4taW5mbycsIDMwNSksXG4gICAgQ1JZUFRPX0VDS0VZOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tZWNrZXknLCAzMDYpLFxuICAgIENSWVBUT19PVVRQVVQ6IG5ldyBSZWdpc3RyeVR5cGUoJ2NyeXB0by1vdXRwdXQnLCAzMDgpLFxuICAgIENSWVBUT19QU0JUOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tcHNidCcsIDMxMCksXG4gICAgQ1JZUFRPX0FDQ09VTlQ6IG5ldyBSZWdpc3RyeVR5cGUoJ2NyeXB0by1hY2NvdW50JywgMzExKSxcbiAgICBDUllQVE9fTVVMVElfQUNDT1VOVFM6IG5ldyBSZWdpc3RyeVR5cGUoXCJjcnlwdG8tbXVsdGktYWNjb3VudHNcIiwgMTEwMyksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVnaXN0cnlUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY3JpcHRFeHByZXNzaW9ucyA9IGV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbiA9IHZvaWQgMDtcbmNsYXNzIFNjcmlwdEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5nZXRUYWcgPSAoKSA9PiB0aGlzLnRhZztcbiAgICAgICAgdGhpcy5nZXRFeHByZXNzaW9uID0gKCkgPT4gdGhpcy5leHByZXNzaW9uO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbiA9IFNjcmlwdEV4cHJlc3Npb247XG5TY3JpcHRFeHByZXNzaW9uLmZyb21UYWcgPSAodGFnKSA9PiB7XG4gICAgY29uc3Qgc2UgPSBPYmplY3QudmFsdWVzKGV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbnMpLmZpbmQoKHNlKSA9PiBzZS5nZXRUYWcoKSA9PT0gdGFnKTtcbiAgICByZXR1cm4gc2U7XG59O1xuZXhwb3J0cy5TY3JpcHRFeHByZXNzaW9ucyA9IHtcbiAgICBTQ1JJUFRfSEFTSDogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAwLCAnc2gnKSxcbiAgICBXSVRORVNTX1NDUklQVF9IQVNIOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDEsICd3c2gnKSxcbiAgICBQVUJMSUNfS0VZOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDIsICdwaycpLFxuICAgIFBVQkxJQ19LRVlfSEFTSDogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAzLCAncGtoJyksXG4gICAgV0lUTkVTU19QVUJMSUNfS0VZX0hBU0g6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNCwgJ3dwa2gnKSxcbiAgICBDT01CTzogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDA1LCAnY29tYm8nKSxcbiAgICBNVUxUSVNJRzogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDA2LCAnbXVsdGknKSxcbiAgICBTT1JURURfTVVMVElTSUc6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNywgJ3NvcnRlZG11bHRpJyksXG4gICAgQUREUkVTUzogbmV3IFNjcmlwdEV4cHJlc3Npb24oMzA3LCAnYWRkcicpLFxuICAgIFJBV19TQ1JJUFQ6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwOCwgJ3JhdycpLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjcmlwdEV4cHJlc3Npb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVua25vd25VUlR5cGVFcnJvciA9IHZvaWQgMDtcbmNsYXNzIFVua25vd25VUlR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5rbm93blVSVHlwZUVycm9yID0gVW5rbm93blVSVHlwZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b011bHRpQWNjb3VudHMgPSB2b2lkIDA7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9SZWdpc3RyeVR5cGVcIik7XG5jb25zdCBDcnlwdG9IREtleV8xID0gcmVxdWlyZShcIi4uL0NyeXB0b0hES2V5XCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi4vbGliXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJtYXN0ZXJGaW5nZXJwcmludFwiXSA9IDFdID0gXCJtYXN0ZXJGaW5nZXJwcmludFwiO1xuICAgIEtleXNbS2V5c1tcImtleXNcIl0gPSAyXSA9IFwia2V5c1wiO1xuICAgIEtleXNbS2V5c1tcImRldmljZVwiXSA9IDNdID0gXCJkZXZpY2VcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvTXVsdGlBY2NvdW50cyBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IobWFzdGVyRmluZ2VycHJpbnQsIGtleXMsIGRldmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hc3RlckZpbmdlcnByaW50ID0gbWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gZGV2aWNlO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX01VTFRJX0FDQ09VTlRTO1xuICAgICAgICB0aGlzLmdldE1hc3RlckZpbmdlcnByaW50ID0gKCkgPT4gdGhpcy5tYXN0ZXJGaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5nZXRLZXlzID0gKCkgPT4gdGhpcy5rZXlzO1xuICAgICAgICB0aGlzLmdldERldmljZSA9ICgpID0+IHRoaXMuZGV2aWNlO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdID0gdGhpcy5tYXN0ZXJGaW5nZXJwcmludC5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMua2V5c10gPSB0aGlzLmtleXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gaXRlbS50b0RhdGFJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyhpdGVtLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMuZGV2aWNlXSA9IHRoaXMuZGV2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvTXVsdGlBY2NvdW50cyA9IENyeXB0b011bHRpQWNjb3VudHM7XG5DcnlwdG9NdWx0aUFjY291bnRzLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCBtYXN0ZXJGaW5nZXJwcmludCA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICBjb25zdCBfbWFzdGVyRmluZ2VycHJpbnQgPSBtYXBbS2V5cy5tYXN0ZXJGaW5nZXJwcmludF07XG4gICAgaWYgKF9tYXN0ZXJGaW5nZXJwcmludCkge1xuICAgICAgICBtYXN0ZXJGaW5nZXJwcmludC53cml0ZVVJbnQzMkJFKF9tYXN0ZXJGaW5nZXJwcmludCwgMCk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBtYXBbS2V5cy5rZXlzXTtcbiAgICBjb25zdCBjcnlwdG9IREtleXMgPSBrZXlzLm1hcCgoaXRlbSkgPT4gQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleS5mcm9tRGF0YUl0ZW0oaXRlbSkpO1xuICAgIGNvbnN0IGRldmljZSA9IG1hcFtLZXlzLmRldmljZV07XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9NdWx0aUFjY291bnRzKG1hc3RlckZpbmdlcnByaW50LCBjcnlwdG9IREtleXMsIGRldmljZSk7XG59O1xuQ3J5cHRvTXVsdGlBY2NvdW50cy5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9NdWx0aUFjY291bnRzLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvTXVsdGlBY2NvdW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnVmZmVyID0gZXhwb3J0cy5leHRlbmQgPSBleHBvcnRzLlBhdGhDb21wb25lbnQgPSBleHBvcnRzLlNjcmlwdEV4cHJlc3Npb25zID0gZXhwb3J0cy5NdWx0aUtleSA9IGV4cG9ydHMuQ3J5cHRvUFNCVCA9IGV4cG9ydHMuQ3J5cHRvT3V0cHV0ID0gZXhwb3J0cy5DcnlwdG9FQ0tleSA9IGV4cG9ydHMuQ3J5cHRvQ29pbkluZm9OZXR3b3JrID0gZXhwb3J0cy5DcnlwdG9Db2luSW5mb1R5cGUgPSBleHBvcnRzLkNyeXB0b0NvaW5JbmZvID0gZXhwb3J0cy5DcnlwdG9LZXlwYXRoID0gZXhwb3J0cy5DcnlwdG9NdWx0aUFjY291bnRzID0gZXhwb3J0cy5DcnlwdG9IREtleSA9IGV4cG9ydHMuQ3J5cHRvQWNjb3VudCA9IGV4cG9ydHMuQnl0ZXMgPSBleHBvcnRzLlVSUmVnaXN0cnlEZWNvZGVyID0gZXhwb3J0cy5EYXRhSXRlbSA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5yZXF1aXJlKFwiLi9wYXRjaENCT1JcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfMS5CdWZmZXI7IH0gfSk7XG5jb25zdCBDcnlwdG9IREtleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvSERLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9IREtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleTsgfSB9KTtcbmNvbnN0IENyeXB0b0tleXBhdGhfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0tleXBhdGhcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9LZXlwYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9LZXlwYXRoXzEuQ3J5cHRvS2V5cGF0aDsgfSB9KTtcbmNvbnN0IENyeXB0b0NvaW5JbmZvXzEgPSByZXF1aXJlKFwiLi9DcnlwdG9Db2luSW5mb1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0NvaW5JbmZvXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9Db2luSW5mb18xLkNyeXB0b0NvaW5JbmZvOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvQ29pbkluZm9UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9Db2luSW5mb18xLlR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9Db2luSW5mb05ldHdvcmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b0NvaW5JbmZvXzEuTmV0d29yazsgfSB9KTtcbmNvbnN0IENyeXB0b0VDS2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9FQ0tleVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0VDS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5OyB9IH0pO1xuY29uc3QgQnl0ZXNfMSA9IHJlcXVpcmUoXCIuL0J5dGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJ5dGVzXzEuQnl0ZXM7IH0gfSk7XG5jb25zdCBDcnlwdG9PdXRwdXRfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b091dHB1dFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b091dHB1dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvT3V0cHV0XzEuQ3J5cHRvT3V0cHV0OyB9IH0pO1xuY29uc3QgQ3J5cHRvUFNCVF8xID0gcmVxdWlyZShcIi4vQ3J5cHRvUFNCVFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b1BTQlRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b1BTQlRfMS5DcnlwdG9QU0JUOyB9IH0pO1xuY29uc3QgQ3J5cHRvQWNjb3VudF8xID0gcmVxdWlyZShcIi4vQ3J5cHRvQWNjb3VudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0FjY291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b0FjY291bnRfMS5DcnlwdG9BY2NvdW50OyB9IH0pO1xuY29uc3QgRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vRGVjb2RlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVSUmVnaXN0cnlEZWNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZWNvZGVyXzEuVVJSZWdpc3RyeURlY29kZXI7IH0gfSk7XG5jb25zdCBNdWx0aUtleV8xID0gcmVxdWlyZShcIi4vTXVsdGlLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aUtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTXVsdGlLZXlfMS5NdWx0aUtleTsgfSB9KTtcbmNvbnN0IFNjcmlwdEV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL1NjcmlwdEV4cHJlc3Npb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY3JpcHRFeHByZXNzaW9uc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zOyB9IH0pO1xuY29uc3QgUGF0aENvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vUGF0aENvbXBvbmVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhdGhDb21wb25lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50OyB9IH0pO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xudmFyIGxpYl8yID0gcmVxdWlyZShcIi4vbGliXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYl8yLkRhdGFJdGVtOyB9IH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgQ3J5cHRvTXVsdGlBY2NvdW50c18xID0gcmVxdWlyZShcIi4vZXh0ZW5kZWQvQ3J5cHRvTXVsdGlBY2NvdW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b011bHRpQWNjb3VudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b011bHRpQWNjb3VudHNfMS5DcnlwdG9NdWx0aUFjY291bnRzOyB9IH0pO1xuY29uc3QgVVJsaWIgPSB7XG4gICAgVVJSZWdpc3RyeURlY29kZXI6IERlY29kZXJfMS5VUlJlZ2lzdHJ5RGVjb2RlcixcbiAgICBCeXRlczogQnl0ZXNfMS5CeXRlcyxcbiAgICBDcnlwdG9BY2NvdW50OiBDcnlwdG9BY2NvdW50XzEuQ3J5cHRvQWNjb3VudCxcbiAgICBDcnlwdG9IREtleTogQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleSxcbiAgICBDcnlwdG9NdWx0aUFjY291bnRzOiBDcnlwdG9NdWx0aUFjY291bnRzXzEuQ3J5cHRvTXVsdGlBY2NvdW50cyxcbiAgICBDcnlwdG9LZXlwYXRoOiBDcnlwdG9LZXlwYXRoXzEuQ3J5cHRvS2V5cGF0aCxcbiAgICBDcnlwdG9Db2luSW5mbzogQ3J5cHRvQ29pbkluZm9fMS5DcnlwdG9Db2luSW5mbyxcbiAgICBDcnlwdG9Db2luSW5mb1R5cGU6IENyeXB0b0NvaW5JbmZvXzEuVHlwZSxcbiAgICBDcnlwdG9Db2luSW5mb05ldHdvcms6IENyeXB0b0NvaW5JbmZvXzEuTmV0d29yayxcbiAgICBDcnlwdG9FQ0tleTogQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleSxcbiAgICBDcnlwdG9PdXRwdXQ6IENyeXB0b091dHB1dF8xLkNyeXB0b091dHB1dCxcbiAgICBDcnlwdG9QU0JUOiBDcnlwdG9QU0JUXzEuQ3J5cHRvUFNCVCxcbiAgICBNdWx0aUtleTogTXVsdGlLZXlfMS5NdWx0aUtleSxcbiAgICBTY3JpcHRFeHByZXNzaW9uczogU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zLFxuICAgIFBhdGhDb21wb25lbnQ6IFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50LFxufTtcbmNvbnN0IGNib3IgPSB7XG4gICAgYWRkUmVhZGVyOiBsaWJfMS5hZGRSZWFkZXIsXG4gICAgYWRkU2VtYW50aWNEZWNvZGU6IGxpYl8xLmFkZFNlbWFudGljRGVjb2RlLFxuICAgIGFkZFNlbWFudGljRW5jb2RlOiBsaWJfMS5hZGRTZW1hbnRpY0VuY29kZSxcbiAgICBhZGRXcml0ZXI6IGxpYl8xLmFkZFdyaXRlcixcbiAgICBwYXRjaFRhZ3M6IHV0aWxzXzEucGF0Y2hUYWdzLFxufTtcbmNvbnN0IGV4dGVuZCA9IHtcbiAgICBSZWdpc3RyeVR5cGVzOiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLFxuICAgIFJlZ2lzdHJ5SXRlbTogUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtLFxuICAgIFJlZ2lzdHJ5VHlwZTogUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlLFxuICAgIGRlY29kZVRvRGF0YUl0ZW06IGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0sXG4gICAgZW5jb2RlRGF0YUl0ZW06IGxpYl8xLmVuY29kZURhdGFJdGVtLFxuICAgIGNib3IsXG59O1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0RlY29kZXJcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9saWJcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9BY2NvdW50XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vQ3J5cHRvUFNCVFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0hES2V5XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vZXh0ZW5kZWQvQ3J5cHRvTXVsdGlBY2NvdW50c1wiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b091dHB1dFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0NvaW5JbmZvXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vQ3J5cHRvRUNLZXlcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9NdWx0aUtleVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0tleXBhdGhcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9wYXRjaENCT1JcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9QYXRoQ29tcG9uZW50XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi91dGlsc1wiKSwgZXhwb3J0cyk7XG5leHBvcnRzLmRlZmF1bHQgPSBVUmxpYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhSXRlbSA9IHZvaWQgMDtcbmNsYXNzIERhdGFJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB0YWcpIHtcbiAgICAgICAgdGhpcy5zZXRUYWcgPSAodGFnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhclRhZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFRhZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhSXRlbSA9IERhdGFJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWwuQ0JPUiA9IGZhY3RvcnkoKTtcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeyBEYXRhSXRlbSB9ID0gcmVxdWlyZSgnLi9EYXRhSXRlbScpO1xuICAgIHZhciBDQk9SID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQmluYXJ5SGV4KGhleCkge1xuICAgICAgICAgICAgdGhpcy4kaGV4ID0gaGV4O1xuICAgICAgICB9XG4gICAgICAgIEJpbmFyeUhleC5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaGV4Lmxlbmd0aCAvIDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdCB8fCBmb3JtYXQgPT09ICdoZXgnIHx8IGZvcm1hdCA9PT0gMTYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRoZXg7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3V0Zi04Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZCArPSAnJScgKyB0aGlzLiRoZXguc3Vic3RyaW5nKGksIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnbGF0aW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkLnB1c2gocGFyc2VJbnQodGhpcy4kaGV4LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBlbmNvZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbmlzZWQgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIEJpbmFyeUhleC5mcm9tTGF0aW5TdHJpbmcgPSBmdW5jdGlvbiAobGF0aW5TdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBoZXggPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW5TdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGxhdGluU3RyaW5nLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwYWlyLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcGFpciA9ICcwJyArIHBhaXI7XG4gICAgICAgICAgICAgICAgaGV4ICs9IHBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleChoZXgpO1xuICAgICAgICB9O1xuICAgICAgICBCaW5hcnlIZXguZnJvbVV0ZjhTdHJpbmcgPSBmdW5jdGlvbiAodXRmOFN0cmluZykge1xuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cmluZyk7XG4gICAgICAgICAgICB2YXIgaGV4ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RlZC5jaGFyQXQoaSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICBoZXggKz0gZW5jb2RlZC5zdWJzdHJpbmcoaSArIDEsIGkgKyAzKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhleFBhaXIgPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGV4UGFpci5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4UGFpciA9ICcwJyArIGhleFBhaXI7XG4gICAgICAgICAgICAgICAgICAgIGhleCArPSBoZXhQYWlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5SGV4KGhleCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZW1hbnRpY0VuY29kZXJzID0gW107XG4gICAgICAgIHZhciBzZW1hbnRpY0RlY29kZXJzID0ge307XG4gICAgICAgIHZhciBub3RJbXBsZW1lbnRlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobGFiZWwgKyAnIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gUmVhZGVyKCkgeyB9XG4gICAgICAgIFJlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBwZWVrQnl0ZTogbm90SW1wbGVtZW50ZWQoJ3BlZWtCeXRlJyksXG4gICAgICAgICAgICByZWFkQnl0ZTogbm90SW1wbGVtZW50ZWQoJ3JlYWRCeXRlJyksXG4gICAgICAgICAgICByZWFkQ2h1bms6IG5vdEltcGxlbWVudGVkKCdyZWFkQ2h1bmsnKSxcbiAgICAgICAgICAgIHJlYWRGbG9hdDE2OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbGYgPSB0aGlzLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSAoaGFsZiAmIDB4N2ZmZikgPj4gMTA7XG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhID0gaGFsZiAmIDB4M2ZmO1xuICAgICAgICAgICAgICAgIHZhciBuZWdhdGl2ZSA9IGhhbGYgJiAweDgwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAweDFmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW50aXNzYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IGV4cG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5wb3coMiwgZXhwb25lbnQgLSAyNSkgKiAoMTAyNCArIG1hbnRpc3NhKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucG93KDIsIC0yNCkgKiBtYW50aXNzYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAtbWFnbml0dWRlIDogbWFnbml0dWRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRGbG9hdDMyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludFZhbHVlID0gdGhpcy5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gKGludFZhbHVlICYgMHg3ZmZmZmZmZikgPj4gMjM7XG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhID0gaW50VmFsdWUgJiAweDdmZmZmZjtcbiAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBpbnRWYWx1ZSAmIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAweGZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW50aXNzYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IGV4cG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5wb3coMiwgZXhwb25lbnQgLSAyMyAtIDEyNykgKiAoODM4ODYwOCArIG1hbnRpc3NhKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucG93KDIsIC0yMyAtIDEyNikgKiBtYW50aXNzYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAtbWFnbml0dWRlIDogbWFnbml0dWRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRGbG9hdDY0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludDEgPSB0aGlzLnJlYWRVaW50MzIoKSwgaW50MiA9IHRoaXMucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IChpbnQxID4+IDIwKSAmIDB4N2ZmO1xuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYSA9IChpbnQxICYgMHhmZmZmZikgKiA0Mjk0OTY3Mjk2ICsgaW50MjtcbiAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBpbnQxICYgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDB4N2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW50aXNzYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IGV4cG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5wb3coMiwgZXhwb25lbnQgLSA1MiAtIDEwMjMpICogKDQ1MDM1OTk2MjczNzA0OTYgKyBtYW50aXNzYSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCAtNTIgLSAxMDIyKSAqIG1hbnRpc3NhO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1tYWduaXR1ZGUgOiBtYWduaXR1ZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZFVpbnQxNjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRCeXRlKCkgKiAyNTYgKyB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZFVpbnQzMjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50MTYoKSAqIDY1NTM2ICsgdGhpcy5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZFVpbnQ2NDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50MzIoKSAqIDQyOTQ5NjcyOTYgKyB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIFdyaXRlcigpIHsgfVxuICAgICAgICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgd3JpdGVCeXRlOiBub3RJbXBsZW1lbnRlZCgnd3JpdGVCeXRlJyksXG4gICAgICAgICAgICByZXN1bHQ6IG5vdEltcGxlbWVudGVkKCdyZXN1bHQnKSxcbiAgICAgICAgICAgIHdyaXRlRmxvYXQxNjogbm90SW1wbGVtZW50ZWQoJ3dyaXRlRmxvYXQxNicpLFxuICAgICAgICAgICAgd3JpdGVGbG9hdDMyOiBub3RJbXBsZW1lbnRlZCgnd3JpdGVGbG9hdDMyJyksXG4gICAgICAgICAgICB3cml0ZUZsb2F0NjQ6IG5vdEltcGxlbWVudGVkKCd3cml0ZUZsb2F0NjQnKSxcbiAgICAgICAgICAgIHdyaXRlVWludDE2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZSgodmFsdWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZSh2YWx1ZSAmIDB4ZmYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlVWludDMyOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVWludDE2KCh2YWx1ZSA+PiAxNikgJiAweGZmZmYpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVaW50MTYodmFsdWUgJiAweGZmZmYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlVWludDY0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gOTAwNzE5OTI1NDc0MDk5MiB8fCB2YWx1ZSA8PSAtOTAwNzE5OTI1NDc0MDk5Mikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNvZGUgVWludDY0IG9mOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbWFnbml0dWRlIHRvIGJpZyAoZmxvYXRpbmcgcG9pbnQgZXJyb3JzKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVWludDMyKE1hdGguZmxvb3IodmFsdWUgLyA0Mjk0OTY3Mjk2KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVVpbnQzMih2YWx1ZSAlIDQyOTQ5NjcyOTYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlU3RyaW5nOiBub3RJbXBsZW1lbnRlZCgnd3JpdGVTdHJpbmcnKSxcbiAgICAgICAgICAgIGNhbldyaXRlQmluYXJ5OiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JpdGVCaW5hcnk6IG5vdEltcGxlbWVudGVkKCd3cml0ZUNodW5rJyksXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRIZWFkZXJSYXcocmVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gcmVhZGVyLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICB2YXIgbWFqb3JUeXBlID0gZmlyc3RCeXRlID4+IDUsIHZhbHVlID0gZmlyc3RCeXRlICYgMHgxZjtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IG1ham9yVHlwZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXIudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAyNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDI0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gMjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDI2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSAyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZFVpbnQ2NCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gMzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vdEltcGxlbWVudGVkKCdBZGRpdGlvbmFsIGluZm86ICcgKyB2YWx1ZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZUhlYWRlclJhdyh0eXBlLCB2YWx1ZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKCh0eXBlIDw8IDUpIHwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlSGVhZGVyKHR5cGUsIHZhbHVlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSB0eXBlIDw8IDU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAyNCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJ5dGUoZmlyc3RCeXRlIHwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IDI0KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgNjU1MzYpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IDI1KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVaW50MTYodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZShmaXJzdEJ5dGUgfCAyNik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVWludDMyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJ5dGUoZmlyc3RCeXRlIHwgMjcpO1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVVpbnQ2NCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3BDb2RlID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZVJlYWRlcihyZWFkZXIpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkSGVhZGVyUmF3KHJlYWRlcik7XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlci50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSAtIHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRDaHVuayh2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSByZWFkZXIucmVhZENodW5rKHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheUxlbmd0aCA9IHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnR5cGUgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCAqPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZGVjb2RlUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaXRlbSA9IGRlY29kZVJlYWRlcihyZWFkZXIpKSAhPT0gc3RvcENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnR5cGUgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpSZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqUmVzdWx0W3Jlc3VsdFtpXV0gPSByZXN1bHRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSB2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb2RlciA9IHNlbWFudGljRGVjb2RlcnNbdGFnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRlY29kZVJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlciA/IGRlY29kZXIocmVzdWx0KSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXIudmFsdWUgPT09IDI1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGbG9hdDE2KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyLnZhbHVlID09PSAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRmxvYXQzMigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlYWRlci52YWx1ZSA9PT0gMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEZsb2F0NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3BDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZml4ZWQgdmFsdWU6ICcgKyBoZWFkZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBoZWFkZXI6ICcgKyBKU09OLnN0cmluZ2lmeShoZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZVdyaXRlcihkYXRhLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VtYW50aWNFbmNvZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHNlbWFudGljRW5jb2RlcnNbaV0uZm4oZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNiwgc2VtYW50aWNFbmNvZGVyc1tpXS50YWcsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVXcml0ZXIocmVwbGFjZW1lbnQsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEudG9DQk9SID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9DQk9SKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMCwgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMSwgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMiwgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDcsIDIzLCB3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoZGF0YSkgPT09IGRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA8IDkwMDcxOTkyNTQ3NDA5OTIgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA+IC05MDA3MTk5MjU0NzQwOTkyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMSwgLTEgLSBkYXRhLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMCwgZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXJSYXcoNywgMjcsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUZsb2F0NjQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlU3RyaW5nKGRhdGEsIGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMywgbGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod3JpdGVyLmNhbldyaXRlQmluYXJ5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQmluYXJ5KGRhdGEsIGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoMiwgbGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwaS5jb25maWcudXNlVG9KU09OICYmIHR5cGVvZiBkYXRhLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNCwgZGF0YS5sZW5ndGgsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGFbaV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDUsIGtleXMubGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoa2V5c1tpXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoZGF0YVtrZXlzW2ldXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihudW1iZXIsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGFba2V5c1tpXV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NCT1IgZW5jb2Rpbmcgbm90IHN1cHBvcnRlZDogJyArIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWFkZXJGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHdyaXRlckZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgdXNlVG9KU09OOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFdyaXRlcjogZnVuY3Rpb24gKGZvcm1hdCwgd3JpdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IGYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlckZ1bmN0aW9uKGYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlckZ1bmN0aW9ucy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFJlYWRlcjogZnVuY3Rpb24gKGZvcm1hdCwgcmVhZGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKGRhdGEsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IGYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlckZ1bmN0aW9uKGRhdGEsIGYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlckZ1bmN0aW9ucy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY29kZTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3JpdGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gd3JpdGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVyID0gZnVuYyhmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXIucmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvdXRwdXQgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNvZGVEYXRhSXRlbTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3JpdGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gd3JpdGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVyID0gZnVuYyhmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5nZXRUYWcoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGEsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5yZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhLmdldERhdGEoKSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyLnJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3V0cHV0IGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkZXJGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSByZWFkZXJGdW5jdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBmdW5jKGRhdGEsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGlucHV0IGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlVG9EYXRhSXRlbTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVhZGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gcmVhZGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gZnVuYyhkYXRhLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGFJdGVtKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBpbnB1dCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFNlbWFudGljRW5jb2RlOiBmdW5jdGlvbiAodGFnLCBmbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAnbnVtYmVyJyB8fCB0YWcgJSAxICE9PSAwIHx8IHRhZyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWcgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VtYW50aWNFbmNvZGVycy5wdXNoKHsgdGFnOiB0YWcsIGZuOiBmbiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRTZW1hbnRpY0RlY29kZTogZnVuY3Rpb24gKHRhZywgZm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZyAhPT0gJ251bWJlcicgfHwgdGFnICUgMSAhPT0gMCB8fCB0YWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFnIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbWFudGljRGVjb2RlcnNbdGFnXSA9IGZuO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUucGVla0J5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZFVJbnQxNkJFKHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkJFKHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRGbG9hdEJFKHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWREb3VibGVCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5jb3B5KHJlc3VsdCwgMCwgdGhpcy5wb3MsICh0aGlzLnBvcyArPSBsZW5ndGgpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcldyaXRlcihzdHJpbmdGb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGggPSAxNjM4NDtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdGb3JtYXQgPSBzdHJpbmdGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlclt0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID49IHRoaXMubGF0ZXN0QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2godGhpcy5sYXRlc3RCdWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoKys7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXRCRSh2YWx1ZSwgMCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRG91YmxlQkUodmFsdWUsIDApO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZywgbGVuZ3RoRnVuYykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0cmluZywgJ3V0Zi04Jyk7XG4gICAgICAgICAgICBsZW5ndGhGdW5jKGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLmNhbldyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQnVmZmVyO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGJ1ZmZlciwgbGVuZ3RoRnVuYykge1xuICAgICAgICAgICAgbGVuZ3RoRnVuYyhidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgaWYgKCEoY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlcldyaXRlciBvbmx5IGFjY2VwdHMgQnVmZmVycycpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXRlc3RCdWZmZXIubGVuZ3RoIC0gdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPj1cbiAgICAgICAgICAgICAgICBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5jb3B5KHRoaXMubGF0ZXN0QnVmZmVyLCB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA+PSB0aGlzLmxhdGVzdEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMucHVzaCh0aGlzLmxhdGVzdEJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKHRoaXMubGF0ZXN0QnVmZmVyLnNsaWNlKDAsIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5kZWZhdWx0QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2ModGhpcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBsZXRlQnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmNvbXBsZXRlQnVmZmVyc1tpXTtcbiAgICAgICAgICAgICAgICBidWZmZXIuY29weShyZXN1bHQsIG9mZnNldCwgMCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlci5jb3B5KHJlc3VsdCwgb2Zmc2V0LCAwLCB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJpbmdGb3JtYXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZyh0aGlzLnN0cmluZ0Zvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXBpLmFkZFJlYWRlcihmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2hleCcgfHwgZm9ybWF0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFwaS5hZGRXcml0ZXIoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9ybWF0IHx8IGZvcm1hdCA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSAnaGV4JyB8fCBmb3JtYXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gSGV4UmVhZGVyKGhleCkge1xuICAgICAgICAgICAgdGhpcy5oZXggPSBoZXg7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgSGV4UmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEhleFJlYWRlci5wcm90b3R5cGUucGVla0J5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHRoaXMuaGV4LnN1YnN0cmluZyh0aGlzLnBvcywgMik7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQocGFpciwgMTYpO1xuICAgICAgICB9O1xuICAgICAgICBIZXhSZWFkZXIucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLmhleC5zdWJzdHJpbmcodGhpcy5wb3MsIHRoaXMucG9zICsgMik7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhaXIsIDE2KTtcbiAgICAgICAgfTtcbiAgICAgICAgSGV4UmVhZGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaGV4ID0gdGhpcy5oZXguc3Vic3RyaW5nKHRoaXMucG9zLCB0aGlzLnBvcyArIGxlbmd0aCAqIDIpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoICogMjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5SGV4KGhleCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIEhleFdyaXRlcihmaW5hbEZvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy4kaGV4ID0gJyc7XG4gICAgICAgICAgICB0aGlzLmZpbmFsRm9ybWF0ID0gZmluYWxGb3JtYXQgfHwgJ2hleCc7XG4gICAgICAgIH1cbiAgICAgICAgSGV4V3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSk7XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMjU1KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnl0ZSB2YWx1ZSBvdXQgb2YgcmFuZ2U6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGhleCArPSBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUuY2FuV3JpdGVCaW5hcnkgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiAoY2h1bmsgaW5zdGFuY2VvZiBCaW5hcnlIZXggfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikpO1xuICAgICAgICB9O1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLndyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGNodW5rLCBsZW5ndGhGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgQmluYXJ5SGV4KSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoRnVuY3Rpb24oY2h1bmsubGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGhleCArPSBjaHVuay4kaGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGxlbmd0aEZ1bmN0aW9uKGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaGV4ICs9IGNodW5rLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hleFdyaXRlciBvbmx5IGFjY2VwdHMgQmluYXJ5SGV4IG9yIEJ1ZmZlcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgSGV4V3JpdGVyLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbEZvcm1hdCA9PT0gJ2J1ZmZlcicgJiYgdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLiRoZXgsICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5SGV4KHRoaXMuJGhleCkudG9TdHJpbmcodGhpcy5maW5hbEZvcm1hdCk7XG4gICAgICAgIH07XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nLCBsZW5ndGhGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJpbmFyeUhleC5mcm9tVXRmOFN0cmluZyhzdHJpbmcpO1xuICAgICAgICAgICAgbGVuZ3RoRnVuY3Rpb24oYnVmZmVyLmxlbmd0aCgpKTtcbiAgICAgICAgICAgIHRoaXMuJGhleCArPSBidWZmZXIuJGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgYXBpLmFkZFJlYWRlcihmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJpbmFyeUhleCB8fCBkYXRhLiRoZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhleFJlYWRlcihkYXRhLiRoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhleFJlYWRlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5hZGRXcml0ZXIoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhleFdyaXRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9KSgpO1xuICAgIENCT1IuYWRkU2VtYW50aWNFbmNvZGUoMCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmFkZFNlbWFudGljRGVjb2RlKDAsIGZ1bmN0aW9uIChpc29TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGlzb1N0cmluZyk7XG4gICAgfSlcbiAgICAgICAgLmFkZFNlbWFudGljRGVjb2RlKDEsIGZ1bmN0aW9uIChpc29TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGlzb1N0cmluZyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIENCT1I7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNib3Itc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YUl0ZW0gPSBleHBvcnRzLmFkZFdyaXRlciA9IGV4cG9ydHMuYWRkUmVhZGVyID0gZXhwb3J0cy5hZGRTZW1hbnRpY0VuY29kZSA9IGV4cG9ydHMuYWRkU2VtYW50aWNEZWNvZGUgPSBleHBvcnRzLmRlY29kZVRvRGF0YUl0ZW0gPSBleHBvcnRzLmVuY29kZURhdGFJdGVtID0gdm9pZCAwO1xudmFyIGNib3Jfc3luY18xID0gcmVxdWlyZShcIi4vY2Jvci1zeW5jXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNib3Jfc3luY18xLmVuY29kZURhdGFJdGVtOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlVG9EYXRhSXRlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuZGVjb2RlVG9EYXRhSXRlbTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFNlbWFudGljRGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5hZGRTZW1hbnRpY0RlY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFNlbWFudGljRW5jb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5hZGRTZW1hbnRpY0VuY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFJlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkUmVhZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkV3JpdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5hZGRXcml0ZXI7IH0gfSk7XG52YXIgRGF0YUl0ZW1fMSA9IHJlcXVpcmUoXCIuL0RhdGFJdGVtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGFJdGVtXzEuRGF0YUl0ZW07IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgU2NyaXB0RXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vU2NyaXB0RXhwcmVzc2lvblwiKTtcbmNvbnN0IHJlZ2lzdHJ5VGFncyA9IE9iamVjdC52YWx1ZXMoUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcylcbiAgICAuZmlsdGVyKChyKSA9PiAhIXIuZ2V0VGFnKCkpXG4gICAgLm1hcCgocikgPT4gci5nZXRUYWcoKSk7XG5jb25zdCBzY3JpcHRFeHByZXNzaW9uVGFncyA9IE9iamVjdC52YWx1ZXMoU2NyaXB0RXhwcmVzc2lvbl8xLlNjcmlwdEV4cHJlc3Npb25zKS5tYXAoKHNlKSA9PiBzZS5nZXRUYWcoKSk7XG4oMCwgdXRpbHNfMS5wYXRjaFRhZ3MpKHJlZ2lzdHJ5VGFncy5jb25jYXQoc2NyaXB0RXhwcmVzc2lvblRhZ3MpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGNoQ0JPUi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXRjaFRhZ3MgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IGFscmVhZHlQYXRjaGVkVGFnID0gW107XG5jb25zdCBwYXRjaFRhZ3MgPSAodGFncykgPT4ge1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgIGlmIChhbHJlYWR5UGF0Y2hlZFRhZy5maW5kKChpKSA9PiBpID09PSB0YWcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoMCwgbGliXzEuYWRkU2VtYW50aWNFbmNvZGUpKHRhZywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgbGliXzEuRGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5nZXRUYWcoKSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgbGliXzEuYWRkU2VtYW50aWNEZWNvZGUpKHRhZywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0oZGF0YSwgdGFnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFscmVhZHlQYXRjaGVkVGFnLnB1c2godGFnKTtcbiAgICB9KTtcbn07XG5leHBvcnRzLnBhdGNoVGFncyA9IHBhdGNoVGFncztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wb3NlZFN0b3JlID0gdm9pZCAwO1xuY29uc3QgT2JzZXJ2YWJsZVN0b3JlXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIik7XG5jbGFzcyBDb21wb3NlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgICAgICAvLyBUeXBlY2FzdDogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkS2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2NoaWxkS2V5XTtcbiAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZyb21DaGlsZCA9IChjaGlsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHN0YXRlW2NoaWxkS2V5XSA9IGNoaWxkVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKHVwZGF0ZUZyb21DaGlsZCk7XG4gICAgICAgIHVwZGF0ZUZyb21DaGlsZChjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSBDb21wb3NlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcG9zZWRTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIE1lcmdlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fYWRkQ2hpbGQoY2hpbGQpKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2hvbGVTdGF0ZSgpO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKSk7XG4gICAgfVxuICAgIF91cGRhdGVXaG9sZVN0YXRlKCkge1xuICAgICAgICBjb25zdCBjaGlsZFN0YXRlcyA9IHRoaXMuX2NoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBhcHBseSBzaGFsbG93IG1lcmdlIG92ZXIgc3RhdGVzXG4gICAgICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uY2hpbGRTdGF0ZXMpO1xuICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICB9XG59XG5leHBvcnRzLk1lcmdlZFN0b3JlID0gTWVyZ2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXJnZWRTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2JzZXJ2YWJsZVN0b3JlID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlIGV4dGVuZHMgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoaW5pdFN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChpbml0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gaW5pdFN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHlwZWNhc3QvZGVmYXVsdCBzdGF0ZTogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgZ2V0U3RhdGVcbiAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7XG4gICAgfVxuICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIHB1dFN0YXRlXG4gICAgcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcHV0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ld1N0YXRlKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUocGFydGlhbFN0YXRlKSB7XG4gICAgICAgIC8vIGlmIG5vbi1udWxsIG9iamVjdCwgbWVyZ2VcbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAmJiB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCBwYXJ0aWFsU3RhdGUpKTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdW5zdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IE9ic2VydmFibGVTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZVN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Iob2JzU3RvcmUpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLy8gcGFzcyB2YWx1ZXMsIG5vdCBzZXJpYWxpemF0aW9uc1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgLy8gc2F2ZSBoYW5kbGVyIHNvIHdlIGNhbiB1bnN1YnNjcmliZSBsYXRlclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSAoc3RhdGUpID0+IHRoaXMucHVzaChzdGF0ZSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMub2JzU3RvcmUgPSBvYnNTdG9yZTtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gZW1pdCBjdXJyZW50IHN0YXRlIG9uIG5ldyBkZXN0aW5hdGlvblxuICAgIHBpcGUoZGVzdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5waXBlKGRlc3QsIG9wdGlvbnMpO1xuICAgICAgICBkZXN0LndyaXRlKHRoaXMub2JzU3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHdyaXRlIGZyb20gaW5jb21pbmcgc3RyZWFtIHRvIHN0YXRlXG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBub29wIC0gb3V0Z29pbmcgc3RyZWFtIGlzIGFza2luZyB1cyBpZiB3ZSBoYXZlIGRhdGEgd2UgYXJlbnQgZ2l2aW5nIGl0XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBldmVudCBlbWl0dGVyXG4gICAgX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnVuc3Vic2NyaWJlKHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHN1cGVyLl9kZXN0cm95KGVyciwgY2FsbGJhY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0b3JlQXNTdHJlYW0ob2JzU3RvcmUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdG9yZVN0cmVhbShvYnNTdG9yZSk7XG59XG5leHBvcnRzLnN0b3JlQXNTdHJlYW0gPSBzdG9yZUFzU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc1N0cmVhbVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTWVyZ2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHRocm91Z2gyXzEgPSByZXF1aXJlKFwidGhyb3VnaDJcIik7XG5mdW5jdGlvbiBzdG9yZVRyYW5zZm9ybVN0cmVhbShzeW5jVHJhbnNmb3JtRm4pIHtcbiAgICByZXR1cm4gdGhyb3VnaDJfMS5vYmooKHN0YXRlLCBfZW5jb2RpbmcsIGNiKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN5bmNUcmFuc2Zvcm1GbihzdGF0ZSk7XG4gICAgICAgICAgICBjYihudWxsLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gc3RvcmVUcmFuc2Zvcm1TdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxuICAsIGluaGVyaXRzICA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuICAsIHh0ZW5kICAgICA9IHJlcXVpcmUoJ3h0ZW5kJylcblxuZnVuY3Rpb24gRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0cykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRzKVxuICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhEZXN0cm95YWJsZVRyYW5zZm9ybSwgVHJhbnNmb3JtKVxuXG5EZXN0cm95YWJsZVRyYW5zZm9ybS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICBcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVycilcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gIH0pXG59XG5cbi8vIGEgbm9vcCBfdHJhbnNmb3JtIGZ1bmN0aW9uXG5mdW5jdGlvbiBub29wIChjaHVuaywgZW5jLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCBjaHVuaylcbn1cblxuXG4vLyBjcmVhdGUgYSBuZXcgZXhwb3J0IGZ1bmN0aW9uLCB1c2VkIGJ5IGJvdGggdGhlIG1haW4gZXhwb3J0IGFuZFxuLy8gdGhlIC5jdG9yIGV4cG9ydCwgY29udGFpbnMgY29tbW9uIGxvZ2ljIGZvciBkZWFsaW5nIHdpdGggYXJndW1lbnRzXG5mdW5jdGlvbiB0aHJvdWdoMiAoY29uc3RydWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbHVzaCAgICAgPSB0cmFuc2Zvcm1cbiAgICAgIHRyYW5zZm9ybSA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgICA9IHt9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRyYW5zZm9ybSA9IG5vb3BcblxuICAgIGlmICh0eXBlb2YgZmx1c2ggIT0gJ2Z1bmN0aW9uJylcbiAgICAgIGZsdXNoID0gbnVsbFxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKVxuICB9XG59XG5cblxuLy8gbWFpbiBleHBvcnQsIGp1c3QgbWFrZSBtZSBhIHRyYW5zZm9ybSBzdHJlYW0hXG5tb2R1bGUuZXhwb3J0cyA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRpb25zKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG5cblxuLy8gbWFrZSBtZSBhIHJldXNhYmxlIHByb3RvdHlwZSB0aGF0IEkgY2FuIGBuZXdgLCBvciBpbXBsaWNpdGx5IGBuZXdgXG4vLyB3aXRoIGEgY29uc3RydWN0b3IgY2FsbFxubW9kdWxlLmV4cG9ydHMuY3RvciA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIGZ1bmN0aW9uIFRocm91Z2gyIChvdmVycmlkZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaHJvdWdoMikpXG4gICAgICByZXR1cm4gbmV3IFRocm91Z2gyKG92ZXJyaWRlKVxuXG4gICAgdGhpcy5vcHRpb25zID0geHRlbmQob3B0aW9ucywgb3ZlcnJpZGUpXG5cbiAgICBEZXN0cm95YWJsZVRyYW5zZm9ybS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGluaGVyaXRzKFRocm91Z2gyLCBEZXN0cm95YWJsZVRyYW5zZm9ybSlcblxuICBUaHJvdWdoMi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICBUaHJvdWdoMi5wcm90b3R5cGUuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gVGhyb3VnaDJcbn0pXG5cblxubW9kdWxlLmV4cG9ydHMub2JqID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKHh0ZW5kKHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogMTYgfSwgb3B0aW9ucykpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzQm9va0NvbnRyb2xsZXIgPSBleHBvcnRzLkFkZHJlc3NUeXBlID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcl91dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9jb250cm9sbGVyLXV0aWxzXCIpO1xuY29uc3QgYmFzZV9jb250cm9sbGVyXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2Jhc2UtY29udHJvbGxlclwiKTtcbnZhciBBZGRyZXNzVHlwZTtcbihmdW5jdGlvbiAoQWRkcmVzc1R5cGUpIHtcbiAgICBBZGRyZXNzVHlwZVtcImV4dGVybmFsbHlPd25lZEFjY291bnRzXCJdID0gXCJFWFRFUk5BTExZX09XTkVEX0FDQ09VTlRTXCI7XG4gICAgQWRkcmVzc1R5cGVbXCJjb250cmFjdEFjY291bnRzXCJdID0gXCJDT05UUkFDVF9BQ0NPVU5UU1wiO1xuICAgIEFkZHJlc3NUeXBlW1wibm9uQWNjb3VudHNcIl0gPSBcIk5PTl9BQ0NPVU5UU1wiO1xufSkoQWRkcmVzc1R5cGUgPSBleHBvcnRzLkFkZHJlc3NUeXBlIHx8IChleHBvcnRzLkFkZHJlc3NUeXBlID0ge30pKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IG1hbmFnZXMgYSBsaXN0IG9mIHJlY2lwaWVudCBhZGRyZXNzZXMgYXNzb2NpYXRlZCB3aXRoIG5pY2tuYW1lcy5cbiAqL1xuY2xhc3MgQWRkcmVzc0Jvb2tDb250cm9sbGVyIGV4dGVuZHMgYmFzZV9jb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQWRkcmVzc0Jvb2tDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0FkZHJlc3NCb29rQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0geyBhZGRyZXNzQm9vazoge30gfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgY29udHJhY3QgZW50cmllcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBhZGRyZXNzQm9vazoge30gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNvbnRyYWN0IGVudHJ5IGJ5IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIGlkIGlkZW50aWZpZXMgdGhlIGN1cnJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBSZWNpcGllbnQgYWRkcmVzcyB0byBkZWxldGUuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZW50cnkgd2FzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGNoYWluSWQsIGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBpZiAoISgwLCBjb250cm9sbGVyX3V0aWxzXzEuaXNWYWxpZEhleEFkZHJlc3MpKGFkZHJlc3MpIHx8XG4gICAgICAgICAgICAhdGhpcy5zdGF0ZS5hZGRyZXNzQm9va1tjaGFpbklkXSB8fFxuICAgICAgICAgICAgIXRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF1bYWRkcmVzc10pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzQm9vayA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWRkcmVzc0Jvb2spO1xuICAgICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbY2hhaW5JZF1bYWRkcmVzc107XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhZGRyZXNzQm9va1tjaGFpbklkXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbY2hhaW5JZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyBhZGRyZXNzQm9vayB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBvciB1cGRhdGUgYSBjb250YWN0IGVudHJ5IGJ5IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIFJlY2lwaWVudCBhZGRyZXNzIHRvIGFkZCBvciB1cGRhdGUuXG4gICAgICogQHBhcmFtIG5hbWUgLSBOaWNrbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBpZCBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGNoYWluLlxuICAgICAqIEBwYXJhbSBtZW1vIC0gVXNlcidzIG5vdGUgYWJvdXQgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gYWRkcmVzc1R5cGUgLSBDb250YWN0J3MgYWRkcmVzcyB0eXBlLlxuICAgICAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgYWRkcmVzcyB3YXMgc3VjY2Vzc2Z1bGx5IHNldC5cbiAgICAgKi9cbiAgICBzZXQoYWRkcmVzcywgbmFtZSwgY2hhaW5JZCA9ICcxJywgbWVtbyA9ICcnLCBhZGRyZXNzVHlwZSkge1xuICAgICAgICBhZGRyZXNzID0gKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgIGlmICghKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5pc1ZhbGlkSGV4QWRkcmVzcykoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgaXNFbnM6IGZhbHNlLFxuICAgICAgICAgICAgbWVtbyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhZGRyZXNzVHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5zTmFtZSA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEubm9ybWFsaXplRW5zTmFtZSkobmFtZSk7XG4gICAgICAgIGlmIChlbnNOYW1lKSB7XG4gICAgICAgICAgICBlbnRyeS5uYW1lID0gZW5zTmFtZTtcbiAgICAgICAgICAgIGVudHJ5LmlzRW5zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzQm9vazogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rKSwgeyBbY2hhaW5JZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5hZGRyZXNzQm9va1tjaGFpbklkXSksIHsgW2FkZHJlc3NdOiBlbnRyeSB9KSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzc0Jvb2tDb250cm9sbGVyID0gQWRkcmVzc0Jvb2tDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWRkcmVzc0Jvb2tDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWRkcmVzc0Jvb2tDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQWRkcmVzc0Jvb2tDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Fubm91bmNlbWVudENvbnRyb2xsZXJfaW5zdGFuY2VzLCBfQW5ub3VuY2VtZW50Q29udHJvbGxlcl9hZGRBbm5vdW5jZW1lbnRzO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bbm5vdW5jZW1lbnRDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgYmFzZV9jb250cm9sbGVyXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2Jhc2UtY29udHJvbGxlclwiKTtcbmNvbnN0IGNvbnRyb2xsZXJOYW1lID0gJ0Fubm91bmNlbWVudENvbnRyb2xsZXInO1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIGFubm91bmNlbWVudHM6IHt9LFxufTtcbmNvbnN0IG1ldGFkYXRhID0ge1xuICAgIGFubm91bmNlbWVudHM6IHtcbiAgICAgICAgcGVyc2lzdDogdHJ1ZSxcbiAgICAgICAgYW5vbnltb3VzOiB0cnVlLFxuICAgIH0sXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIGZvciBtYW5hZ2luZyBpbi1hcHAgYW5ub3VuY2VtZW50cy5cbiAqL1xuY2xhc3MgQW5ub3VuY2VtZW50Q29udHJvbGxlciBleHRlbmRzIGJhc2VfY29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyVjIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBBbm5vdW5jZW1lbnRDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGFyZ3MubWVzc2VuZ2VyIC0gTWVzc2VuZ2VyIHVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCBCYXNlVjIgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gYXJncy5zdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gYXJncy5hbGxBbm5vdW5jZW1lbnRzIC0gQW5ub3VuY2VtZW50cyB0byBiZSBwYXNzZWQgdGhyb3VnaCB0byAjYWRkQW5ub3VuY2VtZW50c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2VuZ2VyLCBzdGF0ZSwgYWxsQW5ub3VuY2VtZW50cywgfSkge1xuICAgICAgICBjb25zdCBtZXJnZWRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN0YXRlKSwgc3RhdGUpO1xuICAgICAgICBzdXBlcih7IG1lc3NlbmdlciwgbWV0YWRhdGEsIG5hbWU6IGNvbnRyb2xsZXJOYW1lLCBzdGF0ZTogbWVyZ2VkU3RhdGUgfSk7XG4gICAgICAgIF9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fubm91bmNlbWVudENvbnRyb2xsZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fubm91bmNlbWVudENvbnRyb2xsZXJfYWRkQW5ub3VuY2VtZW50cykuY2FsbCh0aGlzLCBhbGxBbm5vdW5jZW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc3RhdHVzIG9mIHRoZSBzdGF0dXMgb2YgdGhlIHNwZWNpZmllZCBhbm5vdW5jZW1lbnRzXG4gICAgICogb25jZSBpdCBpcyByZWFkIGJ5IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpZXdlZElkcyAtIFRoZSBhbm5vdW5jZW1lbnQgSURzIHRvIG1hcmsgYXMgdmlld2VkLlxuICAgICAqL1xuICAgIHVwZGF0ZVZpZXdlZCh2aWV3ZWRJZHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHsgYW5ub3VuY2VtZW50cyB9KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHZpZXdlZElkcykubWFwKE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBhbm5vdW5jZW1lbnRzW2lkXS5pc1Nob3duID0gdmlld2VkSWRzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Bbm5vdW5jZW1lbnRDb250cm9sbGVyID0gQW5ub3VuY2VtZW50Q29udHJvbGxlcjtcbl9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2FkZEFubm91bmNlbWVudHMgPSBmdW5jdGlvbiBfQW5ub3VuY2VtZW50Q29udHJvbGxlcl9hZGRBbm5vdW5jZW1lbnRzKGFsbEFubm91bmNlbWVudHMpIHtcbiAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhhbGxBbm5vdW5jZW1lbnRzKS5mb3JFYWNoKChhbm5vdW5jZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHN0YXRlLmFubm91bmNlbWVudHNbYW5ub3VuY2VtZW50LmlkXSA9IChfYSA9IHN0YXRlLmFubm91bmNlbWVudHNbYW5ub3VuY2VtZW50LmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbm5vdW5jZW1lbnQpLCB7IGlzU2hvd246IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bbm5vdW5jZW1lbnRDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQW5ub3VuY2VtZW50Q29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBwcm92YWxDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IGJhc2VfY29udHJvbGxlcl8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9iYXNlLWNvbnRyb2xsZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGNvbnRyb2xsZXJOYW1lID0gJ0FwcHJvdmFsQ29udHJvbGxlcic7XG5jb25zdCBzdGF0ZU1ldGFkYXRhID0ge1xuICAgIHBlbmRpbmdBcHByb3ZhbHM6IHsgcGVyc2lzdDogZmFsc2UsIGFub255bW91czogdHJ1ZSB9LFxuICAgIHBlbmRpbmdBcHByb3ZhbENvdW50OiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG59O1xuY29uc3QgZ2V0QWxyZWFkeVBlbmRpbmdNZXNzYWdlID0gKG9yaWdpbiwgdHlwZSkgPT4gYFJlcXVlc3Qgb2YgdHlwZSAnJHt0eXBlfScgYWxyZWFkeSBwZW5kaW5nIGZvciBvcmlnaW4gJHtvcmlnaW59LiBQbGVhc2Ugd2FpdC5gO1xuY29uc3QgZ2V0RGVmYXVsdFN0YXRlID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBlbmRpbmdBcHByb3ZhbHM6IHt9LFxuICAgICAgICBwZW5kaW5nQXBwcm92YWxDb3VudDogMCxcbiAgICB9O1xufTtcbi8qKlxuICogQ29udHJvbGxlciBmb3IgbWFuYWdpbmcgcmVxdWVzdHMgdGhhdCByZXF1aXJlIHVzZXIgYXBwcm92YWwuXG4gKlxuICogRW5hYmxlcyBsaW1pdGluZyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVxdWVzdHMgYnkgb3JpZ2luIGFuZCB0eXBlLCBjb3VudGluZ1xuICogcGVuZGluZyByZXF1ZXN0cywgYW5kIG1vcmUuXG4gKlxuICogQWRkaW5nIGEgcmVxdWVzdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgd2hlbiB0aGUgcmVxdWVzdFxuICogaXMgYXBwcm92ZWQgb3IgZGVuaWVkLCByZXNwZWN0aXZlbHkuXG4gKi9cbmNsYXNzIEFwcHJvdmFsQ29udHJvbGxlciBleHRlbmRzIGJhc2VfY29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyVjIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBBcHByb3ZhbCBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNob3dBcHByb3ZhbFJlcXVlc3QgLSBGdW5jdGlvbiBmb3Igb3BlbmluZyB0aGUgVUkgc3VjaCB0aGF0XG4gICAgICogdGhlIHJlcXVlc3QgY2FuIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXNzZW5nZXIgLSBUaGUgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlciBmb3IgdGhlIEFwcHJvdmFsIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RhdGUgLSBUaGUgaW5pdGlhbCBjb250cm9sbGVyIHN0YXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnR5cGVzRXhjbHVkZWRGcm9tUmF0ZUxpbWl0aW5nIC0gQXJyYXkgb2YgYXByb3ZhbCB0eXBlcyB3aGljaCBhbGxvdyBtdWx0aXBsZSBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3RzIGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2VuZ2VyLCBzaG93QXBwcm92YWxSZXF1ZXN0LCBzdGF0ZSA9IHt9LCB0eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZyA9IFtdLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6IGNvbnRyb2xsZXJOYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXRlTWV0YWRhdGEsXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXREZWZhdWx0U3RhdGUoKSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FwcHJvdmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fb3JpZ2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2hvd0FwcHJvdmFsUmVxdWVzdCA9IHNob3dBcHByb3ZhbFJlcXVlc3Q7XG4gICAgICAgIHRoaXMuX3R5cGVzRXhjbHVkZWRGcm9tUmF0ZUxpbWl0aW5nID0gdHlwZXNFeGNsdWRlZEZyb21SYXRlTGltaXRpbmc7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgaGVscGVyIGZvciByZWdpc3RlcmluZyB0aGlzIGNvbnRyb2xsZXIncyBtZXNzYWdpbmcgc3lzdGVtXG4gICAgICogYWN0aW9ucy5cbiAgICAgKi9cbiAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpjbGVhclJlcXVlc3RzYCwgdGhpcy5jbGVhci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTphZGRSZXF1ZXN0YCwgKG9wdHMsIHNob3VsZFNob3dSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2hvd1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpoYXNSZXF1ZXN0YCwgdGhpcy5oYXMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06YWNjZXB0UmVxdWVzdGAsIHRoaXMuYWNjZXB0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OnJlamVjdFJlcXVlc3RgLCB0aGlzLnJlamVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTp1cGRhdGVSZXF1ZXN0U3RhdGVgLCB0aGlzLnVwZGF0ZVJlcXVlc3RTdGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBhcHByb3ZhbCByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gYXJndW1lbnRzLCBjYWxscyB0aGUgc2hvdyBhcHByb3ZhbFxuICAgICAqIHJlcXVlc3QgZnVuY3Rpb24sIGFuZCByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgYXBwcm92YWwgcGVyIG9yaWdpbiBhbmQgdHlwZS4gQW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gICAgICogYXR0ZW1wdGluZyB0byBhZGQgYW4gaW52YWxpZCBvciBkdXBsaWNhdGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuIEEgcmFuZG9tIGlkIHdpbGwgYmVcbiAgICAgKiBnZW5lcmF0ZWQgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5vcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMucmVxdWVzdERhdGEgLSBBZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0LFxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3RTdGF0ZSAtIEFkZGl0aW9uYWwgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0LFxuICAgICAqIGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92YWwgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBhZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2FkZChvcHRzLm9yaWdpbiwgb3B0cy50eXBlLCBvcHRzLmlkLCBvcHRzLnJlcXVlc3REYXRhLCBvcHRzLnJlcXVlc3RTdGF0ZSk7XG4gICAgICAgIHRoaXMuX3Nob3dBcHByb3ZhbFJlcXVlc3QoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgYXBwcm92YWxcbiAgICAgKiBwcm9taXNlLlxuICAgICAqXG4gICAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGFwcHJvdmFsIHBlciBvcmlnaW4gYW5kIHR5cGUuIEFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIGF0dGVtcHRpbmcgdG8gYWRkIGFuIGludmFsaWQgb3IgZHVwbGljYXRlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LiBBIHJhbmRvbSBpZCB3aWxsIGJlXG4gICAgICogZ2VuZXJhdGVkIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3REYXRhIC0gQWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCxcbiAgICAgKiBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgYWRkKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZChvcHRzLm9yaWdpbiwgb3B0cy50eXBlLCBvcHRzLmlkLCBvcHRzLnJlcXVlc3REYXRhLCBvcHRzLnJlcXVlc3RTdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZm8gZm9yIHRoZSBhcHByb3ZhbCByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCByZXF1ZXN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBpZC5cbiAgICAgKi9cbiAgICBnZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFsc1tpZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBwZW5kaW5nIGFwcHJvdmFscywgYnkgb3JpZ2luIGFuZC9vciB0eXBlLlxuICAgICAqXG4gICAgICogSWYgb25seSBgb3JpZ2luYCBpcyBzcGVjaWZpZWQsIGFsbCBhcHByb3ZhbHMgZm9yIHRoYXQgb3JpZ2luIHdpbGwgYmVcbiAgICAgKiBjb3VudGVkLCByZWdhcmRsZXNzIG9mIHR5cGUuXG4gICAgICogSWYgb25seSBgdHlwZWAgaXMgc3BlY2lmaWVkLCBhbGwgYXBwcm92YWxzIGZvciB0aGF0IHR5cGUgd2lsbCBiZSBjb3VudGVkLFxuICAgICAqIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luLlxuICAgICAqIElmIGJvdGggYG9yaWdpbmAgYW5kIGB0eXBlYCBhcmUgc3BlY2lmaWVkLCAwIG9yIDEgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gVGhlIGFwcHJvdmFsIGNvdW50IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gQW4gYXBwcm92YWwgb3JpZ2luLlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBhcHByb3ZhbCByZXF1ZXN0IGNvdW50IGZvciB0aGUgZ2l2ZW4gb3JpZ2luIGFuZC9vclxuICAgICAqIHR5cGUuXG4gICAgICovXG4gICAgZ2V0QXBwcm92YWxDb3VudChvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIW9wdHMub3JpZ2luICYmICFvcHRzLnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IG9yaWdpbiwgdHlwZSwgb3IgYm90aC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9yaWdpbiwgdHlwZTogX3R5cGUgfSA9IG9wdHM7XG4gICAgICAgIGlmIChvcmlnaW4gJiYgX3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChfdHlwZSkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oKHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikgfHwgbmV3IE1hcCgpKS52YWx1ZXMoKSkucmVkdWNlKCh0b3RhbCwgdmFsdWUpID0+IHRvdGFsICsgdmFsdWUsIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgXCJ0eXBlXCIgd2FzIHNwZWNpZmllZFxuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGFwcHJvdmFsIG9mIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzKSkge1xuICAgICAgICAgICAgaWYgKGFwcHJvdmFsLnR5cGUgPT09IF90eXBlKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdG90YWwgY291bnQgb2YgYWxsIHBlbmRpbmcgYXBwcm92YWwgcmVxdWVzdHMgZm9yIGFsbCBvcmlnaW5zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIHBlbmRpbmcgYXBwcm92YWwgcmVxdWVzdCBjb3VudC5cbiAgICAgKi9cbiAgICBnZXRUb3RhbEFwcHJvdmFsQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbENvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlcmUncyBhIHBlbmRpbmcgYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAgICogQXQgbGVhc3Qgb25lIHBhcmFtZXRlciBtdXN0IGJlIHNwZWNpZmllZC4gQW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgdGhlXG4gICAgICogcGFyYW1ldGVycyBhcmUgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIElmIGBpZGAgaXMgc3BlY2lmaWVkLCBhbGwgb3RoZXIgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogSWYgYGlkYCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbWV0aG9kIHdpbGwgY2hlY2sgZm9yIHJlcXVlc3RzIHRoYXQgbWF0Y2hcbiAgICAgKiBhbGwgb2YgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCAtIFRoZSBJRCB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIG9wdHMudHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYSBtYXRjaGluZyBhcHByb3ZhbCBpcyBmb3VuZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGhhcyhvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGlkLCBvcmlnaW4sIHR5cGU6IF90eXBlIH0gPSBvcHRzO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXkgbm90IHNwZWNpZnkgbm9uLXN0cmluZyBpZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHByb3ZhbHMuaGFzKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGUgJiYgdHlwZW9mIF90eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXkgbm90IHNwZWNpZnkgbm9uLXN0cmluZyB0eXBlLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgb3JpZ2luLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgb3JpZ2luIGFuZCB0eXBlIHBhaXIgaWYgdHlwZSBhbHNvIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKF90eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oKF9hID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChfdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbnMuaGFzKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFwcHJvdmFsIG9mIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzKSkge1xuICAgICAgICAgICAgICAgIGlmIChhcHByb3ZhbC50eXBlID09PSBfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgYSB2YWxpZCBjb21iaW5hdGlvbiBvZiBpZCwgb3JpZ2luLCBhbmQgdHlwZS4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHByb21pc2Ugb2YgdGhlIGFwcHJvdmFsIHdpdGggdGhlIGdpdmVuIGlkLCBhbmQgZGVsZXRlcyB0aGVcbiAgICAgKiBhcHByb3ZhbC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggYXBwcm92YWwgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXNvbHZlIHRoZSBhcHByb3ZhbCBwcm9taXNlIHdpdGguXG4gICAgICovXG4gICAgYWNjZXB0KGlkLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyhpZCkucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgdGhlIHByb21pc2Ugb2YgdGhlIGFwcHJvdmFsIHdpdGggdGhlIGdpdmVuIGlkLCBhbmQgZGVsZXRlcyB0aGVcbiAgICAgKiBhcHByb3ZhbC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggYXBwcm92YWwgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byByZWplY3QgdGhlIGFwcHJvdmFsIHByb21pc2Ugd2l0aC5cbiAgICAgKi9cbiAgICByZWplY3QoaWQsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzKGlkKS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGFuZCBkZWxldGVzIGFsbCBhcHByb3ZhbCByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWplY3Rpb25FcnJvciAtIFRoZSBFdGhlcmV1bVJwY0Vycm9yIHRvIHJlamVjdCB0aGUgYXBwcm92YWxcbiAgICAgKiByZXF1ZXN0cyB3aXRoLlxuICAgICAqL1xuICAgIGNsZWFyKHJlamVjdGlvbkVycm9yKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5fYXBwcm92YWxzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoaWQsIHJlamVjdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcmlnaW5zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCgpID0+IGdldERlZmF1bHRTdGF0ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVxdWVzdCBzdGF0ZSBvZiB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3RTdGF0ZSAtIEFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKi9cbiAgICB1cGRhdGVSZXF1ZXN0U3RhdGUob3B0cykge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFsc1tvcHRzLmlkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3Iob3B0cy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiB0cygyNTg5KVxuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW29wdHMuaWRdLnJlcXVlc3RTdGF0ZSA9XG4gICAgICAgICAgICAgICAgb3B0cy5yZXF1ZXN0U3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBhZGQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0RGF0YSAtIFRoZSByZXF1ZXN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0U3RhdGUgLSBUaGUgcmVxdWVzdCBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgX2FkZChvcmlnaW4sIHR5cGUsIGlkID0gKDAsIG5hbm9pZF8xLm5hbm9pZCkoKSwgcmVxdWVzdERhdGEsIHJlcXVlc3RTdGF0ZSkge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUFkZFBhcmFtcyhpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSwgcmVxdWVzdFN0YXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZy5pbmNsdWRlcyh0eXBlKSAmJlxuICAgICAgICAgICAgdGhpcy5oYXMoeyBvcmlnaW4sIHR5cGUgfSkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlKGdldEFscmVhZHlQZW5kaW5nTWVzc2FnZShvcmlnaW4sIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgcGVuZGluZyBhcHByb3ZhbFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXBwcm92YWxzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRQZW5kaW5nQXBwcm92YWxPcmlnaW4ob3JpZ2luLCB0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvU3RvcmUoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEsIHJlcXVlc3RTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcGFyYW1ldGVycyB0byB0aGUgYWRkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBUaGUgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFN0YXRlIC0gVGhlIHJlcXVlc3Qgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF92YWxpZGF0ZUFkZFBhcmFtcyhpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSwgcmVxdWVzdFN0YXRlKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBpZiAoIWlkIHx8IHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdNdXN0IHNwZWNpZnkgbm9uLWVtcHR5IHN0cmluZyBpZC4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2FwcHJvdmFscy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQXBwcm92YWwgcmVxdWVzdCB3aXRoIGlkICcke2lkfScgYWxyZWFkeSBleGlzdHMuYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3JpZ2luIHx8IHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgb3JpZ2luLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgdHlwZS4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3REYXRhICYmXG4gICAgICAgICAgICAodHlwZW9mIHJlcXVlc3REYXRhICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHJlcXVlc3REYXRhKSkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdSZXF1ZXN0IGRhdGEgbXVzdCBiZSBhIHBsYWluIG9iamVjdCBpZiBzcGVjaWZpZWQuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0U3RhdGUgJiZcbiAgICAgICAgICAgICh0eXBlb2YgcmVxdWVzdFN0YXRlICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHJlcXVlc3RTdGF0ZSkpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnUmVxdWVzdCBzdGF0ZSBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0IGlmIHNwZWNpZmllZC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50cnkgdG8gX29yaWdpbnMuXG4gICAgICogUGVyZm9ybXMgbm8gdmFsaWRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF9hZGRQZW5kaW5nQXBwcm92YWxPcmlnaW4ob3JpZ2luLCB0eXBlKSB7XG4gICAgICAgIGxldCBvcmlnaW5NYXAgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pO1xuICAgICAgICBpZiAoIW9yaWdpbk1hcCkge1xuICAgICAgICAgICAgb3JpZ2luTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2lucy5zZXQob3JpZ2luLCBvcmlnaW5NYXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG9yaWdpbk1hcC5nZXQodHlwZSkgfHwgMDtcbiAgICAgICAgb3JpZ2luTWFwLnNldCh0eXBlLCBjdXJyZW50VmFsdWUgKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbnRyeSB0byB0aGUgc3RvcmUuXG4gICAgICogUGVyZm9ybXMgbm8gdmFsaWRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBUaGUgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFN0YXRlIC0gVGhlIHJlcXVlc3Qgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF9hZGRUb1N0b3JlKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhLCByZXF1ZXN0U3RhdGUpIHtcbiAgICAgICAgY29uc3QgYXBwcm92YWwgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcmVxdWVzdERhdGE6IHJlcXVlc3REYXRhIHx8IG51bGwsXG4gICAgICAgICAgICByZXF1ZXN0U3RhdGU6IHJlcXVlc3RTdGF0ZSB8fCBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IHRzKDI1ODkpXG4gICAgICAgICAgICBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdID0gYXBwcm92YWw7XG4gICAgICAgICAgICBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbENvdW50ID0gT2JqZWN0LmtleXMoZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzKS5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZC4gVGhlIGFwcHJvdmFsIHByb21pc2UgbXVzdCBiZVxuICAgICAqIHJlc29sdmVkIG9yIHJlamVjdCBiZWZvcmUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAqIERlbGV0aW9uIGlzIGFuIGludGVybmFsIG9wZXJhdGlvbiBiZWNhdXNlIGFwcHJvdmFsIHN0YXRlIGlzIHNvbGVseVxuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgX2RlbGV0ZShpZCkge1xuICAgICAgICB0aGlzLl9hcHByb3ZhbHMuZGVsZXRlKGlkKTtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgb25seSBjYWxsZWQgYWZ0ZXIgdmVyaWZ5aW5nIHRoYXQgdGhlIGFwcHJvdmFsIHdpdGggdGhlXG4gICAgICAgIC8vIHNwZWNpZmllZCBpZCBleGlzdHMuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHsgb3JpZ2luLCB0eXBlIH0gPSB0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgICAgICBjb25zdCBvcmlnaW5NYXAgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pO1xuICAgICAgICBjb25zdCBvcmlnaW5Ub3RhbENvdW50ID0gdGhpcy5nZXRBcHByb3ZhbENvdW50KHsgb3JpZ2luIH0pO1xuICAgICAgICBjb25zdCBvcmlnaW5UeXBlQ291bnQgPSBvcmlnaW5NYXAuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAob3JpZ2luVG90YWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2lucy5kZWxldGUob3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbk1hcC5zZXQodHlwZSwgb3JpZ2luVHlwZUNvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudCA9IE9iamVjdC5rZXlzKGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFscykubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm92YWwgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaWQsIGRlbGV0ZXMgdGhlIGVudHJ5LCBhbmQgdGhlblxuICAgICAqIHJldHVybnMgdGhlIGNhbGxiYWNrcyBmb3IgcHJvbWlzZSByZXNvbHV0aW9uLlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBubyBhcHByb3ZhbCBpcyBmb3VuZCBmb3IgdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIGNhbGxiYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICovXG4gICAgX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzKGlkKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2FwcHJvdmFscy5nZXQoaWQpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3IoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbGV0ZShpZCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFja3M7XG4gICAgfVxufVxuZXhwb3J0cy5BcHByb3ZhbENvbnRyb2xsZXIgPSBBcHByb3ZhbENvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBBcHByb3ZhbENvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHByb3ZhbENvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBBcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgICAgIHN1cGVyKGBBcHByb3ZhbCByZXF1ZXN0IHdpdGggaWQgJyR7aWR9JyBub3QgZm91bmQuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5BcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yID0gQXBwcm92YWxSZXF1ZXN0Tm90Rm91bmRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0FwcHJvdmFsQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImxldCB7IHVybEFscGhhYmV0IH0gPSByZXF1aXJlKCcuL3VybC1hbHBoYWJldC9pbmRleC5janMnKVxubGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxubGV0IGN1c3RvbVJhbmRvbSA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUsIGdldFJhbmRvbSkgPT4ge1xuICBsZXQgbWFzayA9ICgyIDw8IChNYXRoLmxvZyhhbHBoYWJldC5sZW5ndGggLSAxKSAvIE1hdGguTE4yKSkgLSAxXG4gIGxldCBzdGVwID0gLX4oKDEuNiAqIG1hc2sgKiBkZWZhdWx0U2l6ZSkgLyBhbHBoYWJldC5sZW5ndGgpXG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IGJ5dGVzID0gZ2V0UmFuZG9tKHN0ZXApXG4gICAgICBsZXQgaiA9IHN0ZXBcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgaWQgKz0gYWxwaGFiZXRbYnl0ZXNbal0gJiBtYXNrXSB8fCAnJ1xuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSBzaXplKSByZXR1cm4gaWRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgc2l6ZSA9IDIxKSA9PlxuICBjdXN0b21SYW5kb20oYWxwaGFiZXQsIHNpemUsIHJhbmRvbSlcbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PlxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKS5yZWR1Y2UoKGlkLCBieXRlKSA9PiB7XG4gICAgYnl0ZSAmPSA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlID4gNjIpIHtcbiAgICAgIGlkICs9ICctJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnXydcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH0sICcnKVxubW9kdWxlLmV4cG9ydHMgPSB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQsIGN1c3RvbVJhbmRvbSwgdXJsQWxwaGFiZXQsIHJhbmRvbSB9XG4iLCJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbm1vZHVsZS5leHBvcnRzID0geyB1cmxBbHBoYWJldCB9XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVTYWx0ID0gZXhwb3J0cy5zZXJpYWxpemVCdWZmZXJGb3JTdG9yYWdlID0gZXhwb3J0cy5zZXJpYWxpemVCdWZmZXJGcm9tU3RvcmFnZSA9IGV4cG9ydHMua2V5RnJvbVBhc3N3b3JkID0gZXhwb3J0cy5leHBvcnRLZXkgPSBleHBvcnRzLmltcG9ydEtleSA9IGV4cG9ydHMuZGVjcnlwdFdpdGhLZXkgPSBleHBvcnRzLmRlY3J5cHRXaXRoRGV0YWlsID0gZXhwb3J0cy5kZWNyeXB0ID0gZXhwb3J0cy5lbmNyeXB0V2l0aEtleSA9IGV4cG9ydHMuZW5jcnlwdFdpdGhEZXRhaWwgPSBleHBvcnRzLmVuY3J5cHQgPSB2b2lkIDA7XG5jb25zdCBFWFBPUlRfRk9STUFUID0gJ2p3ayc7XG5jb25zdCBERVJJVkVEX0tFWV9GT1JNQVQgPSAnQUVTLUdDTSc7XG5jb25zdCBTVFJJTkdfRU5DT0RJTkcgPSAndXRmLTgnO1xuLyoqXG4gKiBFbmNyeXB0cyBhIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIGFueSBzZXJpYWxpemFibGUgdmFsdWUgdXNpbmdcbiAqIGEgcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIHRvIHVzZSBmb3IgZW5jcnlwdGlvbi5cbiAqIEBwYXJhbSBkYXRhT2JqIC0gVGhlIGRhdGEgdG8gZW5jcnlwdC5cbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGVuY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBzYWx0IC0gVGhlIHNhbHQgdG8gdXNlIHRvIGVuY3J5cHQuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIHZhdWx0LlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHBhc3N3b3JkLCBkYXRhT2JqLCBrZXksIHNhbHQgPSBnZW5lcmF0ZVNhbHQoKSkge1xuICAgIGNvbnN0IGNyeXB0b0tleSA9IGtleSB8fCAoYXdhaXQga2V5RnJvbVBhc3N3b3JkKHBhc3N3b3JkLCBzYWx0KSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IGVuY3J5cHRXaXRoS2V5KGNyeXB0b0tleSwgZGF0YU9iaik7XG4gICAgcGF5bG9hZC5zYWx0ID0gc2FsdDtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5leHBvcnRzLmVuY3J5cHQgPSBlbmNyeXB0O1xuLyoqXG4gKiBFbmNyeXB0cyBhIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIGFueSBzZXJpYWxpemFibGUgdmFsdWUgdXNpbmdcbiAqIGEgcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIHBhc3N3b3JkIC0gQSBwYXNzd29yZCB0byB1c2UgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gZGF0YU9iaiAtIFRoZSBkYXRhIHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gc2FsdCAtIFRoZSBzYWx0IHVzZWQgdG8gZW5jcnlwdC5cbiAqIEByZXR1cm5zIFRoZSB2YXVsdCBhbmQgZXhwb3J0ZWQga2V5IHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFdpdGhEZXRhaWwocGFzc3dvcmQsIGRhdGFPYmosIHNhbHQgPSBnZW5lcmF0ZVNhbHQoKSkge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCwgdHJ1ZSk7XG4gICAgY29uc3QgZXhwb3J0ZWRLZXlTdHJpbmcgPSBhd2FpdCBleHBvcnRLZXkoa2V5KTtcbiAgICBjb25zdCB2YXVsdCA9IGF3YWl0IGVuY3J5cHQocGFzc3dvcmQsIGRhdGFPYmosIGtleSwgc2FsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmF1bHQsXG4gICAgICAgIGV4cG9ydGVkS2V5U3RyaW5nLFxuICAgIH07XG59XG5leHBvcnRzLmVuY3J5cHRXaXRoRGV0YWlsID0gZW5jcnlwdFdpdGhEZXRhaWw7XG4vKipcbiAqIEVuY3J5cHRzIHRoZSBwcm92aWRlZCBzZXJpYWxpemFibGUgamF2YXNjcmlwdCBvYmplY3QgdXNpbmcgdGhlXG4gKiBwcm92aWRlZCBDcnlwdG9LZXkgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN5cGhlciB0ZXh0IGFuZFxuICogdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB1c2VkLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGVuY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBkYXRhT2JqIC0gQSBzZXJpYWxpemFibGUgSmF2YVNjcmlwdCBvYmplY3QgdG8gZW5jcnlwdC5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFdpdGhLZXkoa2V5LCBkYXRhT2JqKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGFPYmopO1xuICAgIGNvbnN0IGRhdGFCdWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCBTVFJJTkdfRU5DT0RJTkcpO1xuICAgIGNvbnN0IHZlY3RvciA9IGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgZ2xvYmFsLmNyeXB0by5zdWJ0bGUuZW5jcnlwdCh7XG4gICAgICAgIG5hbWU6IERFUklWRURfS0VZX0ZPUk1BVCxcbiAgICAgICAgaXY6IHZlY3RvcixcbiAgICB9LCBrZXksIGRhdGFCdWZmZXIpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgY29uc3QgdmVjdG9yU3RyID0gQnVmZmVyLmZyb20odmVjdG9yKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgdmF1bHRTdHIgPSBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB2YXVsdFN0cixcbiAgICAgICAgaXY6IHZlY3RvclN0cixcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNyeXB0V2l0aEtleSA9IGVuY3J5cHRXaXRoS2V5O1xuLyoqXG4gKiBHaXZlbiBhIHBhc3N3b3JkIGFuZCBhIGN5cGhlciB0ZXh0LCBkZWNyeXB0cyB0aGUgdGV4dCBhbmQgcmV0dXJuc1xuICogdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoLlxuICogQHBhcmFtIHRleHQgLSBUaGUgY3lwaGVyIHRleHQgdG8gZGVjcnlwdC5cbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgZGF0YS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChwYXNzd29yZCwgdGV4dCwga2V5KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgY29uc3QgeyBzYWx0IH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IGNyeXB0b0tleSA9IGtleSB8fCAoYXdhaXQga2V5RnJvbVBhc3N3b3JkKHBhc3N3b3JkLCBzYWx0KSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVjcnlwdFdpdGhLZXkoY3J5cHRvS2V5LCBwYXlsb2FkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWNyeXB0ID0gZGVjcnlwdDtcbi8qKlxuICogR2l2ZW4gYSBwYXNzd29yZCBhbmQgYSBjeXBoZXIgdGV4dCwgZGVjcnlwdHMgdGhlIHRleHQgYW5kIHJldHVybnNcbiAqIHRoZSByZXN1bHRpbmcgdmFsdWUsIGtleVN0cmluZywgYW5kIHNhbHQuXG4gKlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSB0ZXh0IC0gVGhlIGVuY3J5cHRlZCB2YXVsdCB0byBkZWNyeXB0LlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCB2YXVsdCBhbG9uZyB3aXRoIHRoZSBzYWx0IGFuZCBleHBvcnRlZCBrZXkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRXaXRoRGV0YWlsKHBhc3N3b3JkLCB0ZXh0KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgY29uc3QgeyBzYWx0IH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCwgdHJ1ZSk7XG4gICAgY29uc3QgZXhwb3J0ZWRLZXlTdHJpbmcgPSBhd2FpdCBleHBvcnRLZXkoa2V5KTtcbiAgICBjb25zdCB2YXVsdCA9IGF3YWl0IGRlY3J5cHQocGFzc3dvcmQsIHRleHQsIGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhwb3J0ZWRLZXlTdHJpbmcsXG4gICAgICAgIHZhdWx0LFxuICAgICAgICBzYWx0LFxuICAgIH07XG59XG5leHBvcnRzLmRlY3J5cHRXaXRoRGV0YWlsID0gZGVjcnlwdFdpdGhEZXRhaWw7XG4vKipcbiAqIEdpdmVuIGEgQ3J5cHRvS2V5IGFuZCBhbiBFbmNyeXB0aW9uUmVzdWx0IG9iamVjdCBjb250YWluaW5nIHRoZSBpbml0aWFsaXphdGlvblxuICogdmVjdG9yIChpdikgYW5kIGRhdGEgdG8gZGVjcnlwdCwgcmV0dXJuIHRoZSByZXN1bHRpbmcgZGVjcnlwdGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgdG8gZGVjcnlwdCwgcmV0dXJuZWQgZnJvbSBhbiBlbmNyeXB0aW9uIG1ldGhvZC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgZGF0YS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdFdpdGhLZXkoa2V5LCBwYXlsb2FkKSB7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuZGF0YSwgJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHZlY3RvciA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuaXYsICdiYXNlNjQnKTtcbiAgICBsZXQgZGVjcnlwdGVkT2JqO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdCh7IG5hbWU6IERFUklWRURfS0VZX0ZPUk1BVCwgaXY6IHZlY3RvciB9LCBrZXksIGVuY3J5cHRlZERhdGEpO1xuICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkU3RyID0gQnVmZmVyLmZyb20oZGVjcnlwdGVkRGF0YSkudG9TdHJpbmcoU1RSSU5HX0VOQ09ESU5HKTtcbiAgICAgICAgZGVjcnlwdGVkT2JqID0gSlNPTi5wYXJzZShkZWNyeXB0ZWRTdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZCcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjcnlwdGVkT2JqO1xufVxuZXhwb3J0cy5kZWNyeXB0V2l0aEtleSA9IGRlY3J5cHRXaXRoS2V5O1xuLyoqXG4gKiBSZWNlaXZlcyBhbiBleHBvcnRlZCBDcnlwdG9LZXkgc3RyaW5nIGFuZCBjcmVhdGVzIGEga2V5LlxuICpcbiAqIEBwYXJhbSBrZXlTdHJpbmcgLSBUaGUga2V5IHN0cmluZyB0byBpbXBvcnQuXG4gKiBAcmV0dXJucyBBIENyeXB0b0tleS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0S2V5KGtleVN0cmluZykge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShFWFBPUlRfRk9STUFULCBKU09OLnBhcnNlKGtleVN0cmluZyksIERFUklWRURfS0VZX0ZPUk1BVCwgdHJ1ZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydHMuaW1wb3J0S2V5ID0gaW1wb3J0S2V5O1xuLyoqXG4gKiBSZWNlaXZlcyBhbiBleHBvcnRlZCBDcnlwdG9LZXkgc3RyaW5nLCBjcmVhdGVzIGEga2V5LFxuICogYW5kIGRlY3J5cHRzIGNpcGhlciB0ZXh0IHdpdGggdGhlIHJlY29uc3RydWN0ZWQga2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGV4cG9ydC5cbiAqIEByZXR1cm5zIEEga2V5IHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhwb3J0S2V5KGtleSkge1xuICAgIGNvbnN0IGV4cG9ydGVkS2V5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KEVYUE9SVF9GT1JNQVQsIGtleSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGV4cG9ydGVkS2V5KTtcbn1cbmV4cG9ydHMuZXhwb3J0S2V5ID0gZXhwb3J0S2V5O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIENyeXB0b0tleSBmcm9tIGEgcGFzc3dvcmQgYW5kIHJhbmRvbSBzYWx0LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCB0byB1c2UgdG8gZ2VuZXJhdGUga2V5LlxuICogQHBhcmFtIHNhbHQgLSBUaGUgc2FsdCBzdHJpbmcgdG8gdXNlIGluIGtleSBkZXJpdmF0aW9uLlxuICogQHBhcmFtIGV4cG9ydGFibGUgLSBTaG91bGQgdGhlIGRlcml2ZWQga2V5IGJlIGV4cG9ydGFibGUuXG4gKiBAcmV0dXJucyBBIENyeXB0b0tleSBmb3IgZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24ga2V5RnJvbVBhc3N3b3JkKHBhc3N3b3JkLCBzYWx0LCBleHBvcnRhYmxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBwYXNzQnVmZmVyID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsIFNUUklOR19FTkNPRElORyk7XG4gICAgY29uc3Qgc2FsdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNhbHQsICdiYXNlNjQnKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBnbG9iYWwuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHBhc3NCdWZmZXIsIHsgbmFtZTogJ1BCS0RGMicgfSwgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgY29uc3QgZGVyaXZlZEtleSA9IGF3YWl0IGdsb2JhbC5jcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7XG4gICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICBzYWx0OiBzYWx0QnVmZmVyLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwMCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgIH0sIGtleSwgeyBuYW1lOiBERVJJVkVEX0tFWV9GT1JNQVQsIGxlbmd0aDogMjU2IH0sIGV4cG9ydGFibGUsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIHJldHVybiBkZXJpdmVkS2V5O1xufVxuZXhwb3J0cy5rZXlGcm9tUGFzc3dvcmQgPSBrZXlGcm9tUGFzc3dvcmQ7XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyBpbnRvIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBIZXggZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIGVjb2RlZCBhcyBhIGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlckZyb21TdG9yYWdlKHN0cikge1xuICAgIGNvbnN0IHN0cmlwU3RyID0gc3RyLnNsaWNlKDAsIDIpID09PSAnMHgnID8gc3RyLnNsaWNlKDIpIDogc3RyO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHN0cmlwU3RyLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaXBTdHIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3Qgc2VnID0gc3RyaXBTdHIuc3Vic3RyKGksIDIpO1xuICAgICAgICBidWZbaSAvIDJdID0gcGFyc2VJbnQoc2VnLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5leHBvcnRzLnNlcmlhbGl6ZUJ1ZmZlckZyb21TdG9yYWdlID0gc2VyaWFsaXplQnVmZmVyRnJvbVN0b3JhZ2U7XG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIGludG8gYSBoZXggc3RyaW5nIHJlYWR5IGZvciBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBCdWZmZXIgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgQSBoZXggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlckZvclN0b3JhZ2UoYnVmZmVyKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcweCc7XG4gICAgYnVmZmVyLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSB1bnByZWZpeGVkSGV4KHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zZXJpYWxpemVCdWZmZXJGb3JTdG9yYWdlID0gc2VyaWFsaXplQnVmZmVyRm9yU3RvcmFnZTtcbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgaW50byBoZXggdmFsdWUsIGFuZCBlbnN1cmVzIHByb3BlciBsZWFkaW5nIDBcbiAqIGZvciBzaW5nbGUgY2hhcmFjdGVycyBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSBudW0gLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gc3RyaW5nLlxuICogQHJldHVybnMgQW4gdW5wcmVmaXhlZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiB1bnByZWZpeGVkSGV4KG51bSkge1xuICAgIGxldCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgMikge1xuICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzdHJpbmcgZm9yIHVzZSBhcyBhIHNhbHQgaW4gQ3J5cHRvS2V5IGdlbmVyYXRpb24uXG4gKlxuICogQHBhcmFtIGJ5dGVDb3VudCAtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyBBIHJhbmRvbWx5IGdlbmVyYXRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2FsdChieXRlQ291bnQgPSAzMikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShieXRlQ291bnQpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHZpZXcpO1xuICAgIC8vIFVpbnQ4QXJyYXkgaXMgYSBmaXhlZCBsZW5ndGggYXJyYXkgYW5kIHRodXMgZG9lcyBub3QgaGF2ZSBtZXRob2RzIGxpa2UgcG9wLCBldGNcbiAgICAvLyBzbyBUeXBlU2NyaXB0IGNvbXBsYWlucyBhYm91dCBjYXN0aW5nIGl0IHRvIGFuIGFycmF5LiBBcnJheS5mcm9tKCkgd29ya3MgaGVyZSBmb3JcbiAgICAvLyBnZXR0aW5nIHRoZSBwcm9wZXIgdHlwZSwgYnV0IGl0IHJlc3VsdHMgaW4gYSBmdW5jdGlvbmFsIGRpZmZlcmVuY2UuIEluIG9yZGVyIHRvXG4gICAgLy8gY2FzdCwgeW91IGhhdmUgdG8gZmlyc3QgY2FzdCB2aWV3IHRvIHVua25vd24gdGhlbiBjYXN0IHRoZSB1bmtub3duIHZhbHVlIHRvIG51bWJlcltdXG4gICAgLy8gVHlwZVNjcmlwdCBmdHc6IGRvdWJsZSBvcHQgaW4gdG8gd3JpdGUgcG90ZW50aWFsbHkgdHlwZS1taXNtYXRjaGVkIGNvZGUuXG4gICAgY29uc3QgYjY0ZW5jb2RlZCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB2aWV3KSk7XG4gICAgcmV0dXJuIGI2NGVuY29kZWQ7XG59XG5leHBvcnRzLmdlbmVyYXRlU2FsdCA9IGdlbmVyYXRlU2FsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImNvbnN0IHsgSERLZXkgfSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9oZGtleScpO1xuY29uc3QgeyBrZWNjYWsyNTYgfSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnKTtcbmNvbnN0IHsgYnl0ZXNUb0hleCB9ID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzJyk7XG5jb25zdCB7XG4gIHN0cmlwSGV4UHJlZml4LFxuICBwcml2YXRlVG9QdWJsaWMsXG4gIHB1YmxpY1RvQWRkcmVzcyxcbiAgZWNzaWduLFxuICBhcnJUb0J1ZkFycixcbiAgYnVmZmVyVG9IZXgsXG59ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdXRpbCcpO1xuY29uc3QgYmlwMzkgPSByZXF1aXJlKCdAbWV0YW1hc2svc2N1cmUtYmlwMzknKTtcbmNvbnN0IHsgd29yZGxpc3QgfSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9zY3VyZS1iaXAzOS9kaXN0L3dvcmRsaXN0cy9lbmdsaXNoJyk7XG5jb25zdCB7XG4gIGNvbmNhdFNpZyxcbiAgZGVjcnlwdCxcbiAgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSxcbiAgbm9ybWFsaXplLFxuICBwZXJzb25hbFNpZ24sXG4gIHNpZ25UeXBlZERhdGEsXG4gIFNpZ25UeXBlZERhdGFWZXJzaW9uLFxufSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9ldGgtc2lnLXV0aWwnKTtcblxuLy8gT3B0aW9uczpcbmNvbnN0IGhkUGF0aFN0cmluZyA9IGBtLzQ0Jy82MCcvMCcvMGA7XG5jb25zdCB0eXBlID0gJ0hEIEtleSBUcmVlJztcblxuY2xhc3MgSGRLZXlyaW5nIHtcbiAgLyogUFVCTElDIE1FVEhPRFMgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLl93YWxsZXRzID0gW107XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgfVxuXG4gIGdlbmVyYXRlUmFuZG9tTW5lbW9uaWMoKSB7XG4gICAgdGhpcy5faW5pdEZyb21NbmVtb25pYyhiaXAzOS5nZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0KSk7XG4gIH1cblxuICBfdWludDhBcnJheVRvU3RyaW5nKG1uZW1vbmljKSB7XG4gICAgY29uc3QgcmVjb3ZlcmVkSW5kaWNlcyA9IEFycmF5LmZyb20oXG4gICAgICBuZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkobW5lbW9uaWMpLmJ1ZmZlciksXG4gICAgKTtcbiAgICByZXR1cm4gcmVjb3ZlcmVkSW5kaWNlcy5tYXAoKGkpID0+IHdvcmRsaXN0W2ldKS5qb2luKCcgJyk7XG4gIH1cblxuICBfc3RyaW5nVG9VaW50OEFycmF5KG1uZW1vbmljKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IG1uZW1vbmljLnNwbGl0KCcgJykubWFwKCh3b3JkKSA9PiB3b3JkbGlzdC5pbmRleE9mKHdvcmQpKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KGluZGljZXMpLmJ1ZmZlcik7XG4gIH1cblxuICBfbW5lbW9uaWNUb1VpbnQ4QXJyYXkobW5lbW9uaWMpIHtcbiAgICBsZXQgbW5lbW9uaWNEYXRhID0gbW5lbW9uaWM7XG4gICAgLy8gd2hlbiBlbmNyeXB0ZWQvZGVjcnlwdGVkLCBidWZmZXJzIGdldCBjYXN0IGludG8ganMgb2JqZWN0IHdpdGggYSBwcm9wZXJ0eSB0eXBlIHNldCB0byBidWZmZXJcbiAgICBpZiAobW5lbW9uaWMgJiYgbW5lbW9uaWMudHlwZSAmJiBtbmVtb25pYy50eXBlID09PSAnQnVmZmVyJykge1xuICAgICAgbW5lbW9uaWNEYXRhID0gbW5lbW9uaWMuZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAvLyB0aGlzIGJsb2NrIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHZhdWx0cyB0aGF0IHdlcmUgcHJldmlvdXNseSBzdG9yZWQgYXMgYnVmZmVycywgbnVtYmVyIGFycmF5cyBvciBwbGFpbiB0ZXh0IHN0cmluZ3NcbiAgICAgIHR5cGVvZiBtbmVtb25pY0RhdGEgPT09ICdzdHJpbmcnIHx8XG4gICAgICBCdWZmZXIuaXNCdWZmZXIobW5lbW9uaWNEYXRhKSB8fFxuICAgICAgQXJyYXkuaXNBcnJheShtbmVtb25pY0RhdGEpXG4gICAgKSB7XG4gICAgICBsZXQgbW5lbW9uaWNBc1N0cmluZyA9IG1uZW1vbmljRGF0YTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1uZW1vbmljRGF0YSkpIHtcbiAgICAgICAgbW5lbW9uaWNBc1N0cmluZyA9IEJ1ZmZlci5mcm9tKG1uZW1vbmljRGF0YSkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG1uZW1vbmljRGF0YSkpIHtcbiAgICAgICAgbW5lbW9uaWNBc1N0cmluZyA9IG1uZW1vbmljRGF0YS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N0cmluZ1RvVWludDhBcnJheShtbmVtb25pY0FzU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbW5lbW9uaWNEYXRhIGluc3RhbmNlb2YgT2JqZWN0ICYmXG4gICAgICAhKG1uZW1vbmljRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgKSB7XG4gICAgICAvLyB3aGVuIGVuY3J5cHRlZC9kZWNyeXB0ZWQgdGhlIFVpbnQ4QXJyYXkgYmVjb21lcyBhIGpzIG9iamVjdCB3ZSBuZWVkIHRvIGNhc3QgYmFjayB0byBhIFVpbnQ4QXJyYXlcbiAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhtbmVtb25pY0RhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1uZW1vbmljRGF0YTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBtbmVtb25pY0FzU3RyaW5nID0gdGhpcy5fdWludDhBcnJheVRvU3RyaW5nKHRoaXMubW5lbW9uaWMpO1xuICAgIGNvbnN0IHVpbnQ4QXJyYXlNbmVtb25pYyA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKS5lbmNvZGUoXG4gICAgICBtbmVtb25pY0FzU3RyaW5nLFxuICAgICk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIG1uZW1vbmljOiBBcnJheS5mcm9tKHVpbnQ4QXJyYXlNbmVtb25pYyksXG4gICAgICBudW1iZXJPZkFjY291bnRzOiB0aGlzLl93YWxsZXRzLmxlbmd0aCxcbiAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgfSk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZShvcHRzID0ge30pIHtcbiAgICBpZiAob3B0cy5udW1iZXJPZkFjY291bnRzICYmICFvcHRzLm1uZW1vbmljKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdGgtSGQtS2V5cmluZzogRGVzZXJpYWxpemUgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBvcHRzIHZhbHVlIGZvciBudW1iZXJPZkFjY291bnRzIGFuZCBubyBtZW5tb25pYycsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0V0aC1IZC1LZXlyaW5nOiBTZWNyZXQgcmVjb3ZlcnkgcGhyYXNlIGFscmVhZHkgcHJvdmlkZWQnLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLl93YWxsZXRzID0gW107XG4gICAgdGhpcy5tbmVtb25pYyA9IG51bGw7XG4gICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoIHx8IGhkUGF0aFN0cmluZztcblxuICAgIGlmIChvcHRzLm1uZW1vbmljKSB7XG4gICAgICB0aGlzLl9pbml0RnJvbU1uZW1vbmljKG9wdHMubW5lbW9uaWMpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm51bWJlck9mQWNjb3VudHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZEFjY291bnRzKG9wdHMubnVtYmVyT2ZBY2NvdW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cblxuICBhZGRBY2NvdW50cyhudW1iZXJPZkFjY291bnRzID0gMSkge1xuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aC1IZC1LZXlyaW5nOiBObyBzZWNyZXQgcmVjb3ZlcnkgcGhyYXNlIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkTGVuID0gdGhpcy5fd2FsbGV0cy5sZW5ndGg7XG4gICAgY29uc3QgbmV3V2FsbGV0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBvbGRMZW47IGkgPCBudW1iZXJPZkFjY291bnRzICsgb2xkTGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMucm9vdC5kZXJpdmVDaGlsZChpKTtcbiAgICAgIG5ld1dhbGxldHMucHVzaCh3YWxsZXQpO1xuICAgICAgdGhpcy5fd2FsbGV0cy5wdXNoKHdhbGxldCk7XG4gICAgfVxuICAgIGNvbnN0IGhleFdhbGxldHMgPSBuZXdXYWxsZXRzLm1hcCgodykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3Nmcm9tUHVibGljS2V5KHcucHVibGljS2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleFdhbGxldHMpO1xuICB9XG5cbiAgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHMubWFwKCh3KSA9PiB0aGlzLl9hZGRyZXNzZnJvbVB1YmxpY0tleSh3LnB1YmxpY0tleSkpO1xuICB9XG5cbiAgLyogQkFTRSBLRVlSSU5HIE1FVEhPRFMgKi9cblxuICAvLyByZXR1cm5zIGFuIGFkZHJlc3Mgc3BlY2lmaWMgdG8gYW4gYXBwXG4gIGFzeW5jIGdldEFwcEtleUFkZHJlc3MoYWRkcmVzcywgb3JpZ2luKSB7XG4gICAgaWYgKCFvcmlnaW4gfHwgdHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29yaWdpbicgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdgKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudChhZGRyZXNzLCB7XG4gICAgICB3aXRoQXBwS2V5T3JpZ2luOiBvcmlnaW4sXG4gICAgfSk7XG4gICAgY29uc3QgYXBwS2V5QWRkcmVzcyA9IG5vcm1hbGl6ZShcbiAgICAgIHB1YmxpY1RvQWRkcmVzcyh3YWxsZXQucHVibGljS2V5KS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcblxuICAgIHJldHVybiBhcHBLZXlBZGRyZXNzO1xuICB9XG5cbiAgLy8gZXhwb3J0QWNjb3VudCBzaG91bGQgcmV0dXJuIGEgaGV4LWVuY29kZWQgcHJpdmF0ZSBrZXk6XG4gIGFzeW5jIGV4cG9ydEFjY291bnQoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudChhZGRyZXNzLCBvcHRzKTtcbiAgICByZXR1cm4gYnl0ZXNUb0hleCh3YWxsZXQucHJpdmF0ZUtleSk7XG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKTtcbiAgICBjb25zdCBzaWduZWRUeCA9IHR4LnNpZ24ocHJpdktleSk7XG4gICAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgRXRoZXJldW1qcy10eCBhcmUgaW1tdXRhYmxlIGFuZCByZXR1cm4gYSBuZXcgdHggb2JqZWN0XG4gICAgcmV0dXJuIHNpZ25lZFR4ID09PSB1bmRlZmluZWQgPyB0eCA6IHNpZ25lZFR4O1xuICB9XG5cbiAgLy8gRm9yIGV0aF9zaWduLCB3ZSBuZWVkIHRvIHNpZ24gYXJiaXRyYXJ5IGRhdGE6XG4gIGFzeW5jIHNpZ25NZXNzYWdlKGFkZHJlc3MsIGRhdGEsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKTtcbiAgICBjb25zdCBtc2dTaWcgPSBlY3NpZ24oQnVmZmVyLmZyb20obWVzc2FnZSwgJ2hleCcpLCBwcml2S2V5KTtcbiAgICBjb25zdCByYXdNc2dTaWcgPSBjb25jYXRTaWcobXNnU2lnLnYsIG1zZ1NpZy5yLCBtc2dTaWcucyk7XG4gICAgcmV0dXJuIHJhd01zZ1NpZztcbiAgfVxuXG4gIC8vIEZvciBwZXJzb25hbF9zaWduLCB3ZSBuZWVkIHRvIHByZWZpeCB0aGUgbWVzc2FnZTpcbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZShhZGRyZXNzLCBtc2dIZXgsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZLZXkgPSB0aGlzLl9nZXRQcml2YXRlS2V5Rm9yKGFkZHJlc3MsIG9wdHMpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBCdWZmZXIuZnJvbShwcml2S2V5LCAnaGV4Jyk7XG4gICAgY29uc3Qgc2lnID0gcGVyc29uYWxTaWduKHsgcHJpdmF0ZUtleSwgZGF0YTogbXNnSGV4IH0pO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvLyBGb3IgZXRoX2RlY3J5cHRNZXNzYWdlOlxuICBhc3luYyBkZWNyeXB0TWVzc2FnZSh3aXRoQWNjb3VudCwgZW5jcnlwdGVkRGF0YSkge1xuICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX2dldFdhbGxldEZvckFjY291bnQod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUFzVWludDhBcnJheSB9ID0gd2FsbGV0O1xuICAgIGNvbnN0IHByaXZhdGVLZXlBc0hleCA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXlBc1VpbnQ4QXJyYXkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBzaWcgPSBkZWNyeXB0KHsgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUFzSGV4LCBlbmNyeXB0ZWREYXRhIH0pO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvLyBwZXJzb25hbF9zaWduVHlwZWREYXRhLCBzaWducyBkYXRhIGFsb25nIHdpdGggdGhlIHNjaGVtYVxuICBhc3luYyBzaWduVHlwZWREYXRhKFxuICAgIHdpdGhBY2NvdW50LFxuICAgIHR5cGVkRGF0YSxcbiAgICBvcHRzID0geyB2ZXJzaW9uOiBTaWduVHlwZWREYXRhVmVyc2lvbi5WMSB9LFxuICApIHtcbiAgICAvLyBUcmVhdCBpbnZhbGlkIHZlcnNpb25zIGFzIFwiVjFcIlxuICAgIGNvbnN0IHZlcnNpb24gPSBPYmplY3Qua2V5cyhTaWduVHlwZWREYXRhVmVyc2lvbikuaW5jbHVkZXMob3B0cy52ZXJzaW9uKVxuICAgICAgPyBvcHRzLnZlcnNpb25cbiAgICAgIDogU2lnblR5cGVkRGF0YVZlcnNpb24uVjE7XG5cbiAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cyk7XG4gICAgcmV0dXJuIHNpZ25UeXBlZERhdGEoeyBwcml2YXRlS2V5LCBkYXRhOiB0eXBlZERhdGEsIHZlcnNpb24gfSk7XG4gIH1cblxuICByZW1vdmVBY2NvdW50KGFjY291bnQpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplKGFjY291bnQpO1xuICAgIGlmIChcbiAgICAgICF0aGlzLl93YWxsZXRzXG4gICAgICAgIC5tYXAoKHsgcHVibGljS2V5IH0pID0+IHRoaXMuX2FkZHJlc3Nmcm9tUHVibGljS2V5KHB1YmxpY0tleSkpXG4gICAgICAgIC5pbmNsdWRlcyhhZGRyZXNzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO1xuICAgIH1cblxuICAgIHRoaXMuX3dhbGxldHMgPSB0aGlzLl93YWxsZXRzLmZpbHRlcihcbiAgICAgICh7IHB1YmxpY0tleSB9KSA9PiB0aGlzLl9hZGRyZXNzZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpICE9PSBhZGRyZXNzLFxuICAgICk7XG4gIH1cblxuICAvLyBnZXQgcHVibGljIGtleSBmb3IgbmFjbFxuICBhc3luYyBnZXRFbmNyeXB0aW9uUHVibGljS2V5KHdpdGhBY2NvdW50LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cyk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0RW5jcnlwdGlvblB1YmxpY0tleShwcml2S2V5KTtcbiAgICByZXR1cm4gcHVibGljS2V5O1xuICB9XG5cbiAgX2dldFByaXZhdGVLZXlGb3IoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhZGRyZXNzLicpO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl9nZXRXYWxsZXRGb3JBY2NvdW50KGFkZHJlc3MsIG9wdHMpO1xuICAgIHJldHVybiB3YWxsZXQucHJpdmF0ZUtleTtcbiAgfVxuXG4gIF9nZXRXYWxsZXRGb3JBY2NvdW50KGFjY291bnQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemUoYWNjb3VudCk7XG4gICAgbGV0IHdhbGxldCA9IHRoaXMuX3dhbGxldHMuZmluZCgoeyBwdWJsaWNLZXkgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3Nmcm9tUHVibGljS2V5KHB1YmxpY0tleSkgPT09IGFkZHJlc3M7XG4gICAgfSk7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSEQgS2V5cmluZyAtIFVuYWJsZSB0byBmaW5kIG1hdGNoaW5nIGFkZHJlc3MuJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMud2l0aEFwcEtleU9yaWdpbikge1xuICAgICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSB3YWxsZXQ7XG4gICAgICBjb25zdCBhcHBLZXlPcmlnaW5CdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRzLndpdGhBcHBLZXlPcmlnaW4sICd1dGY4Jyk7XG4gICAgICBjb25zdCBhcHBLZXlCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtwcml2YXRlS2V5LCBhcHBLZXlPcmlnaW5CdWZmZXJdKTtcbiAgICAgIGNvbnN0IGFwcEtleVByaXZhdGVLZXkgPSBhcnJUb0J1ZkFycihrZWNjYWsyNTYoYXBwS2V5QnVmZmVyLCAyNTYpKTtcbiAgICAgIGNvbnN0IGFwcEtleVB1YmxpY0tleSA9IHByaXZhdGVUb1B1YmxpYyhhcHBLZXlQcml2YXRlS2V5KTtcbiAgICAgIHdhbGxldCA9IHsgcHJpdmF0ZUtleTogYXBwS2V5UHJpdmF0ZUtleSwgcHVibGljS2V5OiBhcHBLZXlQdWJsaWNLZXkgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2FsbGV0O1xuICB9XG5cbiAgLyogUFJJVkFURSAvIFVUSUxJVFkgTUVUSE9EUyAqL1xuXG4gIC8qKlxuICAgKiBTZXRzIGFwcHJvcHJpYXRlIHByb3BlcnRpZXMgZm9yIHRoZSBrZXlyaW5nIGJhc2VkIG9uIHRoZSBnaXZlblxuICAgKiBCSVAzOS1jb21wbGlhbnQgbW5lbW9uaWMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PG51bWJlcj58QnVmZmVyfSBtbmVtb25pYyAtIEEgc2VlZCBwaHJhc2UgcmVwcmVzZW50ZWRcbiAgICogYXMgYSBzdHJpbmcsIGFuIGFycmF5IG9mIFVURi04IGJ5dGVzLCBvciBhIEJ1ZmZlci4gTW5lbW9uaWMgaW5wdXRcbiAgICogcGFzc2VkIGFzIHR5cGUgYnVmZmVyIG9yIGFycmF5IG9mIFVURi04IGJ5dGVzIG11c3QgYmUgTkZLRCBub3JtYWxpemVkLlxuICAgKi9cbiAgX2luaXRGcm9tTW5lbW9uaWMobW5lbW9uaWMpIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdGgtSGQtS2V5cmluZzogU2VjcmV0IHJlY292ZXJ5IHBocmFzZSBhbHJlYWR5IHByb3ZpZGVkJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5tbmVtb25pYyA9IHRoaXMuX21uZW1vbmljVG9VaW50OEFycmF5KG1uZW1vbmljKTtcblxuICAgIC8vIHZhbGlkYXRlIGJlZm9yZSBpbml0aWFsaXppbmdcbiAgICBjb25zdCBpc1ZhbGlkID0gYmlwMzkudmFsaWRhdGVNbmVtb25pYyh0aGlzLm1uZW1vbmljLCB3b3JkbGlzdCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdGgtSGQtS2V5cmluZzogSW52YWxpZCBzZWNyZXQgcmVjb3ZlcnkgcGhyYXNlIHByb3ZpZGVkJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tc3luY1xuICAgIGNvbnN0IHNlZWQgPSBiaXAzOS5tbmVtb25pY1RvU2VlZFN5bmModGhpcy5tbmVtb25pYywgd29yZGxpc3QpO1xuICAgIHRoaXMuaGRXYWxsZXQgPSBIREtleS5mcm9tTWFzdGVyU2VlZChzZWVkKTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmhkV2FsbGV0LmRlcml2ZSh0aGlzLmhkUGF0aCk7XG4gIH1cblxuICAvLyBzbWFsbCBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBwdWJsaWNLZXkgaW4gVWludDhBcnJheSBmb3JtIHRvIGEgcHVibGljQWRkcmVzcyBhcyBhIGhleFxuICBfYWRkcmVzc2Zyb21QdWJsaWNLZXkocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIGJ1ZmZlclRvSGV4KFxuICAgICAgcHVibGljVG9BZGRyZXNzKEJ1ZmZlci5mcm9tKHB1YmxpY0tleSksIHRydWUpLFxuICAgICkudG9Mb3dlckNhc2UoKTtcbiAgfVxufVxuXG5IZEtleXJpbmcudHlwZSA9IHR5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IEhkS2V5cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVJbmZ1cmFNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IG5vZGVfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSk7XG5jb25zdCBmZXRjaF9jb25maWdfZnJvbV9yZXFfMSA9IHJlcXVpcmUoXCIuL2ZldGNoLWNvbmZpZy1mcm9tLXJlcVwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBsb2cgPSAoMCwgbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcikobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdjcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmUnKTtcbmNvbnN0IFJFVFJJQUJMRV9FUlJPUlMgPSBbXG4gICAgLy8gaWdub3JlIHNlcnZlciBvdmVybG9hZCBlcnJvcnNcbiAgICAnR2F0ZXdheSB0aW1lb3V0JyxcbiAgICAnRVRJTUVET1VUJyxcbiAgICAnRUNPTk5SRVNFVCcsXG4gICAgLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbiAgICAvLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcbiAgICAnU3ludGF4RXJyb3InLFxuXTtcbi8qKlxuICogQnVpbGRzIFtganNvbi1ycGMtZW5naW5lYF0oaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2pzb24tcnBjLWVuZ2luZSktY29tcGF0aWJsZSBtaWRkbGV3YXJlIGRlc2lnbmVkXG4gKiBmb3IgaW50ZXJmYWNpbmcgd2l0aCBJbmZ1cmEncyBKU09OLVJQQyBlbmRwb2ludHMuXG4gKlxuICogQHBhcmFtIG9wdHMgLSBUaGUgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRzLm5ldHdvcmsgLSBBIG5ldHdvcmsgdGhhdCBJbmZ1cmEgc3VwcG9ydHM7IHBsdWdzIGludG9cbiAqIGBodHRwczovLyR7bmV0d29ya30uaW5mdXJhLmlvYCAoZGVmYXVsdDogJ21haW5uZXQnKS5cbiAqIEBwYXJhbSBvcHRzLm1heEF0dGVtcHRzIC0gVGhlIG51bWJlciBvZiB0aW1lcyBhIHJlcXVlc3QgdG8gSW5mdXJhIHNob3VsZCBiZVxuICogcmV0cmllZCBpbiB0aGUgY2FzZSBvZiBmYWlsdXJlIChkZWZhdWx0OiA1KS5cbiAqIEBwYXJhbSBvcHRzLnNvdXJjZSAtIEEgZGVzY3JpcHRvciBmb3IgdGhlIGVudGl0eSBtYWtpbmcgdGhlIHJlcXVlc3Q7IHRyYWNrZWRcbiAqIGJ5IEluZnVyYSBmb3IgYW5hbHl0aWNzIHB1cnBvc2VzLlxuICogQHBhcmFtIG9wdHMucHJvamVjdElkIC0gVGhlIEluZnVyYSBwcm9qZWN0IGlkLlxuICogQHBhcmFtIG9wdHMuaGVhZGVycyAtIEV4dHJhIGhlYWRlcnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAqIEByZXR1cm5zIFRoZSBganNvbi1ycGMtZW5naW5lYC1jb21wYXRpYmxlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZnVyYU1pZGRsZXdhcmUoeyBuZXR3b3JrID0gJ21haW5uZXQnLCBtYXhBdHRlbXB0cyA9IDUsIHNvdXJjZSwgcHJvamVjdElkLCBoZWFkZXJzID0ge30sIH0pIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgaWYgKCFwcm9qZWN0SWQgfHwgdHlwZW9mIHByb2plY3RJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAncHJvamVjdElkJzogXCIke3Byb2plY3RJZH1cImApO1xuICAgIH1cbiAgICBpZiAoIWhlYWRlcnMgfHwgdHlwZW9mIGhlYWRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgJ2hlYWRlcnMnOiBcIiR7aGVhZGVyc31cImApO1xuICAgIH1cbiAgICBpZiAoIW1heEF0dGVtcHRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgJ21heEF0dGVtcHRzJzogXCIke21heEF0dGVtcHRzfVwiICgke3R5cGVvZiBtYXhBdHRlbXB0c30pYCk7XG4gICAgfVxuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCByZXMpID0+IHtcbiAgICAgICAgLy8gcmV0cnkgTUFYX0FUVEVNUFRTIHRpbWVzLCBpZiBlcnJvciBtYXRjaGVzIGZpbHRlclxuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIGxvZygnQXR0ZW1wdGluZyByZXF1ZXN0IHRvIEluZnVyYS4gbmV0d29yayA9ICVvLCBwcm9qZWN0SWQgPSAlcywgaGVhZGVycyA9ICVvLCByZXEgPSAlbycsIG5ldHdvcmssIHByb2plY3RJZCwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBwZXJmb3JtRmV0Y2gobmV0d29yaywgcHJvamVjdElkLCBoZWFkZXJzLCByZXEsIHJlcywgc291cmNlKTtcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gYW4gZXJyb3Igd2FzIGNhdWdodCB3aGlsZSBwZXJmb3JtaW5nIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IHJldHJpYWJsZSwgcmVzb2x2ZSB3aXRoIHRoZSBlbmNvdW50ZXJlZCBlcnJvclxuICAgICAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGVFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFib3J0IHdpdGggZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdOb24tcmV0cmlhYmxlIHJlcXVlc3QgZXJyb3IgZW5jb3VudGVyZWQuIHJlcSA9ICVvLCByZXMgPSAlbywgZXJyb3IgPSAlbycsIHJlcSwgcmVzLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1vcmUgYXR0ZW1wdHMgcmVtYWluaW5nLCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0F0dGVtcHRzID0gbWF4QXR0ZW1wdHMgLSBhdHRlbXB0O1xuICAgICAgICAgICAgICAgIGlmICghcmVtYWluaW5nQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdSZXRyaWFibGUgcmVxdWVzdCBlcnJvciBlbmNvdW50ZXJlZCwgYnV0IGV4Y2VlZGVkIG1heCBhdHRlbXB0cy4gcmVxID0gJW8sIHJlcyA9ICVvLCBlcnJvciA9ICVvJywgcmVxLCByZXMsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBJbmZ1cmFQcm92aWRlciAtIGNhbm5vdCBjb21wbGV0ZSByZXF1ZXN0LiBBbGwgcmV0cmllcyBleGhhdXN0ZWQuXFxuT3JpZ2luYWwgRXJyb3I6XFxuJHtlcnIudG9TdHJpbmcoKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyaWVzRXhoYXVzdGVkRXJyID0gbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJldHJpZXNFeGhhdXN0ZWRFcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgaWdub3JlIGVycm9yIGFuZCByZXRyeSBhZ2FpbiBhZnRlciB0aW1lb3V0XG4gICAgICAgICAgICAgICAgbG9nKCdSZXRyaWFibGUgcmVxdWVzdCBlcnJvciBlbmNvdW50ZXJlZC4gcmVxID0gJW8sIHJlcyA9ICVvLCBlcnJvciA9ICVvJywgcmVxLCByZXMsIGVycik7XG4gICAgICAgICAgICAgICAgbG9nKCdXYWl0aW5nIDEgc2Vjb25kIHRvIHRyeSBhZ2Fpbi4uLicpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVxdWVzdCB3YXMgaGFuZGxlZCBjb3JyZWN0bHksIGVuZFxuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVJbmZ1cmFNaWRkbGV3YXJlID0gY3JlYXRlSW5mdXJhTWlkZGxld2FyZTtcbi8qKlxuICogTWFrZXMgYSByZXF1ZXN0IHRvIEluZnVyYSwgdXBkYXRpbmcgdGhlIGdpdmVuIHJlc3BvbnNlIG9iamVjdCBpZiB0aGUgcmVzcG9uc2VcbiAqIGhhcyBhIFwic3VjY2Vzc2Z1bFwiIHN0YXR1cyBjb2RlIG9yIHRocm93aW5nIGFuIGVycm9yIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0gbmV0d29yayAtIEEgbmV0d29yayB0aGF0IEluZnVyYSBzdXBwb3J0czsgcGx1Z3MgaW50b1xuICogYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW9gLlxuICogQHBhcmFtIHByb2plY3RJZCAtIFRoZSBJbmZ1cmEgcHJvamVjdCBpZC5cbiAqIEBwYXJhbSBleHRyYUhlYWRlcnMgLSBFeHRyYSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIG1ha2UgdGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0gcmVxIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IG9idGFpbmVkIHZpYSB0aGUgbWlkZGxld2FyZSBzdGFjay5cbiAqIEBwYXJhbSByZXMgLSBUaGUgb3JpZ2luYWwgcmVzcG9uc2Ugb2JqZWN0IG9idGFpbmVkIHZpYSB0aGUgbWlkZGxld2FyZSBzdGFjay5cbiAqIEBwYXJhbSBzb3VyY2UgLSBBIGRlc2NyaXB0b3IgZm9yIHRoZSBlbnRpdHkgbWFraW5nIHRoZSByZXF1ZXN0O1xuICogdHJhY2tlZCBieSBJbmZ1cmEgZm9yIGFuYWx5dGljcyBwdXJwb3Nlcy5cbiAqIEB0aHJvd3MgYW4gZXJyb3Igd2l0aCBhIGRldGFpbGVkIG1lc3NhZ2UgaWYgdGhlIEhUVFAgc3RhdHVzIGNvZGUgaXMgYW55d2hlcmVcbiAqIG91dHNpZGUgMnh4LCBhbmQgZXNwZWNpYWxseSBpZiBpdCBpcyA0MDUsIDQyOSwgNTAzLCBvciA1MDQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1GZXRjaChuZXR3b3JrLCBwcm9qZWN0SWQsIGV4dHJhSGVhZGVycywgcmVxLCByZXMsIHNvdXJjZSkge1xuICAgIGNvbnN0IHsgZmV0Y2hVcmwsIGZldGNoUGFyYW1zIH0gPSAoMCwgZmV0Y2hfY29uZmlnX2Zyb21fcmVxXzEuZmV0Y2hDb25maWdGcm9tUmVxKSh7XG4gICAgICAgIG5ldHdvcmssXG4gICAgICAgIHByb2plY3RJZCxcbiAgICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgICByZXEsXG4gICAgICAgIHNvdXJjZSxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBub2RlX2ZldGNoXzEuZGVmYXVsdCkoZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICBjb25zdCByYXdEYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIC8vIGhhbmRsZSBlcnJvcnNcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIDQwNTpcbiAgICAgICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoKTtcbiAgICAgICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVJhdGVsaW1pdEVycm9yKCk7XG4gICAgICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVRpbWVvdXRFcnJvcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnRlcm5hbEVycm9yKHJhd0RhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igbm93XG4gICAgaWYgKHJlcS5tZXRob2QgPT09ICdldGhfZ2V0QmxvY2tCeU51bWJlcicgJiYgcmF3RGF0YSA9PT0gJ05vdCBGb3VuZCcpIHtcbiAgICAgICAgcmVzLnJlc3VsdCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcGFyc2UgSlNPTlxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhd0RhdGEpO1xuICAgIC8vIGZpbmFsbHkgcmV0dXJuIHJlc3VsdFxuICAgIHJlcy5yZXN1bHQgPSBkYXRhLnJlc3VsdDtcbiAgICByZXMuZXJyb3IgPSBkYXRhLmVycm9yO1xufVxuLyoqXG4gKiBCdWlsZHMgYSBKU09OLVJQQyAyLjAgaW50ZXJuYWwgZXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgYSByYXRlLWxpbWl0aW5nXG4gKiBlcnJvci5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVSYXRlbGltaXRFcnJvcigpIHtcbiAgICBjb25zdCBtc2cgPSBgUmVxdWVzdCBpcyBiZWluZyByYXRlIGxpbWl0ZWQuYDtcbiAgICByZXR1cm4gY3JlYXRlSW50ZXJuYWxFcnJvcihtc2cpO1xufVxuLyoqXG4gKiBCdWlsZHMgYSBKU09OLVJQQyAyLjAgaW50ZXJuYWwgZXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgYSB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRFcnJvcigpIHtcbiAgICBsZXQgbXNnID0gYEdhdGV3YXkgdGltZW91dC4gVGhlIHJlcXVlc3QgdG9vayB0b28gbG9uZyB0byBwcm9jZXNzLiBgO1xuICAgIG1zZyArPSBgVGhpcyBjYW4gaGFwcGVuIHdoZW4gcXVlcnlpbmcgbG9ncyBvdmVyIHRvbyB3aWRlIGEgYmxvY2sgcmFuZ2UuYDtcbiAgICByZXR1cm4gY3JlYXRlSW50ZXJuYWxFcnJvcihtc2cpO1xufVxuLyoqXG4gKiBCdWlsZHMgYSBKU09OLVJQQyAyLjAgaW50ZXJuYWwgZXJyb3Igb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtc2cgLSBUaGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsRXJyb3IobXNnKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChtc2cpO1xufVxuLyoqXG4gKiBVcG9uIG1ha2luZyBhIHJlcXVlc3QsIHdlIG1heSBnZXQgYW4gZXJyb3IgdGhhdCBpcyB0ZW1wb3JhcnkgYW5kXG4gKiBpbnRlcm1pdHRlbnQuIEluIHRoZXNlIGNhc2VzIHdlIGNhbiBhdHRlbXB0IHRoZSByZXF1ZXN0IGFnYWluIHdpdGggdGhlXG4gKiBhc3N1bXB0aW9uIHRoYXQgdGhlIGVycm9yIGlzIHVubGlrZWx5IHRvIG9jY3VyIGFnYWluLiBIZXJlIHdlIGRldGVybWluZSBpZiB3ZVxuICogaGF2ZSByZWNlaXZlZCBzdWNoIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnIgLSBUaGUgZXJyb3Igb2JqZWN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgcmVxdWVzdCB0aGF0IHByb2R1Y2VkIHRoZSBlcnJvciBjYW4gYmUgcmV0cmllZC5cbiAqL1xuZnVuY3Rpb24gaXNSZXRyaWFibGVFcnJvcihlcnIpIHtcbiAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIFJFVFJJQUJMRV9FUlJPUlMuc29tZSgocGhyYXNlKSA9PiBlcnJNZXNzYWdlLmluY2x1ZGVzKHBocmFzZSkpO1xufVxuLyoqXG4gKiBBIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBwcm9taXNpZmllcyBgc2V0VGltZW91dGAuXG4gKlxuICogQHBhcmFtIGxlbmd0aCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQuXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgZ2l2ZW4gdGltZSBoYXMgZWxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gdGltZW91dChsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBsZW5ndGgpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWluZnVyYS1taWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGV0aF9qc29uX3JwY19taWRkbGV3YXJlXzEgPSByZXF1aXJlKFwiZXRoLWpzb24tcnBjLW1pZGRsZXdhcmVcIik7XG5jb25zdCBjcmVhdGVfaW5mdXJhX21pZGRsZXdhcmVfMSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1pbmZ1cmEtbWlkZGxld2FyZVwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIHByb3ZpZGVyIChhcyBkZWZpbmVkIGluXG4gKiBbYGV0aC1qc29uLXJwYy1taWRkbGV3YXJlYF0oaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlKVxuICogd2hpY2ggaXMgcHJlbG9hZGVkIHdpdGggbWlkZGxld2FyZSBzcGVjaWFsaXplZCBmb3IgaW50ZXJmYWNpbmcgd2l0aCBJbmZ1cmFcbiAqIEpTT04tUlBDIGVuZHBvaW50cy5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgdG8ge0BsaW5rIGNyZWF0ZUluZnVyYU1pZGRsZXdhcmV9LlxuICogQHJldHVybnMgVGhlIHByb3ZpZGVyIGFzIHJldHVybmVkIGJ5IGBwcm92aWRlckZyb21FbmdpbmVgIChhIHBhcnQgb2ZcbiAqIFtgZXRoLWpzb24tcnBjLW1pZGRsZXdhcmVgXShodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUpKS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIob3B0cykge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBqc29uX3JwY19lbmdpbmVfMS5Kc29uUnBjRW5naW5lKCk7XG4gICAgZW5naW5lLnB1c2goKDAsIGNyZWF0ZV9pbmZ1cmFfbWlkZGxld2FyZV8xLmNyZWF0ZUluZnVyYU1pZGRsZXdhcmUpKG9wdHMpKTtcbiAgICByZXR1cm4gKDAsIGV0aF9qc29uX3JwY19taWRkbGV3YXJlXzEucHJvdmlkZXJGcm9tRW5naW5lKShlbmdpbmUpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm92aWRlciA9IGNyZWF0ZVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaENvbmZpZ0Zyb21SZXEgPSB2b2lkIDA7XG4vKipcbiAqIERldGVybWluZXMgdGhlIGFyZ3VtZW50cyB0byBmZWVkIGludG8gYGZldGNoYCBpbiBvcmRlciB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICogSW5mdXJhLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5uZXR3b3JrIC0gQSBuZXR3b3JrIHRoYXQgSW5mdXJhIHN1cHBvcnRzOyBwbHVncyBpbnRvXG4gKiBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pb2AuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcm9qZWN0SWQgLSBUaGUgSW5mdXJhIHByb2plY3QgaWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5leHRyYUhlYWRlcnMgLSBFeHRyYSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIG1ha2UgdGhlXG4gKiByZXF1ZXN0LlxuICogQHBhcmFtIG9wdGlvbnMucmVxIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IG9idGFpbmVkIHZpYSB0aGVcbiAqIG1pZGRsZXdhcmUgc3RhY2suXG4gKiBAcGFyYW0gb3B0aW9ucy5zb3VyY2UgLSBBIGRlc2NyaXB0b3IgZm9yIHRoZSBlbnRpdHkgbWFraW5nIHRoZSByZXF1ZXN0O1xuICogdHJhY2tlZCBieSBJbmZ1cmEgZm9yIGFuYWx5dGljcyBwdXJwb3Nlcy5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBVUkwgYW5kIGEgYmFnIG9mIG9wdGlvbnMsIGJvdGggb2Ygd2hpY2hcbiAqIHdpbGwgYmUgcGFzc2VkIHRvIGBmZXRjaGAuXG4gKi9cbmZ1bmN0aW9uIGZldGNoQ29uZmlnRnJvbVJlcSh7IG5ldHdvcmssIHByb2plY3RJZCwgZXh0cmFIZWFkZXJzID0ge30sIHJlcSwgc291cmNlLCB9KSB7XG4gICAgY29uc3QgcmVxdWVzdE9yaWdpbiA9IHJlcS5vcmlnaW4gfHwgJ2ludGVybmFsJztcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFIZWFkZXJzLCB7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH0pO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgaGVhZGVyc1snSW5mdXJhLVNvdXJjZSddID0gYCR7c291cmNlfS8ke3JlcXVlc3RPcmlnaW59YDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmV0Y2hVcmw6IGBodHRwczovLyR7bmV0d29ya30uaW5mdXJhLmlvL3YzLyR7cHJvamVjdElkfWAsXG4gICAgICAgIGZldGNoUGFyYW1zOiB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShub3JtYWxpemVSZXEocmVxKSksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuZmV0Y2hDb25maWdGcm9tUmVxID0gZmV0Y2hDb25maWdGcm9tUmVxO1xuLyoqXG4gKiBTdHJpcHMgb3V0IGV4dHJhIGtleXMgZnJvbSBhIHJlcXVlc3Qgb2JqZWN0IHRoYXQgY291bGQgYmUgcmVqZWN0ZWQgYnkgc3RyaWN0XG4gKiBub2RlcyBsaWtlIHBhcml0eS5cbiAqXG4gKiBAcGFyYW0gcmVxIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IG9idGFpbmVkIHZpYSB0aGUgbWlkZGxld2FyZSBzdGFjay5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIEpTT04tUlBDIHJlcXVlc3QuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcShyZXEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogcmVxLmlkLFxuICAgICAgICBqc29ucnBjOiByZXEuanNvbnJwYyxcbiAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHJlcS5wYXJhbXMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLWNvbmZpZy1mcm9tLXJlcS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NyZWF0ZS1pbmZ1cmEtbWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmV0Y2gtY29uZmlnLWZyb20tcmVxXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jcmVhdGUtcHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGV4cG9ydHMucHJvamVjdExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTW9kdWxlTG9nZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcjsgfSB9KTtcbmV4cG9ydHMucHJvamVjdExvZ2dlciA9ICgwLCB1dGlsc18xLmNyZWF0ZVByb2plY3RMb2dnZXIpKCdldGgtanNvbi1ycGMtaW5mdXJhJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgbWVzc2FnZWAgcHJvcGVydHksIHN1Y2ggYXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgb3IgZmFsc2UsIGRlcGVuZGluZyBvbiB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBjb25zdHJ1Y3RvciwgaS5lLiwgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aFxuICogdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RhYmxlKGZuKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiAoKF9iID0gKF9hID0gZm4gPT09IG51bGwgfHwgZm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZuLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogR2V0IHRoZSBlcnJvciBtZXNzYWdlIGZyb20gYW4gdW5rbm93biBlcnJvciBvYmplY3QuIElmIHRoZSBlcnJvciBvYmplY3QgaGFzXG4gKiBhIGBtZXNzYWdlYCBwcm9wZXJ0eSwgdGhhdCBwcm9wZXJ0eSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgc3RyaW5naWZpZWRcbiAqIGVycm9yIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgLy8gSWYgdGhlIGVycm9yIGVuZHMgd2l0aCBhIHBlcmlvZCwgcmVtb3ZlIGl0LCBhcyB3ZSdsbCBhZGQgb3VyIG93biBwZXJpb2QuXG4gICAgaWYgKG1lc3NhZ2UuZW5kc1dpdGgoJy4nKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2U2NCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwcm92aWRlZCBzdHJpbmctYmFzZWQgc3RydWN0IGlzIHZhbGlkIGJhc2U2NC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cmluZyBiYXNlZCBzdHJ1Y3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgdG8gc3BlY2lhbGl6ZSBiYXNlNjQgdmFsaWRhdGlvbi4gU2VlIHtAbGluayBCYXNlNjRPcHRpb25zfSBkb2N1bWVudGF0aW9uLlxuICogQHJldHVybnMgQSBzdXBlcnN0cnVjdCB2YWxpZGF0aW5nIGJhc2U2NC5cbiAqL1xuY29uc3QgYmFzZTY0ID0gKHN0cnVjdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwYWRkaW5nUmVxdWlyZWQgPSAoX2EgPSBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gKF9iID0gb3B0aW9ucy5jaGFyYWN0ZXJTZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8vICcwJy5jaGFyQ29kZUF0KDApID09PSA0OFxuY29uc3QgSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDQ4O1xuLy8gJzknLmNoYXJDb2RlQXQoMCkgPT09IDU3XG5jb25zdCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNTg7XG5jb25zdCBIRVhfQ0hBUkFDVEVSX09GRlNFVCA9IDg3O1xuLyoqXG4gKiBNZW1vaXplZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgdG8gYmUgdXNlZCBhcyBhIGxvb2t1cCB0YWJsZSBmb3JcbiAqIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4YWRlY2ltYWwgdmFsdWVzLlxuICpcbiAqIFRoZSBhcnJheSBpcyBjcmVhdGVkIGxhemlseSBhbmQgdGhlbiBjYWNoZWQgZm9yIGZ1dHVyZSB1c2UuIFRoZSBiZW5lZml0IG9mXG4gKiB0aGlzIGFwcHJvYWNoIGlzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4IGlzIG11Y2hcbiAqIGJldHRlciB0aGFuIGlmIHdlIHdlcmUgdG8gY2FsbCBgdG9TdHJpbmcoMTYpYCBvbiBlYWNoIGJ5dGUuXG4gKlxuICogVGhlIGRvd25zaWRlIGlzIHRoYXQgdGhlIGFycmF5IGlzIGNyZWF0ZWQgb25jZSBhbmQgdGhlbiBuZXZlciBnYXJiYWdlXG4gKiBjb2xsZWN0ZWQuIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBpbiBwcmFjdGljZSBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IDI1NlxuICogZWxlbWVudHMgbG9uZy5cbiAqXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbG9va3VwIHRhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKSB7XG4gICAgLy8gVG8gYXZvaWQgaXNzdWVzIHdpdGggdHJlZSBzaGFraW5nLCB3ZSBuZWVkIHRvIHVzZSBhIGZ1bmN0aW9uIHRvIHJldHVybiB0aGVcbiAgICAvLyBhcnJheS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IHVzZWQgaW4gdGhlIGBieXRlc1RvSGV4YCBmdW5jdGlvblxuICAgIC8vIGFuZCBpZiB3ZSB3ZXJlIHRvIHVzZSBhIGdsb2JhbCB2YXJpYWJsZSwgdGhlIGFycmF5IG1pZ2h0IGJlIHJlbW92ZWQgYnkgdGhlXG4gICAgLy8gdHJlZSBzaGFrZXIuXG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBbXTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobG9va3VwVGFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUucHVzaChpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9va3VwVGFibGU7XG4gICAgfTtcbn1cbi8qKlxuICogRnVuY3Rpb24gaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXJ9XG4gKiBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNCeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzQnl0ZXModmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIFVpbnQ4QXJyYXkuJyk7XG59XG5leHBvcnRzLmFzc2VydElzQnl0ZXMgPSBhc3NlcnRJc0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMoKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IG5ldyBBcnJheShieXRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgaGV4YWRlY2ltYWxbaV0gPSBsb29rdXBUYWJsZVtieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKGhleGFkZWNpbWFsLmpvaW4oJycpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvTnVtYmVyfS5cbiAqIFRvIGNvbnZlcnQgYSB0d28ncyBjb21wbGVtZW50IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9TaWduZWRCaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9CaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IGJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgIHJldHVybiBCaWdJbnQoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gYnl0ZXNUb0JpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIHNpZ25lZCBgYmlnaW50YC4gVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGJ5dGVzIGFyZVxuICogZW5jb2RlZCBpbiB0d28ncyBjb21wbGVtZW50LlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYW4gdW5zaWduZWQgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc2lnbmVkIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIHNpZ25lZCBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1NpZ25lZEJpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYnl0ZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgQmlnSW50KDgpKSArIEJpZ0ludChieXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oYnl0ZXMubGVuZ3RoICogOCwgdmFsdWUpO1xufVxuZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gYnl0ZXNUb1NpZ25lZEJpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHJlc3VsdGluZyBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgYmlnaW50ID0gYnl0ZXNUb0JpZ0ludChieXRlcyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnaW50IDw9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksICdOdW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJ5dGVzVG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIE51bWJlcihiaWdpbnQpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gYnl0ZXNUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYHN0cmluZ2AuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgc3RyaW5nIGNhbiBvcHRpb25hbGx5IGJlXG4gKiBwcmVmaXhlZCB3aXRoIGAweGAuIEl0IGFjY2VwdHMgZXZlbiBhbmQgb2RkIGxlbmd0aCBzdHJpbmdzLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBcIjB4XCIsIGFuIGVtcHR5IGBVaW50OEFycmF5YCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFwiMHhcIiBpcyBvZnRlbiB1c2VkIGFzIGVtcHR5IGJ5dGUgYXJyYXkuXG4gICAgaWYgKCgoX2EgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9Mb3dlckNhc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlKSkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFJlbW92ZSB0aGUgYDB4YCBwcmVmaXggaWYgaXQgZXhpc3RzLCBhbmQgcGFkIHRoZSBzdHJpbmcgdG8gaGF2ZSBhbiBldmVuXG4gICAgLy8gbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9ICgwLCBoZXhfMS5yZW1vdmUweCkodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gc3RyaXBwZWRWYWx1ZS5sZW5ndGggJSAyID09PSAwID8gc3RyaXBwZWRWYWx1ZSA6IGAwJHtzdHJpcHBlZFZhbHVlfWA7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShub3JtYWxpemVkVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIG5vdCB0aGUgcHJldHRpZXN0IHdheSB0byBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXlgLCBpdCBpcyBhIGxvdCBmYXN0ZXIgdGhhbiB1c2luZyBgcGFyc2VJbnRgIHRvIGNvbnZlcnQgZWFjaFxuICAgICAgICAvLyBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0IGMxID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIpO1xuICAgICAgICBjb25zdCBjMiA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gICAgICAgIGNvbnN0IG4xID0gYzEgLVxuICAgICAgICAgICAgKGMxIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBjb25zdCBuMiA9IGMyIC1cbiAgICAgICAgICAgIChjMiA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgYnl0ZXNbaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYGJpZ2ludGAgaXMgYW4gdW5zaWduZWQgaW50ZWdlci4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYmlnaW50IHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBiaWdJbnRUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gQmlnSW50KDApLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gYmlnSW50VG9CeXRlcztcbi8qKlxuICogQ2hlY2sgaWYgYSBgYmlnaW50YCBmaXRzIGluIGEgY2VydGFpbiBudW1iZXIgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNoZWNrLlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIG51bWJlciBvZiBieXRlcy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGBiaWdpbnRgIGZpdHMgaW4gdGhlIG51bWJlciBvZiBieXRlcy5cbiAqL1xuZnVuY3Rpb24gYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZXMpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlcyA+IDApO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBtYXNrID0gdmFsdWUgPj4gQmlnSW50KDMxKTtcbiAgICByZXR1cm4gISgoKH52YWx1ZSAmIG1hc2spICsgKHZhbHVlICYgfm1hc2spKSA+PiBCaWdJbnQoYnl0ZXMgKiA4ICsgfjApKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC4gVGhpcyB1c2VzIHR3bydzIGNvbXBsZW1lbnRcbiAqIGVuY29kaW5nIHRvIHJlcHJlc2VudCBuZWdhdGl2ZSBudW1iZXJzLlxuICpcbiAqIFRvIGNvbnZlcnQgYW4gdW5zaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9CeXRlc30uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIGBVaW50OEFycmF5YC4gSWYgdGhlIG51bWJlclxuICogaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGxlbmd0aCxcbiAqIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZEJpZ0ludFRvQnl0ZXModmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicsICdCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJ5dGVMZW5ndGggPiAwLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdJbnRGaXRzKHZhbHVlLCBieXRlTGVuZ3RoKSwgJ0J5dGUgbGVuZ3RoIGlzIHRvbyBzbWFsbCB0byByZXByZXNlbnQgdGhlIGdpdmVuIHZhbHVlLicpO1xuICAgIC8vIEVTTGludCBkb2Vzbid0IGxpa2UgbXV0YXRpbmcgZnVuY3Rpb24gcGFyYW1ldGVycywgc28gdG8gYXZvaWQgaGF2aW5nIHRvXG4gICAgLy8gZGlzYWJsZSB0aGUgcnVsZSwgd2UgY3JlYXRlIGEgbmV3IHZhcmlhYmxlLlxuICAgIGxldCBudW1iZXJWYWx1ZSA9IHZhbHVlO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IE51bWJlcihCaWdJbnQuYXNVaW50Tig4LCBudW1iZXJWYWx1ZSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBudW1iZXJWYWx1ZSA+Pj0gQmlnSW50KDgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gc2lnbmVkQmlnSW50VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBudW1iZXJgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0J5dGVzYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IG51bWJlclRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgc3RyaW5nYCB0byBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBieXRlLWxpa2UgdmFsdWUgdG8gYSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZSBjYW4gYmUgYSBgVWludDhBcnJheWAsXG4gKiBhIGBiaWdpbnRgLCBhIGBudW1iZXJgLCBvciBhIGBzdHJpbmdgLlxuICpcbiAqIFRoaXMgd2lsbCBhdHRlbXB0IHRvIGd1ZXNzIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBiYXNlZCBvbiBpdHMgdHlwZSBhbmRcbiAqIGNvbnRlbnRzLiBGb3IgbW9yZSBjb250cm9sIG92ZXIgdGhlIGNvbnZlcnNpb24sIHVzZSB0aGUgbW9yZSBzcGVjaWZpY1xuICogY29udmVyc2lvbiBmdW5jdGlvbnMsIHN1Y2ggYXMge0BsaW5rIGhleFRvQnl0ZXN9IG9yIHtAbGluayBzdHJpbmdUb0J5dGVzfS5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgc3RyaW5nYCwgYW5kIGl0IGlzIHByZWZpeGVkIHdpdGggYDB4YCwgaXQgd2lsbCBiZVxuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhXG4gKiBVVEYtOCBzdHJpbmcuIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYnl0ZXMgd2l0aG91dCBpbnRlcnByZXRpbmdcbiAqIGl0IGFzIGEgVVRGLTggc3RyaW5nLCB1c2Uge0BsaW5rIGhleFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIGFzc3VtZWQgdG8gYmUgdW5zaWduZWQuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIHRvIGJ5dGVzLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gdmFsdWVUb0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGJpZ0ludFRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZSB0eXBlOiBcIiR7dHlwZW9mIHZhbHVlfVwiLmApO1xufVxuZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSB2YWx1ZVRvQnl0ZXM7XG4vKipcbiAqIENvbmNhdGVuYXRlIG11bHRpcGxlIGJ5dGUtbGlrZSB2YWx1ZXMgaW50byBhIHNpbmdsZSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZXNcbiAqIGNhbiBiZSBgVWludDhBcnJheWAsIGBiaWdpbnRgLCBgbnVtYmVyYCwgb3IgYHN0cmluZ2AuIFRoaXMgdXNlc1xuICoge0BsaW5rIHZhbHVlVG9CeXRlc30gdW5kZXIgdGhlIGhvb2QgdG8gY29udmVydCBlYWNoIHZhbHVlIHRvIGJ5dGVzLiBSZWZlciB0b1xuICogdGhlIGRvY3VtZW50YXRpb24gb2YgdGhhdCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWVzID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlVG9CeXRlcyh2YWx1ZXNbaV0pO1xuICAgICAgICBub3JtYWxpemVkVmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgIGJ5dGVMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgbm9ybWFsaXplZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB3ZSBjb3VsZCBzaW1wbHkgc3ByZWFkIHRoZSB2YWx1ZXMgaW50byBhbiBhcnJheSBhbmQgdXNlXG4gICAgICAgIC8vIGBVaW50OEFycmF5LmZyb21gLCB0aGF0IGlzIGEgbG90IHNsb3dlciB0aGFuIHVzaW5nIGBVaW50OEFycmF5LnNldGAuXG4gICAgICAgIGJ5dGVzLnNldChub3JtYWxpemVkVmFsdWVzW2ldLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gbm9ybWFsaXplZFZhbHVlc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBmcm9tIGEge0BsaW5rIFVpbnQ4QXJyYXl9LiBUaGlzIGlzIGEgY29udmVuaWVuY2VcbiAqIGZ1bmN0aW9uIHRoYXQgYXZvaWRzIGhhdmluZyB0byBjcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IG1hbnVhbGx5LCB3aGljaFxuICogcmVxdWlyZXMgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBldmVyeSB0aW1lLlxuICpcbiAqIE5vdCBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGNhbiByZXN1bHQgaW5cbiAqIHVuZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiB0aGUge0BsaW5rIFVpbnQ4QXJyYXl9IGlzIGEgdmlldyBvZiBhIGxhcmdlclxuICoge0BsaW5rIEFycmF5QnVmZmVyfSwgZS5nLiwgd2hlbiB1c2luZyB7QGxpbmsgVWludDhBcnJheS5zdWJhcnJheX0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHNvIHN1cHBvcnRzIE5vZGUuanMge0BsaW5rIEJ1ZmZlcn1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSk7XG4gKlxuICogLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvOlxuICogLy8gY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAqIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpO1xuICogYGBgXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY3JlYXRlIHRoZSB7QGxpbmsgRGF0YVZpZXd9IGZyb20uXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIERhdGFWaWV3fS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpIHtcbiAgICAvLyBUbyBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggTm9kZS5qcywgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgYnl0ZXMgYXJlXG4gICAgLy8gYSBCdWZmZXIuIElmIHNvLCB3ZSBuZWVkIHRvIHNsaWNlIHRoZSBidWZmZXIgdG8gZ2V0IHRoZSB1bmRlcmx5aW5nXG4gICAgLy8gQXJyYXlCdWZmZXIuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBieXRlcy5idWZmZXIuc2xpY2UoYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZU9mZnNldCArIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbn1cbmV4cG9ydHMuY3JlYXRlRGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NFwiKTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5zaXplKSgoMCwgYmFzZTY0XzEuYmFzZTY0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIHsgcGFkZGluZ1JlcXVpcmVkOiB0cnVlIH0pLCA0NCwgNDQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzdW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUhleCA9IGV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBleHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGV4cG9ydHMuY3JlYXRlTnVtYmVyID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRnJvemVuTWFwX21hcCwgX0Zyb3plblNldF9zZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyb3plblNldCA9IGV4cG9ydHMuRnJvemVuTWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seU1hcH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIG1hcCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgbWFwLlxuICovXG5jbGFzcyBGcm96ZW5NYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgX0Zyb3plbk1hcF9tYXAuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIG5ldyBNYXAoZW50cmllcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBtYXAuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZm9yRWFjaCgodmFsdWUsIGtleSwgX21hcCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuaGFzKGtleSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plbk1hcCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke1N0cmluZyhrZXkpfSA9PiAke1N0cmluZyh2YWx1ZSl9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plbk1hcCA9IEZyb3plbk1hcDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlTZXR9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBzZXQgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIHNldC5cbiAqL1xuY2xhc3MgRnJvemVuU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgX0Zyb3plblNldF9zZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plblNldF9zZXQsIG5ldyBTZXQodmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5TZXRfc2V0ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIHNldC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwgdmFsdWUyLCBfc2V0KSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlMiwgdGhpcykpO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5TZXQoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy52YWx1ZXMoKV0ubWFwKChtZW1iZXIpID0+IFN0cmluZyhtZW1iZXIpKS5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuU2V0ID0gRnJvemVuU2V0O1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXApO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXAucHJvdG90eXBlKTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0KTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0LnByb3RvdHlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlMHggPSBleHBvcnRzLmFkZDB4ID0gZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gZXhwb3J0cy5IZXhTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5leHBvcnRzLkhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG5leHBvcnRzLlN0cmljdEhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14weFswLTlhLWZdKyQvaXUpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8qKlxuICogU3RyaWN0bHkgY2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdFxuICogc3RhcnQgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGlzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzSGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG59XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBzdGFydCB3aXRoXG4gKiB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGFzc2VydElzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBZGQgdGhlIGAweGAtcHJlZml4IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaGFzIHRoZVxuICogcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFkZCB0aGUgcHJlZml4IHRvLlxuICogQHJldHVybnMgVGhlIHByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZXhwb3J0cy5hZGQweCA9IGFkZDB4O1xuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW1vdmUweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpIHx8IGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xufVxuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXJ0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlNjRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGVja3N1bVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29lcmNlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21pc2NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3BhcXVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90aW1lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92ZXJzaW9uc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVKc29uQW5kR2V0U2l6ZSA9IGV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmlzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9IGV4cG9ydHMuanNvbnJwYzIgPSBleHBvcnRzLmlzVmFsaWRKc29uID0gZXhwb3J0cy5Kc29uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgbWlzY18xID0gcmVxdWlyZShcIi4vbWlzY1wiKTtcbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZSkoJ0pzb24nLCAodmFsdWUpID0+IHtcbiAgICBjb25zdCBbaXNWYWxpZF0gPSB2YWxpZGF0ZUpzb25BbmRHZXRTaXplKHZhbHVlLCB0cnVlKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuICdFeHBlY3RlZCBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlJztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLCBpLmUuLCBhIHZhbHVlIHRoYXQgaXNcbiAqIHNlcmlhbGl6YWJsZSB0byBKU09OLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIFRoZSBzdHJpbmcgJzIuMCcuXG4gKi9cbmV4cG9ydHMuanNvbnJwYzIgPSAnMi4wJztcbmV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5saXRlcmFsKShleHBvcnRzLmpzb25ycGMyKTtcbmV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubnVsbGFibGUpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCldKSk7XG5leHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGNvZGU6ICgwLCBzdXBlcnN0cnVjdF8xLmludGVnZXIpKCksXG4gICAgbWVzc2FnZTogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIGRhdGE6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpKSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSkpO1xuZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIG1ldGhvZDogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIHBhcmFtczogZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vbWl0KShleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCBbJ2lkJ10pO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259XG4gKiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGlzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIG5vdGlmaWNhdGlvbicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVxdWVzdCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gaXNKc29uUnBjUmVxdWVzdDtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIEpTT04tUlBDIHJlcXVlc3Qgb3Igbm90aWZpY2F0aW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0KHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXF1ZXN0JywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGFzc2VydElzSnNvblJwY1JlcXVlc3Q7XG5leHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmtub3duKSgpKSxcbiAgICBlcnJvcjogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogZXhwb3J0cy5Kc29uU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgZXJyb3I6IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbXG4gICAgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCxcbiAgICBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0LFxuXSk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgd2hldGhlciBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgYVxuICoge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBwZW5kaW5nLlxuICovXG5mdW5jdGlvbiBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkocmVzcG9uc2UsIGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCwgJ0ludmFsaWQgcGVuZGluZyBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGEge0BsaW5rIEpzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIEpzb25ScGNSZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gaXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXNwb25zZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gaXNKc29uUnBjU3VjY2Vzcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNTdWNjZXNzKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBzdWNjZXNzIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGFzc2VydElzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0ZhaWx1cmUodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGlzSnNvblJwY0ZhaWx1cmU7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZmFpbHVyZSByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBhc3NlcnRJc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0Vycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGlzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRXJyb3IodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBlcnJvcicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gYXNzZXJ0SXNKc29uUnBjRXJyb3I7XG4vKipcbiAqIEdldHMgYSBmdW5jdGlvbiBmb3IgdmFsaWRhdGluZyBKU09OLVJQQyByZXF1ZXN0IC8gcmVzcG9uc2UgYGlkYCB2YWx1ZXMuXG4gKlxuICogQnkgbWFuaXB1bGF0aW5nIHRoZSBvcHRpb25zIG9mIHRoaXMgZmFjdG9yeSwgeW91IGNhbiBjb250cm9sIHRoZSBiZWhhdmlvclxuICogb2YgdGhlIHJlc3VsdGluZyB2YWxpZGF0b3IgZm9yIHNvbWUgZWRnZSBjYXNlcy4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBlLmcuXG4gKiBgbnVsbGAgc2hvdWxkIHNvbWV0aW1lcyBidXQgbm90IGFsd2F5cyBiZSBwZXJtaXR0ZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBlbXB0eSBzdHJpbmcgKGAnJ2ApIGlzIGFsd2F5cyBwZXJtaXR0ZWQgYnkgdGhlIEpTT04tUlBDXG4gKiBzcGVjaWZpY2F0aW9uLCBidXQgdGhhdCBraW5kIG9mIHN1Y2tzIGFuZCB5b3UgbWF5IHdhbnQgdG8gZm9yYmlkIGl0IGluIHNvbWVcbiAqIGluc3RhbmNlcyBhbnl3YXkuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZVxuICogW0pTT04tUlBDIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmpzb25ycGMub3JnL3NwZWNpZmljYXRpb24pLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRFbXB0eVN0cmluZyAtIFdoZXRoZXIgdGhlIGVtcHR5IHN0cmluZyAoaS5lLiBgJydgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC4gRGVmYXVsdDogYHRydWVgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRGcmFjdGlvbnMgLSBXaGV0aGVyIGZyYWN0aW9uYWwgbnVtYmVycyAoZS5nLiBgMS4yYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkIElEcy4gRGVmYXVsdDogYGZhbHNlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0TnVsbCAtIFdoZXRoZXIgYG51bGxgIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuXG4gKiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEByZXR1cm5zIFRoZSBKU09OLVJQQyBJRCB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25ScGNJZFZhbGlkYXRvcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwZXJtaXRFbXB0eVN0cmluZywgcGVybWl0RnJhY3Rpb25zLCBwZXJtaXROdWxsIH0gPSBPYmplY3QuYXNzaWduKHsgcGVybWl0RW1wdHlTdHJpbmc6IHRydWUsIHBlcm1pdEZyYWN0aW9uczogZmFsc2UsIHBlcm1pdE51bGw6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3Ige0BsaW5rIEpzb25ScGNJZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSlNPTi1SUEMgSUQgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gSUQgaXMgdmFsaWQgcGVyIHRoZSBvcHRpb25zIGdpdmVuIHRvIHRoZVxuICAgICAqIGZhY3RvcnkuXG4gICAgICovXG4gICAgY29uc3QgaXNWYWxpZEpzb25ScGNJZCA9IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbigodHlwZW9mIGlkID09PSAnbnVtYmVyJyAmJiAocGVybWl0RnJhY3Rpb25zIHx8IE51bWJlci5pc0ludGVnZXIoaWQpKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmIChwZXJtaXRFbXB0eVN0cmluZyB8fCBpZC5sZW5ndGggPiAwKSkgfHxcbiAgICAgICAgICAgIChwZXJtaXROdWxsICYmIGlkID09PSBudWxsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gaXNWYWxpZEpzb25ScGNJZDtcbn1cbmV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZ2V0SnNvblJwY0lkVmFsaWRhdG9yO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIEpTT04gc2VyaWFsaXphYmxlIGFuZCBjb3VudHMgdGhlIHRvdGFsIG51bWJlclxuICogb2YgYnl0ZXMgbmVlZGVkIHRvIHN0b3JlIHRoZSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBqc09iamVjdCAtIFBvdGVudGlhbCBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcGFyYW0gc2tpcFNpemluZ1Byb2Nlc3MgLSBTa2lwIEpTT04gc2l6ZSBjYWxjdWxhdGlvbiAoZGVmYXVsdDogZmFsc2UpLlxuICogQHJldHVybnMgVHVwbGUgW2lzVmFsaWQsIHBsYWluVGV4dFNpemVJbkJ5dGVzXSBjb250YWluaW5nIGEgYm9vbGVhbiB0aGF0IHNpZ25hbHMgd2hldGhlclxuICogdGhlIHZhbHVlIHdhcyBzZXJpYWxpemFibGUgYW5kIGEgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaXQgd2lsbCB1c2Ugd2hlbiBzZXJpYWxpemVkIHRvIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSnNvbkFuZEdldFNpemUoanNPYmplY3QsIHNraXBTaXppbmdQcm9jZXNzID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIEpTT04gc2VyaWFsaXphYmxlIGFuZCBjb3VudHMgdGhlIHRvdGFsIG51bWJlclxuICAgICAqIG9mIGJ5dGVzIG5lZWRlZCB0byBzdG9yZSB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgZW5jb2Rpbmcgb2YgdGhlIEpTT04gaXMgZG9uZSBpbiBVVEYtOC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFBvdGVudGlhbCBKU09OIHNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gc2tpcFNpemluZyAtIFNraXAgSlNPTiBzaXplIGNhbGN1bGF0aW9uIChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICogQHJldHVybnMgVHVwbGUgW2lzVmFsaWQsIHBsYWluVGV4dFNpemVJbkJ5dGVzXSBjb250YWluaW5nIGEgYm9vbGVhbiB0aGF0IHNpZ25hbHMgd2hldGhlclxuICAgICAqIHRoZSB2YWx1ZSB3YXMgc2VyaWFsaXphYmxlIGFuZCBhIG51bWJlciBvZiBieXRlcyB0aGF0IGl0IHdpbGwgdXNlIHdoZW4gc2VyaWFsaXplZCB0byBKU09OLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEpzb25TZXJpYWxpemFibGVJbmZvKHZhbHVlLCBza2lwU2l6aW5nKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGFscmVhZHkgc3BlY2lmaWVkIGNvbnN0YW50IHNpemUgZm9yIG51bGwgKHNwZWNpYWwgb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBza2lwU2l6aW5nID8gMCA6IG1pc2NfMS5Kc29uU2l6ZS5OdWxsXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBhbmQgY2FsY3VsYXRlIHNpemVzIGZvciBiYXNpYyAoYW5kIHNvbWUgc3BlY2lhbCkgdHlwZXNcbiAgICAgICAgY29uc3QgdHlwZU9mVmFsdWUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZU9mVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaXppbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoMCwgbWlzY18xLmNhbGN1bGF0ZVN0cmluZ1NpemUpKHZhbHVlKSArIG1pc2NfMS5Kc29uU2l6ZS5RdW90ZSAqIDIsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgdmFsdWUgPT0gdHJ1ZSA/IG1pc2NfMS5Kc29uU2l6ZS5UcnVlIDogbWlzY18xLkpzb25TaXplLkZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgKDAsIG1pc2NfMS5jYWxjdWxhdGVOdW1iZXJTaXplKSh2YWx1ZSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogSW52YWxpZCBkYXRlcyB3aWxsIHNlcmlhbGl6ZSB0byBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlzTmFOKHZhbHVlLmdldERhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbWlzY18xLkpzb25TaXplLk51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWlzY18xLkpzb25TaXplLkRhdGUgKyBtaXNjXzEuSnNvblNpemUuUXVvdGUgKiAyLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG9iamVjdCBpcyBub3QgcGxhaW4gYW5kIGNhbm5vdCBiZSBzZXJpYWxpemVkIHByb3Blcmx5LFxuICAgICAgICAvLyBzdG9wIGhlcmUgYW5kIHJldHVybiBmYWxzZSBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAoISgwLCBtaXNjXzEuaXNQbGFpbk9iamVjdCkodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2lyY3VsYXIgb2JqZWN0IGRldGVjdGlvbiAoaGFuZGxpbmcpXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzYW1lIG9iamVjdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAoc2Vlbk9iamVjdHMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG5ldyBvYmplY3QgdG8gdGhlIHNlZW4gb2JqZWN0cyBzZXRcbiAgICAgICAgLy8gT25seSB0aGUgcGxhaW4gb2JqZWN0cyBzaG91bGQgYmUgYWRkZWQgKFByaW1pdGl2ZSB0eXBlcyBhcmUgc2tpcHBlZClcbiAgICAgICAgc2Vlbk9iamVjdHMuYWRkKHZhbHVlKTtcbiAgICAgICAgLy8gQ29udGludWUgb2JqZWN0IGRlY29tcG9zaXRpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkucmVkdWNlKChzdW0sIFtrZXksIG5lc3RlZFZhbHVlXSwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvY2VzcyBuZXh0IG5lc3RlZCBvYmplY3Qgb3IgcHJpbWl0aXZlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICAgICAgICAgICAgICBsZXQgW3ZhbGlkLCBzaXplXSA9IGdldEpzb25TZXJpYWxpemFibGVJbmZvKG5lc3RlZFZhbHVlLCBza2lwU2l6aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OIHZhbGlkYXRpb24gZGlkIG5vdCBwYXNzLiBWYWxpZGF0aW9uIHByb2Nlc3Mgc3RvcHBlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaXJjdWxhciBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2UgYSBjaGlsZCBub2RlIGlzIHZpc2l0ZWQgYW5kIHByb2Nlc3NlZCByZW1vdmUgaXQgZnJvbSB0aGUgc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBmYWxzZSBwb3NpdGl2ZXMgd2l0aCB0aGUgc2FtZSBhZGphY2VudCBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICBzZWVuT2JqZWN0cy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0cyB3aWxsIGhhdmUgYmUgc2VyaWFsaXplZCB3aXRoIFwia2V5XCI6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZWZvcmUgd2UgaW5jbHVkZSB0aGUga2V5IGluIHRoZSBjYWxjdWxhdGlvbiBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVNpemUgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGtleS5sZW5ndGggKyBtaXNjXzEuSnNvblNpemUuQ29tbWEgKyBtaXNjXzEuSnNvblNpemUuQ29sb24gKiAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBpZHggPCBhcnIubGVuZ3RoIC0gMSA/IG1pc2NfMS5Kc29uU2l6ZS5Db21tYSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyBrZXlTaXplICsgc2l6ZSArIHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTdGFydHMgYXQgMiBiZWNhdXNlIHRoZSBzZXJpYWxpemVkIEpTT04gc3RyaW5nIGRhdGEgKHBsYWluIHRleHQpXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBtaW5pbWFsbHkgY29udGFpbiB7fS9bXVxuICAgICAgICAgICAgICAgIHNraXBTaXppbmcgPyAwIDogbWlzY18xLkpzb25TaXplLldyYXBwZXIgKiAyKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyhqc09iamVjdCwgc2tpcFNpemluZ1Byb2Nlc3MpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUpzb25BbmRHZXRTaXplID0gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGV4cG9ydHMuY3JlYXRlUHJvamVjdExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGdsb2JhbExvZ2dlciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdtZXRhbWFzaycpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZFxuICogdXNpbmcgdGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBCeSBkZWZhdWx0LCBzdWNoIG1lc3NhZ2VzIHdpbGwgYmVcbiAqIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtIGJ5IHNldHRpbmcgdGhlIGBERUJVR2AgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlIHRvIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cyB0aGF0XG4gKiBhcmUgYWxzbyB1c2luZyB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGVpciBsb2dnZXJzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gVGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2ZcbiAqIHlvdXIgTlBNIHBhY2thZ2UgaWYgeW91J3JlIGRldmVsb3Bpbmcgb25lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvamVjdExvZ2dlcihwcm9qZWN0TmFtZSkge1xuICAgIHJldHVybiBnbG9iYWxMb2dnZXIuZXh0ZW5kKHByb2plY3ROYW1lKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvamVjdExvZ2dlciA9IGNyZWF0ZVByb2plY3RMb2dnZXI7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hpY2ggaXMgZGVyaXZlZCBmcm9tIHRoZSBsb2dnZXIgZm9yXG4gKiB0aGUgd2hvbGUgcHJvamVjdCB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWQgdXNpbmcgdGhlIG5hbWUgb2YgeW91clxuICogbW9kdWxlLiBCeSBkZWZhdWx0LCBzdWNoIG1lc3NhZ2VzIHdpbGwgYmUgc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW1cbiAqIGJ5IHNldHRpbmcgdGhlIGBERUJVR2AgZW52aXJvbm1lbnQgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+Ojxtb2R1bGVOYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIHRoZSBwcm9qZWN0LFxuICogb3IgYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMuXG4gKlxuICogQHBhcmFtIHByb2plY3RMb2dnZXIgLSBUaGUgbG9nZ2VyIGNyZWF0ZWQgdmlhIHtAbGluayBjcmVhdGVQcm9qZWN0TG9nZ2VyfS5cbiAqIEBwYXJhbSBtb2R1bGVOYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBtb2R1bGUuIFlvdSBjb3VsZCB1c2UgdGhlIG5hbWUgb2YgdGhlXG4gKiBmaWxlIHdoZXJlIHlvdSdyZSB1c2luZyB0aGlzIGxvZ2dlciBvciBzb21lIG90aGVyIG5hbWUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2R1bGVMb2dnZXIocHJvamVjdExvZ2dlciwgbW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBwcm9qZWN0TG9nZ2VyLmV4dGVuZChtb2R1bGVOYW1lKTtcbn1cbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gY3JlYXRlTW9kdWxlTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vXG4vLyBUeXBlc1xuLy9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGV4cG9ydHMuaXNBU0NJSSA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gZXhwb3J0cy5Kc29uU2l6ZSA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogUHJlZGVmaW5lZCBzaXplcyAoaW4gQnl0ZXMpIG9mIHNwZWNpZmljIHBhcnRzIG9mIEpTT04gc3RydWN0dXJlLlxuICovXG52YXIgSnNvblNpemU7XG4oZnVuY3Rpb24gKEpzb25TaXplKSB7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJOdWxsXCJdID0gNF0gPSBcIk51bGxcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbW1hXCJdID0gMV0gPSBcIkNvbW1hXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJXcmFwcGVyXCJdID0gMV0gPSBcIldyYXBwZXJcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlRydWVcIl0gPSA0XSA9IFwiVHJ1ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRmFsc2VcIl0gPSA1XSA9IFwiRmFsc2VcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlF1b3RlXCJdID0gMV0gPSBcIlF1b3RlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb2xvblwiXSA9IDFdID0gXCJDb2xvblwiO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJEYXRlXCJdID0gMjRdID0gXCJEYXRlXCI7XG59KShKc29uU2l6ZSA9IGV4cG9ydHMuSnNvblNpemUgfHwgKGV4cG9ydHMuSnNvblNpemUgPSB7fSkpO1xuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBwYXR0ZXJuIG1hdGNoaW5nIGZvciAoc3BlY2lhbCkgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IC9cInxcXFxcfFxcbnxcXHJ8XFx0L2d1O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFuIG9iamVjdCBpcyB0aGUgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsXG4gKiBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBwbGFpbiAoZS5nLiBmdW5jdGlvbikuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4vKipcbiAqIENoZWNrIGlmIGNoYXJhY3RlciBpcyBBU0NJSS5cbiAqXG4gKiBAcGFyYW0gY2hhcmFjdGVyIC0gQ2hhcmFjdGVyLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhIGNoYXJhY3RlciBjb2RlIGlzIEFTQ0lJLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUkoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDEyNztcbn1cbmV4cG9ydHMuaXNBU0NJSSA9IGlzQVNDSUk7XG4vKipcbiAqIENhbGN1bGF0ZSBzdHJpbmcgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBzdHJpbmcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN0cmluZ1NpemUodmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICgoX2EgPSB2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBjYWxjdWxhdGVTdHJpbmdTaXplO1xuLyoqXG4gKiBDYWxjdWxhdGUgc2l6ZSBvZiBhIG51bWJlciBvZnRlciBKU09OIHNlcmlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgbnVtYmVyIGluIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU51bWJlclNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBjYWxjdWxhdGVOdW1iZXJTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlzYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGV4VG9CaWdJbnQgPSBleHBvcnRzLmhleFRvTnVtYmVyID0gZXhwb3J0cy5iaWdJbnRUb0hleCA9IGV4cG9ydHMubnVtYmVyVG9IZXggPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBleHBvcnRzLmd0UmFuZ2UgPSBleHBvcnRzLmd0VmVyc2lvbiA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSBleHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2Jsb2NrLWNhY2hlJyk7XG4vLyBgPG5pbD5gIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8xNjkyNVxuY29uc3QgZW1wdHlWYWx1ZXMgPSBbdW5kZWZpbmVkLCBudWxsLCAnXFx1MDAzY25pbFxcdTAwM2UnXTtcbi8vXG4vLyBDYWNoZSBTdHJhdGVnaWVzXG4vL1xuY2xhc3MgQmxvY2tDYWNoZVN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgICBnZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChfcGF5bG9hZCwgYmxvY2tOdW1iZXJIZXgpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tOdW1iZXJIZXgsIDE2KTtcbiAgICAgICAgbGV0IGJsb2NrQ2FjaGUgPSB0aGlzLmNhY2hlW2Jsb2NrTnVtYmVyXTtcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBjYWNoZSBpZiBuZWNlc2FyeVxuICAgICAgICBpZiAoIWJsb2NrQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICAgICAgICB0aGlzLmNhY2hlW2Jsb2NrTnVtYmVyXSA9IG5ld0NhY2hlO1xuICAgICAgICAgICAgYmxvY2tDYWNoZSA9IG5ld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja0NhY2hlO1xuICAgIH1cbiAgICBhc3luYyBnZXQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gbG9va3VwIGJsb2NrIGNhY2hlXG4gICAgICAgIGNvbnN0IGJsb2NrQ2FjaGUgPSB0aGlzLmdldEJsb2NrQ2FjaGVGb3JQYXlsb2FkKHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgLy8gbG9va3VwIHBheWxvYWQgaW4gYmxvY2sgY2FjaGVcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNhY2hlXzEuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIgPyBibG9ja0NhY2hlW2lkZW50aWZpZXJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBzZXQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlc3VsdCkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gY2FjaGVkIHRoaXMgcmVzdWx0XG4gICAgICAgIGNvbnN0IGNhbkNhY2hlUmVzdWx0ID0gdGhpcy5jYW5DYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWNhbkNhY2hlUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNhY2hlXzEuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tDYWNoZSA9IHRoaXMuZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICBibG9ja0NhY2hlW2lkZW50aWZpZXJdID0gcmVzdWx0O1xuICAgIH1cbiAgICBjYW5DYWNoZVJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICAvLyBjaGVjayByZXF1ZXN0IG1ldGhvZFxuICAgICAgICBpZiAoIWNhY2hlXzEuY2FuQ2FjaGUocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBibG9ja1RhZ1xuICAgICAgICBjb25zdCBibG9ja1RhZyA9IGNhY2hlXzEuYmxvY2tUYWdGb3JQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbiBiZSBjYWNoZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVzdWx0KHBheWxvYWQsIHJlc3VsdCkge1xuICAgICAgICAvLyBuZXZlciBjYWNoZSBlbXB0eSB2YWx1ZXMgKGUuZy4gdW5kZWZpbmVkKVxuICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRyYW5zYWN0aW9ucyBoYXZlIGJsb2NrIHJlZmVyZW5jZSBiZWZvcmUgY2FjaGluZ1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgJiZcbiAgICAgICAgICAgIFsnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJywgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnXS5pbmNsdWRlcyhwYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0IHx8XG4gICAgICAgICAgICAgICAgIXJlc3VsdC5ibG9ja0hhc2ggfHxcbiAgICAgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID09PVxuICAgICAgICAgICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlcyBhbGwgYmxvY2sgY2FjaGVzIHdpdGggYmxvY2sgbnVtYmVyIGxvd2VyIHRoYW4gYG9sZEJsb2NrSGV4YFxuICAgIGNsZWFyQmVmb3JlKG9sZEJsb2NrSGV4KSB7XG4gICAgICAgIGNvbnN0IG9sZEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KG9sZEJsb2NrSGV4LCAxNik7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jYWNoZSlcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcigobnVtKSA9PiBudW0gPCBvbGRCbG9ja051bWJlcilcbiAgICAgICAgICAgIC5mb3JFYWNoKChudW0pID0+IGRlbGV0ZSB0aGlzLmNhY2hlW251bV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSAtIE5vIFBvbGxpbmdCbG9ja1RyYWNrZXIgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAgICBjb25zdCBibG9ja0NhY2hlID0gbmV3IEJsb2NrQ2FjaGVTdHJhdGVneSgpO1xuICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSB7XG4gICAgICAgIHBlcm1hOiBibG9ja0NhY2hlLFxuICAgICAgICBibG9jazogYmxvY2tDYWNoZSxcbiAgICAgICAgZm9yazogYmxvY2tDYWNoZSxcbiAgICB9O1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIC8vIGFsbG93IGNhY2ggdG8gYmUgc2tpcHBlZCBpZiBzbyBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHJlcS5za2lwQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgdHlwZSBhbmQgbWF0Y2hpbmcgc3RyYXRlZ3lcbiAgICAgICAgY29uc3QgdHlwZSA9IGNhY2hlXzEuY2FjaGVUeXBlRm9yUGF5bG9hZChyZXEpO1xuICAgICAgICBjb25zdCBzdHJhdGVneSA9IHN0cmF0ZWdpZXNbdHlwZV07XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gc3RyYXRlZ3kgaW4gcGxhY2UsIHBhc3MgaXQgZG93biB0aGUgY2hhaW4uXG4gICAgICAgIGlmICghc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHN0cmF0ZWd5IGNhbid0IGNhY2hlIHRoaXMgcmVxdWVzdCwgaWdub3JlIGl0LlxuICAgICAgICBpZiAoIXN0cmF0ZWd5LmNhbkNhY2hlUmVxdWVzdChyZXEpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBibG9jayByZWZlcmVuY2UgKG51bWJlciBvciBrZXl3b3JkKVxuICAgICAgICBsZXQgYmxvY2tUYWcgPSBjYWNoZV8xLmJsb2NrVGFnRm9yUGF5bG9hZChyZXEpO1xuICAgICAgICBpZiAoIWJsb2NrVGFnKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIGxvZygnYmxvY2tUYWcgPSAlbywgcmVxID0gJW8nLCBibG9ja1RhZywgcmVxKTtcbiAgICAgICAgLy8gZ2V0IGV4YWN0IGJsb2NrIG51bWJlclxuICAgICAgICBsZXQgcmVxdWVzdGVkQmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gJ2VhcmxpZXN0Jykge1xuICAgICAgICAgICAgLy8gdGhpcyBqdXN0IGV4aXN0cyBmb3Igc3ltbWV0cnkgd2l0aCBcImxhdGVzdFwiXG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9ICcweDAwJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9ja1RhZyA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIC8vIGZldGNoIGxhdGVzdCBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGxvZygnRmV0Y2hpbmcgbGF0ZXN0IGJsb2NrIG51bWJlciB0byBkZXRlcm1pbmUgY2FjaGUga2V5Jyk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGNhY2hlIGJlZm9yZSBsYXRlc3QgYmxvY2tcbiAgICAgICAgICAgIGxvZygnQ2xlYXJpbmcgdmFsdWVzIHN0b3JlZCB1bmRlciBibG9jayBudW1iZXJzIGJlZm9yZSAlbycsIGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUuY2xlYXJCZWZvcmUobGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBoZXggbnVtYmVyXG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgICAgIGNvbnN0IGNhY2hlUmVzdWx0ID0gYXdhaXQgc3RyYXRlZ3kuZ2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FjaGUgbWlzc1xuICAgICAgICAgICAgLy8gd2FpdCBmb3Igb3RoZXIgbWlkZGxld2FyZSB0byBoYW5kbGUgcmVxdWVzdFxuICAgICAgICAgICAgbG9nKCdObyBjYWNoZSBzdG9yZWQgdW5kZXIgYmxvY2sgbnVtYmVyICVvLCBjYXJyeWluZyByZXF1ZXN0IGZvcndhcmQnLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgICAgIC8vIGFkZCByZXN1bHQgdG8gY2FjaGVcbiAgICAgICAgICAgIC8vIGl0J3Mgc2FmZSB0byBjYXN0IHJlcy5yZXN1bHQgYXMgQmxvY2ssIGR1ZSB0byBydW50aW1lIHR5cGUgY2hlY2tzXG4gICAgICAgICAgICAvLyBwZXJmb3JtZWQgd2hlbiBzdHJhdGVneS5zZXQgaXMgY2FsbGVkXG4gICAgICAgICAgICBsb2coJ1BvcHVsYXRpbmcgY2FjaGUgd2l0aCcsIHJlcyk7XG4gICAgICAgICAgICBhd2FpdCBzdHJhdGVneS5zZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmaWxsIGluIHJlc3VsdCBmcm9tIGNhY2hlXG4gICAgICAgICAgICBsb2coJ0NhY2hlIGhpdCwgcmV1c2luZyBjYWNoZSByZXN1bHQgc3RvcmVkIHVuZGVyIGJsb2NrIG51bWJlciAlbycsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSBjYWNoZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stY2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5mdW5jdGlvbiBjcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIF9yZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJld3JpdGUgYmxvY2tSZWYgdG8gYmxvY2stdHJhY2tlcidzIGJsb2NrIG51bWJlclxuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBpZiAocmVxLnBhcmFtcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgICAgIHJlcS5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXJlZi1yZXdyaXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdibG9jay1yZWYnKTtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZSh7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcInByb3ZpZGVyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZk1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9IGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KHJlcSk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja1JlZiA9IChfYiA9IChfYSA9IHJlcS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtibG9ja1JlZkluZGV4XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2xhdGVzdCc7XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmICE9PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgbG9nKCdibG9ja1JlZiBpcyBub3QgXCJsYXRlc3RcIiwgY2FycnlpbmcgcmVxdWVzdCBmb3J3YXJkJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2t1cCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgbG9nKGBibG9ja1JlZiBpcyBcImxhdGVzdFwiLCBzZXR0aW5nIHBhcmFtICR7YmxvY2tSZWZJbmRleH0gdG8gbGF0ZXN0IGJsb2NrICR7bGF0ZXN0QmxvY2tOdW1iZXJ9YCk7XG4gICAgICAgIC8vIGNyZWF0ZSBjaGlsZCByZXF1ZXN0IHdpdGggc3BlY2lmaWMgYmxvY2stcmVmXG4gICAgICAgIGNvbnN0IGNoaWxkUmVxdWVzdCA9IGNsb25lXzEuZGVmYXVsdChyZXEpO1xuICAgICAgICBpZiAoY2hpbGRSZXF1ZXN0LnBhcmFtcykge1xuICAgICAgICAgICAgY2hpbGRSZXF1ZXN0LnBhcmFtc1tibG9ja1JlZkluZGV4XSA9IGxhdGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmZvcm0gY2hpbGQgcmVxdWVzdFxuICAgICAgICBsb2coJ1BlcmZvcm1pbmcgYW5vdGhlciByZXF1ZXN0ICVvJywgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgY2hpbGRSZXMgPSBhd2FpdCBwaWZ5XzEuZGVmYXVsdChwcm92aWRlci5zZW5kQXN5bmMpLmNhbGwocHJvdmlkZXIsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgIC8vIGNvcHkgY2hpbGQgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICByZXMucmVzdWx0ID0gY2hpbGRSZXMucmVzdWx0O1xuICAgICAgICByZXMuZXJyb3IgPSBjaGlsZFJlcy5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stcmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdibG9jay10cmFja2VyLWluc3BlY3RvcicpO1xuY29uc3QgZnV0dXJlQmxvY2tSZWZSZXF1ZXN0cyA9IFtcbiAgICAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJyxcbiAgICAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG5dO1xuLy8gaW5zcGVjdCBpZiByZXNwb25zZSBjb250YWlucyBhIGJsb2NrIHJlZiBoaWdoZXIgdGhhbiBvdXIgbGF0ZXN0IGJsb2NrXG5mdW5jdGlvbiBjcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9KSB7XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWZ1dHVyZUJsb2NrUmVmUmVxdWVzdHMuaW5jbHVkZXMocmVxLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgLy8gYWJvcnQgaWYgbm8gcmVzdWx0IG9yIG5vIGJsb2NrIG51bWJlclxuICAgICAgICBpZiAoISgoX2EgPSByZXMucmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmxvY2tOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxvZygncmVzLnJlc3VsdC5ibG9ja051bWJlciBleGlzdHMsIHByb2NlZWRpbmcuIHJlcyA9ICVvJywgcmVzKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMucmVzdWx0LmJsb2NrTnVtYmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gaWYgbnVtYmVyIGlzIGhpZ2hlciwgc3VnZ2VzdCBibG9jay10cmFja2VyIGNoZWNrIGZvciBhIG5ldyBibG9ja1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQocmVzLnJlc3VsdC5ibG9ja051bWJlciwgMTYpO1xuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IElmIGdldEN1cnJlbnRCbG9jayByZXR1cm5zIG51bGwsIGN1cnJlbnRCbG9ja051bWJlciB3aWxsIGJlIE5hTiwgd2hpY2ggaXMgZmluZS5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChibG9ja1RyYWNrZXIuZ2V0Q3VycmVudEJsb2NrKCksIDE2KTtcbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+IGN1cnJlbnRCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGxvZygnYmxvY2tOdW1iZXIgZnJvbSByZXNwb25zZSBpcyBncmVhdGVyIHRoYW4gY3VycmVudCBibG9jayBudW1iZXIsIHJlZnJlc2hpbmcgY3VycmVudCBibG9jayBudW1iZXInKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBibG9ja1RyYWNrZXIuY2hlY2tGb3JMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stdHJhY2tlci1pbnNwZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSA9IGV4cG9ydHMuY3JlYXRlRmV0Y2hNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvdyAqL1xuY29uc3QgZmV0Y2ggPSBnbG9iYWwuZmV0Y2ggfHwgcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xuY29uc3QgYnRvYSA9IGdsb2JhbC5idG9hIHx8IHJlcXVpcmUoJ2J0b2EnKTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93ICovXG5jb25zdCBSRVRSSUFCTEVfRVJST1JTID0gW1xuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG4gICAgJ0dhdGV3YXkgdGltZW91dCcsXG4gICAgJ0VUSU1FRE9VVCcsXG4gICAgLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbiAgICAvLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcbiAgICAnZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHknLFxuICAgIC8vIGlnbm9yZSBlcnJvcnMgd2hlcmUgaHR0cCByZXEgZmFpbGVkIHRvIGVzdGFibGlzaFxuICAgICdGYWlsZWQgdG8gZmV0Y2gnLFxuXTtcbmZ1bmN0aW9uIGNyZWF0ZUZldGNoTWlkZGxld2FyZSh7IHJwY1VybCwgb3JpZ2luSHR0cEhlYWRlcktleSwgfSkge1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9ID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHtcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIG9yaWdpbkh0dHBIZWFkZXJLZXksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1O1xuICAgICAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMDtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoUmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaHR0cCBlcnJyb3JzXG4gICAgICAgICAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKTtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3Qm9keSA9IGF3YWl0IGZldGNoUmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgZmV0Y2hCb2R5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoQm9keSA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2hNaWRkbGV3YXJlIC0gZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHk6IFwiJHtyYXdCb2R5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBhbmQgZXhpdCByZXRyeSBsb29wXG4gICAgICAgICAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlLXRocm93IGVycm9yIGlmIG5vdCByZXRyaWFibGVcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hNaWRkbGV3YXJlID0gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlO1xuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICAgIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgICAgIGNhc2UgNDE4OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKTtcbiAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlVGltZW91dEVycm9yKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBib2R5KSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yIGNvZGVcbiAgICBpZiAoZmV0Y2hSZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBOb24tMjAwIHN0YXR1cyBjb2RlOiAnJHtmZXRjaFJlcy5zdGF0dXN9J2AsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHJwYyBlcnJvclxuICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgICAgICBkYXRhOiBib2R5LmVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgcmV0dXJuIGJvZHkucmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHsgcmVxLCBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJwY1VybCk7XG4gICAgY29uc3QgZmV0Y2hVcmwgPSBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybCk7XG4gICAgLy8gcHJlcGFyZSBwYXlsb2FkXG4gICAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICAgIH07XG4gICAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gICAgY29uc3Qgb3JpZ2luRG9tYWluID0gcmVxLm9yaWdpbjtcbiAgICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRQYXlsb2FkLFxuICAgIH07XG4gICAgLy8gZW5jb2RlZCBhdXRoIGRldGFpbHMgYXMgaGVhZGVyIChub3QgYWxsb3dlZCBpbiBmZXRjaCB1cmwpXG4gICAgaWYgKHBhcnNlZFVybC51c2VybmFtZSAmJiBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXV0aFN0cmluZyA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgICAgICAgY29uc3QgZW5jb2RlZEF1dGggPSBidG9hKGF1dGhTdHJpbmcpO1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmFzaWMgJHtlbmNvZGVkQXV0aH1gO1xuICAgIH1cbiAgICAvLyBvcHRpb25hbDogYWRkIHJlcXVlc3Qgb3JpZ2luIGFzIGhlYWRlclxuICAgIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzW29yaWdpbkh0dHBIZWFkZXJLZXldID0gb3JpZ2luRG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4geyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxO1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgcmVzdWx0ICs9IHBhcnNlZFVybC5wcm90b2NvbDtcbiAgICByZXN1bHQgKz0gYC8vJHtwYXJzZWRVcmwuaG9zdG5hbWV9YDtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgICAgcmVzdWx0ICs9IGA6JHtwYXJzZWRVcmwucG9ydH1gO1xuICAgIH1cbiAgICByZXN1bHQgKz0gYCR7cGFyc2VkVXJsLnBhdGhuYW1lfWA7XG4gICAgcmVzdWx0ICs9IGAke3BhcnNlZFVybC5zZWFyY2h9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGA7XG4gICAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gO1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlOiBtc2cgfSk7XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLWNhY2hlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1yZWYtcmV3cml0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stcmVmXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay10cmFja2VyLWluc3BlY3RvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmV0Y2hcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2luZmxpZ2h0LWNhY2hlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlckFzTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJGcm9tRW5naW5lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlckZyb21NaWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXRyeU9uRW1wdHlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhbGxldFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2luZmxpZ2h0LWNhY2hlJyk7XG5mdW5jdGlvbiBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSgpIHtcbiAgICBjb25zdCBpbmZsaWdodFJlcXVlc3RzID0ge307XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgY2FjaGVJZCwgaWYgY2FjaGVhYmxlXG4gICAgICAgIGNvbnN0IGNhY2hlSWQgPSBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocmVxKTtcbiAgICAgICAgLy8gaWYgbm90IGNhY2hlYWJsZSwgc2tpcFxuICAgICAgICBpZiAoIWNhY2hlSWQpIHtcbiAgICAgICAgICAgIGxvZygnUmVxdWVzdCBpcyBub3QgY2FjaGVhYmxlLCBwcm9jZWVkaW5nLiByZXEgPSAlbycsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBtYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICBsZXQgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gaWYgZm91bmQsIHdhaXQgZm9yIHRoZSBhY3RpdmUgcmVxdWVzdCB0byBiZSBoYW5kbGVkXG4gICAgICAgIGlmIChhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lciBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGhhbmRsZSBjb3B5aW5nIHRoZSByZXN1bHQgYW5kIHJlcXVlc3QgZmllbGRzXG4gICAgICAgICAgICBsb2coJ1J1bm5pbmcgJWkgaGFuZGxlcihzKSBmb3IgcmVxdWVzdCAlbycsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5sZW5ndGgsIHJlcSk7XG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIHJlc3BvbnNlIGhhbmRsZXIgYXJyYXkgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW107XG4gICAgICAgIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF0gPSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnM7XG4gICAgICAgIC8vIGFsbG93IHJlcXVlc3QgdG8gYmUgaGFuZGxlZCBub3JtYWxseVxuICAgICAgICBsb2coJ0NhcnJ5aW5nIG9yaWdpbmFsIHJlcXVlc3QgZm9yd2FyZCAlbycsIHJlcSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIC8vIGNsZWFyIGluZmxpZ2h0IHJlcXVlc3RzXG4gICAgICAgIGRlbGV0ZSBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgICAgICAvLyBzY2hlZHVsZSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgdG8gYmUgaGFuZGxlZFxuICAgICAgICBsb2coJ1J1bm5pbmcgJWkgY29sbGVjdGVkIGhhbmRsZXIocykgZm9yIHJlcXVlc3QgJW8nLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMubGVuZ3RoLCByZXEpO1xuICAgICAgICBoYW5kbGVBY3RpdmVSZXF1ZXN0KHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKTtcbiAgICAgICAgLy8gY29tcGxldGVcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICBjb25zdCB7IHJlc29sdmUsIHByb21pc2UgfSA9IGRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMucHVzaCgoaGFuZGxlZFJlcykgPT4ge1xuICAgICAgICAgICAgLy8gYXBwZW5kIGEgY29weSBvZiB0aGUgcmVzdWx0IGFuZCBlcnJvciB0byB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSBjbG9uZV8xLmRlZmF1bHQoaGFuZGxlZFJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgcmVzLmVycm9yID0gY2xvbmVfMS5kZWZhdWx0KGhhbmRsZWRSZXMuZXJyb3IpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgLy8gdXNlIHNldFRpbWVvdXQgc28gd2UgY2FuIHJlc29sdmUgb3VyIG9yaWdpbmFsIHJlcXVlc3QgZmlyc3RcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXRjaCBlcnJvciBzbyBhbGwgcmVxdWVzdHMgYXJlIGhhbmRsZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSA9IGNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlO1xuZnVuY3Rpb24gZGVmZXJyZWRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlc29sdmUsIHByb21pc2UgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmxpZ2h0LWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLnByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1vZHVsZUxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXI7IH0gfSk7XG5leHBvcnRzLnByb2plY3RMb2dnZXIgPSB1dGlsc18xLmNyZWF0ZVByb2plY3RMb2dnZXIoJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZSA9IGV4cG9ydHMucHJvdmlkZXJBc01pZGRsZXdhcmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICAgIHJldHVybiAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgICAgIHByb3ZpZGVyLnNlbmRBc3luYyhyZXEsIChlcnIsIHByb3ZpZGVyUmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIGFueSBlcnJvclxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSBwcm92aWRlciByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgcHJvdmlkZXJSZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5wcm92aWRlckFzTWlkZGxld2FyZSA9IHByb3ZpZGVyQXNNaWRkbGV3YXJlO1xuZnVuY3Rpb24gZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgICAgICBwcm92aWRlci5zZW5kKHJlcSwgKGVyciwgcHJvdmlkZXJSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgYW55IGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSBwcm92aWRlciByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgcHJvdmlkZXJSZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5ldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZSA9IGV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJBc01pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3ZpZGVyRnJvbUVuZ2luZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0KCk7XG4gICAgLy8gaGFuZGxlIGJvdGggcnBjIHNlbmQgbWV0aG9kc1xuICAgIHByb3ZpZGVyLnNlbmRBc3luYyA9IChyZXEsIGNiKSA9PiB7XG4gICAgICAgIGVuZ2luZS5oYW5kbGUocmVxLCBjYik7XG4gICAgfTtcbiAgICBwcm92aWRlci5zZW5kID0gKHJlcSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgY2FsbGJhY2sgdG8gXCJzZW5kXCIgbWV0aG9kLicpO1xuICAgICAgICB9XG4gICAgICAgIGVuZ2luZS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgICBpZiAoZW5naW5lLm9uKSB7XG4gICAgICAgIGVuZ2luZS5vbignbm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoJ2RhdGEnLCBudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbn1cbmV4cG9ydHMucHJvdmlkZXJGcm9tRW5naW5lID0gcHJvdmlkZXJGcm9tRW5naW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJGcm9tRW5naW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm92aWRlckZyb21NaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgcHJvdmlkZXJGcm9tRW5naW5lXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlckZyb21FbmdpbmVcIik7XG5mdW5jdGlvbiBwcm92aWRlckZyb21NaWRkbGV3YXJlKG1pZGRsZXdhcmUpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcganNvbl9ycGNfZW5naW5lXzEuSnNvblJwY0VuZ2luZSgpO1xuICAgIGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJGcm9tRW5naW5lXzEucHJvdmlkZXJGcm9tRW5naW5lKGVuZ2luZSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZXhwb3J0cy5wcm92aWRlckZyb21NaWRkbGV3YXJlID0gcHJvdmlkZXJGcm9tTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyRnJvbU1pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbi8vXG4vLyBSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIHdpbGwgcmV0cnkgYW55IHJlcXVlc3Qgd2l0aCBhbiBlbXB0eSByZXNwb25zZSB0aGF0IGhhc1xuLy8gYSBudW1iZXJlZCBibG9jayByZWZlcmVuY2UgYXQgb3IgbG93ZXIgdGhhbiB0aGUgYmxvY2tUcmFja2VyJ3MgbGF0ZXN0IGJsb2NrLlxuLy8gSXRzIHVzZWZ1bCBmb3IgZGVhbGluZyB3aXRoIGxvYWQtYmFsYW5jZWQgZXRoZXJldW0gSlNPTiBSUENcbi8vIG5vZGVzIHRoYXQgYXJlIG5vdCBhbHdheXMgaW4gc3luYyB3aXRoIGVhY2ggb3RoZXIuXG4vL1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ3JldHJ5LW9uLWVtcHR5Jyk7XG4vLyBlbXB0eSB2YWx1ZXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkXG4vLyBgPG5pbD5gIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8xNjkyNVxuY29uc3QgZW1wdHlWYWx1ZXMgPSBbXG4gICAgdW5kZWZpbmVkLFxuICAgIG51bGwsXG4gICAgJ1xcdTAwM2NuaWxcXHUwMDNlJyxcbl07XG5mdW5jdGlvbiBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcInByb3ZpZGVyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9IGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KHJlcSk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vdCBleGFjdCBibG9jayByZWZlcmVuY2VzXG4gICAgICAgIGxldCBibG9ja1JlZiA9IChfYSA9IHJlcS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtibG9ja1JlZkluZGV4XTtcbiAgICAgICAgLy8gb21pdHRlZCBibG9ja1JlZiBpbXBsaWVzIFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsb2NrUmVmID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub24tbnVtYmVyIGJsb2NrIHJlZmVyZW5jZVxuICAgICAgICBpZiAoWydsYXRlc3QnLCAncGVuZGluZyddLmluY2x1ZGVzKGJsb2NrUmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIGJsb2NrIHJlZmVybmNlIGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgICAgICBjb25zdCBibG9ja1JlZk51bWJlciA9IE51bWJlci5wYXJzZUludChibG9ja1JlZi5zbGljZSgyKSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJsb2NrUmVmTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVySGV4ID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGxhdGVzdEJsb2NrTnVtYmVySGV4LnNsaWNlKDIpLCAxNik7XG4gICAgICAgIC8vIHNraXAgaWYgcmVxdWVzdCBibG9jayBudW1iZXIgaXMgaGlnaGVyIHRoYW4gY3VycmVudFxuICAgICAgICBpZiAoYmxvY2tSZWZOdW1iZXIgPiBsYXRlc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgbG9nKCdSZXF1ZXN0ZWQgYmxvY2sgbnVtYmVyICVvIGlzIGhpZ2hlciB0aGFuIGxhdGVzdCBibG9jayBudW1iZXIgJW8sIGZhbGxpbmcgdGhyb3VnaCB0byBvcmlnaW5hbCByZXF1ZXN0JywgYmxvY2tSZWZOdW1iZXIsIGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdSZXF1ZXN0ZWQgYmxvY2sgbnVtYmVyICVvIGlzIG5vdCBoaWdoZXIgdGhhbiBsYXRlc3QgYmxvY2sgbnVtYmVyICVvLCB0cnlpbmcgcmVxdWVzdCB1bnRpbCBub24tZW1wdHkgcmVzcG9uc2UgaXMgcmVjZWl2ZWQnLCBibG9ja1JlZk51bWJlciwgbGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAvLyBjcmVhdGUgY2hpbGQgcmVxdWVzdCB3aXRoIHNwZWNpZmljIGJsb2NrLXJlZlxuICAgICAgICBjb25zdCBjaGlsZFJlcXVlc3QgPSBjbG9uZV8xLmRlZmF1bHQocmVxKTtcbiAgICAgICAgLy8gYXR0ZW1wdCBjaGlsZCByZXF1ZXN0IHVudGlsIG5vbi1lbXB0eSByZXNwb25zZSBpcyByZWNlaXZlZFxuICAgICAgICBjb25zdCBjaGlsZFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoMTAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxvZygnUGVyZm9ybWluZyByZXF1ZXN0ICVvJywgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRSZXNwb25zZSA9IGF3YWl0IHBpZnlfMS5kZWZhdWx0KHByb3ZpZGVyLnNlbmRBc3luYykuY2FsbChwcm92aWRlciwgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGxvZygnUmVzcG9uc2UgaXMgJW8nLCBhdHRlbXB0UmVzcG9uc2UpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlc3VsdFxuICAgICAgICAgICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKGF0dGVtcHRSZXNwb25zZS5yZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gZW1wdHkgcmVzcG9uc2UgXCIke0pTT04uc3RyaW5naWZ5KGF0dGVtcHRSZXNwb25zZSl9XCIgZm9yIHJlcXVlc3QgXCIke0pTT04uc3RyaW5naWZ5KGNoaWxkUmVxdWVzdCl9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdHRlbXB0UmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coJ0NvcHlpbmcgcmVzdWx0ICVvIGFuZCBlcnJvciAlbycsIGNoaWxkUmVzcG9uc2UucmVzdWx0LCBjaGlsZFJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgLy8gY29weSBjaGlsZCByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgIHJlcy5yZXN1bHQgPSBjaGlsZFJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgcmVzLmVycm9yID0gY2hpbGRSZXNwb25zZS5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSA9IGNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmU7XG5hc3luYyBmdW5jdGlvbiByZXRyeShtYXhSZXRyaWVzLCBhc3luY0ZuKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1heFJldHJpZXM7IGluZGV4KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhc3luY0ZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nKCcoY2FsbCAlaSkgUmVxdWVzdCBmYWlsZWQsIHdhaXRpbmcgMXMgdG8gcmV0cnkgYWdhaW4uLi4nLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dCgxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2coJ1JldHJpZXMgZXhoYXVzdGVkJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gcmV0cmllcyBleGhhdXN0ZWQnKTtcbn1cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5T25FbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FjaGVUeXBlRm9yUGF5bG9hZCA9IGV4cG9ydHMuYmxvY2tUYWdQYXJhbUluZGV4ID0gZXhwb3J0cy5wYXJhbXNXaXRob3V0QmxvY2tUYWcgPSBleHBvcnRzLmJsb2NrVGFnRm9yUGF5bG9hZCA9IGV4cG9ydHMuY2FuQ2FjaGUgPSBleHBvcnRzLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQgPSB2b2lkIDA7XG5jb25zdCBqc29uX3N0YWJsZV9zdHJpbmdpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1zdGFibGUtc3RyaW5naWZ5XCIpKTtcbmZ1bmN0aW9uIGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCwgc2tpcEJsb2NrUmVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNpbXBsZVBhcmFtcyA9IHNraXBCbG9ja1JlZlxuICAgICAgICA/IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKVxuICAgICAgICA6IChfYSA9IHBheWxvYWQucGFyYW1zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBpZiAoY2FuQ2FjaGUocGF5bG9hZCkpIHtcbiAgICAgICAgcmV0dXJuIGAke3BheWxvYWQubWV0aG9kfToke2pzb25fc3RhYmxlX3N0cmluZ2lmeV8xLmRlZmF1bHQoc2ltcGxlUGFyYW1zKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZCA9IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQ7XG5mdW5jdGlvbiBjYW5DYWNoZShwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNhY2hlVHlwZUZvclBheWxvYWQocGF5bG9hZCkgIT09ICduZXZlcic7XG59XG5leHBvcnRzLmNhbkNhY2hlID0gY2FuQ2FjaGU7XG5mdW5jdGlvbiBibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZCkge1xuICAgIGlmICghcGF5bG9hZC5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtc1tpbmRleF07XG59XG5leHBvcnRzLmJsb2NrVGFnRm9yUGF5bG9hZCA9IGJsb2NrVGFnRm9yUGF5bG9hZDtcbmZ1bmN0aW9uIHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXlsb2FkLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXM7XG4gICAgfVxuICAgIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDAsIGluZGV4KTtcbn1cbmV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gcGFyYW1zV2l0aG91dEJsb2NrVGFnO1xuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDJcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMVxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMFxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gYmxvY2tUYWdcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5ibG9ja1RhZ1BhcmFtSW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXg7XG5mdW5jdGlvbiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGNhY2hlIHBlcm1hbmVudGx5XG4gICAgICAgIGNhc2UgJ3dlYjNfY2xpZW50VmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlTExMJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgICAgIGNhc2UgJ3NoaF92ZXJzaW9uJzpcbiAgICAgICAgY2FzZSAndGVzdF9wZXJtYUNhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAncGVybWEnO1xuICAgICAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAndGVzdF9mb3JrQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuICdmb3JrJztcbiAgICAgICAgLy8gY2FjaGUgZm9yIGJsb2NrXG4gICAgICAgIGNhc2UgJ2V0aF9nYXNQcmljZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICBjYXNlICdldGhfZXN0aW1hdGVHYXMnOlxuICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRMb2dzJzpcbiAgICAgICAgY2FzZSAndGVzdF9ibG9ja0NhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2snO1xuICAgICAgICAvLyBuZXZlciBjYWNoZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICduZXZlcic7XG4gICAgfVxufVxuZXhwb3J0cy5jYWNoZVR5cGVGb3JQYXlsb2FkID0gY2FjaGVUeXBlRm9yUGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVdhbGxldE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBzaWdVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAbWV0YW1hc2svZXRoLXNpZy11dGlsXCIpKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5mdW5jdGlvbiBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlKHsgZ2V0QWNjb3VudHMsIHByb2Nlc3NEZWNyeXB0TWVzc2FnZSwgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXksIHByb2Nlc3NFdGhTaWduTWVzc2FnZSwgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSwgcHJvY2Vzc1RyYW5zYWN0aW9uLCBwcm9jZXNzU2lnblRyYW5zYWN0aW9uLCBwcm9jZXNzVHlwZWRNZXNzYWdlLCBwcm9jZXNzVHlwZWRNZXNzYWdlVjMsIHByb2Nlc3NUeXBlZE1lc3NhZ2VWNCwgfSkge1xuICAgIGlmICghZ2V0QWNjb3VudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmdldEFjY291bnRzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgICAgICAvLyBhY2NvdW50IGxvb2t1cHNcbiAgICAgICAgZXRoX2FjY291bnRzOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUobG9va3VwQWNjb3VudHMpLFxuICAgICAgICBldGhfY29pbmJhc2U6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShsb29rdXBEZWZhdWx0QWNjb3VudCksXG4gICAgICAgIC8vIHR4IHNpZ25hdHVyZXNcbiAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNlbmRUcmFuc2FjdGlvbiksXG4gICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHJhbnNhY3Rpb24pLFxuICAgICAgICAvLyBtZXNzYWdlIHNpZ25hdHVyZXNcbiAgICAgICAgZXRoX3NpZ246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShldGhTaWduKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGE6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHlwZWREYXRhKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjM6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHlwZWREYXRhVjMpLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92NDoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UeXBlZERhdGFWNCksXG4gICAgICAgIHBlcnNvbmFsX3NpZ246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShwZXJzb25hbFNpZ24pLFxuICAgICAgICBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleToganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGVuY3J5cHRpb25QdWJsaWNLZXkpLFxuICAgICAgICBldGhfZGVjcnlwdDoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGRlY3J5cHRNZXNzYWdlKSxcbiAgICAgICAgcGVyc29uYWxfZWNSZWNvdmVyOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUocGVyc29uYWxSZWNvdmVyKSxcbiAgICB9KTtcbiAgICAvL1xuICAgIC8vIGFjY291bnQgbG9va3Vwc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9va3VwQWNjb3VudHMocmVxLCByZXMpIHtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRzKHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvb2t1cERlZmF1bHRBY2NvdW50KHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGFjY291bnRzWzBdIHx8IG51bGw7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gdHJhbnNhY3Rpb24gc2lnbmF0dXJlc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFRyYW5zYWN0aW9uKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSByZXEucGFyYW1zWzBdIHx8IHt9O1xuICAgICAgICB0eFBhcmFtcy5mcm9tID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIodHhQYXJhbXMuZnJvbSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UGFyYW1zID0gcmVxLnBhcmFtc1swXSB8fCB7fTtcbiAgICAgICAgdHhQYXJhbXMuZnJvbSA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHR4UGFyYW1zLmZyb20sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzU2lnblRyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIG1lc3NhZ2Ugc2lnbmF0dXJlc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gZXRoU2lnbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NFdGhTaWduTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0V0aFNpZ25NZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMV0sIHJlcSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjEnO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YVYzKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZVYzKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1YzJztcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YVY0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZVY0KSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1Y0JztcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0KG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcGVyc29uYWxTaWduKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb2Nlc3Mgbm9ybWFsbHlcbiAgICAgICAgY29uc3QgZmlyc3RQYXJhbSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IHNlY29uZFBhcmFtID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgLy8gbm9uLXN0YW5kYXJkIFwiZXh0cmFQYXJhbXNcIiB0byBiZSBhcHBlbmRlZCB0byBvdXIgXCJtc2dQYXJhbXNcIiBvYmpcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICAvLyBXZSBpbml0aWFsbHkgaW5jb3JyZWN0bHkgb3JkZXJlZCB0aGVzZSBwYXJhbWV0ZXJzLlxuICAgICAgICAvLyBUbyBncmFjZWZ1bGx5IHJlc3BlY3QgdXNlcnMgd2hvIGFkb3B0ZWQgdGhpcyBBUEkgZWFybHksXG4gICAgICAgIC8vIHdlIGFyZSBjdXJyZW50bHkgZ3JhY2VmdWxseSByZWNvdmVyaW5nIGZyb20gdGhlIHdyb25nIHBhcmFtIG9yZGVyXG4gICAgICAgIC8vIHdoZW4gaXQgaXMgY2xlYXJseSBpZGVudGlmaWFibGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgd2hlbiB0aGUgZmlyc3QgcGFyYW0gaXMgZGVmaW5pdGVseSBhbiBhZGRyZXNzLFxuICAgICAgICAvLyBhbmQgdGhlIHNlY29uZCBwYXJhbSBpcyBkZWZpbml0ZWx5IG5vdCwgYnV0IGlzIGhleC5cbiAgICAgICAgbGV0IGFkZHJlc3MsIG1lc3NhZ2U7XG4gICAgICAgIGlmIChyZXNlbWJsZXNBZGRyZXNzKGZpcnN0UGFyYW0pICYmICFyZXNlbWJsZXNBZGRyZXNzKHNlY29uZFBhcmFtKSkge1xuICAgICAgICAgICAgbGV0IHdhcm5pbmcgPSBgVGhlIGV0aF9wZXJzb25hbFNpZ24gbWV0aG9kIHJlcXVpcmVzIHBhcmFtcyBvcmRlcmVkIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBbbWVzc2FnZSwgYWRkcmVzc10uIFRoaXMgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbmNvcnJlY3RseSwgYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYGFuZCBoYXMgYmVlbiBjb3JyZWN0ZWQgYXV0b21hdGljYWxseS4gYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYFBsZWFzZSBzd2l0Y2ggdGhpcyBwYXJhbSBvcmRlciBmb3Igc21vb3RoIGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuYDtcbiAgICAgICAgICAgIHJlcy53YXJuaW5nID0gd2FybmluZztcbiAgICAgICAgICAgIGFkZHJlc3MgPSBmaXJzdFBhcmFtO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHNlY29uZFBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZpcnN0UGFyYW07XG4gICAgICAgICAgICBhZGRyZXNzID0gc2Vjb25kUGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKGFkZHJlc3MsIHJlcSk7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF0b21pYy11cGRhdGVzXG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzUGVyc29uYWxNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcGVyc29uYWxSZWNvdmVyKHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoe1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBzaWduZXJBZGRyZXNzO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBlbmNyeXB0aW9uUHVibGljS2V5KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5KGFkZHJlc3MsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRNZXNzYWdlKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0RlY3J5cHRNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzFdLCByZXEpO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IGNpcGhlcnRleHQgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHV0aWxpdHlcbiAgICAvL1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUga2V5aG9sZGVyIGFkZHJlc3MsIGFuZCByZXR1cm5zIGEgbm9ybWFsaXplZCAoaS5lLiBsb3dlcmNhc2UpXG4gICAgICogY29weSBvZiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxIC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG5vcm1hbGl6ZWQgYWRkcmVzcywgaWYgdmFsaWQuIE90aGVyd2lzZSwgdGhyb3dzXG4gICAgICogYW4gZXJyb3JcbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihhZGRyZXNzLCByZXEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgYWRkcmVzcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICByZXNlbWJsZXNBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgYWRkcmVzcyBpcyBpbmNsdWRlZCBpbiBwcm92aWRlZCBhY2NvdW50cy4gYHN1cHByZXNzVW5hdXRob3JpemVkOiBmYWxzZWAgaXMgcGFzc2VkIHRvIGBnZXRBY2NvdW50c2BcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgYW4gXCJ1bmF1dGhvcml6ZWRcIiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHJlcXVlc3RlciBkb2VzIG5vdCBoYXZlIHRoZSBgZXRoX2FjY291bnRzYFxuICAgICAgICAgICAgLy8gcGVybWlzc2lvbi5cbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxLCB7XG4gICAgICAgICAgICAgICAgc3VwcHJlc3NVbmF1dGhvcml6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQWNjb3VudHMgPSBhY2NvdW50cy5tYXAoKF9hZGRyZXNzKSA9PiBfYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRBY2NvdW50cy5pbmNsdWRlcyhub3JtYWxpemVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBwYXJhbWV0ZXJzOiBtdXN0IHByb3ZpZGUgYW4gRXRoZXJldW0gYWRkcmVzcy5gLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZVdhbGxldE1pZGRsZXdhcmUgPSBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlO1xuZnVuY3Rpb24gcmVzZW1ibGVzQWRkcmVzcyhzdHIpIHtcbiAgICAvLyBoZXggcHJlZml4IDIgKyAyMCBieXRlc1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAyICsgMjAgKiAyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRzKSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IFAgPSBvcHRzLnByb21pc2VNb2R1bGU7XG5cdGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0cy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMudW5zaGlmdChlcnIpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvYmosIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBmaWx0ZXIgPSBrZXkgPT4ge1xuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHRsZXQgcmV0O1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuXHRcdGNvbnN0IHggPSBvYmpba2V5XTtcblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIG9wdHMpIDogeDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdibG9jay1jYWNoZScpO1xuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW3VuZGVmaW5lZCwgbnVsbCwgJ1xcdTAwM2NuaWxcXHUwMDNlJ107XG4vL1xuLy8gQ2FjaGUgU3RyYXRlZ2llc1xuLy9cbmNsYXNzIEJsb2NrQ2FjaGVTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgZ2V0QmxvY2tDYWNoZShibG9ja051bWJlckhleCkge1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChibG9ja051bWJlckhleCwgMTYpO1xuICAgICAgICBsZXQgYmxvY2tDYWNoZSA9IHRoaXMuY2FjaGVbYmxvY2tOdW1iZXJdO1xuICAgICAgICAvLyBjcmVhdGUgbmV3IGNhY2hlIGlmIG5lY2VzYXJ5XG4gICAgICAgIGlmICghYmxvY2tDYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVbYmxvY2tOdW1iZXJdID0gbmV3Q2FjaGU7XG4gICAgICAgICAgICBibG9ja0NhY2hlID0gbmV3Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrQ2FjaGU7XG4gICAgfVxuICAgIGFzeW5jIGdldChyZXF1ZXN0LCByZXF1ZXN0ZWRCbG9ja051bWJlcikge1xuICAgICAgICAvLyBsb29rdXAgYmxvY2sgY2FjaGVcbiAgICAgICAgY29uc3QgYmxvY2tDYWNoZSA9IHRoaXMuZ2V0QmxvY2tDYWNoZShyZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIC8vIGxvb2t1cCBwYXlsb2FkIGluIGJsb2NrIGNhY2hlXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QocmVxdWVzdCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyID8gYmxvY2tDYWNoZVtpZGVudGlmaWVyXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgc2V0KHJlcXVlc3QsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCByZXN1bHQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIGNhY2hlZCB0aGlzIHJlc3VsdFxuICAgICAgICBjb25zdCBjYW5DYWNoZVJlc3VsdCA9IHRoaXMuY2FuQ2FjaGVSZXN1bHQocmVxdWVzdCwgcmVzdWx0KTtcbiAgICAgICAgaWYgKCFjYW5DYWNoZVJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWUgaW4gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QocmVxdWVzdCwgdHJ1ZSk7XG4gICAgICAgIGlmICghaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrQ2FjaGUgPSB0aGlzLmdldEJsb2NrQ2FjaGUocmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICBibG9ja0NhY2hlW2lkZW50aWZpZXJdID0gcmVzdWx0O1xuICAgIH1cbiAgICBjYW5DYWNoZVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICAvLyBjaGVjayByZXF1ZXN0IG1ldGhvZFxuICAgICAgICBpZiAoIWNhY2hlXzEuY2FuQ2FjaGUocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYmxvY2tUYWdcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSBjYWNoZV8xLmJsb2NrVGFnRm9yUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYW4gYmUgY2FjaGVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYW5DYWNoZVJlc3VsdChyZXF1ZXN0LCByZXN1bHQpIHtcbiAgICAgICAgLy8gbmV2ZXIgY2FjaGUgZW1wdHkgdmFsdWVzIChlLmcuIHVuZGVmaW5lZClcbiAgICAgICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0cmFuc2FjdGlvbnMgaGF2ZSBibG9jayByZWZlcmVuY2UgYmVmb3JlIGNhY2hpbmdcbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kICYmXG4gICAgICAgICAgICBbJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0J10uaW5jbHVkZXMocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCB8fFxuICAgICAgICAgICAgICAgICFyZXN1bHQuYmxvY2tIYXNoIHx8XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9PT1cbiAgICAgICAgICAgICAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHJlbW92ZXMgYWxsIGJsb2NrIGNhY2hlcyB3aXRoIGJsb2NrIG51bWJlciBsb3dlciB0aGFuIGBvbGRCbG9ja0hleGBcbiAgICBjbGVhckJlZm9yZShvbGRCbG9ja0hleCkge1xuICAgICAgICBjb25zdCBvbGRCbG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChvbGRCbG9ja0hleCwgMTYpO1xuICAgICAgICAvLyBjbGVhciBvbGQgY2FjaGVzXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY2FjaGUpXG4gICAgICAgICAgICAubWFwKE51bWJlcilcbiAgICAgICAgICAgIC5maWx0ZXIoKG51bSkgPT4gbnVtIDwgb2xkQmxvY2tOdW1iZXIpXG4gICAgICAgICAgICAuZm9yRWFjaCgobnVtKSA9PiBkZWxldGUgdGhpcy5jYWNoZVtudW1dKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUgLSBObyBQb2xsaW5nQmxvY2tUcmFja2VyIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgY2FjaGluZyBzdHJhdGVnaWVzXG4gICAgY29uc3QgYmxvY2tDYWNoZSA9IG5ldyBCbG9ja0NhY2hlU3RyYXRlZ3koKTtcbiAgICBjb25zdCBzdHJhdGVnaWVzID0ge1xuICAgICAgICBbY2FjaGVfMS5DYWNoZVN0cmF0ZWd5LlBlcm1hbmVudF06IGJsb2NrQ2FjaGUsXG4gICAgICAgIFtjYWNoZV8xLkNhY2hlU3RyYXRlZ3kuQmxvY2tdOiBibG9ja0NhY2hlLFxuICAgICAgICBbY2FjaGVfMS5DYWNoZVN0cmF0ZWd5LkZvcmtdOiBibG9ja0NhY2hlLFxuICAgICAgICBbY2FjaGVfMS5DYWNoZVN0cmF0ZWd5Lk5ldmVyXTogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0eXBlIGFuZCBtYXRjaGluZyBzdHJhdGVneVxuICAgICAgICBjb25zdCB0eXBlID0gY2FjaGVfMS5jYWNoZVR5cGVGb3JNZXRob2QocmVxLm1ldGhvZCk7XG4gICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gc3RyYXRlZ2llc1t0eXBlXTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBzdHJhdGVneSBpbiBwbGFjZSwgcGFzcyBpdCBkb3duIHRoZSBjaGFpbi5cbiAgICAgICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc3RyYXRlZ3kgY2FuJ3QgY2FjaGUgdGhpcyByZXF1ZXN0LCBpZ25vcmUgaXQuXG4gICAgICAgIGlmICghc3RyYXRlZ3kuY2FuQ2FjaGVSZXF1ZXN0KHJlcSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGJsb2NrIHJlZmVyZW5jZSAobnVtYmVyIG9yIGtleXdvcmQpXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCbG9ja1RhZyA9IGNhY2hlXzEuYmxvY2tUYWdGb3JSZXF1ZXN0KHJlcSk7XG4gICAgICAgIGNvbnN0IGJsb2NrVGFnID0gcmVxdWVzdEJsb2NrVGFnICYmIHR5cGVvZiByZXF1ZXN0QmxvY2tUYWcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHJlcXVlc3RCbG9ja1RhZ1xuICAgICAgICAgICAgOiAnbGF0ZXN0JztcbiAgICAgICAgbG9nKCdibG9ja1RhZyA9ICVvLCByZXEgPSAlbycsIGJsb2NrVGFnLCByZXEpO1xuICAgICAgICAvLyBnZXQgZXhhY3QgYmxvY2sgbnVtYmVyXG4gICAgICAgIGxldCByZXF1ZXN0ZWRCbG9ja051bWJlcjtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSAnZWFybGllc3QnKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGp1c3QgZXhpc3RzIGZvciBzeW1tZXRyeSB3aXRoIFwibGF0ZXN0XCJcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gJzB4MDAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrVGFnID09PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgLy8gZmV0Y2ggbGF0ZXN0IGJsb2NrIG51bWJlclxuICAgICAgICAgICAgbG9nKCdGZXRjaGluZyBsYXRlc3QgYmxvY2sgbnVtYmVyIHRvIGRldGVybWluZSBjYWNoZSBrZXknKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgICAgICAvLyBjbGVhciBhbGwgY2FjaGUgYmVmb3JlIGxhdGVzdCBibG9ja1xuICAgICAgICAgICAgbG9nKCdDbGVhcmluZyB2YWx1ZXMgc3RvcmVkIHVuZGVyIGJsb2NrIG51bWJlcnMgYmVmb3JlICVvJywgbGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgYmxvY2tDYWNoZS5jbGVhckJlZm9yZShsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9IGxhdGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGhleCBudW1iZXJcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kIG9uIGEgaGl0LCBjb250aW51ZSBvbiBhIG1pc3NcbiAgICAgICAgY29uc3QgY2FjaGVSZXN1bHQgPSBhd2FpdCBzdHJhdGVneS5nZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGlmIChjYWNoZVJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjYWNoZSBtaXNzXG4gICAgICAgICAgICAvLyB3YWl0IGZvciBvdGhlciBtaWRkbGV3YXJlIHRvIGhhbmRsZSByZXF1ZXN0XG4gICAgICAgICAgICBsb2coJ05vIGNhY2hlIHN0b3JlZCB1bmRlciBibG9jayBudW1iZXIgJW8sIGNhcnJ5aW5nIHJlcXVlc3QgZm9yd2FyZCcsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAgICAgLy8gYWRkIHJlc3VsdCB0byBjYWNoZVxuICAgICAgICAgICAgLy8gaXQncyBzYWZlIHRvIGNhc3QgcmVzLnJlc3VsdCBhcyBCbG9jaywgZHVlIHRvIHJ1bnRpbWUgdHlwZSBjaGVja3NcbiAgICAgICAgICAgIC8vIHBlcmZvcm1lZCB3aGVuIHN0cmF0ZWd5LnNldCBpcyBjYWxsZWRcbiAgICAgICAgICAgIGxvZygnUG9wdWxhdGluZyBjYWNoZSB3aXRoJywgcmVzKTtcbiAgICAgICAgICAgIGF3YWl0IHN0cmF0ZWd5LnNldChyZXEsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCByZXMucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbGwgaW4gcmVzdWx0IGZyb20gY2FjaGVcbiAgICAgICAgICAgIGxvZygnQ2FjaGUgaGl0LCByZXVzaW5nIGNhY2hlIHJlc3VsdCBzdG9yZWQgdW5kZXIgYmxvY2sgbnVtYmVyICVvJywgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGNhY2hlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgX3JlcywgbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgocmVxLm1ldGhvZCk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vdCBcImxhdGVzdFwiXG4gICAgICAgIGxldCBibG9ja1JlZiA9IEFycmF5LmlzQXJyYXkocmVxLnBhcmFtcylcbiAgICAgICAgICAgID8gcmVxLnBhcmFtc1tibG9ja1JlZkluZGV4XVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIG9taXR0ZWQgYmxvY2tSZWYgaW1wbGllcyBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibG9ja1JlZiA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1JlZiAhPT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV3cml0ZSBibG9ja1JlZiB0byBibG9jay10cmFja2VyJ3MgYmxvY2sgbnVtYmVyXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICAgICAgICAgICAgcmVxLnBhcmFtc1tibG9ja1JlZkluZGV4XSA9IGxhdGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stcmVmLXJld3JpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbmNvbnN0IHBpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGlmeVwiKSk7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2Jsb2NrLXJlZicpO1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwicHJvdmlkZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleChyZXEubWV0aG9kKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmID0gQXJyYXkuaXNBcnJheShyZXEucGFyYW1zKVxuICAgICAgICAgICAgPyAoX2EgPSByZXEucGFyYW1zW2Jsb2NrUmVmSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnbGF0ZXN0J1xuICAgICAgICAgICAgOiAnbGF0ZXN0JztcbiAgICAgICAgLy8gc2tpcCBpZiBub3QgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICBsb2coJ2Jsb2NrUmVmIGlzIG5vdCBcImxhdGVzdFwiLCBjYXJyeWluZyByZXF1ZXN0IGZvcndhcmQnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9va3VwIGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBsb2coYGJsb2NrUmVmIGlzIFwibGF0ZXN0XCIsIHNldHRpbmcgcGFyYW0gJHtibG9ja1JlZkluZGV4fSB0byBsYXRlc3QgYmxvY2sgJHtsYXRlc3RCbG9ja051bWJlcn1gKTtcbiAgICAgICAgLy8gY3JlYXRlIGNoaWxkIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBibG9jay1yZWZcbiAgICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0ID0gY2xvbmVfMS5kZWZhdWx0KHJlcSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkUmVxdWVzdC5wYXJhbXMpKSB7XG4gICAgICAgICAgICBjaGlsZFJlcXVlc3QucGFyYW1zW2Jsb2NrUmVmSW5kZXhdID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSBjaGlsZCByZXF1ZXN0XG4gICAgICAgIGxvZygnUGVyZm9ybWluZyBhbm90aGVyIHJlcXVlc3QgJW8nLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICBjb25zdCBjaGlsZFJlcyA9IGF3YWl0IHBpZnlfMS5kZWZhdWx0KHByb3ZpZGVyLnNlbmRBc3luYykuY2FsbChwcm92aWRlciwgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgLy8gY29weSBjaGlsZCByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgIHJlcy5yZXN1bHQgPSBjaGlsZFJlcy5yZXN1bHQ7XG4gICAgICAgIHJlcy5lcnJvciA9IGNoaWxkUmVzLmVycm9yO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yJyk7XG5jb25zdCBmdXR1cmVCbG9ja1JlZlJlcXVlc3RzID0gW1xuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0Jyxcbl07XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdFRvQ2hlY2sgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgLSBXaGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqZWN0VG9DaGVjaywgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0VG9DaGVjaywgcHJvcGVydHkpO1xufVxuZnVuY3Rpb24gZ2V0UmVzdWx0QmxvY2tOdW1iZXIocmVzcG9uc2UpIHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVzcG9uc2U7XG4gICAgaWYgKCFyZXN1bHQgfHxcbiAgICAgICAgdHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgIWhhc1Byb3BlcnR5KHJlc3VsdCwgJ2Jsb2NrTnVtYmVyJykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQuYmxvY2tOdW1iZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBpbnNwZWN0IGlmIHJlc3BvbnNlIGNvbnRhaW5zIGEgYmxvY2sgcmVmIGhpZ2hlciB0aGFuIG91ciBsYXRlc3QgYmxvY2tcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0pIHtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICBpZiAoIWZ1dHVyZUJsb2NrUmVmUmVxdWVzdHMuaW5jbHVkZXMocmVxLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgLy8gYWJvcnQgaWYgbm8gcmVzdWx0IG9yIG5vIGJsb2NrIG51bWJlclxuICAgICAgICBjb25zdCByZXNwb25zZUJsb2NrTnVtYmVyID0gZ2V0UmVzdWx0QmxvY2tOdW1iZXIocmVzKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZUJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxvZygncmVzLnJlc3VsdC5ibG9ja051bWJlciBleGlzdHMsIHByb2NlZWRpbmcuIHJlcyA9ICVvJywgcmVzKTtcbiAgICAgICAgLy8gaWYgbnVtYmVyIGlzIGhpZ2hlciwgc3VnZ2VzdCBibG9jay10cmFja2VyIGNoZWNrIGZvciBhIG5ldyBibG9ja1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChyZXNwb25zZUJsb2NrTnVtYmVyLCAxNik7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBJZiBnZXRDdXJyZW50QmxvY2sgcmV0dXJucyBudWxsLCBjdXJyZW50QmxvY2tOdW1iZXIgd2lsbCBiZSBOYU4sIHdoaWNoIGlzIGZpbmUuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChibG9ja1RyYWNrZXIuZ2V0Q3VycmVudEJsb2NrKCksIDE2KTtcbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gY3VycmVudEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICBsb2coJ2Jsb2NrTnVtYmVyIGZyb20gcmVzcG9uc2UgaXMgZ3JlYXRlciB0aGFuIGN1cnJlbnQgYmxvY2sgbnVtYmVyLCByZWZyZXNoaW5nIGN1cnJlbnQgYmxvY2sgbnVtYmVyJyk7XG4gICAgICAgICAgICBhd2FpdCBibG9ja1RyYWNrZXIuY2hlY2tGb3JMYXRlc3RCbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stdHJhY2tlci1pbnNwZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSA9IGV4cG9ydHMuY3JlYXRlRmV0Y2hNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IHRpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3RpbWVvdXRcIik7XG5jb25zdCBSRVRSSUFCTEVfRVJST1JTID0gW1xuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG4gICAgJ0dhdGV3YXkgdGltZW91dCcsXG4gICAgJ0VUSU1FRE9VVCcsXG4gICAgLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbiAgICAvLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcbiAgICAnZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHknLFxuICAgIC8vIGlnbm9yZSBlcnJvcnMgd2hlcmUgaHR0cCByZXEgZmFpbGVkIHRvIGVzdGFibGlzaFxuICAgICdGYWlsZWQgdG8gZmV0Y2gnLFxuXTtcbi8qKlxuICogQ3JlYXRlIG1pZGRsZXdhcmUgZm9yIHNlbmRpbmcgYSBKU09OLVJQQyByZXF1ZXN0IHRvIHRoZSBnaXZlbiBSUEMgVVJMLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnMuYnRvYSAtIEdlbmVyYXRlcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZyBmcm9tIGEgYmluYXJ5IHN0cmluZy5cbiAqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gVGhlIGBmZXRjaGAgZnVuY3Rpb247IGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gYHdpbmRvdy5mZXRjaGAuXG4gKiBAcGFyYW0gb3B0aW9ucy5ycGNVcmwgLSBUaGUgVVJMIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gKiBAcGFyYW0gb3B0aW9ucy5vcmlnaW5IdHRwSGVhZGVyS2V5IC0gSWYgcHJvdmlkZXIsIHRoZSBvcmlnaW4gZmllbGQgZm9yIGVhY2ggSlNPTi1SUEMgcmVxdWVzdFxuICogd2lsbCBiZSBhdHRhY2hlZCB0byBlYWNoIG91dGdvaW5nIGZldGNoIHJlcXVlc3QgdW5kZXIgdGhpcyBoZWFkZXIuXG4gKiBAcmV0dXJucyBUaGUgZmV0Y2ggbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKHsgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuYnRvYSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuZmV0Y2gsIHJwY1VybCwgb3JpZ2luSHR0cEhlYWRlcktleSwgfSkge1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9ID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHtcbiAgICAgICAgICAgIGJ0b2EsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBycGNVcmwsXG4gICAgICAgICAgICBvcmlnaW5IdHRwSGVhZGVyS2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYXR0ZW1wdCByZXF1ZXN0IG11bHRpcGxlIHRpbWVzXG4gICAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTtcbiAgICAgICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDEwMDA7XG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZXRjaFJlcyA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGh0dHAgZXJycm9yc1xuICAgICAgICAgICAgICAgIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcyk7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgcmVzcG9uc2UgYm9keVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0JvZHkgPSBhd2FpdCBmZXRjaFJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGZldGNoQm9keTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaEJvZHkgPSBKU09OLnBhcnNlKHJhd0JvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZldGNoTWlkZGxld2FyZSAtIGZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5OiBcIiR7cmF3Qm9keX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBmZXRjaEJvZHkpO1xuICAgICAgICAgICAgICAgIC8vIHNldCByZXN1bHQgYW5kIGV4aXQgcmV0cnkgbG9vcFxuICAgICAgICAgICAgICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGVyci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmV0cmlhYmxlID0gUkVUUklBQkxFX0VSUk9SUy5zb21lKChwaHJhc2UpID0+IGVyck1zZy5pbmNsdWRlcyhwaHJhc2UpKTtcbiAgICAgICAgICAgICAgICAvLyByZS10aHJvdyBlcnJvciBpZiBub3QgcmV0cmlhYmxlXG4gICAgICAgICAgICAgICAgaWYgKCFpc1JldHJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsYXkgYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgICAgICBhd2FpdCB0aW1lb3V0XzEudGltZW91dChyZXRyeUludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVGZXRjaE1pZGRsZXdhcmUgPSBjcmVhdGVGZXRjaE1pZGRsZXdhcmU7XG5mdW5jdGlvbiBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpIHtcbiAgICAvLyBjaGVjayBmb3IgZXJyb3JzXG4gICAgc3dpdGNoIChmZXRjaFJlcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSA0MDU6XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoKTtcbiAgICAgICAgY2FzZSA0MTg6XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVSYXRlbGltaXRFcnJvcigpO1xuICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVUaW1lb3V0RXJyb3IoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGJvZHkpIHtcbiAgICAvLyBjaGVjayBmb3IgZXJyb3IgY29kZVxuICAgIGlmIChmZXRjaFJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgICAgICAgbWVzc2FnZTogYE5vbi0yMDAgc3RhdHVzIGNvZGU6ICcke2ZldGNoUmVzLnN0YXR1c30nYCxcbiAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgcnBjIGVycm9yXG4gICAgaWYgKGJvZHkuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICAgIGRhdGE6IGJvZHkuZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZXR1cm4gc3VjY2Vzc2Z1bCByZXN1bHRcbiAgICByZXR1cm4gYm9keS5yZXN1bHQ7XG59XG4vKipcbiAqIEdlbmVyYXRlIGBmZXRjaGAgY29uZmlndXJhdGlvbiBmb3Igc2VuZGluZyB0aGUgZ2l2ZW4gcmVxdWVzdCB0byBhbiBSUEMgQVBJLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnMuYnRvYSAtIEdlbmVyYXRlcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZyBmcm9tIGEgYmluYXJ5IHN0cmluZy5cbiAqIEBwYXJhbSBvcHRpb25zLnJwY1VybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAqIEBwYXJhbSBvcHRpb25zLm9yaWdpbkh0dHBIZWFkZXJLZXkgLSBJZiBwcm92aWRlciwgdGhlIG9yaWdpbiBmaWVsZCBmb3IgZWFjaCBKU09OLVJQQyByZXF1ZXN0XG4gKiB3aWxsIGJlIGF0dGFjaGVkIHRvIGVhY2ggb3V0Z29pbmcgZmV0Y2ggcmVxdWVzdCB1bmRlciB0aGlzIGhlYWRlci5cbiAqIEByZXR1cm5zIFRoZSBmZXRjaCBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoeyBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG5idG9hLCByZXEsIHJwY1VybCwgb3JpZ2luSHR0cEhlYWRlcktleSwgfSkge1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwocnBjVXJsKTtcbiAgICBjb25zdCBmZXRjaFVybCA9IG5vcm1hbGl6ZVVybEZyb21QYXJzZWQocGFyc2VkVXJsKTtcbiAgICAvLyBwcmVwYXJlIHBheWxvYWRcbiAgICAvLyBjb3B5IG9ubHkgY2Fub25pY2FsIGpzb24gcnBjIHByb3BlcnRpZXNcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBpZDogcmVxLmlkLFxuICAgICAgICBqc29ucnBjOiByZXEuanNvbnJwYyxcbiAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHJlcS5wYXJhbXMsXG4gICAgfTtcbiAgICAvLyBleHRyYWN0ICdvcmlnaW4nIHBhcmFtZXRlciBmcm9tIHJlcXVlc3RcbiAgICBjb25zdCBvcmlnaW5Eb21haW4gPSByZXEub3JpZ2luO1xuICAgIC8vIHNlcmlhbGl6ZSByZXF1ZXN0IGJvZHlcbiAgICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIC8vIGNvbmZpZ3VyZSBmZXRjaCBwYXJhbXNcbiAgICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogc2VyaWFsaXplZFBheWxvYWQsXG4gICAgfTtcbiAgICAvLyBlbmNvZGVkIGF1dGggZGV0YWlscyBhcyBoZWFkZXIgKG5vdCBhbGxvd2VkIGluIGZldGNoIHVybClcbiAgICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lICYmIHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhdXRoU3RyaW5nID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICAgICAgICBjb25zdCBlbmNvZGVkQXV0aCA9IGJ0b2EoYXV0aFN0cmluZyk7XG4gICAgICAgIGZldGNoUGFyYW1zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCYXNpYyAke2VuY29kZWRBdXRofWA7XG4gICAgfVxuICAgIC8vIG9wdGlvbmFsOiBhZGQgcmVxdWVzdCBvcmlnaW4gYXMgaGVhZGVyXG4gICAgaWYgKG9yaWdpbkh0dHBIZWFkZXJLZXkgJiYgb3JpZ2luRG9tYWluKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmhlYWRlcnNbb3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gICAgfVxuICAgIHJldHVybiB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9O1xufVxuZXhwb3J0cy5jcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEgPSBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXE7XG5mdW5jdGlvbiBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybCkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICByZXN1bHQgKz0gcGFyc2VkVXJsLnByb3RvY29sO1xuICAgIHJlc3VsdCArPSBgLy8ke3BhcnNlZFVybC5ob3N0bmFtZX1gO1xuICAgIGlmIChwYXJzZWRVcmwucG9ydCkge1xuICAgICAgICByZXN1bHQgKz0gYDoke3BhcnNlZFVybC5wb3J0fWA7XG4gICAgfVxuICAgIHJlc3VsdCArPSBgJHtwYXJzZWRVcmwucGF0aG5hbWV9YDtcbiAgICByZXN1bHQgKz0gYCR7cGFyc2VkVXJsLnNlYXJjaH1gO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVSYXRlbGltaXRFcnJvcigpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHsgbWVzc2FnZTogYFJlcXVlc3QgaXMgYmVpbmcgcmF0ZSBsaW1pdGVkLmAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaW1lb3V0RXJyb3IoKSB7XG4gICAgbGV0IG1zZyA9IGBHYXRld2F5IHRpbWVvdXQuIFRoZSByZXF1ZXN0IHRvb2sgdG9vIGxvbmcgdG8gcHJvY2Vzcy4gYDtcbiAgICBtc2cgKz0gYFRoaXMgY2FuIGhhcHBlbiB3aGVuIHF1ZXJ5aW5nIGxvZ3Mgb3ZlciB0b28gd2lkZSBhIGJsb2NrIHJhbmdlLmA7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IG1zZyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stY2FjaGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXJlZi1yZXdyaXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1yZWZcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZXRjaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5mbGlnaHQtY2FjaGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyQXNNaWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXRyeU9uRW1wdHlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhbGxldFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2luZmxpZ2h0LWNhY2hlJyk7XG5mdW5jdGlvbiBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSgpIHtcbiAgICBjb25zdCBpbmZsaWdodFJlcXVlc3RzID0ge307XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgY2FjaGVJZCwgaWYgY2FjaGVhYmxlXG4gICAgICAgIGNvbnN0IGNhY2hlSWQgPSBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QocmVxKTtcbiAgICAgICAgLy8gaWYgbm90IGNhY2hlYWJsZSwgc2tpcFxuICAgICAgICBpZiAoIWNhY2hlSWQpIHtcbiAgICAgICAgICAgIGxvZygnUmVxdWVzdCBpcyBub3QgY2FjaGVhYmxlLCBwcm9jZWVkaW5nLiByZXEgPSAlbycsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBtYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICBsZXQgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gaWYgZm91bmQsIHdhaXQgZm9yIHRoZSBhY3RpdmUgcmVxdWVzdCB0byBiZSBoYW5kbGVkXG4gICAgICAgIGlmIChhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lciBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGhhbmRsZSBjb3B5aW5nIHRoZSByZXN1bHQgYW5kIHJlcXVlc3QgZmllbGRzXG4gICAgICAgICAgICBsb2coJ1J1bm5pbmcgJWkgaGFuZGxlcihzKSBmb3IgcmVxdWVzdCAlbycsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5sZW5ndGgsIHJlcSk7XG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIHJlc3BvbnNlIGhhbmRsZXIgYXJyYXkgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW107XG4gICAgICAgIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF0gPSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnM7XG4gICAgICAgIC8vIGFsbG93IHJlcXVlc3QgdG8gYmUgaGFuZGxlZCBub3JtYWxseVxuICAgICAgICBsb2coJ0NhcnJ5aW5nIG9yaWdpbmFsIHJlcXVlc3QgZm9yd2FyZCAlbycsIHJlcSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIC8vIGNsZWFyIGluZmxpZ2h0IHJlcXVlc3RzXG4gICAgICAgIGRlbGV0ZSBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgICAgICAvLyBzY2hlZHVsZSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgdG8gYmUgaGFuZGxlZFxuICAgICAgICBsb2coJ1J1bm5pbmcgJWkgY29sbGVjdGVkIGhhbmRsZXIocykgZm9yIHJlcXVlc3QgJW8nLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMubGVuZ3RoLCByZXEpO1xuICAgICAgICBoYW5kbGVBY3RpdmVSZXF1ZXN0KHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKTtcbiAgICAgICAgLy8gY29tcGxldGVcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICBjb25zdCB7IHJlc29sdmUsIHByb21pc2UgfSA9IGRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMucHVzaCgoaGFuZGxlZFJlcykgPT4ge1xuICAgICAgICAgICAgLy8gYXBwZW5kIGEgY29weSBvZiB0aGUgcmVzdWx0IGFuZCBlcnJvciB0byB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSBjbG9uZV8xLmRlZmF1bHQoaGFuZGxlZFJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgcmVzLmVycm9yID0gY2xvbmVfMS5kZWZhdWx0KGhhbmRsZWRSZXMuZXJyb3IpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgLy8gdXNlIHNldFRpbWVvdXQgc28gd2UgY2FuIHJlc29sdmUgb3VyIG9yaWdpbmFsIHJlcXVlc3QgZmlyc3RcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXRjaCBlcnJvciBzbyBhbGwgcmVxdWVzdHMgYXJlIGhhbmRsZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSA9IGNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlO1xuZnVuY3Rpb24gZGVmZXJyZWRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlc29sdmUsIHByb21pc2UgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmxpZ2h0LWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLnByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1vZHVsZUxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXI7IH0gfSk7XG5leHBvcnRzLnByb2plY3RMb2dnZXIgPSB1dGlsc18xLmNyZWF0ZVByb2plY3RMb2dnZXIoJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZSA9IGV4cG9ydHMucHJvdmlkZXJBc01pZGRsZXdhcmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICAgIHJldHVybiAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgICAgIHByb3ZpZGVyLnNlbmRBc3luYyhyZXEsIChlcnIsIHByb3ZpZGVyUmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIGFueSBlcnJvclxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSBwcm92aWRlciByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgcHJvdmlkZXJSZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5wcm92aWRlckFzTWlkZGxld2FyZSA9IHByb3ZpZGVyQXNNaWRkbGV3YXJlO1xuZnVuY3Rpb24gZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgICAgICBwcm92aWRlci5zZW5kKHJlcSwgKGVyciwgcHJvdmlkZXJSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgYW55IGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgY2FzdCB3aGVuIG5leHQgbWFqb3IgYGpzb24tcnBjLWVuZ2luZWAgcmVsZWFzZSBpcyBvdXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgbmV4dCByZWxlYXNlIGNoYW5nZXMgaG93IGVycm9ycyBhcmUgcHJvcG9nYXRlZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckFzTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHBpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGlmeVwiKSk7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuY29uc3QgdGltZW91dF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdGltZW91dFwiKTtcbi8vXG4vLyBSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIHdpbGwgcmV0cnkgYW55IHJlcXVlc3Qgd2l0aCBhbiBlbXB0eSByZXNwb25zZSB0aGF0IGhhc1xuLy8gYSBudW1iZXJlZCBibG9jayByZWZlcmVuY2UgYXQgb3IgbG93ZXIgdGhhbiB0aGUgYmxvY2tUcmFja2VyJ3MgbGF0ZXN0IGJsb2NrLlxuLy8gSXRzIHVzZWZ1bCBmb3IgZGVhbGluZyB3aXRoIGxvYWQtYmFsYW5jZWQgZXRoZXJldW0gSlNPTiBSUENcbi8vIG5vZGVzIHRoYXQgYXJlIG5vdCBhbHdheXMgaW4gc3luYyB3aXRoIGVhY2ggb3RoZXIuXG4vL1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ3JldHJ5LW9uLWVtcHR5Jyk7XG4vLyBlbXB0eSB2YWx1ZXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkXG4vLyBgPG5pbD5gIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8xNjkyNVxuY29uc3QgZW1wdHlWYWx1ZXMgPSBbXG4gICAgdW5kZWZpbmVkLFxuICAgIG51bGwsXG4gICAgJ1xcdTAwM2NuaWxcXHUwMDNlJyxcbl07XG5mdW5jdGlvbiBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcInByb3ZpZGVyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleChyZXEubWV0aG9kKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IGV4YWN0IGJsb2NrIHJlZmVyZW5jZXNcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gQXJyYXkuaXNBcnJheShyZXEucGFyYW1zKVxuICAgICAgICAgICAgPyByZXEucGFyYW1zW2Jsb2NrUmVmSW5kZXhdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gb21pdHRlZCBibG9ja1JlZiBpbXBsaWVzIFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsb2NrUmVmID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub24tbnVtYmVyIGJsb2NrIHJlZmVyZW5jZVxuICAgICAgICBpZiAoWydsYXRlc3QnLCAncGVuZGluZyddLmluY2x1ZGVzKGJsb2NrUmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIGJsb2NrIHJlZmVybmNlIGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgICAgICBjb25zdCBibG9ja1JlZk51bWJlciA9IE51bWJlci5wYXJzZUludChibG9ja1JlZi5zbGljZSgyKSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJsb2NrUmVmTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVySGV4ID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGxhdGVzdEJsb2NrTnVtYmVySGV4LnNsaWNlKDIpLCAxNik7XG4gICAgICAgIC8vIHNraXAgaWYgcmVxdWVzdCBibG9jayBudW1iZXIgaXMgaGlnaGVyIHRoYW4gY3VycmVudFxuICAgICAgICBpZiAoYmxvY2tSZWZOdW1iZXIgPiBsYXRlc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgbG9nKCdSZXF1ZXN0ZWQgYmxvY2sgbnVtYmVyICVvIGlzIGhpZ2hlciB0aGFuIGxhdGVzdCBibG9jayBudW1iZXIgJW8sIGZhbGxpbmcgdGhyb3VnaCB0byBvcmlnaW5hbCByZXF1ZXN0JywgYmxvY2tSZWZOdW1iZXIsIGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdSZXF1ZXN0ZWQgYmxvY2sgbnVtYmVyICVvIGlzIG5vdCBoaWdoZXIgdGhhbiBsYXRlc3QgYmxvY2sgbnVtYmVyICVvLCB0cnlpbmcgcmVxdWVzdCB1bnRpbCBub24tZW1wdHkgcmVzcG9uc2UgaXMgcmVjZWl2ZWQnLCBibG9ja1JlZk51bWJlciwgbGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAvLyBjcmVhdGUgY2hpbGQgcmVxdWVzdCB3aXRoIHNwZWNpZmljIGJsb2NrLXJlZlxuICAgICAgICBjb25zdCBjaGlsZFJlcXVlc3QgPSBjbG9uZV8xLmRlZmF1bHQocmVxKTtcbiAgICAgICAgLy8gYXR0ZW1wdCBjaGlsZCByZXF1ZXN0IHVudGlsIG5vbi1lbXB0eSByZXNwb25zZSBpcyByZWNlaXZlZFxuICAgICAgICBjb25zdCBjaGlsZFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoMTAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxvZygnUGVyZm9ybWluZyByZXF1ZXN0ICVvJywgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRSZXNwb25zZSA9IGF3YWl0IHBpZnlfMS5kZWZhdWx0KHByb3ZpZGVyLnNlbmRBc3luYykuY2FsbChwcm92aWRlciwgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGxvZygnUmVzcG9uc2UgaXMgJW8nLCBhdHRlbXB0UmVzcG9uc2UpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlc3VsdFxuICAgICAgICAgICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKGF0dGVtcHRSZXNwb25zZS5yZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gZW1wdHkgcmVzcG9uc2UgXCIke0pTT04uc3RyaW5naWZ5KGF0dGVtcHRSZXNwb25zZSl9XCIgZm9yIHJlcXVlc3QgXCIke0pTT04uc3RyaW5naWZ5KGNoaWxkUmVxdWVzdCl9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdHRlbXB0UmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coJ0NvcHlpbmcgcmVzdWx0ICVvIGFuZCBlcnJvciAlbycsIGNoaWxkUmVzcG9uc2UucmVzdWx0LCBjaGlsZFJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgLy8gY29weSBjaGlsZCByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgIHJlcy5yZXN1bHQgPSBjaGlsZFJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgcmVzLmVycm9yID0gY2hpbGRSZXNwb25zZS5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSA9IGNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmU7XG5hc3luYyBmdW5jdGlvbiByZXRyeShtYXhSZXRyaWVzLCBhc3luY0ZuKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1heFJldHJpZXM7IGluZGV4KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhc3luY0ZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nKCcoY2FsbCAlaSkgUmVxdWVzdCBmYWlsZWQsIHdhaXRpbmcgMXMgdG8gcmV0cnkgYWdhaW4uLi4nLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dF8xLnRpbWVvdXQoMTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nKCdSZXRyaWVzIGV4aGF1c3RlZCcpO1xuICAgIHRocm93IG5ldyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIHJldHJpZXMgZXhoYXVzdGVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeU9uRW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhY2hlVHlwZUZvck1ldGhvZCA9IGV4cG9ydHMuYmxvY2tUYWdQYXJhbUluZGV4ID0gZXhwb3J0cy5ibG9ja1RhZ0ZvclJlcXVlc3QgPSBleHBvcnRzLmNhbkNhY2hlID0gZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0ID0gZXhwb3J0cy5DYWNoZVN0cmF0ZWd5ID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9zdGFibGVfc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwic2FmZS1zdGFibGUtc3RyaW5naWZ5XCIpO1xuY29uc3Qgc3RyaW5naWZ5ID0gc2FmZV9zdGFibGVfc3RyaW5naWZ5XzEuY29uZmlndXJlKHsgYmlnaW50OiBmYWxzZSwgY2lyY3VsYXJWYWx1ZTogRXJyb3IgfSk7XG4vKipcbiAqIFRoZSBjYWNoZSBzdHJhdGVneSB0byB1c2UgZm9yIGEgZ2l2ZW4gbWV0aG9kLlxuICovXG52YXIgQ2FjaGVTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FjaGVTdHJhdGVneSkge1xuICAgIC8qKlxuICAgICAqIENhY2hlIHBlci1ibG9jay5cbiAgICAgKi9cbiAgICBDYWNoZVN0cmF0ZWd5W1wiQmxvY2tcIl0gPSBcImJsb2NrXCI7XG4gICAgLyoqXG4gICAgICogQ2FjaGUgdW50aWwgYSBjaGFpbiByZW9yZ2FuaXphdGlvbiBvY2N1cnMuXG4gICAgICovXG4gICAgQ2FjaGVTdHJhdGVneVtcIkZvcmtcIl0gPSBcImZvcmtcIjtcbiAgICAvKipcbiAgICAgKiBOZXZlciBjYWNoZS5cbiAgICAgKi9cbiAgICBDYWNoZVN0cmF0ZWd5W1wiTmV2ZXJcIl0gPSBcIm5ldmVyXCI7XG4gICAgLyoqXG4gICAgICogUGVybWFuZW50bHkgY2FjaGUuXG4gICAgICovXG4gICAgQ2FjaGVTdHJhdGVneVtcIlBlcm1hbmVudFwiXSA9IFwicGVybWFcIjtcbn0pKENhY2hlU3RyYXRlZ3kgPSBleHBvcnRzLkNhY2hlU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FjaGVTdHJhdGVneSA9IHt9KSk7XG4vKlxuICogUmV0dXJuIGEgY2FjaGUgaWRlbnRpZmllciBmb3IgdGhlIGdpdmVuIHJlcXVlc3QuXG4gKlxuICogVGhpcyBpZGVudGlmaWVyIHNob3VsZCBpbmNsdWRlIGFueSByZXF1ZXN0IGRldGFpbHMgdGhhdCBtaWdodCBpbXBhY3QgdGhlXG4gKiByZXNwb25zZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBibG9jayBwYXJhbWV0ZXIgaWYgdGhlIGBza2lwQmxvY2tSZWZgXG4gKiBvcHRpb24gaXMgc2V0LFxuICpcbiAqIElmIHRoZSByZXF1ZXN0IGNhbm5vdCBiZSBjYWNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYG51bGxgLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIEpTT04tUlBDIHJlcXVlc3QuXG4gKiBAcGFyYW0gc2tpcEJsb2NrUmVmIC0gU2tpcCB0aGUgYmxvY2sgcGFyYW1ldGVyIHdoZW4gZ2VuZXJhdGluZyB0aGUgY2FjaGVcbiAqIGlkZW50aWZpZXIuXG4gKiBAcmV0dXJucyBUaGUgY2FjaGUgaWRlbnRpZmllciBmb3IgdGhpcyByZXF1ZXN0LCBvciBgbnVsbGAgaWYgaXQgY2FuJ3QgYmVcbiAqIGNhY2hlZC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdChyZXF1ZXN0LCBza2lwQmxvY2tSZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2ltcGxlUGFyYW1zID0gc2tpcEJsb2NrUmVmXG4gICAgICAgID8gcGFyYW1zV2l0aG91dEJsb2NrVGFnKHJlcXVlc3QpXG4gICAgICAgIDogKF9hID0gcmVxdWVzdC5wYXJhbXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIGlmIChjYW5DYWNoZShyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGAke3JlcXVlc3QubWV0aG9kfToke3N0cmluZ2lmeShzaW1wbGVQYXJhbXMpfWA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0ID0gY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdDtcbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBtZXRob2QgY2FuIGJlIGNhY2hlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBtZXRob2QgY2FuIGJlIGNhY2hlZC5cbiAqL1xuZnVuY3Rpb24gY2FuQ2FjaGUobWV0aG9kKSB7XG4gICAgcmV0dXJuIGNhY2hlVHlwZUZvck1ldGhvZChtZXRob2QpICE9PSBDYWNoZVN0cmF0ZWd5Lk5ldmVyO1xufVxuZXhwb3J0cy5jYW5DYWNoZSA9IGNhbkNhY2hlO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGJsb2NrIHBhcmFtZXRlciBmb3IgdGhlIGdpdmVuIHJlcXVlc3QsIGlmIGl0IGhhcyBvbmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdC5cbiAqIEByZXR1cm5zIFRoZSBibG9jayBwYXJhbWV0ZXIgaW4gdGhlIGdpdmVuIHJlcXVlc3QsIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUgd2FzIGZvdW5kLlxuICovXG5mdW5jdGlvbiBibG9ja1RhZ0ZvclJlcXVlc3QocmVxdWVzdCkge1xuICAgIGlmICghcmVxdWVzdC5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocmVxdWVzdC5tZXRob2QpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICFBcnJheS5pc0FycmF5KHJlcXVlc3QucGFyYW1zKSB8fFxuICAgICAgICBpbmRleCA+PSByZXF1ZXN0LnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3QucGFyYW1zW2luZGV4XTtcbn1cbmV4cG9ydHMuYmxvY2tUYWdGb3JSZXF1ZXN0ID0gYmxvY2tUYWdGb3JSZXF1ZXN0O1xuLyoqXG4gKiBSZXR1cm4gdGhlIHJlcXVlc3QgcGFyYW1ldGVycyB3aXRob3V0IHRoZSBibG9jayBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdC5cbiAqIEByZXR1cm5zIFRoZSByZXF1ZXN0IHBhcmFtZXRlcnMgd2l0aCB0aGUgYmxvY2sgcGFyYW1ldGVyIHJlbW92ZWQsIGlmIG9uZSB3YXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhyZXF1ZXN0KSB7XG4gICAgaWYgKCFyZXF1ZXN0LnBhcmFtcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHJlcXVlc3QubWV0aG9kKTtcbiAgICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAhQXJyYXkuaXNBcnJheShyZXF1ZXN0LnBhcmFtcykgfHxcbiAgICAgICAgaW5kZXggPj0gcmVxdWVzdC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0LnBhcmFtcztcbiAgICB9XG4gICAgLy8gZXRoX2dldEJsb2NrQnlOdW1iZXIgaGFzIHRoZSBibG9jayB0YWcgZmlyc3QsIHRoZW4gdGhlIG9wdGlvbmFsIGluY2x1ZGVUeD8gcGFyYW1cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdldGhfZ2V0QmxvY2tCeU51bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QucGFyYW1zLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdC5wYXJhbXMuc2xpY2UoMCwgaW5kZXgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgYmxvY2sgcGFyYW1ldGVyIGZvciB0aGUgZ2l2ZW4gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBtZXRob2QgLSBBIEpTT04tUlBDIG1ldGhvZC5cbiAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYmxvY2sgcGFyYW1ldGVyIGZvciB0aGF0IG1ldGhvZCwgb3IgYHVuZGVmaW5lZGAgaWZcbiAqIHRoZXJlIGlzIG5vIGtub3duIGJsb2NrIHBhcmFtZXRlci5cbiAqL1xuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDJcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMVxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMFxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gYmxvY2tUYWdcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5ibG9ja1RhZ1BhcmFtSW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXg7XG4vKipcbiAqIFJldHVybiB0aGUgY2FjaGUgdHlwZSB1c2VkIGZvciB0aGUgZ2l2ZW4gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBtZXRob2QgLSBBIEpTT04tUlBDIG1ldGhvZC5cbiAqIEByZXR1cm5zIFRoZSBjYWNoZSB0eXBlIHRvIHVzZSBmb3IgdGhhdCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlVHlwZUZvck1ldGhvZChtZXRob2QpIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAvLyBjYWNoZSBwZXJtYW5lbnRseVxuICAgICAgICBjYXNlICd3ZWIzX2NsaWVudFZlcnNpb24nOlxuICAgICAgICBjYXNlICd3ZWIzX3NoYTMnOlxuICAgICAgICBjYXNlICdldGhfcHJvdG9jb2xWZXJzaW9uJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29kZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb21waWxlcnMnOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZUxMTCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU29saWRpdHknOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZVNlcnBlbnQnOlxuICAgICAgICBjYXNlICdzaGhfdmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3Rlc3RfcGVybWFDYWNoZSc6XG4gICAgICAgICAgICByZXR1cm4gQ2FjaGVTdHJhdGVneS5QZXJtYW5lbnQ7XG4gICAgICAgIC8vIGNhY2hlIHVudGlsIGZvcmtcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICd0ZXN0X2ZvcmtDYWNoZSc6XG4gICAgICAgICAgICByZXR1cm4gQ2FjaGVTdHJhdGVneS5Gb3JrO1xuICAgICAgICAvLyBjYWNoZSBmb3IgYmxvY2tcbiAgICAgICAgY2FzZSAnZXRoX2dhc1ByaWNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2Jsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgICAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZUdhcyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRGaWx0ZXJMb2dzJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldExvZ3MnOlxuICAgICAgICBjYXNlICd0ZXN0X2Jsb2NrQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuIENhY2hlU3RyYXRlZ3kuQmxvY2s7XG4gICAgICAgIC8vIG5ldmVyIGNhY2hlXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQ2FjaGVTdHJhdGVneS5OZXZlcjtcbiAgICB9XG59XG5leHBvcnRzLmNhY2hlVHlwZUZvck1ldGhvZCA9IGNhY2hlVHlwZUZvck1ldGhvZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aW1lb3V0ID0gdm9pZCAwO1xuLyoqXG4gKiBXYWl0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZS5cbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xufVxuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlV2FsbGV0TWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHNpZ1V0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBtZXRhbWFzay9ldGgtc2lnLXV0aWxcIikpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdhbGxldE1pZGRsZXdhcmUoeyBnZXRBY2NvdW50cywgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlLCBwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleSwgcHJvY2Vzc0V0aFNpZ25NZXNzYWdlLCBwcm9jZXNzUGVyc29uYWxNZXNzYWdlLCBwcm9jZXNzVHJhbnNhY3Rpb24sIHByb2Nlc3NTaWduVHJhbnNhY3Rpb24sIHByb2Nlc3NUeXBlZE1lc3NhZ2UsIHByb2Nlc3NUeXBlZE1lc3NhZ2VWMywgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0LCB9KSB7XG4gICAgaWYgKCFnZXRBY2NvdW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdHMuZ2V0QWNjb3VudHMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSh7XG4gICAgICAgIC8vIGFjY291bnQgbG9va3Vwc1xuICAgICAgICBldGhfYWNjb3VudHM6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShsb29rdXBBY2NvdW50cyksXG4gICAgICAgIGV0aF9jb2luYmFzZToganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGxvb2t1cERlZmF1bHRBY2NvdW50KSxcbiAgICAgICAgLy8gdHggc2lnbmF0dXJlc1xuICAgICAgICBldGhfc2VuZFRyYW5zYWN0aW9uOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2VuZFRyYW5zYWN0aW9uKSxcbiAgICAgICAgZXRoX3NpZ25UcmFuc2FjdGlvbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UcmFuc2FjdGlvbiksXG4gICAgICAgIC8vIG1lc3NhZ2Ugc2lnbmF0dXJlc1xuICAgICAgICBldGhfc2lnbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGV0aFNpZ24pLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YToganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UeXBlZERhdGEpLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92MzoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UeXBlZERhdGFWMyksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblR5cGVkRGF0YVY0KSxcbiAgICAgICAgcGVyc29uYWxfc2lnbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHBlcnNvbmFsU2lnbiksXG4gICAgICAgIGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5OiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoZW5jcnlwdGlvblB1YmxpY0tleSksXG4gICAgICAgIGV0aF9kZWNyeXB0OiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoZGVjcnlwdE1lc3NhZ2UpLFxuICAgICAgICBwZXJzb25hbF9lY1JlY292ZXI6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShwZXJzb25hbFJlY292ZXIpLFxuICAgIH0pO1xuICAgIC8vXG4gICAgLy8gYWNjb3VudCBsb29rdXBzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBsb29rdXBBY2NvdW50cyhyZXEsIHJlcykge1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbG9va3VwRGVmYXVsdEFjY291bnQocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYWNjb3VudHNbMF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLy9cbiAgICAvLyB0cmFuc2FjdGlvbiBzaWduYXR1cmVzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBzZW5kVHJhbnNhY3Rpb24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHJlcS5wYXJhbXNbMF0gfHwge307XG4gICAgICAgIHR4UGFyYW1zLmZyb20gPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcih0eFBhcmFtcy5mcm9tLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1RyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzU2lnblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSByZXEucGFyYW1zWzBdIHx8IHt9O1xuICAgICAgICB0eFBhcmFtcy5mcm9tID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIodHhQYXJhbXMuZnJvbSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NTaWduVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gbWVzc2FnZSBzaWduYXR1cmVzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBldGhTaWduKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0V0aFNpZ25NZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1sxXSwgcmVxKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWMSc7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhVjMocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlVjMpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjMnO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlVjMobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhVjQocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlVjQpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjQnO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlVjQobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwZXJzb25hbFNpZ24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzUGVyc29uYWxNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgICBjb25zdCBmaXJzdFBhcmFtID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFyYW0gPSByZXEucGFyYW1zWzFdO1xuICAgICAgICAvLyBub24tc3RhbmRhcmQgXCJleHRyYVBhcmFtc1wiIHRvIGJlIGFwcGVuZGVkIHRvIG91ciBcIm1zZ1BhcmFtc1wiIG9ialxuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIC8vIFdlIGluaXRpYWxseSBpbmNvcnJlY3RseSBvcmRlcmVkIHRoZXNlIHBhcmFtZXRlcnMuXG4gICAgICAgIC8vIFRvIGdyYWNlZnVsbHkgcmVzcGVjdCB1c2VycyB3aG8gYWRvcHRlZCB0aGlzIEFQSSBlYXJseSxcbiAgICAgICAgLy8gd2UgYXJlIGN1cnJlbnRseSBncmFjZWZ1bGx5IHJlY292ZXJpbmcgZnJvbSB0aGUgd3JvbmcgcGFyYW0gb3JkZXJcbiAgICAgICAgLy8gd2hlbiBpdCBpcyBjbGVhcmx5IGlkZW50aWZpYWJsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhhdCBtZWFucyB3aGVuIHRoZSBmaXJzdCBwYXJhbSBpcyBkZWZpbml0ZWx5IGFuIGFkZHJlc3MsXG4gICAgICAgIC8vIGFuZCB0aGUgc2Vjb25kIHBhcmFtIGlzIGRlZmluaXRlbHkgbm90LCBidXQgaXMgaGV4LlxuICAgICAgICBsZXQgYWRkcmVzcywgbWVzc2FnZTtcbiAgICAgICAgaWYgKHJlc2VtYmxlc0FkZHJlc3MoZmlyc3RQYXJhbSkgJiYgIXJlc2VtYmxlc0FkZHJlc3Moc2Vjb25kUGFyYW0pKSB7XG4gICAgICAgICAgICBsZXQgd2FybmluZyA9IGBUaGUgZXRoX3BlcnNvbmFsU2lnbiBtZXRob2QgcmVxdWlyZXMgcGFyYW1zIG9yZGVyZWQgYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYFttZXNzYWdlLCBhZGRyZXNzXS4gVGhpcyB3YXMgcHJldmlvdXNseSBoYW5kbGVkIGluY29ycmVjdGx5LCBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgYW5kIGhhcyBiZWVuIGNvcnJlY3RlZCBhdXRvbWF0aWNhbGx5LiBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgUGxlYXNlIHN3aXRjaCB0aGlzIHBhcmFtIG9yZGVyIGZvciBzbW9vdGggYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5gO1xuICAgICAgICAgICAgcmVzLndhcm5pbmcgPSB3YXJuaW5nO1xuICAgICAgICAgICAgYWRkcmVzcyA9IGZpcnN0UGFyYW07XG4gICAgICAgICAgICBtZXNzYWdlID0gc2Vjb25kUGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZmlyc3RQYXJhbTtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBzZWNvbmRQYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIoYWRkcmVzcywgcmVxKTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NQZXJzb25hbE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwZXJzb25hbFJlY292ZXIocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBzaWdVdGlsLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSh7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IHNpZ25lckFkZHJlc3M7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRpb25QdWJsaWNLZXkocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXkoYWRkcmVzcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdE1lc3NhZ2UocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRGVjcnlwdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMV0sIHJlcSk7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogY2lwaGVydGV4dCB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NEZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gdXRpbGl0eVxuICAgIC8vXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBrZXlob2xkZXIgYWRkcmVzcywgYW5kIHJldHVybnMgYSBub3JtYWxpemVkIChpLmUuIGxvd2VyY2FzZSlcbiAgICAgKiBjb3B5IG9mIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXEgLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbm9ybWFsaXplZCBhZGRyZXNzLCBpZiB2YWxpZC4gT3RoZXJ3aXNlLCB0aHJvd3NcbiAgICAgKiBhbiBlcnJvclxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKGFkZHJlc3MsIHJlcSkge1xuICAgICAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBhZGRyZXNzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHJlc2VtYmxlc0FkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGFuIFwidW5hdXRob3JpemVkXCIgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSByZXF1ZXN0ZXIgZG9lcyBub3QgaGF2ZSB0aGUgYGV0aF9hY2NvdW50c2BcbiAgICAgICAgICAgIC8vIHBlcm1pc3Npb24uXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGdldEFjY291bnRzKHJlcSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQWNjb3VudHMgPSBhY2NvdW50cy5tYXAoKF9hZGRyZXNzKSA9PiBfYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRBY2NvdW50cy5pbmNsdWRlcyhub3JtYWxpemVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBwYXJhbWV0ZXJzOiBtdXN0IHByb3ZpZGUgYW4gRXRoZXJldW0gYWRkcmVzcy5gLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZVdhbGxldE1pZGRsZXdhcmUgPSBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlO1xuZnVuY3Rpb24gcmVzZW1ibGVzQWRkcmVzcyhzdHIpIHtcbiAgICAvLyBoZXggcHJlZml4IDIgKyAyMCBieXRlc1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAyICsgMjAgKiAyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgbWVzc2FnZWAgcHJvcGVydHksIHN1Y2ggYXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgb3IgZmFsc2UsIGRlcGVuZGluZyBvbiB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBjb25zdHJ1Y3RvciwgaS5lLiwgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aFxuICogdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RhYmxlKGZuKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiAoKF9iID0gKF9hID0gZm4gPT09IG51bGwgfHwgZm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZuLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogR2V0IHRoZSBlcnJvciBtZXNzYWdlIGZyb20gYW4gdW5rbm93biBlcnJvciBvYmplY3QuIElmIHRoZSBlcnJvciBvYmplY3QgaGFzXG4gKiBhIGBtZXNzYWdlYCBwcm9wZXJ0eSwgdGhhdCBwcm9wZXJ0eSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgc3RyaW5naWZpZWRcbiAqIGVycm9yIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgLy8gSWYgdGhlIGVycm9yIGVuZHMgd2l0aCBhIHBlcmlvZCwgcmVtb3ZlIGl0LCBhcyB3ZSdsbCBhZGQgb3VyIG93biBwZXJpb2QuXG4gICAgaWYgKG1lc3NhZ2UuZW5kc1dpdGgoJy4nKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2U2NCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwcm92aWRlZCBzdHJpbmctYmFzZWQgc3RydWN0IGlzIHZhbGlkIGJhc2U2NC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cmluZyBiYXNlZCBzdHJ1Y3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgdG8gc3BlY2lhbGl6ZSBiYXNlNjQgdmFsaWRhdGlvbi4gU2VlIHtAbGluayBCYXNlNjRPcHRpb25zfSBkb2N1bWVudGF0aW9uLlxuICogQHJldHVybnMgQSBzdXBlcnN0cnVjdCB2YWxpZGF0aW5nIGJhc2U2NC5cbiAqL1xuY29uc3QgYmFzZTY0ID0gKHN0cnVjdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwYWRkaW5nUmVxdWlyZWQgPSAoX2EgPSBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gKF9iID0gb3B0aW9ucy5jaGFyYWN0ZXJTZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8vICcwJy5jaGFyQ29kZUF0KDApID09PSA0OFxuY29uc3QgSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDQ4O1xuLy8gJzknLmNoYXJDb2RlQXQoMCkgPT09IDU3XG5jb25zdCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNTg7XG5jb25zdCBIRVhfQ0hBUkFDVEVSX09GRlNFVCA9IDg3O1xuLyoqXG4gKiBNZW1vaXplZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgdG8gYmUgdXNlZCBhcyBhIGxvb2t1cCB0YWJsZSBmb3JcbiAqIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4YWRlY2ltYWwgdmFsdWVzLlxuICpcbiAqIFRoZSBhcnJheSBpcyBjcmVhdGVkIGxhemlseSBhbmQgdGhlbiBjYWNoZWQgZm9yIGZ1dHVyZSB1c2UuIFRoZSBiZW5lZml0IG9mXG4gKiB0aGlzIGFwcHJvYWNoIGlzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4IGlzIG11Y2hcbiAqIGJldHRlciB0aGFuIGlmIHdlIHdlcmUgdG8gY2FsbCBgdG9TdHJpbmcoMTYpYCBvbiBlYWNoIGJ5dGUuXG4gKlxuICogVGhlIGRvd25zaWRlIGlzIHRoYXQgdGhlIGFycmF5IGlzIGNyZWF0ZWQgb25jZSBhbmQgdGhlbiBuZXZlciBnYXJiYWdlXG4gKiBjb2xsZWN0ZWQuIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBpbiBwcmFjdGljZSBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IDI1NlxuICogZWxlbWVudHMgbG9uZy5cbiAqXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbG9va3VwIHRhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKSB7XG4gICAgLy8gVG8gYXZvaWQgaXNzdWVzIHdpdGggdHJlZSBzaGFraW5nLCB3ZSBuZWVkIHRvIHVzZSBhIGZ1bmN0aW9uIHRvIHJldHVybiB0aGVcbiAgICAvLyBhcnJheS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IHVzZWQgaW4gdGhlIGBieXRlc1RvSGV4YCBmdW5jdGlvblxuICAgIC8vIGFuZCBpZiB3ZSB3ZXJlIHRvIHVzZSBhIGdsb2JhbCB2YXJpYWJsZSwgdGhlIGFycmF5IG1pZ2h0IGJlIHJlbW92ZWQgYnkgdGhlXG4gICAgLy8gdHJlZSBzaGFrZXIuXG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBbXTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobG9va3VwVGFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUucHVzaChpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9va3VwVGFibGU7XG4gICAgfTtcbn1cbi8qKlxuICogRnVuY3Rpb24gaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXJ9XG4gKiBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNCeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzQnl0ZXModmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIFVpbnQ4QXJyYXkuJyk7XG59XG5leHBvcnRzLmFzc2VydElzQnl0ZXMgPSBhc3NlcnRJc0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMoKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IG5ldyBBcnJheShieXRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgaGV4YWRlY2ltYWxbaV0gPSBsb29rdXBUYWJsZVtieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKGhleGFkZWNpbWFsLmpvaW4oJycpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvTnVtYmVyfS5cbiAqIFRvIGNvbnZlcnQgYSB0d28ncyBjb21wbGVtZW50IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9TaWduZWRCaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9CaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IGJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgIHJldHVybiBCaWdJbnQoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gYnl0ZXNUb0JpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIHNpZ25lZCBgYmlnaW50YC4gVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGJ5dGVzIGFyZVxuICogZW5jb2RlZCBpbiB0d28ncyBjb21wbGVtZW50LlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYW4gdW5zaWduZWQgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc2lnbmVkIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIHNpZ25lZCBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1NpZ25lZEJpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYnl0ZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgQmlnSW50KDgpKSArIEJpZ0ludChieXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oYnl0ZXMubGVuZ3RoICogOCwgdmFsdWUpO1xufVxuZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gYnl0ZXNUb1NpZ25lZEJpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHJlc3VsdGluZyBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgYmlnaW50ID0gYnl0ZXNUb0JpZ0ludChieXRlcyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnaW50IDw9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksICdOdW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJ5dGVzVG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIE51bWJlcihiaWdpbnQpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gYnl0ZXNUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYHN0cmluZ2AuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgc3RyaW5nIGNhbiBvcHRpb25hbGx5IGJlXG4gKiBwcmVmaXhlZCB3aXRoIGAweGAuIEl0IGFjY2VwdHMgZXZlbiBhbmQgb2RkIGxlbmd0aCBzdHJpbmdzLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBcIjB4XCIsIGFuIGVtcHR5IGBVaW50OEFycmF5YCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFwiMHhcIiBpcyBvZnRlbiB1c2VkIGFzIGVtcHR5IGJ5dGUgYXJyYXkuXG4gICAgaWYgKCgoX2EgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9Mb3dlckNhc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlKSkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFJlbW92ZSB0aGUgYDB4YCBwcmVmaXggaWYgaXQgZXhpc3RzLCBhbmQgcGFkIHRoZSBzdHJpbmcgdG8gaGF2ZSBhbiBldmVuXG4gICAgLy8gbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9ICgwLCBoZXhfMS5yZW1vdmUweCkodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gc3RyaXBwZWRWYWx1ZS5sZW5ndGggJSAyID09PSAwID8gc3RyaXBwZWRWYWx1ZSA6IGAwJHtzdHJpcHBlZFZhbHVlfWA7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShub3JtYWxpemVkVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIG5vdCB0aGUgcHJldHRpZXN0IHdheSB0byBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXlgLCBpdCBpcyBhIGxvdCBmYXN0ZXIgdGhhbiB1c2luZyBgcGFyc2VJbnRgIHRvIGNvbnZlcnQgZWFjaFxuICAgICAgICAvLyBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0IGMxID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIpO1xuICAgICAgICBjb25zdCBjMiA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gICAgICAgIGNvbnN0IG4xID0gYzEgLVxuICAgICAgICAgICAgKGMxIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBjb25zdCBuMiA9IGMyIC1cbiAgICAgICAgICAgIChjMiA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgYnl0ZXNbaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYGJpZ2ludGAgaXMgYW4gdW5zaWduZWQgaW50ZWdlci4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYmlnaW50IHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBiaWdJbnRUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gQmlnSW50KDApLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gYmlnSW50VG9CeXRlcztcbi8qKlxuICogQ2hlY2sgaWYgYSBgYmlnaW50YCBmaXRzIGluIGEgY2VydGFpbiBudW1iZXIgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNoZWNrLlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIG51bWJlciBvZiBieXRlcy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGBiaWdpbnRgIGZpdHMgaW4gdGhlIG51bWJlciBvZiBieXRlcy5cbiAqL1xuZnVuY3Rpb24gYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZXMpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlcyA+IDApO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBtYXNrID0gdmFsdWUgPj4gQmlnSW50KDMxKTtcbiAgICByZXR1cm4gISgoKH52YWx1ZSAmIG1hc2spICsgKHZhbHVlICYgfm1hc2spKSA+PiBCaWdJbnQoYnl0ZXMgKiA4ICsgfjApKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC4gVGhpcyB1c2VzIHR3bydzIGNvbXBsZW1lbnRcbiAqIGVuY29kaW5nIHRvIHJlcHJlc2VudCBuZWdhdGl2ZSBudW1iZXJzLlxuICpcbiAqIFRvIGNvbnZlcnQgYW4gdW5zaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9CeXRlc30uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIGBVaW50OEFycmF5YC4gSWYgdGhlIG51bWJlclxuICogaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGxlbmd0aCxcbiAqIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZEJpZ0ludFRvQnl0ZXModmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicsICdCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJ5dGVMZW5ndGggPiAwLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdJbnRGaXRzKHZhbHVlLCBieXRlTGVuZ3RoKSwgJ0J5dGUgbGVuZ3RoIGlzIHRvbyBzbWFsbCB0byByZXByZXNlbnQgdGhlIGdpdmVuIHZhbHVlLicpO1xuICAgIC8vIEVTTGludCBkb2Vzbid0IGxpa2UgbXV0YXRpbmcgZnVuY3Rpb24gcGFyYW1ldGVycywgc28gdG8gYXZvaWQgaGF2aW5nIHRvXG4gICAgLy8gZGlzYWJsZSB0aGUgcnVsZSwgd2UgY3JlYXRlIGEgbmV3IHZhcmlhYmxlLlxuICAgIGxldCBudW1iZXJWYWx1ZSA9IHZhbHVlO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IE51bWJlcihCaWdJbnQuYXNVaW50Tig4LCBudW1iZXJWYWx1ZSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBudW1iZXJWYWx1ZSA+Pj0gQmlnSW50KDgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gc2lnbmVkQmlnSW50VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBudW1iZXJgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0J5dGVzYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IG51bWJlclRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgc3RyaW5nYCB0byBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBieXRlLWxpa2UgdmFsdWUgdG8gYSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZSBjYW4gYmUgYSBgVWludDhBcnJheWAsXG4gKiBhIGBiaWdpbnRgLCBhIGBudW1iZXJgLCBvciBhIGBzdHJpbmdgLlxuICpcbiAqIFRoaXMgd2lsbCBhdHRlbXB0IHRvIGd1ZXNzIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBiYXNlZCBvbiBpdHMgdHlwZSBhbmRcbiAqIGNvbnRlbnRzLiBGb3IgbW9yZSBjb250cm9sIG92ZXIgdGhlIGNvbnZlcnNpb24sIHVzZSB0aGUgbW9yZSBzcGVjaWZpY1xuICogY29udmVyc2lvbiBmdW5jdGlvbnMsIHN1Y2ggYXMge0BsaW5rIGhleFRvQnl0ZXN9IG9yIHtAbGluayBzdHJpbmdUb0J5dGVzfS5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgc3RyaW5nYCwgYW5kIGl0IGlzIHByZWZpeGVkIHdpdGggYDB4YCwgaXQgd2lsbCBiZVxuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhXG4gKiBVVEYtOCBzdHJpbmcuIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYnl0ZXMgd2l0aG91dCBpbnRlcnByZXRpbmdcbiAqIGl0IGFzIGEgVVRGLTggc3RyaW5nLCB1c2Uge0BsaW5rIGhleFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIGFzc3VtZWQgdG8gYmUgdW5zaWduZWQuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIHRvIGJ5dGVzLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gdmFsdWVUb0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGJpZ0ludFRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZSB0eXBlOiBcIiR7dHlwZW9mIHZhbHVlfVwiLmApO1xufVxuZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSB2YWx1ZVRvQnl0ZXM7XG4vKipcbiAqIENvbmNhdGVuYXRlIG11bHRpcGxlIGJ5dGUtbGlrZSB2YWx1ZXMgaW50byBhIHNpbmdsZSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZXNcbiAqIGNhbiBiZSBgVWludDhBcnJheWAsIGBiaWdpbnRgLCBgbnVtYmVyYCwgb3IgYHN0cmluZ2AuIFRoaXMgdXNlc1xuICoge0BsaW5rIHZhbHVlVG9CeXRlc30gdW5kZXIgdGhlIGhvb2QgdG8gY29udmVydCBlYWNoIHZhbHVlIHRvIGJ5dGVzLiBSZWZlciB0b1xuICogdGhlIGRvY3VtZW50YXRpb24gb2YgdGhhdCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWVzID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlVG9CeXRlcyh2YWx1ZXNbaV0pO1xuICAgICAgICBub3JtYWxpemVkVmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgIGJ5dGVMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgbm9ybWFsaXplZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB3ZSBjb3VsZCBzaW1wbHkgc3ByZWFkIHRoZSB2YWx1ZXMgaW50byBhbiBhcnJheSBhbmQgdXNlXG4gICAgICAgIC8vIGBVaW50OEFycmF5LmZyb21gLCB0aGF0IGlzIGEgbG90IHNsb3dlciB0aGFuIHVzaW5nIGBVaW50OEFycmF5LnNldGAuXG4gICAgICAgIGJ5dGVzLnNldChub3JtYWxpemVkVmFsdWVzW2ldLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gbm9ybWFsaXplZFZhbHVlc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBmcm9tIGEge0BsaW5rIFVpbnQ4QXJyYXl9LiBUaGlzIGlzIGEgY29udmVuaWVuY2VcbiAqIGZ1bmN0aW9uIHRoYXQgYXZvaWRzIGhhdmluZyB0byBjcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IG1hbnVhbGx5LCB3aGljaFxuICogcmVxdWlyZXMgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBldmVyeSB0aW1lLlxuICpcbiAqIE5vdCBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGNhbiByZXN1bHQgaW5cbiAqIHVuZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiB0aGUge0BsaW5rIFVpbnQ4QXJyYXl9IGlzIGEgdmlldyBvZiBhIGxhcmdlclxuICoge0BsaW5rIEFycmF5QnVmZmVyfSwgZS5nLiwgd2hlbiB1c2luZyB7QGxpbmsgVWludDhBcnJheS5zdWJhcnJheX0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHNvIHN1cHBvcnRzIE5vZGUuanMge0BsaW5rIEJ1ZmZlcn1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSk7XG4gKlxuICogLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvOlxuICogLy8gY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAqIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpO1xuICogYGBgXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY3JlYXRlIHRoZSB7QGxpbmsgRGF0YVZpZXd9IGZyb20uXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIERhdGFWaWV3fS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpIHtcbiAgICAvLyBUbyBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggTm9kZS5qcywgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgYnl0ZXMgYXJlXG4gICAgLy8gYSBCdWZmZXIuIElmIHNvLCB3ZSBuZWVkIHRvIHNsaWNlIHRoZSBidWZmZXIgdG8gZ2V0IHRoZSB1bmRlcmx5aW5nXG4gICAgLy8gQXJyYXlCdWZmZXIuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBieXRlcy5idWZmZXIuc2xpY2UoYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZU9mZnNldCArIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbn1cbmV4cG9ydHMuY3JlYXRlRGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NFwiKTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5zaXplKSgoMCwgYmFzZTY0XzEuYmFzZTY0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIHsgcGFkZGluZ1JlcXVpcmVkOiB0cnVlIH0pLCA0NCwgNDQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzdW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUhleCA9IGV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBleHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGV4cG9ydHMuY3JlYXRlTnVtYmVyID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRnJvemVuTWFwX21hcCwgX0Zyb3plblNldF9zZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyb3plblNldCA9IGV4cG9ydHMuRnJvemVuTWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seU1hcH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIG1hcCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgbWFwLlxuICovXG5jbGFzcyBGcm96ZW5NYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgX0Zyb3plbk1hcF9tYXAuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIG5ldyBNYXAoZW50cmllcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBtYXAuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZm9yRWFjaCgodmFsdWUsIGtleSwgX21hcCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuaGFzKGtleSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plbk1hcCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke1N0cmluZyhrZXkpfSA9PiAke1N0cmluZyh2YWx1ZSl9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plbk1hcCA9IEZyb3plbk1hcDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlTZXR9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBzZXQgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIHNldC5cbiAqL1xuY2xhc3MgRnJvemVuU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgX0Zyb3plblNldF9zZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plblNldF9zZXQsIG5ldyBTZXQodmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5TZXRfc2V0ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIHNldC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwgdmFsdWUyLCBfc2V0KSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlMiwgdGhpcykpO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5TZXQoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy52YWx1ZXMoKV0ubWFwKChtZW1iZXIpID0+IFN0cmluZyhtZW1iZXIpKS5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuU2V0ID0gRnJvemVuU2V0O1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXApO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXAucHJvdG90eXBlKTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0KTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0LnByb3RvdHlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlMHggPSBleHBvcnRzLmFkZDB4ID0gZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gZXhwb3J0cy5IZXhTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5leHBvcnRzLkhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG5leHBvcnRzLlN0cmljdEhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14weFswLTlhLWZdKyQvaXUpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8qKlxuICogU3RyaWN0bHkgY2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdFxuICogc3RhcnQgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGlzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzSGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG59XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBzdGFydCB3aXRoXG4gKiB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGFzc2VydElzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBZGQgdGhlIGAweGAtcHJlZml4IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaGFzIHRoZVxuICogcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFkZCB0aGUgcHJlZml4IHRvLlxuICogQHJldHVybnMgVGhlIHByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZXhwb3J0cy5hZGQweCA9IGFkZDB4O1xuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW1vdmUweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpIHx8IGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xufVxuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXJ0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlNjRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGVja3N1bVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29lcmNlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21pc2NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3BhcXVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90aW1lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92ZXJzaW9uc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVKc29uQW5kR2V0U2l6ZSA9IGV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmlzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9IGV4cG9ydHMuanNvbnJwYzIgPSBleHBvcnRzLmlzVmFsaWRKc29uID0gZXhwb3J0cy5Kc29uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgbWlzY18xID0gcmVxdWlyZShcIi4vbWlzY1wiKTtcbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZSkoJ0pzb24nLCAodmFsdWUpID0+IHtcbiAgICBjb25zdCBbaXNWYWxpZF0gPSB2YWxpZGF0ZUpzb25BbmRHZXRTaXplKHZhbHVlLCB0cnVlKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuICdFeHBlY3RlZCBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlJztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLCBpLmUuLCBhIHZhbHVlIHRoYXQgaXNcbiAqIHNlcmlhbGl6YWJsZSB0byBKU09OLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIFRoZSBzdHJpbmcgJzIuMCcuXG4gKi9cbmV4cG9ydHMuanNvbnJwYzIgPSAnMi4wJztcbmV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5saXRlcmFsKShleHBvcnRzLmpzb25ycGMyKTtcbmV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubnVsbGFibGUpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCldKSk7XG5leHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGNvZGU6ICgwLCBzdXBlcnN0cnVjdF8xLmludGVnZXIpKCksXG4gICAgbWVzc2FnZTogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIGRhdGE6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpKSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSkpO1xuZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIG1ldGhvZDogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIHBhcmFtczogZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vbWl0KShleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCBbJ2lkJ10pO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259XG4gKiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGlzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIG5vdGlmaWNhdGlvbicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVxdWVzdCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gaXNKc29uUnBjUmVxdWVzdDtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIEpTT04tUlBDIHJlcXVlc3Qgb3Igbm90aWZpY2F0aW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0KHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXF1ZXN0JywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGFzc2VydElzSnNvblJwY1JlcXVlc3Q7XG5leHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmtub3duKSgpKSxcbiAgICBlcnJvcjogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogZXhwb3J0cy5Kc29uU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgZXJyb3I6IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbXG4gICAgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCxcbiAgICBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0LFxuXSk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgd2hldGhlciBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgYVxuICoge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBwZW5kaW5nLlxuICovXG5mdW5jdGlvbiBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkocmVzcG9uc2UsIGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCwgJ0ludmFsaWQgcGVuZGluZyBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGEge0BsaW5rIEpzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIEpzb25ScGNSZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gaXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXNwb25zZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gaXNKc29uUnBjU3VjY2Vzcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNTdWNjZXNzKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBzdWNjZXNzIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGFzc2VydElzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0ZhaWx1cmUodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGlzSnNvblJwY0ZhaWx1cmU7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZmFpbHVyZSByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBhc3NlcnRJc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0Vycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGlzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRXJyb3IodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBlcnJvcicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gYXNzZXJ0SXNKc29uUnBjRXJyb3I7XG4vKipcbiAqIEdldHMgYSBmdW5jdGlvbiBmb3IgdmFsaWRhdGluZyBKU09OLVJQQyByZXF1ZXN0IC8gcmVzcG9uc2UgYGlkYCB2YWx1ZXMuXG4gKlxuICogQnkgbWFuaXB1bGF0aW5nIHRoZSBvcHRpb25zIG9mIHRoaXMgZmFjdG9yeSwgeW91IGNhbiBjb250cm9sIHRoZSBiZWhhdmlvclxuICogb2YgdGhlIHJlc3VsdGluZyB2YWxpZGF0b3IgZm9yIHNvbWUgZWRnZSBjYXNlcy4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBlLmcuXG4gKiBgbnVsbGAgc2hvdWxkIHNvbWV0aW1lcyBidXQgbm90IGFsd2F5cyBiZSBwZXJtaXR0ZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBlbXB0eSBzdHJpbmcgKGAnJ2ApIGlzIGFsd2F5cyBwZXJtaXR0ZWQgYnkgdGhlIEpTT04tUlBDXG4gKiBzcGVjaWZpY2F0aW9uLCBidXQgdGhhdCBraW5kIG9mIHN1Y2tzIGFuZCB5b3UgbWF5IHdhbnQgdG8gZm9yYmlkIGl0IGluIHNvbWVcbiAqIGluc3RhbmNlcyBhbnl3YXkuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZVxuICogW0pTT04tUlBDIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmpzb25ycGMub3JnL3NwZWNpZmljYXRpb24pLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRFbXB0eVN0cmluZyAtIFdoZXRoZXIgdGhlIGVtcHR5IHN0cmluZyAoaS5lLiBgJydgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC4gRGVmYXVsdDogYHRydWVgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRGcmFjdGlvbnMgLSBXaGV0aGVyIGZyYWN0aW9uYWwgbnVtYmVycyAoZS5nLiBgMS4yYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkIElEcy4gRGVmYXVsdDogYGZhbHNlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0TnVsbCAtIFdoZXRoZXIgYG51bGxgIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuXG4gKiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEByZXR1cm5zIFRoZSBKU09OLVJQQyBJRCB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25ScGNJZFZhbGlkYXRvcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwZXJtaXRFbXB0eVN0cmluZywgcGVybWl0RnJhY3Rpb25zLCBwZXJtaXROdWxsIH0gPSBPYmplY3QuYXNzaWduKHsgcGVybWl0RW1wdHlTdHJpbmc6IHRydWUsIHBlcm1pdEZyYWN0aW9uczogZmFsc2UsIHBlcm1pdE51bGw6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3Ige0BsaW5rIEpzb25ScGNJZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSlNPTi1SUEMgSUQgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gSUQgaXMgdmFsaWQgcGVyIHRoZSBvcHRpb25zIGdpdmVuIHRvIHRoZVxuICAgICAqIGZhY3RvcnkuXG4gICAgICovXG4gICAgY29uc3QgaXNWYWxpZEpzb25ScGNJZCA9IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbigodHlwZW9mIGlkID09PSAnbnVtYmVyJyAmJiAocGVybWl0RnJhY3Rpb25zIHx8IE51bWJlci5pc0ludGVnZXIoaWQpKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmIChwZXJtaXRFbXB0eVN0cmluZyB8fCBpZC5sZW5ndGggPiAwKSkgfHxcbiAgICAgICAgICAgIChwZXJtaXROdWxsICYmIGlkID09PSBudWxsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gaXNWYWxpZEpzb25ScGNJZDtcbn1cbmV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZ2V0SnNvblJwY0lkVmFsaWRhdG9yO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIEpTT04gc2VyaWFsaXphYmxlIGFuZCBjb3VudHMgdGhlIHRvdGFsIG51bWJlclxuICogb2YgYnl0ZXMgbmVlZGVkIHRvIHN0b3JlIHRoZSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBqc09iamVjdCAtIFBvdGVudGlhbCBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcGFyYW0gc2tpcFNpemluZ1Byb2Nlc3MgLSBTa2lwIEpTT04gc2l6ZSBjYWxjdWxhdGlvbiAoZGVmYXVsdDogZmFsc2UpLlxuICogQHJldHVybnMgVHVwbGUgW2lzVmFsaWQsIHBsYWluVGV4dFNpemVJbkJ5dGVzXSBjb250YWluaW5nIGEgYm9vbGVhbiB0aGF0IHNpZ25hbHMgd2hldGhlclxuICogdGhlIHZhbHVlIHdhcyBzZXJpYWxpemFibGUgYW5kIGEgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaXQgd2lsbCB1c2Ugd2hlbiBzZXJpYWxpemVkIHRvIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSnNvbkFuZEdldFNpemUoanNPYmplY3QsIHNraXBTaXppbmdQcm9jZXNzID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIEpTT04gc2VyaWFsaXphYmxlIGFuZCBjb3VudHMgdGhlIHRvdGFsIG51bWJlclxuICAgICAqIG9mIGJ5dGVzIG5lZWRlZCB0byBzdG9yZSB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgZW5jb2Rpbmcgb2YgdGhlIEpTT04gaXMgZG9uZSBpbiBVVEYtOC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFBvdGVudGlhbCBKU09OIHNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gc2tpcFNpemluZyAtIFNraXAgSlNPTiBzaXplIGNhbGN1bGF0aW9uIChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICogQHJldHVybnMgVHVwbGUgW2lzVmFsaWQsIHBsYWluVGV4dFNpemVJbkJ5dGVzXSBjb250YWluaW5nIGEgYm9vbGVhbiB0aGF0IHNpZ25hbHMgd2hldGhlclxuICAgICAqIHRoZSB2YWx1ZSB3YXMgc2VyaWFsaXphYmxlIGFuZCBhIG51bWJlciBvZiBieXRlcyB0aGF0IGl0IHdpbGwgdXNlIHdoZW4gc2VyaWFsaXplZCB0byBKU09OLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEpzb25TZXJpYWxpemFibGVJbmZvKHZhbHVlLCBza2lwU2l6aW5nKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGFscmVhZHkgc3BlY2lmaWVkIGNvbnN0YW50IHNpemUgZm9yIG51bGwgKHNwZWNpYWwgb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBza2lwU2l6aW5nID8gMCA6IG1pc2NfMS5Kc29uU2l6ZS5OdWxsXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBhbmQgY2FsY3VsYXRlIHNpemVzIGZvciBiYXNpYyAoYW5kIHNvbWUgc3BlY2lhbCkgdHlwZXNcbiAgICAgICAgY29uc3QgdHlwZU9mVmFsdWUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZU9mVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaXppbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoMCwgbWlzY18xLmNhbGN1bGF0ZVN0cmluZ1NpemUpKHZhbHVlKSArIG1pc2NfMS5Kc29uU2l6ZS5RdW90ZSAqIDIsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgdmFsdWUgPT0gdHJ1ZSA/IG1pc2NfMS5Kc29uU2l6ZS5UcnVlIDogbWlzY18xLkpzb25TaXplLkZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgKDAsIG1pc2NfMS5jYWxjdWxhdGVOdW1iZXJTaXplKSh2YWx1ZSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogSW52YWxpZCBkYXRlcyB3aWxsIHNlcmlhbGl6ZSB0byBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlzTmFOKHZhbHVlLmdldERhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbWlzY18xLkpzb25TaXplLk51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWlzY18xLkpzb25TaXplLkRhdGUgKyBtaXNjXzEuSnNvblNpemUuUXVvdGUgKiAyLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG9iamVjdCBpcyBub3QgcGxhaW4gYW5kIGNhbm5vdCBiZSBzZXJpYWxpemVkIHByb3Blcmx5LFxuICAgICAgICAvLyBzdG9wIGhlcmUgYW5kIHJldHVybiBmYWxzZSBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAoISgwLCBtaXNjXzEuaXNQbGFpbk9iamVjdCkodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2lyY3VsYXIgb2JqZWN0IGRldGVjdGlvbiAoaGFuZGxpbmcpXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzYW1lIG9iamVjdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAoc2Vlbk9iamVjdHMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG5ldyBvYmplY3QgdG8gdGhlIHNlZW4gb2JqZWN0cyBzZXRcbiAgICAgICAgLy8gT25seSB0aGUgcGxhaW4gb2JqZWN0cyBzaG91bGQgYmUgYWRkZWQgKFByaW1pdGl2ZSB0eXBlcyBhcmUgc2tpcHBlZClcbiAgICAgICAgc2Vlbk9iamVjdHMuYWRkKHZhbHVlKTtcbiAgICAgICAgLy8gQ29udGludWUgb2JqZWN0IGRlY29tcG9zaXRpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkucmVkdWNlKChzdW0sIFtrZXksIG5lc3RlZFZhbHVlXSwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvY2VzcyBuZXh0IG5lc3RlZCBvYmplY3Qgb3IgcHJpbWl0aXZlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICAgICAgICAgICAgICBsZXQgW3ZhbGlkLCBzaXplXSA9IGdldEpzb25TZXJpYWxpemFibGVJbmZvKG5lc3RlZFZhbHVlLCBza2lwU2l6aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OIHZhbGlkYXRpb24gZGlkIG5vdCBwYXNzLiBWYWxpZGF0aW9uIHByb2Nlc3Mgc3RvcHBlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaXJjdWxhciBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2UgYSBjaGlsZCBub2RlIGlzIHZpc2l0ZWQgYW5kIHByb2Nlc3NlZCByZW1vdmUgaXQgZnJvbSB0aGUgc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBmYWxzZSBwb3NpdGl2ZXMgd2l0aCB0aGUgc2FtZSBhZGphY2VudCBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICBzZWVuT2JqZWN0cy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0cyB3aWxsIGhhdmUgYmUgc2VyaWFsaXplZCB3aXRoIFwia2V5XCI6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZWZvcmUgd2UgaW5jbHVkZSB0aGUga2V5IGluIHRoZSBjYWxjdWxhdGlvbiBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVNpemUgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGtleS5sZW5ndGggKyBtaXNjXzEuSnNvblNpemUuQ29tbWEgKyBtaXNjXzEuSnNvblNpemUuQ29sb24gKiAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBpZHggPCBhcnIubGVuZ3RoIC0gMSA/IG1pc2NfMS5Kc29uU2l6ZS5Db21tYSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyBrZXlTaXplICsgc2l6ZSArIHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTdGFydHMgYXQgMiBiZWNhdXNlIHRoZSBzZXJpYWxpemVkIEpTT04gc3RyaW5nIGRhdGEgKHBsYWluIHRleHQpXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBtaW5pbWFsbHkgY29udGFpbiB7fS9bXVxuICAgICAgICAgICAgICAgIHNraXBTaXppbmcgPyAwIDogbWlzY18xLkpzb25TaXplLldyYXBwZXIgKiAyKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyhqc09iamVjdCwgc2tpcFNpemluZ1Byb2Nlc3MpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUpzb25BbmRHZXRTaXplID0gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGV4cG9ydHMuY3JlYXRlUHJvamVjdExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGdsb2JhbExvZ2dlciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdtZXRhbWFzaycpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZFxuICogdXNpbmcgdGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBCeSBkZWZhdWx0LCBzdWNoIG1lc3NhZ2VzIHdpbGwgYmVcbiAqIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtIGJ5IHNldHRpbmcgdGhlIGBERUJVR2AgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlIHRvIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cyB0aGF0XG4gKiBhcmUgYWxzbyB1c2luZyB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGVpciBsb2dnZXJzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gVGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2ZcbiAqIHlvdXIgTlBNIHBhY2thZ2UgaWYgeW91J3JlIGRldmVsb3Bpbmcgb25lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvamVjdExvZ2dlcihwcm9qZWN0TmFtZSkge1xuICAgIHJldHVybiBnbG9iYWxMb2dnZXIuZXh0ZW5kKHByb2plY3ROYW1lKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvamVjdExvZ2dlciA9IGNyZWF0ZVByb2plY3RMb2dnZXI7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hpY2ggaXMgZGVyaXZlZCBmcm9tIHRoZSBsb2dnZXIgZm9yXG4gKiB0aGUgd2hvbGUgcHJvamVjdCB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWQgdXNpbmcgdGhlIG5hbWUgb2YgeW91clxuICogbW9kdWxlLiBCeSBkZWZhdWx0LCBzdWNoIG1lc3NhZ2VzIHdpbGwgYmUgc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW1cbiAqIGJ5IHNldHRpbmcgdGhlIGBERUJVR2AgZW52aXJvbm1lbnQgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+Ojxtb2R1bGVOYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIHRoZSBwcm9qZWN0LFxuICogb3IgYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMuXG4gKlxuICogQHBhcmFtIHByb2plY3RMb2dnZXIgLSBUaGUgbG9nZ2VyIGNyZWF0ZWQgdmlhIHtAbGluayBjcmVhdGVQcm9qZWN0TG9nZ2VyfS5cbiAqIEBwYXJhbSBtb2R1bGVOYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBtb2R1bGUuIFlvdSBjb3VsZCB1c2UgdGhlIG5hbWUgb2YgdGhlXG4gKiBmaWxlIHdoZXJlIHlvdSdyZSB1c2luZyB0aGlzIGxvZ2dlciBvciBzb21lIG90aGVyIG5hbWUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2R1bGVMb2dnZXIocHJvamVjdExvZ2dlciwgbW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBwcm9qZWN0TG9nZ2VyLmV4dGVuZChtb2R1bGVOYW1lKTtcbn1cbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gY3JlYXRlTW9kdWxlTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vXG4vLyBUeXBlc1xuLy9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGV4cG9ydHMuaXNBU0NJSSA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gZXhwb3J0cy5Kc29uU2l6ZSA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogUHJlZGVmaW5lZCBzaXplcyAoaW4gQnl0ZXMpIG9mIHNwZWNpZmljIHBhcnRzIG9mIEpTT04gc3RydWN0dXJlLlxuICovXG52YXIgSnNvblNpemU7XG4oZnVuY3Rpb24gKEpzb25TaXplKSB7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJOdWxsXCJdID0gNF0gPSBcIk51bGxcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbW1hXCJdID0gMV0gPSBcIkNvbW1hXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJXcmFwcGVyXCJdID0gMV0gPSBcIldyYXBwZXJcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlRydWVcIl0gPSA0XSA9IFwiVHJ1ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRmFsc2VcIl0gPSA1XSA9IFwiRmFsc2VcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlF1b3RlXCJdID0gMV0gPSBcIlF1b3RlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb2xvblwiXSA9IDFdID0gXCJDb2xvblwiO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJEYXRlXCJdID0gMjRdID0gXCJEYXRlXCI7XG59KShKc29uU2l6ZSA9IGV4cG9ydHMuSnNvblNpemUgfHwgKGV4cG9ydHMuSnNvblNpemUgPSB7fSkpO1xuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBwYXR0ZXJuIG1hdGNoaW5nIGZvciAoc3BlY2lhbCkgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IC9cInxcXFxcfFxcbnxcXHJ8XFx0L2d1O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFuIG9iamVjdCBpcyB0aGUgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsXG4gKiBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBwbGFpbiAoZS5nLiBmdW5jdGlvbikuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4vKipcbiAqIENoZWNrIGlmIGNoYXJhY3RlciBpcyBBU0NJSS5cbiAqXG4gKiBAcGFyYW0gY2hhcmFjdGVyIC0gQ2hhcmFjdGVyLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhIGNoYXJhY3RlciBjb2RlIGlzIEFTQ0lJLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUkoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDEyNztcbn1cbmV4cG9ydHMuaXNBU0NJSSA9IGlzQVNDSUk7XG4vKipcbiAqIENhbGN1bGF0ZSBzdHJpbmcgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBzdHJpbmcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN0cmluZ1NpemUodmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICgoX2EgPSB2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBjYWxjdWxhdGVTdHJpbmdTaXplO1xuLyoqXG4gKiBDYWxjdWxhdGUgc2l6ZSBvZiBhIG51bWJlciBvZnRlciBKU09OIHNlcmlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgbnVtYmVyIGluIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU51bWJlclNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBjYWxjdWxhdGVOdW1iZXJTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlzYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGV4VG9CaWdJbnQgPSBleHBvcnRzLmhleFRvTnVtYmVyID0gZXhwb3J0cy5iaWdJbnRUb0hleCA9IGV4cG9ydHMubnVtYmVyVG9IZXggPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBleHBvcnRzLmd0UmFuZ2UgPSBleHBvcnRzLmd0VmVyc2lvbiA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSBleHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXItZnJvbS1lbmdpbmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWZyb20tbWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdmlkZXJGcm9tRW5naW5lID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9zYWZlLWV2ZW50LWVtaXR0ZXItcHJvdmlkZXJcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhbiBFdGhlcmV1bSBwcm92aWRlciBmcm9tIHRoZSBnaXZlbiBKU09OLVJQQyBlbmdpbmUuXG4gKlxuICogQHBhcmFtIGVuZ2luZSAtIFRoZSBKU09OLVJQQyBlbmdpbmUgdG8gY29uc3RydWN0IGEgcHJvdmlkZXIgZnJvbS5cbiAqIEByZXR1cm5zIEFuIEV0aGVyZXVtIHByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XG4gICAgcmV0dXJuIG5ldyBzYWZlX2V2ZW50X2VtaXR0ZXJfcHJvdmlkZXJfMS5TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXIoeyBlbmdpbmUgfSk7XG59XG5leHBvcnRzLnByb3ZpZGVyRnJvbUVuZ2luZSA9IHByb3ZpZGVyRnJvbUVuZ2luZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWZyb20tZW5naW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm92aWRlckZyb21NaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgcHJvdmlkZXJfZnJvbV9lbmdpbmVfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWZyb20tZW5naW5lXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gcHJvdmlkZXIgZnJvbSB0aGUgZ2l2ZW4gbWlkZGxld2FyZS5cbiAqXG4gKiBAcGFyYW0gbWlkZGxld2FyZSAtIFRoZSBtaWRkbGV3YXJlIHRvIGNvbnN0cnVjdCBhIHByb3ZpZGVyIGZyb20uXG4gKiBAcmV0dXJucyBBbiBFdGhlcmV1bSBwcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShtaWRkbGV3YXJlKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IGpzb25fcnBjX2VuZ2luZV8xLkpzb25ScGNFbmdpbmUoKTtcbiAgICBlbmdpbmUucHVzaChtaWRkbGV3YXJlKTtcbiAgICBjb25zdCBwcm92aWRlciA9ICgwLCBwcm92aWRlcl9mcm9tX2VuZ2luZV8xLnByb3ZpZGVyRnJvbUVuZ2luZSkoZW5naW5lKTtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG59XG5leHBvcnRzLnByb3ZpZGVyRnJvbU1pZGRsZXdhcmUgPSBwcm92aWRlckZyb21NaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItZnJvbS1taWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXJfZW5naW5lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG4vKipcbiAqIEFuIEV0aGVyZXVtIHByb3ZpZGVyLlxuICpcbiAqIFRoaXMgcHJvdmlkZXIgbG9vc2VseSBmb2xsb3dzIGNvbnZlbnRpb25zIHRoYXQgcHJlLWRhdGUgRUlQLTExOTMuXG4gKiBJdCBpcyBub3QgY29tcGxpYW50IHdpdGggYW55IEV0aGVyZXVtIHByb3ZpZGVyIHN0YW5kYXJkLlxuICovXG5jbGFzcyBTYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXIgZXh0ZW5kcyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBTYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXIgZnJvbSBhIEpTT04tUlBDIGVuZ2luZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5lbmdpbmUgLSBUaGUgSlNPTi1SUEMgZW5naW5lIHVzZWQgdG8gcHJvY2VzcyByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGVuZ2luZSB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIF9TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXJfZW5naW5lLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBhIHByb3ZpZGVyIHJlcXVlc3QgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZXEgLSBUaGUgcmVxdWVzdCB0byBzZW5kLlxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHVwb24gdGhlIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBvZiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VuZEFzeW5jID0gKHJlcSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NhZmVFdmVudEVtaXR0ZXJQcm92aWRlcl9lbmdpbmUsIFwiZlwiKS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIGEgcHJvdmlkZXIgcmVxdWVzdCBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2VydmVzIHRoZSBzYW1lIHB1cnBvc2UgYXMgYHNlbmRBc3luY2AuIEl0IG9ubHkgZXhpc3RzIGZvclxuICAgICAgICAgKiBsZWdhY3kgcmVhc29ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGBzZW5kQXN5bmNgIGluc3RlYWQuXG4gICAgICAgICAqIEBwYXJhbSByZXEgLSBUaGUgcmVxdWVzdCB0byBzZW5kLlxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHVwb24gdGhlIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBvZiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VuZCA9IChyZXEsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgY2FsbGJhY2sgdG8gXCJzZW5kXCIgbWV0aG9kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyX2VuZ2luZSwgXCJmXCIpLmhhbmRsZShyZXEsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyX2VuZ2luZSwgZW5naW5lLCBcImZcIik7XG4gICAgICAgIGlmIChlbmdpbmUub24pIHtcbiAgICAgICAgICAgIGVuZ2luZS5vbignbm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXIgPSBTYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXI7XG5fU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyX2VuZ2luZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYWZlLWV2ZW50LWVtaXR0ZXItcHJvdmlkZXIuanMubWFwIiwiY29uc3QgZW5jcnlwdG9yID0gcmVxdWlyZSgnQG1ldGFtYXNrL2Jyb3dzZXItcGFzc3dvcmRlcicpO1xuY29uc3QgSGRLZXlyaW5nID0gcmVxdWlyZSgnQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nJyk7XG5jb25zdCB7IG5vcm1hbGl6ZTogbm9ybWFsaXplQWRkcmVzcyB9ID0gcmVxdWlyZSgnQG1ldGFtYXNrL2V0aC1zaWctdXRpbCcpO1xuY29uc3QgU2ltcGxlS2V5cmluZyA9IHJlcXVpcmUoJ0BtZXRhbWFzay9ldGgtc2ltcGxlLWtleXJpbmcnKTtcbi8vIFRPRE86IFN0b3AgdXNpbmcgYGV2ZW50c2AsIGFuZCByZW1vdmUgdGhlIG5vdGljZSBhYm91dCB0aGlzIGZyb20gdGhlIFJFQURNRVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlc1xuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgT2JzZXJ2YWJsZVN0b3JlID0gcmVxdWlyZSgnb2JzLXN0b3JlJyk7XG5cbmNvbnN0IGRlZmF1bHRLZXlyaW5nQnVpbGRlcnMgPSBbXG4gIGtleXJpbmdCdWlsZGVyRmFjdG9yeShTaW1wbGVLZXlyaW5nKSxcbiAga2V5cmluZ0J1aWxkZXJGYWN0b3J5KEhkS2V5cmluZyksXG5dO1xuXG5jb25zdCBLRVlSSU5HU19UWVBFX01BUCA9IHtcbiAgSERfS0VZUklORzogJ0hEIEtleSBUcmVlJyxcbiAgU0lNUExFX0tFWVJJTkc6ICdTaW1wbGUgS2V5IFBhaXInLFxufTtcblxuLyoqXG4gKiBTdHJpcCB0aGUgaGV4IHByZWZpeCBmcm9tIGFuIGFkZHJlc3MsIGlmIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0aGF0IG1pZ2h0IGJlIGhleCBwcmVmaXhlZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhZGRyZXNzIHdpdGhvdXQgYSBoZXggcHJlZml4LlxuICovXG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChhZGRyZXNzKSB7XG4gIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICByZXR1cm4gYWRkcmVzcy5zbGljZSgyKTtcbiAgfVxuICByZXR1cm4gYWRkcmVzcztcbn1cblxuY2xhc3MgS2V5cmluZ0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvL1xuICAvLyBQVUJMSUMgTUVUSE9EU1xuICAvL1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IGluaXRTdGF0ZSA9IG9wdHMuaW5pdFN0YXRlIHx8IHt9O1xuICAgIHRoaXMua2V5cmluZ0J1aWxkZXJzID0gb3B0cy5rZXlyaW5nQnVpbGRlcnNcbiAgICAgID8gZGVmYXVsdEtleXJpbmdCdWlsZGVycy5jb25jYXQob3B0cy5rZXlyaW5nQnVpbGRlcnMpXG4gICAgICA6IGRlZmF1bHRLZXlyaW5nQnVpbGRlcnM7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcbiAgICB0aGlzLm1lbVN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSh7XG4gICAgICBpc1VubG9ja2VkOiBmYWxzZSxcbiAgICAgIGtleXJpbmdUeXBlczogdGhpcy5rZXlyaW5nQnVpbGRlcnMubWFwKFxuICAgICAgICAoa2V5cmluZ0J1aWxkZXIpID0+IGtleXJpbmdCdWlsZGVyLnR5cGUsXG4gICAgICApLFxuICAgICAga2V5cmluZ3M6IFtdLFxuICAgICAgZW5jcnlwdGlvbktleTogbnVsbCxcbiAgICB9KTtcblxuICAgIHRoaXMuZW5jcnlwdG9yID0gb3B0cy5lbmNyeXB0b3IgfHwgZW5jcnlwdG9yO1xuICAgIHRoaXMua2V5cmluZ3MgPSBbXTtcbiAgICB0aGlzLl91bnN1cHBvcnRlZEtleXJpbmdzID0gW107XG5cbiAgICAvLyBUaGlzIG9wdGlvbiBhbGxvd3MgdGhlIGNvbnRyb2xsZXIgdG8gY2FjaGUgYW4gZXhwb3J0ZWQga2V5XG4gICAgLy8gZm9yIHVzZSBpbiBkZWNyeXB0aW5nIGFuZCBlbmNyeXB0aW5nIGRhdGEgd2l0aG91dCBwYXNzd29yZFxuICAgIHRoaXMuY2FjaGVFbmNyeXB0aW9uS2V5ID0gQm9vbGVhbihvcHRzLmNhY2hlRW5jcnlwdGlvbktleSk7XG4gIH1cblxuICAvKipcbiAgICogRnVsbCBVcGRhdGVcbiAgICpcbiAgICogRW1pdHMgdGhlIGB1cGRhdGVgIGV2ZW50IGFuZCBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0b1xuICAgKiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogRnJlcXVlbnRseSB1c2VkIHRvIGVuZCBhc3luY2hyb25vdXMgY2hhaW5zIGluIHRoaXMgY2xhc3MsXG4gICAqIGluZGljYXRpbmcgY29uc3VtZXJzIGNhbiBvZnRlbiBlaXRoZXIgbGlzdGVuIGZvciB1cGRhdGVzLFxuICAgKiBvciBhY2NlcHQgYSBzdGF0ZS1yZXNvbHZpbmcgcHJvbWlzZSB0byBjb25zdW1lIHRoZWlyIHJlc3VsdHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBjb250cm9sbGVyIHN0YXRlLlxuICAgKi9cbiAgZnVsbFVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgTmV3IFZhdWx0IEFuZCBLZXljaGFpblxuICAgKlxuICAgKiBEZXN0cm95cyBhbnkgb2xkIGVuY3J5cHRlZCBzdG9yYWdlLFxuICAgKiBjcmVhdGVzIGEgbmV3IGVuY3J5cHRlZCBzdG9yZSB3aXRoIHRoZSBnaXZlbiBwYXNzd29yZCxcbiAgICogcmFuZG9tbHkgY3JlYXRlcyBhIG5ldyBIRCB3YWxsZXQgd2l0aCAxIGFjY291bnQsXG4gICAqIGZhdWNldHMgdGhhdCBhY2NvdW50IG9uIHRoZSB0ZXN0bmV0LlxuICAgKlxuICAgKiBAZmlyZXMgS2V5cmluZ0NvbnRyb2xsZXIjdW5sb2NrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCB0byBlbmNyeXB0IHRoZSB2YXVsdCB3aXRoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBhc3luYyBjcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKHBhc3N3b3JkKSB7XG4gICAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuXG4gICAgYXdhaXQgdGhpcy5jcmVhdGVGaXJzdEtleVRyZWUoKTtcbiAgICB0aGlzLnNldFVubG9ja2VkKCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZVxuICAgKlxuICAgKiBEZXN0cm95cyBhbnkgb2xkIGVuY3J5cHRlZCBzdG9yYWdlLFxuICAgKiBjcmVhdGVzIGEgbmV3IGVuY3J5cHRlZCBzdG9yZSB3aXRoIHRoZSBnaXZlbiBwYXNzd29yZCxcbiAgICogY3JlYXRlcyBhIG5ldyBIRCB3YWxsZXQgZnJvbSB0aGUgZ2l2ZW4gc2VlZCB3aXRoIDEgYWNjb3VudC5cbiAgICpcbiAgICogQGZpcmVzIEtleXJpbmdDb250cm9sbGVyI3VubG9ja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB0aGUgdmF1bHQgd2l0aC5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgc3RyaW5nfSBzZWVkUGhyYXNlIC0gVGhlIEJJUDM5LWNvbXBsaWFudCBzZWVkIHBocmFzZSxcbiAgICogZWl0aGVyIGFzIGEgc3RyaW5nIG9yIFVpbnQ4QXJyYXkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZShwYXNzd29yZCwgc2VlZFBocmFzZSkge1xuICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIG11c3QgYmUgdGV4dC4nKTtcbiAgICB9XG4gICAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuXG4gICAgYXdhaXQgdGhpcy5jbGVhcktleXJpbmdzKCk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuYWRkTmV3S2V5cmluZyhLRVlSSU5HU19UWVBFX01BUC5IRF9LRVlSSU5HLCB7XG4gICAgICBtbmVtb25pYzogc2VlZFBocmFzZSxcbiAgICAgIG51bWJlck9mQWNjb3VudHM6IDEsXG4gICAgfSk7XG4gICAgY29uc3QgW2ZpcnN0QWNjb3VudF0gPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG5cbiAgICBpZiAoIWZpcnN0QWNjb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlyaW5nQ29udHJvbGxlciAtIEZpcnN0IEFjY291bnQgbm90IGZvdW5kLicpO1xuICAgIH1cbiAgICB0aGlzLnNldFVubG9ja2VkKCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBMb2NrZWRcbiAgICogVGhpcyBtZXRob2QgZGVhbGxvY2F0ZXMgYWxsIHNlY3JldHMsIGFuZCBlZmZlY3RpdmVseSBsb2NrcyBNZXRhTWFzay5cbiAgICpcbiAgICogQGZpcmVzIEtleXJpbmdDb250cm9sbGVyI2xvY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgc2V0TG9ja2VkKCkge1xuICAgIGRlbGV0ZSB0aGlzLnBhc3N3b3JkO1xuXG4gICAgLy8gc2V0IGxvY2tlZFxuICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgaXNVbmxvY2tlZDogZmFsc2UsXG4gICAgICBlbmNyeXB0aW9uS2V5OiBudWxsLFxuICAgICAgZW5jcnlwdGlvblNhbHQ6IG51bGwsXG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUga2V5cmluZ3NcbiAgICB0aGlzLmtleXJpbmdzID0gW107XG4gICAgYXdhaXQgdGhpcy5fdXBkYXRlTWVtU3RvcmVLZXlyaW5ncygpO1xuICAgIHRoaXMuZW1pdCgnbG9jaycpO1xuICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXQgcGFzc3dvcmQuXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGRlY3J5cHQgdGhlIGN1cnJlbnQgdmF1bHQgYW5kIGxvYWQgaXRzIGtleXJpbmdzXG4gICAqIGludG8gbWVtb3J5LlxuICAgKlxuICAgKiBUZW1wb3JhcmlseSBhbHNvIG1pZ3JhdGVzIGFueSBvbGQtc3R5bGUgdmF1bHRzIGZpcnN0LCBhcyB3ZWxsXG4gICAqIChQcmUgTWV0YU1hc2sgMy4wLjApLlxuICAgKlxuICAgKiBAZmlyZXMgS2V5cmluZ0NvbnRyb2xsZXIjdW5sb2NrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSBrZXlyaW5nIGNvbnRyb2xsZXIgcGFzc3dvcmQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIHN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgdGhpcy5rZXlyaW5ncyA9IGF3YWl0IHRoaXMudW5sb2NrS2V5cmluZ3MocGFzc3dvcmQpO1xuXG4gICAgdGhpcy5zZXRVbmxvY2tlZCgpO1xuICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXQgRW5jcnlwdGlvbiBLZXkuXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGRlY3J5cHQgdGhlIGN1cnJlbnQgdmF1bHQgYW5kIGxvYWQgaXRzIGtleXJpbmdzXG4gICAqIGludG8gbWVtb3J5IGJhc2VkIG9uIHRoZSB2YXVsdCBhbmQgQ3J5cHRvS2V5IGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAZmlyZXMgS2V5cmluZ0NvbnRyb2xsZXIjdW5sb2NrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNyeXB0aW9uS2V5IC0gVGhlIGVuY3J5cHRlZCBrZXkgaW5mb3JtYXRpb24gdXNlZCB0byBkZWNyeXB0IHRoZSB2YXVsdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRpb25TYWx0IC0gVGhlIHNhbHQgdXNlZCB0byBnZW5lcmF0ZSB0aGUgbGFzdCBrZXkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIHN1Ym1pdEVuY3J5cHRpb25LZXkoZW5jcnlwdGlvbktleSwgZW5jcnlwdGlvblNhbHQpIHtcbiAgICB0aGlzLmtleXJpbmdzID0gYXdhaXQgdGhpcy51bmxvY2tLZXlyaW5ncyhcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGVuY3J5cHRpb25LZXksXG4gICAgICBlbmNyeXB0aW9uU2FsdCxcbiAgICApO1xuICAgIHRoaXMuc2V0VW5sb2NrZWQoKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IFBhc3N3b3JkXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGRlY3J5cHQgdGhlIGN1cnJlbnQgdmF1bHQgd2l0aCBhIGdpdmVuIHBhc3N3b3JkXG4gICAqIHRvIHZlcmlmeSBpdHMgdmFsaWRpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSB2YXVsdCBwYXNzd29yZC5cbiAgICovXG4gIGFzeW5jIHZlcmlmeVBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVmF1bHQgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkudmF1bHQ7XG4gICAgaWYgKCFlbmNyeXB0ZWRWYXVsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5sb2NrIHdpdGhvdXQgYSBwcmV2aW91cyB2YXVsdC4nKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0b3IuZGVjcnlwdChwYXNzd29yZCwgZW5jcnlwdGVkVmF1bHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBOZXcgS2V5cmluZ1xuICAgKlxuICAgKiBBZGRzIGEgbmV3IEtleXJpbmcgb2YgdGhlIGdpdmVuIGB0eXBlYCB0byB0aGUgdmF1bHRcbiAgICogYW5kIHRoZSBjdXJyZW50IGRlY3J5cHRlZCBLZXlyaW5ncyBhcnJheS5cbiAgICpcbiAgICogQWxsIEtleXJpbmcgY2xhc3NlcyBpbXBsZW1lbnQgYSB1bmlxdWUgYHR5cGVgIHN0cmluZyxcbiAgICogYW5kIHRoaXMgaXMgdXNlZCB0byByZXRyaWV2ZSB0aGVtIGZyb20gdGhlIGtleXJpbmdCdWlsZGVycyBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBrZXlyaW5nIHRvIGFkZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBUaGUgY29uc3RydWN0b3Igb3B0aW9ucyBmb3IgdGhlIGtleXJpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEtleXJpbmc+fSBUaGUgbmV3IGtleXJpbmcuXG4gICAqL1xuICBhc3luYyBhZGROZXdLZXlyaW5nKHR5cGUsIG9wdHMpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5fbmV3S2V5cmluZyh0eXBlLCBvcHRzKTtcblxuICAgIGlmICgoIW9wdHMgfHwgIW9wdHMubW5lbW9uaWMpICYmIHR5cGUgPT09IEtFWVJJTkdTX1RZUEVfTUFQLkhEX0tFWVJJTkcpIHtcbiAgICAgIGtleXJpbmcuZ2VuZXJhdGVSYW5kb21NbmVtb25pYygpO1xuICAgICAgYXdhaXQga2V5cmluZy5hZGRBY2NvdW50cygpO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIGF3YWl0IHRoaXMuY2hlY2tGb3JEdXBsaWNhdGUodHlwZSwgYWNjb3VudHMpO1xuXG4gICAgdGhpcy5rZXlyaW5ncy5wdXNoKGtleXJpbmcpO1xuICAgIGF3YWl0IHRoaXMucGVyc2lzdEFsbEtleXJpbmdzKCk7XG5cbiAgICB0aGlzLmZ1bGxVcGRhdGUoKTtcblxuICAgIHJldHVybiBrZXlyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBFbXB0eSBLZXlyaW5ncy5cbiAgICpcbiAgICogTG9vcHMgdGhyb3VnaCB0aGUga2V5cmluZ3MgYW5kIHJlbW92ZXMgdGhlIG9uZXMgd2l0aCBlbXB0eSBhY2NvdW50c1xuICAgKiAodXN1YWxseSBhZnRlciByZW1vdmluZyB0aGUgbGFzdCAvIG9ubHkgYWNjb3VudCkgZnJvbSBhIGtleXJpbmcuXG4gICAqL1xuICBhc3luYyByZW1vdmVFbXB0eUtleXJpbmdzKCkge1xuICAgIGNvbnN0IHZhbGlkS2V5cmluZ3MgPSBbXTtcblxuICAgIC8vIFNpbmNlIGdldEFjY291bnRzIHJldHVybnMgYSBQcm9taXNlXG4gICAgLy8gV2UgbmVlZCB0byB3YWl0IHRvIGhlYXIgYmFjayBmb3JtIGVhY2gga2V5cmluZ1xuICAgIC8vIGluIG9yZGVyIHRvIGRlY2lkZSB3aGljaCBvbmVzIGFyZSBub3cgdmFsaWQgKGFjY291bnRzLmxlbmd0aCA+IDApXG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMua2V5cmluZ3MubWFwKGFzeW5jIChrZXlyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhbGlkS2V5cmluZ3MucHVzaChrZXlyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgKTtcbiAgICB0aGlzLmtleXJpbmdzID0gdmFsaWRLZXlyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSBrZXlwYWlycywgdXNpbmcgdGhlIHRoZSBmaXJzdCBhY2NvdW50IGluIHRoZSBnaXZlblxuICAgKiBhcnJheS4gUmVqZWN0cyBpZiBhIGR1cGxpY2F0ZSBpcyBmb3VuZC5cbiAgICpcbiAgICogT25seSBzdXBwb3J0cyAnU2ltcGxlIEtleSBQYWlyJy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUga2V5IHBhaXIgdHlwZSB0byBjaGVjayBmb3IuXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbmV3QWNjb3VudEFycmF5IC0gQXJyYXkgb2YgbmV3IGFjY291bnRzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gVGhlIGFjY291bnQsIGlmIG5vIGR1cGxpY2F0ZSBpcyBmb3VuZC5cbiAgICovXG4gIGFzeW5jIGNoZWNrRm9yRHVwbGljYXRlKHR5cGUsIG5ld0FjY291bnRBcnJheSkge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEtFWVJJTkdTX1RZUEVfTUFQLlNJTVBMRV9LRVlSSU5HOiB7XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBCb29sZWFuKFxuICAgICAgICAgIGFjY291bnRzLmZpbmQoXG4gICAgICAgICAgICAoa2V5KSA9PlxuICAgICAgICAgICAgICBrZXkgPT09IG5ld0FjY291bnRBcnJheVswXSB8fFxuICAgICAgICAgICAgICBrZXkgPT09IHN0cmlwSGV4UHJlZml4KG5ld0FjY291bnRBcnJheVswXSksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNJbmNsdWRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgYWNjb3VudCB5b3UgYXJlIHRyeWluZyB0byBpbXBvcnQgaXMgYSBkdXBsaWNhdGUnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0FjY291bnRBcnJheTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gbmV3QWNjb3VudEFycmF5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgTmV3IEFjY291bnQuXG4gICAqXG4gICAqIENhbGxzIHRoZSBgYWRkQWNjb3VudHNgIG1ldGhvZCBvbiB0aGUgZ2l2ZW4ga2V5cmluZyxcbiAgICogYW5kIHRoZW4gc2F2ZXMgdGhvc2UgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlyaW5nfSBzZWxlY3RlZEtleXJpbmcgLSBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGtleXJpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIGFkZE5ld0FjY291bnQoc2VsZWN0ZWRLZXlyaW5nKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBzZWxlY3RlZEtleXJpbmcuYWRkQWNjb3VudHMoMSk7XG4gICAgYWNjb3VudHMuZm9yRWFjaCgoaGV4QWNjb3VudCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCduZXdBY2NvdW50JywgaGV4QWNjb3VudCk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnBlcnNpc3RBbGxLZXlyaW5ncygpO1xuICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgQWNjb3VudFxuICAgKlxuICAgKiBSZXF1ZXN0cyB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUga2V5cmluZyBjb250cm9sbGluZ1xuICAgKiB0aGUgc3BlY2lmaWVkIGFkZHJlc3MuXG4gICAqXG4gICAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgbWF5IHJlc29sdmUgd2l0aCB0aGUgcHJpdmF0ZSBrZXkgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIGV4cG9ydC5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIHByaXZhdGUga2V5IG9mIHRoZSBhY2NvdW50LlxuICAgKi9cbiAgYXN5bmMgZXhwb3J0QWNjb3VudChhZGRyZXNzKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGF3YWl0IGtleXJpbmcuZXhwb3J0QWNjb3VudChub3JtYWxpemVBZGRyZXNzKGFkZHJlc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgQWNjb3VudC5cbiAgICpcbiAgICogUmVtb3ZlcyBhIHNwZWNpZmljIGFjY291bnQgZnJvbSBhIGtleXJpbmdcbiAgICogSWYgdGhlIGFjY291bnQgaXMgdGhlIGxhc3Qvb25seSBvbmUgdGhlbiBpdCBhbHNvIHJlbW92ZXMgdGhlIGtleXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bC5cbiAgICovXG4gIGFzeW5jIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuXG4gICAgLy8gTm90IGFsbCB0aGUga2V5cmluZ3Mgc3VwcG9ydCB0aGlzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrXG4gICAgaWYgKHR5cGVvZiBrZXlyaW5nLnJlbW92ZUFjY291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGtleXJpbmcucmVtb3ZlQWNjb3VudChhZGRyZXNzKTtcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlZEFjY291bnQnLCBhZGRyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgS2V5cmluZyAke2tleXJpbmcudHlwZX0gZG9lc24ndCBzdXBwb3J0IGFjY291bnQgcmVtb3ZhbCBvcGVyYXRpb25zYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyB3YXMgdGhlIGxhc3Qvb25seSBhY2NvdW50XG4gICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXdhaXQgdGhpcy5yZW1vdmVFbXB0eUtleXJpbmdzKCk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wZXJzaXN0QWxsS2V5cmluZ3MoKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvL1xuICAvLyBTSUdOSU5HIE1FVEhPRFNcbiAgLy9cblxuICAvKipcbiAgICogU2lnbiBFdGhlcmV1bSBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBTaWducyBhbiBFdGhlcmV1bSB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldGhUeCAtIFRoZSB0cmFuc2FjdGlvbiB0byBzaWduLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2Zyb21BZGRyZXNzIC0gVGhlIHRyYW5zYWN0aW9uICdmcm9tJyBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIFNpZ25pbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gVGhlIHNpZ25lZCB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oZXRoVHgsIF9mcm9tQWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZnJvbUFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKF9mcm9tQWRkcmVzcyk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoZnJvbUFkZHJlc3MpO1xuICAgIHJldHVybiBhd2FpdCBrZXlyaW5nLnNpZ25UcmFuc2FjdGlvbihmcm9tQWRkcmVzcywgZXRoVHgsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gTWVzc2FnZVxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBzaWduIHRoZSBwcm92aWRlZCBtZXNzYWdlIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbWVzc2FnZSBwYXJhbWV0ZXJzIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBzaWduaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgc2lnbmF0dXJlLlxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2UobXNnUGFyYW1zLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhtc2dQYXJhbXMuZnJvbSk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGF3YWl0IGtleXJpbmcuc2lnbk1lc3NhZ2UoYWRkcmVzcywgbXNnUGFyYW1zLmRhdGEsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gUGVyc29uYWwgTWVzc2FnZVxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBzaWduIHRoZSBwcm92aWRlZCBtZXNzYWdlIHBhcmFtZXRlcnMuXG4gICAqIFByZWZpeGVzIHRoZSBoYXNoIGJlZm9yZSBzaWduaW5nIHBlciB0aGUgcGVyc29uYWwgc2lnbiBleHBlY3RhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtZXNzYWdlIHBhcmFtZXRlcnMgdG8gc2lnbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIHNpZ25pbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gVGhlIHJhdyBzaWduYXR1cmUuXG4gICAqL1xuICBhc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKG1zZ1BhcmFtcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MobXNnUGFyYW1zLmZyb20pO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBhd2FpdCBrZXlyaW5nLnNpZ25QZXJzb25hbE1lc3NhZ2UoYWRkcmVzcywgbXNnUGFyYW1zLmRhdGEsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBlbmNyeXB0aW9uIHB1YmxpYyBrZXlcbiAgICpcbiAgICogR2V0IGVuY3J5cHRpb24gcHVibGljIGtleSBmb3IgdXNpbmcgaW4gZW5jcnlwdC9kZWNyeXB0IHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gZ2V0IHRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgZm9yLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgZW5jcnlwdGlvbiBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBUaGUgcHVibGljIGtleS5cbiAgICovXG4gIGFzeW5jIGdldEVuY3J5cHRpb25QdWJsaWNLZXkoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBhd2FpdCBrZXlyaW5nLmdldEVuY3J5cHRpb25QdWJsaWNLZXkobm9ybWFsaXplZEFkZHJlc3MsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHQgTWVzc2FnZVxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBkZWNyeXB0IHRoZSBwcm92aWRlZCBtZXNzYWdlIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgZGVjcnlwdGlvbiBtZXNzYWdlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBkZWNyeXB0aW9uIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgZGVjcnlwdGlvbiByZXN1bHQuXG4gICAqL1xuICBhc3luYyBkZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKG1zZ1BhcmFtcy5mcm9tKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4ga2V5cmluZy5kZWNyeXB0TWVzc2FnZShhZGRyZXNzLCBtc2dQYXJhbXMuZGF0YSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBUeXBlZCBEYXRhLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9wdWxsLzcxMiNpc3N1ZWNvbW1lbnQtMzI5OTg4NDU0fEVJUDcxMn0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbWVzc2FnZSBwYXJhbWV0ZXJzIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBzaWduaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgc2lnbmF0dXJlLlxuICAgKi9cbiAgYXN5bmMgc2lnblR5cGVkTWVzc2FnZShtc2dQYXJhbXMsIG9wdHMgPSB7IHZlcnNpb246ICdWMScgfSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKG1zZ1BhcmFtcy5mcm9tKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4ga2V5cmluZy5zaWduVHlwZWREYXRhKGFkZHJlc3MsIG1zZ1BhcmFtcy5kYXRhLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhcHAga2V5IGFkZHJlc3MgZm9yIHRoZSBnaXZlbiBFdGhlcmV1bSBhZGRyZXNzIGFuZCBvcmlnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfYWRkcmVzcyAtIFRoZSBFdGhlcmV1bSBhZGRyZXNzIGZvciB0aGUgYXBwIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gZm9yIHRoZSBhcHAga2V5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYXBwIGtleSBhZGRyZXNzLlxuICAgKi9cbiAgYXN5bmMgZ2V0QXBwS2V5QWRkcmVzcyhfYWRkcmVzcywgb3JpZ2luKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MoX2FkZHJlc3MpO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBrZXlyaW5nLmdldEFwcEtleUFkZHJlc3MoYWRkcmVzcywgb3JpZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIGFuIGFwcCBrZXkgcHJpdmF0ZSBrZXkgZm9yIHRoZSBnaXZlbiBFdGhlcmV1bSBhZGRyZXNzIGFuZCBvcmlnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfYWRkcmVzcyAtIFRoZSBFdGhlcmV1bSBhZGRyZXNzIGZvciB0aGUgYXBwIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gZm9yIHRoZSBhcHAga2V5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYXBwIGtleSBwcml2YXRlIGtleS5cbiAgICovXG4gIGFzeW5jIGV4cG9ydEFwcEtleUZvckFkZHJlc3MoX2FkZHJlc3MsIG9yaWdpbikge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKF9hZGRyZXNzKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICAvLyBUaGUgXCJpblwiIG9wZXJhdG9yIGlzIHR5cGljYWxseSByZXN0cmljdGVkIGJlY2F1c2UgaXQgYWxzbyBjaGVja3MgaW5oZXJpdGVkIHByb3BlcnRpZXMsXG4gICAgLy8gd2hpY2ggY2FuIGJlIHVuZXhwZWN0ZWQgZm9yIHBsYWluIG9iamVjdHMuIFdlJ3JlIGFsbG93aW5nIGl0IGhlcmUgYmVjYXVzZSBga2V5cmluZ2AgaXMgbm90XG4gICAgLy8gYSBwbGFpbiBvYmplY3QsIGFuZCB3ZSBleHBsaWNpdGx5IHdhbnQgdG8gaW5jbHVkZSBpbmhlcml0ZWQgbWV0aG9kcyBpbiB0aGlzIGNoZWNrLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGlmICghKCdleHBvcnRBY2NvdW50JyBpbiBrZXlyaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIGtleXJpbmcgZm9yIGFkZHJlc3MgJHtfYWRkcmVzc30gZG9lcyBub3Qgc3VwcG9ydCBleHBvcnRpbmcuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBrZXlyaW5nLmV4cG9ydEFjY291bnQoYWRkcmVzcywgeyB3aXRoQXBwS2V5T3JpZ2luOiBvcmlnaW4gfSk7XG4gIH1cblxuICAvL1xuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgLy9cblxuICAvKipcbiAgICogQ3JlYXRlIEZpcnN0IEtleSBUcmVlLlxuICAgKlxuICAgKiAtIENsZWFycyB0aGUgZXhpc3RpbmcgdmF1bHQuXG4gICAqIC0gQ3JlYXRlcyBhIG5ldyB2YXVsdC5cbiAgICogLSBDcmVhdGVzIGEgcmFuZG9tIG5ldyBIRCBLZXlyaW5nIHdpdGggMSBhY2NvdW50LlxuICAgKiAtIE1ha2VzIHRoYXQgYWNjb3VudCB0aGUgc2VsZWN0ZWQgYWNjb3VudC5cbiAgICogLSBGYXVjZXRzIHRoYXQgYWNjb3VudCBvbiB0ZXN0bmV0LlxuICAgKiAtIFB1dHMgdGhlIGN1cnJlbnQgc2VlZCB3b3JkcyBpbnRvIHRoZSBzdGF0ZSB0cmVlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUZpcnN0S2V5VHJlZSgpIHtcbiAgICB0aGlzLmNsZWFyS2V5cmluZ3MoKTtcblxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmFkZE5ld0tleXJpbmcoS0VZUklOR1NfVFlQRV9NQVAuSERfS0VZUklORyk7XG4gICAgY29uc3QgW2ZpcnN0QWNjb3VudF0gPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgaWYgKCFmaXJzdEFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5cmluZ0NvbnRyb2xsZXIgLSBObyBhY2NvdW50IGZvdW5kIG9uIGtleWNoYWluLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhleEFjY291bnQgPSBub3JtYWxpemVBZGRyZXNzKGZpcnN0QWNjb3VudCk7XG4gICAgdGhpcy5lbWl0KCduZXdWYXVsdCcsIGhleEFjY291bnQpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcnNpc3QgQWxsIEtleXJpbmdzXG4gICAqXG4gICAqIEl0ZXJhdGVzIHRoZSBjdXJyZW50IGBrZXlyaW5nc2AgYXJyYXksXG4gICAqIHNlcmlhbGl6ZXMgZWFjaCBvbmUgaW50byBhIHNlcmlhbGl6ZWQgYXJyYXksXG4gICAqIGVuY3J5cHRzIHRoYXQgYXJyYXkgd2l0aCB0aGUgcHJvdmlkZWQgYHBhc3N3b3JkYCxcbiAgICogYW5kIHBlcnNpc3RzIHRoYXQgZW5jcnlwdGVkIHN0cmluZyB0byBzdG9yYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUmVzb2x2ZXMgdG8gdHJ1ZSBvbmNlIGtleXJpbmdzIGFyZSBwZXJzaXN0ZWQuXG4gICAqL1xuICBhc3luYyBwZXJzaXN0QWxsS2V5cmluZ3MoKSB7XG4gICAgY29uc3QgeyBlbmNyeXB0aW9uS2V5LCBlbmNyeXB0aW9uU2FsdCB9ID0gdGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgaWYgKCF0aGlzLnBhc3N3b3JkICYmICFlbmNyeXB0aW9uS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgcGVyc2lzdCB2YXVsdCB3aXRob3V0IHBhc3N3b3JkIGFuZCBlbmNyeXB0aW9uIGtleScsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRLZXlyaW5ncyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5rZXlyaW5ncy5tYXAoYXN5bmMgKGtleXJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgW3R5cGUsIGRhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIGtleXJpbmcudHlwZSxcbiAgICAgICAgICBrZXlyaW5nLnNlcmlhbGl6ZSgpLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZSwgZGF0YSB9O1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIHNlcmlhbGl6ZWRLZXlyaW5ncy5wdXNoKC4uLnRoaXMuX3Vuc3VwcG9ydGVkS2V5cmluZ3MpO1xuXG4gICAgbGV0IHZhdWx0O1xuICAgIGxldCBuZXdFbmNyeXB0aW9uS2V5O1xuXG4gICAgaWYgKHRoaXMuY2FjaGVFbmNyeXB0aW9uS2V5KSB7XG4gICAgICBpZiAodGhpcy5wYXNzd29yZCkge1xuICAgICAgICBjb25zdCB7IHZhdWx0OiBuZXdWYXVsdCwgZXhwb3J0ZWRLZXlTdHJpbmcgfSA9XG4gICAgICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0b3IuZW5jcnlwdFdpdGhEZXRhaWwoXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkLFxuICAgICAgICAgICAgc2VyaWFsaXplZEtleXJpbmdzLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgdmF1bHQgPSBuZXdWYXVsdDtcbiAgICAgICAgbmV3RW5jcnlwdGlvbktleSA9IGV4cG9ydGVkS2V5U3RyaW5nO1xuICAgICAgfSBlbHNlIGlmIChlbmNyeXB0aW9uS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuZW5jcnlwdG9yLmltcG9ydEtleShlbmNyeXB0aW9uS2V5KTtcbiAgICAgICAgY29uc3QgdmF1bHRKU09OID0gYXdhaXQgdGhpcy5lbmNyeXB0b3IuZW5jcnlwdFdpdGhLZXkoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHNlcmlhbGl6ZWRLZXlyaW5ncyxcbiAgICAgICAgKTtcbiAgICAgICAgdmF1bHRKU09OLnNhbHQgPSBlbmNyeXB0aW9uU2FsdDtcbiAgICAgICAgdmF1bHQgPSBKU09OLnN0cmluZ2lmeSh2YXVsdEpTT04pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXVsdCA9IGF3YWl0IHRoaXMuZW5jcnlwdG9yLmVuY3J5cHQodGhpcy5wYXNzd29yZCwgc2VyaWFsaXplZEtleXJpbmdzKTtcbiAgICB9XG5cbiAgICBpZiAoIXZhdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwZXJzaXN0IHZhdWx0IHdpdGhvdXQgdmF1bHQgaW5mb3JtYXRpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdmF1bHQgfSk7XG5cbiAgICAvLyBUaGUga2V5cmluZyB1cGRhdGVzIG5lZWQgdG8gYmUgYW5ub3VuY2VkIGJlZm9yZSB1cGRhdGluZyB0aGUgZW5jcnlwdGlvbktleVxuICAgIC8vIHNvIHRoYXQgdGhlIHVwZGF0ZWQga2V5cmluZyBnZXRzIHByb3BhZ2F0ZWQgdG8gdGhlIGV4dGVuc2lvbiBmaXJzdC5cbiAgICAvLyBOb3QgY2FsbGluZyBfdXBkYXRlTWVtU3RvcmVLZXlyaW5ncyByZXN1bHRzIGluIHRoZSB3cm9uZyBhY2NvdW50IGJlaW5nIHNlbGVjdGVkXG4gICAgLy8gaW4gdGhlIGV4dGVuc2lvbi5cbiAgICBhd2FpdCB0aGlzLl91cGRhdGVNZW1TdG9yZUtleXJpbmdzKCk7XG5cbiAgICBpZiAobmV3RW5jcnlwdGlvbktleSkge1xuICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVuY3J5cHRpb25LZXk6IG5ld0VuY3J5cHRpb25LZXksXG4gICAgICAgIGVuY3J5cHRpb25TYWx0OiBKU09OLnBhcnNlKHZhdWx0KS5zYWx0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVW5sb2NrIEtleXJpbmdzLlxuICAgKlxuICAgKiBBdHRlbXB0cyB0byB1bmxvY2sgdGhlIHBlcnNpc3RlZCBlbmNyeXB0ZWQgc3RvcmFnZSxcbiAgICogaW5pdGlhbGl6aW5nIHRoZSBwZXJzaXN0ZWQga2V5cmluZ3MgdG8gUkFNLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUga2V5cmluZyBjb250cm9sbGVyIHBhc3N3b3JkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jcnlwdGlvbktleSAtIEFuIGV4cG9ydGVkIGtleSBzdHJpbmcgdG8gdW5sb2NrIGtleXJpbmdzIHdpdGguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNyeXB0aW9uU2FsdCAtIFRoZSBzYWx0IHVzZWQgdG8gZW5jcnlwdCB0aGUgdmF1bHQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PEtleXJpbmc+Pn0gVGhlIGtleXJpbmdzLlxuICAgKi9cbiAgYXN5bmMgdW5sb2NrS2V5cmluZ3MocGFzc3dvcmQsIGVuY3J5cHRpb25LZXksIGVuY3J5cHRpb25TYWx0KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVmF1bHQgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkudmF1bHQ7XG4gICAgaWYgKCFlbmNyeXB0ZWRWYXVsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5sb2NrIHdpdGhvdXQgYSBwcmV2aW91cyB2YXVsdC4nKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmNsZWFyS2V5cmluZ3MoKTtcblxuICAgIGxldCB2YXVsdDtcblxuICAgIGlmICh0aGlzLmNhY2hlRW5jcnlwdGlvbktleSkge1xuICAgICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZW5jcnlwdG9yLmRlY3J5cHRXaXRoRGV0YWlsKFxuICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgIGVuY3J5cHRlZFZhdWx0LFxuICAgICAgICApO1xuICAgICAgICB2YXVsdCA9IHJlc3VsdC52YXVsdDtcbiAgICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuXG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIGVuY3J5cHRpb25LZXk6IHJlc3VsdC5leHBvcnRlZEtleVN0cmluZyxcbiAgICAgICAgICBlbmNyeXB0aW9uU2FsdDogcmVzdWx0LnNhbHQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRW5jcnlwdGVkVmF1bHQgPSBKU09OLnBhcnNlKGVuY3J5cHRlZFZhdWx0KTtcblxuICAgICAgICBpZiAoZW5jcnlwdGlvblNhbHQgIT09IHBhcnNlZEVuY3J5cHRlZFZhdWx0LnNhbHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24ga2V5IGFuZCBzYWx0IHByb3ZpZGVkIGFyZSBleHBpcmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLmVuY3J5cHRvci5pbXBvcnRLZXkoZW5jcnlwdGlvbktleSk7XG4gICAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5lbmNyeXB0b3IuZGVjcnlwdFdpdGhLZXkoa2V5LCBwYXJzZWRFbmNyeXB0ZWRWYXVsdCk7XG5cbiAgICAgICAgLy8gVGhpcyBjYWxsIGlzIHJlcXVpcmVkIG9uIHRoZSBmaXJzdCBjYWxsIGJlY2F1c2UgZW5jcnlwdGlvbktleVxuICAgICAgICAvLyBpcyBub3QgeWV0IGluc2lkZSB0aGUgbWVtU3RvcmVcbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgZW5jcnlwdGlvbktleSxcbiAgICAgICAgICBlbmNyeXB0aW9uU2FsdCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5lbmNyeXB0b3IuZGVjcnlwdChwYXNzd29yZCwgZW5jcnlwdGVkVmF1bHQpO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKHZhdWx0Lm1hcCh0aGlzLl9yZXN0b3JlS2V5cmluZy5iaW5kKHRoaXMpKSk7XG4gICAgYXdhaXQgdGhpcy5fdXBkYXRlTWVtU3RvcmVLZXlyaW5ncygpO1xuICAgIHJldHVybiB0aGlzLmtleXJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgS2V5cmluZ1xuICAgKlxuICAgKiBBdHRlbXB0cyB0byBpbml0aWFsaXplIGEgbmV3IGtleXJpbmcgZnJvbSB0aGUgcHJvdmlkZWQgc2VyaWFsaXplZCBwYXlsb2FkLlxuICAgKiBPbiBzdWNjZXNzLCB1cGRhdGVzIHRoZSBtZW1TdG9yZSBrZXlyaW5ncyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nXG4gICAqIGtleXJpbmcgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQga2V5cmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5cmluZz59IFRoZSBkZXNlcmlhbGl6ZWQga2V5cmluZy5cbiAgICovXG4gIGFzeW5jIHJlc3RvcmVLZXlyaW5nKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5fcmVzdG9yZUtleXJpbmcoc2VyaWFsaXplZCk7XG4gICAgaWYgKGtleXJpbmcpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZU1lbVN0b3JlS2V5cmluZ3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXJpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBLZXlyaW5nIEhlbHBlclxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBpbml0aWFsaXplIGEgbmV3IGtleXJpbmcgZnJvbSB0aGUgcHJvdmlkZWQgc2VyaWFsaXplZCBwYXlsb2FkLlxuICAgKiBPbiBzdWNjZXNzLCByZXR1cm5zIHRoZSByZXN1bHRpbmcga2V5cmluZyBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCBrZXlyaW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXlyaW5nfHVuZGVmaW5lZD59IFRoZSBkZXNlcmlhbGl6ZWQga2V5cmluZyBvciB1bmRlZmluZWQgaWYgdGhlIGtleXJpbmcgdHlwZSBpcyB1bnN1cHBvcnRlZC5cbiAgICovXG4gIGFzeW5jIF9yZXN0b3JlS2V5cmluZyhzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBzZXJpYWxpemVkO1xuXG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuX25ld0tleXJpbmcodHlwZSwgZGF0YSk7XG4gICAgaWYgKCFrZXlyaW5nKSB7XG4gICAgICB0aGlzLl91bnN1cHBvcnRlZEtleXJpbmdzLnB1c2goc2VyaWFsaXplZCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGdldEFjY291bnRzIGFsc28gdmFsaWRhdGVzIHRoZSBhY2NvdW50cyBmb3Igc29tZSBrZXlyaW5nc1xuICAgIGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICB0aGlzLmtleXJpbmdzLnB1c2goa2V5cmluZyk7XG4gICAgcmV0dXJuIGtleXJpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEtleXJpbmcgQ2xhc3MgRm9yIFR5cGVcbiAgICpcbiAgICogU2VhcmNoZXMgdGhlIGN1cnJlbnQgYGtleXJpbmdCdWlsZGVyc2AgYXJyYXlcbiAgICogZm9yIGEgS2V5cmluZyBidWlsZGVyIHdob3NlIHVuaXF1ZSBgdHlwZWAgcHJvcGVydHlcbiAgICogbWF0Y2hlcyB0aGUgcHJvdmlkZWQgYHR5cGVgLFxuICAgKiByZXR1cm5pbmcgaXQgaWYgaXQgZXhpc3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIHdob3NlIGNsYXNzIHRvIGdldC5cbiAgICogQHJldHVybnMge0tleXJpbmd8dW5kZWZpbmVkfSBUaGUgY2xhc3MsIGlmIGl0IGV4aXN0cy5cbiAgICovXG4gIGdldEtleXJpbmdCdWlsZGVyRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ0J1aWxkZXJzLmZpbmQoXG4gICAgICAoa2V5cmluZ0J1aWxkZXIpID0+IGtleXJpbmdCdWlsZGVyLnR5cGUgPT09IHR5cGUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgS2V5cmluZ3MgYnkgVHlwZVxuICAgKlxuICAgKiBHZXRzIGFsbCBrZXlyaW5ncyBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUga2V5cmluZyB0eXBlcyB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybnMge0FycmF5PEtleXJpbmc+fSBUaGUga2V5cmluZ3MuXG4gICAqL1xuICBnZXRLZXlyaW5nc0J5VHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ3MuZmlsdGVyKChrZXlyaW5nKSA9PiBrZXlyaW5nLnR5cGUgPT09IHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBY2NvdW50c1xuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMgYWRkcmVzc2VzIG9mIGFsbCBjdXJyZW50IGFjY291bnRzXG4gICAqIG1hbmFnZWQgYnkgYWxsIGN1cnJlbnRseSB1bmxvY2tlZCBrZXlyaW5ncy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59IFRoZSBhcnJheSBvZiBhY2NvdW50cy5cbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRzKCkge1xuICAgIGNvbnN0IGtleXJpbmdzID0gdGhpcy5rZXlyaW5ncyB8fCBbXTtcblxuICAgIGNvbnN0IGtleXJpbmdBcnJheXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGtleXJpbmdzLm1hcCgoa2V5cmluZykgPT4ga2V5cmluZy5nZXRBY2NvdW50cygpKSxcbiAgICApO1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGtleXJpbmdBcnJheXMucmVkdWNlKChyZXMsIGFycikgPT4ge1xuICAgICAgcmV0dXJuIHJlcy5jb25jYXQoYXJyKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gYWRkcmVzc2VzLm1hcChub3JtYWxpemVBZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgS2V5cmluZyBGb3IgQWNjb3VudFxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgaW5pdGlhbGl6ZWQga2V5cmluZyB0aGF0IG1hbmFnZXNcbiAgICogdGhlIHNwZWNpZmllZCBgYWRkcmVzc2AgaWYgb25lIGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBbiBhY2NvdW50IGFkZHJlc3MuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEtleXJpbmc+fSBUaGUga2V5cmluZyBvZiB0aGUgYWNjb3VudCwgaWYgaXQgZXhpc3RzLlxuICAgKi9cbiAgYXN5bmMgZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcykge1xuICAgIGNvbnN0IGhleGVkID0gbm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzKTtcblxuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMua2V5cmluZ3MubWFwKChrZXlyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChba2V5cmluZywga2V5cmluZy5nZXRBY2NvdW50cygpXSk7XG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgY29uc3Qgd2lubmVycyA9IGNhbmRpZGF0ZXMuZmlsdGVyKChjYW5kaWRhdGUpID0+IHtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gY2FuZGlkYXRlWzFdLm1hcChub3JtYWxpemVBZGRyZXNzKTtcbiAgICAgIHJldHVybiBhY2NvdW50cy5pbmNsdWRlcyhoZXhlZCk7XG4gICAgfSk7XG4gICAgaWYgKHdpbm5lcnMgJiYgd2lubmVycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gd2lubmVyc1swXVswXTtcbiAgICB9XG5cbiAgICAvLyBBZGRpbmcgbW9yZSBpbmZvIHRvIHRoZSBlcnJvclxuICAgIGxldCBlcnJvckluZm8gPSAnJztcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIGVycm9ySW5mbyA9ICdUaGUgYWRkcmVzcyBwYXNzZWQgaW4gaXMgaW52YWxpZC9lbXB0eSc7XG4gICAgfSBlbHNlIGlmICghY2FuZGlkYXRlcyB8fCAhY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICAgIGVycm9ySW5mbyA9ICdUaGVyZSBhcmUgbm8ga2V5cmluZ3MnO1xuICAgIH0gZWxzZSBpZiAoIXdpbm5lcnMgfHwgIXdpbm5lcnMubGVuZ3RoKSB7XG4gICAgICBlcnJvckluZm8gPSAnVGhlcmUgYXJlIGtleXJpbmdzLCBidXQgbm9uZSBtYXRjaCB0aGUgYWRkcmVzcyc7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBObyBrZXlyaW5nIGZvdW5kIGZvciB0aGUgcmVxdWVzdGVkIGFjY291bnQuIEVycm9yIGluZm86ICR7ZXJyb3JJbmZvfWAsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IEZvciBLZXlyaW5nXG4gICAqXG4gICAqIElzIHVzZWQgZm9yIGFkZGluZyB0aGUgY3VycmVudCBrZXlyaW5ncyB0byB0aGUgc3RhdGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0tleXJpbmd9IGtleXJpbmcgLSBUaGUga2V5cmluZyB0byBkaXNwbGF5LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIGtleXJpbmcgZGlzcGxheSBvYmplY3QsIHdpdGggdHlwZSBhbmQgYWNjb3VudHMgcHJvcGVydGllcy5cbiAgICovXG4gIGFzeW5jIGRpc3BsYXlGb3JLZXlyaW5nKGtleXJpbmcpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBrZXlyaW5nLnR5cGUsXG4gICAgICBhY2NvdW50czogYWNjb3VudHMubWFwKG5vcm1hbGl6ZUFkZHJlc3MpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgS2V5cmluZ3NcbiAgICpcbiAgICogRGVhbGxvY2F0ZXMgYWxsIGN1cnJlbnRseSBtYW5hZ2VkIGtleXJpbmdzIGFuZCBhY2NvdW50cy5cbiAgICogVXNlZCBiZWZvcmUgaW5pdGlhbGl6aW5nIGEgbmV3IHZhdWx0LlxuICAgKi9cblxuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIGFzeW5jIGNsZWFyS2V5cmluZ3MoKSB7XG4gICAgLy8gY2xlYXIga2V5cmluZ3MgZnJvbSBtZW1vcnlcbiAgICB0aGlzLmtleXJpbmdzID0gW107XG4gICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBrZXlyaW5nczogW10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG1lbVN0b3JlIEtleXJpbmdzXG4gICAqXG4gICAqIFVwZGF0ZXMgdGhlIGluLW1lbW9yeSBrZXlyaW5ncywgd2l0aG91dCBwZXJzaXN0aW5nLlxuICAgKi9cbiAgYXN5bmMgX3VwZGF0ZU1lbVN0b3JlS2V5cmluZ3MoKSB7XG4gICAgY29uc3Qga2V5cmluZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMua2V5cmluZ3MubWFwKHRoaXMuZGlzcGxheUZvcktleXJpbmcpLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoeyBrZXlyaW5ncyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxvY2sgS2V5cmluZ3NcbiAgICpcbiAgICogVW5sb2NrcyB0aGUga2V5cmluZ3MuXG4gICAqXG4gICAqIEBmaXJlcyBLZXlyaW5nQ29udHJvbGxlciN1bmxvY2tcbiAgICovXG4gIHNldFVubG9ja2VkKCkge1xuICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoeyBpc1VubG9ja2VkOiB0cnVlIH0pO1xuICAgIHRoaXMuZW1pdCgndW5sb2NrJyk7XG4gIH1cblxuICAvKipcbiAgICogRm9yZ2V0IGhhcmR3YXJlIGtleXJpbmcuXG4gICAqXG4gICAqIEZvcmdldCBoYXJkd2FyZSBhbmQgdXBkYXRlIG1lbW9yaXplZCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlyaW5nfSBrZXlyaW5nIC0gVGhlIGtleXJpbmcgdG8gZm9yZ2V0LlxuICAgKi9cbiAgZm9yZ2V0S2V5cmluZyhrZXlyaW5nKSB7XG4gICAgaWYgKGtleXJpbmcuZm9yZ2V0RGV2aWNlKSB7XG4gICAgICBrZXlyaW5nLmZvcmdldERldmljZSgpO1xuICAgICAgdGhpcy5wZXJzaXN0QWxsS2V5cmluZ3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgS2V5cmluZ0NvbnRyb2xsZXIgLSBrZXlyaW5nIGRvZXMgbm90IGhhdmUgbWV0aG9kIFwiZm9yZ2V0RGV2aWNlXCIsIGtleXJpbmcgdHlwZTogJHtrZXlyaW5nLnR5cGV9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlLCBpbml0aWFsaXplIGFuZCByZXR1cm4gYSBuZXcga2V5cmluZ1xuICAgKlxuICAgKiBUaGUga2V5cmluZyBpbnN0YW50aWF0ZWQgaXMgb2YgdGhlIGdpdmVuIGB0eXBlYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBrZXlyaW5nIHRvIGFkZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byByZXN0b3JlIGEgcHJldmlvdXNseSBzZXJpYWxpemVkIGtleXJpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEtleXJpbmc+fSBUaGUgbmV3IGtleXJpbmcuXG4gICAqL1xuICBhc3luYyBfbmV3S2V5cmluZyh0eXBlLCBkYXRhKSB7XG4gICAgY29uc3Qga2V5cmluZ0J1aWxkZXIgPSB0aGlzLmdldEtleXJpbmdCdWlsZGVyRm9yVHlwZSh0eXBlKTtcblxuICAgIGlmICgha2V5cmluZ0J1aWxkZXIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cmluZyA9IGtleXJpbmdCdWlsZGVyKCk7XG5cbiAgICBhd2FpdCBrZXlyaW5nLmRlc2VyaWFsaXplKGRhdGEpO1xuXG4gICAgaWYgKGtleXJpbmcuaW5pdCkge1xuICAgICAgYXdhaXQga2V5cmluZy5pbml0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYnVpbGRlciBmdW5jdGlvbiBmb3IgYEtleXJpbmdgXG4gKlxuICogUmV0dXJucyBhIGJ1aWxkZXIgZnVuY3Rpb24gZm9yIGBLZXlyaW5nYCB3aXRoIGEgYHR5cGVgIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7S2V5cmluZ30gS2V5cmluZyAtIFRoZSBLZXlyaW5nIGNsYXNzIGZvciB0aGUgYnVpbGRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBidWlsZGVyIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gS2V5cmluZy5cbiAqL1xuZnVuY3Rpb24ga2V5cmluZ0J1aWxkZXJGYWN0b3J5KEtleXJpbmcpIHtcbiAgY29uc3QgYnVpbGRlciA9ICgpID0+IG5ldyBLZXlyaW5nKCk7XG5cbiAgYnVpbGRlci50eXBlID0gS2V5cmluZy50eXBlO1xuXG4gIHJldHVybiBidWlsZGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgS2V5cmluZ0NvbnRyb2xsZXIsXG4gIGtleXJpbmdCdWlsZGVyRmFjdG9yeSxcbn07XG4iLCJjb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IEhES2V5ID0gcmVxdWlyZSgnaGRrZXknKVxuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBzaWdVdGlsID0gcmVxdWlyZSgnZXRoLXNpZy11dGlsJylcbmNvbnN0IHsgVHJhbnNhY3Rpb25GYWN0b3J5IH0gPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpXG5cbmNvbnN0IHBhdGhCYXNlID0gJ20nXG5jb25zdCBoZFBhdGhTdHJpbmcgPSBgJHtwYXRoQmFzZX0vNDQnLzYwJy8wJ2BcbmNvbnN0IHR5cGUgPSAnTGVkZ2VyIEhhcmR3YXJlJ1xuXG5jb25zdCBCUklER0VfVVJMID0gJ2h0dHBzOi8vbWV0YW1hc2suZ2l0aHViLmlvL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcnXG5cbmNvbnN0IE1BWF9JTkRFWCA9IDEwMDBcbmNvbnN0IE5FVFdPUktfQVBJX1VSTFMgPSB7XG4gIHJvcHN0ZW46ICdodHRwOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvJyxcbiAga292YW46ICdodHRwOi8vYXBpLWtvdmFuLmV0aGVyc2Nhbi5pbycsXG4gIHJpbmtlYnk6ICdodHRwczovL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pbycsXG4gIG1haW5uZXQ6ICdodHRwczovL2FwaS5ldGhlcnNjYW4uaW8nLFxufVxuXG5jb25zdCBDT05ORUNUSU9OX0VWRU5UID0gJ2xlZGdlci1jb25uZWN0aW9uLWNoYW5nZSdcblxuY2xhc3MgTGVkZ2VyQnJpZGdlS2V5cmluZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5hY2NvdW50RGV0YWlscyA9IHt9XG4gICAgdGhpcy5icmlkZ2VVcmwgPSBudWxsXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMucGFnZSA9IDBcbiAgICB0aGlzLnBlclBhZ2UgPSA1XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwXG4gICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKVxuICAgIHRoaXMucGF0aHMgPSB7fVxuICAgIHRoaXMuaWZyYW1lID0gbnVsbFxuICAgIHRoaXMubmV0d29yayA9ICdtYWlubmV0J1xuICAgIHRoaXMuaW1wbGVtZW50RnVsbEJJUDQ0ID0gZmFsc2VcbiAgICB0aGlzLmRlc2VyaWFsaXplKG9wdHMpXG5cbiAgICB0aGlzLmlmcmFtZUxvYWRlZCA9IGZhbHNlXG4gICAgdGhpcy5fc2V0dXBJZnJhbWUoKVxuXG4gICAgdGhpcy5jdXJyZW50TWVzc2FnZUlkID0gMFxuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcyA9IHt9XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcigpXG4gIH1cblxuICBzZXJpYWxpemUgKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgYWNjb3VudERldGFpbHM6IHRoaXMuYWNjb3VudERldGFpbHMsXG4gICAgICBicmlkZ2VVcmw6IHRoaXMuYnJpZGdlVXJsLFxuICAgICAgaW1wbGVtZW50RnVsbEJJUDQ0OiBmYWxzZSxcbiAgICB9KVxuICB9XG5cbiAgZGVzZXJpYWxpemUgKG9wdHMgPSB7fSkge1xuICAgIHRoaXMuaGRQYXRoID0gb3B0cy5oZFBhdGggfHwgaGRQYXRoU3RyaW5nXG4gICAgdGhpcy5icmlkZ2VVcmwgPSBvcHRzLmJyaWRnZVVybCB8fCBCUklER0VfVVJMXG4gICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHMgfHwgW11cbiAgICB0aGlzLmFjY291bnREZXRhaWxzID0gb3B0cy5hY2NvdW50RGV0YWlscyB8fCB7fVxuICAgIGlmICghb3B0cy5hY2NvdW50RGV0YWlscykge1xuICAgICAgdGhpcy5fbWlncmF0ZUFjY291bnREZXRhaWxzKG9wdHMpXG4gICAgfVxuXG4gICAgdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPSBvcHRzLmltcGxlbWVudEZ1bGxCSVA0NCB8fCBmYWxzZVxuXG4gICAgLy8gUmVtb3ZlIGFjY291bnRzIHRoYXQgZG9uJ3QgaGF2ZSBjb3JyZXNwb25kaW5nIGFjY291bnQgZGV0YWlsc1xuICAgIHRoaXMuYWNjb3VudHMgPSB0aGlzLmFjY291bnRzXG4gICAgICAuZmlsdGVyKChhY2NvdW50KSA9PiBPYmplY3Qua2V5cyh0aGlzLmFjY291bnREZXRhaWxzKS5pbmNsdWRlcyhldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFjY291bnQpKSlcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgX21pZ3JhdGVBY2NvdW50RGV0YWlscyAob3B0cykge1xuICAgIGlmICh0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSAmJiBvcHRzLmFjY291bnRJbmRleGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgT2JqZWN0LmtleXMob3B0cy5hY2NvdW50SW5kZXhlcykpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50RGV0YWlsc1thY2NvdW50XSA9IHtcbiAgICAgICAgICBiaXA0NDogdHJ1ZSxcbiAgICAgICAgICBoZFBhdGg6IHRoaXMuX2dldFBhdGhGb3JJbmRleChvcHRzLmFjY291bnRJbmRleGVzW2FjY291bnRdKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRyeSB0byBtaWdyYXRlIG5vbi1MZWRnZXJMaXZlIGFjY291bnRzIHRvb1xuICAgIGlmICghdGhpcy5faXNMZWRnZXJMaXZlSGRQYXRoKCkpIHtcbiAgICAgIHRoaXMuYWNjb3VudHNcbiAgICAgICAgLmZpbHRlcigoYWNjb3VudCkgPT4gIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCkpKVxuICAgICAgICAuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCldID0ge1xuICAgICAgICAgICAgICBiaXA0NDogZmFsc2UsXG4gICAgICAgICAgICAgIGhkUGF0aDogdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFjY291bnQpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBmYWlsZWQgdG8gbWlncmF0ZSBhY2NvdW50ICR7YWNjb3VudH1gKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpc1VubG9ja2VkICgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhkayAmJiB0aGlzLmhkay5wdWJsaWNLZXkpXG4gIH1cblxuICBpc0Nvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZXZpY2VDb25uZWN0ZWRcbiAgfVxuXG4gIHNldEFjY291bnRUb1VubG9jayAoaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMClcbiAgfVxuXG4gIHNldEhkUGF0aCAoaGRQYXRoKSB7XG4gICAgLy8gUmVzZXQgSERLZXkgaWYgdGhlIHBhdGggY2hhbmdlc1xuICAgIGlmICh0aGlzLmhkUGF0aCAhPT0gaGRQYXRoKSB7XG4gICAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gICAgfVxuICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoXG4gIH1cblxuICB1bmxvY2sgKGhkUGF0aCwgdXBkYXRlSGRrID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSAmJiAhaGRQYXRoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdhbHJlYWR5IHVubG9ja2VkJylcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGhkUGF0aCA/IHRoaXMuX3RvTGVkZ2VyUGF0aChoZFBhdGgpIDogdGhpcy5oZFBhdGhcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdW5sb2NrJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIGlmICh1cGRhdGVIZGspIHtcbiAgICAgICAgICAgIHRoaXMuaGRrLnB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucHVibGljS2V5LCAnaGV4JylcbiAgICAgICAgICAgIHRoaXMuaGRrLmNoYWluQ29kZSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuY2hhaW5Db2RlLCAnaGV4JylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLmFkZHJlc3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFkZEFjY291bnRzIChuID0gMSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oYXN5bmMgKF8pID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gdGhpcy51bmxvY2tlZEFjY291bnRcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICAgICAgICBsZXQgYWRkcmVzc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhwYXRoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID0ge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW5hbWluZyB0aGlzIHByb3BlcnR5LCBhcyB0aGUgY3VycmVudCBuYW1lIGlzIG1pc2xlYWRpbmdcbiAgICAgICAgICAgICAgLy8gSXQncyBjdXJyZW50bHkgdXNlZCB0byByZXByZXNlbnQgd2hldGhlciBhbiBhY2NvdW50IHVzZXMgdGhlIExlZGdlciBMaXZlIHBhdGguXG4gICAgICAgICAgICAgIGJpcDQ0OiB0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSxcbiAgICAgICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHJlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSAwXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUodGhpcy5hY2NvdW50cylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlICgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXROZXh0UGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSlcbiAgfVxuXG4gIGdldEFjY291bnRzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMuc2xpY2UoKSlcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQgKGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKVxuICAgIH1cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoKGEpID0+IGEudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgIGRlbGV0ZSB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldXG4gIH1cblxuICBhdHRlbXB0TWFrZUFwcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLW1ha2UtYXBwJyxcbiAgICAgIH0sICh7IHN1Y2Nlc3MsIGVycm9yIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGVUcmFuc3BvcnRNZXRob2QgKHRyYW5zcG9ydFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gSWYgdGhlIGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0LCBsZXQncyBzdG9yZSB0aGUgZGVzaXJlZCB0cmFuc3BvcnRUeXBlIHZhbHVlIGFuZFxuICAgICAgLy8gb3B0aW1pc3RpY2FsbHkgcmV0dXJuIGEgc3VjY2Vzc2Z1bCBwcm9taXNlXG4gICAgICBpZiAoIXRoaXMuaWZyYW1lTG9hZGVkKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UgPSB7XG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgdHJhbnNwb3J0VHlwZSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdXBkYXRlLXRyYW5zcG9ydCcsXG4gICAgICAgIHBhcmFtczogeyB0cmFuc3BvcnRUeXBlIH0sXG4gICAgICB9LCAoeyBzdWNjZXNzIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyIHRyYW5zcG9ydCBjb3VsZCBub3QgYmUgdXBkYXRlZCcpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgc2lnblRyYW5zYWN0aW9uIChhZGRyZXNzLCB0eCkge1xuICAgIGxldCByYXdUeEhleFxuICAgIC8vIHRyYW5zYWN0aW9ucyBidWlsdCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGV0aGVyZXVtanMtdHggaGF2ZSBhXG4gICAgLy8gZ2V0Q2hhaW5JZCBtZXRob2QgdGhhdCBuZXdlciB2ZXJzaW9ucyBkbyBub3QuIE9sZGVyIHZlcnNpb25zIGFyZSBtdXRhYmxlXG4gICAgLy8gd2hpbGUgbmV3ZXIgdmVyc2lvbnMgZGVmYXVsdCB0byBiZWluZyBpbW11dGFibGUuIEV4cGVjdGVkIHNoYXBlIGFuZCB0eXBlXG4gICAgLy8gb2YgZGF0YSBmb3IgdiwgciBhbmQgcyBkaWZmZXIgKEJ1ZmZlciAob2xkKSB2cyBCTiAobmV3KSlcbiAgICBpZiAodHlwZW9mIHR4LmdldENoYWluSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEluIHRoaXMgdmVyc2lvbiBvZiBldGhlcmV1bWpzLXR4IHdlIG11c3QgYWRkIHRoZSBjaGFpbklkIGluIGhleCBmb3JtYXRcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIHYgdmFsdWUuIFRoZSBjaGFpbklkIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcmlhbGl6ZWRcbiAgICAgIC8vIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG9ubHkgY29tbXVuaWNhdGVkIHRvIGV0aGVyZXVtanMtdHggaW4gdGhpc1xuICAgICAgLy8gdmFsdWUuIEluIG5ld2VyIHZlcnNpb25zIHRoZSBjaGFpbklkIGlzIGNvbW11bmljYXRlZCB2aWEgdGhlICdDb21tb24nXG4gICAgICAvLyBvYmplY3QuXG4gICAgICB0eC52ID0gZXRoVXRpbC5idWZmZXJUb0hleCh0eC5nZXRDaGFpbklkKCkpXG4gICAgICB0eC5yID0gJzB4MDAnXG4gICAgICB0eC5zID0gJzB4MDAnXG5cbiAgICAgIHJhd1R4SGV4ID0gdHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHR4LnYgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnYsICdoZXgnKVxuICAgICAgICB0eC5yID0gQnVmZmVyLmZyb20ocGF5bG9hZC5yLCAnaGV4JylcbiAgICAgICAgdHgucyA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucywgJ2hleCcpXG4gICAgICAgIHJldHVybiB0eFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBUaGUgYmVsb3cgYGVuY29kZWAgY2FsbCBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgYXMgYGdldE1lc3NhZ2VUb1NpZ25gXG4gICAgLy8gY2FsbHMgYHJscC5lbmNvZGVgIGludGVybmFsbHkgZm9yIG5vbi1sZWdhY3kgdHJhbnNhY3Rpb25zLiBBcyBwZXIgdGhlIFwiVHJhbnNhY3Rpb24gRXhlY3V0aW9uXCJcbiAgICAvLyBzZWN0aW9uIG9mIHRoZSBldGhlcmV1bSB5ZWxsb3cgcGFwZXIsIHRyYW5zYWN0aW9ucyBuZWVkIHRvIGJlIFwid2VsbC1mb3JtZWQgUkxQLCB3aXRoIG5vIGFkZGl0aW9uYWxcbiAgICAvLyB0cmFpbGluZyBieXRlc1wiLlxuXG4gICAgLy8gTm90ZSBhbHNvIHRoYXQgYGdldE1lc3NhZ2VUb1NpZ25gIHdpbGwgcmV0dXJuIHZhbGlkIFJMUCBmb3IgYWxsIHRyYW5zYWN0aW9uIHR5cGVzLCB3aGVyZWFzIHRoZVxuICAgIC8vIGBzZXJpYWxpemVgIG1ldGhvZCB3aWxsIG5vdCBmb3IgYW55IHRyYW5zYWN0aW9uIHR5cGUgZXhjZXB0IGxlZ2FjeS4gVGhpcyBpcyBiZWNhdXNlIGBzZXJpYWxpemVgIGluY2x1ZGVzXG4gICAgLy8gZW1wdHkgciwgcyBhbmQgdiB2YWx1ZXMgaW4gdGhlIGVuY29kZWQgcmxwLiBUaGlzIGlzIHdoeSB3ZSB1c2UgYGdldE1lc3NhZ2VUb1NpZ25gIGhlcmUgaW5zdGVhZCBvZiBgc2VyaWFsaXplYC5cbiAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gdHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSlcblxuICAgIHJhd1R4SGV4ID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2VUb1NpZ24pXG4gICAgICA/IG1lc3NhZ2VUb1NpZ24udG9TdHJpbmcoJ2hleCcpXG4gICAgICA6IGV0aFV0aWwucmxwLmVuY29kZShtZXNzYWdlVG9TaWduKS50b1N0cmluZygnaGV4JylcblxuICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAvLyBCZWNhdXNlIHR4IHdpbGwgYmUgaW1tdXRhYmxlLCBmaXJzdCBnZXQgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAvLyBub21lbmNsYXR1cmUgb2YgZXRoZXJldW1qcy90eC5cbiAgICAgIGNvbnN0IHR4RGF0YSA9IHR4LnRvSlNPTigpXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgYSB0eXBlIHRvIHN1cHBvcnQgdHJhbnNhY3Rpb25zIHdpdGggYSB0eXBlIG90aGVyIHRoYW4gMFxuICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgdHhEYXRhLnYgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnYpXG4gICAgICB0eERhdGEuciA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQucilcbiAgICAgIHR4RGF0YS5zID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5zKVxuICAgICAgLy8gQWRvcHQgdGhlICdjb21tb24nIG9wdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbiBhbmQgc2V0IHRoZVxuICAgICAgLy8gcmV0dXJuZWQgb2JqZWN0IHRvIGJlIGZyb3plbiBpZiB0aGUgb3JpZ2luYWwgaXMgZnJvemVuLlxuICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwgeyBjb21tb246IHR4LmNvbW1vbiwgZnJlZXplOiBPYmplY3QuaXNGcm96ZW4odHgpIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9zaWduVHJhbnNhY3Rpb24gKGFkZHJlc3MsIHJhd1R4SGV4LCBoYW5kbGVTaWduaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyhhZGRyZXNzKVxuICAgICAgICAudGhlbigoaGRQYXRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXNpZ24tdHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIHR4OiByYXdUeEhleCxcbiAgICAgICAgICAgICAgaGRQYXRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgICBjb25zdCBuZXdPck11dGF0ZWRUeCA9IGhhbmRsZVNpZ25pbmcocGF5bG9hZClcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBuZXdPck11dGF0ZWRUeC52ZXJpZnlTaWduYXR1cmUoKVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld09yTXV0YXRlZFR4KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xlZGdlcjogVGhlIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBpcyBub3QgdmFsaWQnKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyB0cmFuc2FjdGlvbicpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIHNpZ25NZXNzYWdlICh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpXG4gIH1cblxuICAvLyBGb3IgcGVyc29uYWxfc2lnbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG1lc3NhZ2U6XG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UgKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICAgICAgLnRoZW4oKGhkUGF0aCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXBlcnNvbmFsLW1lc3NhZ2UnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoeyBzdWNjZXNzLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGxldCB2ID0gcGFyc2VJbnQocGF5bG9hZC52LCAxMClcbiAgICAgICAgICAgICAgdiA9IHYudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAweCR7cGF5bG9hZC5yfSR7cGF5bG9hZC5zfSR7dn1gXG4gICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoeyBkYXRhOiBtZXNzYWdlLCBzaWc6IHNpZ25hdHVyZSB9KVxuICAgICAgICAgICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgdW5sb2NrQWNjb3VudEJ5QWRkcmVzcyAoYWRkcmVzcykge1xuICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcylcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGNoZWNrc3VtbWVkQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGVkZ2VyOiBBY2NvdW50IGZvciBhZGRyZXNzICcke2NoZWNrc3VtbWVkQWRkcmVzc30nIG5vdCBmb3VuZGApXG4gICAgfVxuICAgIGNvbnN0IHsgaGRQYXRoIH0gPSB0aGlzLmFjY291bnREZXRhaWxzW2NoZWNrc3VtbWVkQWRkcmVzc11cbiAgICBjb25zdCB1bmxvY2tlZEFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhoZFBhdGgsIGZhbHNlKVxuXG4gICAgLy8gdW5sb2NrIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciB0aGUgZ2l2ZW4gaGRQYXRoIGFzIHJlcG9ydGVkIGJ5IHRoZSBsZWRnZXIgZGV2aWNlXG4gICAgLy8gaWYgdGhhdCBhZGRyZXNzIGlzIG5vdCB0aGUgcmVxdWVzdGVkIGFkZHJlc3MsIHRoZW4gdGhpcyBhY2NvdW50IGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgZGV2aWNlIG9yIHNlZWRcbiAgICBpZiAodW5sb2NrZWRBZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZWRnZXI6IEFjY291bnQgJHthZGRyZXNzfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIGNvbm5lY3RlZCBkZXZpY2VgKVxuICAgIH1cbiAgICByZXR1cm4gaGRQYXRoXG4gIH1cblxuICBhc3luYyBzaWduVHlwZWREYXRhICh3aXRoQWNjb3VudCwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaXNWNCA9IG9wdGlvbnMudmVyc2lvbiA9PT0gJ1Y0J1xuICAgIGlmICghaXNWNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWRnZXI6IE9ubHkgdmVyc2lvbiA0IG9mIHR5cGVkIGRhdGEgc2lnbmluZyBpcyBzdXBwb3J0ZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRvbWFpbixcbiAgICAgIHR5cGVzLFxuICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICBtZXNzYWdlLFxuICAgIH0gPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLnNhbml0aXplRGF0YShkYXRhKVxuICAgIGNvbnN0IGRvbWFpblNlcGFyYXRvckhleCA9IHNpZ1V0aWwuVHlwZWREYXRhVXRpbHMuaGFzaFN0cnVjdCgnRUlQNzEyRG9tYWluJywgZG9tYWluLCB0eXBlcywgaXNWNCkudG9TdHJpbmcoJ2hleCcpXG4gICAgY29uc3QgaGFzaFN0cnVjdE1lc3NhZ2VIZXggPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLmhhc2hTdHJ1Y3QocHJpbWFyeVR5cGUsIG1lc3NhZ2UsIHR5cGVzLCBpc1Y0KS50b1N0cmluZygnaGV4JylcblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICBjb25zdCB7IHN1Y2Nlc3MsIHBheWxvYWQgfSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXR5cGVkLWRhdGEnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBoZFBhdGgsXG4gICAgICAgICAgZG9tYWluU2VwYXJhdG9ySGV4LFxuICAgICAgICAgIGhhc2hTdHJ1Y3RNZXNzYWdlSGV4LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIChyZXN1bHQpID0+IHJlc29sdmUocmVzdWx0KSlcbiAgICB9KVxuXG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIGxldCB2ID0gcGFyc2VJbnQocGF5bG9hZC52LCAxMClcbiAgICAgIHYgPSB2LnRvU3RyaW5nKDE2KVxuICAgICAgaWYgKHYubGVuZ3RoIDwgMikge1xuICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYDB4JHtwYXlsb2FkLnJ9JHtwYXlsb2FkLnN9JHt2fWBcbiAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBzaWc6IHNpZ25hdHVyZSxcbiAgICAgIH0pXG4gICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnbmF0dXJlXG4gICAgfVxuICAgIHRocm93IHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJylcbiAgfVxuXG4gIGV4cG9ydEFjY291bnQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpXG4gIH1cblxuICBmb3JnZXREZXZpY2UgKCkge1xuICAgIHRoaXMuYWNjb3VudHMgPSBbXVxuICAgIHRoaXMucGFnZSA9IDBcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDBcbiAgICB0aGlzLnBhdGhzID0ge31cbiAgICB0aGlzLmFjY291bnREZXRhaWxzID0ge31cbiAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gIH1cblxuICAvKiBQUklWQVRFIE1FVEhPRFMgKi9cblxuICBfc2V0dXBJZnJhbWUgKCkge1xuICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICB0aGlzLmlmcmFtZS5zcmMgPSB0aGlzLmJyaWRnZVVybFxuICAgIHRoaXMuaWZyYW1lLmFsbG93ID0gYGhpZCAnc3JjJ2BcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgbGVkZ2VyIGxpdmUgcHJlZmVyZW5jZSB3YXMgc2V0IGJlZm9yZSB0aGUgaWZyYW1lIGlzIGxvYWRlZCxcbiAgICAgIC8vIHNldCBpdCBhZnRlciB0aGUgaWZyYW1lIGhhcyBsb2FkZWRcbiAgICAgIHRoaXMuaWZyYW1lTG9hZGVkID0gdHJ1ZVxuICAgICAgaWYgKHRoaXMuZGVsYXllZFByb21pc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnVwZGF0ZVRyYW5zcG9ydE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UudHJhbnNwb3J0VHlwZSxcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5kZWxheWVkUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UucmVqZWN0KGUpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZGVsYXllZFByb21pc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKVxuICB9XG5cbiAgX2dldE9yaWdpbiAoKSB7XG4gICAgY29uc3QgdG1wID0gdGhpcy5icmlkZ2VVcmwuc3BsaXQoJy8nKVxuICAgIHRtcC5zcGxpY2UoLTEsIDEpXG4gICAgcmV0dXJuIHRtcC5qb2luKCcvJylcbiAgfVxuXG4gIF9zZW5kTWVzc2FnZSAobXNnLCBjYikge1xuICAgIG1zZy50YXJnZXQgPSAnTEVER0VSLUlGUkFNRSdcblxuICAgIHRoaXMuY3VycmVudE1lc3NhZ2VJZCArPSAxXG4gICAgbXNnLm1lc3NhZ2VJZCA9IHRoaXMuY3VycmVudE1lc3NhZ2VJZFxuXG4gICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzW3RoaXMuY3VycmVudE1lc3NhZ2VJZF0gPSBjYlxuICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCAnKicpXG4gIH1cblxuICBfc2V0dXBMaXN0ZW5lciAoKSB7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lciA9ICh7IG9yaWdpbiwgZGF0YSB9KSA9PiB7XG4gICAgICBpZiAob3JpZ2luICE9PSB0aGlzLl9nZXRPcmlnaW4oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1lc3NhZ2VJZF0pIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tZXNzYWdlSWRdKGRhdGEpXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gPT09IENPTk5FQ1RJT05fRVZFTlQpIHtcbiAgICAgICAgICB0aGlzLmlzRGV2aWNlQ29ubmVjdGVkID0gZGF0YS5wYXlsb2FkLmNvbm5lY3RlZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9ldmVudExpc3RlbmVyKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9ldmVudExpc3RlbmVyKVxuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlIChpbmNyZW1lbnQpIHtcblxuICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnRcblxuICAgIGlmICh0aGlzLnBhZ2UgPD0gMCkge1xuICAgICAgdGhpcy5wYWdlID0gMVxuICAgIH1cbiAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlXG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlXG5cbiAgICBhd2FpdCB0aGlzLnVubG9jaygpXG4gICAgbGV0IGFjY291bnRzXG4gICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuX2dldEFjY291bnRzQklQNDQoZnJvbSwgdG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY291bnRzID0gdGhpcy5fZ2V0QWNjb3VudHNMZWdhY3koZnJvbSwgdG8pXG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgYXN5bmMgX2dldEFjY291bnRzQklQNDQgKGZyb20sIHRvKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy51bmxvY2socGF0aClcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPyBhd2FpdCB0aGlzLl9oYXNQcmV2aW91c1RyYW5zYWN0aW9ucyhhZGRyZXNzKSA6IHRydWVcbiAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgIH0pXG4gICAgICAvLyBQRVIgQklQNDRcbiAgICAgIC8vIFwiU29mdHdhcmUgc2hvdWxkIHByZXZlbnQgYSBjcmVhdGlvbiBvZiBhbiBhY2NvdW50IGlmXG4gICAgICAvLyBhIHByZXZpb3VzIGFjY291bnQgZG9lcyBub3QgaGF2ZSBhIHRyYW5zYWN0aW9uIGhpc3RvcnlcbiAgICAgIC8vIChtZWFuaW5nIG5vbmUgb2YgaXRzIGFkZHJlc3NlcyBoYXZlIGJlZW4gdXNlZCBiZWZvcmUpLlwiXG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgX2dldEFjY291bnRzTGVnYWN5IChmcm9tLCB0bykge1xuICAgIGNvbnN0IGFjY291bnRzID0gW11cblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICB9KVxuICAgICAgdGhpcy5wYXRoc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRzXG4gIH1cblxuICBfcGFkTGVmdEV2ZW4gKGhleCkge1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleCA6IGAwJHtoZXh9YFxuICB9XG5cbiAgX25vcm1hbGl6ZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZExlZnRFdmVuKGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmKS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBfYWRkcmVzc0Zyb21JbmRleCAocGF0aEJhc2UsIGkpIHtcbiAgICBjb25zdCBka2V5ID0gdGhpcy5oZGsuZGVyaXZlKGAke3BhdGhCYXNlfS8ke2l9YClcbiAgICBjb25zdCBhZGRyZXNzID0gZXRoVXRpbFxuICAgICAgLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSlcbiAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICByZXR1cm4gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhgMHgke2FkZHJlc3N9YClcbiAgfVxuXG4gIF9wYXRoRnJvbUFkZHJlc3MgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpIHtcbiAgICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhdGhGb3JJbmRleChpbmRleClcbiAgfVxuXG4gIF90b0FzY2lpIChoZXgpIHtcbiAgICBsZXQgc3RyID0gJydcbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aFxuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICBpID0gMlxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KVxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICBfZ2V0UGF0aEZvckluZGV4IChpbmRleCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGlzIEJJUCA0NCAoTGVkZ2VyIExpdmUpXG4gICAgcmV0dXJuIHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpID8gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYCA6IGAke3RoaXMuaGRQYXRofS8ke2luZGV4fWBcbiAgfVxuXG4gIF9pc0xlZGdlckxpdmVIZFBhdGggKCkge1xuICAgIHJldHVybiB0aGlzLmhkUGF0aCA9PT0gYG0vNDQnLzYwJy8wJy8wLzBgXG4gIH1cblxuICBfdG9MZWRnZXJQYXRoIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5yZXBsYWNlKCdtLycsICcnKVxuICB9XG5cbiAgYXN5bmMgX2hhc1ByZXZpb3VzVHJhbnNhY3Rpb25zIChhZGRyZXNzKSB7XG4gICAgY29uc3QgYXBpVXJsID0gdGhpcy5fZ2V0QXBpVXJsKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaChgJHthcGlVcmx9L2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9JHthZGRyZXNzfSZ0YWc9bGF0ZXN0JnBhZ2U9MSZvZmZzZXQ9MWApXG4gICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBpZiAocGFyc2VkUmVzcG9uc2Uuc3RhdHVzICE9PSAnMCcgJiYgcGFyc2VkUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgX2dldEFwaVVybCAoKSB7XG4gICAgcmV0dXJuIE5FVFdPUktfQVBJX1VSTFNbdGhpcy5uZXR3b3JrXSB8fCBORVRXT1JLX0FQSV9VUkxTLm1haW5uZXRcbiAgfVxuXG59XG5cbkxlZGdlckJyaWRnZUtleXJpbmcudHlwZSA9IHR5cGVcbm1vZHVsZS5leHBvcnRzID0gTGVkZ2VyQnJpZGdlS2V5cmluZ1xuIiwiY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IGV0aEFiaSA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtYWJpJylcbmNvbnN0IG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKVxubmFjbC51dGlsID0gcmVxdWlyZSgndHdlZXRuYWNsLXV0aWwnKVxuXG5jb25zdCBUWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgZG9tYWluOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgbWVzc2FnZTogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICB9LFxuICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGFcbiAqL1xuY29uc3QgVHlwZWREYXRhVXRpbHMgPSB7XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGVuY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3RcbiAgICovXG4gIGVuY29kZURhdGEgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ11cbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW3RoaXMuaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKV1cblxuICAgIGlmICh1c2VWNCkge1xuICAgICAgY29uc3QgZW5jb2RlRmllbGQgPSAobmFtZSwgdHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyA6XG4gICAgICAgICAgICBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGZpZWxkICR7bmFtZX0gb2YgdHlwZSAke3R5cGV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5sYXN0SW5kZXhPZignXScpID09PSB0eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKG5hbWUsIHBhcnNlZFR5cGUsIGl0ZW0pKVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2NhayhldGhBYmkucmF3RW5jb2RlKFxuICAgICAgICAgICAgdHlwZVZhbHVlUGFpcnMubWFwKChbX3R5cGVdKSA9PiBfdHlwZSksXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFssIF92YWx1ZV0pID0+IF92YWx1ZSksXG4gICAgICAgICAgKSldXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3R5cGUsIHZhbHVlXVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQoZmllbGQubmFtZSwgZmllbGQudHlwZSwgZGF0YVtmaWVsZC5uYW1lXSlcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSlcbiAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2ZpZWxkLm5hbWVdXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodmFsdWUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgLy8gY29udmVydCBzdHJpbmcgdG8gYnVmZmVyIC0gcHJldmVudHMgZXRoVXRpbCBmcm9tIGludGVycHJldGluZyBzdHJpbmdzIGxpa2UgJzB4YWJjZCcgYXMgaGV4XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZXNbZmllbGQudHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEoZmllbGQudHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlLmxhc3RJbmRleE9mKCddJykgPT09IGZpZWxkLnR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgY3VycmVudGx5IHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YScpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKGZpZWxkLnR5cGUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aEFiaS5yYXdFbmNvZGUoZW5jb2RlZFR5cGVzLCBlbmNvZGVkVmFsdWVzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBieSBlbmNvZGluZyBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIGl0cyBtZW1iZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBlbmNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqL1xuICBlbmNvZGVUeXBlIChwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICBsZXQgZGVwcyA9IHRoaXMuZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKS5maWx0ZXIoKGRlcCkgPT4gZGVwICE9PSBwcmltYXJ5VHlwZSlcbiAgICBkZXBzID0gW3ByaW1hcnlUeXBlXS5jb25jYXQoZGVwcy5zb3J0KCkpXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHlwZXNbdHlwZV1cbiAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YClcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBgJHt0eXBlfSgke3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlOiBfdHlwZSB9KSA9PiBgJHtfdHlwZX0gJHtuYW1lfWApLmpvaW4oJywnKX0pYFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCB0eXBlcyB3aXRoaW4gYSB0eXBlIGRlZmludGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0cyAtIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gLSBTZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbiAgICovXG4gIGZpbmRUeXBlRGVwZW5kZW5jaWVzIChwcmltYXJ5VHlwZSwgdHlwZXMsIHJlc3VsdHMgPSBbXSkge1xuICAgIGNvbnN0IFtmaXJzdFdvcmRdID0gcHJpbWFyeVR5cGUubWF0Y2goL15cXHcqL3UpXG4gICAgcHJpbWFyeVR5cGUgPSBmaXJzdFdvcmRcbiAgICBpZiAocmVzdWx0cy5pbmNsdWRlcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHRzXG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChwcmltYXJ5VHlwZSlcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgdGhpcy5maW5kVHlwZURlcGVuZGVuY2llcyhmaWVsZC50eXBlLCB0eXBlcywgcmVzdWx0cykpIHtcbiAgICAgICAgIXJlc3VsdHMuaW5jbHVkZXMoZGVwKSAmJiByZXN1bHRzLnB1c2goZGVwKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFN0cnVjdCAocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCA9IHRydWUpIHtcbiAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQpKVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFR5cGUgKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgIHJldHVybiBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZVR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSlcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzXG4gICAqL1xuICBzYW5pdGl6ZURhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0ge31cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhUWVBFRF9NRVNTQUdFX1NDSEVNQS5wcm9wZXJ0aWVzKSkge1xuICAgICAgZGF0YVtrZXldICYmIChzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV0pXG4gICAgfVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnR5cGVzKSB7XG4gICAgICBzYW5pdGl6ZWREYXRhLnR5cGVzID0geyBFSVA3MTJEb21haW46IFtdLCAuLi5zYW5pdGl6ZWREYXRhLnR5cGVzIH1cbiAgICB9XG4gICAgcmV0dXJuIHNhbml0aXplZERhdGFcbiAgfSxcblxuICAvKipcbiAgICogU2lnbnMgYSB0eXBlZCBtZXNzYWdlIGFzIHBlciBFSVAtNzEyIGFuZCByZXR1cm5zIGl0cyBrZWNjYWsgaGFzaFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWREYXRhIC0gVHlwZXMgbWVzc2FnZSBkYXRhIHRvIHNpZ25cbiAgICogQHJldHVybnMge3N0cmluZ30gLSBrZWNjYWsgaGFzaCBvZiB0aGUgcmVzdWx0aW5nIHNpZ25lZCBtZXNzYWdlXG4gICAqL1xuICBzaWduICh0eXBlZERhdGEsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB0aGlzLnNhbml0aXplRGF0YSh0eXBlZERhdGEpXG4gICAgY29uc3QgcGFydHMgPSBbQnVmZmVyLmZyb20oJzE5MDEnLCAnaGV4JyldXG4gICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIHNhbml0aXplZERhdGEuZG9tYWluLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICBwYXJ0cy5wdXNoKHRoaXMuaGFzaFN0cnVjdChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlLCBzYW5pdGl6ZWREYXRhLm1lc3NhZ2UsIHNhbml0aXplZERhdGEudHlwZXMsIHVzZVY0KSlcbiAgICB9XG4gICAgcmV0dXJuIGV0aFV0aWwua2VjY2FrKEJ1ZmZlci5jb25jYXQocGFydHMpKVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVFlQRURfTUVTU0FHRV9TQ0hFTUEsXG4gIFR5cGVkRGF0YVV0aWxzLFxuXG4gIGNvbmNhdFNpZyAodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSBldGhVdGlsLmZyb21TaWduZWQocilcbiAgICBjb25zdCBzU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHMpXG4gICAgY29uc3QgdlNpZyA9IGV0aFV0aWwuYnVmZmVyVG9JbnQodilcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoclNpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCB2U3RyID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeChldGhVdGlsLmludFRvSGV4KHZTaWcpKVxuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeChyU3RyLmNvbmNhdChzU3RyLCB2U3RyKSkudG9TdHJpbmcoJ2hleCcpXG4gIH0sXG5cbiAgbm9ybWFsaXplIChpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9XG5cbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoaW5wdXQudG9Mb3dlckNhc2UoKSlcbiAgfSxcblxuICBwZXJzb25hbFNpZ24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICBjb25zdCBzZW5kZXJIZXggPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgICByZXR1cm4gc2VuZGVySGV4XG4gIH0sXG5cbiAgZXh0cmFjdFB1YmxpY0tleSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICByZXR1cm4gYDB4JHtwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpfWBcbiAgfSxcblxuICB0eXBlZFNpZ25hdHVyZUhhc2ggKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YUxlZ2FjeSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgfSxcblxuICBlbmNyeXB0IChyZWNlaXZlclB1YmxpY0tleSwgbXNnUGFyYW1zLCB2ZXJzaW9uKSB7XG5cbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2dQYXJhbXMuZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlY3Qgc2VjcmV0IG1lc3NhZ2UsIG1lc3NhZ2UgcGFyYW1zIHNob3VsZCBiZSBvZiB0aGUgZm9ybSB7ZGF0YTogXCJzZWNyZXQgbWVzc2FnZVwifSAnKVxuICAgICAgICB9XG4gICAgICAgIC8vIGdlbmVyYXRlIGVwaGVtZXJhbCBrZXlwYWlyXG4gICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKClcblxuICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KHJlY2VpdmVyUHVibGljS2V5KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwdWJsaWMga2V5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2dQYXJhbXMuZGF0YSlcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKVxuXG4gICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94KG1zZ1BhcmFtc1VJbnQ4QXJyYXksIG5vbmNlLCBwdWJLZXlVSW50OEFycmF5LCBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSlcblxuICAgICAgICAvLyBoYW5kbGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgIHZlcnNpb246ICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnLFxuICAgICAgICAgIG5vbmNlOiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KG5vbmNlKSxcbiAgICAgICAgICBlcGhlbVB1YmxpY0tleTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgY2lwaGVydGV4dDogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0ZWRNZXNzYWdlKSxcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZW5jcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpXG5cbiAgICB9XG4gIH0sXG5cbiAgZW5jcnlwdFNhZmVseSAocmVjZWl2ZXJQdWJsaWNLZXksIG1zZ1BhcmFtcywgdmVyc2lvbikge1xuXG4gICAgY29uc3QgREVGQVVMVF9QQURESU5HX0xFTkdUSCA9ICgyICoqIDExKVxuICAgIGNvbnN0IE5BQ0xfRVhUUkFfQllURVMgPSAxNlxuXG4gICAgY29uc3QgeyBkYXRhIH0gPSBtc2dQYXJhbXNcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgZW1wdHkgbXNnLmRhdGEnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS50b0pTT04pIHtcbiAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHdpdGggdG9KU09OIHByb3BlcnR5LiAgUGxlYXNlIHJlbW92ZSB0b0pTT04gcHJvcGVydHknKVxuICAgIH1cblxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgZGF0YSxcbiAgICAgIHBhZGRpbmc6ICcnLFxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpXG4gICAgY29uc3QgbW9kVmFsID0gKGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIKVxuICAgIGxldCBwYWRMZW5ndGggPSAwXG4gICAgLy8gT25seSBwYWQgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZFZhbCA+IDApIHtcbiAgICAgIHBhZExlbmd0aCA9IChERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsKSAtIE5BQ0xfRVhUUkFfQllURVMgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKVxuXG4gICAgY29uc3QgcGFkZGVkTXNnUGFyYW1zID0geyBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpIH1cbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0KHJlY2VpdmVyUHVibGljS2V5LCBwYWRkZWRNc2dQYXJhbXMsIHZlcnNpb24pXG4gIH0sXG5cbiAgZGVjcnlwdCAoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG5cbiAgICBzd2l0Y2ggKGVuY3J5cHRlZERhdGEudmVyc2lvbikge1xuICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAvLyBzdHJpbmcgdG8gYnVmZmVyIHRvIFVJbnQ4QXJyYXlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHJlY2VpdmVyUHJpdmF0ZUtleSlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShyZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5KS5zZWNyZXRLZXlcblxuICAgICAgICAvLyBhc3NlbWJsZSBkZWNyeXB0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEubm9uY2UpXG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dClcbiAgICAgICAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpXG5cbiAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZXBoZW1QdWJsaWNLZXksIHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkpXG5cbiAgICAgICAgLy8gcmV0dXJuIGRlY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICBsZXQgb3V0cHV0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmFjbC51dGlsLmVuY29kZVVURjgoZGVjcnlwdGVkTWVzc2FnZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY3J5cHRpb24gZmFpbGVkLicpXG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZC4nKVxuICAgIH1cbiAgfSxcblxuICBkZWNyeXB0U2FmZWx5IChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBkYXRhV2l0aFBhZGRpbmcgPSBKU09OLnBhcnNlKHRoaXMuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpKVxuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YVxuICB9LFxuXG5cbiAgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSAocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbF9kZWNvZGVIZXgocHJpdmF0ZUtleSlcbiAgICBjb25zdCBlbmNyeXB0aW9uUHVibGljS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlVaW50OEFycmF5KS5wdWJsaWNLZXlcbiAgICByZXR1cm4gbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0aW9uUHVibGljS2V5KVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBlbnRyeSBwb2ludCBmb3IgYWxsIHR5cGVkIGRhdGEgbWV0aG9kcyB0byBiZSBwYXNzZWQsIGluY2x1ZGVzIGEgdmVyc2lvbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBzaWduVHlwZWRNZXNzYWdlIChwcml2YXRlS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFMZWdhY3kocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjMnOlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhKHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICAgIGNhc2UgJ1Y0JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFfdjQocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICByZWNvdmVyVHlwZWRNZXNzYWdlIChtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWMyc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWNCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQobXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICBzaWduVHlwZWREYXRhIChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSwgZmFsc2UpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICBzaWduVHlwZWREYXRhX3Y0IChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZSwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZV92NCAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3QgcHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleShtZXNzYWdlLCBtc2dQYXJhbXMuc2lnKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gIH0sXG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCAodHlwZWREYXRhKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdFeHBlY3QgYXJndW1lbnQgdG8gYmUgbm9uLWVtcHR5IGFycmF5JylcbiAgaWYgKHR5cGVvZiB0eXBlZERhdGEgIT09ICdvYmplY3QnIHx8ICF0eXBlZERhdGEubGVuZ3RoKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUudHlwZSA9PT0gJ2J5dGVzJyA/IGV0aFV0aWwudG9CdWZmZXIoZS52YWx1ZSkgOiBlLnZhbHVlXG4gIH0pXG4gIGNvbnN0IHR5cGVzID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnR5cGVcbiAgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gXG4gIH0pXG5cbiAgcmV0dXJuIGV0aEFiaS5zb2xpZGl0eVNIQTMoXG4gICAgWydieXRlczMyJywgJ2J5dGVzMzInXSxcbiAgICBbXG4gICAgICBldGhBYmkuc29saWRpdHlTSEEzKG5ldyBBcnJheSh0eXBlZERhdGEubGVuZ3RoKS5maWxsKCdzdHJpbmcnKSwgc2NoZW1hKSxcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTModHlwZXMsIGRhdGEpLFxuICAgIF0sXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleSAoaGFzaCwgc2lnKSB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFV0aWwudG9CdWZmZXIoc2lnKVxuICBjb25zdCBzaWdQYXJhbXMgPSBldGhVdGlsLmZyb21ScGNTaWcoc2lnbmF0dXJlKVxuICByZXR1cm4gZXRoVXRpbC5lY3JlY292ZXIoaGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucylcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yIChtc2dQYXJhbXMpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGV0aFV0aWwudG9CdWZmZXIobXNnUGFyYW1zLmRhdGEpXG4gIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgcmV0dXJuIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbn1cblxuXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzIChudW1iZXIsIGxlbmd0aCkge1xuICBsZXQgbXlTdHJpbmcgPSBgJHtudW1iZXJ9YFxuICB3aGlsZSAobXlTdHJpbmcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgbXlTdHJpbmcgPSBgMCR7bXlTdHJpbmd9YFxuICB9XG4gIHJldHVybiBteVN0cmluZ1xufVxuXG4vLyBjb252ZXJ0cyBoZXggc3RyaW5ncyB0byB0aGUgVWludDhBcnJheSBmb3JtYXQgdXNlZCBieSBuYWNsXG5mdW5jdGlvbiBuYWNsX2RlY29kZUhleCAobXNnSGV4KSB7XG4gIGNvbnN0IG1zZ0Jhc2U2NCA9IChCdWZmZXIuZnJvbShtc2dIZXgsICdoZXgnKSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIHJldHVybiBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KG1zZ0Jhc2U2NClcbn1cblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhaycpLFxuICAgIGtlY2NhazIyNCA9IF9yZXF1aXJlLmtlY2NhazIyNCxcbiAgICBrZWNjYWszODQgPSBfcmVxdWlyZS5rZWNjYWszODQsXG4gICAgazI1NiA9IF9yZXF1aXJlLmtlY2NhazI1NixcbiAgICBrZWNjYWs1MTIgPSBfcmVxdWlyZS5rZWNjYWs1MTI7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1hZGFwdGVyJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgcmxwID0gcmVxdWlyZSgncmxwJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCByZXF1aXJlKCdldGhqcy11dGlsJykpO1xuXG4vKipcbiAqIHRoZSBtYXggaW50ZWdlciB0aGF0IHRoaXMgVk0gY2FuIGhhbmRsZSAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBNQVhfSU5URUdFUlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuXG4vKipcbiAqIDJeMjU2IChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IFRXT19QT1cyNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9OVUxMX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuZXhwb3J0cy5TSEEzX05VTExfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9OVUxMXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTDtcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfQVJSQVlfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3JztcbmV4cG9ydHMuU0hBM19STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUF9BUlJBWVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsICAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbmV4cG9ydHMuU0hBM19STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQO1xuXG4vKipcbiAqIFtgQk5gXShodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcylcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLkJOID0gQk47XG5cbi8qKlxuICogW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5ybHAgPSBybHA7XG5cbi8qKlxuICogW2BzZWNwMjU2azFgXShodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlLylcbiAqIEB2YXIge09iamVjdH1cbiAqL1xuZXhwb3J0cy5zZWNwMjU2azEgPSBzZWNwMjU2azE7XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwc1xuICogQG1ldGhvZCB6ZXJvc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5cbi8qKlxuICAqIFJldHVybnMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIHplcm9BZGRyZXNzXG4gICogQHJldHVybiB7U3RyaW5nfVxuICAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoemVyb0FkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBMZWZ0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQG1ldGhvZCBsc2V0TGVuZ3RoXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHtCb29sZWFufSBbcmlnaHQ9ZmFsc2VdIHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICBtc2cgPSBleHBvcnRzLnRvQnVmZmVyKG1zZyk7XG4gIGlmIChyaWdodCkge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSaWdodCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAgb3IgYW4gYEFycmF5YFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfSBhXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfVxuICovXG5leHBvcnRzLnVucGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYSk7XG4gIHZhciBmaXJzdCA9IGFbMF07XG4gIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgZmlyc3QgPSBhWzBdO1xuICB9XG4gIHJldHVybiBhO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC4gQXMgaW5wdXQgaXQgc3VwcG9ydHMgYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB7Kn0gdiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGV4cG9ydHMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMucGFkVG9FdmVuKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHYgPSBleHBvcnRzLmludFRvQnVmZmVyKHYpO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfSBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gbmV3IEJOKGV4cG9ydHMudG9CdWZmZXIoYnVmKSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGJ1ZiA9IGV4cG9ydHMudG9CdWZmZXIoYnVmKTtcbiAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IG51bVxuICogQHJldHVybiB7Qk59XG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG5ldyBCTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCTn0gbnVtXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIEtlY2NhayB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICBpZiAoIWJpdHMpIGJpdHMgPSAyNTY7XG5cbiAgc3dpdGNoIChiaXRzKSB7XG4gICAgY2FzZSAyMjQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyMjQoYSk7XG4gICAgICB9XG4gICAgY2FzZSAyNTY6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrMjU2KGEpO1xuICAgICAgfVxuICAgIGNhc2UgMzg0OlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrMzg0KGEpO1xuICAgICAgfVxuICAgIGNhc2UgNTEyOlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrNTEyKGEpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxkIGFsZ29yaXRobToga2VjY2FrJyArIGJpdHMpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKGEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIChLZWNjYWspIGhhc2ggb2YgdGhlIGlucHV0IFtPQlNPTEVURV1cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBTSEEtMyB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTMgPSBleHBvcnRzLmtlY2NhaztcblxuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtCb29sZWFufSBwYWRkZWQgd2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKGhhc2gsIDMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhybHAuZW5jb2RlKGEpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICB9XG5cbiAgaWYgKCFzYW5pdGl6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICBwdWJLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YktleSk7XG4gIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIGFzc2VydChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHByaXZhdGVLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHByaXZhdGVLZXkpO1xuICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHB1YmxpY0tleSA9IGV4cG9ydHMudG9CdWZmZXIocHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogRUNEU0Egc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZWNzaWduID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuXG4gIHZhciByZXQgPSB7fTtcbiAgcmV0LnIgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgcmV0LnMgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCk7XG4gIHJldC52ID0gc2lnLnJlY292ZXJ5ICsgMjc7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGhhc2hcbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgdmFyIHByZWZpeCA9IGV4cG9ydHMudG9CdWZmZXIoJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJyArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcblxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqL1xuZXhwb3J0cy5lY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcykge1xuICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGgociwgMzIpLCBleHBvcnRzLnNldExlbmd0aChzLCAzMildLCA2NCk7XG4gIHZhciByZWNvdmVyeSA9IHYgLSAyNztcbiAgaWYgKHJlY292ZXJ5ICE9PSAwICYmIHJlY292ZXJ5ICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gIH1cbiAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7U3RyaW5nfSBzaWdcbiAqL1xuZXhwb3J0cy50b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzKSB7XG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWNvdmVyeSBpZCcpO1xuICB9XG5cbiAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgLy8gRklYTUU6IHRoaXMgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUgLSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgZXhwb3J0cy50b0J1ZmZlcih2IC0gMjcpXSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgc2lnID0gZXhwb3J0cy50b0J1ZmZlcihzaWcpO1xuXG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmIChzaWcubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgdiA9IHNpZ1s2NF07XG4gIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICBpZiAodiA8IDI3KSB7XG4gICAgdiArPSAyNztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdjogdixcbiAgICByOiBzaWcuc2xpY2UoMCwgMzIpLFxuICAgIHM6IHNpZy5zbGljZSgzMiwgNjQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKHByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b29cbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuICgvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChhZGRyZXNzKVxuICApO1xufTtcblxuLyoqXG4gICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgaXNaZXJvQWRkcmVzc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MoKTtcbiAgcmV0dXJuIHplcm9BZGRyZXNzID09PSBleHBvcnRzLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBhZGRyZXNzID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzaCA9IGV4cG9ydHMua2VjY2FrKGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIHJldCA9ICcweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gZnJvbSB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbm9uY2UgdGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgZnJvbSA9IGV4cG9ydHMudG9CdWZmZXIoZnJvbSk7XG4gIG5vbmNlID0gbmV3IEJOKG5vbmNlKTtcblxuICBpZiAobm9uY2UuaXNaZXJvKCkpIHtcbiAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgIG5vbmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub25jZSA9IEJ1ZmZlci5mcm9tKG5vbmNlLnRvQXJyYXkoKSk7XG4gIH1cblxuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMucmxwaGFzaChbZnJvbSwgbm9uY2VdKS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSlcbiAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIGEgPSBleHBvcnRzLnVucGFkKGFkZHJlc3MpO1xuICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA+PSAxICYmIGFbMF0gPD0gODtcbn07XG5cbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgRUNEU0Egc2lnbmF0dXJlXG4gKiBAbWV0aG9kIGlzVmFsaWRTaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hvbWVzdGVhZD10cnVlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkKSB7XG4gIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuXG4gIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgciA9IG5ldyBCTihyKTtcbiAgcyA9IG5ldyBCTihzKTtcblxuICBpZiAoci5pc1plcm8oKSB8fCByLmd0KFNFQ1AyNTZLMV9OKSB8fCBzLmlzWmVybygpIHx8IHMuZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhvbWVzdGVhZCA9PT0gZmFsc2UgJiYgbmV3IEJOKHMpLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT05cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBiYVxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydHMuYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICByZXR1cm4gJzB4JyArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIHsqfSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgc2VsZi5yYXcgPSBbXTtcbiAgc2VsZi5fZmllbGRzID0gW107XG5cbiAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIG9ialtmaWVsZF0gPSAnMHgnICsgc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5iYVRvSlNPTih0aGlzLnJhdyk7XG4gIH07XG5cbiAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICB9O1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgIHYgPSBleHBvcnRzLnRvQnVmZmVyKHYpO1xuXG4gICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICB2ID0gZXhwb3J0cy5zdHJpcFplcm9zKHYpO1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IG5vdCBoYXZlIG1vcmUgJyArIGZpZWxkLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgICAgIH0gZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICcgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIHNldDogc2V0dGVyXG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoZGF0YSksICdoZXgnKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gcmxwLmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGV4cG9ydHMudG9CdWZmZXIoZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSkgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSkgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgIH1cbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG5cbmZ1bmN0aW9uIGdldFNlY3AyNTZrMSAoKSB7IHJldHVybiByZXF1aXJlKCcuL3NlY3AyNTZrMS1saWIvaW5kZXgnKTsgfVxudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9kZXInKTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHJpdmF0ZUtleSBsZW5ndGggaXMgbm90IDMyXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogRXhwb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBzZWNwMjU2azF2MyA9IGdldFNlY3AyNTZrMSgpO1xuICAvLyBwcml2YXRlS2V5RXhwb3J0IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHZhciBwdWJsaWNLZXkgPSBzZWNwMjU2azF2My5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpO1xuXG4gIHJldHVybiBkZXIucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpO1xufTtcblxuLyoqXG4gKiBJbXBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuXG52YXIgcHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSkge1xuICAvLyBwcml2YXRlS2V5SW1wb3J0IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KTtcbiAgaWYgKHByaXZhdGVLZXkgIT09IG51bGwgJiYgcHJpdmF0ZUtleS5sZW5ndGggPT09IDMyICYmIHByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkpIHtcbiAgICByZXR1cm4gcHJpdmF0ZUtleTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IGltcG9ydCBmcm9tIERFUiBmb3JtYXRcIik7XG59O1xuXG4vKipcbiAqIE5lZ2F0ZSBhIHByaXZhdGVLZXkgYnkgc3VidHJhY3RpbmcgaXQgZnJvbSB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludFxuICogQG1ldGhvZCBwcml2YXRlS2V5TmVnYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlOZWdhdGUocHJpdmF0ZUtleSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlOZWdhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgYSBwcml2YXRlS2V5IChtb2R1bG8gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnQpLlxuICogQG1ldGhvZCBwcml2YXRlS2V5TW9kSW52ZXJzZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gcHJpdmF0ZUtleU1vZEludmVyc2UocHJpdmF0ZUtleSkge1xuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG4gIHZhciBzZWNwMjU2azF2MyA9IGdldFNlY3AyNTZrMSgpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMucHJpdmF0ZUtleU1vZEludmVyc2UoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBhZGRpbmcgdHdlYWsgdG8gaXQuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgdHdlYWspKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrTXVsID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciBhIHByaXZhdGVLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNyZWF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwdWJsaWNLZXkgdG8gY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgZm9ybS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29udmVydFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gcHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwdWJsaWNLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIHB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHVibGljS2V5IGxlbmd0aCBpcyBub3QgMzMgb3IgNjVcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBhZGRpbmcgdHdlYWsgdGltZXMgdGhlIGdlbmVyYXRvciB0byBpdC5cbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrQWRkKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrIHZhbHVlXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb21iaW5lKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgcHVibGljS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICBrZXlzLnB1c2goVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xuICB9KTtcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbWJpbmUoa2V5cywgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmF0dXJlIHRvIGEgbm9ybWFsaXplZCBsb3dlci1TIGZvcm0uXG4gKiBAbWV0aG9kIHNpZ25hdHVyZU5vcm1hbGl6ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gc2lnbmF0dXJlTm9ybWFsaXplKHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKG5vdCBmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRMYXhcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpIHtcbiAgLy8gc2lnbmF0dXJlSW1wb3J0TGF4IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuICB2YXIgc2VjcDI1NmsxdjMgPSBnZXRTZWNwMjU2azEoKTtcblxuICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpO1xuICBpZiAoc2lnT2JqID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgcGFyc2UgREVSIHNpZ25hdHVyZVwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azF2My5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVDRFNBIHNpZ25hdHVyZS4gQWx3YXlzIHJldHVybiBsb3ctUyBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBhbiBPYmplY3QnKTtcbiAgfVxuXG4gIHZhciBzaWduT3B0aW9ucyA9IHZvaWQgMDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHNpZ25PcHRpb25zID0ge307XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgQnVmZmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgLy8gdmFsaWRhdGUgb3B0aW9uLmRhdGEgbGVuZ3RoXG4gICAgICBpZiAob3B0aW9ucy5kYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29wdGlvbnMuZGF0YSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgICAgfVxuXG4gICAgICBzaWduT3B0aW9ucy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub25jZWZuID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5vbmNlZm4gc2hvdWxkIGJlIGEgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAvLyAgY29udmVydCBvcHRpb24ubm9uY2VmbiBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgIHNpZ25PcHRpb25zLm5vbmNlZm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgYWxnbywgZGF0YSwgYXR0ZW1wdCkge1xuICAgICAgICB2YXIgYnVmZmVyQWxnbyA9IGFsZ28gIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGFsZ28pIDogbnVsbDtcbiAgICAgICAgdmFyIGJ1ZmZlckRhdGEgPSBkYXRhICE9IG51bGwgPyBCdWZmZXIuZnJvbShkYXRhKSA6IG51bGw7XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCcnKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAgICAgYnVmZmVyID0gb3B0aW9ucy5ub25jZWZuKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLCBCdWZmZXIuZnJvbShwcml2YXRlS2V5KSwgYnVmZmVyQWxnbywgYnVmZmVyRGF0YSwgYXR0ZW1wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ1ZmZlcik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBzaWcgPSBzZWNwMjU2azEuZWNkc2FTaWduKFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBzaWduT3B0aW9ucyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHNpZy5zaWduYXR1cmUpLFxuICAgIHJlY292ZXJ5OiBzaWcucmVjaWRcbiAgfTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgdmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjQgdmVyaWZ5IG1ldGhvZCBoYXMgYSBkaWZmZXJlbnQgYXJndW1lbnQgb3JkZXJcbiAgcmV0dXJuIHNlY3AyNTZrMS5lY2RzYVZlcmlmeShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZWNvdmVyIGFuIEVDRFNBIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgcmVjb3ZlclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWNpZFxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciByZWNvdmVyID0gZnVuY3Rpb24gcmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUsIHJlY2lkLCBjb21wcmVzc2VkKSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2NCByZWNvdmVyIG1ldGhvZCBoYXMgYSBkaWZmZXJlbnQgYXJndW1lbnQgb3JkZXJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RzYVJlY292ZXIoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIHJlY2lkLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIGFwcGxpZWQgc2hhMjU2IHRvIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAqIEBtZXRob2QgZWNkaFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIGVjZGggPSBmdW5jdGlvbiBlY2RoKHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjMgZG9lc24ndCBhbGxvdyBvcHRpb25hbCBwYXJhbWV0ZXJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHt9KSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gRUMgRGlmZmllLUhlbGxtYW4gc2VjcmV0IGFuZCByZXR1cm4gcHVibGljIGtleSBhcyByZXN1bHRcbiAqIEBtZXRob2QgZWNkaFVuc2FmZVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIGVjZGhVbnNhZmUocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIC8vIGVjZGhVbnNhZmUgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgLy8gZW5zdXJlIHZhbGlkIHB1YmxpY0tleSBsZW5ndGhcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3B1YmxpYyBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSB2YWxpZCBwcml2YXRlS2V5IGxlbmd0aFxuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgdmFyIHNlY3AyNTZrMXYzID0gZ2V0U2VjcDI1NmsxKCk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLmVjZGhVbnNhZmUoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByaXZhdGVLZXlWZXJpZnk6IHByaXZhdGVLZXlWZXJpZnksXG4gIHByaXZhdGVLZXlFeHBvcnQ6IHByaXZhdGVLZXlFeHBvcnQsXG4gIHByaXZhdGVLZXlJbXBvcnQ6IHByaXZhdGVLZXlJbXBvcnQsXG4gIHByaXZhdGVLZXlOZWdhdGU6IHByaXZhdGVLZXlOZWdhdGUsXG4gIHByaXZhdGVLZXlNb2RJbnZlcnNlOiBwcml2YXRlS2V5TW9kSW52ZXJzZSxcbiAgcHJpdmF0ZUtleVR3ZWFrQWRkOiBwcml2YXRlS2V5VHdlYWtBZGQsXG4gIHByaXZhdGVLZXlUd2Vha011bDogcHJpdmF0ZUtleVR3ZWFrTXVsLFxuXG4gIHB1YmxpY0tleUNyZWF0ZTogcHVibGljS2V5Q3JlYXRlLFxuICBwdWJsaWNLZXlDb252ZXJ0OiBwdWJsaWNLZXlDb252ZXJ0LFxuICBwdWJsaWNLZXlWZXJpZnk6IHB1YmxpY0tleVZlcmlmeSxcbiAgcHVibGljS2V5VHdlYWtBZGQ6IHB1YmxpY0tleVR3ZWFrQWRkLFxuICBwdWJsaWNLZXlUd2Vha011bDogcHVibGljS2V5VHdlYWtNdWwsXG4gIHB1YmxpY0tleUNvbWJpbmU6IHB1YmxpY0tleUNvbWJpbmUsXG5cbiAgc2lnbmF0dXJlTm9ybWFsaXplOiBzaWduYXR1cmVOb3JtYWxpemUsXG4gIHNpZ25hdHVyZUV4cG9ydDogc2lnbmF0dXJlRXhwb3J0LFxuICBzaWduYXR1cmVJbXBvcnQ6IHNpZ25hdHVyZUltcG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0TGF4OiBzaWduYXR1cmVJbXBvcnRMYXgsXG5cbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnksXG4gIHJlY292ZXI6IHJlY292ZXIsXG5cbiAgZWNkaDogZWNkaCxcbiAgZWNkaFVuc2FmZTogZWNkaFVuc2FmZVxufTsiXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIn0=
