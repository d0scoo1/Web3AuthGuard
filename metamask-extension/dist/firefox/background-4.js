LavaPack.loadBundle([
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\PollingBlockTracker.js", {"./BaseBlockTracker":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\BaseBlockTracker.js","./logging-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\logging-utils.js","json-rpc-random-id":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-random-id\\index.js","pify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cdist%5CPollingBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault(require("json-rpc-random-id"));
const pify_1 = __importDefault(require("pify"));
const BaseBlockTracker_1 = require("./BaseBlockTracker");
const logging_utils_1 = require("./logging-utils");
const log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, 'polling-block-tracker');
const createRandomId = (0, json_rpc_random_id_1.default)();
const sec = 1000;
class PollingBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
    constructor(opts = {}) {
        var _a;
        // parse + validate args
        if (!opts.provider) {
            throw new Error('PollingBlockTracker - no provider specified.');
        }
        super({
            blockResetDuration: (_a = opts.blockResetDuration) !== null && _a !== void 0 ? _a : opts.pollingInterval,
        });
        // config
        this._provider = opts.provider;
        this._pollingInterval = opts.pollingInterval || 20 * sec;
        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
        this._keepEventLoopActive =
            opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;
        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
    }
    // trigger block polling
    async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
    }
    async _start() {
        this._synchronize();
    }
    async _end() {
        // No-op
    }
    async _synchronize() {
        var _a;
        while (this._isRunning) {
            try {
                await this._updateLatestBlock();
                const promise = timeout(this._pollingInterval, !this._keepEventLoopActive);
                this.emit('_waitingForNextIteration');
                await promise;
            }
            catch (err) {
                const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${(_a = err.stack) !== null && _a !== void 0 ? _a : err}`);
                try {
                    this.emit('error', newErr);
                }
                catch (emitErr) {
                    console.error(newErr);
                }
                const promise = timeout(this._retryTimeout, !this._keepEventLoopActive);
                this.emit('_waitingForNextIteration');
                await promise;
            }
        }
    }
    async _updateLatestBlock() {
        // fetch + set latest block
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
    }
    async _fetchLatestBlock() {
        const req = {
            jsonrpc: '2.0',
            id: createRandomId(),
            method: 'eth_blockNumber',
            params: [],
        };
        if (this._setSkipCacheFlag) {
            req.skipCache = true;
        }
        log('Making request', req);
        const res = await (0, pify_1.default)((cb) => this._provider.sendAsync(req, cb))();
        log('Got response', res);
        if (res.error) {
            throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error.message}`);
        }
        return res.result;
    }
}
exports.PollingBlockTracker = PollingBlockTracker;
/**
 * Waits for the specified amount of time.
 *
 * @param duration - The amount of time in milliseconds.
 * @param unref - Assuming this function is run in a Node context, governs
 * whether Node should wait before the `setTimeout` has completed before ending
 * the process (true for no, false for yes). Defaults to false.
 * @returns A promise that can be used to wait.
 */
function timeout(duration, unref) {
    return new Promise((resolve) => {
        const timeoutRef = setTimeout(resolve, duration);
        // don't keep process open
        if (timeoutRef.unref && unref) {
            timeoutRef.unref();
        }
    });
}
//# sourceMappingURL=PollingBlockTracker.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker",file:"node_modules\\eth-block-tracker\\dist\\PollingBlockTracker.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\SubscribeBlockTracker.js", {"./BaseBlockTracker":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\BaseBlockTracker.js","json-rpc-random-id":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-random-id\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cdist%5CSubscribeBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscribeBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault(require("json-rpc-random-id"));
const BaseBlockTracker_1 = require("./BaseBlockTracker");
const createRandomId = (0, json_rpc_random_id_1.default)();
class SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
    constructor(opts = {}) {
        // parse + validate args
        if (!opts.provider) {
            throw new Error('SubscribeBlockTracker - no provider specified.');
        }
        // BaseBlockTracker constructor
        super(opts);
        // config
        this._provider = opts.provider;
        this._subscriptionId = null;
    }
    async checkForLatestBlock() {
        return await this.getLatestBlock();
    }
    async _start() {
        if (this._subscriptionId === undefined || this._subscriptionId === null) {
            try {
                const blockNumber = (await this._call('eth_blockNumber'));
                this._subscriptionId = (await this._call('eth_subscribe', 'newHeads'));
                this._provider.on('data', this._handleSubData.bind(this));
                this._newPotentialLatest(blockNumber);
            }
            catch (e) {
                this.emit('error', e);
            }
        }
    }
    async _end() {
        if (this._subscriptionId !== null && this._subscriptionId !== undefined) {
            try {
                await this._call('eth_unsubscribe', this._subscriptionId);
                this._subscriptionId = null;
            }
            catch (e) {
                this.emit('error', e);
            }
        }
    }
    _call(method, ...params) {
        return new Promise((resolve, reject) => {
            this._provider.sendAsync({
                id: createRandomId(),
                method,
                params,
                jsonrpc: '2.0',
            }, (err, res) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res.result);
                }
            });
        });
    }
    _handleSubData(_, response) {
        var _a;
        if (response.method === 'eth_subscription' &&
            ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {
            this._newPotentialLatest(response.params.result.number);
        }
    }
}
exports.SubscribeBlockTracker = SubscribeBlockTracker;
//# sourceMappingURL=SubscribeBlockTracker.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker",file:"node_modules\\eth-block-tracker\\dist\\SubscribeBlockTracker.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\index.js", {"./PollingBlockTracker":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\PollingBlockTracker.js","./SubscribeBlockTracker":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\SubscribeBlockTracker.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./PollingBlockTracker"), exports);
__exportStar(require("./SubscribeBlockTracker"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker",file:"node_modules\\eth-block-tracker\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\dist\\logging-utils.js", {"@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = (0, utils_1.createProjectLogger)('eth-block-tracker');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker",file:"node_modules\\eth-block-tracker\\dist\\logging-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\base64.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\bytes.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\hex.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\bytes.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\checksum.js", {"./base64":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\base64.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cchecksum.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecksumStruct = void 0;
const superstruct_1 = require("superstruct");
const base64_1 = require("./base64");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
//# sourceMappingURL=checksum.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\checksum.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\coercers.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\bytes.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\hex.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccoercers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;
//# sourceMappingURL=coercers.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\coercers.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\collections.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccollections.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\collections.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\hex.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Chex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;
//# sourceMappingURL=hex.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\hex.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\index.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","./base64":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\base64.js","./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\bytes.js","./checksum":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\checksum.js","./coercers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\coercers.js","./collections":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\collections.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\hex.js","./json":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\json.js","./logging":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\logging.js","./misc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\misc.js","./number":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\number.js","./opaque":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\opaque.js","./time":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\time.js","./versions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\versions.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./base64"), exports);
__exportStar(require("./bytes"), exports);
__exportStar(require("./checksum"), exports);
__exportStar(require("./coercers"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./hex"), exports);
__exportStar(require("./json"), exports);
__exportStar(require("./logging"), exports);
__exportStar(require("./misc"), exports);
__exportStar(require("./number"), exports);
__exportStar(require("./opaque"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./versions"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\json.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","./misc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\misc.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const misc_1 = require("./misc");
exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
    const [isValid] = validateJsonAndGetSize(value, true);
    if (!isValid) {
        return 'Expected a valid JSON-serializable value';
    }
    return true;
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            return [false, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, (0, misc_1.calculateNumberSize)(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\json.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\logging.js", {"debug":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Clogging.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(require("debug"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;
//# sourceMappingURL=logging.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\logging.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\misc.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cmisc.js
      return function (require, module, exports) {
"use strict";
//
// Types
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;
//# sourceMappingURL=misc.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\misc.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\number.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\hex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cnumber.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;
//# sourceMappingURL=number.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\number.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\opaque.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Copaque.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=opaque.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\opaque.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\time.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ctime.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
//# sourceMappingURL=time.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\time.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\versions.js", {"./assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\assert.js","semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\index.js","superstruct":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cversions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = require("semver");
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;
//# sourceMappingURL=versions.js.map
      };
    };
  }
  }
}, {package:"eth-block-tracker>@metamask/utils",file:"node_modules\\eth-block-tracker\\node_modules\\@metamask\\utils\\dist\\versions.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-block-tracker\\node_modules\\pify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-block-tracker%5Cnode_modules%5Cpify%5Cindex.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
  }
}, {package:"eth-block-tracker>pify",file:"node_modules\\eth-block-tracker\\node_modules\\pify\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\abi.js", {"./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\util.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\bn.js\\lib\\bn.js","buffer/":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-eip712-util-browser%5Cabi.js
      return function (require, module, exports) {
// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code
// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi

const util = require('./util')
const BN = require('bn.js')
const Buffer = require('buffer/').Buffer

// Convert from short to canonical names
// FIXME: optimise or make this nicer?
function elementaryName (name) {
  if (name.startsWith('int[')) {
    return 'int256' + name.slice(3)
  } else if (name === 'int') {
    return 'int256'
  } else if (name.startsWith('uint[')) {
    return 'uint256' + name.slice(4)
  } else if (name === 'uint') {
    return 'uint256'
  } else if (name.startsWith('fixed[')) {
    return 'fixed128x128' + name.slice(5)
  } else if (name === 'fixed') {
    return 'fixed128x128'
  } else if (name.startsWith('ufixed[')) {
    return 'ufixed128x128' + name.slice(6)
  } else if (name === 'ufixed') {
    return 'ufixed128x128'
  }
  return name
}

// Parse N from type<N>
function parseTypeN (type) {
  return parseInt(/^\D+(\d+)$/.exec(type)[1], 10)
}

// Parse N,M from type<N>x<M>
function parseTypeNxM (type) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type)
  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]
}

// Parse N in type[<N>] where "type" can itself be an array type.
function parseTypeArray (type) {
  var tmp = type.match(/(.*)\[(.*?)\]$/)
  if (tmp) {
    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)
  }
  return null
}

function parseNumber (arg) {
  var type = typeof arg
  if (type === 'string') {
    if (util.isHexString(arg)) {
      return new BN(util.stripHexPrefix(arg), 16)
    } else {
      return new BN(arg, 10)
    }
  } else if (type === 'number') {
    return new BN(arg)
  } else if (arg.toArray) {
    // assume this is a BN for the moment, replace with BN.isBN soon
    return arg
  } else {
    throw new Error('Argument is not a number')
  }
}

// Encodes a single item (can be dynamic array)
// @returns: Buffer
function encodeSingle (type, arg) {
  var size, num, ret, i

  if (type === 'address') {
    return encodeSingle('uint160', parseNumber(arg))
  } else if (type === 'bool') {
    return encodeSingle('uint8', arg ? 1 : 0)
  } else if (type === 'string') {
    return encodeSingle('bytes', new Buffer(arg, 'utf8'))
  } else if (isArray(type)) {
    // this part handles fixed-length ([2]) and variable length ([]) arrays
    // NOTE: we catch here all calls to arrays, that simplifies the rest
    if (typeof arg.length === 'undefined') {
      throw new Error('Not an array?')
    }
    size = parseTypeArray(type)
    if (size !== 'dynamic' && size !== 0 && arg.length > size) {
      throw new Error('Elements exceed array size: ' + size)
    }
    ret = []
    type = type.slice(0, type.lastIndexOf('['))
    if (typeof arg === 'string') {
      arg = JSON.parse(arg)
    }
    for (i in arg) {
      ret.push(encodeSingle(type, arg[i]))
    }
    if (size === 'dynamic') {
      var length = encodeSingle('uint256', arg.length)
      ret.unshift(length)
    }
    return Buffer.concat(ret)
  } else if (type === 'bytes') {
    arg = new Buffer(arg)

    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])

    if ((arg.length % 32) !== 0) {
      ret = Buffer.concat([ ret, util.zeros(32 - (arg.length % 32)) ])
    }

    return ret
  } else if (type.startsWith('bytes')) {
    size = parseTypeN(type)
    if (size < 1 || size > 32) {
      throw new Error('Invalid bytes<N> width: ' + size)
    }

    return util.setLengthRight(arg, 32)
  } else if (type.startsWith('uint')) {
    size = parseTypeN(type)
    if ((size % 8) || (size < 8) || (size > 256)) {
      throw new Error('Invalid uint<N> width: ' + size)
    }

    num = parseNumber(arg)
    if (num.bitLength() > size) {
      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
    }

    if (num < 0) {
      throw new Error('Supplied uint is negative')
    }

    return num.toArrayLike(Buffer, 'be', 32)
  } else if (type.startsWith('int')) {
    size = parseTypeN(type)
    if ((size % 8) || (size < 8) || (size > 256)) {
      throw new Error('Invalid int<N> width: ' + size)
    }

    num = parseNumber(arg)
    if (num.bitLength() > size) {
      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
    }

    return num.toTwos(256).toArrayLike(Buffer, 'be', 32)
  } else if (type.startsWith('ufixed')) {
    size = parseTypeNxM(type)

    num = parseNumber(arg)

    if (num < 0) {
      throw new Error('Supplied ufixed is negative')
    }

    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))
  } else if (type.startsWith('fixed')) {
    size = parseTypeNxM(type)

    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))
  }

  throw new Error('Unsupported or invalid type: ' + type)
}

// Is a type dynamic?
function isDynamic (type) {
  // FIXME: handle all types? I don't think anything is missing now
  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')
}

// Is a type an array?
function isArray (type) {
  return type.lastIndexOf(']') === type.length - 1
}

// Encode a method/event with arguments
// @types an array of string type names
// @args  an array of the appropriate values
function rawEncode (types, values) {
  var output = []
  var data = []

  var headLength = 32 * types.length

  for (var i in types) {
    var type = elementaryName(types[i])
    var value = values[i]
    var cur = encodeSingle(type, value)

    // Use the head/tail method for storing dynamic data
    if (isDynamic(type)) {
      output.push(encodeSingle('uint256', headLength))
      data.push(cur)
      headLength += cur.length
    } else {
      output.push(cur)
    }
  }

  return Buffer.concat(output.concat(data))
}

function solidityPack (types, values) {
  if (types.length !== values.length) {
    throw new Error('Number of types are not matching the values')
  }

  var size, num
  var ret = []

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i])
    var value = values[i]

    if (type === 'bytes') {
      ret.push(value)
    } else if (type === 'string') {
      ret.push(new Buffer(value, 'utf8'))
    } else if (type === 'bool') {
      ret.push(new Buffer(value ? '01' : '00', 'hex'))
    } else if (type === 'address') {
      ret.push(util.setLength(value, 20))
    } else if (type.startsWith('bytes')) {
      size = parseTypeN(type)
      if (size < 1 || size > 32) {
        throw new Error('Invalid bytes<N> width: ' + size)
      }

      ret.push(util.setLengthRight(value, size))
    } else if (type.startsWith('uint')) {
      size = parseTypeN(type)
      if ((size % 8) || (size < 8) || (size > 256)) {
        throw new Error('Invalid uint<N> width: ' + size)
      }

      num = parseNumber(value)
      if (num.bitLength() > size) {
        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
      }

      ret.push(num.toArrayLike(Buffer, 'be', size / 8))
    } else if (type.startsWith('int')) {
      size = parseTypeN(type)
      if ((size % 8) || (size < 8) || (size > 256)) {
        throw new Error('Invalid int<N> width: ' + size)
      }

      num = parseNumber(value)
      if (num.bitLength() > size) {
        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
      }

      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8))
    } else {
      // FIXME: support all other types
      throw new Error('Unsupported or invalid type: ' + type)
    }
  }

  return Buffer.concat(ret)
}

function soliditySHA3 (types, values) {
  return util.keccak(solidityPack(types, values))
}

module.exports = {
  rawEncode,
  solidityPack,
  soliditySHA3
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>eth-eip712-util-browser",file:"node_modules\\eth-eip712-util-browser\\abi.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\index.js", {"./abi":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\abi.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\util.js","buffer/":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-eip712-util-browser%5Cindex.js
      return function (require, module, exports) {
const util = require('./util')
const abi = require('./abi')
const Buffer = require('buffer/').Buffer

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: {type: 'string'},
            type: {type: 'string'},
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: {type: 'string'},
    domain: {type: 'object'},
    message: {type: 'object'},
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if(useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value == null ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            util.keccak(this.encodeData(type, value, types, useV4))]
        }

        if(value === undefined)
          throw new Error(`missing value for field ${name} of type ${type}`)

        if (type === 'bytes') {
          return ['bytes32', util.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', util.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map(item =>
            encodeField(name, parsedType, item))
          return ['bytes32', util.keccak(abi.rawEncode(
            typeValuePairs.map(([type]) => type),
            typeValuePairs.map(([, value]) => value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = util.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = util.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = util.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return abi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error('No type definition specified: ' + type)
      }
      result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')'
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    primaryType = primaryType.match(/^\w*/)[0]
    if (results.includes(primaryType) || types[primaryType] === undefined) { return results }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return util.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return util.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key in TYPED_MESSAGE_SCHEMA.properties) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types)
    }
    return sanitizedData
  },

  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return util.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  hashForSignTypedDataLegacy: function (msgParams) {
    return typedSignatureHashLegacy(msgParams.data)
  },

  hashForSignTypedData_v3: function (msgParams) {
    return TypedDataUtils.hash(msgParams.data, false)
  },

  hashForSignTypedData_v4: function (msgParams) {
    return TypedDataUtils.hash(msgParams.data)
  },
}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHashLegacy(typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) throw error

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) { return e.type })
  const schema = typedData.map(function (e) {
    if (!e.name) throw error
    return e.type + ' ' + e.name
  })

  return abi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      abi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      abi.soliditySHA3(types, data)
    ]
  )
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>eth-eip712-util-browser",file:"node_modules\\eth-eip712-util-browser\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\bn.js\\lib\\bn.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-eip712-util-browser%5Cnode_modules%5Cbn.js%5Clib%5Cbn.js
      return function (require, module, exports) {
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>eth-eip712-util-browser>bn.js",file:"node_modules\\eth-eip712-util-browser\\node_modules\\bn.js\\lib\\bn.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\buffer\\index.js", {"base64-js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\base64-js\\index.js","ieee754":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ieee754\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-eip712-util-browser%5Cnode_modules%5Cbuffer%5Cindex.js
      return function (require, module, exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

const base64 = require('base64-js')
const ieee754 = require('ieee754')
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>eth-eip712-util-browser>buffer",file:"node_modules\\eth-eip712-util-browser\\node_modules\\buffer\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\js-sha3\\src\\sha3.js", {"_process":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\process\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-eip712-util-browser%5Cnode_modules%5Cjs-sha3%5Csrc%5Csha3.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      define(function () {
        return methods;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>eth-eip712-util-browser>js-sha3",file:"node_modules\\eth-eip712-util-browser\\node_modules\\js-sha3\\src\\sha3.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\util.js", {"bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\bn.js\\lib\\bn.js","buffer/":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\buffer\\index.js","js-sha3":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\node_modules\\js-sha3\\src\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-eip712-util-browser%5Cutil.js
      return function (require, module, exports) {
// Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code
// Original code licensed under the Mozilla Public License Version 2.0

const BN = require('bn.js')
const Buffer = require('buffer/').Buffer
const keccak256 = require('js-sha3').keccak256

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
function zeros (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0)
}

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method setLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
function setLength (msg, length, right) {
  const buf = zeros(length)
  msg = toBuffer(msg)
  if (right) {
    if (msg.length < length) {
      msg.copy(buf)
      return buf
    }
    return msg.slice(0, length)
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length)
      return buf
    }
    return msg.slice(-length)
  }
}

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
function setLengthRight (msg, length) {
  return setLength(msg, length, true)
}

/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
function toBuffer (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v)
    } else if (typeof v === 'string') {
      if (isHexString(v)) {
        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex')
      } else {
        v = Buffer.from(v)
      }
    } else if (typeof v === 'number') {
      v = intToBuffer(v)
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0)
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer)
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray())
    } else {
      throw new Error('invalid type')
    }
  }
  return v
}

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
function bufferToHex (buf) {
  buf = toBuffer(buf)
  return '0x' + buf.toString('hex')
}

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
function keccak (a) {
  a = toBuffer(a)
  return Buffer.from(keccak256(a), 'hex')
}

function padToEven (str) {
  return str.length % 2 ? '0' + str : str
}

function isHexString (str) {
  return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/)
}

function stripHexPrefix (str) {
  if (typeof str === 'string' && str.startsWith('0x')) {
    return str.slice(2)
  }
  return str
}

module.exports = {
  zeros,
  setLength,
  setLengthRight,
  isHexString,
  stripHexPrefix,
  toBuffer,
  bufferToHex,
  keccak
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>eth-eip712-util-browser",file:"node_modules\\eth-eip712-util-browser\\util.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\base-filter-history.js", {"./base-filter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\base-filter.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5Cbase-filter-history.js
      return function (require, module, exports) {
const BaseFilter = require('./base-filter')

// tracks all results ever recorded
class BaseFilterWithHistory extends BaseFilter {

  constructor () {
    super()
    this.allResults = []
  }

  async update () {
    throw new Error('BaseFilterWithHistory - no update method specified')
  }

  addResults (newResults) {
    this.allResults = this.allResults.concat(newResults)
    super.addResults(newResults)
  }

  addInitialResults (newResults) {
    this.allResults = this.allResults.concat(newResults)
    super.addInitialResults(newResults)
  }

  getAllResults () {
    return this.allResults
  }

}

module.exports = BaseFilterWithHistory
      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\base-filter-history.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\base-filter.js", {"@metamask/safe-event-emitter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5Cbase-filter.js
      return function (require, module, exports) {
const SafeEventEmitter = require('@metamask/safe-event-emitter').default

class BaseFilter extends SafeEventEmitter {

  constructor () {
    super()
    this.updates = []
  }

  async initialize () {}

  async update () {
    throw new Error('BaseFilter - no update method specified')
  }

  addResults (newResults) {
    this.updates = this.updates.concat(newResults)
    newResults.forEach(result => this.emit('update', result))
  }

  addInitialResults (newResults) {}

  getChangesAndClear () {
    const updates = this.updates
    this.updates = []
    return updates
  }
  
}

module.exports = BaseFilter

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\base-filter.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\block-filter.js", {"./base-filter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\base-filter.js","./getBlocksForRange":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\getBlocksForRange.js","./hexUtils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\hexUtils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5Cblock-filter.js
      return function (require, module, exports) {
const BaseFilter = require('./base-filter')
const getBlocksForRange = require('./getBlocksForRange')
const { incrementHexInt } = require('./hexUtils')

class BlockFilter extends BaseFilter {

  constructor ({ provider, params }) {
    super()
    this.type = 'block'
    this.provider = provider
  }

  async update ({ oldBlock, newBlock }) {
    const toBlock = newBlock
    const fromBlock = incrementHexInt(oldBlock)
    const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock })
    const blockHashes = blockBodies.map((block) => block.hash)
    this.addResults(blockHashes)
  }

}

module.exports = BlockFilter

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\block-filter.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\getBlocksForRange.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5CgetBlocksForRange.js
      return function (require, module, exports) {
module.exports = getBlocksForRange

async function getBlocksForRange({ provider, fromBlock, toBlock }) {
  if (!fromBlock) fromBlock = toBlock

  const fromBlockNumber = hexToInt(fromBlock)
  const toBlockNumber = hexToInt(toBlock)
  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1
  // load all blocks from old to new (inclusive)
  const missingBlockNumbers = Array(blockCountToQuery).fill()
                              .map((_,index) => fromBlockNumber + index)
                              .map(intToHex)
  let blockBodies = await Promise.all(
    missingBlockNumbers.map(blockNum => query(provider, 'eth_getBlockByNumber', [blockNum, false]))
  )
  blockBodies = blockBodies.filter(block => block !== null);
  return blockBodies
}

function hexToInt(hexString) {
  if (hexString === undefined || hexString === null) return hexString
  return Number.parseInt(hexString, 16)
}

function incrementHexInt(hexString){
  if (hexString === undefined || hexString === null) return hexString
  const value = hexToInt(hexString)
  return intToHex(value + 1)
}

function intToHex(int) {
  if (int === undefined || int === null) return int
  const hexString = int.toString(16)
  return '0x' + hexString
}

function sendAsync(provider, request) {
  return new Promise((resolve, reject) => {
    provider.sendAsync(request, (error, response) => {
      if (error) {
        reject(error);
      } else if (response.error) {
        reject(response.error);
      } else if (response.result) {
        resolve(response.result);
      } else {
        reject(new Error("Result was empty"));
      }
    });
  });
}

async function query(provider, method, params) {
  for (let i = 0; i < 3; i++) {
    try {
      return await sendAsync(provider, {
        id: 1,
        jsonrpc: "2.0",
        method,
        params,
      });
    } catch (error) {
      console.error(
        `provider.sendAsync failed: ${error.stack || error.message || error}`
      );
    }
  }
  return null;
}

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\getBlocksForRange.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\hexUtils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5ChexUtils.js
      return function (require, module, exports) {

module.exports = {
  minBlockRef,
  maxBlockRef,
  sortBlockRefs,
  bnToHex,
  blockRefIsNumber,
  hexToInt,
  incrementHexInt,
  intToHex,
  unsafeRandomBytes,
}

function minBlockRef(...refs) {
  const sortedRefs = sortBlockRefs(refs)
  return sortedRefs[0]
}

function maxBlockRef(...refs) {
  const sortedRefs = sortBlockRefs(refs)
  return sortedRefs[sortedRefs.length-1]
}

function sortBlockRefs(refs) {
  return refs.sort((refA, refB) => {
    if (refA === 'latest' || refB === 'earliest') return 1
    if (refB === 'latest' || refA === 'earliest') return -1
    return hexToInt(refA) - hexToInt(refB)
  })
}

function bnToHex(bn) {
  return '0x' + bn.toString(16)
}

function blockRefIsNumber(blockRef){
  return blockRef && !['earliest', 'latest', 'pending'].includes(blockRef)
}

function hexToInt(hexString) {
  if (hexString === undefined || hexString === null) return hexString
  return Number.parseInt(hexString, 16)
}

function incrementHexInt(hexString){
  if (hexString === undefined || hexString === null) return hexString
  const value = hexToInt(hexString)
  return intToHex(value + 1)
}

function intToHex(int) {
  if (int === undefined || int === null) return int
  let hexString = int.toString(16)
  const needsLeftPad = hexString.length % 2
  if (needsLeftPad) hexString = '0' + hexString
  return '0x' + hexString
}

function unsafeRandomBytes(byteCount) {
  let result = '0x'
  for (let i = 0; i < byteCount; i++) {
    result += unsafeRandomNibble()
    result += unsafeRandomNibble()
  }
  return result
}

function unsafeRandomNibble() {
  return Math.floor(Math.random() * 16).toString(16)
}

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\hexUtils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\index.js", {"./block-filter.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\block-filter.js","./hexUtils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\hexUtils.js","./log-filter.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\log-filter.js","./tx-filter.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\tx-filter.js","async-mutex":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5Cindex.js
      return function (require, module, exports) {
const Mutex = require('async-mutex').Mutex
const { createAsyncMiddleware, createScaffoldMiddleware } = require('json-rpc-engine')
const LogFilter = require('./log-filter.js')
const BlockFilter = require('./block-filter.js')
const TxFilter = require('./tx-filter.js')
const { intToHex, hexToInt } = require('./hexUtils')

module.exports = createEthFilterMiddleware

function createEthFilterMiddleware({ blockTracker, provider }) {

  // create filter collection
  let filterIndex = 0
  let filters = {}
  // create update mutex
  const mutex = new Mutex()
  const waitForFree = mutexMiddlewareWrapper({ mutex })

  const middleware = createScaffoldMiddleware({
    // install filters
    eth_newFilter:                   waitForFree(toFilterCreationMiddleware(newLogFilter)),
    eth_newBlockFilter:              waitForFree(toFilterCreationMiddleware(newBlockFilter)),
    eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
    // uninstall filters
    eth_uninstallFilter:             waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
    // checking filter changes
    eth_getFilterChanges:            waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
    eth_getFilterLogs:               waitForFree(toAsyncRpcMiddleware(getFilterLogs)),
  })

  // setup filter updating and destroy handler
  const filterUpdater = async ({ oldBlock, newBlock }) => {
    if (filters.length === 0) return
    // lock update reads
    const releaseLock = await mutex.acquire()
    try {
      // process all filters in parallel
      await Promise.all(objValues(filters).map(async (filter) => {
        try {
         await filter.update({ oldBlock, newBlock })
        } catch (err) {
          // handle each error individually so filter update errors don't affect other filters
          console.error(err)
        }
      }))
    } catch (err) {
      // log error so we don't skip the releaseLock
      console.error(err)
    }
    // unlock update reads
    releaseLock()
  }

  // expose filter methods directly
  middleware.newLogFilter = newLogFilter
  middleware.newBlockFilter = newBlockFilter
  middleware.newPendingTransactionFilter = newPendingTransactionFilter
  middleware.uninstallFilter = uninstallFilterHandler
  middleware.getFilterChanges = getFilterChanges
  middleware.getFilterLogs = getFilterLogs

  // expose destroy method for cleanup
  middleware.destroy = () => {
    uninstallAllFilters()
  }

  return middleware

  //
  // new filters
  //

  async function newLogFilter(params) {
    const filter = new LogFilter({ provider, params })
    const filterIndex = await installFilter(filter)
    return filter
  }

  async function newBlockFilter() {
    const filter = new BlockFilter({ provider })
    const filterIndex = await installFilter(filter)
    return filter
  }

  async function newPendingTransactionFilter() {
    const filter = new TxFilter({ provider })
    const filterIndex = await installFilter(filter)
    return filter
  }

  //
  // get filter changes
  //

  async function getFilterChanges(filterIndexHex) {
    const filterIndex = hexToInt(filterIndexHex)
    const filter = filters[filterIndex]
    if (!filter) {
      throw new Error(`No filter for index "${filterIndex}"`)
    }
    const results = filter.getChangesAndClear()
    return results
  }

  async function getFilterLogs(filterIndexHex) {
    const filterIndex = hexToInt(filterIndexHex)
    const filter = filters[filterIndex]
    if (!filter) {
      throw new Error(`No filter for index "${filterIndex}"`)
    }
    // only return results for log filters
    let results = []
    if (filter.type === 'log') {
      results = filter.getAllResults()
    }
    return results
  }


  //
  // remove filters
  //


  async function uninstallFilterHandler(filterIndexHex) {
    // check filter exists
    const filterIndex = hexToInt(filterIndexHex)
    const filter = filters[filterIndex]
    const result = Boolean(filter)
    // uninstall filter
    if (result) {
      await uninstallFilter(filterIndex)
    }
    return result
  }

  //
  // utils
  //

  async function installFilter(filter) {
    const prevFilterCount = objValues(filters).length
    // install filter
    const currentBlock = await blockTracker.getLatestBlock()
    await filter.initialize({ currentBlock })
    filterIndex++
    filters[filterIndex] = filter
    filter.id = filterIndex
    filter.idHex = intToHex(filterIndex)
    // update block tracker subs
    const newFilterCount = objValues(filters).length
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount })
    return filterIndex
  }

  async function uninstallFilter(filterIndex) {
    const prevFilterCount = objValues(filters).length
    delete filters[filterIndex]
    // update block tracker subs
    const newFilterCount = objValues(filters).length
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount })
  }

  async function uninstallAllFilters() {
    const prevFilterCount = objValues(filters).length
    filters = {}
    // update block tracker subs
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 })
  }

  function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
    // subscribe
    if (prevFilterCount === 0 && newFilterCount > 0) {
      blockTracker.on('sync', filterUpdater)
      return
    }
    // unsubscribe
    if (prevFilterCount > 0 && newFilterCount === 0) {
      blockTracker.removeListener('sync', filterUpdater)
      return
    }
  }

}

// helper for turning filter constructors into rpc middleware
function toFilterCreationMiddleware(createFilterFn) {
  return toAsyncRpcMiddleware(async (...args) => {
    const filter = await createFilterFn(...args)
    const result = intToHex(filter.id)
    return result
  })
}

// helper for pulling out req.params and setting res.result
function toAsyncRpcMiddleware(asyncFn) {
  return createAsyncMiddleware(async (req, res) => {
    const result = await asyncFn.apply(null, req.params)
    res.result = result
  })
}

function mutexMiddlewareWrapper({ mutex }) {
  return (middleware) => {
    return async (req, res, next, end) => {
      // wait for mutex available
      // we can release immediately because
      // we just need to make sure updates aren't active
      const releaseLock = await mutex.acquire()
      releaseLock()
      middleware(req, res, next, end)
    }
  }
}

function objValues(obj, fn){
  const values = []
  for (let key in obj) {
    values.push(obj[key])
  }
  return values
}

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\log-filter.js", {"./base-filter-history":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\base-filter-history.js","./hexUtils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\hexUtils.js","eth-query":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-query\\index.js","pify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5Clog-filter.js
      return function (require, module, exports) {
const EthQuery = require('eth-query')
const pify = require('pify')
const BaseFilterWithHistory = require('./base-filter-history')
const { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require('./hexUtils')

class LogFilter extends BaseFilterWithHistory {

  constructor ({ provider, params }) {
    super()
    this.type = 'log'
    this.ethQuery = new EthQuery(provider)
    this.params = Object.assign({
      fromBlock: 'latest',
      toBlock: 'latest',
      address: undefined,
      topics: [],
    }, params)
    // normalize address parameter
    if (this.params.address) {
      // ensure array
      if (!Array.isArray(this.params.address)) {
        this.params.address = [this.params.address]
      }
      // ensure lowercase
      this.params.address = this.params.address.map(address => address.toLowerCase())
    }
  }

  async initialize({ currentBlock }) {
    // resolve params.fromBlock
    let fromBlock = this.params.fromBlock
    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock
    if ('earliest' === fromBlock) fromBlock = '0x0'
    this.params.fromBlock = fromBlock
    // set toBlock for initial lookup
    const toBlock = minBlockRef(this.params.toBlock, currentBlock)
    const params = Object.assign({}, this.params, { toBlock })
    // fetch logs and add to results
    const newLogs = await this._fetchLogs(params)
    this.addInitialResults(newLogs)
  }

  async update ({ oldBlock, newBlock }) {
    // configure params for this update
    const toBlock = newBlock
    let fromBlock
    // oldBlock is empty on first sync
    if (oldBlock) {
      fromBlock = incrementHexInt(oldBlock)
    } else {
      fromBlock = newBlock
    }
    // fetch logs
    const params = Object.assign({}, this.params, { fromBlock, toBlock })
    const newLogs = await this._fetchLogs(params)
    const matchingLogs = newLogs.filter(log => this.matchLog(log))

    // add to results
    this.addResults(matchingLogs)
  }

  async _fetchLogs (params) {
    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))()
    // add to results
    return newLogs
  }

  matchLog(log) {
    // check if block number in bounds:
    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false
    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false

    // address is correct:
    const normalizedLogAddress = log.address && log.address.toLowerCase()
    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false

    // topics match:
    // topics are position-dependant
    // topics can be nested to represent `or` [[a || b], c]
    // topics can be null, representing a wild card for that position
    const topicsMatch = this.params.topics.every((topicPattern, index) => {
      // pattern is longer than actual topics
      let logTopic = log.topics[index]
      if (!logTopic) return false
      logTopic = logTopic.toLowerCase()
      // normalize subTopics
      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]
      // check for wild card
      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null)
      if (subtopicsIncludeWildcard) return true
      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase())
      // check each possible matching topic
      const topicDoesMatch = subtopicsToMatch.includes(logTopic)
      return topicDoesMatch
    })

    return topicsMatch
  }

}

module.exports = LogFilter

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\log-filter.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\subscriptionManager.js", {"./getBlocksForRange.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\getBlocksForRange.js","./hexUtils.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\hexUtils.js","./index.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\index.js","@metamask/safe-event-emitter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js","json-rpc-engine":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5CsubscriptionManager.js
      return function (require, module, exports) {
const SafeEventEmitter = require('@metamask/safe-event-emitter').default
const { createAsyncMiddleware, createScaffoldMiddleware } = require('json-rpc-engine')
const createFilterMiddleware = require('./index.js')
const { unsafeRandomBytes, incrementHexInt } = require('./hexUtils.js')
const getBlocksForRange = require('./getBlocksForRange.js')

module.exports = createSubscriptionMiddleware


function createSubscriptionMiddleware({ blockTracker, provider }) {
  // state and utilities for handling subscriptions
  const subscriptions = {}
  const filterManager = createFilterMiddleware({ blockTracker, provider })

  // internal flag
  let isDestroyed = false

  // create subscriptionManager api object
  const events = new SafeEventEmitter()
  const middleware = createScaffoldMiddleware({
    eth_subscribe: createAsyncMiddleware(subscribe),
    eth_unsubscribe: createAsyncMiddleware(unsubscribe),
  })
  middleware.destroy = destroy
  return { events, middleware }

  async function subscribe(req, res) {

    if (isDestroyed) throw new Error(
      'SubscriptionManager - attempting to use after destroying'
    )

    const subscriptionType = req.params[0]
    // subId is 16 byte hex string
    const subId = unsafeRandomBytes(16)

    // create sub
    let sub
    switch (subscriptionType) {
      case 'newHeads':
        sub = createSubNewHeads({ subId })
        break
      case 'logs':
        const filterParams = req.params[1]
        const filter = await filterManager.newLogFilter(filterParams)
        sub = createSubFromFilter({ subId, filter })
        break
      default:
        throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`)

    }
    subscriptions[subId] = sub

    res.result = subId
    return

    function createSubNewHeads({ subId }) {
      const sub = {
        type: subscriptionType,
        destroy: async () => {
          blockTracker.removeListener('sync', sub.update)
        },
        update: async ({ oldBlock, newBlock }) => {
          // for newHeads
          const toBlock = newBlock
          const fromBlock = incrementHexInt(oldBlock)
          const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock })
          const results = rawBlocks.map(normalizeBlock).filter(block => block !== null)
          results.forEach((value) => {
            _emitSubscriptionResult(subId, value)
          })
        }
      }
      // check for subscription updates on new block
      blockTracker.on('sync', sub.update)
      return sub
    }

    function createSubFromFilter({ subId, filter }) {
      filter.on('update', result => _emitSubscriptionResult(subId, result))
      const sub = {
        type: subscriptionType,
        destroy: async () => {
          return await filterManager.uninstallFilter(filter.idHex)
        },
      }
      return sub
    }
  }

  async function unsubscribe(req, res) {

    if (isDestroyed) throw new Error(
      'SubscriptionManager - attempting to use after destroying'
    )

    const id = req.params[0]
    const subscription = subscriptions[id]
    // if missing, return "false" to indicate it was not removed
    if (!subscription) {
      res.result = false
      return
    }
    // cleanup subscription
    delete subscriptions[id]
    await subscription.destroy()
    res.result = true
  }

  function _emitSubscriptionResult(filterIdHex, value) {
    events.emit('notification', {
      jsonrpc: '2.0',
      method: 'eth_subscription',
      params: {
        subscription: filterIdHex,
        result: value,
      },
    })
  }

  function destroy() {
    events.removeAllListeners()
    for (const id in subscriptions) {
      subscriptions[id].destroy()
      delete subscriptions[id]
    }
    isDestroyed = true
  }
}

function normalizeBlock(block) {
  if (block === null || block === undefined) {
    return null;
  }
  return {
    hash: block.hash,
    parentHash: block.parentHash,
    sha3Uncles: block.sha3Uncles,
    miner: block.miner,
    stateRoot: block.stateRoot,
    transactionsRoot: block.transactionsRoot,
    receiptsRoot: block.receiptsRoot,
    logsBloom: block.logsBloom,
    difficulty: block.difficulty,
    number: block.number,
    gasLimit: block.gasLimit,
    gasUsed: block.gasUsed,
    nonce: block.nonce,
    mixHash: block.mixHash,
    timestamp: block.timestamp,
    extraData: block.extraData,
  }
}

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\subscriptionManager.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\tx-filter.js", {"./base-filter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\base-filter.js","./getBlocksForRange":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\getBlocksForRange.js","./hexUtils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-json-rpc-filters\\hexUtils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-json-rpc-filters%5Ctx-filter.js
      return function (require, module, exports) {
const BaseFilter = require('./base-filter')
const getBlocksForRange = require('./getBlocksForRange')
const { incrementHexInt } = require('./hexUtils')

class TxFilter extends BaseFilter {

  constructor ({ provider }) {
    super()
    this.type = 'tx'
    this.provider = provider
  }

  async update ({ oldBlock }) {
    const toBlock = oldBlock
    const fromBlock = incrementHexInt(oldBlock)
    const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock })
    const blockTxHashes = []
    for (const block of blocks) {
      blockTxHashes.push(...block.transactions)
    }
    // add to results
    this.addResults(blockTxHashes)
  }

}

module.exports = TxFilter

      };
    };
  }
  }
}, {package:"eth-json-rpc-filters",file:"node_modules\\eth-json-rpc-filters\\tx-filter.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-lattice-keyring\\index.js", {"@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-lattice-keyring\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","crypto":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\crypto-browserify\\index.js","events":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","gridplus-sdk":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-lattice-keyring\\node_modules\\rlp\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-lattice-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const crypto = require('crypto');
const EventEmitter = require('events').EventEmitter;
const BN = require('bn.js');
const SDK = require('gridplus-sdk');
const EthTx = require('@ethereumjs/tx');
const { addHexPrefix } = require("@ethereumjs/util");
const rlp = require('rlp');
const keyringType = 'Lattice Hardware';
const HARDENED_OFFSET = 0x80000000;
const PER_PAGE = 5;
const CLOSE_CODE = -1000;
const STANDARD_HD_PATH = `m/44'/60'/0'/0/x`;
const SDK_TIMEOUT = 120000;
const CONNECT_TIMEOUT = 20000;

class LatticeKeyring extends EventEmitter {
  constructor (opts={}) {
    super()
    this.type = keyringType;
    this._resetDefaults();
    this.deserialize(opts);
  }

  //-------------------------------------------------------------------
  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)
  //-------------------------------------------------------------------
  async deserialize (opts = {}) {
    if (opts.hdPath)
      this.hdPath = opts.hdPath;
    if (opts.creds)
      this.creds = opts.creds;
    if (opts.accounts)
      this.accounts = opts.accounts;
    if (opts.accountIndices)
      this.accountIndices = opts.accountIndices;
    if (opts.accountOpts)
      this.accountOpts = opts.accountOpts;
    if (opts.walletUID)
      this.walletUID = opts.walletUID;
    if (opts.name)  // Legacy; use is deprecated and appName is more descriptive
      this.appName = opts.name;
    if (opts.appName)
      this.appName = opts.appName;
    if (opts.network)
      this.network = opts.network;
    if (opts.page)
      this.page = opts.page;
    return;
  }

  setHdPath(hdPath) {
    this.hdPath = hdPath;
  }

  async serialize() {
    return {
      creds: this.creds,
      accounts: this.accounts,
      accountIndices: this.accountIndices,
      accountOpts: this.accountOpts,
      walletUID: this.walletUID,
      appName: this.appName,
      name: this.name,  // Legacy; use is deprecated
      network: this.network,
      page: this.page,
      hdPath: this.hdPath,
    };
  }

  // Deterimine if we have a connection to the Lattice and an existing wallet UID
  // against which to make requests.
  isUnlocked () {
    return !!this._getCurrentWalletUID() && !!this.sdkSession;
  }

  // Initialize a session with the Lattice1 device using the GridPlus SDK
  // NOTE: `bypassOnStateData=true` allows us to rehydrate a new SDK session without
  // reconnecting to the target Lattice. This is only currently used for signing
  // because it eliminates the need for 2 connection requests and shaves off ~4-6sec.
  // We avoid passing `bypassOnStateData=true` for other calls on `unlock` to avoid
  // possible edge cases related to this new functionality (it's probably fine - just
  // being cautious). In the future we may remove `bypassOnStateData` entirely.
  async unlock (bypassOnStateData = false) {
    if (this.isUnlocked()) {
      return "Unlocked";
    }
    const creds = await this._getCreds();
    if (creds) {
      this.creds.deviceID = creds.deviceID;
      this.creds.password = creds.password;
      this.creds.endpoint = creds.endpoint || null;
    }
    const includedStateData = await this._initSession();
    // If state data was provided and if we are authorized to
    // bypass reconnecting, we can exit here.
    if (includedStateData && bypassOnStateData) {
      return "Unlocked";
    }
    await this._connect();
    return "Unlocked";
  }

  // Add addresses to the local store and return the full result
  async addAccounts(n=1) {
    if (n <= 0) {
      // Avoid non-positive numbers.
      throw new Error(
        'Number of accounts to add must be a positive number.'
      );
    }
    // Normal behavior: establish the connection and fetch addresses.
    await this.unlock()
    const addrs = await this._fetchAddresses(n, this.unlockedAccount);
    const walletUID = this._getCurrentWalletUID();
    if (!walletUID) {
      // We should not add accounts that do not have wallet UIDs.
      // Something went wrong and needs to be retried.
      await this._connect();
      throw new Error('No active wallet found in Lattice. Please retry.');
    }
    // Add these indices
    addrs.forEach((addr, i) => {
      let alreadySaved = false;
      for (let j = 0; j < this.accounts.length; j++) {
        if ((this.accounts[j] === addr) &&
            (this.accountOpts[j].walletUID === walletUID) &&
            (this.accountOpts[j].hdPath === this.hdPath))
          alreadySaved = true;
      }
      if (!alreadySaved) {
        this.accounts.push(addr);
        this.accountIndices.push(this.unlockedAccount+i);
        this.accountOpts.push({
          walletUID,
          hdPath: this.hdPath,
        })
      }
    })
    return this.accounts;
  }

  // Return the local store of addresses. This gets called when the extension unlocks.
  async getAccounts() {
    return this.accounts ? [...this.accounts] : [];
  }

  async signTransaction (address, tx) {
    let signedTx, v;
    // We will be adding a signature to hydration data for a new
    // transaction object since the sig data is not mutable.
    // Setup `txToReturn` data and start adding to it.
    const txToReturn = tx.toJSON();
    txToReturn.type = tx._type || null;
    // Setup info related to signer account
    const accountIdx = await this._findSignerIdx(address);
    const chainId = getTxChainId(tx).toNumber();
    const fwVersion = this.sdkSession.getFwVersion();
    const addressIdx = this.accountIndices[accountIdx];
    const { hdPath } = this.accountOpts[accountIdx];
    const signerPath = this._getHDPathIndices(hdPath, addressIdx);
    // Lattice firmware v0.11.0 implemented EIP1559 and EIP2930
    // We should throw an error if we cannot support this.
    if (fwVersion.major === 0 && fwVersion.minor <= 11) {
      throw new Error('Please update Lattice firmware.');
    }
    // Build the signing request
    if (fwVersion.major > 0 || fwVersion.minor >= 15) {
      // Newer firmware versions support an easier pathway
      const data = {
        // Legacy transactions return tx params. Newer transactions
        // return the raw, serialized transaction
        payload:  tx._type ?
                  tx.getMessageToSign(false) :
                  rlp.encode(tx.getMessageToSign(false)),
        curveType: SDK.Constants.SIGNING.CURVES.SECP256K1,
        hashType: SDK.Constants.SIGNING.HASHES.KECCAK256,
        encodingType: SDK.Constants.SIGNING.ENCODINGS.EVM,
        signerPath,
      };
      const supportsDecoderRecursion = fwVersion.major > 0 || fwVersion.minor >=16;
      // Check if we can decode the calldata
      const { def } = await SDK.Utils.fetchCalldataDecoder(tx.data, tx.to, chainId, supportsDecoderRecursion);
      if (def) {
        data.decoder = def;
      }
      // Send the request
      signedTx = await this.sdkSession.sign({ data });
    } else {
      // Older firmware versions (<0.15.0) use the legacy signing pathway.
      const data = getLegacyTxReq(tx);
      data.chainId = chainId;
      data.signerPath = signerPath;
      signedTx = await this.sdkSession.sign({ currency: 'ETH', data });
    }
    // Ensure we got a signature back
    if (!signedTx.sig || !signedTx.sig.r || !signedTx.sig.s) {
      throw new Error('No signature returned.');
    }
    // Construct the `v` signature param
    if (signedTx.sig.v === undefined) {
      // V2 signature needs `v` calculated
      v = SDK.Utils.getV(tx, signedTx);
    } else {
      // Legacy signatures have `v` in the response
      v = signedTx.sig.v.length === 0 ? '0' : signedTx.sig.v.toString('hex')
    }

    // Pack the signature into the return object
    txToReturn.r = addHexPrefix(signedTx.sig.r.toString('hex'));
    txToReturn.s = addHexPrefix(signedTx.sig.s.toString('hex'));
    txToReturn.v = addHexPrefix(v);

    // Make sure the active wallet is correct to avoid returning
    // a signature from an unexpected signer.
    const foundIdx = await this._accountIdxInCurrentWallet(address);
    if (foundIdx === null) {
      throw new Error(
        'Wrong account. Please change your Lattice wallet or ' +
        'switch to an account on your current active wallet.'
      );
    }
    return EthTx.TransactionFactory.fromTxData(txToReturn, {
      common: tx.common, freeze: Object.isFrozen(tx)
    })
  }

  async signPersonalMessage(address, msg) {
    return this.signMessage(address, { payload: msg, protocol: 'signPersonal' });
  }

  async signTypedData(address, msg, opts) {
    if (opts.version && (opts.version !== 'V4' && opts.version !== 'V3')) {
      throw new Error(
        `Only signTypedData V3 and V4 messages (EIP712) are supported. Got version ${opts.version}`
      );
    }
    return this.signMessage(address, { payload: msg, protocol: 'eip712' })
  }

  async signMessage (address, msg) {
    const accountIdx = await this._findSignerIdx(address);
    let { payload, protocol } = msg;
    // If the message is not an object we assume it is a legacy signPersonal request
    if (!payload || !protocol) {
      payload = msg;
      protocol = "signPersonal";
    }
    const addressIdx = this.accountIndices[accountIdx];
    const addressParentPath = this.accountOpts[accountIdx].hdPath;
    const req = {
      currency: "ETH_MSG",
      data: {
        protocol,
        payload,
        signerPath: this._getHDPathIndices(addressParentPath, addressIdx),
      },
    };
    const res = await this.sdkSession.sign(req);
    if (!res.sig) {
      throw new Error("No signature returned");
    }
    // Convert the `v` to a number. It should convert to 0 or 1
    let v;
    try {
      v = res.sig.v.toString("hex");
      if (v.length < 2) {
        v = `0${v}`;
      }
    } catch (err) {
      throw new Error("Invalid signature format returned.");
    }
    // Make sure the active wallet is correct to avoid returning
    // a signature from an unexpected signer.
    const foundIdx = await this._accountIdxInCurrentWallet(address);
    if (foundIdx === null) {
      throw new Error(
        'Wrong account. Please change your Lattice wallet or ' +
        'switch to an account on your current active wallet.'
      );
    }
    // Return the sig string
    return `0x${res.sig.r}${res.sig.s}${v}`;
  }

  async exportAccount(address) {
    throw new Error('exportAccount not supported by this device');
  }

  removeAccount(address) {
    this.accounts.forEach((account, i) => {
      if (account.toLowerCase() === address.toLowerCase()) {
        this.accounts.splice(i, 1);
        this.accountIndices.splice(i, 1);
        this.accountOpts.splice(i, 1);
        return;
      }
    })
  }

  async getFirstPage() {
    this.page = 0;
    return this._getPage(0);
  }

  async getNextPage () {
    return this._getPage(1);
  }

  async getPreviousPage () {
    return this._getPage(-1);
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  forgetDevice () {
    this._resetDefaults();
  }

  //-------------------------------------------------------------------
  // Internal methods and interface to SDK
  //-------------------------------------------------------------------
  // Find the account index of the requested address.
  // Note that this is the BIP39 path index, not the index in the address cache.
  async _findSignerIdx (address) {
    // Take note if this was already unlocked
    const wasUnlocked = this.isUnlocked();
    // Unlock and get the wallet UID. We will bypass the reconnection
    // step if we are able to rehydrate an SDK session with state data.
    await this.unlock(true);
    let accountIdx = await this._accountIdxInCurrentWallet(address);
    if (accountIdx !== null) {
      return accountIdx;
    }
    // If this was unlocked already, the `this.unlock` call did not sync
    // data with the Lattice. We should force a sync by reconnecting.
    if (wasUnlocked) {
      await this._connect();
      // Check the new wallet and see if there is a match
      accountIdx = await this._accountIdxInCurrentWallet(address);
      if (accountIdx !== null) {
        return accountIdx;
      }
    }
    // If we could not find a match, exit here
    throw new Error(
      "Account not found in active Lattice wallet. Please switch."
    );
  }

  async _accountIdxInCurrentWallet(address) {
    // Get the wallet UID associated with the signer and make sure
    // the Lattice has that as its active wallet before continuing.
    const accountIdx = await this._findAccountByAddress(address);
    const { walletUID } = this.accountOpts[accountIdx];
    // Get the last updated SDK wallet UID
    const activeWallet = this.sdkSession.getActiveWallet();
    if (!activeWallet) {
      this._connect();
      throw new Error("No active wallet in Lattice.");
    }
    const activeUID = activeWallet.uid.toString("hex");
    // If this is already the active wallet we don't need to make a request
    if (walletUID.toString("hex") === activeUID) {
      return accountIdx;
    }
    return null;
  }

  async _findAccountByAddress(address) {
    const addrs = await this.getAccounts();
    let accountIdx = -1;
    addrs.forEach((addr, i) => {
      if (address.toLowerCase() === addr.toLowerCase())
        accountIdx = i;
    })
    if (accountIdx < 0) {
      throw new Error('Signer not present');
    }
    return accountIdx;
  }

  _getHDPathIndices(hdPath, insertIdx=0) {
    const path = hdPath.split('/').slice(1);
    const indices = [];
    let usedX = false;
    path.forEach((_idx) => {
      const isHardened = (_idx[_idx.length - 1] === "'");
      let idx = isHardened ? HARDENED_OFFSET : 0;
      // If there is an `x` in the path string, we will use it to insert our
      // index. This is useful for e.g. Ledger Live path. Most paths have the
      // changing index as the last one, so having an `x` in the path isn't
      // usually necessary.
      if (_idx.indexOf('x') > -1) {
        idx += insertIdx;
        usedX = true;
      } else if (isHardened) {
        idx += Number(_idx.slice(0, _idx.length - 1));
      } else {
        idx += Number(_idx);
      }
      indices.push(idx);
    })
    // If this path string does not include an `x`, we just append the index
    // to the end of the extracted set
    if (usedX === false) {
      indices.push(insertIdx);
    }
    // Sanity check -- Lattice firmware will throw an error for large paths
    if (indices.length > 5)
      throw new Error('Only HD paths with up to 5 indices are allowed.')
    return indices;
  }

  _resetDefaults() {
    this.accounts = [];
    this.accountIndices = [];
    this.accountOpts = [];
    this.isLocked = true;
    this.creds = {
      deviceID: null,
      password: null,
      endpoint: null,
    };
    this.walletUID = null;
    this.sdkSession = null;
    this.page = 0;
    this.unlockedAccount = 0;
    this.network = null;
    this.hdPath = STANDARD_HD_PATH;
  }

  async _openConnectorTab(url) {
    try {
      const browserTab = window.open(url);
      // Preferred option for Chromium browsers. This extension runs in a window
      // for Chromium so we can do window-based communication very easily.
      if (browserTab) {
        return { chromium: browserTab };
      } else if (browser && browser.tabs && browser.tabs.create) {
        // FireFox extensions do not run in windows, so it will return `null` from
        // `window.open`. Instead, we need to use the `browser` API to open a tab.
        // We will surveille this tab to see if its URL parameters change, which
        // will indicate that the user has logged in.
        const tab = await browser.tabs.create({url})
        return { firefox: tab };
      } else {
        throw new Error('Unknown browser context. Cannot open Lattice connector.');
      }
    } catch (err) {
      throw new Error('Failed to open Lattice connector.');
    }
  }

  async _findTabById(id) {
    const tabs = await browser.tabs.query({});
    return tabs.find((tab) => tab.id === id);
  }

  _getCreds() {
    return new Promise((resolve, reject) => {
      // We only need to setup if we don't have a deviceID
      if (this._hasCreds())
        return resolve();
      // If we are not aware of what Lattice we should be talking to,
      // we need to open a window that lets the user go through the
      // pairing or connection process.
      const name = this.appName ? this.appName : 'Unknown'
      const base = 'https://lattice.gridplus.io';
      const url = `${base}?keyring=${name}&forceLogin=true`;
      let listenInterval;

      // PostMessage handler
      function receiveMessage(event) {
        // Ensure origin
        if (event.origin !== base)
          return;
        try {
          // Stop the listener
          clearInterval(listenInterval);
          // Parse and return creds
          const creds = JSON.parse(event.data);
          if (!creds.deviceID || !creds.password)
            return reject(new Error('Invalid credentials returned from Lattice.'));
          return resolve(creds);
        } catch (err) {
          return reject(err);
        }
      }

      // Open the tab
      this._openConnectorTab(url)
      .then((conn) => {
        if (conn.chromium) {
          // On a Chromium browser we can just listen for a window message
          window.addEventListener("message", receiveMessage, false);
          // Watch for the open window closing before creds are sent back
          listenInterval = setInterval(() => {
            if (conn.chromium.closed) {
              clearInterval(listenInterval);
              return reject(new Error('Lattice connector closed.'));
            }
          }, 500);
        } else if (conn.firefox) {
          // For Firefox we cannot use `window` in the extension and can't
          // directly communicate with the tabs very easily so we use a
          // workaround: listen for changes to the URL, which will contain
          // the login info.
          // NOTE: This will only work if have `https://lattice.gridplus.io/*`
          // host permissions in your manifest file (and also `activeTab` permission)
          const loginUrlParam = '&loginCache=';
          listenInterval = setInterval(() => {
            this._findTabById(conn.firefox.id)
            .then((tab) => {
              if (!tab || !tab.url) {
                return reject(new Error('Lattice connector closed.'));
              }
              // If the tab we opened contains a new URL param
              const paramLoc = tab.url.indexOf(loginUrlParam);
              if (paramLoc < 0)
                return;
              const dataLoc = paramLoc + loginUrlParam.length;
              // Stop this interval
              clearInterval(listenInterval);
              try {
                // Parse the login data. It is a stringified JSON object
                // encoded as a base64 string.
                const _creds = Buffer.from(tab.url.slice(dataLoc), 'base64').toString();
                // Close the tab and return the credentials
                browser.tabs.remove(tab.id)
                .then(() => {
                  const creds = JSON.parse(_creds);
                  if (!creds.deviceID || !creds.password)
                    return reject(new Error('Invalid credentials returned from Lattice.'));
                  return resolve(creds);
                })
              } catch (err) {
                return reject('Failed to get login data from Lattice. Please try again.')
              }
            })
          }, 500);
        }
      })
    })
  }

  // [re]connect to the Lattice. This should be done frequently to ensure
  // the expected wallet UID is still the one active in the Lattice.
  // This will handle SafeCard insertion/removal events.
  async _connect () {
    try {
      // Attempt to connect with a Lattice using a shorter timeout. If
      // the device is unplugged it will time out and we don't need to wait
      // 2 minutes for that to happen.
      this.sdkSession.timeout = CONNECT_TIMEOUT;
      return this.sdkSession.connect(this.creds.deviceID)
    } finally {
      // Reset to normal timeout no matter what
      this.sdkSession.timeout = SDK_TIMEOUT;
    }
  }

  async _initSession() {
    if (this.isUnlocked()) {
      return;
    }
    let url = 'https://signing.gridpl.us';
    if (this.creds.endpoint)
      url = this.creds.endpoint
    let setupData = {
      name: this.appName,
      baseUrl: url,
      timeout: SDK_TIMEOUT,
      privKey: this._genSessionKey(),
      network: this.network,
      skipRetryOnWrongWallet: true,
    };
    /*
    NOTE: We need state to actually be synced by MetaMask or we can't
    use this. See: https://github.com/MetaMask/KeyringController/issues/130

    if (this.sdkState) {
      // If we have state data we can fully rehydrate the session.
      setupData = {
        stateData: this.sdkState,
        skipRetryOnWrongWallet: true,
      }
    }
    */
    this.sdkSession = new SDK.Client(setupData);
    // Return a boolean indicating whether we provided state data.
    // If we have, we can skip `connect`.
    return !!setupData.stateData;
  }

  async _fetchAddresses(n=1, i=0, recursedAddrs=[]) {
    if (!this.isUnlocked()) {
      throw new Error('No connection to Lattice. Cannot fetch addresses.')
    }
    return this.__fetchAddresses(n, i);
  }

  async __fetchAddresses(n=1, i=0, recursedAddrs=[]) {
    // Determine if we need to do a recursive call here. We prefer not to
    // because they will be much slower, but Ledger paths require it since
    // they are non-standard.
    if (n === 0) {
      return recursedAddrs;
    }
    const shouldRecurse = this._hdPathHasInternalVarIdx();

    // Make the request to get the requested address
    const addrData = {
      currency: 'ETH',
      startPath: this._getHDPathIndices(this.hdPath, i),
      n: shouldRecurse ? 1 : n,
    };
    const addrs = await this.sdkSession.getAddresses(addrData);
    // Sanity check -- if this returned 0 addresses, handle the error
    if (addrs.length < 1) {
      throw new Error('No addresses returned');
    }
    // Return the addresses we fetched *without* updating state
    if (shouldRecurse) {
      return await this.__fetchAddresses(n-1, i+1, recursedAddrs.concat(addrs));
    }
    return addrs;
  }

  async _getPage(increment=0) {
    try {
      this.page += increment;
      if (this.page < 0)
        this.page = 0;
      const start = PER_PAGE * this.page;
      // Otherwise unlock the device and fetch more addresses
      await this.unlock()
      const addrs = await this._fetchAddresses(PER_PAGE, start)
      const accounts = addrs.map((address, i) => {
        return {
          address,
          balance: null,
          index: start + i,
        };
      });
      return accounts;
    } catch (err) {
      // This will get hit for a few reasons. Here are two possibilities:
      // 1. The user has a SafeCard inserted, but not unlocked
      // 2. The user fetched a page for a different wallet, then switched
      //    interface on the device
      // In either event we should try to resync the wallet and if that
      // fails throw an error
      try {
        const isPaired = await this._connect();
        if (!isPaired) {
          throw new Error('NOT_PAIRED');
        }
        const accounts = await this._getPage(0);
        return accounts;
      } catch (err) {
        if (this.accounts.length === 0){
          this.forgetDevice();
        }
        throw new Error(
          'Failed to get accounts. Please forget the device and try again. ' +
          'Make sure you do not have a locked SafeCard inserted.'
        );
      }
    }
  }

  _hasCreds() {
    return this.creds.deviceID !== null && this.creds.password !== null && this.appName;
  }

  _genSessionKey() {
    if (this.name && !this.appName) // Migrate from legacy param if needed
      this.appName = this.name;
    if (!this._hasCreds())
      throw new Error('No credentials -- cannot create session key!');
    const buf = Buffer.concat([
      Buffer.from(this.creds.password),
      Buffer.from(this.creds.deviceID),
      Buffer.from(this.appName)
    ])
    return crypto.createHash('sha256').update(buf).digest();
  }

  // Determine if an HD path has a variable index internal to it.
  // e.g. m/44'/60'/x'/0/0 -> true, while m/44'/60'/0'/0/x -> false
  // This is just a hacky helper to avoid having to recursively call for non-ledger
  // derivation paths. Ledger is SO ANNOYING TO SUPPORT.
  _hdPathHasInternalVarIdx() {
    const path = this.hdPath.split('/').slice(1);
    for (let i = 0; i < path.length -1; i++) {
      if (path[i].indexOf('x') > -1)
        return true;
    }
    return false;
  }

  _getCurrentWalletUID() {
    if (!this.sdkSession) {
      return null;
    }
    const activeWallet = this.sdkSession.getActiveWallet();
    if (!activeWallet || !activeWallet.uid) {
      return null;
    }
    return activeWallet.uid.toString('hex');
  }
}

// -----
// HELPERS
// -----
function getTxChainId (tx) {
  if (tx && tx.common && typeof tx.common.chainIdBN === 'function') {
    return tx.common.chainIdBN();
  } else if (tx && tx.chainId) {
    return new BN(tx.chainId);
  }
  return new BN(1);
}

// Legacy versions of Lattice firmware signed ETH transactions out of
// a now deprecated pathway. The request data is built by this helper.
function getLegacyTxReq (tx) {
  let txData;
  try {
    txData = {
      nonce: `0x${tx.nonce.toString('hex')}` || 0,
      gasLimit: `0x${tx.gasLimit.toString('hex')}`,
      to: !!tx.to ? tx.to.toString('hex') : null, // null for contract deployments
      value: `0x${tx.value.toString('hex')}`,
      data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,
    }
    switch (tx._type) {
      case 2: // eip1559
        if ((tx.maxPriorityFeePerGas === null || tx.maxFeePerGas === null) ||
            (tx.maxPriorityFeePerGas === undefined || tx.maxFeePerGas === undefined))
          throw new Error('`maxPriorityFeePerGas` and `maxFeePerGas` must be included for EIP1559 transactions.');
        txData.maxPriorityFeePerGas = `0x${tx.maxPriorityFeePerGas.toString('hex')}`;
        txData.maxFeePerGas = `0x${tx.maxFeePerGas.toString('hex')}`;
        txData.accessList = tx.accessList || [];
        txData.type = 2;
        break;
      case 1: // eip2930
        txData.accessList = tx.accessList || [];
        txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;
        txData.type = 1;
        break;
      default: // legacy
        txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;
        txData.type = null;
        break;
    }
  } catch (err) {
    throw new Error(`Failed to build transaction.`)
  }
  return txData;
}

async function httpRequest (url) {
  const resp = await window.fetch(url);
  if (resp.ok) {
    return await resp.text();
  } else {
    throw new Error('Failed to make request: ', resp.status);
  }
}

LatticeKeyring.type = keyringType
module.exports = LatticeKeyring;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring",file:"node_modules\\eth-lattice-keyring\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-lattice-keyring\\node_modules\\bn.js\\lib\\bn.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-lattice-keyring%5Cnode_modules%5Cbn.js%5Clib%5Cbn.js
      return function (require, module, exports) {
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>bn.js",file:"node_modules\\eth-lattice-keyring\\node_modules\\bn.js\\lib\\bn.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-lattice-keyring\\node_modules\\rlp\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-lattice-keyring%5Cnode_modules%5Crlp%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.decode = exports.encode = void 0;
/**
 * RLP Encoding based on https://eth.wiki/en/fundamentals/rlp
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        const buf = concatBytes(...output);
        return concatBytes(encodeLength(buf.length, 192), buf);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
exports.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
exports.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
exports.utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes,
};
const RLP = { encode, decode };
exports.default = RLP;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>rlp",file:"node_modules\\eth-lattice-keyring\\node_modules\\rlp\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-phishing-detect\\src\\config.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-phishing-detect%5Csrc%5Cconfig.json
      return function (require, module, exports) {
module.exports={
  "version": 2,
  "tolerance": 2,
  "fuzzylist": [
    "auctus.org",
    "cryptokitties.co",
    "dfinity.org",
    "launchpad.ethereum.org",
    "etherscan.io",
    "fulcrum.trade",
    "hederahashgraph.com",
    "localcryptos.com",
    "localethereum.com",
    "makerfoundation.com",
    "maskmeta.org",
    "metamask.io",
    "myetherwallet.com",
    "opensea.io",
    "originprotocol.com"
  ],
  "whitelist": [
    "auctic.net",
    "metavas.com",
    "openwear.pl",
    "aftus.io",
    "opendem.info",
    "peansea.store",
    "ifinty.nl",
    "artus.com",
    "aukus.fr",
    "fulcrumwp.com",
    "opensi.net",
    "xactus.com",
    "spenser.xyz",
    "openscad.cloud",
    "opende.fi",
    "sushiguard.com",
    "sushirelay.com",
    "sushi.com",
    "metarank.ai",
    "vultus.one",
    "klimadao.finance",
    "9finite.com",
    "opengem.com",
    "infinity.exchange",
    "otterscan.io",
    "olympusdao.finance",
    "bifinity.com",
    "effinity.fr",
    "opensend.com",
    "app.cryptoblades.io",
    "auctusiq.com",
    "artblocks.io",
    "finite.io",
    "lasmeta.io",
    "actum.dk",
    "actum.games",
    "actum.gr",
    "actyus.com",
    "metapass.cloud",
    "metamarz.com",
    "metamarz.io",
    "opensfx.com",
    "msmeta.fun",
    "metamap.com",
    "metamars.org",
    "metamars.ai",
    "metadash.ai",
    "sanctus.audio",
    "affinity.ad",
    "affinity.ro",
    "affinity.solutions",
    "actis.no",
    "actss.ca",
    "actus.at",
    "ajatus.in",
    "aptus.ai",
    "nfinit.com",
    "arcus.no",
    "arcteus.in",
    "fincity.sk",
    "askmenta.com",
    "astus.app",
    "aubtu.biz",
    "aubus.xyz",
    "aucu.es",
    "audius.io",
    "audius.party",
    "auktus.com",
    "aulus.org",
    "aulus.xyz",
    "autos.id",
    "autos.nu",
    "aureus.eu",
    "aureus.ltd",
    "aureus.money",
    "aurous.cl",
    "au.tts.ru",
    "avatus.com",
    "avinity.com",
    "aurous.finance",
    "befinity.media",
    "beta.ask.rip",
    "betatask.com",
    "bulurum.com",
    "cryptopatties.xyz",
    "definfty.io",
    "difinite.com",
    "dinify.io",
    "divinity.ca",
    "divinity.es",
    "doinita.art",
    "easymeta.fun",
    "revigo.fanclub.rocks",
    "finity.in",
    "finitty.com",
    "finityx.com",
    "fulcrum.ag",
    "fulcrum.org",
    "fulcrum7.com",
    "fulcrumtx.com",
    "fulpruf.com",
    "hugtus.com",
    "fvlcrvm.com",
    "futurum.cl",
    "futurum.software",
    "ifinity.ch",
    "cryptohotties.space",
    "cryptopities.com",
    "cryptotitties.xyz",
    "cutus.in",
    "metapass.ml",
    "open5e.com",
    "openbee.com",
    "openbeta.works",
    "openeo.cloud",
    "openeo.org",
    "openes.io",
    "openhead.info",
    "openmeta.city",
    "openmeta.finance",
    "openmeta.kr",
    "openmeta.trade",
    "openpoa.com",
    "opensig.org",
    "opensit.net",
    "openseas.com",
    "opensees.pro",
    "looksrare.org",
    "openmha.org",
    "openres.io",
    "openresa.com",
    "opensat.cc",
    "opensoc.pl",
    "openspa.info",
    "openweb.science",
    "openzeka.com",
    "openuba.org",
    "open.wa.link",
    "pulsechain.com",
    "pulseramp.com",
    "pulsex.com",
    "cactus.by",
    "cactus.cards",
    "cactus.gr",
    "cactus.store",
    "cactus.la",
    "cactus.sh",
    "ebinity.com",
    "flarum.it",
    "hoctus.win",
    "infinity.co",
    "infinity.fish",
    "infinity.group",
    "infinity.health",
    "infinity.irish",
    "infinity.nl",
    "infinity.re",
    "infinity.watch",
    "ipensa.com",
    "justus.fun",
    "justus.link",
    "kryptkitties.com",
    "openscad.info",
    "flarum.ir",
    "noctus.cc",
    "quatus.de",
    "ruckus.cloud",
    "ruckus.nl",
    "ruckus.one",
    "ruckus.studio",
    "fvlcrum.com",
    "openseas.gr",
    "lautus.net",
    "metacas.io",
    "magendao.com",
    "markmeta.finance",
    "masknet.net",
    "lectus.kr",
    "lucrum.digital",
    "lucrum.fund",
    "lucrum.pro",
    "lucrum.uk",
    "lucrum.vc",
    "lucrus.io",
    "metaease.com",
    "metaease.io",
    "metahack.games",
    "metajack.org",
    "maddmeta.com",
    "metamac.live",
    "metamail.ink",
    "metamark.lt",
    "metamars.capital",
    "metamars.com",
    "metamars.fr",
    "metamars.mx",
    "metamars.to",
    "metamart.space",
    "metamasu.com",
    "metamate.crypto",
    "metamate.game",
    "metamaxx.io",
    "metamese.com",
    "metamess.io",
    "metamilk.xyz",
    "metamuse.xyz",
    "metamk.com",
    "metamusk.eu",
    "metamusk.io",
    "meta-musk.com",
    "metamosa.io",
    "metaoak.com",
    "metaoak.xyz",
    "metapak.co",
    "metapak.io",
    "metapark.kr",
    "metapark.land",
    "metapass.world",
    "metalmark.xyz",
    "metasmas.com",
    "metatalk.id",
    "missmeta.world",
    "multus.media",
    "nfiniti.io",
    "nvinity.nl",
    "officialnft.xyz",
    "wpopensea.com",
    "open-ed.fyi",
    "openex.io",
    "opengear.tv",
    "openidea.lv",
    "openner.vc",
    "openspv.com",
    "opensrc.fans",
    "opensrc.finance",
    "opena.tv",
    "opener.pl",
    "open-e.com",
    "open-es.com",
    "opengee.org",
    "opengem.net",
    "opensea.institute",
    "opensea.ru",
    "opensenf.de",
    "opensera.com",
    "openset.co",
    "opensis.com",
    "opensky.blue",
    "opensky.com",
    "opensky.es",
    "opensky.kr",
    "opensky.la",
    "openslo.com",
    "opensoc.io",
    "openspec.io",
    "openreal.one",
    "opentee.io",
    "eap.gr",
    "open.eap.gr",
    "ua.edu",
    "open.ua.edu",
    "dinitz.cz",
    "opengear.com",
    "openteam.community",
    "openipa.org",
    "opinsta.com",
    "opensc.org",
    "opensipa.it",
    "opensyr.com",
    "openset.com",
    "opensteak.com",
    "openscan.eu",
    "openswan.org",
    "affinity.locus",
    "opendev.at",
    "opendev.org",
    "openei.org",
    "opensee.io",
    "openlca.org",
    "openra.net",
    "opentca.co",
    "open-sec.com",
    "odense.dk",
    "openzeta.io",
    "spense.nl",
    "spense.no",
    "metamsp.com",
    "factus.io",
    "openme.com",
    "opendei.eu",
    "metacase.pt",
    "openia.ae",
    "opener.aero",
    "opendex.network",
    "openpa.net",
    "punctus.org",
    "openges.es",
    "metamade.io",
    "metamade.xyz",
    "metabase.build",
    "openstf.io",
    "opentek.eu",
    "open.ga.gov",
    "opensfm.org",
    "altus.finance",
    "infinity.xyz",
    "upfinity.xyz",
    "www.openrec.tv",
    "opensky.finance",
    "opensbr.org",
    "openka.net",
    "openbet.com",
    "openscad.org",
    "openssl.org",
    "openme.gl",
    "openmeta.foundation",
    "openssh.com",
    "opengra.com",
    "opengra.it",
    "openbisea.io",
    "openbisea.com",
    "openssf.org",
    "opennet.ru",
    "openslr.org",
    "openstax.org",
    "openweb.systems",
    "opensrs.com",
    "openweb.com",
    "openweb.onl",
    "oulrum.com",
    "tuctuc.com",
    "ynfinity.es",
    "finty.com",
    "opensea.io",
    "pensec.no",
    "altus.cr",
    "altus.education",
    "altus.digital",
    "altus.one",
    "altus.global",
    "atus.ch",
    "pxinity.com",
    "vcinity.io",
    "vcinity.org",
    "vcinity.com",
    "nfinita.com",
    "nfinita.io",
    "nfinita.org",
    "spi.club",
    "stakespi.com",
    "aucto.com",
    "deficity.tech",
    "deficity.app",
    "arfinity.io",
    "cactus.tools",
    "cactus.bm",
    "ascetus.com",
    "mynetherwallet.io",
    "metamasks.com",
    "metacask.com",
    "metacask.io",
    "efinity.io",
    "finite.ltd",
    "auus.cloud",
    "masternodes.online",
    "myetpwallet.com",
    "fulcrum.rocks",
    "mycrpro.com",
    "openmev.org",
    "openmev.net",
    "openmev.com",
    "openmev.xyz",
    "openswap.io",
    "openswap.one",
    "openswap.tech",
    "openswap.xyz",
    "ycryptos.com",
    "mrcrypto.space",
    "mrcrypto.me",
    "ethscan.org",
    "crypto.museum",
    "qtcrypto.com",
    "dcrypto.io",
    "drcrypto.io",
    "decrypto.in",
    "mycryptonx.com",
    "m3crypto.online",
    "dcrypto.net",
    "msncrypto.com",
    "incrypto.pl",
    "crypto.market",
    "j-crypto.com",
    "scrypto.digital",
    "pmicrypto.ml",
    "mecrypto.club",
    "mdxcrypto.com",
    "launchpad.ethereum.org",
    "enledger.io",
    "crypto.tt",
    "badger.finance",
    "enledger.com",
    "ledgerx.com",
    "ledgerql.com",
    "fulcrum.wiki",
    "aptus.hr",
    "aptus.life",
    "edge.network",
    "actius.mx",
    "ipledger.co",
    "auctim.com",
    "fulcrumep.com",
    "definity.network",
    "ledger.com",
    "wax.community",
    "flarum.org",
    "qiswap.com",
    "decrypto.finance",
    "uniswap.eth",
    "crypto.co",
    "anyswap.exchange",
    "anyswap.network",
    "miniswap.org",
    "anyswap.org",
    "anyswap.info",
    "anyswap.market",
    "anyswap.net",
    "uniswap.ch",
    "uniswap.io",
    "uniswap.ninja",
    "unisocks.exchange",
    "unipig.exchange",
    "uniswap.vision",
    "uniswap.info",
    "uniswap.org",
    "uniswap.exchange",
    "uniswapex.io",
    "umtswap.finance",
    "auctia.io",
    "sgcrypto.info",
    "mr-crypto.net",
    "morcrypto.net",
    "dfinite.org",
    "decrypto.org",
    "mracrypto.com",
    "etinity.net",
    "crypto.games",
    "crypto-games.net",
    "crypto.ro",
    "buycrypto.info",
    "basic.international",
    "actua.ca",
    "bultus.nl",
    "oai.io",
    "pass.org",
    "yasiv.com",
    "tasks.org",
    "audus.net",
    "osris.org",
    "otis.is",
    "oris.ch",
    "oaks.rent",
    "oxis.org",
    "navis.io",
    "sfoasis.com",
    "saxis.dk",
    "marsis.tv",
    "oss.kr",
    "casio.com",
    "pais.center",
    "uchus.online",
    "patis.com",
    "osi.es",
    "tasos.co",
    "pass.camp",
    "asics.com",
    "omsi.edu",
    "vultus.io",
    "kosis.kr",
    "paris.cl",
    "parsis.agency",
    "apis.guru",
    "asi.lv",
    "pasts.lv",
    "oesir.com",
    "avis.ca",
    "oess.de",
    "horasis.org",
    "oazis.hu",
    "zapis.kz",
    "nadis.jp",
    "osif.org",
    "omnis.com",
    "fass.se",
    "tass.ru",
    "sis.pt",
    "3asi.es",
    "iasia.co",
    "okasi.me",
    "wasi.dev",
    "nosis.com",
    "odasie.fr",
    "orvis.com",
    "ovis.news",
    "orasio.org",
    "asos.fr",
    "basic.finance",
    "vanis.io",
    "avis.com",
    "axis.li",
    "nafis.co",
    "trinity.art",
    "trinity.design",
    "trinity.edu",
    "trinity.global",
    "trinity.jp",
    "trinity.moe",
    "trinity.one",
    "trinity.org",
    "trinity.pw",
    "trinity.tech",
    "axis.com",
    "oasa.co",
    "apis.zone",
    "otris.de",
    "stasis.network",
    "nais.io",
    "arctis.at",
    "atc.us.es",
    "tasit.io",
    "fasio.biz",
    "fasio.org",
    "fasio.net",
    "fasio.yokohama",
    "canis.xyz",
    "oeis.org",
    "paris.fr",
    "basic.net",
    "asus.com",
    "gsis.gr",
    "asos.com",
    "orbis.pl",
    "stasis.net",
    "stasis.foundation",
    "ofsys.com",
    "acrypto.nl",
    "gesis.org",
    "orasis.tech",
    "basic.fail",
    "apis.mn",
    "asic.to",
    "kalis.me",
    "mass.gov",
    "stakerdao.com",
    "oasis.fish",
    "makerpad.co",
    "vk.com",
    "alis.to",
    "groasis.investments",
    "msn.com",
    "ok.ru",
    "makerfoundation.com",
    "oasis.app",
    "mkr.tools",
    "mlcrypt.de",
    "buycrypto.work",
    "metamail.app",
    "finite.games",
    "decrypto.fr",
    "dfini.com",
    "daddys-digest.sadek.usermd.net",
    "damii.usermd.net",
    "imagine.usermd.net",
    "krr.usermd.net",
    "prezenty.tomu.usermd.net",
    "etherscams.io",
    "strzelcu.usermd.net",
    "icrypto.media",
    "ryecrypto.com",
    "crypto.gy",
    "pmpcrypto.com",
    "ejcrypto.com",
    "bccrypto.club",
    "crypto.law",
    "socrypto.io",
    "crypto.tax",
    "okcrypto.com",
    "acts.ca",
    "edfinity.com",
    "therascan.info",
    "wifinity.es",
    "nfinity.com",
    "ways.16mb.com",
    "aucta.io",
    "findity.se",
    "dexinity.com",
    "etherscan.com",
    "arttus.net",
    "arttus.art",
    "crypto.garden",
    "kactus.com",
    "decrypto.com.ar",
    "decrypto.la",
    "etherscan.kr",
    "updog.co",
    "cryptotittiez.com",
    "paycrypto.com",
    "trcrypto.live",
    "act4s.com",
    "ecrypto.shop",
    "auths.eu",
    "finits.org",
    "mifinity.com",
    "cryptonities.com",
    "crypto.center",
    "autos.deals",
    "abcrypto.co",
    "gcrypto.media",
    "paycrypto.tech",
    "metamesh.com",
    "cactus.app",
    "lucius.fr",
    "lucius.nl",
    "crypto.casa",
    "socrypto.app",
    "gocrypto.com",
    "becrypto.co",
    "etherstat.io",
    "arcus.org",
    "arcus.finance",
    "ubtus.com",
    "metahash.tools",
    "metatalk.io",
    "metatalk.org",
    "mrcrypto.xyz",
    "fixity.io",
    "mycrypto.guide",
    "affinity.id",
    "mrcrypto.cc",
    "binance.net",
    "binance.cloud",
    "binance.vision",
    "infinity.cm",
    "sccrypto.net",
    "crypto.ie",
    "tkcrypto.com",
    "eufinity.com",
    "idcrypto.fr",
    "divinity.clothing",
    "crypto.cards",
    "encrypto.art",
    "crypto.express",
    "crypto.airforce",
    "accrypto.io",
    "ohmycrypto.news",
    "aureus.cl",
    "audius.de",
    "ethplode.org",
    "sfcrypto.co",
    "alytus.lt",
    "nbcrypto.eu",
    "arctos.capital",
    "incrypto.trade",
    "skycrypto.io",
    "crypto.men",
    "etherean.io",
    "affinity.pt",
    "infinity.family",
    "metamesh.life",
    "metamesh.online",
    "metamesh.co",
    "crypto.business",
    "aetherwallet.io",
    "icon.community",
    "ethercap.com",
    "ncrypto.sale",
    "scrypto.capital",
    "scrypto.mt",
    "lzcrypto.net",
    "ezycrypto.net",
    "vultus.se",
    "akitus.com",
    "buycrypto.today",
    "coindesk-email.com",
    "buycrypto.gr",
    "atfinity.io",
    "atfinity.ch",
    "atfinity.de",
    "atfinity.at",
    "atfinity.swiss",
    "atfinity.sg",
    "atfinity.fr",
    "atfinity.li",
    "atfinity.co.uk",
    "atfinity.info",
    "atfinity.app",
    "atfinitytest.me",
    "finity.ch",
    "infinity.reviews",
    "betanet.quantstamp.com",
    "modcrypto.online",
    "crypto.ad",
    "ctus.io",
    "f5crypto.com",
    "crypto.direct",
    "ruckus.org",
    "justus.co",
    "dignity.cf",
    "arctur.si",
    "becrypto.fund",
    "lucius.digital",
    "binance.co",
    "xcrypto.in",
    "lucus.io",
    "xfinite.io",
    "xfinite.xyz",
    "infinity.money",
    "crypto.xyz",
    "crypto.holdings",
    "crypto.directory",
    "bucrypto.co",
    "mitcrypto.tech",
    "sydcrypto.com",
    "gocrypto.bet",
    "scrypto.club",
    "victus.gg",
    "victus.finance",
    "mycryptoro.com",
    "infinity.black",
    "nactus.com",
    "crypto.tn",
    "autum.com",
    "alictus.com",
    "justus.pw",
    "etherman.app",
    "ducatus.net",
    "eitherscan.com",
    "dmunity.com",
    "cryptokitties.city",
    "etherkan.com",
    "aicrypto.io",
    "autos.ca",
    "acatus.com",
    "pcrypto.io",
    "metacash.gg",
    "metacash.online",
    "metacash.it",
    "aptus.aero",
    "odinity.com",
    "buycrypto.guide",
    "metalmas.com",
    "vafinity.com",
    "mycryp.to",
    "cryptokittiesvr.co",
    "token.usermd.net",
    "dbcrypto.io",
    "ethercat.org",
    "bestrate.org",
    "msgcrypto.com",
    "vethorscan.io",
    "mykrypto.io",
    "trycrypto.net",
    "trycrypto.com",
    "atatus.com",
    "acuitus.com",
    "tradingview.com",
    "coinmarketcap.com",
    "crypto.fm",
    "crypto.ru",
    "x-crypto.com",
    "mycrypto.store",
    "etherwan.com",
    "etherean.com",
    "etherean.org",
    "cactus.tv",
    "victus.be",
    "crypto.gratis",
    "crypto.markets",
    "metamath.org",
    "crypto.schule",
    "cactus.lu",
    "arctus.io",
    "lecrypto.club",
    "aicrypto.blog",
    "jmcrypto.org",
    "tactus.dk",
    "tactus.nl",
    "auctus.com",
    "avotus.com",
    "mycrypto.guru",
    "cultus.com",
    "actas.club",
    "crypto.tube",
    "aureus.nl",
    "crypto.ca",
    "fallin.rf.gd",
    "adcrypto.io",
    "wbored2.usermd.net",
    "gocrypto.dk",
    "etherscape.io",
    "mlbcrypto.io",
    "secrypto.io",
    "acus.gov",
    "cryptonia-dash.bitballoon.com",
    "ecrypto.ro",
    "cofinity.net",
    "crypto.farm",
    "crypto.radio",
    "arcrypto.xyz",
    "l-crypto.com",
    "aptus.de",
    "crypto.study",
    "crypto.work",
    "etherical.io",
    "arcus.city",
    "w2crypto.com",
    "criptokitties.it",
    "crypto.kg",
    "buycrypto.ca",
    "cactus.is",
    "apc-us.com",
    "usonline.apc.fr",
    "fructus.io",
    "cactus.vision",
    "incrypto.io",
    "actis.nl",
    "nem-dns.bitballoon.com",
    "ethersat.io",
    "sanctus.io",
    "smbr.rf.gd",
    "mocrypto.io",
    "mycryptos.io",
    "affinity.help",
    "originprotocol.com",
    "kactus.io",
    "apttus.com",
    "aptus.be",
    "ethen.market",
    "encrypto.site",
    "encrypto.website",
    "crypto.one",
    "crypto.fashion",
    "megamark.fr",
    "apptus.cloud",
    "apptus.com",
    "aucxis.gr",
    "crypto.ch",
    "etherplan.com",
    "octus.network",
    "underwear-leaderboard.bitballoon.com",
    "midcrypto.com",
    "meratask.com",
    "arhash.xyz",
    "quantstamp.com",
    "app.quantstamp.com",
    "tacrypto.net",
    "hopeful-poitras-654e5a.bitballoon.com",
    "actum.online",
    "iunctus.io",
    "efinity.com",
    "bccrypto.org",
    "mtkrypto.de",
    "adoring-booth-276e15.bitballoon.com",
    "actux.com",
    "abcrypto.nl",
    "abchus.no",
    "gocrypto.tools",
    "crypto.eu",
    "auditus.cc",
    "divinity.game",
    "aditus.net",
    "amatus.com",
    "aureus.aero",
    "aginity.com",
    "aurus.io",
    "afiniti.com",
    "actu.fr",
    "nuclus.co",
    "nuclus.io",
    "auctus.org",
    "ncrypto.io",
    "dfinery.com",
    "hederahashgraph.com",
    "mycrypto.education",
    "metamesh.io",
    "crypto.by",
    "mycrypto.toys",
    "hkcrypto.com",
    "crypto.deals",
    "crypto.quebec",
    "crypto.dance",
    "vncrypto.info",
    "crypto.ms",
    "ncrypto.com",
    "mrcrypto.dk",
    "nedfinity.com",
    "affinity.me",
    "crypto.cat",
    "winity.io",
    "gfinity.net",
    "mycryptons.com",
    "aicrypto.ai",
    "azcrypto.net",
    "crypto.com",
    "crypto.org",
    "affinity.photography",
    "abcrypto.info",
    "ucrypto.net",
    "vscrypto.com",
    "affinity.com",
    "affinity.co",
    "upfinity.io",
    "crypto.news",
    "dbcrypto.com",
    "ezcrypto.guide",
    "gocrypto.me",
    "finity.ai",
    "weffkemining.com",
    "nwcrypto.com",
    "cobinhood.com",
    "affinity.vc",
    "metahusk.com",
    "mrcrypto.fr",
    "affinity.store",
    "affinity.serif.com",
    "xfinity.com",
    "dfinity.org",
    "mycrypto.website",
    "pqcrypto.org",
    "z-crypto.com",
    "mpcrypo.com",
    "localethereum.com",
    "localcryptos.com",
    "localbitcoins.com",
    "huobipro.com",
    "ncrypto.tech",
    "9crypto.co",
    "netmask.hu",
    "cryptokittens.club",
    "rucrypto.com",
    "cryptocities.world",
    "crypto.press",
    "becrypto.xyz",
    "hicrypto.io",
    "crypto.nl",
    "zycrypto.com",
    "mmcrypto.io",
    "mycrypter.com",
    "crypto.tickets",
    "crypto.pro",
    "ocrypto.org",
    "wecrypto.net",
    "iccrypto.io",
    "crypto.kred",
    "ohmycrypto.io",
    "zzcrypto.org",
    "crypto.bg",
    "mycrypto24.online",
    "acrypto.io",
    "mycrypto.ca",
    "scrypto.io",
    "mycrypto.dk",
    "mvzcrypto.com",
    "ambcrypto.com",
    "crypto.bi",
    "crypto.jobs",
    "crypto.help",
    "my.crypt.observer",
    "crypt.observer",
    "ucrypto.com",
    "cryptojobslist.com",
    "crypto.review",
    "crypto.me",
    "mycrypto.ninja",
    "jkcrypto.com",
    "crypto.cr",
    "mycrypto.live",
    "yocrypto.io",
    "crypto.ba",
    "zacrypto.info",
    "mycrypto.com",
    "remix.ethereum.org",
    "metahash.io",
    "metahash.net",
    "metahash.org",
    "cryptotitties.com",
    "cryptocities.net",
    "cryptoshitties.co",
    "cryptotitties.fun",
    "cryptokitties.forsale",
    "cryptokitties.care",
    "metamate.cc",
    "metamate.io",
    "metamate.com",
    "metamate.one",
    "metamate.xyz",
    "metamesh.tech",
    "ico.nexus.social",
    "metamesh.org",
    "metatask.io",
    "metmask.com",
    "metarasa.com",
    "metapack.com",
    "metacase.com",
    "metafas.nl",
    "metamako.com",
    "metamast.com",
    "metamax.ru",
    "metadesk.club",
    "metadesk.io",
    "metadesk.run",
    "metadisk.com",
    "metallsk.ru",
    "metamag.fr",
    "metamaks.ru",
    "metamaps.cc",
    "metamaps.co",
    "metamaps.dev",
    "metamaps.land",
    "metamats.com",
    "metamax.by",
    "metamax.com",
    "metamax.io",
    "metamuse.io",
    "metamuse.net",
    "metamaze.eu",
    "metamaze.world",
    "metarank.com",
    "metaxas.com",
    "megamas2.ru",
    "metamask.io",
    "myetherwallet.com",
    "ethereum.org",
    "myetheroll.com",
    "myetherapi.com",
    "ledgerwallet.com",
    "databrokerdao.com",
    "etherscan.io",
    "etherid.org",
    "ether.cards",
    "etheroll.com",
    "ethnews.com",
    "ethex.market",
    "ethereumdev.io",
    "ethereumdev.kr",
    "dether.io",
    "ethermine.org",
    "slaask.com",
    "etherbtc.io",
    "ethereal.capital",
    "etherisc.com",
    "etherecho.com",
    "ethereum.os.tc",
    "theethereum.wiki",
    "metajack.im",
    "etherhub.io",
    "ethereum.network",
    "ethereum.link",
    "ethereum.com",
    "prethereum.org",
    "ethereumj.io",
    "etheraus.com",
    "ethereum.dev",
    "1ethereum.ru",
    "ethereum.nz",
    "nethereum.com",
    "metabank.com",
    "metamas.com",
    "aventus.io",
    "etherdelta.com",
    "cryptokitties.co",
    "remme.io",
    "jibrel.network",
    "twinity.com",
    "metabase.art",
    "metabase.com",
    "metabase.cc",
    "metabase.one",
    "metabase.network",
    "metabase.studio",
    "metabase.gg",
    "decrypto.net",
    "audius.co",
    "audius.org",
    "audius.app",
    "verasity.io",
    "orionprotocol.io",
    "etherspin.co",
    "actua.ad",
    "aditus.io",
    "cass.ad",
    "nabis.com",
    "fscrypto.co",
    "divinity.ai",
    "fulcrum.trade",
    "torque.loans",
    "oneswap.net",
    "ducatus.com",
    "hedget.com",
    "ladder.to",
    "app.tornado.cash",
    "coinbased.xyz",
    "askzeta.com",
    "fulcra.design",
    "fulcra.io",
    "axle.design",
    "cactus.chat",
    "nfinity.space",
    "catctus.io",
    "caucus.so",
    "exinity.com",
    "markeeta.sk",
    "markeeta.cz",
    "cryptoknitties.io",
    "factus.ru",
    "etherscene.com",
    "metamash.co",
    "metamash.io",
    "cactus.black",
    "amatus.capital",
    "nfinite.app",
    "nfinite.in",
    "fructus.xyz",
    "fructus.co",
    "lifinity.io",
    "metadash.app",
    "openkey.dev",
    "openseal.ch",
    "metadusk.io",
    "metabase.finance",
    "metamarc.io",
    "metapass.fyi",
    "roco.finance",
    "arceus.gg",
    "openrep.foundation",
    "esa.int",
    "open.esa.int",
    "darkmeta.xyz",
    "everscan.io"
  ],
  "blacklist": [
    "azukishop.live",
    "etherealart.nfts-mints.com",
    "nfts-mints.com",
    "moonbirds.tv",
    "moonbirds.gifts",
    "free-azuki.com",
    "nft-moonbirds.net",
    "cryptolaunchs.webflow.io",
    "bscbnb.vip",
    "dappsnftconnect.netlify.app",
    "nftswhitelistdapps.weebly.com",
    "ethtokens.xyz",
    "illuviumc.com",
    "smartwalletsystem.com",
    "multi-entitychainprotocol.link",
    "veefreends.com",
    "defiuni.network",
    "tgovx-conn.com",
    "defikingdoms-play.com",
    "webserversnetwork.com",
    "dapp-airdrops.io",
    "officialapynodes.online",
    "illuiumx.com",
    "block-sync.live",
    "criatixinfotech.com",
    "defi-kjingdooms.com",
    "pooccoin-app.tk",
    "minitabe.com",
    "autoreconnect.com",
    "authenticdapp.net",
    "bakeryswaperes.org",
    "collablandvalidate.com",
    "metmaskslogi.azurewebsites.net",
    "pinksale.zone",
    "dapp.accessactivation.com",
    "polygon-techologlesjord.com",
    "tekrollindustrial.com.br",
    "everdome.in",
    "authorizedapps.netlify.app",
    "mint-sandbox.app",
    "apps.moonebeam.network",
    "multi-chain.io",
    "trustpad-airdrops.com",
    "decenrtalend.com",
    "nodifyloop.online",
    "connectingauth.me",
    "cryptobaseconnect.com",
    "maincoinvault.com",
    "dapps-connects.live",
    "serversync.netlify.app",
    "itheum.network",
    "nanopassnft.co",
    "minting-cheap.com",
    "syncnftslink.live",
    "azukiairdrop.com",
    "biautwacomin.com",
    "authorizemywall.net",
    "ethpool365.com",
    "api.collab-land.ac",
    "azuki-beanz.com",
    "app.dapptokenvalidator.com",
    "vesunture.com",
    "walletnode.webflow.io",
    "chainsyncpermit.org",
    "metamaskapp.io",
    "defflklngdoms.com",
    "collablanq.cc",
    "covid19-sys.io",
    "gyariasy.fromsmash.com",
    "s.fastidious-mainet.com",
    "callabland.com",
    "eth-hummingbot.com",
    "decentralizedwep.com",
    "applovinstudios.com",
    "tokendappvalidator.com",
    "wallet-technology.in",
    "dappwalletauthentication.com",
    "supportwebdefi.com",
    "bggb.org",
    "somethingisbrewing.live",
    "invsblefriends-airdrop.io",
    "connectifydapps.net",
    "cryptoconnectbase.com",
    "assetaccess.site",
    "dappintegrator.com",
    "m.restoreweb.online",
    "aave.live",
    "bapetaverse-nft.co",
    "meta-information.io",
    "thesynchronizer.live",
    "yaaar.in",
    "mint-invisiblefriends.io",
    "silk.mint-launch.com",
    "syncc-collab.net",
    "yugalabs.and",
    "theprimeapeplanetnft.com",
    "omnisocietynft-mint.com",
    "unrollk.com",
    "imaginary-ones-nft.xyz",
    "dexlaunchpad.io",
    "theweirdos.yours-mints.com",
    "ueswap.cloud",
    "airdrop-trust.com",
    "store.boardapeyarhtclub.com",
    "worldofwomen-nft.art",
    "multichainsync.netlify.app",
    "opensea.cc",
    "airdrop-sphere.finance",
    "bnbfame.io",
    "bnbfur.io",
    "strongblockl.com",
    "azuki.claim",
    "alphakongs.co",
    "webserversnetworkss.com",
    "cryptoratefx.com",
    "joinmoon.net",
    "invisiblefriend-nft.com",
    "azuki-drop.com",
    "beanz-azuki.com",
    "azuki-airdrop.com",
    "synchronization-collab.land",
    "coindapps.webflow.io",
    "kycs-for-metalocation.live",
    "mint-mutantshib.club",
    "boredapeproject.com",
    "ammmine.cc",
    "ape-coin.claims",
    "dappsdefichain.com",
    "defi-aavev3.arab",
    "defi-aavev3.buzz",
    "defi-aavev3.info",
    "defi-aavev3.life",
    "defi-aavev3.live",
    "ape-coin.app",
    "willsmithinu.io",
    "akkswap.io",
    "primeapesnftmint.com",
    "realape-club.com",
    "syncnpay.com",
    "shirtum.fastmint.online",
    "apple.icoprimelist.com",
    "cross-chainbot.org",
    "pegasxy.net",
    "tronixdapp.com",
    "ygalaxy168.com",
    "minings.bet",
    "trustwallet.xiamicoin.top",
    "trx58168.com",
    "trustwalletdapp.vip",
    "dapp-collab.land",
    "defi.internationaltrc.com",
    "dpethmin.com",
    "validationfixswallets.org",
    "free-airdrop.com",
    "sostineskl.lt",
    "ericwaustin.com",
    "mayc.space",
    "rtfkt-giveaway.com",
    "apecoinclaimer.com",
    "othersidewl.com",
    "0army.io",
    "twfnft.shop",
    "lazymutantlion.com",
    "correctionweby.netlify.app",
    "app.importwallets.com",
    "presale.seesawprotocol.io",
    "mainnetdappwallets.com",
    "louisvuittonnfts.top",
    "tokenfix.net",
    "c0labland.com",
    "c0labland.io",
    "callabland.cc",
    "otp-metamask.io",
    "wallet-validation.netlify.app",
    "automaticdexsynchr.com",
    "cryptowalletconnector.com",
    "norddappverification.netlify.app",
    "solution-fix.online",
    "apecoin.events",
    "cerealentrepreneurs.academy",
    "verifiedmetanow.net",
    "dappintegrates.me",
    "dappsprotocols.tech",
    "authenticatedapps.org",
    "b0mbecrypt0.com",
    "ptt97.com",
    "smartpairing.net",
    "mint.alphadogs.run",
    "apescoin.online",
    "defi-aavev3.link",
    "eth-aave.org",
    "defi-aavev3.club",
    "coinbasecloud.club",
    "etoro.zone",
    "defi-aavev3.fun",
    "eth-panda.com",
    "defi-lp.biz",
    "defi-cloud.cloud",
    "eth-aave.xyz",
    "ammuni.shop",
    "usdt-ether.bet",
    "ape-coin.art",
    "colabconnect.land",
    "dappreauthenticate.org",
    "dapps-airdrops.io",
    "metamaskticket.com",
    "defi-ethu.me",
    "nftworibs.com",
    "metawizardsnft.mint-tool.com",
    "decetnral.guru",
    "maindappsconnect.org",
    "blokpadlaunch.com",
    "liquddriver.finance",
    "up1.org",
    "maycdao.io",
    "conneect-lannd.org",
    "app.defiserverprotocols.com",
    "planetape.co",
    "trillionairethugs.mintin.info",
    "apppolygon.net",
    "eth-coin.club",
    "connectswallets.webflow.io",
    "decentralizednonce.org",
    "live-nft-mint.com",
    "ape-coin.net",
    "pegaxy.pw",
    "pegax.yvte.com",
    "protocolsresolvesite.com",
    "metamask.io.web7615.web07.bero-webspace.de",
    "metamakrecovery2022.com",
    "c0llabland.com",
    "app.dinolland.io",
    "connectledgelive.com",
    "looksrare.news",
    "looksrare.fun",
    "looksrare.ong",
    "looksrare.ngo",
    "looksrore.org",
    "soullz.com",
    "tokeninfo.netlify.app",
    "landauth.me",
    "collaqland.cc",
    "web.connectassist.live",
    "opensea-gw.art",
    "apecoin.claims",
    "spacedoodles.org",
    "gamedefikindoms.com",
    "meta-application.xyz",
    "doodlesmint.com",
    "dpptest001-b6cba.web.app",
    "invisiblefriends-nft.co",
    "realapeclub.co",
    "e-cryptchains.com",
    "presale-metatriads.org",
    "daapkits.com",
    "ammmine.club",
    "ammmine.com",
    "ammmine.pro",
    "ammmine.info",
    "ammmine.org",
    "worldchain.online",
    "onlytransinterface.netlify.app",
    "connectwalletfix.com",
    "walletconnecthelpdesk.netlify.app",
    "securedprotocols.network",
    "bridgeprotocolfix.net",
    "validat0rdesk.com",
    "raritytools.online",
    "web3nodes.link",
    "wallet-dapps.site",
    "worldchains.online",
    "2rfle.com",
    "deficonnect.netlify.app",
    "appsyncpage.live",
    "walletvalidator.onrender.com",
    "dapp-sync.herokuapp.com",
    "trustpad.claims",
    "uni-defis.com",
    "verify-nftnow.com",
    "vaultrecitfication.com",
    "use-thesandbox.com",
    "mint-holyversenft.com",
    "cloud-eth.cc",
    "nftcollabpads.org",
    "muon-token.sale",
    "app.accessactivationbot.com",
    "iptsb.com.my",
    "supportmetamask.netjilify.app",
    "dex-airdrops.com",
    "coinresolve.com",
    "antonym.mintings.club",
    "cb-tti.com",
    "azuki.mintsecure.io",
    "azuki-mint.art",
    "dnodeconnect.com",
    "app.energybridge.io",
    "mainnetconnections.com",
    "voyagersunknownmint.com",
    "spinterslands.com",
    "pegaxy-1play.co",
    "mainnet-rectify.com",
    "defi-aavev3.tech",
    "stephero-event.com",
    "therudekidz.art",
    "swiftdappsco.online",
    "la.trrecoin.cc",
    "walletsecureval.com",
    "murakamiflowers-kaikaiikiki.com",
    "dexsolution.online",
    "connect.dapconnectlive.com",
    "walletconnect-verification.netlify.app",
    "defiearn-vip.co",
    "sanbdoxdefigame.space",
    "smartconnectdapp.online",
    "neutralprotocol.site",
    "apps.walletvalidatelive.com",
    "coinsolution.pw",
    "metamansionsnft-mint.com",
    "sneweasy.com",
    "usdt-ether.cc",
    "wallet-polygontechnolagy.co",
    "mint-mammeths.com",
    "maticforum.live",
    "polygon-bsc-bridge.com",
    "company-atomic.com",
    "daomaker.com.ms",
    "wallet-connect-meta.com",
    "wallet-meta-connec.com",
    "validationopensea.com",
    "mysecure-dnsserver.com",
    "2ombs.finance",
    "metamaskwebwallet.io",
    "metamask-mobile.io",
    "cyclicswitch.online",
    "metasafe.ddns.net",
    "apocalyptic-apes.co",
    "airdrop-trustpad.io",
    "invisibilfriends.com",
    "baycnftc.io",
    "esystemprotocols.com",
    "errorcorrections.com",
    "decertraland.org",
    "validwalletconnect.live",
    "metamask.io-nyzwnhya.ru",
    "voyager-unknown.com",
    "apocalypticapes.co",
    "defi.hy-eth.net",
    "polygn-tehnolegy.digital",
    "sendbaxgame.com",
    "collabland.bmifcu.services",
    "dappslink.org",
    "verifymetamask.io",
    "mm-support.io",
    "mm-renew.io",
    "mm-updates.io",
    "mm-update.io",
    "mm-recovery.io",
    "mm-aware.io",
    "mm-verify.io",
    "mm-web.io",
    "mm-alert.io",
    "metam-ask.io",
    "mm-service.io",
    "coolmansuniverse.xyz",
    "cosmiccats.io.swadexfi.online",
    "access-collab.land",
    "give-sea.com",
    "helpmetamask.online",
    "aneswap.com",
    "soulzznft.com",
    "fixerrorwallet.org",
    "walletinstantsolutions.weebly.com",
    "looksraredapp.live",
    "fixsupport.online",
    "new-collab.land",
    "dappssupport.co",
    "looksrqre.org",
    "thedapsauth.com",
    "syncrestore.me",
    "dappconnect.webflow.io",
    "dwintdapps.com",
    "walletconnect-synchronize.com",
    "alletbridges.com",
    "wallliveencrypt.com",
    "onlyintermeritapps.netlify.app",
    "mint-rainboyclub.com",
    "dappsint.com",
    "supportpages.org",
    "walletauthentications.us",
    "iancolemanvalidator.com",
    "souilz.com",
    "dappsnetwork.co",
    "cryptovalidator.org",
    "instantconnectsfixed.com",
    "collabvalidator.com",
    "walletapps.cloud",
    "recoverywallet.net",
    "dappsolvetech.org",
    "walletfix.dev",
    "short-process.app",
    "mainnetsupport.online",
    "nodesdapp.org",
    "speedbits.org",
    "dappstoolsconnects.com",
    "defiassetsync.com",
    "walletauth-dapps.org",
    "dappsforall.com",
    "brigeprotocol.link",
    "soulzminter.xyz",
    "device-authentication-dappsprotocol-mechanism.weebly.com",
    "walletconnects-sync.com",
    "mint-coolcatsnft.com",
    "metamask1.io",
    "c-01nftmint.com",
    "hapebeast-nft.io",
    "webconnectingwallets.net",
    "dapp.activationaccess.com",
    "fixconnect.click",
    "dapps-node.link",
    "chainprotocol.tools",
    "metamask-wallet-sync-103444.square.site",
    "moodyapeclub.app",
    "multibridgedapps.com",
    "dappslauncher.org",
    "collablandjoinholder.ukoffshoreaccounts.com",
    "xpubcalculators.com",
    "wallet-sync.herokuapp.com",
    "defierrorvalidator.com",
    "web-dappsconnect.net",
    "land.xn--6frz82g",
    "auth-connector.com",
    "dappwalletextension.com",
    "angryspitbullclub.com",
    "marketplace.thetansarena.com",
    "walleteauthorization.com",
    "inbetweners.com",
    "shibasocialsclub.com",
    "reauthenticator.online",
    "polygonchain.io",
    "dappsrader.com",
    "defiease.net",
    "dapnodescan.com",
    "mainnetnow.com",
    "soulz-nft.com",
    "walletchainsync.surge.sh",
    "defi-conects.com",
    "webauthdapps.com",
    "forumsmatic.network",
    "pinksalefinances.com",
    "xn--samurasaga-c9a.com",
    "vlaunch.online",
    "nonfungiblealliens.com",
    "clonex.rlfkt.com",
    "flippedbayc.club",
    "usdt-beestake.site",
    "theboredbunnies.com",
    "eth-coin.cc",
    "adidas-mint.net",
    "qrcunigen.com",
    "ethu2e.com",
    "theinvisiblefriends.io",
    "hypebearsclub.com",
    "cryptorepair.io",
    "web3nodes.network",
    "dappconnectwallet.web.app",
    "dappchainsconnect.com",
    "allnodedap.com",
    "backendweb.online",
    "sync-validation.com",
    "mainetintegration.com",
    "defiprotocols.one",
    "walletsauthy.webflow.io",
    "walletsync-dapps.com",
    "nodeverify.com",
    "onnectdapps.info",
    "dnode-link.co",
    "getactivewallet.netlify.app",
    "walletvalid.webflow.io",
    "swiftsyncs.io",
    "defi-appsolutions.com",
    "dappslivewalletsconnects.net",
    "dappsconn.com",
    "mainwalletauthorisation.net",
    "metawallet.com.travelplus.gr",
    "looksraresupport.org",
    "looik-rares.org",
    "looksralre.org",
    "looksrare.org.ua",
    "looksrares.org",
    "looksare.top",
    "liooksrare.com",
    "looksarare.org",
    "looksrarem.org",
    "looksarare.tech",
    "fixedvalidateswalleterrors.org",
    "syncwalletcloud.org",
    "smartdappwalletsconnect.com",
    "dappmobilesync.co",
    "importvalidator.com",
    "metamask2x.com",
    "dappsynsconnect.org",
    "metablack.software",
    "game-bombcripto-com.jcloud.kz",
    "thebigcats.art",
    "realapesclub.co",
    "collab-land.cx",
    "bored-ape.us",
    "rowdysociety.art",
    "luckylionclub.art",
    "decnetarland.org",
    "decnteraland.org",
    "bayc-nft.com",
    "thetronwars.art",
    "access-poocoinn.com",
    "metadata.io.tambooks.vn",
    "killergf.mintin.org",
    "officialmm.com",
    "metamask-xpubs.web.app",
    "mint-monsterapeclub.art",
    "verifymeta.net",
    "metasercon.com",
    "oldapecountryclub.store",
    "shiftersnft.io",
    "decnteraland.com",
    "supportmetamasks.netlify.app",
    "pdot.io",
    "pdot.app",
    "yetiswap.io",
    "mint-azuki.in",
    "mutantapesplanet.com",
    "synchronapps.com",
    "dapp-airdrop.com",
    "kittycryptogangofficial.com",
    "zone-sales.netlify.app",
    "app.opresale.com",
    "makerometa.org",
    "mint-adidas.app",
    "metannask-verification.com",
    "bapes.net",
    "eth-invest21.org",
    "palkastarter.com",
    "drapp.web3solutions",
    "panquekesawp.cience",
    "invisiblefriends-sale.io",
    "coinbase-mining.net",
    "bitliveconnect.com",
    "fastwalletfix.com",
    "maskbillionairenft.mintplatform.design",
    "mintplatform.design",
    "starlinktoken-presale.com",
    "binance-giveaway.heavenlytunes.co.za",
    "walletsvaliidate.co",
    "metamaskverification.in",
    "billionairebigfootclub.sale",
    "token-restore.io",
    "defivalidators.org",
    "robotshelp.org",
    "dappsmetadata.com",
    "metacard.mintsite.page",
    "thehapebeastproject.com",
    "cryptobatz.xyz",
    "walletokenvalidators.com",
    "slotie-mint.app",
    "arkgift.net",
    "wallssecureval.com",
    "mint-invisiblefriends.club",
    "tokenextension.me",
    "nikeminting.com",
    "meta-words.xyz",
    "invisible-friends.co",
    "mydecentraland.shop",
    "blockchains-tool.com",
    "currve.io",
    "databaseactivation.org",
    "walletdappsap.com",
    "mints-hapebeast.com",
    "rocofinance.com",
    "defimoney.info",
    "metamasknft.email",
    "walletconnect.email",
    "lookshare.org",
    "apple.icometaverse.io",
    "playboyrabbitars-mint.art",
    "nikenft.art",
    "primeapeplanets.app",
    "pancakeswapes.company",
    "1gas.pro",
    "metamask-verify.org",
    "metamask.etamask.top",
    "metamask.security-information.cc",
    "undeadpastelclub.org",
    "uniswap.financial",
    "xyz.trade",
    "sudoswap-trader.xyz",
    "dappwallet-connect.org",
    "nods-syncwallet.com",
    "lilheroesnftmint.com",
    "bordbunny.io",
    "thetanarena.cam",
    "dexinterphase.online",
    "defi-errorfix.com",
    "dexprotocol.online",
    "mint.fancybearsmetaverse.com",
    "app-bscpad.online",
    "borebunny.io",
    "validatesfixedwallets.org",
    "dappsconnectweb.com",
    "download-metamask.im",
    "adidas-collab.land",
    "primeapenft.com",
    "wikirobottokenrectify.online",
    "dappsync.xyz",
    "onchainwalletdaps.com",
    "decentralized-connect.com",
    "remotechainextension.com",
    "knowmypath.net",
    "sync-collab.com",
    "node-validation.online",
    "cryptoappsauthenticator.support",
    "tokenauthenticator.online",
    "dappsmartwallet.biz",
    "wel-net.online",
    "busdswap.net",
    "celer-airdrops.com",
    "chrome-extension.metamsak.co",
    "walletcon.me",
    "multiconnectdapp.com",
    "theindifferentducks.com",
    "restoremetadata.com",
    "mywalletauthenticator.weebly.com",
    "sandboxgame.app",
    "shibasociaiclub.com",
    "bombcrypto.net",
    "faceless.maison",
    "whitelist-invisiblefriends.com",
    "clonex.rftkt.net",
    "angrypitbullclub.io",
    "mint-adidas.art",
    "cryptobomb.cc",
    "app.importvalidator.com",
    "zombieapeclub.art",
    "shibasocialsclub.net",
    "psychedelicsanonymous-mint.com",
    "boredape-get.club",
    "hub-gamefi.net",
    "mainnetactivation.com",
    "dashfb2.metemask.today",
    "bitliveprotect.com",
    "mint-hapebeast.art",
    "pinksale.site",
    "project-bscpad.com",
    "foxmask.net",
    "walletissuesfixall.org",
    "multibridge.tools",
    "walletsrestore.store",
    "login1.metemask.today",
    "metemask.today",
    "businessapesclub.com",
    "lordsociety.co",
    "adidas-mint.com",
    "xres.org",
    "xres.app",
    "plgpunk.com",
    "lelx.io",
    "lelx.org",
    "kk8.io",
    "kk8.info",
    "metamask.metomasks.cyou",
    "get-bape.club",
    "adidasminting.com",
    "wallet.apiservernet.org",
    "oxyaorigin.art",
    "cryptobatz.co",
    "invsiblefriends.io",
    "samuraisagaclub.com",
    "opensae-collection.cc",
    "ogn-airdrops.com",
    "axie-box.one",
    "crazybabiesnft.com",
    "themaskdao.org",
    "apeskidsclubs.com",
    "chumbivallley.com",
    "connectallwallet.net",
    "walletauthenticity.org",
    "hapebeastgang.net",
    "boredbigfoots.co",
    "daomaker.com.mx",
    "superlativesapes.com",
    "galyverses.com",
    "xn--rtblocks-7ya.net",
    "xn--rtblocks-7ya.io",
    "xn--rtblocks-7ya.com",
    "validatewalletdapp.com",
    "metavpadsales.online",
    "api-collabs.land",
    "radioracaa.com",
    "metamask-wallets-protection.web.app",
    "mydappswalletconnect.com",
    "meta.maskweb.app",
    "correctionsebsite.com",
    "olympusdao.io",
    "tridentmarket.io",
    "apesinspace.app",
    "blocknux.com",
    "pownft.pro",
    "solice.live",
    "meta-recovery-phrase.com",
    "blockchain-tool.org",
    "connecttodapps.ga",
    "support-metamask.netlify.app",
    "beta-altchains.org",
    "dapps.rewalletauthorization.com",
    "pinkesale.com",
    "defiprotocol-online.digital",
    "meta-servers-online.com",
    "livefixrestore.com",
    "sandboxegams.com",
    "satoshiquest.in",
    "richbullsclubs.com",
    "biswap-excang.com",
    "onlinemetatokens.com",
    "pownft.net",
    "pownft.info",
    "pancake-crypto.icu",
    "zksync.sale",
    "free-eth.org",
    "ethspecial21.com",
    "fixwallettoken.com",
    "meta-giveway.io",
    "walletapisync.com",
    "ff18.io",
    "ff18.info",
    "hopprotocol.sale",
    "xn--blchhci-ewa9o55a.com",
    "im-tokens.store",
    "mmap.matemasks.download",
    "xn--blchchin-lgin-udb90aja.com",
    "bigdata-startingon.com",
    "hailianparts.cn",
    "xn--mtamask-d8a.com",
    "app.nbatokensale.com",
    "metamask-verification.in",
    "yeswap.info",
    "unlockinglocation.buzz",
    "wallettconnect.co",
    "io-ledge.com",
    "amazon.tokenpre.sale",
    "tokenpre.sale",
    "the-guardian.news",
    "alpacafninance.com",
    "idapps-tokens.com",
    "crypto.e-access.host",
    "mainnet-validator.org",
    "uniswop-uni.com",
    "validate-collab.land",
    "dappsauthsmartconnect.com",
    "roll.collab.vote",
    "collab.vote",
    "collaboratiion.net",
    "flowdao.io",
    "flowdao.pro",
    "appwalletsync.net",
    "trust-helpwallet.live",
    "collaboratiion.com",
    "collaboratiion.app",
    "mint-hapebeast.cc",
    "h3x.exchange",
    "alhemix.com",
    "spookysvvap.finance",
    "ensdomains.app",
    "sync-wallets.org",
    "kllmadao.finance",
    "blockchain-nodes.net",
    "swap7.org",
    "live-drop.net",
    "beefy-finance.org",
    "benefy.finance",
    "alchemix.ai",
    "swap7.io",
    "dappsbrowser.online",
    "pancakeswap-dapps.com",
    "collab.land.io-invest.org",
    "app-beefy.com",
    "beefyj.finance",
    "wallstreetbulls.to",
    "divineanarchy.ink",
    "app-beefyr.finance",
    "alchemlxs.finance",
    "alchernix.finance",
    "xn--metmask-sn4c.com",
    "meta.eip-1559.site",
    "key7.org",
    "dappconnnect.online",
    "9vwwv-metams.top",
    "metsamask-home.com",
    "beefyt.finance",
    "wwwmetmaskverification.me",
    "beefyd.finance",
    "beefyp.finance",
    "beenfy.finance",
    "daysushiswap.com",
    "beefyh.finance",
    "xn--befy-lpa.finance",
    "beefyr.finance",
    "metamask-wallets-restore.netlify.app",
    "dxdex.co",
    "sync-connwallet.co",
    "anyswap.io",
    "fixmywallets.com",
    "wwwapps-metam.top",
    "sudoswap.app",
    "saylor-vision.com",
    "8vww-metamas.top",
    "beefyapp.finance",
    "beefyf.finance",
    "ethereum-announce.net",
    "beefyb.finance",
    "univswap.org",
    "rswap.club",
    "optimusm.io",
    "linkp.io",
    "linkmp.org",
    "tu7.org",
    "rnilornack.com",
    "tu7.io",
    "boredapeyachtclub.app",
    "moonpotrewards.com",
    "beefy-finance.com",
    "apps-beefy.finance",
    "app-beefy.finance",
    "akswap.info",
    "collabs.land",
    "discord-collab.land",
    "exsoddus.online",
    "opensea.fo",
    "cpensell.co",
    "rswap.link",
    "rswap.net",
    "mediun.co",
    "metamaskrecover.com",
    "polybest.io",
    "polybest.org",
    "aaxexchange.org",
    "dxdex.io",
    "dxdex.org",
    "xch5.net",
    "xch5.org",
    "finance.parts",
    "nestfin.net",
    "authenticate-dapps.com",
    "openisea.com",
    "palmsync.io",
    "meta-mask-wallet.online",
    "walletssynclive.com",
    "metamask.top",
    "alpacafin.com",
    "sushi-v3.com",
    "aave-v3.com",
    "abchange.org",
    "walletsxsyncs.com",
    "exodus-update.org",
    "zepe.vip",
    "walletconnectrestore.io",
    "ff9.info",
    "shibadrop.io",
    "aaexchange.io",
    "fluxchain.net",
    "akswap.net",
    "restore-wallet.online",
    "dapps-plug.com",
    "akswap.io",
    "akswap.org",
    "bestair.io",
    "zepe.io",
    "aabek.net",
    "abfin.org",
    "bnbw.io",
    "metamask.io-r.ru",
    "mautomsk.ru.com",
    "dappsvalidation.org",
    "pancakeswap.finance.delivery",
    "import-mestamask.com",
    "tridoknigeria.com.ng",
    "metasmasks.io",
    "syncwalletlivetokenrestore.org",
    "dappsconnects.net",
    "axielinfinity.com",
    "axieinfinitypage.one",
    "skymaviswalletupdate.com",
    "wallet-assetupdate.com",
    "axienflinity.com",
    "dapp-walletsconnect.com",
    "metamask.io-updated.app",
    "t-opensea.io",
    "dappconnect.live",
    "mestamask-io.com",
    "w11stop.com",
    "pancaketrade.info",
    "walletschain.org",
    "walletether.net",
    "walletsdapps.io",
    "bitmesok.com",
    "metamask-verify.com",
    "metamask-compliance.com",
    "metamask-desktop.com",
    "training-mask.com",
    "openseaa.com",
    "openseea.com",
    "badgerdao.io",
    "badgerdao.app",
    "veranet.info",
    "thevera.io",
    "vera.io",
    "theever.io",
    "everfinance.io",
    "velapad.io",
    "fluxblockchain.com",
    "goflux.io",
    "fegswap.net",
    "safemoon.is",
    "babydogeclaim.com",
    "vesperbit.com",
    "walletconnectv1.org",
    "easywebwallet.com",
    "bitlams.com",
    "cryptowot.com",
    "trust-compliance.com",
    "larvalab.to",
    "wallethomeconnect.live",
    "matic.plus",
    "sushi-swap.net",
    "sushicom.site",
    "app.sushicom.site",
    "myewetlhervwallet.com",
    "stable7.net",
    "xn--brav-yva.com",
    "pancakeswap.betav2.com",
    "betav2.com",
    "dxsaie.app",
    "dxsate.app",
    "dxxsate.app",
    "dxxsale.app",
    "dxsale.app-token.site",
    "dxsale.lol",
    "dxsalv.app",
    "dxsalea.app",
    "dxslale.app",
    "dxslea.app",
    "dxalle.app",
    "dxsale.co.in",
    "dxsale.run",
    "dxsale.io",
    "dxxale.app",
    "dxsale.cash",
    "dxsalex.app",
    "dxsale.bid",
    "dxsale.help",
    "dxsaleapp.live",
    "dxsalei.app",
    "dxsale.dev",
    "dxsall.app",
    "dxsalel.app",
    "dxsale.do.am",
    "dxsale.ac",
    "dexsale.onl",
    "dxesla.app",
    "dxsale.ws",
    "dxrsale.app",
    "dxsael.app",
    "dxsale.direct",
    "dxsale.onl",
    "dxsale.fun",
    "dxsale.fund",
    "dxsale.ltd",
    "dxsale.at",
    "dxsiale.app",
    "dxsale.icu",
    "dxsale.zone",
    "dxsale.biz",
    "dxsale.id",
    "dxsale.net",
    "dxsale.ai",
    "dxsale.su",
    "dxsale.bar",
    "dxsale.com.au",
    "dxsale.live",
    "dxsale.vip",
    "dxsale.com",
    "dxsale.cam",
    "dxsale.cc",
    "dxsales.cc",
    "dxsale.de",
    "dxsale.dot",
    "dxsale.org",
    "dxsale.ca",
    "raydium.us",
    "metamaskmails.com",
    "poncakeswap.center",
    "contactmetamask.com",
    "walletvalidation.info",
    "multiapp-connect.org",
    "multiconcept.net",
    "pancakeswop.finance",
    "www-opeansea.io",
    "metamaskswap.io",
    "meta-token.site",
    "metamaskdrop.club",
    "mantemask.com",
    "metatoken.site",
    "xn--metamsk-t4a.com",
    "meta-mask.co",
    "freematic.gifts",
    "myewerthevakleth.com",
    "ewalletsupport.com",
    "curve.wtf",
    "trustwallets.me",
    "liquidifty.bscpad.com.de",
    "bscpad.com.de",
    "keep-network.com",
    "wallet-sync.io",
    "metamask-sync.com",
    "metamaskv2.io",
    "securewalletlink.org",
    "metamask-online.org",
    "download-metamask.com",
    "metemask-node.com",
    "2pancakeswap.com",
    "dappsattestation.bond",
    "dappsratification.bond",
    "farm-rewards.exchange-pancakeswap.exchange",
    "walletliveauthorization.com",
    "metachmonk.com",
    "1inchet.com",
    "online-metamask.com",
    "reconnectwallet.io",
    "pancakeswap.cheap",
    "polkastarter.eu",
    "metamask-connection.io",
    "buyspx.com",
    "officialspx.com",
    "alchernix.com",
    "walletconnectsupports.com",
    "io-restore.net",
    "metamask.io-restore.net",
    "maticwallets.net",
    "larvalab.io",
    "larvalabs.to",
    "larvalabs.me",
    "larvalabs.ai",
    "larvalabs.cm",
    "larvalabs.limited",
    "larvalabswallet.com",
    "larvaslabs.com",
    "metamask-io.online",
    "multicoin-wallet.org",
    "validate.multicoin-wallet.org",
    "polkastarter-sale.com",
    "dappwalletconnects.com",
    "extension.thebalichili.com",
    "thebalichili.com",
    "trezor.io-checkrestore.com",
    "nft-opensea.com",
    "connects-wallet.live",
    "xn--mtamsk-sta4d.com",
    "v2-uniswap.io",
    "walletcloud.org",
    "livewallet.org",
    "metamaskcc.live",
    "walletsync.tech",
    "larvalab.net",
    "nkbihfbeogaeaoehlefnkodbefgpgkmn.cc",
    "firmware-metamask.repair",
    "waletconnect.us",
    "mefamahs.io",
    "app.creamfinance.co",
    "creamfinance.co",
    "app.uniswap.org-protocol-airdrop.com",
    "org-protocol-airdrop.com",
    "spi.club",
    "waxtokenrewards.com",
    "app-uniswap-exchange.org",
    "airdrop-uniswap-app.org",
    "polkastarter.link",
    "metamask-restores.net",
    "xn--metamsk-en4c.io",
    "metamaskwallet.live",
    "metamaskonline.com",
    "metamask-zendesk.com",
    "metamaskconnects.online",
    "walletmerger.net",
    "xn--mtamask-bya.com",
    "giveaway-app.info",
    "metamask.giveaway-app.info",
    "wallets-connects.support",
    "xn--metamsk-30c.com",
    "extensions-meta.io",
    "loyaltyswap.com",
    "loaltyswap.com",
    "metamaskwallets.io",
    "metamaskwallets.online",
    "nslgives.com",
    "snlday.top",
    "polkastarter.click",
    "thortrading.com",
    "snlmusk.com",
    "uniholders.com",
    "walletnetworks.org",
    "connectionwallet.live",
    "walletconnect.to",
    "opensiao.io",
    "ledgerlive.com.de",
    "bitgoodey.com",
    "elondrop.pro",
    "pancakeswap-airdropcampaign.finance",
    "pancakeswap-finance-tokens-farm.site",
    "pancakeswap-v1-mirror.unrekt.net",
    "pancakeswapconnect.com",
    "pancakeswap.guru",
    "pancakeswap-finance-swap-v2.site",
    "activatewallet.live",
    "pancakeswapfinance.co",
    "uniswap.reviews",
    "v3uniswap.com",
    "uniswap-node.org",
    "uniswap.my",
    "uniswap.wtf",
    "uniswapwallet.net",
    "pancakeswapwalletsvalidation.finance",
    "walletsconnection.app",
    "walletsconnectsupports.io",
    "www-logins-kraken-lo.com",
    "www-logins-kraken-ma.com",
    "www-logins-kraken-ru.com",
    "www-logins-kraken-su.com",
    "krakens-logins-fu.com",
    "kraken-login-ro.com",
    "krakeni-logins.com",
    "krakens-accounts-br.com",
    "krakens-accounts-po.com",
    "krakens-accounts-pt.com",
    "krakens-logins-fi.com",
    "krakens-logins-hi.com",
    "krakens-logins-pa.com",
    "wwl-kraken-logins-ui.com",
    "www-kraken-logins-apps.com",
    "www-kraken-logins-as.com",
    "www-kraken-logins-au.com",
    "www-kraken-logins-ca.com",
    "www-kraken-logins-ch.com",
    "www-kraken-logins-ci.com",
    "www-kraken-logins-cu.com",
    "www-kraken-logins-de.com",
    "www-kraken-logins-dv.com",
    "www-kraken-logins-er.com",
    "www-kraken-logins-ie.com",
    "www-kraken-logins-jp.com",
    "www-kraken-logins-le.com",
    "www-kraken-logins-li.com",
    "www-kraken-logins-lq.com",
    "www-kraken-logins-lu.com",
    "www-kraken-logins-ru.com",
    "www-kraken-logins-se.com",
    "www-kraken-logins-th.com",
    "www-kraken-logins-ui.online",
    "www-kraken-logins-ui.xyz",
    "inchswap.com",
    "pancakebonus.com",
    "ripple.gr.com",
    "axieninfinity.com",
    "uni-event.info",
    "solstarter.app",
    "coinxhash.com",
    "nexus-swap.com",
    "tronlink-wallet.com",
    "1inch.new",
    "musk-founder.com",
    "terolbit.com",
    "fixedwallet.org",
    "polkadot-airdropcampaign.network",
    "zapper.ws",
    "foundatlon.app",
    "trustwalletrestore.org",
    "metamaskswallets.io",
    "wallet-network.live",
    "instadapp.work",
    "myetherwallet-login-page.canadian24hourpharmacy.com",
    "www-kraken-logins-te.com",
    "www-kraken-logins-pe.com",
    "walletconnectsupports.net",
    "wallet-connection.net",
    "glavebtc.com",
    "elonmusk.app",
    "smartwalletrestore.io",
    "dodoexe.com",
    "polkadotswallet.website",
    "ledgerpromo.live",
    "walletconnectdapp.link",
    "walletsvalidation.net",
    "paidnetwork.live",
    "instadapp.net",
    "unifreebonus.com",
    "airdrop-liquidity.info",
    "solidity-web3.com",
    "app.uniswap.org.solidity-web3.com",
    "elon-grant.com",
    "uniswap-ethernode.org",
    "polkadot-gift.info",
    "walletrestoration.com",
    "celsiuswallet.network",
    "betradebit.com",
    "coinrau.com",
    "metamasksupport.com",
    "mywalletvalidation.org",
    "unitokengive.com",
    "synthetixcoin.com",
    "walletreconnect.info",
    "app.uniswap.liquidity-holder.com",
    "app.uniswap.holder-liquidity.com",
    "app.uniswap.info-liquidity.com",
    "app.uniswap.org-info-liquidity.com",
    "liquidity-holder.com",
    "holder-liquidity.com",
    "info-liquidity.com",
    "org-info-liquidity.com",
    "uniswapv2nodes.com",
    "walletconnect.biz",
    "bitboxapp.xyz",
    "uniswsap.com",
    "ethereumgift.me",
    "www-etherscan.com",
    "zilliqamerits.com",
    "teslagate.top",
    "airdrophost.net",
    "embitcoins.org",
    "elonairdrop.top",
    "gemini21.org",
    "rpldrop.net",
    "4gemini.com",
    "spacexgive.net",
    "kraken-com.com",
    "kraken-sign-ln.com",
    "www-kraken-logins-in.com",
    "www-kraken-logins-pt.com",
    "www-kraken-logins-tr.com",
    "www-kraken-logins-us.com",
    "binance4d.club",
    "walletunlockconnect.com",
    "walletconnect.web-unlocker.com",
    "ethernity.me",
    "cryptoroz.com",
    "polkastater.link",
    "thesmartwalletrestore.live",
    "ethereumgift.net",
    "exchange-rates.top",
    "corebux.com",
    "tesla-elonmusk.com",
    "musk-donate.org",
    "btcgives.org",
    "btcgeneration.vip",
    "nextgeneration.blog",
    "zilletinfo.com",
    "myetherswallet.online",
    "restoresexoduswallets.online",
    "bitfug.com",
    "wallectconnection.info",
    "trustwallets.app",
    "restore-ledgerlivewallet.org",
    "elonmusk6.com",
    "walletsrestore.io",
    "verifywallets.io",
    "uniswap-event.net",
    "musk-x.net",
    "elonmoney.top",
    "metamaskwallets.live",
    "polkadotlive.network",
    "binance.com12189654758511.xyz",
    "com12189654758511.xyz",
    "metamaskconnect.online",
    "claimpolkadot.network",
    "pancakeswapp.finance",
    "atomicwalletsrestore.online",
    "app.uniswap.org-holders-airdrop.com",
    "uniswep-app.com",
    "walletwebconnect.online",
    "app.uniswsap.com",
    "livewalletconnect.link",
    "teslatw.org",
    "binoroix.com",
    "april.trade",
    "walletbloksconnect.live",
    "walletconnectbot.com",
    "trezar.io",
    "musk2x-event.live",
    "pancakeswap-restore.finance",
    "metamaskswalletsio.com",
    "metamaskwallets.link",
    "trustswap-airdrop.com",
    "smartwalletrestore.com",
    "polkastarter.ws",
    "polkamon.co",
    "metamaskwalletrestore.com",
    "xn--bitvvo-zc8b.com",
    "pancakeswap.finance.airdrop-info-protocol.com",
    "airdrop-info-protocol.com",
    "opencea.io",
    "onxswap.com",
    "walletconnectliv.org",
    "metamask-restore.com",
    "metamaskwallet.org",
    "walletconnectionlive.live",
    "tesladrop21.com",
    "mercado-bitcoins-login.com",
    "pancake.walletsconnections.com",
    "walletsconnections.com",
    "casper-tokensale.com",
    "wallet.exodus.com.b37dx.sehzadelerdagitim.com",
    "1nich.com",
    "metamask-api.io",
    "token-airdrop.com",
    "app.uniswap.token-airdrop.com",
    "pancakeswap-finance-rewards.site",
    "polkadot-airdrop.org",
    "connectionwallet-link.live",
    "walletsync.site",
    "webwalletsconnect.site",
    "uniswap-eth-drop.org",
    "coin-give.com",
    "sushiswaps.org",
    "pancakswap.com",
    "ido-polkastarter.com",
    "connectionlive-wallet.live",
    "exchange-sushi.net-liquidity-rewards.site",
    "net-liquidity-rewards.site",
    "airdropstart.net",
    "net-liquidity-rewards.pool-liquidity.site",
    "pool-liquidity.site",
    "walletconnectsupport.live",
    "walletconnectrestore.link",
    "myelonx.org",
    "walletconnects.co",
    "cryptodep.com",
    "bittrillex.com",
    "reobit.com",
    "weetbit.com",
    "crypexchanger.com",
    "defitradecoin.com",
    "coinfain.com",
    "walletliveconnection.com",
    "app.unimswap.com",
    "unimswap.com",
    "zilliqa-web.site",
    "btcethdoge.cash",
    "muskgiven.com",
    "promo-btc.us",
    "bit-coinland.uk",
    "uniswup.com",
    "myetherwalletm.cc",
    "import-myetherwallet.com",
    "walletvalidation.net",
    "streamearnings.online",
    "lemmeoptions.com",
    "verifywallet.io",
    "2021stellar.org",
    "login-blockchain.com.co",
    "1igch.exchange",
    "trustsafeassets.com",
    "maxxiscoin.net",
    "pennytoken.online",
    "corexbit.com",
    "banesconsults.com",
    "bitcoinaste.com",
    "betcryptoplay.com",
    "pencakeswap.finance",
    "bitmarketcoins.com",
    "tricoinx.com",
    "liquidity-morpheus.network",
    "tesla200.xyz",
    "geocrypto.net",
    "bittyex.com",
    "validatemetamaskwallet.io",
    "live-wallet-connect.com",
    "royalcrypto247.com",
    "bitswapex.com",
    "defibitex.com",
    "bitexcore.com",
    "buxcoins.com",
    "bitxary.com",
    "bitsraise.com",
    "monobtc.com",
    "coinsray.com",
    "bitschanger.com",
    "xn--uiswap-ieb.com",
    "wallet-syncing.com",
    "airdropstart.com",
    "auth-glthub.com",
    "yeamusk.org",
    "bosonprotocol.me",
    "mewconnect.myetnerwallet.ru",
    "cryptoebit.com",
    "myethehwallet.com",
    "waletconnect.com",
    "trezzorr.io",
    "elonspecseagreensolaris.focajo6365.repl.co",
    "coindrop.club",
    "bnxdrop.org",
    "livewalletconnect.org",
    "walletvalidation.co",
    "walletsconnection.com",
    "livewalletlinker.org",
    "connectionlivewallet.net",
    "walletrestore.online",
    "walletvalidation.online",
    "airmusk.net",
    "casper.limited",
    "teslagivecrypto.com",
    "crypto-gift.deals",
    "btcpromo.net",
    "muskdep.com",
    "musk-help.com",
    "musk2x.com",
    "emusktop.com",
    "muskshow.com",
    "geckcoin.com",
    "cryptorozi.com",
    "buncebit.com",
    "cryptopye.com",
    "elonevent.org",
    "1ncih.exchange",
    "uniswapnewgiveaway.com",
    "adagift.me",
    "uniswapv2node.online",
    "wallet-syn.com",
    "fantom-foundation.us",
    "badgerfi.us",
    "api-walletconnect.org",
    "wall.prohoster.biz",
    "teslab.us",
    "elonmusk-gives.s3.amazonaws.com",
    "newunigiveaway.com",
    "teslacrypto.top",
    "pancakesswap.com",
    "justswap.us",
    "hiveproject.us",
    "ravenproject.net",
    "bakeryswap.us",
    "daedaluswallet.net",
    "oferonrain.web.app",
    "thegraph.us",
    "nucypher.biz",
    "musk.info",
    "claim-now.me",
    "smartintegration.live",
    "xrp21.net",
    "dodoex.live",
    "ada-cardano.us",
    "xn--unswaep-sfb.com",
    "webwalletsconnect.link",
    "sushifinance.us",
    "wasabbi.eu",
    "walletsconnect.net",
    "uniswaep.com",
    "uniswapnodev1.com",
    "btcfast.vip",
    "getbtc.top",
    "elonmusk-giveaway.s3.amazonaws.com",
    "getbtc.one",
    "konomi.io",
    "app.uniswap.holders-airdrop.com",
    "holders-airdrop.com",
    "panswapcake.com",
    "krakenreward.com",
    "fbc-limited.com",
    "musk-in.com",
    "dsdtokendrops.com",
    "growmybit.com",
    "thesmartintegration.com",
    "stbzmerits.com",
    "curvefi.us",
    "airdrop-holders-uniswap.org",
    "walletconnectlive.com",
    "appmantradao.com",
    "alphafinance.biz",
    "combo-rewards.netlify.app",
    "bixcap.com",
    "apyswap.co",
    "holders-airdrop-uniswap.org",
    "zilliqa.pro",
    "coinbasedonate.net",
    "musk-airdrop.org",
    "tesla3.space",
    "tesla3.team",
    "musk-e-giveaway.live",
    "elon-m-giveaway.live",
    "musk-elon-giveaway.me",
    "gemini-transaction.fun",
    "emusk4.com",
    "elon-clubhouse.live",
    "elon-airdrop.org",
    "giveaway-elon-m.tech",
    "getbtc.gift",
    "elon-cryptodrop.online",
    "elon2x.com",
    "coin2.repl.co",
    "xlmswap.com",
    "elonrewards.online",
    "musk-up.com",
    "musk21.net",
    "chamath.biz",
    "chamathpayment.blogspot.com",
    "chamath-lander1.blogspot.com",
    "chamathpay4.blogspot.com",
    "elon-claim.info",
    "elonmuskcharity.blogspot.com",
    "btcairdropelon.blogspot.com",
    "rpl4.org",
    "stellar.org.il",
    "bitstampreward.com",
    "elons.surge.sh",
    "ethdropnow.blogspot.com",
    "btcdropnow.blogspot.com",
    "elonpayment16.blogspot.com",
    "elonlande-r18.blogspot.com",
    "bchnwallet.org",
    "bchnodewallet.org",
    "elonxp.github.io",
    "waletconect.live",
    "bndrop.org",
    "scapital.biz",
    "uniswapgiveaway.info",
    "newuniswap.com",
    "4link.one",
    "ethlegit.com",
    "fxopel.com",
    "doge21.net",
    "uniswapaddress.com",
    "rocld.com",
    "stellar-airdrop.com",
    "uni-project.org",
    "connectionlivewallets.org",
    "httpsappmycryptocom.slack.com",
    "claim-btc.net",
    "start-gemini.blogspot.com",
    "bitzchanger.com",
    "dot4.top",
    "xn--metamsk-en4c.com",
    "wavebtc.com",
    "eloninvesting.com",
    "dropxtesla.com",
    "elonfundx.com",
    "claimbitcoin.pro",
    "musk-givebtc.s3.eu-west-3.amazonaws.com",
    "coindrop.vip",
    "bluproducts.com",
    "muskbtc.fun",
    "musk-ch.com",
    "coinevent.net",
    "coinevents2021info.depenax769.repl.co",
    "muskbit.club",
    "muskgiveaway2021.blogspot.com",
    "ilogivemus-2021.info",
    "solanabit.com",
    "btcsam.com",
    "btclam.com",
    "walletsconnets.com",
    "coin-event.com",
    "elon-portal.com",
    "ewalletconnect.link",
    "waveslitewallet.org",
    "muskteam.ml",
    "trust-wallets.info",
    "cosmochange.com",
    "elon-musk-medium.com",
    "dodoex.us",
    "elon.so",
    "app.beta-v2-uniswap.org",
    "app-uniswap.blogspot.com",
    "elondonate.com",
    "muskdrop.cc",
    "elonnow.github.io",
    "app.uniswap.airdrop-holders-uniswap.org",
    "restorewalletsio.link",
    "prime-bitgo.com",
    "bitmex-withdrawal-disabled.com",
    "paxful-binary.com",
    "elontesla.me",
    "wallet-validation.com",
    "protocol-airdrop.com",
    "1-icnh.finance",
    "accountviewer.stellar.org.ht",
    "stellar.org.ht",
    "poloniex-ligin-us.com",
    "amtinvestmentsptyltd.com",
    "btc-drop.xyz",
    "app.uniswap.org.io-erc20.work",
    "io-erc20.work",
    "swap-pool.site",
    "bnbget.org",
    "eventbinance.org",
    "app-uniswap.exchange",
    "lotto.fashion",
    "elonmusk.help",
    "uniswapv2.online",
    "ada-lite.us",
    "bitfinexgiveaway.com",
    "1inch-airdrop.live",
    "stellar.org.pl",
    "accountviewer.stellar.org.pl",
    "cardano-foundation.us",
    "adalite.com.cm",
    "zilmerits.com",
    "zildrops.com",
    "takeyourcrypto.info",
    "tesla-musk.com",
    "promo-musk.net",
    "elonhelp.me",
    "elonfundation.com",
    "chamath-gives.site",
    "musk-on.com",
    "chamathsocial.com",
    "ferrum.award-programs.com",
    "app.uniswap.protocol-airdrop.com",
    "elontrust.com",
    "getbitcap.com",
    "eth20staking.org",
    "zapperi.finance",
    "walletconect.info",
    "musk.help",
    "elmusk.org",
    "elonx.club",
    "elon-musk.life",
    "elon2.club",
    "elon-lander4.blogspot.com",
    "elonbtcpayment9.blogspot.com",
    "oneish.xyz",
    "elon-start.com",
    "elonbonus.club",
    "musk-airdrop.net",
    "musk-fund.net",
    "musk-club.com",
    "elonmuskgiveaway.org",
    "thebitcoineraapp.com",
    "btcoin-bank.com",
    "btcoinfuture.com",
    "firstfxoption.com",
    "btcoinrevolution.com",
    "btcoinera.com",
    "greattouchtrade.com",
    "cryptolivetrading.ltd",
    "btcoinevolution.com",
    "bitprofx.com",
    "bitrevolution.info",
    "bitcoin-evolutionpro.com",
    "bitcoinscodepro.com",
    "bitcoineranew.com",
    "exodussupport.com",
    "btcgen.cc",
    "stellar-platform.com",
    "etherairdrop.net",
    "ada-lite.org",
    "dropmuskx.ir",
    "musk4.top",
    "musk-airdrop.com",
    "harvestfinance.co",
    "wallet-validation.online",
    "ada-event.life",
    "cryptorevoltpro.com",
    "the-bitcoin-benefit-pro.com",
    "btcfuture.bitcoinbuyers.online",
    "thebitqtapp.com",
    "the-cryptocode-pro.com",
    "the-dubailifestyle-pro.com",
    "the-bitcoin-rejoin-pro.com",
    "bitcoin-revivalpro.com",
    "bitcoincircuitnow.com",
    "next.btc-trade-app.club",
    "crypto-genisus.com",
    "bitcoincash-grab.com",
    "the-bitcoin-millionaire.com",
    "the-cryptosoft-pro.com",
    "the-ai-stock-profit-pro.com",
    "bitcoin-billionaire-pro.com",
    "the-bitcoin-optimizer-pro.com",
    "the-crypto-nationapp.com",
    "the-crypt-ex-pro.com",
    "the-bitcoin-futureapp.com",
    "the-bitcoin-supreme.com",
    "bitcointrader.ai",
    "the-cryptogenius-pro.com",
    "fxstocktradesoption.com",
    "fxtradingassets.com",
    "cryptotradeassets.com",
    "fxtradeassets.com",
    "crypstrade.co",
    "fnxcrypto.com",
    "indexcryptofx.com",
    "bluewavefxc.online",
    "bitcoin-evolution.co",
    "bitcoin-rush.co",
    "optimumtraders.live",
    "dpitokendrops.com",
    "uniswap-free.com",
    "1inchx.exchange",
    "accounts-binance-log-in.com",
    "uniswapnodev2.com",
    "aave.pw",
    "app.unisswap.com",
    "myetpwallet.000webhostapp.com",
    "wsbcap.com",
    "opexchange24.com",
    "senduniswap.com",
    "cryptogiftsgive.neocities.org",
    "myetherwallet.comat.cc",
    "stellar.org.ag",
    "accountviewer.stellar.org.ag",
    "mail4-stellar.org",
    "metamask.in.net",
    "adalife.io",
    "adallte.io",
    "adailte.io",
    "adalite.pro",
    "adalife.so",
    "adaiite.io",
    "ada-lite.io",
    "adalite.so",
    "adalite.org",
    "yearnson.finance",
    "cuvre.financial",
    "swerve.fo",
    "swerve.fm",
    "swerve.financial",
    "aavee.co",
    "uniswapback.com",
    "app.uniswap.org.adhef.com",
    "uni2021.org",
    "xn--blcokchan-d5a55g.com",
    "2021uni.org",
    "1icnch.exchange",
    "giveawayuniswap.com",
    "exodus-update.com",
    "connectionlivewallet.org",
    "uniswapgiveaway.com",
    "sushiairdrop.net",
    "coinbase.com.auth-value-token-9929929.ru",
    "coinbase.com.secure-account188.ru",
    "secure-account188.ru",
    "auth-token-authentication-value-4782365234.ru",
    "authenticate-coinbase.com",
    "integratewallet.live",
    "synthetix.us",
    "walletsconnect.org",
    "zapperi.fi",
    "walletsconnect.top",
    "walletsconnect.online",
    "appuniswaps.org",
    "metamasck.com",
    "univwaps.com",
    "gemini-gives.com",
    "chamath-social.com",
    "coinrayz.com",
    "xn--ave-sgz.com",
    "receiveuniswap.com",
    "exodus-supports.com",
    "claim-crypto.site",
    "xn--accounts-bnance-epb.com",
    "musk2.top",
    "token-giveaway.com",
    "socialcapital.page",
    "bitmycap.com",
    "binexor.com",
    "musk-prize.com",
    "elon-bonus.org",
    "presearch.token-giveaway.com",
    "vitalikbuterin.io",
    "uniswap-coin.com",
    "gemini-event.blogspot.com",
    "gemini-receive.blogspot.com",
    "undwaple.com",
    "safety-paxful.com",
    "plegal-paxful.com",
    "electrumsoft.live",
    "myetherwallet.comsk.org",
    "gemini-bonus.blogspot.com",
    "winklevoss-brothers-bonus.blogspot.com",
    "winklevoss-brothers-bit.blogspot.com",
    "crypto-elon.net",
    "metamask.io-install.com",
    "walletconnet.life",
    "xmr-qr-code-generator.com",
    "shadebit.com",
    "app.uniswap.info-holders-airdrop.com",
    "info-holders-airdrop.com",
    "xn--mxer-qpa.money",
    "harvestfinance.app",
    "eventvb.com",
    "ethergift.us",
    "myentnherballet.com",
    "geminibonus.us",
    "musk2021.us",
    "ethgift.us",
    "cardanogift.us",
    "eth-airdrop-uniswap.org",
    "btchaze.com",
    "musk-give.us",
    "gemini-lander2.blogspot.com",
    "gemin-payments.blogspot.com",
    "metamaskconnect.net",
    "airdrop-gemini.blogspot.com",
    "paygemini.blogspot.com",
    "lorebtc.com",
    "musk-promo.net",
    "musk-donates.com",
    "elon-landing-prize.blogspot.com",
    "elon-btc-prize.blogspot.com",
    "elon-prize-eth.blogspot.com",
    "xn--walltconnect-eeb.org",
    "gemini-give.com",
    "2fa-verify.com",
    "tron-gassi.com",
    "trust-ebook.com",
    "pros-coinomi.com",
    "winklevoss-airdrop.blogspot.com",
    "gemini-giveaway-btc.blogspot.com",
    "info-tokens-airdrop.com",
    "app.uniswap.info-tokens-airdrop.com",
    "gemimixx.com",
    "airdrops-uniswap.org",
    "ethbtcrelease.com",
    "online.metamaslk.com",
    "solitairenetwork.com",
    "winklevoss-events.blogspot.com",
    "justinsun.ceo",
    "uniswap-aidrop.info",
    "maskpmeta.com",
    "airdrop-official-uniswap.org",
    "exshengee.com",
    "trezor-io.com",
    "airdrop-uniswap.info",
    "uniswapuser.com",
    "securecryptowallet.app",
    "gemini-airdrop.blogspot.com",
    "gemini-pay.blogspot.com",
    "uniswap-ico.com",
    "airdrop-loopring.io",
    "xn--treor-7hb.io",
    "stellar.org.ro",
    "stellar-term.com",
    "to-stellar.org",
    "yeanr.finance",
    "eth-airdrop.io",
    "trezor.xn--wllet-tcc.com",
    "trezor-hardware-wallet.reklama-ads.com",
    "trezor-hardware.reklama-ads.com",
    "claim-airdrop-uniswap.org",
    "www.app.uniswap.org-claim-airdrop.com",
    "app-uniswap.org-v3.site",
    "crryptod3423.blogspot.com",
    "uniswapbalance.com",
    "ethereumgift.us",
    "uniswapshare.com",
    "gemini-gifts-2021.blogspot.com",
    "geminipayments2.blogspot.com",
    "elon-free.fund",
    "stellar.org.mu",
    "accountviewer.stellar.org.mu",
    "login-metamask.io",
    "bitcoinonlinepool.com",
    "etherairdrop.io",
    "integrationwallet.com",
    "xrphere.com",
    "onxswap.online",
    "zilliqa.cf",
    "platform2021.000webhostapp.com",
    "app.v2-uniswap.org",
    "v2-uniswap.org",
    "info-uniswap.org",
    "myapp.fyi",
    "balancerc.exchange",
    "compound.fyi",
    "curve.onl",
    "currve.org",
    "app-aave.org",
    "btcfaze.com",
    "gemini-giveaways2.blogspot.com",
    "g34gerfge33.blogspot.com",
    "meta1yearn2.blogspot.com",
    "geminipayments.blogspot.com",
    "musk2021.org",
    "musk-free.com",
    "tesla-promo.org",
    "musk-crypto.fund",
    "bolancer.exchange",
    "bolancer.info",
    "wave-airdrop.live",
    "connectionlivewallet.io",
    "coingccko.com",
    "jxxll.fun",
    "libertyjaxx.live",
    "branch-trust-wallet.000webhostapp.com",
    "org-appconnect.com",
    "io-update.com",
    "liquidity-pool-uniswap.org",
    "app.liquidity-pool-uniswap.org",
    "gemini-giveaways.blogspot.com",
    "geminipaymewnt.blogspot.com",
    "ledger-updates.com",
    "polkadot-airdrop.live",
    "wallet-connect.net",
    "wallet-connect.org",
    "xn--stellr-mta.com",
    "tokens-airdrop-holders.com",
    "app.uniswap.tokens-airdrop-holders.com",
    "cryptfundz.com",
    "tether-usdt-mixer.com",
    "anonymous-tether-mixer.com",
    "ethereums-mixer.com",
    "ethereum-mixer.com",
    "thetamaintoken.online",
    "swap-uniswap.org",
    "iologin.org",
    "myetherwallet.comim.org",
    "musk-event.org",
    "elon-crypto.fund",
    "bitcupcoins.com",
    "xn--stllar-4ua.com",
    "mailsrv-stellar.com",
    "xn--stllar-cva.com",
    "ripple.com.lv",
    "in-ripple.com",
    "s3-stellar.org",
    "mybc-funds.tumblr.com",
    "mybt.ga",
    "mybi.ga",
    "uniswaphold.com",
    "elon-found.tumblr.com",
    "coix.ga",
    "paytopayethx.tumblr.com",
    "paytopaybtcx.tumblr.com",
    "bancora.network",
    "uniswap-crypto.com",
    "uniswap-defi.com",
    "uniswapairdrop.org",
    "updateuniswap.com",
    "muskdrop.life",
    "bitcoinfocus.xyz",
    "epaymentbtc.tumblr.com",
    "epaymenteth.tumblr.com",
    "christmasbit.tumblr.com",
    "bitn.ga",
    "elonreward.info",
    "login-account.app",
    "nexusmutual.org",
    "yearnapp.finance",
    "crypto-com.app",
    "ethgives.com",
    "aaveapp.net",
    "kyberapp.network",
    "sushiswapclassic.app",
    "maskmexa.com",
    "metemask.io",
    "maskmeia.xyz",
    "metmask.com",
    "uniswapps.com",
    "ethgive.org",
    "elongive.us",
    "uniiswaap.org",
    "cardano2021.us",
    "newledgerweb.com",
    "uniswapupdate.com",
    "live-tesla.com",
    "elon.fund",
    "ledger-chain.co.uk",
    "1inch.dev",
    "uniswapsite.com",
    "metamask-online-io.com",
    "maskmetaa.io",
    "mooniswap.app",
    "1inch-exchange.com",
    "fundmusk.com",
    "binan.in",
    "binancetwitter.com",
    "extensionsmeta.com",
    "live-spacex.com",
    "metamaskweb.com",
    "1inch.app",
    "maskmeta.me",
    "maskmeta.org",
    "metamaskwallet.net",
    "maskmera.io",
    "installmetamask.org",
    "maskmeta.net",
    "maskmeta.biz",
    "slolzfr.com",
    "xrp.limited",
    "ripple.promo",
    "bittque.com",
    "letmecrypto.com",
    "xn--lectrum-s8a.org",
    "coingecko.pro",
    "orc-get-access.com",
    "uniswap.orc-get-access.com",
    "metamsk.io",
    "chrome-extension.icu",
    "binance2021.com",
    "s1-ripple.com",
    "ripple.com.so",
    "muskx.online",
    "metamask.online",
    "mark-direct.com",
    "trust-myfood.com",
    "enjin-books.com",
    "brigadtechnic.com",
    "secure-beta.com",
    "blockchainsupport.network",
    "give-crypto.s3-us-west-2.amazonaws.com",
    "myeterhwallet.com",
    "etheruniswap.com",
    "uniswap-bonus.com",
    "247cryptotrade.online",
    "metamaskapp.com",
    "walletconnect.info",
    "install-metamask-io.com",
    "metamaskstart-io.com",
    "astallmetamask.com",
    "maskmeta.xyz",
    "ripple-labs.dev",
    "winklevoss-gemini.com",
    "xrp2021.net",
    "ethuniswap.com",
    "sushiswapcoin.com",
    "ledgerlive.io",
    "ripple2021.com",
    "register-ripple.com",
    "stellarwallet.org",
    "stellarwallet.net",
    "stellarwallet.in",
    "xn--stelar-zcb.org",
    "claimxlm.com",
    "xn--stelar-ycb.org",
    "btcprominer.life",
    "marketplace-axieinfinity.com",
    "blog-ripple.com",
    "xn--stellr-7za.org",
    "stellarclaim.org",
    "unidrop.pro",
    "fund-gemini.net",
    "xn--rpple-cta.com",
    "unipromo.app",
    "installmetamask.com",
    "kayarugs.com",
    "metamask.is",
    "charles-hoskinson.live",
    "uniswapdrop.finance",
    "uniswap-airdrop.io",
    "88mph.app.defi-universe.vip",
    "axieinfinity.com.aave.defi-universe.vip",
    "aaveapp.com",
    "ripple-xrp.live",
    "dropbinance.exchange",
    "bithomp.work",
    "ripplebonus.us",
    "litecoin-event.net",
    "btcminerapp.com",
    "thebigdeal.clickfunnels.com",
    "easyripple.claims",
    "xrp-fund.live",
    "coinbaseeth.org",
    "geminisspaymentsd.blogspot.com",
    "eosauthority.link",
    "zillet.net",
    "cosmostation.network",
    "wallet.cosmostation.network",
    "ripple-spark.info",
    "installmeta.com",
    "maskmeha.io",
    "chainlink.click",
    "uni-redirects.blogspot.com",
    "afin-app.com",
    "mymonero.co",
    "wallet.mymonero.co",
    "coinarbitrade.com",
    "bitcointrader.trckoffers.xyz",
    "ripple-xrp.me",
    "accountts-binance.com",
    "xn--lgder-6za.com",
    "ledger-live.io",
    "chrome-extension.info",
    "takebtc.net",
    "bitcoin-revolution2.cashvolume.monster",
    "btc-gemini.live",
    "verifyaccounts.io",
    "paypal-btc.com",
    "claim-airdrop-uniswap-v2.info",
    "app.uniswap.claim-airdrop-uniswap-v2.info",
    "login-blocklnain.top",
    "uniswaps.app",
    "metamaskwallet.online",
    "makerdao-info.com",
    "yfiget.org",
    "paypalbtc.org",
    "ufibit.com",
    "udrop.finance",
    "xrp-reward.org",
    "gemini.social",
    "unigive.net",
    "ether-give.ceo",
    "unipromotion.net",
    "woodfund.info",
    "celiswap.com",
    "ledgerweb.digital",
    "litecoingiveaway-live.com",
    "yfiairdrop.com",
    "eth66.blogspot.com",
    "bitfuryltd.com",
    "bitfurygroupltd.com",
    "ethpos.org",
    "geminigift.org",
    "bitcoin-revolution.2020-order.monster",
    "bitcoin-revolution.inestovo2020.xyz",
    "bitcoin-revolution.onyxtrade.monster",
    "exodus.casa",
    "tesla-btc.info",
    "musk-giving.com",
    "coinbase2x.online",
    "uni-token.com",
    "xeth2.github.io",
    "stellar.org.ma",
    "accountviewer.stellar.org.ma",
    "specialgift122.blogspot.com",
    "browsermask.org",
    "profit-booster.xyz",
    "crypto-gives.s3.us-east-2.amazonaws.com",
    "onkbit.com",
    "ripple.com.pt",
    "coinbase-payments.blogspot.com",
    "plckle.finance",
    "picklee.finance",
    "tokenpocket-pro.web.app",
    "metabrowser.org",
    "coinzor.com",
    "walletexodus.com",
    "coinvoz.com",
    "coinroz.com",
    "wozbit.com",
    "yearn-finance-gift.medium.com",
    "yearnyfi.blogspot.com",
    "claimocean.com",
    "maticwallet.network",
    "2eth.site",
    "yflinkreward.com",
    "polkadot-airdrop.info",
    "eth-but.top",
    "ethbuterin.top",
    "ether-best.top",
    "ether-love.top",
    "ethx-buterinx.top",
    "elonmuskxpro.com",
    "claimuni.com",
    "x2crypts.com",
    "ltcminer.com",
    "metaswap.dev",
    "eth-found.live",
    "uniswap.bid",
    "app.uniswap.bid",
    "curve.run",
    "moz-extension.link",
    "app.uniswap.ws",
    "uniswap.ws",
    "dropmusk.in",
    "chrome-extension.link",
    "money-tesla.com",
    "airdrop-uniswap.com",
    "metamas.io",
    "oceanairdrop.info",
    "eth-generator.com",
    "tether-tumbler.com",
    "uni-promo.net",
    "stellar-info.org",
    "stake-ethereum.org",
    "eth67.blogspot.com",
    "airdrop-ocean.com",
    "musk-coins.com",
    "muskprize.fun",
    "getmusk.fun",
    "spacexlive.top",
    "elonbtcx.com",
    "chain-ledger.info",
    "ledger-chain.live",
    "xn--ledgr-251b.com",
    "xn--rpple-n4a.net",
    "claim-ripple.com",
    "metamask.org-swap.app",
    "org-swap.app",
    "airdropocean.com",
    "ocean-airdrop.com",
    "bestcheinge.com",
    "lbestchenge.com",
    "uni-airdrop.info",
    "zillet.info",
    "uniswapairdrop.info",
    "uniswapofficial.com",
    "bitcoins-gift.blogspot.com",
    "eth-gift.blogspot.com",
    "metamask.bonus-erc20-token.info",
    "dice2win.co",
    "bonus-erc20-token.info",
    "yrean.finance",
    "live.ledgerorigin.com",
    "ledgerorigin.com",
    "ledger.com-client.email",
    "xn--ledgr-q51b.com",
    "keepkey.app",
    "ethgiveaways.me",
    "ethx2.io",
    "ledger.report",
    "ledger.buzz",
    "us-ledger.com",
    "usa-ledger.com",
    "ledger.us.org",
    "ledger.uk.com",
    "ledger.deals",
    "de-ledger.com",
    "fr-ledger.com",
    "it-ledger.com",
    "au-ledger.com",
    "nl-ledger.com",
    "ledger.org.pl",
    "ledgersupport.pro",
    "ledgersupport.online",
    "ledgerconnect.stream",
    "ledger-chain.info",
    "connectledger.live",
    "ledgir.xyz",
    "lebqer.xyz",
    "ledger.cam",
    "xn--edger-55a.com",
    "xn--ldgr-vvac.com",
    "xn--ldgr-lu5ac.com",
    "xn--ldger-6za.com",
    "xn--ledge-9bb.com",
    "xn--ledge-xbb.com",
    "uniairdrop.org",
    "ledger.media",
    "xn--ldger-n51b.com",
    "eth2020.top",
    "xripplex.tumblr.com",
    "btc-gift.blogspot.com",
    "cryptovitalik.s3-us-west-1.amazonaws.com",
    "rewards-tokens-airdrop.info",
    "sellcrypto.top",
    "eth.ug",
    "oldmyetherwallet.com",
    "gift-eth.info",
    "ripple.ug",
    "legder.com",
    "buterin.s3.eu-west-2.amazonaws.com",
    "giveawaysushi.com",
    "login.blockhaln.com",
    "blockhaln.com",
    "wallets-tlx-blockchain.com",
    "paradefi.network",
    "get30bnb.live",
    "pdfescape.su",
    "uniswap.org.claim-tokens-airdrop.info",
    "claim-tokens-airdrop.info",
    "aavelend.com",
    "aave-defi.com",
    "app.trieaharderewa.com",
    "bitcoinnow.bid",
    "sushiswapclasslc.org",
    "xn--bstchange-03a.net",
    "bithau.com",
    "elongift.s3.eu-west-2.amazonaws.com",
    "bitnau.com",
    "unigiv.com",
    "trustwallettoken.io",
    "metamaskwallet.io",
    "xrp-giveaway.blogspot.com",
    "uniswap.ug",
    "accountviewer.stellar.org.bi",
    "stellar.org.bi",
    "dexuniswap.org",
    "ethereum.ug",
    "uniswap-paper.s3.eu-west-3.amazonaws.com",
    "ethereumdownloads.com",
    "get-geth.org",
    "get-geth.com",
    "winnerscrypto.live",
    "uni-fund.info",
    "ripplebonus.net",
    "dexairdrop-binance.com",
    "btccham.info",
    "geminixfund.info",
    "geminidrop.fund",
    "ripplegift.ceo",
    "ada-give.info",
    "yearm.finance",
    "stellar.org.ng",
    "sushiback.com",
    "ripple.supply",
    "zillet.org",
    "chico-ethers.com",
    "login-metamask.com",
    "eventuniswap.com",
    "xrpceo.com",
    "vechainevent.com",
    "freeuniswap.com",
    "10000ethgiveaway.com",
    "bipcalculator.io",
    "uniswap-claim.com",
    "get-stellar.com",
    "zilliqa-live.org",
    "ryebit.com",
    "unigiveaway.net",
    "stellar.org.in",
    "accountviewer.stellar.org.in",
    "info-binance.us",
    "myus-app.com",
    "unigiveaway.org",
    "metamask.site",
    "trustwallet.in",
    "etherscan.member.event.monesrg.com",
    "monesrg.com",
    "musk-elon.co",
    "air-drop.us",
    "pyebit.com",
    "eth-fond.info",
    "ethget.us",
    "syebit.com",
    "unigiveaway.com",
    "accountviewer.stellar.org.za",
    "stellar.org.za",
    "uni-drop.org",
    "un2app.com",
    "fund-vechain.com",
    "chico-eth.com",
    "cryptogenscript.com",
    "officialvbuterin.com",
    "spacexfoundation.com",
    "airdropsushi.com",
    "vifbit.com",
    "zifbit.com",
    "rifbit.com",
    "sushigiveaway.com",
    "omg-airdrop.io",
    "muskbtcx.top",
    "binance-defi.net",
    "binance-smart.com",
    "unidrop.org",
    "polkawallets.site",
    "tradeintel.biz",
    "sushi-gifts.blogspot.com",
    "vbeth.com",
    "uniairdrop.com",
    "futures-binance.co",
    "uni-giveaway.blogspot.com",
    "genscripteth.go.yo.fr",
    "diubit.com",
    "teslamining.ltd",
    "riubit.com",
    "but-send.top",
    "eth-news.com",
    "swerve-finance.com",
    "czbinance.co",
    "crypto2xpool.com",
    "sushiswap.blogspot.com",
    "binance-medium.com",
    "ripplebonus.events",
    "xrp.ceo",
    "garlinghouse.ceo",
    "sushi-giveaway.blogspot.com",
    "yfi-airdrops.blogspot.com",
    "ethvv.com",
    "ethef.com",
    "ethez.com",
    "ethtd.com",
    "ethdf.com",
    "vitalik.io",
    "ethkd.com",
    "ethoy.com",
    "ethiy.com",
    "ethfc.com",
    "ethff.com",
    "cryptonil.ltd",
    "ledger.com.de",
    "rewards-coin.000webhostapp.com",
    "renairdrop.com",
    "uniswapnode.com",
    "app.uniswapnode.com",
    "drop-eth.org",
    "jdax.market",
    "supportbnb.com",
    "bin-crypto.com",
    "exiodus.com",
    "binancefound.com",
    "l1nch.exchange",
    "exoduz.io",
    "exodus.sg",
    "exodus.cm",
    "atomicwllet.io",
    "omisegoairdrop.info",
    "siubit.com",
    "linkcoinbonus.com",
    "link-token.com",
    "goairdrop.fun",
    "goairdrop.pro",
    "eth-link.site",
    "airdrop-linkchain.site",
    "airdropwallet.pro",
    "airdropwallet.site",
    "airdrop-linkchain.pro",
    "tokenlink.info",
    "trezor.com.se",
    "restore-ledger.org",
    "restore-ledgerwallet.org",
    "wallet.restore-ledger.org",
    "binance.oktaplatform.com",
    "trustswap-rewards-programs-claims-tokens.com",
    "freebitcoinmining.website",
    "omgnetwork.info",
    "atomicweb.network",
    "wallet.atomicweb.network",
    "ethfo.com",
    "tether-mixer.com",
    "ethereum-giveaway.network",
    "chainlinksgiveaways.blogspot.com",
    "stellarpay.org",
    "ethbv.com",
    "officialvitalik.com",
    "chainlink-giveaway.blogspot.com",
    "vitalikb.top",
    "vitalikbb.top",
    "app.xn--unswp-6qa5f.com",
    "xn--unswp-6qa5f.com",
    "app.xn--uniswp-0ta.com",
    "xn--uniswp-0ta.com",
    "app.xn--nswap-0ua70b.com",
    "xn--nswap-0ua70b.com",
    "morphtoken.co",
    "libraglobalcoin.io",
    "elon2.top",
    "litecoinminer.space",
    "dogecoinminer.space",
    "ethereumminer.space",
    "bchminer.space",
    "dashcoinminer.space",
    "btcminer.website",
    "tozbit.com",
    "stellar.org.lv",
    "tesla3-bonus.com",
    "defi-universe.vip",
    "marketplace.axieinfinity.com.inventoryclaim.defi-universe.vip",
    "brad-gift.com",
    "coinaxel.com",
    "eth-drop.club",
    "uniswap-exchange.com",
    "app.uniswap-exchange.com",
    "uniswap-exchange.eu",
    "app.uniswap-exchange.eu",
    "appunjswap.org",
    "appuniswop.link",
    "ethoff.org",
    "fulcrum.nu",
    "eth.fulcrum.nu",
    "eth-giveaway.top",
    "vit-ethx.top",
    "eth-vitya.top",
    "airdrop-bit.top",
    "cryptogifts.s3.amazonaws.com",
    "xrp-event.com",
    "cryptogifts.s3.us-east-2.amazonaws.com",
    "xrp-funds.com",
    "omisego-giveaway.blogspot.com",
    "omg-giveaway.blogspot.com",
    "uniswap-x.com",
    "app.uniswap-x.com",
    "stellar.org.im",
    "accountviewer.stellar.org.im",
    "cdn-stellar.org",
    "go-stellar.org",
    "steliar.org",
    "stellar.org.sb",
    "excodus.cf",
    "exodus.cf",
    "electrumy.org",
    "app.unjswap.org",
    "unjswap.org",
    "uniswap-org.com",
    "app.uniswap-org.com",
    "xn--niswap-hq8b.com",
    "app.xn--niswap-hq8b.com",
    "ethevent.top",
    "crypto-safe.ltd",
    "elonhelp.in",
    "xrp.ltda",
    "bovbit.com",
    "zelbit.exchange",
    "tevbit.com",
    "tocbit.com",
    "chipmixer.app",
    "app.unlswap.org",
    "unlswap.org",
    "coinbitmex.com",
    "buterin-gold.xyz",
    "etherh-vitalik.top",
    "check-ledger.com",
    "moonswap.exchange",
    "xn--uniswp-mta.com",
    "app.xn--uniswp-mta.com",
    "org-connect-wallet.com",
    "bizstar.icu",
    "atomicwallet.website",
    "cryptoiqoptions.com",
    "fxpectcrypt.com",
    "tradergrove.space",
    "house-article.space",
    "greece-platform.space",
    "musk-send.top",
    "btctesla.org",
    "muskgive.top",
    "space-elon.site",
    "cutve.finance",
    "appuniswop.org",
    "appuniswop.site",
    "unswap.site",
    "btcsystem-web-app.com",
    "hederabit.com",
    "nivbit.com",
    "kavbit.com",
    "jocbit.com",
    "mivbit.com",
    "xn--pxfull-pta.com",
    "trustwalletapp-erc-20-tokens.000webhostapp.com",
    "starlinkbtc.com",
    "starlinketh.com",
    "xn--bitmai-nt7b.com",
    "giveaway.is",
    "2ethereum.org",
    "spacex-eth.biz",
    "spacexethereum.net",
    "xn--niswap-oya.com",
    "metask.website",
    "wallet.metask.website",
    "spacex.click",
    "tesla-musk.net",
    "uniswapp.site",
    "altexchenge.com",
    "mycosmospay.com",
    "exoddus.net",
    "uniswap.net",
    "uniswap.eu",
    "muskto.fun",
    "musktop.pw",
    "muskevent.org",
    "huobl.ru",
    "uniswap.site",
    "metamask.eu",
    "app.xn--unswap-4va.com",
    "xn--unswap-4va.com",
    "appuniswap.live",
    "xn--unswap-xk8b.com",
    "app.xn--unswap-xk8b.com",
    "elonmuskevent.com",
    "elonmusk.network",
    "bitcoincomputos.com",
    "dshop.originprotocol.cordpidgeon.com",
    "bitfurytrade.com",
    "bitfuryweb.com",
    "bitfuryinvest.co",
    "xn--unswap-q9a.com",
    "bestchamge.ru",
    "chamathcapital.com",
    "cardano-page.org",
    "neo-live.org",
    "elonmusk.capital",
    "chamath.fund",
    "vet.capital",
    "giveeth.com",
    "appuniswap.com",
    "uniswapdex.org",
    "ethereumupdate.info",
    "ethereumofficial.org",
    "social-capital.us",
    "ethereum.ltda",
    "accountviewer.stellar.org.so",
    "stellar.org.so",
    "giveaway-eth-trustwallets.000webhostapp.com",
    "app-trustwallet.erc20-airdrop.icu",
    "erc20-airdrop.icu",
    "assets-index-files.xyz",
    "app-trustwallet.rewards-erc20-airdrop.site",
    "rewards-erc20-airdrop.site",
    "trustwallet.erc20-airdrop.icu",
    "lk.million.money.erc20-airdrop.icu",
    "maezawa-bonus.com",
    "gomusk.fun",
    "spacex.market",
    "elondrops.com",
    "elonpromo.org",
    "johnpromo.com",
    "tesla-bitcoin.info",
    "binance.rewards-programs.org",
    "rewards-programs.org",
    "lcoinbase.com",
    "etherscan.io.rewards-user-info.com",
    "zedxe.com.rewards-user-info.com",
    "rewards-user-info.com",
    "multiminer.website",
    "landcoinlnc.com",
    "appuniswop.com",
    "unisvvap.org",
    "app.unisvvap.org",
    "uniswapv1v2.org",
    "giveawayairdrop-eth.ga",
    "secretmethodsnow.com",
    "airdropbat.com",
    "muskx.co",
    "daxxcoins.com",
    "eth-event.biz",
    "blockdrops.info",
    "elon-blog.com",
    "bonus-tesla.com",
    "bitminers.store",
    "unionfinance.org",
    "exoduss.org",
    "excodus.io",
    "exsodus.io",
    "elcastrum.com",
    "basbit.com",
    "digiminer.io",
    "batairdrop.net",
    "makerdaoweb.org",
    "vitalik.top",
    "ether-promo-participate-now.com",
    "ether-promo.com",
    "bafbit.com",
    "frezor.us",
    "gemini-btc.news",
    "avaxsales.net",
    "cryptominer.tel",
    "bitcryptomania.com",
    "fundusdt.com",
    "v4-antpool.com",
    "airdrop2020.com",
    "wozbtcfunds-joinpromotion.com",
    "btcxevent.com",
    "cryptoforhealth.com",
    "xn--binnce-kta.com",
    "xn--blnnce-dd8b.com",
    "node.uniswapv1v2.app",
    "uniswapv1v2.app",
    "uniswapexchange.online",
    "xmr-wallet.com",
    "uniswop.shop",
    "tronairdrop.com",
    "stellar-limited.com",
    "verify.paxfulsupport.online",
    "paxfulsupport.online",
    "im-creator.com",
    "bitcoinmonth-top.info",
    "smartcontractbiz.com",
    "link-drop.net",
    "login.xn--blockchin-h2a.com",
    "xn--blockchin-h2a.com",
    "login.xn--blockcha-91a41g.com",
    "xn--blockcha-91a41g.com",
    "billgatesbtc.com",
    "claimbsv.to",
    "xn--bockchain-0e5h.com",
    "login.xn--bockchain-0e5h.com",
    "tesla3.gifts",
    "musk-gifts.com",
    "muskpromotion.com",
    "musk-coin.com",
    "cardanoevent.org",
    "event-eth.com",
    "adafund.pro",
    "event-ada.info",
    "cardano-info.us",
    "ethfundx.info",
    "eth-free.com",
    "brainpromo.info",
    "joerogan.fund",
    "binancefund.org",
    "brock-btc.com",
    "cardano-ada.info",
    "ethxevent-participate.com",
    "ethuman.com",
    "kanyebtc.org",
    "ethermoneymachine.com",
    "air-ether.top",
    "trezor.li",
    "xn--rezor-6db.com",
    "drop-eth.info",
    "coin-free-exchange.cf",
    "ripple.com.vc",
    "ethfree.info",
    "stellar.org.vc",
    "accountviewer.stellar.org.vc",
    "eth-info.org",
    "ada-event.info",
    "cardanoevent.com",
    "cardanofund.info",
    "adafund.net",
    "spacex-5000btc.com",
    "fundgemini.com",
    "ethfoundation.info",
    "uniswapv3.org",
    "uniswop.exchange",
    "event-eth.info",
    "fundsretrieve.com",
    "bat-airdrop.com",
    "cryptotabhack.com",
    "freebitgenerator.com",
    "tron-project.com",
    "wwwguarda.co",
    "wwwthetatoken.org",
    "hetatoken.org",
    "thetatoken.cn",
    "tetatoken.org",
    "lumiwalle.com",
    "luiwallet.com",
    "lumiwalet.com",
    "umiwallet.com",
    "lumiwallt.com",
    "lumiwallet.net",
    "lumwallet.com",
    "wwwcoinfy.com",
    "wwwlumiwallet.com",
    "lumiwllet.com",
    "thetaoken.org",
    "thetatken.org",
    "thetatoen.org",
    "thetatokn.org",
    "wwwwhitecoin.info",
    "lmiwallet.com",
    "theatoken.org",
    "thetatoke.org",
    "thtatoken.org",
    "stock-index.space",
    "finmaxbo.com",
    "tesla-give.com",
    "tesla-cryptos.com",
    "cryptos-mask.com",
    "crypto-event.com",
    "geminilive.org",
    "proether-fundsrelease-participate.com",
    "ethmarket.info",
    "geminibtc.net",
    "gemini-btc.io",
    "eth-info.com",
    "ethdropx.info",
    "bezos-amazon.top",
    "mrbeastbtc.info",
    "ethereumnews.pw",
    "jack-btc.net",
    "muskspacex.org",
    "pool.balancer.dev",
    "balancer.dev",
    "bitcoinsearchengines.store",
    "avaxweb.typeform.com",
    "elonx.co",
    "notall.eshost.com.ar",
    "notallwallet.ml",
    "bavbit.com",
    "tesla-bonus.com",
    "trez0r.com",
    "activdarto.com",
    "bit-airdrop.club",
    "compoundnode.dev",
    "lumiwalletapp.com",
    "dashwalletapp.com",
    "metamask.ltd",
    "evercoinapp.com",
    "samoraiwalletapp.com",
    "bitpieapp.com",
    "bluewalletapp.com",
    "tokenpocketapp.com",
    "paytomatwallet.com",
    "pumapayapp.com",
    "blockchainapp.ltd",
    "jaxx.ltd",
    "greenapp.ltd",
    "exodusapp.ltd",
    "coboapp.ltd",
    "atomicapp.ltd",
    "etorowalletapp.com",
    "ripplewalletapps.com",
    "crypteriumwalletapp.com",
    "trezorapp.com",
    "mewapp.ltd",
    "vladlad.com",
    "dexapis.xyz",
    "arbitragecrypto.org",
    "theapi.pro",
    "elonevent.site",
    "trustapp.ltd",
    "myrthervvellanti.com",
    "guadra.com",
    "giveaway-bit.xyz",
    "crypto-trust.co",
    "dao-migrate.com",
    "wintesla.net",
    "0101.systems",
    "bitcoinblack.cash",
    "xn--rippl-8ra.com",
    "blogstellar.org",
    "claimstellar.com",
    "xn--accountvewer-stellar-pbd.com",
    "xn--troscan-mkb.org",
    "xn--tellar-2ib.org",
    "xn--stelar-5db.com",
    "getxlm.org",
    "xn--stelar-6db.org",
    "accountviewer.xn--stelar-6db.org",
    "getripple.org",
    "xn--stllar-cpc.com",
    "xn--stllar-q3a.com",
    "xrp-community.com",
    "bithomb.com",
    "xn--bithmp-6wb.com",
    "growbitcoin.co.uk",
    "get2xcoin.com",
    "bkexcapital.com",
    "oldetherwallet.com",
    "mydashwallets.com",
    "myakawallet.com",
    "musicoinwallet.com",
    "expwallet.net",
    "dbix.link",
    "myubiqwallet.com",
    "clowallet.network",
    "myrthesrvvelltni.com",
    "linkcoinairdrop.com",
    "batairdrop.com",
    "team-blockchain.info",
    "avubit.com",
    "fulcrum.plus",
    "eth.fulcrum.plus",
    "usdc.fulcrum.plus",
    "dai.usdc.fulcrum.plus",
    "xn--ripp-yva1x.com",
    "ripple.com.bz",
    "chainlinktoken.info",
    "node-binancedex.online",
    "hexnode.online",
    "uniswapv2v1.org",
    "paxfulc.com",
    "paxful-verified.com",
    "paxfuloffers.com",
    "tronscan.me",
    "tronscan.in",
    "xn--tronsan-65a.com",
    "oauth-deriv-binary.website",
    "paxful-com-login.oauth-deriv-binary.website",
    "electrume.org",
    "fulcrum.codes",
    "xn--blocchan-cib7h.com",
    "coinbiz.me",
    "fulcrum.repair",
    "uniswap.services",
    "max-maicoin-bonusbtc.000webhostapp.com",
    "fxoption27.com",
    "lcon.foundation",
    "wallet.fantom.link",
    "fantom.link",
    "coinphant.com",
    "thetatoken.link",
    "iconfoundation.online",
    "dropelon.co",
    "btc-event.org",
    "btcmixer.tech",
    "muskevent.net",
    "muskxdrop.info",
    "musk-give.online",
    "zilliqawallet.online",
    "blockchain-auto-btc.ru",
    "wallet.trxlive.network",
    "trxlive.network",
    "foundatlon.com",
    "exodlus.io",
    "litecoln.org",
    "bitcolncore.org",
    "exodusupdate.com",
    "shrembtc.com",
    "alanbtc.com",
    "josephbtc.com",
    "fordbtc.org",
    "bransonbtc.com",
    "bloombergbtc.net",
    "exodus.com.swtest.ru",
    "elonmuskdrop.com",
    "muskbtc.us",
    "metmaask.io",
    "sonyxbtc.net",
    "nicelhash.com",
    "monnero.org",
    "guimlner.org",
    "bilinance.org",
    "nicerhash.com",
    "nlcehash.ru",
    "wozniakdrop.com",
    "tinkoffbtc.info",
    "durovairdrop.com",
    "cookbtc.com",
    "pewdiepiebtc.com",
    "etherairdrop.com",
    "panteradrop.com",
    "spacexdropx.com",
    "spacexbtcdrop.com",
    "billgatesfund.com",
    "litecoin-tumbler.com",
    "hurtrade.com",
    "hubcoi.com",
    "fixxcoin.com",
    "muskfreebtc.com",
    "ethereum-tumbler.com",
    "muskreward.com",
    "elongives.fun",
    "gaintesla.com",
    "trustwallet.claim-giveaway-airdrop.site",
    "claim-giveaway-airdrop.site",
    "airdrop-giveaway.xyz",
    "ps-btc.info",
    "xn--blockchin-c2d.com",
    "xn--blockchn-1od4993e.com",
    "xn--blocchan-g49cv1d.com",
    "investbinance.com",
    "myfusionwallet.net",
    "btcdouble2x.site",
    "coinanytime.com",
    "portal.node-binance.dev",
    "node-binance.dev",
    "portal.synthetix.dev",
    "synthetix.dev",
    "portal.hex-node.network",
    "hex-node.network",
    "portal.uniswap.dev",
    "uniswap.dev",
    "portal.curvefinance.network",
    "curvefinance.network",
    "portal.fulcrum.network",
    "fulcrum.network",
    "uniswap-exchange.repair",
    "teslagain.com",
    "zrxairdrop.com",
    "leddger.io",
    "quickbtcminer.com",
    "teslax.in",
    "app.fulcrum.repair",
    "jaxxx.io",
    "zilllet.io",
    "moonllet.io",
    "app.moonllet.io",
    "profittesla.com",
    "teslapayout.com",
    "givetesla.com",
    "teslax.live",
    "ainbit.com",
    "spacexbtc.net",
    "makerdao.redeem.bz",
    "redeem.bz",
    "sai.redeem.bz",
    "btconline.io",
    "xrpcontest.tumblr.com",
    "fovbit.com",
    "atomic.im",
    "exodus.vc",
    "paxful-ns.com",
    "paxful-sl.com",
    "my-paxful.com",
    "paxful-verifier.com",
    "paxful-fra.com",
    "bitoprowallet.000webhostapp.com",
    "ftx-com-exchange-cryptocurrency.000webhostapp.com",
    "pionex-com-exchange-giveaway.000webhostapp.com",
    "paxfulsecured.com",
    "cryptoxluck.com",
    "kucoin-info.live",
    "elon.gifts",
    "simpleswap.org",
    "getbtcx.com",
    "makerdao.redeem.fund",
    "sai.redeem.fund",
    "redeem.fund",
    "librasale.io",
    "hovbit.com",
    "officiallibracoin.com",
    "musk-event.online",
    "musk-event.tech",
    "musk-event.space",
    "teslaearn.com",
    "zalbit.com",
    "elonx.org",
    "folbit.com",
    "omisego.info",
    "muetherwallet.co",
    "btcshower.com",
    "lk.forsage.io.giveaway-token-member.com",
    "giveaway-token-member.com",
    "accountviewer.xn-stella-gib.org",
    "xn-stella-gib.org",
    "bestchanqe.ru",
    "miningbase.cloud",
    "accountviewer-stellar.com",
    "ledgerslive.web.app",
    "ledgerlivewallet.000webhostapp.com",
    "teamspacex.info",
    "tslamusk.me",
    "roberteth.com",
    "chambtc.org",
    "tslabtc.me",
    "brinbtc.net",
    "winkbtc.com",
    "brinbtc.org",
    "xrp.claims",
    "get-xrp-now.online",
    "xrp20.org",
    "barrybtc.org",
    "shrembtc.org",
    "takexrp.live",
    "xrpdrop.me",
    "xrp.work",
    "xrp.bio",
    "xrp20.com",
    "jackmabtc.com",
    "wozniak.group",
    "robertki.org",
    "gates.promo",
    "topxrp.com",
    "xrpclaim.org",
    "awayxrp.org",
    "xrptop.com",
    "xrptake.live",
    "2020xrp.org",
    "claimxrp.org",
    "20xrp.tech",
    "giveawayseptember.com",
    "receivexrp.com",
    "xrpx10.org",
    "xrpaway.org",
    "geteth.live",
    "2020xrp.net",
    "claimxrp.net",
    "awayxrp.net",
    "myxrp.org",
    "ripple.re",
    "dave-btc.info",
    "stevebtc.org",
    "cham-btc.info",
    "pantera.ltd",
    "xiaomibtc.com",
    "found-bin.com",
    "walletgenerator.net",
    "max-maicoin-claimbonusbtc.000webhostapp.com",
    "lokbit.com",
    "vaubit.com",
    "bitcoinpaperwallet.com",
    "profitmusk.com",
    "elonsave.com",
    "tony-btc.info",
    "dentacoins.com",
    "laubit.com",
    "binancechange.com",
    "royal-crypto.cc",
    "muskprofit.com",
    "etherscanner.ml",
    "wozdrop.me",
    "yaubit.com",
    "halfbit.cc",
    "bitcoinbonuswallet.com",
    "bytombit.com",
    "tesla.bz",
    "myetherwallet-inc.com",
    "etcwallet.net",
    "mastercoin.top",
    "ledgerwallet.xyz",
    "claim-token-erc20-rewards-program.com",
    "metamaks.io",
    "metadb.online",
    "mycrypto.ml",
    "myetherwallet.keynasty.com",
    "wallets.company",
    "myetherwallet-erc20token.weebly.com",
    "bitgen.pro",
    "metarnask.io",
    "giveaway.revproject.site",
    "elonmusk.financial",
    "ethereum-promo.site",
    "spacexcash.com",
    "bestchange.run",
    "applegive.club",
    "mycrypto.ga",
    "recovermycoins.com",
    "meta-mask.io",
    "faobit.com",
    "teslapromo.org",
    "xlmget.org",
    "metmamask.com",
    "metamask.info",
    "metamosk.info",
    "metamosk.com",
    "paubit.com",
    "spacexgives.com",
    "ethereumfond.com",
    "app.fulcrum.link",
    "fulcrum.link",
    "ethdrop.news",
    "maker.dao.migrate.claims",
    "migrate.claims",
    "promomusk.me",
    "myehterwaltet.com",
    "spacex.sale",
    "piutrade.com",
    "mytiethervveallet.com",
    "gmsstatistics.com",
    "yolbit.com",
    "rewards-holders-erc20-tokens.com",
    "taas.fund.rewards-holders-erc20-tokens.com",
    "spacexgiveaway.com",
    "ethdrop.org",
    "prethbonus.com",
    "ethpromo.news",
    "proethevent.com",
    "bezosxbt.com",
    "erc-20.online",
    "ethevent.us",
    "ethgift.com",
    "teslagives.com",
    "spacex.bz",
    "rewards-program-erc-20-token.com",
    "glybit.com",
    "aprilcontest.tumblr.com",
    "bezos.xyz",
    "xn--trstwallet-odb.com",
    "10xbitcoin.net.deepprofitstreams.com",
    "elonlive.org",
    "promocoinbase.xyz",
    "myelthermwallet.com",
    "asset-erc-20-token.com",
    "daostack.asset-erc-20-token.com",
    "leakedbitcoin.excelerate.co.nz",
    "nixetrade.com",
    "bitcoin.cryptogenerator.live",
    "cryptogenerator.live",
    "ethereum.cryptogenerator.live",
    "musktesla.press",
    "tesladrops.info",
    "spacexgifts.info",
    "xrpclaim.net",
    "muskfunds.info",
    "proeth-april-campaign.com",
    "ethnow.site",
    "bestcrhange.ru",
    "hofbit.com",
    "elonfund.info",
    "doubleyourbitcoin.com",
    "bitcoinairdrop.info",
    "easybitcoin.fun",
    "sso-github.com",
    "glthubs.info",
    "githb.co",
    "git-secure-service.in",
    "wallet.terzcr.com",
    "terzcr.com",
    "muskfund.info",
    "ethdrop.me",
    "lifbit.com",
    "teslagiving.com",
    "vitalik-eth.com",
    "proeth-event-april.com",
    "ethventure.com",
    "randomix.org",
    "glt-hub.com",
    "trust-wallet.me",
    "trustwollet.com",
    "xn--blnnce-yc8b.com",
    "coinbase.fund",
    "login.blcohchaln.com",
    "blcohchaln.com",
    "wallet.blockchaln.company",
    "tifbit.com",
    "ungleder.no",
    "login-trezor.io",
    "trezory.site",
    "ethairdrops.com",
    "reether.store",
    "ethlive.org",
    "teslamusk.online",
    "teslax.tech",
    "teslax.store",
    "ethchain.gift",
    "coinbasetoday.info",
    "binance.com18954761.info",
    "com18954761.info",
    "ethereum-give.com",
    "coinbase2x.pro",
    "coinbasegive.info",
    "coinbasedrop.info",
    "trading-binance.com",
    "coinbase.deposit-allow.com",
    "deposit-allow.com",
    "coinbaseverify.xyz",
    "coinbase.pro-deposit.com",
    "pro-deposit.com",
    "coinbase2x.us",
    "coinbase-bitcoin.tech",
    "bitcoincode.tech",
    "coinbasejoin.info",
    "coinbase-assist.com",
    "wallet.trczor.com",
    "trczor.com",
    "telegramcrypto.net",
    "blokchalne.info",
    "etherum.giveaway-coinbase.com",
    "bitcoin.giveaway-coinbase.com",
    "giveaway-coinbase.com",
    "jaxxupdatesupport.com",
    "trustcoin.exchange",
    "doubleway.rf.gd",
    "xtibit.com",
    "crypto-crown.ltd",
    "feex.exchange",
    "musktesla.pro",
    "bestchange.ru.bitcoin-sberbank.online",
    "spacexmusk.info",
    "musknow.info",
    "zeriontrade.io",
    "rozbit.com",
    "myledgernano.com",
    "completssl.com",
    "bitcoinsystem-app.com",
    "xn--ytherallet-to2e94ayr.com",
    "teslamusk.pro",
    "muskget.info",
    "bit-coinvestor.com",
    "bestchrnge.ru",
    "wallet-coinomi-giveaway.000webhostapp.com",
    "trustwallet.biz",
    "ledgerweb.ai",
    "spacex.bet",
    "elonmusk.market",
    "teslaevent.pro",
    "gatesfree.com",
    "muskgive.info",
    "spacex.world",
    "bestcoins.info",
    "teslamusk.group",
    "gateslive.tech",
    "billgates.capital",
    "trumpbtc.tech",
    "bezosmoney.net",
    "slmpleswap.site",
    "bestchange.space",
    "jaxx.live",
    "atomicwallet.ltd",
    "cryptonfx.com",
    "qrcodebtc.com",
    "viabtc-transaction-accelerator.com",
    "bitcoins-qr-code.com",
    "create-bitcoin-qr-code.com",
    "login.blcokchaln.top",
    "blcokchaln.top",
    "bitcoingeneratorsonline.com",
    "bitmusk.net",
    "supportve-coinbase.icu.dreamcenterinternational.org",
    "binance.com182763748.info",
    "com182763748.info",
    "bitcoindoubler2x.com",
    "bezosbit.com",
    "teslabest.info",
    "bmgfevent.com",
    "migrate.fund",
    "maker.dao.migrate.fund",
    "getnewbtc.com",
    "mdl3.top",
    "bitcoingenerat.online",
    "binance-dex.app",
    "free-bitcoin-qr-codes.com",
    "bitcoinaddresstoqrcode.com",
    "binanceprofit.com",
    "x2bitcoin.info",
    "qr-code-bitcoin.com",
    "freebitcoinqrcodes.com",
    "freewalletgiveaway.com",
    "eth-to-btc-converter.com",
    "bitcoin-transaction-accelerator.com",
    "transaction-accelerator.com",
    "btc-to-qr.com",
    "bitcoin-tx-transaction-accelerator.com",
    "bitcoin-barcode-generator.com",
    "muskgiving.com",
    "coinbase.com.nervo.co.za",
    "bitcoin-electrum.me",
    "bitcoinelon.com",
    "bitcoinpayout.net",
    "bitcoinforme.net",
    "com-bitcoins.com",
    "elon-musk.online",
    "binance-giveeth.online",
    "bitcoinelectrum.co",
    "morefreebitcoin.com",
    "elonxcoin.info",
    "binance.com158768471.info",
    "4xrp.org",
    "cnipmixer.com",
    "bliocklchain.com",
    "login-blockchanin.com",
    "eventcrypto.me",
    "eventcrypto.net",
    "muskgiving.info",
    "bestchagne.ru",
    "spacex.expert",
    "eventcrypto.org",
    "bitcoinminerpro.yj.fr",
    "mercadobitcoin.tech",
    "elonnews.online",
    "thebitcoin-code.net",
    "bitcoinelectrum.ws",
    "bitcoin-electrum.org",
    "bitcoinrising.net",
    "www.login.coinbase.com-src.cgi-bin.colnbase.site",
    "colnbase.site",
    "bitcoingives.info",
    "xn--treor-7hb.com",
    "wallets-trezor.io",
    "muskbitcoin.info",
    "bitcoinmusk.info",
    "maticbit.com",
    "musk-promo.pro",
    "tmdl3.space",
    "spacex.press",
    "spacegains.info",
    "librasecure.net",
    "blcokclnaln.com",
    "xn--localbicoins-jcc.com",
    "xn--mythrwalle-o12ej8aca.com",
    "ledger-live.com",
    "teslabitcoin.info",
    "binance-ethpromo.tech",
    "musk4.fun",
    "elonteam.space",
    "muskgive.org",
    "spacebitcoin.info",
    "muskfree.net",
    "tesladrop.space",
    "btcfminer.online",
    "ledgerhalving.com",
    "btcethtesla.info",
    "muskevent.pro",
    "muskbtc.net",
    "gram-march.com",
    "rivbit.com",
    "btczeal.com",
    "rafbit.com",
    "lorechange.com",
    "rocsbit.com",
    "blerbit.com",
    "btcethpromo.info",
    "eloneth.org",
    "btcwebminer.site",
    "300dollarsdaily.com",
    "ethereum-eth.info",
    "4musk.top",
    "elonmuskgive.net",
    "muskpromo.cloud",
    "login-bl0ckchain.com",
    "minebitcoin.club",
    "xn--locabitcoins-gcc.com",
    "btcmusk.net",
    "teslaevent.online",
    "elonlive.com",
    "btcelon.com",
    "teslalive.online",
    "teslagoods.info",
    "musk20.com",
    "grampublic.com",
    "qoloniex.com",
    "xn--chpmixer-31a.com",
    "teslateam.net",
    "teslawallet.info",
    "model3.pw",
    "ethereum-gift.neocities.org",
    "bestcoin.ltd",
    "changequick.services",
    "xn--bestchng-5za62c.net",
    "net24ex.club",
    "idex-market.net",
    "fulcrum.claims",
    "elonmusk.bet",
    "elonmusk.promo",
    "teslagives.info",
    "muskpromo.press",
    "spacetesla.info",
    "bitcoina.us",
    "nexus-crypto.com",
    "xn--bestchag-ceb20c.net",
    "xn--bstchag-t8ag20c.net",
    "xn--bstchage-4db90c.net",
    "xn--bstchan-t8ag3h.net",
    "xn--btchange-4db49d.net",
    "xn--bstchag-t8ag26b.net",
    "xn--bestchag-ceb26b.net",
    "xn--betchang-ceb78w.net",
    "eventmusk.com",
    "spacedrops.info",
    "moontrade.org",
    "moontrade.herokuapp.com",
    "btcvip.net",
    "4tesla.top",
    "myeheterrwallet.com",
    "exodus.com.ru",
    "logln-blcokchian.com",
    "getlibra.cc",
    "muskevent.info",
    "muskpresent.com",
    "ethereum-eth.ltd",
    "b-promo.online",
    "elon2020.online",
    "musk-airdrop.online",
    "xn--bstchang-b1a14b.com",
    "bestchanrge.net",
    "bit-exhcanger.xn--r-9ga.net",
    "xn--besthage-49a.com",
    "besrchange.ru",
    "elon-give.online",
    "spacexbonus.info",
    "elonmusk.world",
    "spacexdrop.info",
    "bonustesla.com",
    "muskdrop.com",
    "teslapresent.com",
    "lcgin.xn--bcokchan-6ob9076e.com",
    "xn--bcokchan-6ob9076e.com",
    "xn--bstcha-3ua59ard8p.net",
    "changequick.network",
    "24netex.life",
    "signin.blockchaln.com.18secure.host",
    "blockchaln.com.18secure.host",
    "xn--bestchage-hxb.com",
    "xn--bstchane-3cb0i.com",
    "bestchange.ru4bestchange.ru",
    "bestchange.ru5bestchange.ru",
    "bestchanrge.com",
    "xn--bestcange-4mb.com",
    "air-drop-coinbase.com",
    "droptesla.com",
    "elonx-space.com",
    "exodus.onl",
    "ledger.icu",
    "aragongift.live",
    "vertocoins.com",
    "ledger.gmbh",
    "coinbase-air-drop.com",
    "btcwebminer.trade",
    "minebitcoin.online",
    "fresh-mining.com",
    "xashmining.com",
    "spaceprize.info",
    "elonxspace.com",
    "metalfabpro.com",
    "donaldcrypto.com",
    "doubler.to",
    "xn--bstchang-3cbh.com",
    "xn--bethae-k2a2p2l5g.net",
    "elonxpromo.com",
    "rugggbestchange.ru",
    "binanceeth.space",
    "spacebonus.info",
    "changequick.digital",
    "coin-best.info",
    "365cash.today",
    "xn--etx24-7za04a.net",
    "treroz.io",
    "mybsvwallet.org",
    "getxrp.org",
    "xrp-airdrop.net",
    "jaxx.ws",
    "exodus-wallet.org",
    "ledger.ink",
    "jaxx-wallet.com",
    "webledger.dev",
    "ledgerwallet.life",
    "bonuspacex.com",
    "musksecret.info",
    "eloncrypto.io",
    "xn--btha-bpad1ski0ki7e.net",
    "ether-binance.online",
    "bestchsanges.com",
    "ledger-webwallet.com",
    "xrp2020.net",
    "grimebit.com",
    "craigsecret.com",
    "ethereumpro.eu",
    "earn2xethnow.com",
    "teslanews.life",
    "webledger.pro",
    "elongiftpromo.com",
    "elonpromo.net",
    "elongiving.net",
    "yusaku2020.org",
    "elonpromo.online",
    "vazebit.com",
    "beldexcurrency.com",
    "elonpromo.tech",
    "xn--netx24-r3a.net",
    "musk2020.fun",
    "xn--beschange-d5b.com",
    "xn--bethae-d1a0url7i.net",
    "bestchange.combestchange.ru",
    "tesladrop.info",
    "secretmusk.com",
    "cybertruck.work",
    "bonusmusk.com",
    "maker.dao.migrate.ltd",
    "maker.migrate.tools",
    "connect.maker.migrate.tools",
    "swap.makerdao.guide",
    "connect.maker.dao.migrate.ltd",
    "migrate.makerdao.guide",
    "makerdao.guide",
    "makerdao.care",
    "migrate.tools",
    "migrate.ltd",
    "ripple.gift",
    "login.blcolkchaln.com",
    "blcolkchaln.com",
    "blcckchlen.com",
    "trezor.io-wallet.com",
    "io-wallet.com",
    "xn--localbitcins-vcd.net",
    "razebit.com",
    "infinivi.io",
    "bytetrade.com",
    "bytetrade.io",
    "cgen.fr.fo",
    "cryptotabscript.online",
    "cryptotabscripts.com",
    "wallet.blockcnain.tech",
    "blockcnain.tech",
    "exodusapp.life",
    "ledgerweb.life",
    "airdrop-ethereum.com",
    "wallet.blockcnain.biz",
    "login.blockchaln.com.attp.host",
    "localbitcoins.name",
    "strainbit.com",
    "benribit.com",
    "pleinbit.com",
    "elon.vip",
    "elonpromogift.com",
    "lazebit.com",
    "elon.press",
    "teslapromo.net",
    "teslagive.net",
    "teslagive.vip",
    "elon.live",
    "musk.bet",
    "beldextrade.com",
    "musk2020.site",
    "shapeshifte.xyz",
    "login.blockchaln.company",
    "blockchaln.company",
    "login.blockchaln.com.14secure.host",
    "blockchaln.com.14secure.host",
    "blockchaln.com.13secure.host",
    "btcethgiveaway.com",
    "muskpromo.com",
    "elonxgive.online",
    "teslacoins.club",
    "muskgift.com",
    "btc-gen.site",
    "makerdao.ltd",
    "xn--betchnge-dza05j.net",
    "xn--etex24-vfb.net",
    "seriosbit.com",
    "elonbtc.info",
    "makerdao.llc",
    "makerdao.one",
    "migrate.makerdao.one",
    "makerdao.cash",
    "migrate.makerdao.cash",
    "maezawaotoshidama.info",
    "lrezor.io",
    "instant2xreward.com",
    "makerdao.click",
    "elonairdrop.com",
    "wallet.blockchaln.llc",
    "blockchaln.llc",
    "login.blockchaln.com.16secure.host",
    "blockchaln.com.16secure.host",
    "login-blockchain-com.nl",
    "beldexchange.com",
    "bestchangre.ru",
    "bit-changer.ru",
    "vitaliketh.live",
    "4musk.host",
    "elonxgive.com",
    "elongive.live",
    "muskgiveaway.com",
    "thetatoken.gq",
    "elonxcrypto.com",
    "xn--myetherwet-bhb64ea.com",
    "myetherwallet.colu.com",
    "blokchiain.com",
    "vitaliketh.com",
    "hoxbit.com",
    "free-ethereum.io",
    "elon.market",
    "tmdl3.online",
    "multisupport.live",
    "huobiglobal.live",
    "infinances.com",
    "quakebit.com",
    "etcagharta.org",
    "wallet.etcagharta.org",
    "makerdao.tools",
    "tmdl3.company",
    "login-blockchain.com.br",
    "btcgenplus.fr.fo",
    "musk.blog",
    "elonxdrop.com",
    "tesla.gift",
    "generatorapp.cf",
    "xn--beschne-pcb24tm35j.net",
    "btc-pro.ru",
    "xn--bsthnge-kwa3dys.net",
    "cash365.me",
    "xn--etex24-heb.net",
    "xn--bsthnge-kwa45amf.net",
    "xn--bethge-k2a78b9gm78y.net",
    "cash365.cc",
    "xn--bechnge-rqb88nm21m.net",
    "xn--netx24-rva.net",
    "365cash.cash",
    "xn--betchge-4kb19p751l.net",
    "best-coin.vip",
    "change-quick.us",
    "xn--ntex24-pva.net",
    "ethdropcharity.tech",
    "change-quick.vip",
    "cash-i.xyz",
    "coinbest.us",
    "xn--trezr-yua.com",
    "besrtchange.ru",
    "xn--besthng-lwa45atf.net",
    "coinbest.cc",
    "quickchange.vip",
    "365cash.us",
    "xn--bethnge-kwa45a24a.net",
    "xn--neex24-jmc.net",
    "muskfun.info",
    "elonpresent.com",
    "makerdao.live",
    "migrate.makerdao.live",
    "beldexwallet.com",
    "xn--bsthange-mbb1h.net",
    "xn--beschng-lwa20cv7f.net",
    "xn--bsthng-sta61azeh.net",
    "coin-best.me",
    "quick-change.co",
    "365cash.mobi",
    "i-cash.link",
    "xn--etex24-9eb.net",
    "bitcoinminer2x.com",
    "blockchain-script.net",
    "btc-gen.com",
    "bitcoinmining-pro.software",
    "lisane.gq",
    "shitcoinwallet.co",
    "erc20wallet.tk",
    "capitalbitsinvestments.com",
    "best-coin.world",
    "elonchris.com",
    "xn--bethane-74a9w0v.net",
    "xn--besthag-hya43amu.net",
    "xn--betchae-pcb82a7i.net",
    "xn--betchage-dqb9r.net",
    "eth-giveout.com",
    "xn--bethage-74a38cji.net",
    "xn--bethage-74a38cng.net",
    "xn--bethage-74a56c3i.net",
    "xn--besthane-38a7z.net",
    "xn--besthnge-dza29a.net",
    "xn--bsthange-28a1n.net",
    "xn--bsthange-b1a61a.net",
    "xn--bestchng-eza6e.net",
    "xn--besthng-lwa80bye.net",
    "xn--besthng-lwa9dzu.net",
    "xn--betchng-lwa9d43e.net",
    "xn--bsthang-l6a1gh.net",
    "xn--bestchag-80a2g.net",
    "xn--besthang-nbb8h.net",
    "xn--besthang-v0a83c.net",
    "xn--bstchag-2xa0gut.net",
    "xn--bstchag-2xag2g.net",
    "xn--bstchag-9za05aha.net",
    "cash365.vip",
    "xn--bstchage-10a9g.net",
    "i-change.co",
    "i-cash.cc",
    "blockchainscript.net",
    "cryptotabscript.com",
    "multicoinminer.fund",
    "xn--myeterwaet-h0bau.com",
    "login.blcorkchein.com",
    "blcorkchein.com",
    "coinbase-xmas.com",
    "xmasgive.info",
    "trezor.world",
    "xn--trzr-cpa7e.com",
    "ripplelabs.space",
    "elonchristmas.com",
    "coinbasexmas.com",
    "xmasbtc.com",
    "xn--besthage-38a62d.net",
    "xn--bethange-28a25f.net",
    "i-change.online",
    "change-quick.xyz",
    "elonchristmas.net",
    "elonxmas.net",
    "lledger.io",
    "leedger.io",
    "mcafeechristmas.net",
    "mcafee2020.xyz",
    "emusk.host",
    "musk.one",
    "airdropxrp.com",
    "bitcoinx10.cloudaccess.host",
    "xrpdoubler.us",
    "shopzoro.co.uk",
    "xrpchristmas.com",
    "trezors.io",
    "blockchainsevent.claim-free-btc.com",
    "airdrop-stx-blockchain.info",
    "coinbase-promo.info",
    "login.lblockhcoin.com",
    "lblockhcoin.com",
    "login-bllockchain.com",
    "brestchange.ru",
    "site-blockchain.jdevcloud.com",
    "myehterwalltet.info",
    "lastchance.tech",
    "etherflyer.com.claim-tokens-erc-20.com",
    "claim-tokens-erc-20.com",
    "trezors-wallets.com",
    "elongiftcrypto.com",
    "instanbtc.site",
    "freebitcoinminer.org",
    "bitcoinminer-pool.com",
    "bitcoinfast.xyz",
    "bitcoinpoolmining.xyz",
    "login.lbloclkchoin.com",
    "lbloclkchoin.com",
    "doublebtc3hours.com",
    "multibit.app",
    "freebtcminer.org",
    "btcgenerator.pro",
    "giveaway5000.com",
    "biockchoin.info",
    "block-chain-id.joomla.com",
    "bittrex-yds.com",
    "rnjelherwallet.com",
    "btcfree.pro",
    "coinbasegive.net",
    "stellardrop.com",
    "mercatox2xbonus.com",
    "bitcoindoubler.tech",
    "upgradesai2dai.com",
    "xn--bstchnge-neb8176e.net",
    "xn--bestchge-dqb3626e.net",
    "xn--bstchane-10a01d.net",
    "stellar.us.com",
    "coinbase12.info",
    "cash-coinbase.com",
    "coinbase-cash.com",
    "elonbiz.host",
    "btcfastmining.xyz",
    "musk-btc.com",
    "elonbonus.info",
    "trezgr.io",
    "wallet.trrezor.com",
    "trrezor.com",
    "xn--bestcange-u85d.com",
    "xn--bstchange-03a.com",
    "xn--bestchang-83a.com",
    "xn--besthnge-49a5586e.net",
    "beldexcoins.com",
    "mcafeegiveaway.com",
    "btc-on.com",
    "ripple-gifts.online",
    "coinbasegrant.com",
    "btc-prize.com",
    "trezcor.com",
    "trezor-io.co",
    "wallet.trezor-io.co",
    "xrp2020.com",
    "mcafee2020.online",
    "btc-coin.online",
    "coinbasec.com",
    "coinbase50m.com",
    "ripple-airdrop.org",
    "btcmust.com",
    "elonmuskgo.com",
    "bnbgift.info",
    "binancegiveaway.site",
    "erc-20-token.com",
    "sai2dai.pro",
    "musknews.info",
    "wallet.trezore.io",
    "trezore.io",
    "coinbasego.com",
    "tronnet.network",
    "xrplike.com",
    "zn--trezr-mua.com",
    "ledqer.net",
    "ledgers.com",
    "xn--bestchane-xkb.com",
    "givexrp.net",
    "2020mcafee.info",
    "upbitcoin.info",
    "xn--bestchane-2lb.com",
    "xn--betchange-w1b.com",
    "sai2dai.link",
    "xmrqrcode.com",
    "bonusbtc.net",
    "hitbrc.ru",
    "geminieth.com",
    "e-deals.online",
    "btc50x.info",
    "tesla-3.online",
    "elonbiz.site",
    "coinbaseup.com",
    "login.bilockchoin.com",
    "bilockchoin.com",
    "bittrexthankgiving.com",
    "airdropex.site",
    "mychainlink.org",
    "xn--betchane-dgb84d.com",
    "biggest-airdrop.top",
    "dai2sai.exchange",
    "sai2dai.exchange",
    "airdropdex.site",
    "xn--treor-wib.com",
    "trerzor.io",
    "btcgift.pro",
    "claim-stellar.info",
    "coinbase5k.com",
    "receipt.invoice.reward-ethereum.cf",
    "reward-ethereum.cf",
    "receipt.invoice.eth-referral-airdrop.ml",
    "eth-referral-airdrop.ml",
    "eleckctrum.org",
    "dai2sai.app",
    "sai-to-dai.com",
    "3mdl.space",
    "zilliqa-network.com",
    "geminieth.live",
    "freebtc-drop.live",
    "xn--bestchage-1vb.net",
    "xn--bstchange-0ib.net",
    "xn--betchange-12b.com",
    "xn--betchane-dgb84d.net",
    "xn--besthange-jeb.com",
    "ledgre.com",
    "myetherwallet-getextratoken.000webhostapp.com",
    "triezor.io",
    "ldexmarket.ru.com",
    "margineth.online",
    "bloom.reward-programs.erc20-tokens.com",
    "erc20-tokens.com",
    "exchange.bnbdex.top",
    "bnbdex.top",
    "wallet-thetatoken-extrabonuses.000webhostapp.com",
    "wallet-thetatoken-claim-extra-bonuses.000webhostapp.com",
    "wallet-thetatoken-bonuses.000webhostapp.com",
    "wallet-thetatoken-extrabonuses-erc20.000webhostapp.com",
    "get-extra.tk",
    "next.get-extra.tk",
    "myetherwallet-getfreetoken.000webhostapp.com",
    "get-extra.ml",
    "myetherwallet.rekllama.com",
    "vintage-myetherwallet.telegram-airdrop.com",
    "telegram-airdrop.com",
    "coinxback.com",
    "cryptocloudx.com",
    "saitodai.app",
    "cryptoback.org",
    "trezor.bz",
    "wallet.trezor.bz",
    "bedstchange.pp.ru",
    "xn--bestchnge-51a.net",
    "xn--betchange-6ld.net",
    "3mdl.pw",
    "trezor-info-wallet.musicfestes.com",
    "muskbonus.info",
    "cyber-tesla.com",
    "3mdl.pro",
    "ldexmarket.xyz",
    "btc5k.com",
    "crypto-giveaway.com",
    "ldexmarket.info",
    "muskgives.info",
    "bitmusk.info",
    "2020btc.site",
    "mew-offlclal.info",
    "xn--bestchage-mwb.net",
    "bestchange.page",
    "reward-crypto.com",
    "spacexbit.net",
    "spacexbit.info",
    "terezor.io",
    "wallet.terezor.io",
    "treezor.io",
    "elonmuskgift.com",
    "trezor-wallets.cc",
    "trrezor.io",
    "trezor.promo",
    "eilectum.org",
    "lerger.cf",
    "localbitcoins.com.0fficial-localbitcoins.website",
    "0fficial-localbitcoins.website",
    "official-localbjtcoins.website",
    "mewmyetherwallets.com",
    "official-mcafee.me",
    "elonbonus.com",
    "idex-market.space",
    "sai2dai.com",
    "wallet.trezcr.com",
    "trezcr.com",
    "neosmarteconomy.netlify.com",
    "leedger.info",
    "ovdan.com",
    "legder.co",
    "xn--trezr-gua.com",
    "blockchain.info.rekllama.com",
    "login.blockhiean.com",
    "blockhiean.com",
    "ehterdelta.ru.com",
    "binance-cz-promo.netlify.com",
    "ripple.ooo",
    "chainlinktoken.net",
    "chainlink-info.pro",
    "claim-erc20-token-bonus.ga",
    "bancor-network.ga",
    "crypto-reward.com",
    "intrenational.bjtftrex.com",
    "bjtftrex.com",
    "2xbonus.live",
    "coinbaseteam.com",
    "idex-market.info",
    "geteth.site",
    "binancefutures.online",
    "crypto-generat.ml",
    "myetherwallet-giveaway.000webhostapp.com",
    "extra-bonuses.ga",
    "official-ethers.com",
    "login.bllockhaiin.com",
    "bllockhaiin.com",
    "idexmarket.art",
    "hellogold.in",
    "steemeth.com",
    "beentrade.org",
    "coinspin.net",
    "bitlare.com",
    "uni-pouch.com",
    "elon-get.com",
    "lite.foundation",
    "ripple.expert",
    "3tesla.info",
    "coinsmax.live",
    "4ltc.su",
    "get-xrp.online",
    "freebtceth.com",
    "wp.locallbittcoins.net",
    "locallbittcoins.net",
    "myetherwallet-extra-bonuses.000webhostapp.com",
    "extra-bonuses.gq",
    "next.extra-bonuses.gq",
    "dex-start.net",
    "teslamusk.info",
    "3tesla.club",
    "elonmusk.tk",
    "ethersaway.net",
    "try-ethers.com",
    "tesla3.link",
    "elon-crypto.me",
    "eth-get.org",
    "ethplode.live",
    "mygram.pro",
    "gramsale.org",
    "mc2020get.com",
    "mcf-crypt.net",
    "4tesla.biz",
    "elon-crypto.online",
    "tesla3-now.com",
    "model3.space",
    "mcafee-crypto.com",
    "elon-crypto.net",
    "4tesla.pro",
    "elontesla.info",
    "tesla3.promo",
    "chianlink.io",
    "wallet.chianlink.io",
    "claimlink.org",
    "wallet.chianlink.org",
    "chianlink.org",
    "wallet.xn--chainlik-o99c.com",
    "xn--chainlik-o99c.com",
    "earnxrp.live",
    "tron-network.live",
    "btc-titan.com",
    "uminer.net",
    "2xcoin.live",
    "multicoinsminer.fund",
    "claimbtc.org",
    "elonspace.online",
    "xrpinsights.live",
    "ethaget.com",
    "coinxkeep.com",
    "cravetrade.com",
    "investmentworld.site",
    "bondinvest.site",
    "lidex.market",
    "binancebnbgive.com",
    "eth-charity.tech",
    "tonpresale.com",
    "ethget.org",
    "ildex.host",
    "blittrex.intrenational.com",
    "lcgin-blockchian.com",
    "blcolchian.lcgiln.com",
    "lcgiln.com",
    "blocckchainn.com",
    "binance.bnbnetwork.icu",
    "bnbnetwork.icu",
    "ethereumfreemining.com",
    "exchange.jerseyrelease.services",
    "jerseyrelease.services",
    "binance.jerseytrade.icu",
    "jerseytrade.icu",
    "chianlink.com",
    "wallet.chianlink.com",
    "localbitcolns.net",
    "binance.marketjersey.icu",
    "rippleinsights.live",
    "cryptogrowth.live",
    "login.blolockhain.icu",
    "blolockhain.icu",
    "ehterdelta.host",
    "thelibrasale.com",
    "xn--login-blockchan-wj5h.com",
    "xn--login-blockchn-dmb79a.com",
    "btcgen.io",
    "trx-ethgiveaway.com",
    "karlken.com",
    "bilttrex.intrenational.com",
    "intrenational.com",
    "upbitgift.com",
    "xrpdrop.fun",
    "rippleinsights.tech",
    "login.blolckchaln.com",
    "blolckchaln.com",
    "blcolchian.lcgjrn.com",
    "lcgjrn.com",
    "xn--leder-y1a.com",
    "login-blockchain.com.mx",
    "quickinv.com",
    "mcafee-prize.online",
    "bakkt-event-start.netlify.com",
    "spacexbit.com",
    "unruffled-shockley-1db491.netlify.com",
    "t3md.net",
    "earnbros.com",
    "m2020.me",
    "rippleinsights.pro",
    "ton-ico.com",
    "claim-btc.com",
    "medium-crypto.tech",
    "bakktgift.info",
    "chainlink.webcindario.com",
    "coinbasecrypto.tech",
    "xrp-promo.tech",
    "bakkt-celebration.netlify.com",
    "bonuscoinbase.com",
    "bakkt-give.org",
    "bakktget.com",
    "bakkt.wz.cz",
    "btcdrops.net",
    "promobakkt.com",
    "bakktlaunch.com",
    "bololckhain.com",
    "login-bloclknainn.com",
    "newcryptogift.com",
    "dex-get.net",
    "extra-rewards-bonus.com",
    "muskbit.com",
    "blockchain5th.com",
    "ltdex.market",
    "dogechain.org",
    "exodus.icu",
    "ton-telegram.net",
    "freebakkt.com",
    "libratokensale.com",
    "getbabb-claims.exclusive-extra-bonuses.com",
    "exclusive-extra-bonuses.com",
    "claims-token-erc20.exclusive-extra-bonuses.com",
    "xrpcompetition.live",
    "bithumb.live",
    "spacexfree.com",
    "cryptogood.000webhostapp.com",
    "delltrade.com",
    "yobit.website",
    "netexcoins.com",
    "highcoin.net",
    "coinbascet.com",
    "chartrade.com",
    "tradeberry.org",
    "billaxy.com",
    "cryptonex.uk",
    "hyptrade.com",
    "wintraders.net",
    "coinrexo.com",
    "exmofit.com",
    "xn--stllar-cva.org",
    "xn--mdium-n51b.com",
    "claimlumens.org",
    "xn--stllr-6wa7j.org",
    "ledger-live.co",
    "ledger-ad.com",
    "wallet.my-trezor.com",
    "my-trezor.com",
    "snegir-shop.ru",
    "tokenairdrops.net",
    "idexmarket.info",
    "xn--localitcoins-bh4f.net",
    "ddexbit.com",
    "secure-ledger.com",
    "ethereumatlantis.network",
    "btcethgift.com",
    "blockkchain.ru",
    "login.bllocklnain.com",
    "bllocklnain.com",
    "mcf2020.net",
    "tmdl.info",
    "xn--stellr-tta.org",
    "xrpgift.live",
    "login.blogchain.icu",
    "blogchain.icu",
    "login.bllcoklnain.com",
    "bllcoklnain.com",
    "yourlibra.net",
    "atlantis-wallet.com",
    "go-testnet.com",
    "info-dex.com",
    "biboxgive.com",
    "toreovonline.uk",
    "blockcchain.ru",
    "ethereumclassic.bonus-programs.com",
    "bonus-programs.com",
    "myetherwallet.com-wallet-transactions.host",
    "com-wallet-transactions.host",
    "trezor.blog",
    "doubleinv.com",
    "medium-crypto.xyz",
    "idtex.market",
    "hitbtc.su",
    "blcckchian.com",
    "ethereumboston.com",
    "5000-btc.com",
    "loqin.blcakchian.com",
    "blcakchian.com",
    "blockchailn.biz",
    "exchange.bnbmx.services",
    "event.exchangemarket.services",
    "coinbase-promo.net",
    "drop-crypto.org",
    "libra-coin.cc",
    "thevidbit.com",
    "binance.launch-usa.net",
    "launch-usa.net",
    "coinbase-bonus.net",
    "bitcoingenerator.com.ru",
    "b-lockchian.com",
    "ehterdetla.com",
    "btc10.org",
    "tornado.best",
    "binance-test.org",
    "vintage.myethewallet.online",
    "myethewallet.online",
    "login.blackchair.info",
    "blackchair.info",
    "linkairdrop.com",
    "vipmagija.com",
    "kungmedia.com",
    "btcandeth.com",
    "dropkraken.com",
    "binance-get.org",
    "project2019.services",
    "bloclkchain.net",
    "coinbase-prize.com",
    "idex.net.ru",
    "gram-chain.com",
    "etherdelta.net.ru",
    "win-coinbase.com",
    "tokengiveaway.in",
    "finalgiveaway.com",
    "coinbasewin.com",
    "coinbase-reward.com",
    "bttfinex.ru",
    "bitdegree-claims.bonus-client.com",
    "bonus-client.com",
    "cryptousd.host",
    "earncrypto.xyz",
    "cryptxbit.pro",
    "btcjob.pw",
    "cryptoex.icu",
    "cryptocoin24.site",
    "musk.ml",
    "crypto-airdrop.org",
    "coinbasegiveaway.com",
    "lucky-binance.com",
    "exchange.bnbdexevent.services",
    "bnbdexevent.services",
    "bin-us.com",
    "bitshumb.com",
    "bnbmarket.services",
    "exchange.bnbmarket.services",
    "event.exchangejersey.top",
    "exchangejersey.top",
    "exchange.webjersey.top",
    "webjersey.top",
    "binance.marketlaunch.site",
    "marketlaunch.site",
    "exchange.projectdex.top",
    "projectdex.top",
    "wwwelectrum.org",
    "blcokchian.licgin.com",
    "licgin.com",
    "idex.ru.net",
    "bitmartgive.com",
    "freecryptoevent.com",
    "muskgive.com",
    "xn--stllar-x4a.org",
    "lauchesevent.services",
    "tronetwork.live",
    "cryptobridges.com",
    "eth-drop.org",
    "get-back.site",
    "bcash-promo.org",
    "coinbasepromotion.com",
    "mytethwellet.com",
    "kutixtoken.com",
    "myaetherwellat.com",
    "ktx.typeform.com",
    "ideex.pw",
    "btc-coinbase.com",
    "gwayaugust.blogspot.com",
    "intenrational.bfttrex.com",
    "litecoingiveaway.info",
    "bfttrex.com",
    "ethberlin.org",
    "coinbasegive.com",
    "muskelon.ga",
    "rippleairdrop.club",
    "myetherwallet.signtransaction.co",
    "signtransaction.co",
    "zendesk-news.com",
    "litecoinairdrop.club",
    "bllockchain.ga",
    "5000-coinbase.com",
    "binance-airdro.online",
    "ltccontest.com",
    "litecoin-giveaway.org",
    "satoshi-litecoin.netlify.com",
    "top-coinbase.com",
    "pultegive.com",
    "ethereum-bounty.live",
    "ripplebounty.live",
    "ripple-give.net",
    "medium.xrpairdrop.website",
    "xrpairdrop.website",
    "best-event.host",
    "mcafee2020-airdrop.netlify.com",
    "charlieleedrop.net",
    "ltc-give.org",
    "2019giveaway.net",
    "ctoken.info",
    "binance.newproject.site",
    "newproject.site",
    "zendesk-binanc.com",
    "binancekyc.com",
    "coinkanon.com",
    "bit7880.com",
    "bitcoin-address-cracker.bit7880.com",
    "www-ideex.market",
    "idleax.market",
    "bitmex-blog.info",
    "eth-send.tech",
    "blcokchian.lcgljn.com",
    "lcgljn.com",
    "dropcoinbase.com",
    "augustcontest.blogspot.com",
    "xn--localbitcons-jfbf.net",
    "airdrop-mcafee.tech",
    "crypto-promo.store",
    "ethereumprize.pro",
    "plus-ethers.com",
    "kucoin.live",
    "b-nance.com",
    "coinbase.gifts",
    "www-idaex.market",
    "btc-drop.com",
    "promo-coinbase.com",
    "get-mcafee.me",
    "mcafeegiveaway.net",
    "mcafeetoday.com",
    "john-mcafee-events.com",
    "get-mcafee.press",
    "cryptofans2019.com",
    "coinbase-promotion.com",
    "coinbase-news.com",
    "btc-bonus.com",
    "myetherverify.com",
    "forkdelta.id",
    "forkdelta.co.uk",
    "forkdelta.club",
    "ethereum-mixer.org",
    "feathercoin.top",
    "myethdex.com",
    "ethcombo.com",
    "locaibitcoins.net",
    "giveaway-transfer.com",
    "decentralized-exchange.info",
    "mcafeenow.net",
    "www-ldax.market",
    "dveryirazdvyzhniesystemy.com",
    "binance.dexmx.site",
    "www-idlex.market",
    "idexmarket.live",
    "mcafeedrop.com",
    "airdrop-mcafee.online",
    "get-mcafee.space",
    "mcafeegroup.org",
    "xn--localbtcoins-jfbb.net",
    "blonckhian.com",
    "perlin.in",
    "trezor.team",
    "brave-bounty.com",
    "5000crypto.com",
    "exchange.eventsolutions.top",
    "coinbasegives.com",
    "coinbasegold.com",
    "coinbase-5000.com",
    "coinbase-drop.com",
    "teamofbinance.com",
    "neoaugust.blogspot.com",
    "binance.jerseyexchange.site",
    "jerseyexchange.site",
    "litecoinpromo.netlify.com",
    "exchange.webdexlaunch.top",
    "webdexlaunch.top",
    "ethereum-airdrop.netlify.com",
    "get-binance.org",
    "get3tesla.space",
    "calibra-ico.info",
    "binancefree2018.droppages.com",
    "binance.newrelease.site",
    "5000coinbase.com",
    "coinbasebtc.atspace.cc",
    "coinbasebonus.net",
    "coinbasegift.epizy.com",
    "transaction-verification.tech",
    "coinbase-team.com",
    "btc-generator.club",
    "idekx.market",
    "vip.kelireqa.xyz",
    "muskelon547776.webcindario.com",
    "muskelon.net",
    "airdrop-crypto.com",
    "promotion-crypto.com",
    "coinbasegift.net",
    "ethereum4th.org",
    "drop-crypto.com",
    "coinbasetop.com",
    "coinbase.promo",
    "100kbtc.com",
    "binance10x.epizy.com",
    "ethereumpromo.epizy.com",
    "2019giveaway.com",
    "gram-net.org",
    "5000btc.gift",
    "promo-binance.netlify.com",
    "btc.wz.sk",
    "myellthevwaallet.com",
    "mcafeebtc.net",
    "buterineth.net",
    "fastprofitableoptiontrade.com",
    "ethereum4th.com",
    "conn-view-wallet.info",
    "myetherwallet.conn-view-wallet.info",
    "top-binance.com",
    "news-bnb.org",
    "neofoundation.blogspot.com",
    "eventbinance.com",
    "xn--blockcain-lmb.com",
    "hiverzone.com",
    "elonmuskcrypto.webcindario.com",
    "binance-margin-launch.com",
    "anycoins.club",
    "mcafees-redemption.netlify.com",
    "calibra-token.info",
    "now5000.com",
    "crypto-drop.org",
    "crypto-promo.net",
    "cryptoextravaganza.online",
    "donalt.livetrades.vip",
    "biitmrt.com",
    "coinbasepromo.epizy.com",
    "win-binance.com",
    "crypto-extravaganza.store",
    "drop-binance.com",
    "gift-binance.com",
    "huobipartners.com",
    "mn-r.store",
    "token-1.com",
    "coinbase.token-1.com",
    "huobiglobal.ltd",
    "zendesk.huobiglobal.ltd",
    "binancebtc.epizy.com",
    "upbit.sale",
    "binance-updates.com",
    "btc5000.epizy.com",
    "promobinance.net",
    "30f3000f-5f1f-4dee-af2d-0b7a6159f4c0.htmlpasta.com",
    "3365cad5-455b-4ed0-a944-2b9bd0191501.htmlpasta.com",
    "0978f655-465b-4434-99fb-f8357c7bca4b.htmlpasta.com",
    "airdrop2.com",
    "get-crypto.tech",
    "dietologicheskoepit.space",
    "binance5000.epizy.com",
    "btcfast.net",
    "transaction-sends.tech",
    "btc-drop.net",
    "coinbasepromo.net",
    "mgctoken.biz",
    "mgctoken.org",
    "binance5000.info",
    "bigpromo.net",
    "5000btc.org",
    "calibra-token.com",
    "calibraico.com",
    "calibra-ico.com",
    "bakkt-btc-event.netlify.com",
    "buylibracoins.com",
    "mcafee-official.net",
    "mcafee-eth.netlify.com",
    "mcafee-btc.netlify.com",
    "calibra-ico.net",
    "tron-official-btc-promo.netlify.com",
    "crypto-promo-get.tech",
    "tron-foundation-redeem.netlify.com",
    "5000giveaway.com",
    "coinbasegift.com",
    "binance-margin-new.com",
    "5000get.com",
    "get3tesla.org",
    "litenet.ltd",
    "5000promo.net",
    "cryptoclub247.com",
    "btcpresent.net",
    "binancevisit.net",
    "thecryptobonus.com",
    "mdl3.org",
    "easybinance.com",
    "crypto-promotion-get.online",
    "tesla-promo.netlify.com",
    "binancegiveaway.top",
    "binancebegin.com",
    "binancefeast.org",
    "drop5000.com",
    "crypto-promotion-get.tech",
    "5000btc.net",
    "blockchain-exploit.site",
    "btc10x.org",
    "binance2019.com",
    "binancefeast.net",
    "2binance.com",
    "binance2yo.com",
    "mybinance.net",
    "localbitcoins.com.digicerts.live",
    "20eth.org",
    "binclic.com",
    "binancepro.epizy.com",
    "mcafee-official-comeback.netlify.com",
    "official-service.online",
    "binancefunds.com",
    "binancetoday.net",
    "julyneo.blogspot.com",
    "innovamine.ltd",
    "cryptoplay.world",
    "binancegiveaway.net",
    "20btc.net",
    "binance-gift.pro",
    "binancewin.com",
    "20eth.com",
    "crypto-event.host",
    "dropbinance.com",
    "xrpx2july.blogspot.co.ke",
    "giftbinance.com",
    "anniversary-eth.com",
    "dropfestextravaganza.tech",
    "fly-promo.online",
    "binpromo.net",
    "cbn-project.com",
    "biltmain.com",
    "binance-team.com",
    "binanceteams.net",
    "binance2.epizy.com",
    "xrpx2july.blogspot.com",
    "binance-gives.com",
    "binance2.vip",
    "5000drop.com",
    "getpromo.me",
    "anniversary-binance.com",
    "dothereumwallet.net",
    "gramton.pw",
    "getbuterin.org",
    "binance20.org",
    "binan-marginal.com",
    "idnex.market",
    "promo-extravaganzza.tech",
    "binancegift.org",
    "win-giveaway.com",
    "crypto-extravaganza.tech",
    "livebinance.com",
    "btcfast.org",
    "binancesuper.net",
    "bitcoindrop.org",
    "eth10.top",
    "binancefree.net",
    "official-drop.club",
    "binancepromo.epizy.com",
    "airdropbtc.epizy.com",
    "binanceclub.rf.gd",
    "crypto-promo.com",
    "giveaway-btc.net",
    "promocrypto.net",
    "binancev2.live",
    "binance-btc.neocities.org",
    "eth30.org",
    "binance-promo.netlify.com",
    "x2neojuly.blogspot.com",
    "celebration-binance.netlify.com",
    "bitcoingift.net",
    "elon-musk.xyz",
    "bllockchain.tk",
    "hiltbtc.com",
    "login.bilockcnain.com",
    "bilockcnain.com",
    "starkdex.net",
    "mew.starkapp.net",
    "starkapp.net",
    "dextestnet.info",
    "eth20.org",
    "binance-bit.net",
    "extravaganza-event.website",
    "teslapromo.info",
    "xn--githu-k90b.com",
    "ethbuterin.com",
    "best-event.site",
    "airdrop.best-event.site",
    "xn--medum-1sa.com",
    "binannce.net",
    "news.binannce.net",
    "myetherewallet.io",
    "giveaway-crypto.tech",
    "binancepromo-now.online",
    "bitcoindrop.net",
    "binance-claims.netlify.com",
    "eth-btcpromotion.online",
    "ethcharity.net",
    "ethprize.net",
    "mcafee.airdrop-event.fun",
    "airdrop-event.fun",
    "doubleethereum.cc",
    "hitbtc.co.ua",
    "coinbasepro10000.webcindario.com",
    "neojulyx2.blogspot.com",
    "ethdrop.net",
    "eth.gift",
    "eth-link.info",
    "chainlink.pro",
    "claimwallet.org",
    "gram-ton.com",
    "ripplesupport.org",
    "6602c412-67f3-4725-92eb-5c2ebb2c6166.htmlpasta.com",
    "d6513d71-ee0e-41c3-8bda-83587ac4e863.htmlpasta.com",
    "johns20190gift.tumblr.com",
    "zendesk-bnb.org",
    "login.blodchain.com",
    "blodchain.com",
    "ethereum-verify.website",
    "login.blocickchairn.com",
    "blocickchairn.com",
    "mew.starkwallet.org",
    "starkwallet.org",
    "bip39.info",
    "bip39tools.com",
    "electrum.org-secure.app",
    "claimlink.online",
    "org-secure.app",
    "refereum.com.erc-20.claims",
    "erc-20.claims",
    "bigdrop.pro",
    "medium.exchange-promo.fun",
    "exchange-promo.fun",
    "pompliano-promo.netlify.com",
    "coinbase.getforge.io",
    "more-getback.site",
    "dothereum-polkadot.net",
    "ripplecompetition.com",
    "junecoinsx2.blogspot.com",
    "cryptexplatform.com",
    "coineplus.com",
    "ecptoken.com",
    "zendesk-bnb.com",
    "vitalik-gives.website",
    "stopp.com.au",
    "promo-from-buterin.site",
    "bnb-zendesk.com",
    "neojunex2.blogspot.com",
    "e3c01d47-32d5-417d-86a5-6484412fd477.htmlpasta.com",
    "xn--calbra-yva.com",
    "zilliqa.tech",
    "cryptosupport.live",
    "idax-market.ru",
    "myeltherewallet.com",
    "blockchairnew.info",
    "starcoine.com",
    "cryptohype.world",
    "eths.gift",
    "mcafee.airdrop-promotion.host",
    "airdrop-promotion.host",
    "apompliano.netlify.com",
    "now-ethers.com",
    "official-promo.pw",
    "official-promo.pro",
    "tesla-promo.epizy.com",
    "airdrop-sale.online",
    "airdrop-main.info",
    "bitfinex.click",
    "official-events.site",
    "myelthwaltter.com",
    "bigclaim.pro",
    "electrumus.com",
    "blog.decentralized-exchange.org",
    "decentralized-exchange.org",
    "neojune.blogspot.com",
    "medium.bitcoin-gain.org",
    "bitcoin-gain.org",
    "sf520pk.com",
    "lianjiedu.com",
    "coinexminer.site",
    "bit-donor.com",
    "bnb-launch.com",
    "mediumcdn.today",
    "mcafee.crypto-airdrop.space",
    "crypto-airdrop.space",
    "teslamusk.tech",
    "58b48d07-110c-487e-8a77-938cfaa8af18.htmlpasta.com",
    "mcafee-promo.com",
    "mcafee-crypto.tech",
    "coin2coin.co",
    "receive-ethereum.website",
    "com-eth.top",
    "binance.com-eth.top",
    "binance-trade.com",
    "musk-event.info",
    "binance-presents.fund",
    "airdrop.center",
    "get-eth-free.com",
    "brave-browser.info",
    "mcafee.site",
    "john.mcafee.getforge.io",
    "binance-app.org",
    "news.binance-app.org",
    "mythwalter.com",
    "logn.life",
    "poloniex.com-account-login.logn.life",
    "com-account-login.logn.life",
    "margin-bintestnet.com",
    "mcafee.getforge.io",
    "newetherewallets.com",
    "ether-return.com",
    "elon-musk.getforge.io",
    "coinexplorer.tech",
    "www-myethenrwallet.com",
    "rnewetherwallet.com",
    "rrryehlerewvallet.com",
    "ildexmarket.pw",
    "news-bnb.com",
    "origin.foundation",
    "cloudtokenexchange.com",
    "blockchaincomexplorer.z13.web.core.windows.net",
    "cryptotronx.com",
    "xn--coinbse-dwa.com",
    "no-replycoinbase.com",
    "hmrcmeclaim.com",
    "mycrypto-wallet.info",
    "dogepay.info",
    "iddex.pw",
    "localbilcolns.net",
    "bnb-testnet.org",
    "jerseylaunches.icu",
    "dexcompetition.site",
    "cryptoxglobal.com",
    "buyeth70.jdevcloud.com",
    "xcoinback.com",
    "eth.elon-musk-tesla.space",
    "elon-musk-tesla.space",
    "btc.elon-musk-tesla.space",
    "tortoken.io",
    "secure.globalsec.icu",
    "doublebitcoin.ga",
    "globalsec.icu",
    "lldex.pw",
    "id-ex.pw",
    "binance-client.com",
    "reddit-securepage-hdsjhg3jh5gjasged32h4i2349803434553.secglobal.icu",
    "secglobal.icu",
    "reddit-securepage-hdsjhg3jh5gjasged32h4i23496jhgh677u.secglobal.icu",
    "blackchoin.info",
    "myrlherwallet.com",
    "iidex.pw",
    "myethirwailets.co",
    "binance-margin.com",
    "cryptogiveaways.top",
    "lidex.pw",
    "tokensmarket.online",
    "telos-fundation.io",
    "mycofterwallet.com",
    "xn--blokchan-u0a8d.com",
    "myethherewallet.com",
    "promo-tesla.store",
    "ldexmarket.pw",
    "eth.elonmusk-tesla.space",
    "elonmusk-tesla.space",
    "teslastore-giveaway.online",
    "buy7btc.online",
    "buy7btc.pro",
    "tenocrypt.com",
    "elon-spacex.promo",
    "elon-spacex.com",
    "elon-spacex.online",
    "elon-spacex.store",
    "giveawaytesla.me",
    "vwv-binance.com",
    "tebestina.info",
    "elon-tesla.info",
    "walletgenerator.org",
    "bnb-binance.com",
    "www-vntage-myetherwallet.com",
    "www-vintage-myetherwallet.com",
    "www-vintaqe-myetherwallet.com",
    "www-vnitage-myetherwallet.com",
    "www1-vintage-myetherwallet.com",
    "ldex.pw",
    "blcckchian.lcgjn.com",
    "lcgjn.com",
    "blodkchian.com",
    "giveaway-tesla.club",
    "cointo.us",
    "launchpadbinance.com",
    "launchpad-binance.com",
    "crypto-mult.io",
    "btc.crypto-mult.io",
    "ltc.crypto-mult.io",
    "doge.crypto-mult.io",
    "xeppwallet.io",
    "dextestnet-binance.com",
    "dexbinance.in",
    "myehtervallet.com",
    "receive-ethereum.com",
    "goxtrade.com",
    "etbcwallet.com",
    "ildex.pw",
    "blockchainxyz.000webhostapp.com",
    "blockchainhacker.net",
    "binance-zendesk.net",
    "cashbit.world",
    "miningbanking.com",
    "constantinople.site",
    "transfer-btc.website",
    "tesla-gift.club",
    "medium.return-btc.com",
    "return-btc.com",
    "trezor-official.link",
    "giveaway-xrp.com",
    "idex-market.pw",
    "xn--polonex-cza.com",
    "xcryptofunds.com",
    "buy7000btc.online",
    "idexmarket.pw",
    "exodus-wallet.net",
    "trezor-wallet.la",
    "cometcrypt.com",
    "ethmarket.store",
    "btc-pro.co",
    "platform-bitmex.com",
    "constantinoplehardfork.cf",
    "elon-gifting.website",
    "tesla3.org",
    "ethnocrypt.com",
    "cashadd.org",
    "exmo.in.ua",
    "tesla-gift.space",
    "idexx.pw",
    "official-elon.space",
    "idexmartk.net",
    "airdrop-running.info",
    "mybitcoinqrcode.com",
    "client-tezbox.com",
    "binance.bintestnet.com",
    "bintestnet.com",
    "ico-samsung.org",
    "btcdaily.info",
    "chance.services",
    "biockchainn.com",
    "supermining.website",
    "binance-dex.cf",
    "electrum.mx",
    "l-jaxx.io",
    "xn----itbjab7adkacocegb9etd2c.xn--p1ai",
    "ripplegiveaway.net",
    "i-dex.pw",
    "bithomp.info",
    "coinpromo.fund",
    "bitcoin-btc-qr-code-generator.com",
    "thundercore.space",
    "xn--mrcatox-bya.com",
    "trustswallet.xyz",
    "electrum.la",
    "idex.pw",
    "btc-gift.com",
    "bin-testnet.com",
    "4-xrp.com",
    "live-ethers.com",
    "coinmining.website",
    "coinpromo.icu",
    "bithumb.cf",
    "xrpbullish.blogspot.com",
    "bitlhomp.com",
    "ripple-infogiveaway.com",
    "bonusmonthly.blogspot.com",
    "dex-launch.net",
    "xrp.earth",
    "microtestdigitalagency.host",
    "bitcoin-doubler.us",
    "atomicwallet.tech",
    "idex.cash",
    "ripplebounty.blogspot.com",
    "satoshilite.promo",
    "bitmex-airdrop.com",
    "localbitcoins-verify.com",
    "coindecker.com",
    "everex.cash.events-erc-20.com",
    "events-erc-20.com",
    "tokenstore.store",
    "bountyxrp.blogspot.am",
    "bountyxrp.blogspot.com",
    "ico-matic.network",
    "wallet-trezor.io-backup-online.info",
    "io-backup-online.info",
    "exoduswallet.io",
    "matic.live",
    "buterin-promo.info",
    "ethgift.blogspot.com",
    "binance.bilttly.com",
    "bitlvy.com",
    "binance.bitlvy.com",
    "binance.bnbcryptofiat.com",
    "bnbcryptofiat.com",
    "xrp-ripple.org",
    "idex.dev",
    "get-ltc-now.online",
    "hellogoldcontract.com",
    "the-spectrumnetwork.com",
    "paxfuiverify.info",
    "besetchange.org.ru",
    "blockchai-w.info",
    "bestmixer.info",
    "bin-dex.club",
    "claim-token-dgtx.com",
    "digitexfutures.com.claim-token-dgtx.com",
    "dex-launch.com",
    "dexbetalaunchcampaign.com",
    "bitcoin-btc-adder.com",
    "constantinopleplus.tech",
    "tokensico.online",
    "official-binance.space",
    "rnuetherewallet.com",
    "myeterewalliet.com",
    "gruzovyespecavtovesy.online",
    "gdax.us",
    "hillstrade.net",
    "decentralized-launch.com",
    "binancebnb-dex.net",
    "xn--lgin-blockchain-dl5h.com",
    "xn--logn-blockchan-2lbk.com",
    "blockchain-0158275.info",
    "blockchain-0174628.info",
    "blockchain-0182719.info",
    "blockchain-0193765.info",
    "blockchain-0289488.info",
    "blockchain-10358.info",
    "blockchain-1561.info",
    "blockchain-199372.info",
    "blockchain-401988.info",
    "blockchain-901742.info",
    "blockchain-918425.info",
    "blockchain-9501.info",
    "myetherwallet.com-eth.network",
    "com-eth.network",
    "bnb-launch.eu",
    "electrum.bz",
    "bnb-testnet.com",
    "matic-network.com",
    "fortunejack.cc",
    "dex.binance.org.nz",
    "binance.org.nz",
    "rnyatharwellat.com",
    "get-xlm-stellar.org",
    "kartiy.com",
    "dextestnet.com",
    "drep-wallet.com",
    "updatebinance.com",
    "myetherwallet-admin.com",
    "xn--myetherwalle-4k5f.com",
    "xn--myetherwlet-3kb80f.com",
    "blockchnain.info",
    "blochchai.info",
    "blochchaim.info",
    "blocichain.com",
    "blocickchain.com",
    "bittrexi.online",
    "xn--intenational-bittrex-65g.com",
    "xn--intrnational-bittrex-yyg.com",
    "blockholn.com",
    "blockinchain.pl",
    "bloclkchain.com",
    "paxfulupdate.com",
    "xn--bittrx-tva.com",
    "xn--bttrex-b9a.com",
    "https-blocckchain.com",
    "yobit-wallet.com",
    "hittbtc.net",
    "rnyeatlerwaitet.com",
    "backxcoin.com",
    "admaeto.com",
    "verify-bloch-chain.com",
    "blockhchain.info",
    "blokcihain.com",
    "xn--blckchain-66a.com",
    "verify-coinbase.com",
    "blockchaiiin.com",
    "coinbase.pro-xa.com",
    "pro-xa.com",
    "blockcihain.com",
    "medium.wiki",
    "ethers.today",
    "bitcoinru-wallet.site",
    "bitcoin24-wallet.site",
    "bitcoin-walletru.site",
    "blokhchian-wallet.xyz",
    "bloclkchaln.online",
    "blockchainwalletoffical.com",
    "www---binance.com",
    "xn--intrnational-bittrex-yuc.com",
    "binance-testnet.net",
    "myethervvallet.co.uk",
    "paxful-es.com",
    "xn--bittrx-7h8b.com",
    "xn--bttrx-q51bme.com",
    "blockchain-251.ru",
    "blockchain-252.ru",
    "blockchain-253.ru",
    "blockchain-254.ru",
    "blockchain-255.ru",
    "blockchain-256.ru",
    "blockchain-257.ru",
    "blockchain-258.ru",
    "blockchain-259.ru",
    "blockchain-260.ru",
    "xn--eectrum-9hb.org",
    "xn--eletrum-45a.com",
    "xn--internatinal-bittrex-4nh.com",
    "xn--internatinal-bittrex-q86k.com",
    "xn--internatonalbittrex-71c.com",
    "gram.one",
    "bittrexverifymeplease.com",
    "interneational-bittrex.com",
    "loginbittrex.com",
    "myethervvallet.vip",
    "xn--bittex-lkc.com",
    "xn--btstamp-eeb.net",
    "zollo.io",
    "tde.zollo.io",
    "zilliqablog.com",
    "register.zollo.io",
    "xn--nternational-bittrex-966k.com",
    "hitbtc.com.pl",
    "blcokchain.lloqin.com",
    "lloqin.com",
    "ldax.market",
    "idexcorp.com",
    "idexcorp.comgg.gg",
    "investment2x.online",
    "electrumsecuredownload.com",
    "myetherwallet-claim.com",
    "myetherwallet-claim.net",
    "myetherwallet-claim.org",
    "myethoverwalluet.site",
    "myethsonemallvet.site",
    "myethsonewallret.icu",
    "myethschoolclass.pw",
    "kucoin-activity.com",
    "mtc-ico.online",
    "ethereum2.online",
    "cryptoempireinc.co",
    "ripplebonus.blogspot.com",
    "idexx.site",
    "myethantiwallcafe.club",
    "coinbase-getcrypto.890m.com",
    "bithextrade.com",
    "matic.work",
    "xn--bttrx-y3a5604c.com",
    "blockchain-130.ru",
    "binance-testnet.host",
    "binance-testnet.fun",
    "binance-dextestnet.site",
    "rnuathervatlet.com",
    "myetherwallet-bonus.info",
    "exodus-support.com",
    "myetherwallet-bonus.net",
    "myetherwallet-bonus.org",
    "bitcoinru-org.site",
    "coinapult-login.com",
    "blogbibox.com",
    "binance-testnet.com",
    "earnfreebitcoins.org",
    "myethyogawallclass.icu",
    "wowx.io",
    "coinbtcbot.com",
    "catbot.ru",
    "paraetherwallet.com",
    "binancecz.blogspot.com",
    "bttorent.com",
    "xn--coinbse-en4c.com",
    "your-btc.co.uk",
    "cryptotis.com",
    "btcldn.com",
    "ildexmarket.info",
    "bitcoin-gold-blockchain.info",
    "international-bittrex-login.com",
    "internation-bittrex.com",
    "internatlonal-bittrex.com",
    "international-bittrex-a.com",
    "100x-mlt-btc.com",
    "constantinopleplus.io",
    "official-trezor.cc",
    "usddex.io",
    "mithril.pro",
    "cryptoxfan.website",
    "wbscoins.com",
    "neotracker.me",
    "gift-wallet-stellar.org",
    "eth.elon-musk.space",
    "btc.elon-musk.space",
    "elon-musk.space",
    "rnuathervaltet.com",
    "rnyetherwaliet.com",
    "celer.work",
    "electrumproject.org",
    "idex.money",
    "celerc.network",
    "kraken-com.ga",
    "exoduswallet.online",
    "bitcoinarmory.tech",
    "celer.today",
    "celer.site",
    "coinbase-app.ga",
    "ripplenet.limited",
    "gram-network.org",
    "xyogift.network",
    "blockchein.lpgirn.com",
    "lpgirn.com",
    "thewayhere.accesshealthautism.com.au",
    "hmqfoundation.com",
    "onixcrypt.com",
    "ldexmarket.pro",
    "vintage-metherwallet.co",
    "bitcoinvest.tech",
    "bestcdanje.org.ru",
    "kraken-login.ml",
    "kraken-login.ga",
    "gram-network.net",
    "ethersale.online",
    "huobiairdrop.com",
    "get-gift-stellar.org",
    "ethers-live.com",
    "forexetoro.com",
    "huobi-airdrop.org",
    "huobiairdrop.co",
    "electrumcircle.com",
    "l-electrum.org",
    "paxful-dashboard.com",
    "paxfuluser.com",
    "vlntage-myethereswallet.com",
    "rmyetherewallet.com",
    "idexxonline.com",
    "mycrypto.kr",
    "p-eos.io",
    "btc24ex.pro",
    "get-10000-xlm.org",
    "blockckchain.info",
    "gift-lumens-stellar.org",
    "myelevenwallsen.site",
    "dexlaunch-testnet.space",
    "moyblogspor.blogspot.com",
    "bounty-platform.website",
    "celer.space",
    "launchpad.celer.space",
    "wallet.elitetreum.com",
    "elitetreum.com",
    "dogx.dog",
    "cryptoxinvest.com",
    "paxfulconfirmation.com",
    "p-eos.one",
    "idex.website",
    "x-crypto.info",
    "npxs.pro",
    "ethereum-constantinople.com",
    "gift7500xlm.org",
    "azbit.org",
    "bittorent.site",
    "dex-binances.info",
    "exodus-wallet.info",
    "idexxmarket.website",
    "locaibltcoins.ru",
    "myethcwallet.com",
    "myetherwallet-vintage.co",
    "official-trezor.org",
    "paxful-login.id",
    "paxfulhelp.com",
    "paxfultrade.ml",
    "paxllful.com",
    "vlntage-myetherewallet.com",
    "xn--myeterwallt-nl8ey3e.com",
    "xn--myetherwllt-jfe8916g.com",
    "xn--myterwallet-ml8eq3e.com",
    "ltcgiveaway.online",
    "electrex.info",
    "binance-bonus.online",
    "binance-support.home.blog",
    "binance.com1615873261.ga",
    "binance.com1983762161.ml",
    "binance.music.blog",
    "binancecustomersupport18883023444.home.blog",
    "binances.site",
    "binancesupport.home.blog",
    "cm-coinmaster.home.blog",
    "coinbasexrp.blogspot.com",
    "coinbaze.online",
    "coinindex.tech",
    "cpanel.myietherwallet.com",
    "imageonline.ga",
    "ldexmarket.site",
    "licalbitcoins.org",
    "localbitcoihs.ru",
    "localbitcoind.icu",
    "localbitcoind.mobi",
    "localbitcoins-rus.ru",
    "localbitcoinss.info",
    "localbitconis.info",
    "localbitcouins.mobi",
    "localbitcouins.pro",
    "localnitcoins.info",
    "localvitcoins.info",
    "locslbitcoins.icu",
    "lokalbitcons.com",
    "mail.bittrex1.com",
    "myelhereswallet.com",
    "myelherwalicet.com",
    "myeterwollet.com",
    "myethelwallet.com",
    "myethermwallet.com",
    "myietherwallet.com",
    "mypaxful.com",
    "paxful.gq",
    "paxful.vip",
    "paxfulsupports.com",
    "paxfulverify.website",
    "signin-coinbase.com",
    "telosfundation.io",
    "trezor-sale.com",
    "trezor-shop.website",
    "vintage-myetherewallet.com",
    "vintage.myetherewallet.com",
    "vintaqe-myetherewallet.com",
    "xn--bance-3l1b03b.com",
    "xn--myetherwalt-crb49b.com",
    "xn--mytherwalle-jb9ey9a.com",
    "binance-testnet.site",
    "monero-rings.org",
    "myxrmwallet.com",
    "rnyuthewallet.xyz",
    "heuvellandcatering.com",
    "vlntage-myetherwallet.com",
    "idex-market-com.info",
    "binaripple.blogspot.com",
    "binafeb.blogspot.com",
    "fetchai.net",
    "binance-support-number.com",
    "httpsmyetherwallet.com",
    "deltafork.app",
    "yobitex-ru.net",
    "paxfultrade.xyz",
    "fetchai.eu",
    "bitcoin-update.info",
    "brad-promo.info",
    "rnyuthevvallet.com",
    "bttairdrop.com",
    "electrum.org.uk",
    "rnyuthevallet.xyz",
    "fetch-ai.net",
    "paxfull.ga",
    "musk.center",
    "telegram.systems",
    "fetchai.co",
    "fetchai.org",
    "electrumhome.org",
    "xn--myethewalt-zmb75bgl.com",
    "vintaqe-myetherwallet.com",
    "login-blockchaain.com",
    "loqin-blockchain.com",
    "loqin-blockchaln.com",
    "vintagemyetherwallet.com",
    "xn--medum-85a.com",
    "rntherwallet.icu",
    "myethrewallet.xyz",
    "myetherwalletcom.xyz",
    "myetherwalletcom.website",
    "wwwmyetherwallet.shop",
    "wwwmyetherwallet.icu",
    "etherwallets.info",
    "mydogechains.info",
    "rntherwallet.xyz",
    "xrpbinan.blogspot.com",
    "musk.credit",
    "musk.fyi",
    "binanceee.blogspot.com",
    "binanceee.blogspot.lt",
    "binanceee.blogspot.com.mt",
    "paxful.log-iin.com",
    "log-iin.com",
    "myehlerwal.com",
    "atomcwallet.com",
    "atomcwallet.club",
    "atomswallet.co",
    "atomswallet.me",
    "atomswallet.org",
    "atomcwallet.biz",
    "bittrex-login.inter-cliente.online",
    "inter-cliente.online",
    "store-trezor.com",
    "store-trezor.org",
    "storetrezor.com",
    "trezor-wallet.info",
    "wallet-trezor.info",
    "trezor-shops.com",
    "wallets-trezor.ltd",
    "store-trezor.eu",
    "myelhitorwailct.com",
    "vintage-myethereswallet.com",
    "bitcoin-mixer.tk",
    "46.226.108.171",
    "bancor.network.sign-in-by-wallet.event-distributors.com",
    "bancor.network.sign-in-by-wallet.members-gift.com",
    "blogbinanc.blogspot.com",
    "coinbase.com-9da7a204-544e-53d1-9a12-61176c4d4cd8.site",
    "coinbase.com-9da7a204-544e-5fd1-9a12-61176c5d4cd8.com",
    "coinbase.com-9da7a204-544e-63d1-4a12-61176c4d4cd8.site",
    "coinbase.com-9da7a204-544e-63d1-4a12-61176c4d4cd8.su",
    "coinbasebitbank.com",
    "coinbasehelpdesk.com",
    "coindesk.link.16640.aqq.ru",
    "coindesk.name.16640.aqq.ru",
    "coindeskjapan.net",
    "coinlbase.com-7da7a204-744e-63d1-64b12-61176c4d4cd7.site",
    "coinlbase.space",
    "cojnbase.com",
    "dexlaunch-binance.com",
    "trezor-wallet.shop",
    "idex-market-com.com",
    "idexmarket.pro",
    "idexmarket.store",
    "indadax.com",
    "ipaxful.us",
    "kyber.network.sign-in.user-bonus-tokens.com",
    "lacalbitcoins.ru",
    "lcalbitcoins.ru",
    "licalbitcoins.ru",
    "loalbitcoins.ru",
    "localbicoins.com",
    "localbircoins.ru",
    "localbitcoim.com",
    "localbitcoims.pro",
    "localbitcoin.com.paxfulreport.online",
    "localbitcoina.ru",
    "localbitcoind.ru",
    "localbitcoins.technology.16640.aqq.ru",
    "localbitcouins.ru",
    "localbitcouns.ru",
    "localbiticoins.com",
    "localbitocin.com",
    "localethereum.biz.16640.aqq.ru",
    "localethereum.cc.16640.aqq.ru",
    "localethereum.club.16640.aqq.ru",
    "localethereum.co.16640.aqq.ru",
    "localethereum.company.16640.aqq.ru",
    "localethereum.me.16640.aqq.ru",
    "localethereum.name.16640.aqq.ru",
    "localethereum.technology.16640.aqq.ru",
    "localethereum.today.16640.aqq.ru",
    "localibitcons.com",
    "localnitcoins.ru",
    "localvitcoins.ru",
    "locialbitcoins.com",
    "locoibitcoin.com",
    "locslbitcoins.pro",
    "loculbitcoins.com",
    "lokalbitcoin.net",
    "lokalbitcoin.top",
    "lokalbitkoins.com",
    "lovalbitcoins.ru",
    "loxalbitcoin.com",
    "my.paxfulcheck.xyz",
    "myathereswallet.com",
    "myatherewallet.com",
    "myehterwoailet.com",
    "myelherevallet.com",
    "myelherewallet.com",
    "myelherswaltet.com",
    "myelherwaflet.com",
    "myelherwalfet.com",
    "myelherwaltet.com",
    "myelherwollet.com",
    "myesererwallet.com",
    "myetherecvallet.com",
    "myetherecwallet.com",
    "myetherewaiiet.com",
    "myetherewallef.com",
    "myetherewaltyt.com",
    "myetheruomwallet.com",
    "myetherwalet.ru",
    "myetherwalets.ru",
    "myetherwallet-payment.com",
    "myetherwallet.com-7da3a790-214a-51c7-14g19-87531g0f4co9.site",
    "myetherwallet.com-7da3a790-214u-23c1-14a19-87536g0f4ca1.site",
    "myetherwallet.com-7da3a890-214u-23c1-14a19-87536g0f4cc3.site",
    "myetherwallet.com-7da3a890-214u-23c1-14a19-87536g0f4ce5.site",
    "myetherwallet.com-7da3a890-214u-23c1-14a19-87536g0f4cf6.site",
    "myetherwallet.com-7da3a890-214u-23c1-14a19-87536g0f4cg7.site",
    "myetherwallet.com.ether-send.info",
    "myetherwallet.com.ether-transactions.info",
    "myetherwallet.com.ethers-transaction.info",
    "myetherwallet.com.node-ethereum.info",
    "myetherwallet.com.sen-transaction.info",
    "myetherwallets.ru",
    "myetherweltet.com",
    "myethewaliet-login.site",
    "myethrernwallet.com",
    "myetllerwallet.com",
    "myetnerwalet.ru",
    "myetnerwallet.com.load-transaction.info",
    "myetnerwallet.com.seth-transaction.info",
    "myetnerwallets.ru",
    "myetserwallet.com",
    "myiethereswallet.com",
    "mythetawallet.com",
    "ocalbitcoins.ru",
    "paxful.com.loolic.ga",
    "paxfulcheck.xyz",
    "paxfulreport.online",
    "paxfulreverify.com",
    "paxfulverify.online",
    "remitano.trade",
    "rnuetherwallet.com",
    "rnyethereurnwallet.com",
    "rnyethrewallet.com",
    "shop-trezor.info",
    "trezor-ship.biz",
    "trezor-shop.biz",
    "trezor-wallet.eu",
    "trezor-wallet.live",
    "trustwallet.com.erc-20-gift.com",
    "vvww-coinbase.com",
    "vww-coinbase.com",
    "vww.myetnerwallet.com.node-send.info",
    "wallets-trezor.eu",
    "wallets-trezor.org",
    "wvw-coinbase.com",
    "www-ldex.market",
    "xn--conbase-hza.com",
    "xn--medum-g81b.com",
    "xn--myetherwllet-ncb.com.status-send.info",
    "xn--myetherwllt-3kb0v.com",
    "xn--myetherwllt-3kb8699g.com",
    "xn--pxful-93b.com",
    "xn--trezor-wllet-59a.com",
    "rnuethervvallet.com",
    "electrumupdate.com",
    "electrumweb.net",
    "vintage-myetherwallet.com",
    "wedderbergen.com",
    "myetherwallet.com.access-wallet.info",
    "access-wallet.info",
    "electrumfix.com",
    "electrumsource.org",
    "bltaddress.org",
    "cryptoxcash.com",
    "cryptonback.com",
    "binannn.blogspot.com",
    "binanxrp.blogspot.com",
    "unfreeze-paxful.com",
    "rnuetharwallet.com",
    "bintrx.blogspot.com",
    "bin-ance.blogspot.com.tr",
    "binaxrp.blogspot.com",
    "itubeonline.com",
    "enjin.pro",
    "tronxwallet.com",
    "tronxcash.com",
    "electrumupgrade.org",
    "wwwmycrypto.com",
    "coindesk.me.16640.aqq.ru",
    "electrumdownload.com",
    "ldexmarket.com",
    "bittrex-m.com",
    "rnuathervvalfet.com",
    "spacex.promo",
    "paxful.com.ru",
    "electrumbase.com",
    "electrumcore.net",
    "electrumapps.com",
    "xn--blckchin-eza9o.com",
    "idexxmarket.site",
    "idexmarkt.store",
    "get2802lumens.online",
    "electrumofficial.com",
    "privatstuff.store",
    "ttrxtrx.blogspot.com",
    "xrpxrp.blogspot.com",
    "ldex-market.pro",
    "bittorrent.pro",
    "doublebitcoin.io",
    "lucalbltcoins.com",
    "xn--hitbt-8xa.com",
    "idexmarket.space",
    "bakktplatform.io",
    "btcdev.us",
    "myetherwallet.com-7da3a890-214u-23c1-14a19-87536g0f4cd4.site",
    "myetherwallet.com-7da3a890-214u-23c1-14a19-87536g0f4cb2.site",
    "bittorrent.foundation",
    "getfree-neo.blogspot.my",
    "getfree-neo.blogspot.com",
    "binjerseygbpeur.com",
    "get-freecrypto.blogspot.com",
    "eth4free.com",
    "giveaway-x.blogspot.com",
    "etherchange.tech",
    "claim-xyotokens.com",
    "bitcoin4future.club",
    "dexbetalaunch.com",
    "airdropxneo.blogspot.com",
    "myetheresswallet.com",
    "bitaeon.top",
    "btrmartgve.com",
    "stellar-lightning.org",
    "xllwallet.com",
    "idexmarket.website",
    "cryptoexcoins.com",
    "bitcoin-generator.network",
    "ethtokens.store",
    "xn--bttorrent-54a.com",
    "btcaim.com",
    "bizzilion.com",
    "seth-transaction.info",
    "cryptocreditfoundation.com",
    "circlemix.io",
    "jancrypto.blogspot.com",
    "wallet-support.com",
    "airdropxrp.blogspot.com",
    "cryptoback.top",
    "cryptogene.net",
    "buteringift.com",
    "quick2xbtc.com",
    "doublecrypto.ml",
    "doubleinvestment.cf",
    "doublebitco.in",
    "bitcoin-pro.club",
    "idexgroup.online",
    "bttpromotion.github.io",
    "telos-foundation.io",
    "binancegive.com",
    "ethereum-advanced.com",
    "investmentdoubler.online",
    "bttpromo.github.io",
    "bittorrentpromo.github.io",
    "binancedexg.com",
    "isecurecoinbase.live",
    "meyhterwailet.com",
    "mycfherwallet.com",
    "myctherwailet.com",
    "myctherwalet.com",
    "myefhervvailet.com",
    "myefhervvaliet.com",
    "myefhervvellet.com",
    "myefherwalet.com",
    "myefherwellet.com",
    "myefterwallet.com",
    "myehtervvallet.com",
    "myetfervvallet.com",
    "myetfervvellet.com",
    "myetferwaillet.com",
    "myethervellet.com",
    "myethervvallct.com",
    "myethervveilet.com",
    "myethervveliet.com",
    "myethervvellet.org",
    "myetherwalfet.com",
    "myetherwallet.com.ether-transaction.info",
    "myetherweilet.com",
    "myetherweliet.com",
    "myetherwellct.com",
    "myethrwallet.ru",
    "myetnerwallet.ru",
    "mythervvallet.com",
    "paxful.ml",
    "www-paxful.com",
    "xn--dx-qbb4240a.market",
    "xn--myethrwllet-q7a1340h.com",
    "xn--trzor-7za.net",
    "xn--trzor-csa.com",
    "xn--trzor-csa.co",
    "toke.online",
    "binancexrpjan.blogspot.com",
    "ethercontest.com",
    "escobarsbr.com",
    "myesereswallet.com",
    "myeromahousit.com",
    "binancegiveaways.com",
    "eloncity.sale",
    "mana-gift.com",
    "digitexfutures.site",
    "localbitcoins.com.support-ticket-report.com",
    "paxful.co.in",
    "paxfulwallets.com",
    "trezor-official.org",
    "xn--myetherwalt-15b4719g.com",
    "xn--myetherwalt-o4b6229g.com",
    "xn--myetherwat-mybx6229g.com",
    "xn--mythrwllet-jj3enkc.com",
    "localbltcoins.com",
    "meytherwalet.com",
    "myctherwallet.icu",
    "myetherwallet.com.et-transaction.info",
    "myetherwallet.com.send-etransaction.info",
    "myetherwallet.com.view-chain.info",
    "myetherwattet.com",
    "paxful.to",
    "paxfull.club",
    "support-ticket-report.com",
    "localethereum.com.support-ticket-report.com",
    "doublebitcoin.cc",
    "double2btc.top",
    "trondiscount.com",
    "hydrowallet.io",
    "ltcpro.live",
    "ltcgiveaway.com",
    "ltcpro.xyz",
    "dexchainlaunchpad.com",
    "ethgws.com",
    "xpro.icu",
    "airdropcampaign.com",
    "bttlaunchpad.com",
    "client-wavesx.com",
    "btc-promo.net",
    "waves-x.com",
    "etcv-wallet.co",
    "faceusd.com",
    "tokenshops.online",
    "janbinancexrp.blogspot.com",
    "janbinance.blogspot.com",
    "coinbit24.site",
    "idex-market.live",
    "x10eth.com",
    "betabindex.com",
    "bitmrtpro.com",
    "bonus-stellarterm.com",
    "coinbvse.com",
    "dex-hbiglobal.info",
    "xn--wvww-krakn-5q3e.com",
    "bancor.network.xbancor.online",
    "binancegift.online",
    "bitcoincoinbase.top",
    "coimbase.top",
    "coinbase-airdrop.xyz",
    "coinbase-btc.top",
    "coinbase-btcairdrop.top",
    "coinbase-competition.top",
    "coinbase-crypto.top",
    "coinbase-give.top",
    "coinbase-gives.top",
    "coinbase-prize.top",
    "coinbase.army",
    "coinbaseair.coinbaseairdrops.info",
    "coinbaseair.info",
    "coinbasebitcoin.coinbaseairdrops.info",
    "coinbasebtcairdrop.coinbaseairdrops.info",
    "coinbasebtcairdrop.info",
    "coinbasebtcdrop.coinbaseairdrops.info",
    "coinbased.top",
    "coinbased.xyz",
    "coinbasedex.top",
    "coinbasedexdrop.coinbaseairdrops.info",
    "coinbasedexx.coinbaseairdrops.info",
    "coinbasedx.coinbaseairdrops.info",
    "coinbasee.coinbaseairdrops.info",
    "coinbasee.info",
    "coinbaseio.top",
    "coinbaserx.coinbaseairdrops.info",
    "coinbaserx.top",
    "coinbasevert.network",
    "coinbasevertnetwork.coinbaseairdrops.info",
    "coinbasex.top",
    "coinbasexx.coinbaseairdrops.info",
    "colnbase.top",
    "cpanel.bitcoincoinbase.top",
    "cpanel.coinbase-airdrop.top",
    "cpanel.coinbase-airdrop.xyz",
    "cpanel.coinbase-btc.top",
    "cpanel.coinbase-btc.xyz",
    "cpanel.coinbase-btcairdrop.top",
    "cpanel.coinbase-competition.top",
    "cpanel.coinbase-crypto.top",
    "cpanel.coinbase-give.top",
    "cpanel.coinbase-gives.top",
    "cpanel.coinbase-prize.top",
    "cpanel.coinbaseair.info",
    "cpanel.coinbaseairdrops.info",
    "cpanel.coinbasebtcairdrop.info",
    "cpanel.coinbasebtcdrop.info",
    "cpanel.coinbasecampaign.online",
    "cpanel.coinbased.top",
    "cpanel.coinbased.xyz",
    "cpanel.coinbasedex.top",
    "cpanel.coinbasedexdrop.info",
    "cpanel.coinbasedexio.online",
    "cpanel.coinbasee.info",
    "cpanel.coinbasegiveaway.online",
    "cpanel.coinbasegives.top",
    "cpanel.coinbaseio.top",
    "cpanel.coinbaserx.top",
    "cpanel.coinbasex.top",
    "cpanel.myetherwallet-dec.space",
    "lccalbtlcoins.com",
    "mail.coinbase.army",
    "myetherwallet-ye.space",
    "xn--myethrwalt-zxb6271g.com",
    "xn--mytherwllt-kj3emkia.com",
    "idex-market.website",
    "forkdelta.space",
    "big-gift.ga",
    "doubleinvest.online",
    "ebitservices.com",
    "btcexcelinvest.com",
    "electrum.one",
    "e-xodus.com",
    "myetcvwallet.com",
    "wallet.hydroproject.io",
    "hydroprotocol.tech",
    "etcv-wallet.com",
    "tesla-promo.tech",
    "binancejan.blogspot.com",
    "ethereumcv.io",
    "ethereumcv.info",
    "ethnowawallet.com",
    "myetherwallet-dfz.space",
    "sdf34myetherwallet.site",
    "wallet.bancor.network.xbancor.online",
    "xbancor.online",
    "23423myetherwallet.site",
    "33333myetherwallet.site",
    "44332myetherwallet.site",
    "binancepromo.com",
    "coinbase-airdrop.com",
    "jhfjmyetherwallet.site",
    "bitmartpro.live",
    "etcvwallet.com",
    "coinibase.pro",
    "myetherwallet-ne.space",
    "trezor-sales.online",
    "karatbars-affiliate-bonus.com",
    "idex.ru.com",
    "2fa-myetherwallet.com",
    "blocktower.info",
    "myetherwallet-eb.space",
    "trezor-shop.org",
    "hydroproject.io",
    "rnyetherwallet.site",
    "xn--mythrwllt-576dqjcf.com",
    "en.coinbase-coupon.com",
    "localbiitcoinz.club",
    "myethereswallet.com",
    "myethreiwallet.com",
    "online-localbitcoins-th.co",
    "test.tdstraf.ru",
    "vwww-coinbase.com",
    "xn--binnce-dh8b.com",
    "xn--bnnce-c51bsf.com",
    "xn--vww-krakn-2f7d.com",
    "xn--wvw-krakn-2f7d.com",
    "gowincoin.com",
    "delta.money",
    "coinsupergive.live",
    "ethers-claim.com",
    "binanceevent.net",
    "huobilive.icu",
    "cryptocashback.org",
    "cryptocashback.info",
    "cryptoback.one",
    "newyearcrypto.blogspot.com",
    "newyearneo.blogspot.com",
    "cryptobridge.su",
    "xrp-giveaway.com",
    "biboxpr.icu",
    "myetheresvallet.com",
    "paxfu1.com.mx",
    "paxfui.com",
    "paxful-pp.com",
    "xn--coinbas-xs4c.com",
    "xn--myethrwllt-kj3epkf.com",
    "com-1a7d1kf3i5786dghba88.site",
    "coinbasegiveaway.info",
    "coinbasegiveaway.online",
    "ethnowa-wallet.com",
    "crystal-profit.com",
    "bancor.store",
    "binance-competition.info",
    "binancel.ru",
    "bithumbs.com",
    "coinlbase.coinbase.cloud",
    "lccalbltcoins.com",
    "myetherevvallet.com",
    "myetlnerwallet.com",
    "posmyetherwallet.com",
    "rnythervvallet.com",
    "xn--coinbse-ixa.com",
    "xn--wvw-krken-576d.com",
    "xn--wwv-krken-576d.com",
    "cash-bitcoin.online",
    "yobitex.info",
    "yobit-admin.net",
    "yobit--net.com",
    "supportyobit.net",
    "xn--ybit-gra.net",
    "xn--yobt-sya.net",
    "bankcor.network",
    "bankor.network",
    "binance-tr.com",
    "binancebch.com",
    "coinbasecanada.com",
    "coinbasegives.top",
    "coinbaseofficials.com",
    "https-trezor.com",
    "localbtlcoins.com",
    "trezor.site",
    "xn--bitfinx-v9a.com",
    "xn--bitrex-rkb.com",
    "xn--vww-krken-576d.com",
    "xn--www-kaken-u0b.com",
    "xn--www-krake-3vb.com",
    "xn--www-krakn-2f7d.com",
    "xn--www-krken-576d.com",
    "binance-competition.net",
    "excdus.org",
    "xn--myethrwalt-yxb2271gfa.com",
    "giveawayxneo.blogspot.com",
    "ethtokens.online",
    "okexpro.icu",
    "poetairdrop.com",
    "coinbankatm.com",
    "coinbasedex.online",
    "coinsbankcom.com",
    "form-coinbase.com",
    "kraken.fr",
    "mercoatox.com",
    "mwww-kraken.com",
    "myetherwallel.pro",
    "poloniexbch.com",
    "swww-kraken.com",
    "coinbase-airdrop.top",
    "coinbase-btc.xyz",
    "kucoindectrx.blogspot.com",
    "jaxx.im",
    "jaxx.ru.com",
    "coinbasedexio.online",
    "myetherwallet-ico.space",
    "myetherwallet-xo.space",
    "myetherwellet.cc",
    "trezor.ltd",
    "user.paxfulreports.com",
    "crypto-positive.club",
    "erc-20-tokens-gift.com",
    "trustwallet.com.erc-20-tokens-gift.com",
    "binance-dex.pro",
    "binance.bid",
    "binancebtc.com",
    "binancecashback.com",
    "binancemobile.app",
    "medlum.org",
    "trezor.vozp.cz",
    "xn--myethrwalet-92b.com",
    "xn--myethrwalt-yxb7271g.com",
    "xn--myethrwlet-xxb7341g.com",
    "binance.fit",
    "coinbasebonus.org",
    "coinbasediscount.com",
    "localbitcoins.vip",
    "myetherwallet.ilogirn.com",
    "trezor-wallet.online",
    "xn--myeerwallet-vic8676g.com",
    "bittlrex.com",
    "xn--binnce-rhc.com",
    "binance.exchange2018.support",
    "exchange2018.support",
    "binancehelpdesk.com",
    "binancetwofactorauthentication.com",
    "pumapay.io.giveaway-user.com",
    "ether-contest.com",
    "dex-huobiglo.info",
    "xn--myetherllet-hoc47z.com",
    "xn--myethewllet-hdc193a.com",
    "airgiveaway.typeform.com",
    "bitcashsv.org",
    "bitlry.info",
    "coinbasse.com198637829761.ml",
    "myethevvallel.com",
    "myetnerwalel.com",
    "xn--myeterwalle-wc9exr.com",
    "xn--pxful-j11b.com",
    "etherdelta.pro",
    "quarkairdrop.com",
    "crypterium.site",
    "bittfinex.com",
    "bittrex.mobi",
    "bittrexbtc.com",
    "bonus-coinbase.com",
    "coinbase-giveaway.com",
    "coinbaseearn.com",
    "krakenonline.com",
    "coinbasedexdrop.info",
    "coinbebase.com",
    "localbitcoins-info.ru",
    "localbitcoins-ru.ru",
    "muyetherwaliet.com",
    "myelherwaliet.com",
    "myetherevallet.com",
    "myetherwallet.lcgirn.com",
    "myethevalet.com",
    "trezor-wallet.net",
    "xn--hobi-08a.com",
    "xn--huob-tpa.com",
    "xn--myetherwat-zxba7729g.com",
    "xn--myethrwalet-92b3729g.com",
    "xn--mytherwalet-3qb20c.com",
    "xn--mythrwalet-xxb0271g.com",
    "xn--yeterwalle-ue2e3nrs.com",
    "support-coinbase.info",
    "meduim.online",
    "myeltherwaliet.com",
    "myetherwallet-tgt.space",
    "binance.com.au",
    "bitbankmoney.com",
    "bithumbjapan.com",
    "bithumbus.com",
    "ckraken.com",
    "coinbasebtcdrop.info",
    "coindesk.vip",
    "huobipro.tk",
    "indodcx.com",
    "xn--myethrwalt-zxb1271gfa.com",
    "xn--eoscorearbitratio-l6c.io",
    "basicattentiontoken.website",
    "myetherwallet.96.lt",
    "dec-kucoin.blogspot.com",
    "trx-kucoin.blogspot.com",
    "neo-kucoin.blogspot.com",
    "cryptobountymco.com",
    "tokensic.online",
    "encrypex.online",
    "myetherwallet.890m.com",
    "freebitcobot.top",
    "biftinex.com",
    "binance-beta.info",
    "binance.bnblaunch.com",
    "bithumbloan.com",
    "bittrex.com158987679.ga",
    "coinbaseairdrops.info",
    "iwww-kraken.com",
    "kraken.world",
    "localbitcoins.cash",
    "localbitlcoins.com",
    "msetherwallet.com",
    "mycrypto.faith",
    "myetheswaiiet.info",
    "myethevvallet.biz",
    "myethevvallet.org",
    "myethevwallet.org",
    "myietherwallet.pro",
    "paxfulusers.com",
    "pr-hitbtc.com",
    "trezor-wallets.net",
    "wvvw-kraken.com",
    "wwvv-kraken.com",
    "wwwbittrex.com",
    "xn--hubi-hx5a.com",
    "xn--hubi-w0b.com",
    "xn--idx-lra.market",
    "xn--myetherwalt-c3b7729g.com",
    "xn--myethrwalet-b3b2729g.com",
    "binancedexairdrop.net",
    "giveaway2018.org",
    "bullrun2018.com",
    "doublecoinio.jdevcloud.com",
    "mediium.org",
    "myetherwallet-be.space",
    "binance-dexbeta.net",
    "bittrex-rf.com",
    "bittrex-rx.com",
    "coinbase-zendesk.com",
    "coinbasedexnews.info",
    "coinbasehub.com",
    "coinbaseth.info",
    "mycryptoa.gq",
    "myetervallient.info",
    "myethirwalde.info",
    "trezor-wallets.org",
    "vwv-kraken.com",
    "vwvw-kraken.com",
    "wvww-kraken.com",
    "xn--kaken-17b.com",
    "xn--kaken-e8b.com",
    "xn--krakn-25b.com",
    "xn--krakn-8cc.com",
    "xn--krakn-f6b.com",
    "coinbase.pro-xca.com",
    "pro-xca.com",
    "awx-ly.store",
    "binance-dex.life",
    "binance-dex.live",
    "binance-dexonline.info",
    "binance.fan",
    "binancedexbeta.com",
    "bit-thumb.com",
    "coinbasedexx.info",
    "kraken.vip",
    "localbatcoins.com",
    "localbcoins.ru",
    "localbikcoins.com",
    "localbimcoins.com",
    "localbitcains.com",
    "localbitcoims.info",
    "localbitcoin.cash",
    "localbitcoines.info",
    "localbitcolins.info",
    "localbitloins.com",
    "localbitscoins.info",
    "localsitcoins.com",
    "locslbitcoins.info",
    "lojalbitcoins.com",
    "lokalbitcoin.info",
    "metamaskhelp.com",
    "myethdwalliet.info",
    "myetherwellet.info",
    "myethieswallep.info",
    "myethlerwalliet.info",
    "myethrwaillet.info",
    "poloniex.cloud",
    "poloniexs.com",
    "shop-trezor.io",
    "stcoinbase.com",
    "trezor-wallets.store",
    "tupbit.com",
    "wwvw-kraken.com",
    "xn--conbas-xva87a.com",
    "xn--myetherwalt-b3b4039g.com",
    "coinbase.prows-ax.com",
    "prows-ax.com",
    "otx-ca.com",
    "av-za.com",
    "cla-pro.com",
    "bitcointoolmining.com",
    "idexethereum.online",
    "bbxotc.tech",
    "btc-gifts.net",
    "biitfiinex.com",
    "binance-dexbounty.info",
    "binance-download.com",
    "binancebtcairdrop.net",
    "bitbank.fund",
    "bittrexx.win",
    "careerbittrex.com",
    "coinbase-ripple.org",
    "coinbase-vip.com",
    "coinbaseairdrop.com",
    "coinbaseairdrop.info",
    "coinbasecash.com",
    "coinbasedex.info",
    "coinmarketcap.ovh",
    "hitbtc.se",
    "international-binance.com",
    "international.bittrex.com781236781.gq",
    "krakezn.com",
    "locambitcoins.com",
    "lohalbitcoins.com",
    "lolalbitcoins.com",
    "meythermallet.com",
    "mycthcrwallct.com",
    "myehtcrwallct.com",
    "myehtervvaillet.com",
    "myethernwallet.info",
    "myetherswajllet.info",
    "myetherwallet-es.space",
    "myetherwallet-get.space",
    "myetherwalletl.info",
    "myetherwolet.com",
    "myethrenwallet.com",
    "myethwallet.info",
    "myetlherwallet.online",
    "myetrhewallet.com",
    "paxful.co",
    "polonlex.com",
    "vww-kraken.com",
    "webimage.ml",
    "wwv-kraken.com",
    "www-coinsbank.com",
    "wwwhuobi.pro",
    "xn--huob-yw5a.com",
    "xn--krke-moa40d.com",
    "xn--krken-4qa.com",
    "xn--krken-c51b.com",
    "xn--krken-n41b.com",
    "xn--krkn-6na9c.com",
    "xn--methrwllet-umb0681g94a.com",
    "xn--myethewallet-9d5f.com",
    "xn--rezor-q9b.com",
    "xn--trzor-7za.com",
    "xn--trzor-vza.com",
    "xn--uphld-wob.com",
    "xn--bibo-eo5a.com",
    "paxfulldashboard.com",
    "info.paxfulverify.com",
    "paxfulverify.com",
    "myetherwallet-xyo.space",
    "view-statys.info",
    "xn--myetherwllet-59a.com.view-statys.info",
    "myethwalchellet.site",
    "applyer.info",
    "xn--pxful-3qa.com",
    "tronkucoin.blogspot.com",
    "huobiglo.com",
    "cryptokucoin.blogspot.com",
    "neokucoin.blogspot.com",
    "blockchain-update.bounceme.net",
    "coinbene.net",
    "hitbtcwalet.com",
    "musk.claims",
    "spacex.gives",
    "musk.click",
    "ethnew.store",
    "coinbase.pro-cax.com",
    "pro-cax.com",
    "cbs-pro.com",
    "txa-aso.com",
    "zas-pro.com",
    "blockchiarn.net",
    "poloniexneo.blogspot.com",
    "binance.eth-win.com",
    "eth-win.com",
    "huobiglob.live",
    "mediumpost.top",
    "pundix.site",
    "dexhuobi.com",
    "binance-dev.online",
    "aabithub.com",
    "binance-airdrop.hol.es",
    "binance-gift.com",
    "binance.accountant",
    "binance.date",
    "binance.men",
    "binance.science",
    "binance.webcam",
    "binancebnb.online",
    "binances.club",
    "bitfiles.ml",
    "coiinbase.com",
    "design.localbitcoinsx.com",
    "i1.localbitcoinsx.com",
    "i2.localbitcois.org",
    "kraken.com.se",
    "lcalbitcoins.biz",
    "licalbitcoins.club",
    "localbipcoins.com",
    "localbircoins.club",
    "localbircoins.top",
    "localbitcoin.asia",
    "localbitcoina.club",
    "localbitcoina.top",
    "localbitcoind.club",
    "localbitcoind.net.ru",
    "localbitcoines.top",
    "localbitcoins.ooo",
    "localbitcoins.ru.net",
    "localbitcolins.com",
    "localbitcouns.club",
    "localbitkoins.com.ru",
    "localbitkoins.net.ru",
    "localbitocins.club",
    "localbitscoins.com",
    "localbitscoins.net.ru",
    "localbutcoins.asia",
    "localbutcoins.net",
    "localbutcoins.net.ru",
    "localnitcoins.club",
    "localnitcoins.top",
    "localsbitcoins.net",
    "localvitcoins.club",
    "loclbitcoins.com.ru",
    "loclbitcoins.net.ru",
    "locslbitcoins.club",
    "lokalbitcins.com",
    "lokalbitcoins.com.ru",
    "lokalbitcoins.gdn",
    "lokalbitcoins.net.ru",
    "lokalbitcoins.org.ru",
    "lokalbitcoins.pl",
    "lokalbitcoint.com",
    "lovalbitcoins.club",
    "lovalbitcoins.top",
    "manage-applesupport-verification.com",
    "meythervvallet.net",
    "meythervvallet.org",
    "meytherwellet.info",
    "meytherwellet.net",
    "mnyetlherwbllet.com",
    "mnyetnherwailet.com",
    "mycthervvellet.com",
    "myctherwellet.com",
    "myefherwailet.com",
    "myehtervvallct.com",
    "myehterwellete.com",
    "myetherwallet-de.space",
    "myetherwallnet.com",
    "myscreen.ml",
    "poloniex.online",
    "rnyethervallel.com",
    "terms-paxful.com",
    "xn--bitfnex-2ya.com",
    "xn--huob-8w5a.com",
    "cryptophonesupport.com",
    "keepstake.github.io",
    "msg.xn--metherwllt-zmb5581g94a.com",
    "xn--metherwllt-zmb5581g94a.com",
    "international.bittrex.com8917321.ga",
    "com8917321.ga",
    "spacex.delivery",
    "bibolx.com",
    "xn--metherwllt-f2d4888f9va.com",
    "myetherwallet-ue.space",
    "get-eth-now.online",
    "xn--tro-rwa.net",
    "erc-20.myetherwallet.bonus.tokens-mew.com",
    "tokens-mew.com",
    "binance-home-app.com",
    "binance-il.com",
    "binance.cricket",
    "binance.loan",
    "binancedex.center",
    "binancel.com",
    "binances.win",
    "binancesto.org",
    "coinbase-usdc.info",
    "coindesk.hu",
    "design.localbitcoin.download",
    "design.localbitcoin.online",
    "design.localbitcoin.review",
    "design.localbitcoin.us",
    "design.localbitcoin.website",
    "design.localbitcoin.win",
    "design.localbitcoins.date",
    "design.localbitcoins.gdn",
    "design.localbitcoins.racing",
    "design.localbitcoins.review",
    "design.localbitcoins.science",
    "design.localbitcoins.webcam",
    "design.localbitcoinsa.com",
    "design.localbitcoinsd.com",
    "design.localbitcoinst.com",
    "design.localbitcoinxs.com",
    "design.markethot24.ru",
    "dexbinance.center",
    "dexbinance.info",
    "hitbtc.info",
    "hitbtc.org",
    "hitbtc.ru",
    "hitbtc.site",
    "hitbtc.space",
    "hitbtc.tech",
    "hitbtc.us",
    "hitbtx.com",
    "hittbtc.com",
    "i1.localbitcoin.bid",
    "i1.localbitcoin.online",
    "i1.localbitcoin.review",
    "i1.localbitcoin.stream",
    "i1.localbitcoin.top",
    "i1.localbitcoin.win",
    "i1.localbitcoins.review",
    "i1.localbitcoins.science",
    "i1.localbitcoins.webcam",
    "i1.localbitcoinsd.com",
    "i1.localbitcoinst.com",
    "i1.localbitcois.biz",
    "i1.localbitcois.org",
    "i2.klocalbitcoins.com",
    "i2.localbitcoin.download",
    "i2.localbitcoin.online",
    "i2.localbitcoin.review",
    "i2.localbitcoin.top",
    "i2.localbitcoin.us",
    "i2.localbitcoin.website",
    "i2.localbitcoind.com",
    "i2.localbitcoins.date",
    "i2.localbitcoins.gdn",
    "i2.localbitcoins.review",
    "i2.localbitcoins.science",
    "i2.localbitcoins.su",
    "i2.localbitcoins.webcam",
    "i2.localbitcoinsd.com",
    "i2.localbitcoinsx.com",
    "i2.localbitcois.biz",
    "i2.localbitcois.info",
    "i3.localbitcoin.bid",
    "i3.localbitcoin.review",
    "i3.localbitcoin.top",
    "i3.localbitcoin.us",
    "i3.localbitcoin.website",
    "i3.localbitcois.org",
    "i4.localbitcoin.review",
    "indodax1.com",
    "indodaxc.com",
    "info-mercatox.com",
    "l9calbitcoins.com",
    "lcalbitcoins.club",
    "lcalbitcoins.org",
    "ldex.space",
    "lecalbitcoins.com",
    "liocalbitcoins.com",
    "loaclbitcoins.com",
    "loaclbitcoins.net",
    "loaclbitcoins.org",
    "loaclbitcoins.us",
    "loalbitcoins.biz",
    "loalbitcoins.club",
    "loalbitcoins.loan",
    "loalbitcoins.mobi",
    "loalbitcoins.net",
    "loalbitcoins.org",
    "loalbitcoins.us",
    "loalbitcoins.win",
    "locabitcoins.top",
    "locabitcoins.trade",
    "locabitcoins.win",
    "localb9tcoins.com",
    "localbbitcoins.net",
    "localbeetcoins.com",
    "localbi6coins.com",
    "localbicoins.bid",
    "localbicoins.biz",
    "localbicoins.club",
    "localbicoins.loan",
    "localbicoins.org",
    "localbicoins.top",
    "localbicoins.trade",
    "localbicoins.us",
    "localbicoins.win",
    "localbictoins.net",
    "localbikoins.com",
    "localbiktcoins.com",
    "localbillcoins.ru",
    "localbincoins.com",
    "localbircoins.com",
    "localbircoins.us",
    "localbiscoins.com",
    "localbitc0ins.com",
    "localbitcdoins.com",
    "localbitcfoins.com",
    "localbitcins.club",
    "localbitcins.loan",
    "localbitcins.men",
    "localbitcins.trade",
    "localbitcins.win",
    "localbitckoins.com",
    "localbitclins.com",
    "localbitcloins.com",
    "localbitco8ns.com",
    "localbitco9ns.com",
    "localbitcoens.com",
    "localbitcoibns.com",
    "localbitcoihs.com",
    "localbitcoimns.com",
    "localbitcoin.cricket",
    "localbitcoin.gdn",
    "localbitcoin.host",
    "localbitcoin.house",
    "localbitcoin.link",
    "localbitcoin.loan",
    "localbitcoin.nl",
    "localbitcoin.org.ru",
    "localbitcoin.party",
    "localbitcoin.pro",
    "localbitcoin.racing",
    "localbitcoin.review",
    "localbitcoin.science",
    "localbitcoin.site",
    "localbitcoin.space",
    "localbitcoin.top",
    "localbitcoin.webcam",
    "localbitcoin.website",
    "localbitcoin.win",
    "localbitcoina.org",
    "localbitcoina.us",
    "localbitcoind.top",
    "localbitcoind.win",
    "localbitcoines.bid",
    "localbitcoines.trade",
    "localbitcoines.win",
    "localbitcoins.accountant",
    "localbitcoins.com.ru",
    "localbitcoins.cz",
    "localbitcoins.design",
    "localbitcoins.gdn",
    "localbitcoins.kim",
    "localbitcoins.life",
    "localbitcoins.net.ru",
    "localbitcoins.site",
    "localbitcoins.space",
    "localbitcoins.top",
    "localbitcoins.webcam",
    "localbitcoins.world",
    "localbitcoins2v.com",
    "localbitcoinsa.com",
    "localbitcoinsd.com",
    "localbitcoinse.com",
    "localbitcoinsforo.net",
    "localbitcoinss.com",
    "localbitcoinss.net",
    "localbitcoinsw.com",
    "localbitcoint.bid",
    "localbitcoint.loan",
    "localbitcoint.top",
    "localbitcoinw.com",
    "localbitcoinx.com",
    "localbitcois.biz",
    "localbitcois.info",
    "localbitcois.loan",
    "localbitcois.men",
    "localbitcois.org",
    "localbitcois.ru",
    "localbitcois.trade",
    "localbitcois.us",
    "localbitcois.win",
    "localbitcoisn.net",
    "localbitcoiuns.com",
    "localbitcoiyns.com",
    "localbitcojins.com",
    "localbitcolns.info",
    "localbitconis.biz",
    "localbitconis.com",
    "localbitconis.net",
    "localbitconis.org",
    "localbitconis.top",
    "localbitcons.bid",
    "localbitcons.biz",
    "localbitcons.info",
    "localbitcons.net",
    "localbitcons.ru",
    "localbitcons.space",
    "localbitcons.us",
    "localbitcons.win",
    "localbitcouins.club",
    "localbitcouins.com",
    "localbitcouins.net",
    "localbitcouins.net.ru",
    "localbitcouins.site",
    "localbitcouins.website",
    "localbitcouins.xyz",
    "localbitcouns.biz",
    "localbitcouns.us",
    "localbitcpins.us",
    "localbitcpoins.com",
    "localbitcxoins.com",
    "localbitdcoins.com",
    "localbitfcoins.com",
    "localbitkoin.com",
    "localbitkoins.bid",
    "localbitkoins.club",
    "localbitkoins.co",
    "localbitkoins.com",
    "localbitkoins.download",
    "localbitkoins.faith",
    "localbitkoins.loan",
    "localbitkoins.men",
    "localbitkoins.pro",
    "localbitkoins.ru",
    "localbitkoins.site",
    "localbitkoins.top",
    "localbitkoins.trade",
    "localbitkoins.us",
    "localbitkoins.win",
    "localbitocins.org",
    "localbitoins.bid",
    "localbitoins.biz",
    "localbitoins.club",
    "localbitoins.info",
    "localbitoins.loan",
    "localbitoins.org",
    "localbitoins.ru",
    "localbitoins.trade",
    "localbitoins.us",
    "localbitoins.win",
    "localbitqoins.com",
    "localbitscoins.bid",
    "localbitscoins.club",
    "localbitscoins.faith",
    "localbitscoins.men",
    "localbitscoins.org",
    "localbitscoins.top",
    "localbitscoins.us",
    "localbitscoins.win",
    "localbitsoins.com",
    "localbitvoins.com",
    "localbiutcoins.com",
    "localbiycoins.com",
    "localbjtcoins.com",
    "localbotcoins.top",
    "localbotcoins.trade",
    "localbtcoins.biz",
    "localbtcoins.men",
    "localbtcoins.org",
    "localbtcoins.win",
    "localbttcoins.ru",
    "localbuitcoins.com",
    "localbutcoins.bid",
    "localbutcoins.faith",
    "localbutcoins.info",
    "localbutcoins.men",
    "localbutcoins.win",
    "localbutscoins.com",
    "localbvitcoins.com",
    "localgbitcoins.com",
    "localgitcoins.com",
    "localhitcoins.com",
    "localibtcoins.com",
    "localitcoins.bid",
    "localitcoins.biz",
    "localitcoins.club",
    "localitcoins.info",
    "localitcoins.men",
    "localitcoins.org",
    "localitcoins.top",
    "localitcoins.us",
    "localkbitcoins.com",
    "localnitcoins.biz",
    "localnitcoins.com",
    "localnitcoins.us",
    "localpitcoins.com",
    "localsbitcoins.info",
    "localsbitcoins.ru",
    "localsbitcoins.top",
    "localsbitcoins.us",
    "localsbitcoins.win",
    "localsbitscoins.com",
    "localvitcoins.xyz",
    "localvitscoins.com",
    "localybitcoins.com",
    "locaslbitcoins.org",
    "locazlbitcoins.com",
    "locfalbitcoins.com",
    "loclabitcoins.net",
    "loclabitcoins.us",
    "loclbitcoins.accountant",
    "loclbitcoins.asia",
    "loclbitcoins.club",
    "loclbitcoins.cricket",
    "loclbitcoins.date",
    "loclbitcoins.download",
    "loclbitcoins.faith",
    "loclbitcoins.loan",
    "loclbitcoins.org",
    "loclbitcoins.party",
    "loclbitcoins.pro",
    "loclbitcoins.racing",
    "loclbitcoins.review",
    "loclbitcoins.science",
    "loclbitcoins.site",
    "loclbitcoins.space",
    "loclbitcoins.top",
    "loclbitcoins.trade",
    "loclbitcoins.website",
    "loclbitcoins.win",
    "locqlbitcoins.com",
    "loczlbitcoins.com",
    "lodcalbitcoins.com",
    "logalbitcoins.com",
    "loicalbitcoins.com",
    "lokalbicoins.com",
    "lokalbitcoin.com",
    "lokalbitcoins.bid",
    "lokalbitcoins.club",
    "lokalbitcoins.date",
    "lokalbitcoins.host",
    "lokalbitcoins.me",
    "lokalbitcoins.men",
    "lokalbitcoins.mobi",
    "lokalbitcoins.online",
    "lokalbitcoins.racing",
    "lokalbitcoins.review",
    "lokalbitcoins.science",
    "lokalbitcoins.site",
    "lokalbitcoins.space",
    "lokalbitcoins.stream",
    "lokalbitcoins.top",
    "lokalbitcoins.us",
    "lokalbitcoins.win",
    "lokalbitscoins.com",
    "lokalbutcoins.com",
    "lokalsbitcoins.com",
    "lokcalbitcoins.com",
    "loqalbitcoins.com",
    "lovalbitcoins.biz",
    "lpcalbitcoins.com",
    "lpocalbitcoins.com",
    "luocalbitcoins.com",
    "mercaotx.com",
    "mercatoox.com",
    "mercatox.market",
    "mercattox.com",
    "mervatox.com",
    "myeterwallet.su",
    "myethereum-wallet-com.com",
    "myethereum-wallet-com.info",
    "myethereum-wallet-com.site",
    "myetherwallet-drop.space",
    "myetherwallet-em.space",
    "myetherwallet-eu.space",
    "myetherwallet-msgsign.space",
    "myetherwallet.claim.erc-20.bonus.tokens-mew.com",
    "myethiwallet.com",
    "myethwachltet.com",
    "myethwatchlet.com",
    "myethwatchllet.com",
    "myselherwallel.com",
    "ocalbitcoins.net",
    "olcalbitcoins.com",
    "v-kraken.com",
    "www-binance.online",
    "xn--binnc-5wa6l.com",
    "xn--huob-oza.com",
    "xn--krake-wm1b.com",
    "xn--krakn-f61b.com",
    "xn--krken-yqa.com",
    "xn--krkn-cta9976b.com",
    "medium-ether.com",
    "gift-btc.net",
    "myetnerwallet.com.application-send.info",
    "application-send.info",
    "mediumz.top",
    "giveawayether.net",
    "drgnairdrop.com",
    "huobiglo.live",
    "getmusk.space",
    "poloniextron.blogspot.com",
    "btc-promo.info",
    "myetherwallet.16mb.com",
    "blog.0xproject.co",
    "0xproject.co",
    "wallet.pollux.network",
    "pollux.network",
    "mvelnerwallet.com",
    "multplatforlex.asia",
    "cryptoblackfriday.blogspot.com",
    "freecryptogift.org",
    "tronblackfriday.blogspot.com",
    "btc-gift.tech",
    "neoblackfriday.blogspot.com",
    "ayetherwallet.com",
    "binance.faith",
    "binance.racing",
    "binances.top",
    "design.klocalbitcoins.com",
    "design.localbitcoin.stream",
    "design.localbitcoin.top",
    "design.localbitcoind.com",
    "design.localbitcoinjs.com",
    "design.localbitcoins.su",
    "design.localbitcoinw.com",
    "design.localbitcoinzs.com",
    "hitbtc.bid",
    "hitbtc.biz",
    "hitbtc.club",
    "hitbtc.link",
    "hitbtc.loan",
    "hitbtc.online",
    "hitbtc.press",
    "hitbtc.top",
    "hitbtc.trade",
    "hitbtc.win",
    "hitbttc.com",
    "huobi.press",
    "i1.klocalbitcoins.com",
    "i1.localbitcoin.download",
    "i1.localbitcoin.us",
    "i1.localbitcoin.website",
    "i1.localbitcoind.com",
    "i1.localbitcoinjs.com",
    "i1.localbitcoins.date",
    "i1.localbitcoins.gdn",
    "i1.localbitcoins.su",
    "i1.localbitcoinsa.com",
    "i1.localbitcoinw.com",
    "i1.localbitcoinzs.com",
    "i1.localbitcois.info",
    "i2.localbitcoin.bid",
    "i2.localbitcoinjs.com",
    "i2.localbitcoinsa.com",
    "i2.localbitcoinw.com",
    "i2.localbitcoinzs.com",
    "klocalbitcoins.com",
    "lacalbitcoins.com",
    "lcalbitcoins.info",
    "lcalbitcoins.net",
    "licalbitcoins.com",
    "lkcalbitcoins.com",
    "lkocalbitcoins.com",
    "llcalbitcoins.com",
    "loalbitcoins.bid",
    "loalbitcoins.info",
    "loalbitcoins.pro",
    "locabitcoins.bid",
    "locabitcoins.biz",
    "locabitcoins.club",
    "locabitcoins.info",
    "locabitcoins.loan",
    "locabitcoins.org",
    "locabitcoins.ru",
    "locabitcoins.us",
    "locablitcoins.net",
    "locakbitcoins.com",
    "locaklbitcoins.com",
    "localb8tcoins.com",
    "localbaytcoins.com",
    "localbgitcoins.com",
    "localbhitcoins.com",
    "localbi5coins.com",
    "localbicoins.men",
    "localbidcoins.com",
    "localbifcoins.com",
    "localbiftcoins.com",
    "localbigcoins.com",
    "localbigtcoins.com",
    "localbiitcoins.net",
    "localbijtcoins.com",
    "localbircoins.info",
    "localbirtcoins.com",
    "localbitc9ins.com",
    "localbitciins.com",
    "localbitcins.bid",
    "localbitcins.ru",
    "localbitco9ins.com",
    "localbitcoibs.com",
    "localbitcoihns.com",
    "localbitcoiins.com",
    "localbitcoijns.com",
    "localbitcoijs.com",
    "localbitcoikns.com",
    "localbitcoin.accountant",
    "localbitcoin.click",
    "localbitcoin.club",
    "localbitcoin.com.ru",
    "localbitcoin.date",
    "localbitcoin.download",
    "localbitcoin.faith",
    "localbitcoin.icu",
    "localbitcoin.me",
    "localbitcoin.men",
    "localbitcoin.mobi",
    "localbitcoin.net.ru",
    "localbitcoin.online",
    "localbitcoin.stream",
    "localbitcoin.us",
    "localbitcoina.com",
    "localbitcoina.info",
    "localbitcoina.xyz",
    "localbitcoinas.com",
    "localbitcoind.com",
    "localbitcoind.info",
    "localbitcoind.net",
    "localbitcoind.us",
    "localbitcoinds.com",
    "localbitcoines.loan",
    "localbitcoines.space",
    "localbitcoines.us",
    "localbitcoinhs.com",
    "localbitcoinjs.com",
    "localbitcoinms.com",
    "localbitcoinns.com",
    "localbitcoins.agency",
    "localbitcoins.asia",
    "localbitcoins.bid",
    "localbitcoins.cricket",
    "localbitcoins.date",
    "localbitcoins.faith",
    "localbitcoins.host",
    "localbitcoins.house",
    "localbitcoins.men",
    "localbitcoins.mobi",
    "localbitcoins.party",
    "localbitcoins.press",
    "localbitcoins.pro",
    "localbitcoins.racing",
    "localbitcoins.red",
    "localbitcoins.review",
    "localbitcoins.rocks",
    "localbitcoins.science",
    "localbitcoins.store",
    "localbitcoins.su",
    "localbitcoins.trade",
    "localbitcoins.win",
    "localbitcoins.work",
    "localbitcoins.xyz",
    "localbitcoinsl.com",
    "localbitcoinst.com",
    "localbitcoinsx.com",
    "localbitcoinsz.com",
    "localbitcoint.trade",
    "localbitcoint.win",
    "localbitcoinws.com",
    "localbitcoinxs.com",
    "localbitcoinzs.com",
    "localbitcois.bid",
    "localbitcois.space",
    "localbitcoisn.com",
    "localbitcojns.com",
    "localbitcokins.com",
    "localbitcokns.com",
    "localbitcons.loan",
    "localbitcons.men",
    "localbitcons.trade",
    "localbitcooins.com",
    "localbitcoons.com",
    "localbitcopins.com",
    "localbitcouins.info",
    "localbitcouins.space",
    "localbitcouns.com",
    "localbitcoyns.com",
    "localbitcpins.com",
    "localbitcuins.com",
    "localbitcvoins.com",
    "localbitdoins.com",
    "localbitfoins.com",
    "localbitgcoins.com",
    "localbitkoins.date",
    "localbitkoins.info",
    "localbitkoins.mobi",
    "localbitkoins.net",
    "localbitkoins.org",
    "localbitkoins.space",
    "localbitocins.com",
    "localbitocins.info",
    "localbitocins.xyz",
    "localbitoins.net",
    "localbitrcoins.com",
    "localbitscoin.com",
    "localbitscoins.download",
    "localbitscoins.net",
    "localbitscoins.ru",
    "localbitskoins.com",
    "localbittcoins.com",
    "localbitvcoins.com",
    "localbitxcoins.com",
    "localbitxoins.com",
    "localbitycoins.com",
    "localbiytcoins.com",
    "localbjitcoins.com",
    "localbkitcoins.com",
    "localbktcoins.com",
    "localbnitcoins.com",
    "localboitcoins.com",
    "localbotcoins.info",
    "localbtcoins.info",
    "localbtcoins.loan",
    "localbtcoins.trade",
    "localbticoins.net",
    "localbutcoins.biz",
    "localbutcoins.club",
    "localbutcoins.com",
    "localbutcoins.ru",
    "localbutcoins.space",
    "localbutcoins.top",
    "localbutcoins.trade",
    "localbutcoins.us",
    "localbutcoins.xyz",
    "localbutkoins.com",
    "localbytcoins.com",
    "localbytecoins.com",
    "localhbitcoins.com",
    "localitcoins.loan",
    "localitcoins.ru",
    "localitcoins.trade",
    "localitcoins.win",
    "localnbitcoins.com",
    "localnitcoins.org",
    "localnitscoins.com",
    "localpbitcoins.com",
    "localsbitcoins.loan",
    "localsbitkoins.com",
    "localvbitcoins.com",
    "localvitcoins.com",
    "locanbitcoins.com",
    "locaobitcoins.com",
    "locapbitcoins.com",
    "locaqlbitcoins.com",
    "locawlbitcoins.com",
    "loccalbitcoins.com",
    "locdalbitcoins.com",
    "locelbitcoins.com",
    "loclabitcoins.com",
    "loclbitcoins.bid",
    "loclbitcoins.host",
    "loclbitcoins.info",
    "loclbitcoins.men",
    "loclbitcoins.press",
    "loclbitcoins.ru",
    "loclbitcoins.stream",
    "loclbitcoins.webcam",
    "loclbitscoins.com",
    "locqalbitcoins.com",
    "locslbitcoins.com",
    "locvalbitcoins.com",
    "locwalbitcoins.com",
    "locwlbitcoins.com",
    "locxalbitcoins.com",
    "loczalbitcoins.com",
    "lodalbitcoins.com",
    "lofcalbitcoins.com",
    "login.localbitcoins.com.localbitcoinns.com",
    "lokalbitcoins.biz",
    "lokalbitcoins.co",
    "lokalbitcoins.download",
    "lokalbitcoins.loan",
    "lokalbitcoins.org",
    "lokalbitcoins.pro",
    "lokalbitcoins.ru",
    "lokalbitcoins.website",
    "lokalbitcoints.com",
    "lokalbitscoin.com",
    "loklbitcoins.com",
    "lolcalbitcoins.com",
    "loocalbitcoins.com",
    "losalbitcoins.com",
    "loucalbitcoins.com",
    "lovalbitcoins.com",
    "lovcalbitcoins.com",
    "loxalbitcoins.com",
    "loxcalbitcoins.com",
    "mercarox.com",
    "merrcatox.com",
    "myetherwallet-eng.space",
    "myetheywallet.com",
    "paxful-recrutement.com",
    "st.localbitcoin.review",
    "wmyetherwallet.com",
    "binance-dex.top",
    "binance.com1278623.cf",
    "binance.com136347135.ml",
    "binance.com1378623.ga",
    "binance.com16324.ml",
    "binance.com987574.ml",
    "coinbaseoffer.com",
    "coindesk.online",
    "ldex.host",
    "localbitcoins.loan",
    "lopcalbitcoins.com",
    "mail.wallet-trezor.io",
    "myetherwallet-en.space",
    "myetherwallet.logiln.com",
    "myetherwallet.rlogin.co",
    "myetherwelet.com",
    "paxful.com.tubulk.ga",
    "huobiairdrop.info",
    "huobiairdrop.org",
    "huobiairdrop.top",
    "lcgin.com",
    "rlogin.co",
    "blockchain.lcgiin.com",
    "blockchain.llogin.co",
    "blcokchain.llogin.co",
    "blockchain.logirn.com",
    "blockchein.logirn.com",
    "blockchain.lcgin.com",
    "empowr.com",
    "bnbeth.net",
    "dex-bnb.net",
    "paxos-bounty.com",
    "blackfridayneo.blogspot.com",
    "blackfridayetc.blogspot.com",
    "blackfridaycrypto.blogspot.com",
    "btc-gift.live",
    "btc-gift.us",
    "huobiairdrop.net",
    "tesla-crypto.info",
    "bnb-ethcompetition.com",
    "eth.binancegift.pro",
    "binancegift.pro",
    "idex.com.ru",
    "ibex.cc",
    "t-btc.net",
    "etherdelta.com.ru",
    "binance-mmx.com",
    "binance-tx.com",
    "binance-xm.com",
    "binance.com762367321.ml",
    "binance0.com",
    "binance88.com",
    "bitffinnex.com",
    "bitfinexlogin.com",
    "bittrexl.uk.l-lws.com",
    "coinbase-com.cloud",
    "coinbase-com.info",
    "coinbase-com.org",
    "coinbase-com.site",
    "coinbase.fans",
    "giftauroradao.com",
    "localbicoins.ru",
    "localbilcoins.ru",
    "localbitcoins.ltd",
    "localbitcoins.org.ru",
    "localbitcoinsv.com",
    "lofalbitcoins.com",
    "lucalbitcoins.com",
    "wallet-trezor.io",
    "miyetherwallet.pw",
    "myetherwallet-msg.space",
    "myetherwallet.llogin.co",
    "paxful067.000webhostapp.com",
    "paxfulcoins.com",
    "paxiiful.com",
    "polonienx.com",
    "tokens-tronscan.org",
    "xn--bttrx-esar.com",
    "xn--hittc-3jb.com",
    "xn--oinbase-txa.com",
    "stellar-term.store",
    "binance-giveaways.com",
    "btc-verified.com",
    "crypto-giveaways.com",
    "elon-official-giveaway.com",
    "elon-official-promo.com",
    "elon-party.com",
    "elon-presents.com",
    "elon-promotion.com",
    "elon-surprise.com",
    "ethereums-giveaway.com",
    "gainbtc.org",
    "get-btcs-now.com",
    "get-eths-now.com",
    "giftbtc.org",
    "giveaway-official.org",
    "grab-btc.com",
    "limited-promo.org",
    "limited-promotion.com",
    "limited-promotion.org",
    "musk-gives.com",
    "musk-presents.com",
    "musk-promotion.com",
    "musk-surprise.com",
    "treats-from-elon.blogspot.com",
    "official-giveaway.org",
    "promo-official.com",
    "promo-official.org",
    "promotion-official.com",
    "promotion-official.org",
    "binances.pro",
    "bittrex.management",
    "bittrex.promo",
    "idexmarket.host",
    "kraken--login.com",
    "meercatox.com",
    "mercaatox.com",
    "myetherwallet-pdtt.host",
    "myetherwallet-signcoin.top.md-56.webhostbox.net",
    "myetherwallet-toh.host",
    "online-image.ml",
    "spaxful.com",
    "xn--bitfnexs-wkb.com",
    "xn--phod-xpa08i.com",
    "dexairdropevent.com",
    "eth.tronnetwork.pw",
    "btc.tronnetwork.pw",
    "tronnetwork.pw",
    "pool-neo.blogspot.com",
    "lbexm.com",
    "lbexmarnet.com",
    "lbexmet.com",
    "ldcxmanket.com",
    "binance-beta.net",
    "binance.best-org.mx",
    "binance.com169823623.gq",
    "binance.space",
    "binancex.club",
    "binancex.org",
    "coinbase-pro.net",
    "coinbase-pro.org",
    "coinbase.group",
    "coinbasesto.com",
    "locabitcoins.mobi",
    "locabitcoins.pro",
    "localbicoins.mobi",
    "localbicoins.pro",
    "localbitcois.pro",
    "localbitcons.mobi",
    "localbitcons.pro",
    "localbitcooins.ru",
    "localbitoins.mobi",
    "localbitoins.pro",
    "localbtcoins.mobi",
    "localbtcoins.pro",
    "localitcoins.mobi",
    "localitcoins.pro",
    "my-etherwallet.online",
    "myether-wallet.online",
    "myethermallet.online",
    "myetherwailet.club",
    "myetherwallet-pdt.host",
    "myetherwallet.com.noreply.group",
    "rnyetharwallet.com",
    "rnyetherwellet.com",
    "trezor-shop.com",
    "trezor-store.com",
    "xn--aken-f0a6q.com",
    "xn--bitfnex-ufb.com",
    "xn--coinbac-xs4c.com",
    "xn--hibtc-s9b.com",
    "xn--kaen-h0a4q.com",
    "xn--myetherwalt-b3b8729g.com",
    "xn--mytherwllet-ife0916g.com",
    "xn--phold-erb.com",
    "dexbnb.net",
    "xn--bockchan-81a78e.com",
    "ico.karatgold.io.bonus.wallet-crypto-member.com",
    "wallet-crypto-member.com",
    "btc-gift.net",
    "xfreecrypto.blogspot.co.nz",
    "xfreeneo.blogspot.com",
    "e1contest.blogspot.com",
    "dexbinancebeta.org",
    "dcontestd.blogspot.com",
    "fastcryptogiveaway.website",
    "bcryptob.blogspot.com",
    "acontesta.blogspot.com",
    "elon.gift",
    "xn--dex-klz.market",
    "contestc.blogspot.com",
    "ethereum-generator.cf",
    "0xproject.org",
    "pollux.ai",
    "wallet.pollux.ai",
    "get-10000-ethereum.org",
    "crypto-giveaway.org",
    "btc-crypto.me",
    "crypto-return.online",
    "crypto-share.online",
    "tesla-gift.com",
    "tesla-promo.top",
    "ldex-market.host",
    "xn--blocchn-4ya8tls.com",
    "xn--myeterwaliet-fs4f.com",
    "xn--blockhan-w0a6d.com",
    "xn--bockhain-v0a06f.com",
    "xn--bockcha-eza81eld.com",
    "login.xn--bockcha-eza81eld.com",
    "shapeshitf.io",
    "shapehift.io",
    "coinbase.xm-login2.com",
    "am-ov.store",
    "xm-login2.com",
    "etherdesk.co",
    "immigrationpoint.co.uk",
    "ldcxmarket.com",
    "ldcxmarket.info",
    "ldexmark.com",
    "ldexmark.info",
    "myetherwallet-sing.top.md-66.webhostbox.net",
    "xn--localbitcoi-ix8e.com",
    "xn--phod-21a07d.com",
    "binance-inc.com",
    "binance.com185665.cf",
    "bithumb.biz",
    "coinbase.team",
    "coingase.com",
    "idex-market.fun",
    "idex-market.host",
    "localbitcoins-signup.com",
    "localbotcoins.com",
    "m30-coinbase.com",
    "myetherrwallets.club",
    "xn--myetherwalet-m8b.com",
    "xn--myetherwalt-kbb19h.com",
    "xn--myethrwall-b22ep7afa.com",
    "xn--phod-kra55b.com",
    "zzuc.coinbasez.com",
    "bittrex.live",
    "coinbase-giveaway.site",
    "localbicoins.info",
    "localbitcoints.net",
    "localbitcoints.ru",
    "localebitcoins.ru",
    "loccalbitcoins.ru",
    "myetherwallet-msgsign.top.md-86.webhostbox.net",
    "myethirwalet.com",
    "upholld.com",
    "xn--dx-h7s6c.market",
    "xn--idx-kjz.market",
    "xn--mythrwalet-yq3ec1v.com",
    "xn--phod-21a6v.com",
    "xn--phod-zra73b.com",
    "coinbasedomain.club",
    "coinbasehelp.com",
    "coinbasesm.com",
    "myetherrwallets.icu",
    "xn--conbase-8ya.com",
    "xn--myethrwallt-crb6279g.com",
    "bancor-network.com",
    "bancor.ltd",
    "lbittrex.com",
    "myetherrwallets.pw",
    "myetherwallet-admin.xyz",
    "paxfulj.com",
    "xn--dex-1ta.etherdetta.com",
    "xn--dex-1ta.market",
    "xn--dex-1ub.market",
    "xn--dex-6jb.market",
    "xn--dex-iua.market",
    "xn--dex-lta.market",
    "xn--dex-odb.market",
    "cutduct.com",
    "myetherwallett.tech",
    "mymonero.me",
    "xn--dex-fkb.market",
    "xn--myetherwale-z3b32c.com",
    "binance-dx.org",
    "coinbase.markets",
    "localbitcoins-4f.com",
    "localbitcoins.cloud",
    "myethereum-login.com",
    "rnyethervwallet.com",
    "steambalance.info",
    "xn--dex-clz.market",
    "xn--myetherwalet-n8b.com",
    "xn--myetherwalt-0rb76b.com",
    "xn--mytherwalet-15b5619g.com",
    "xn--mythrwalet-8k2ep1dca.com",
    "xn--upold-y2a.com",
    "amazonbalance.com",
    "emeyetherweallet.com",
    "ld-hitbtc.com",
    "localbircoins.biz",
    "localbitcins.biz",
    "localbitcoind.biz",
    "localbitconis.ru",
    "localbitcouins.biz",
    "localbitscoins.biz",
    "meetherwallet.website",
    "metamaskconnect.org",
    "meyetherwallct.com",
    "meytferwallet.com",
    "meytherwallet.co",
    "meytherwallet.org",
    "my-etherwalletcorp.com",
    "mycryptoethwallet.com",
    "mycthcrwallet.com",
    "myeetherwallet.space",
    "myehterwallet.us",
    "myertherewallet.com",
    "myeterwallet.info",
    "myetheawllet.com",
    "myethedwallet.info",
    "myetheerwallet.space",
    "myetheerwallet.top",
    "myetheerwallet.website",
    "myethefwallet.info",
    "myether-walletcorp.com",
    "myetherawallet.info",
    "myetherewallet.biz",
    "myethertwallet.online",
    "myetherwafllet.com",
    "myetherwal11et.com",
    "myetherwalel.com",
    "myetherwallelet.com",
    "myetherwallet-blnance.space",
    "myetherwallet-bnb.space",
    "myetherwallet-checks.space",
    "myetherwallet-coin.space",
    "myetherwallet-coinhydro.top",
    "myetherwallet-coinss.top",
    "myetherwallet-cps.space",
    "myetherwallet-cripto.space",
    "myetherwallet-dec.space",
    "myetherwallet-ecta.space",
    "myetherwallet-hydrocoin.top",
    "myetherwallet-hydrogen.space",
    "myetherwallet-hydrosmg.space",
    "myetherwallet-hydrotokens.space",
    "myetherwallet-ign.space",
    "myetherwallet-kep.space",
    "myetherwallet-knd.space",
    "myetherwallet-knp.space",
    "myetherwallet-log.space",
    "myetherwallet-login.space",
    "myetherwallet-logincoin.space",
    "myetherwallet-lvt.space",
    "myetherwallet-mpcx.space",
    "myetherwallet-nobs.space",
    "myetherwallet-rix.space",
    "myetherwallet-sgn.top",
    "myetherwallet-shlt.space",
    "myetherwallet-sig.space",
    "myetherwallet-siggn.space",
    "myetherwallet-sigin.space",
    "myetherwallet-sigl.space",
    "myetherwallet-sign.space",
    "myetherwallet-signcoins.space",
    "myetherwallet-signcoins.top",
    "myetherwallet-signhydro.space",
    "myetherwallet-signin.space",
    "myetherwallet-signl.space",
    "myetherwallet-signlog.space",
    "myetherwallet-signmsg.space",
    "myetherwallet-signn.space",
    "myetherwallet-signt.space",
    "myetherwallet-sit.space",
    "myetherwallet-tix.space",
    "myetherwallet-token.space",
    "myetherwallet-tokens.space",
    "myetherwallet-wabsign.space",
    "myetherwallet-xcmd.space",
    "myetherwallet.bplaced.net",
    "myetherwallet.com.login-status.info",
    "myetherwallet.net.ru",
    "myetherwdllet.com",
    "myetherwealletr.com",
    "myethewallets.com",
    "myethierwaliet.net",
    "myethirewallet.com",
    "myethrswallet.com",
    "myethrwallet.info",
    "myettherwaellet.com",
    "myettherwallet.website",
    "mytherwallet.news",
    "mytherwallet.site",
    "mytherwellet.com",
    "myyetherwallet.space",
    "paxful.com.jobora.ml",
    "private-myetherwallet.quanta.im",
    "rnyethervwallet.info",
    "xn--binnce-yoc.com",
    "xn--btrx-dpap16f.com",
    "xn--bttex-cta85e.com",
    "xn--htbt-3oa2b.com",
    "xn--metherwalet-ms8eq4b.com",
    "xn--myeterwalle-3ic6876g.com",
    "xn--myetherallet-wt5f.com",
    "xn--myethewallt-738eu8b.com",
    "xn--myethrwllet-q7a31e.com.com",
    "xn--myetrwallet-5qb7087g.com",
    "xn--mytherwallt-019eia.com",
    "xn--mythrwalet-c7ac57i.com",
    "xn--phod-21a40a.com",
    "xn--ploniex-90a.com",
    "xn--poloex-6va52e.com",
    "xn--poloiex-nkb.com",
    "bennychophouse.com",
    "www-idex.market",
    "xn--mytherwallt-3qbi.com",
    "xn--uphod-n7a.com",
    "binance-dex.club",
    "binance.efilum.de",
    "binances.com",
    "bitfinex.ltd",
    "bittrex.com.qdgcx.com",
    "bittrexi.bid",
    "bnbbinance.com",
    "coinbaseapp.com",
    "dexbinance.club",
    "idexi.market",
    "m-paxful.com",
    "mail.myetherrwaliet.com.cp-19.webhostbox.net",
    "myetherrwaliet.com.cp-19.webhostbox.net",
    "myetherwallet-c.space",
    "myetherwallet-distribution.space",
    "myetherwalletsolutions.com",
    "paxfulreport.com",
    "stobithumb.com",
    "uphold.cf",
    "xn--coinsbnk-nza.com",
    "xn--paxfl-4ua.com",
    "xn--pxful-gra.com",
    "spacex.to",
    "xlm-wallet.com",
    "getpetrocoin.com",
    "paxosbounty.com",
    "etoro-exchange.com",
    "musk.plus",
    "spacex.plus",
    "elongift.space",
    "musk.fund",
    "c-crypto.me",
    "p-crypto.pw",
    "c-crypto.pw",
    "elonbtc.me",
    "p-crypto.me",
    "elonmusk.gift",
    "bcrypto.pro",
    "bcrypto.pw",
    "coinbase.plus",
    "bcrypto.live",
    "ehitbtc.com.viptempobetgirisi.com",
    "hit-blentf-com.blogspot.com",
    "paxful.com.autaro.tk",
    "autaro.tk",
    "ethereum-giveaway.net",
    "bonus.ethereum-giveaway.net",
    "go.ethereum-giveaway.net",
    "enter.ethereum-giveaway.net",
    "join-eth-promotion.ethereum-giveaway.net",
    "participate.ethereum-giveaway.net",
    "etherdelta.ru",
    "ethereumgifting.com",
    "bithumb.today",
    "coinbasehotelcard.com",
    "coinbasepromo.us",
    "cox.com-6159368de39251d7a-login.id-107sbtd9cbhsbtd5d80a13c0db1f546757jnq9j5754675782500416.kylelierman.com",
    "etherwallet.it",
    "etherwallet.shop",
    "etherwallet.world",
    "eyetherwallet.com",
    "iyetherwallet.com",
    "jyetherwallet.com",
    "lhitlbtc.com",
    "lyetherwallet.com",
    "m.yetherwallet.com",
    "myetherwallet5.com",
    "myetherwalleta.com",
    "myetherwalletb.com",
    "myetherwalletc.com",
    "myetherwalletd.com",
    "myetherwallete.com",
    "myetherwalletf.com",
    "myetherwalletg.com",
    "myetherwalleth.com",
    "myetherwalleti.com",
    "myetherwalletie.com",
    "myetherwalletip.com",
    "myetherwalletiy.com",
    "myetherwalletj.com",
    "myetherwalletk.com",
    "myetherwalletm.com",
    "myetherwalletn.com",
    "myetherwalletntw.com",
    "myetherwalleto.com",
    "myetherwalletp.com",
    "myetherwalletq.com",
    "myetherwalletr.com",
    "myetherwallets.cc",
    "myetherwallets.co",
    "myetherwallets.us",
    "myetherwalletto.com",
    "myetherwalletu.com",
    "myetherwalletv.com",
    "myetherwalletw.com",
    "myetherwalletws.com",
    "myetherwalletx.com",
    "myetherwallety.com",
    "myetherwalletz.com",
    "myetherwalleu.com",
    "myetherwallev.com",
    "myetherwallewt.com",
    "myetherwalley.com",
    "myetherwalleyt.com",
    "myetherwallez.com",
    "myetherwallezt.com",
    "myetherwallgt.com",
    "myetherwallit.com",
    "myetherwallket.com",
    "myetherwallmet.com",
    "myetherwallmt.com",
    "myetherwalloet.com",
    "myetherwallot.com",
    "myetherwallpet.com",
    "myetherwallrt.com",
    "myetherwallset.com",
    "myetherwallst.com",
    "myetherwallut.com",
    "myetherwallzet.com",
    "myetherwalnet.com",
    "myetherwaloet.com",
    "myetherwalolet.com",
    "myetherwalpet.com",
    "myetherwalplet.com",
    "myetherwamlet.com",
    "myetherwamllet.com",
    "myetherwanlet.com",
    "myetherwaolet.com",
    "myetherwaollet.com",
    "myetherwaplet.com",
    "myetherwapllet.com",
    "myetherwaqllet.com",
    "myetherwasllet.com",
    "myetherwawllet.com",
    "myetherwazllet.com",
    "myetherwcllet.com",
    "myetherweallet.com",
    "myetherwiallet.com",
    "myetherwillet.com",
    "myetherwlalet.com",
    "myetherwlallet.com",
    "myetherwqallet.com",
    "myetherwqllet.com",
    "myetherwsallet.com",
    "myetherwsllet.com",
    "myetherwullet.com",
    "myetherwwallet.com",
    "myetherwwllet.com",
    "myetherwxallet.com",
    "myetherwyallet.com",
    "myetherwyllet.com",
    "myetherwzallet.com",
    "myetherwzllet.com",
    "myetherxwallet.com",
    "myethesrwallet.com",
    "myethetrwallet.com",
    "myethewallet.com",
    "myethewallet.net",
    "myethewrallet.com",
    "myethewrwallet.com",
    "myethezrwallet.com",
    "myethezwallet.com",
    "myethgerwallet.com",
    "myethgrwallet.com",
    "myethjerwallet.com",
    "myethmrwallet.com",
    "myethnerwallet.com",
    "myethorwallet.com",
    "myethrrwallet.com",
    "myethserwallet.com",
    "myethsrwallet.com",
    "myethuerwallet.com",
    "myethwallct.com",
    "myethwallet.net",
    "myethwallet.uk",
    "myethwerwallet.com",
    "myethwrwallet.com",
    "myethyerwallet.com",
    "myethzerwallet.com",
    "myethzrwallet.com",
    "myetierwallet.com",
    "myetjherwallet.com",
    "myetnerwallet.com",
    "myetnherwallet.com",
    "myetterrwallet.com",
    "myettherwallet.com",
    "myetuerwallet.com",
    "myetuherwallet.com",
    "myetxerwallet.com",
    "myetyerwallet.com",
    "myetyherwallet.com",
    "myetzherwallet.com",
    "myeuherwallet.com",
    "myevherwallet.com",
    "myewtherwallet.com",
    "myeyherwallet.com",
    "myeytherwallet.com",
    "myezherwallet.com",
    "myeztherwallet.com",
    "mygtherwallet.com",
    "myhetherwallet.com",
    "myitherwallet.com",
    "mymtherwallet.com",
    "myotherwallet.com",
    "myretherwallet.com",
    "myrtherwallet.com",
    "mysetherwallet.com",
    "mystherwallet.com",
    "mytetherwallet.com",
    "myuetherwallet.com",
    "myutherwallet.com",
    "mywetherwallet.com",
    "mywtherwallet.com",
    "myxetherwallet.com",
    "myyetherwallet.com",
    "myzetherwallet.com",
    "myztherwallet.com",
    "nnyetherwallet.com",
    "nyetherwallet.com",
    "oyetherwallet.com",
    "poloniex-login.account2fa-login.com",
    "pro-coinbase.online",
    "promobittrex.site",
    "rnyetherwallet.pw",
    "rryetherwallet.com",
    "shapeshifter.gr",
    "sign.xn--mytherwalet-3qb10c.com",
    "trezire.com",
    "uphold.gq",
    "wwmyetherwallet.com",
    "xn--myetherwalet-lcc.net",
    "xn--myethrwalle-3bb60n.com",
    "xn--mytherwallt-qpbi.com",
    "yetherwallet.com",
    "ymetherwallet.com",
    "binance-exchange.space",
    "binancekp.com",
    "coinbesebtc.com",
    "getnaij.altervista.org",
    "mobile3490-coinbase.com",
    "mobile3490-coinbase.site",
    "myetherlogin.com",
    "myetherwallet-trade.space",
    "myetherwalletmsg.com",
    "myethwatchlett.com",
    "pafxulcom.000webhostapp.com",
    "parxful.com",
    "pro4-coinbase.space",
    "xn--kaken-5bb.com",
    "xn--kaken-icb.com",
    "xn--blokchain-login-20b.com",
    "xn--login-blockchai-7uc.com",
    "xn--www-blockchan-m9b.com",
    "wallet.paxfulassist.com",
    "paxfulassist.com",
    "paxful.w3schoolsonline.com",
    "paxful.com.leverk.cf",
    "leverk.cf",
    "appbittrex.com",
    "account-bittrex.com",
    "bittrex-es.com",
    "security-bittrex.com",
    "en-coinbase.com",
    "bd-bitfinex.com",
    "bitfniex.com",
    "bittrex.online",
    "coinbasesupportnumbers.com",
    "myetherwallet-binance.space",
    "myetherwallet-check.space",
    "myetherwallet-ether.space",
    "myetherwallet-mi.space",
    "pax-ful.com",
    "paxful1.com",
    "shapeshifit.me",
    "shapeshifted.net",
    "stobinance.com",
    "xn--idx-tra.market",
    "xn--raen-k0ac.com",
    "bittrex.net.security-login2fa.com",
    "bittrexi.men",
    "paxful.com.joiery.cf",
    "hitbtc.pratiktlyukleme.com",
    "xn--mercaox-rrb.com",
    "xn--phld-rqa7a.com",
    "xn--uphod-e4a.com",
    "xn--uhol-bsa9h.com",
    "xn--uphod-95a.com",
    "xn--hold-pray.com",
    "xn--phold-kfb.com",
    "xn--phold-0ua.com",
    "elherscan.host",
    "claim-ethers.com",
    "givetrx.blogspot.com.au",
    "ethergiffcrypto.webcindario.com",
    "zen-smartgives.space",
    "win-give-away.club",
    "coinbasepromo.webcindario.com",
    "mediun-blog-coinbasepro1.tumblr.com",
    "ethwalletbonus.com",
    "crypton-exchange.com",
    "omisego-network.io",
    "easy-ethers.com",
    "dexxlaunch.com",
    "airdrop.systems",
    "simbatools.com",
    "nextbitcoinwallet.com",
    "dentairdrop.com",
    "get-smartsend.website",
    "bigcoingift.club",
    "cryptogive.rf.gd",
    "verify.xn--myethrwllet-xt9e3k.com",
    "musk-cryptocurrency.info",
    "dexchainevent.info",
    "karatgold.io.bonus.award.wallet-token-member.com",
    "wallet-token-member.com",
    "cryponium.info",
    "neogive.blogspot.ie",
    "promocrypt.com",
    "get-smartcontract.website",
    "transfer.getmore.host",
    "give-neo.blogspot.com",
    "give-neo.blogspot.ro",
    "elongives.tech",
    "iost-airdrop.com",
    "bin-launch.com",
    "givecrypto.website",
    "freecrypto-x.blogspot.com",
    "binance-shb.com",
    "binance.cash",
    "bitbank.group",
    "bithumbsto.com",
    "bittrex-login.oficial-homepage.com",
    "bittrex.com.oficial-homepage.com",
    "coinbasemining.biz",
    "coinsbank365.com",
    "huobi.loans",
    "kraken.gq",
    "krakenni.com",
    "myetherwallet-eth.space",
    "myetherwallet-hydr.space",
    "myetherwallet-idap.space",
    "paxful.trade",
    "paxfulj.trade",
    "paxfulrectify.com",
    "paxfulsecureteam.com",
    "paxfulsecurity.com",
    "paxfulvalidate.com",
    "paxfulverified.com",
    "poloniex-fr.com",
    "xn--iex-vyy.market",
    "xn--myethewllet-2kb87h.com",
    "binance.com1235723786.cf",
    "binance.com1762378235.cf",
    "binance.tax",
    "binancealtcoin.com",
    "bithumb.center",
    "bittrex-rm.com",
    "bwidthherop.herokuapp.com",
    "coinbase.company",
    "coinbase.gold",
    "coinbase.institute",
    "coinbase.market",
    "coinbase.network",
    "coinbase.page",
    "coinbase.pizza",
    "coinbase.properties",
    "coinbase.rip",
    "coinbase.software",
    "coinbasepromo.com",
    "coinbases.fr",
    "freecoinbase.com",
    "idex.services",
    "kraken.tools",
    "mercatox.net",
    "myethereurnwallet.com",
    "myetherrwallet.icu",
    "myetheruemwallet.com",
    "myetherwallet-stars.space",
    "myetherwallet.team",
    "myethierwallet.tech",
    "myethirwallet.online",
    "poloniex-rm.com",
    "poloniexsign.com",
    "poloniexsignup.com",
    "rnyethervallet.com",
    "widgets.www.ibexofmark.com",
    "xn--binane-f1a.com",
    "xn--bttrexx-gza.com",
    "xn--coinxchange-2bb.com",
    "xn--htbt-vpa3n.com",
    "xn--htbt-vpa5o.com",
    "xn--login-blockchan-okc.com",
    "xn--mercaox-brb.com",
    "binanceholding.com",
    "binanceholdings.com",
    "binancesgp.com",
    "coinbahis8.com",
    "ethfinex.net",
    "indodax-sdr.com",
    "isidorian-knobs.000webhostapp.com",
    "myetheruim.com",
    "myetherwallet-lot.space",
    "myetherwallt.net",
    "myethrwllet.com",
    "paxful-com.com",
    "paxful.ink",
    "trustwallet.co.uk",
    "binance-event.com",
    "binance-labs.com",
    "binance.com986213.ga",
    "binnance24.com",
    "bittrex-login.accountt-apps.com",
    "bittrex.com.tradinglending.com",
    "coinbase.aa-gg.com",
    "exchange-coindesk.com",
    "mnyelherwallel.com",
    "myetheruimwallet.com",
    "myethervvallet.us",
    "myetherwaliet.space",
    "myetherwallet-bing.space",
    "myetherwallet-ken.space",
    "myetherwallet-me.space",
    "myetherwallet-mr.space",
    "myetherwallet-my.space",
    "myetherwallet-sam.space",
    "myetherwallet-se.space",
    "myetherwallet.airdropmew.com",
    "myetherwallet.com.signin.message.dolphinexplorer.sg",
    "sign.xn--myethrwllet-ife3916g.com",
    "wkraken.com",
    "xn--myeterwallt-cm8e02e.com",
    "biinancelab.com",
    "binance-zendesk.com",
    "binance.com198367236.ml",
    "binanclogin.com",
    "bithumbex.com",
    "coinbasepromocode.com",
    "com12334567736789854.ml",
    "com124487897653274.ga",
    "com164795623564456654.ml",
    "com188565235654846.ml",
    "ethfinix.com",
    "huoobi.pro",
    "ibinance.com",
    "idex.agency",
    "idex.company",
    "localethereum.app",
    "my-ether-wallet.com",
    "myetharwellat.com",
    "myetherwallet.co.uk",
    "paxfullogin.us",
    "poloniexchina.com",
    "rnelherwallel.com",
    "rnyelherwallel.com",
    "sign-in.coinbase.com.puracosmetica.pt",
    "trade-indodax.com",
    "web-binance.com.ru",
    "xn--binne-hwa5e.net",
    "xn--bockchain-gsb.com",
    "xn--coinexchang-xbb.com",
    "xn--coinxchange-qbb.com",
    "xn--dex-uma.com",
    "xn--dx-bjao.market",
    "xn--myethrwllet-xt9e3k.com",
    "xn--mytherwalliet-4o2g.com",
    "xn--mytherwallt-79ae.com",
    "xn--mytherwllt-smb383ayq9k.com",
    "binance.com13897234.gq",
    "binanceusa.com",
    "coinbase-eth.org",
    "hitbtcvip.com",
    "idexj.market",
    "ios-icloud.us",
    "plooniex.com",
    "xn--biinanc-z8a.net",
    "xn--binace-zeb.net",
    "xn--binanc-n4a.net",
    "xn--binane-0ua.net",
    "xn--bnance-bwa.net",
    "xn--myeherwallt-crb6378g.com",
    "ildex.space",
    "1coinbase.com",
    "8idex.market",
    "9idex.market",
    "binance-get.fund",
    "binance-official.fund",
    "binance.com17268923.ml",
    "binance.com18976231.gq",
    "binancest.com",
    "binanecisecurity-com.com",
    "bitcoinspoloniexchange.com",
    "bitfinexvip.com",
    "bithumbvip.com",
    "bittrex.club",
    "coinbase-pro.com",
    "coinbasevip.com",
    "hitdtc.online",
    "hltbtc.online",
    "idax.market",
    "idexa.market",
    "idexc.market",
    "idexx.space",
    "idexz.market",
    "kidex.market",
    "mgetherwallat.com",
    "mycrypt0.com",
    "myetharwolet.com",
    "myethermwalet.com",
    "myetherumallet.com",
    "myetherumawllet.com",
    "myetherumqallet.com",
    "myetherumwalket.com",
    "myetherumwallett.com",
    "myetherumwalllet.com",
    "myetherumwallt.com",
    "myetherumwallte.com",
    "myetherumwllet.com",
    "myethorwalllet.com",
    "oidex.market",
    "poloniex.bid",
    "post-binance.com",
    "uidex.market",
    "wwwlidex.market",
    "xn--binne-hwa5e.com",
    "xn--dex-9ta.market",
    "xn--hitbt-lya.com",
    "xn--myehrwallet-bb9e99a.com",
    "xn--myethrwllet-ife3916g.com",
    "account-myetherwallet.club",
    "account-myetherwallet.info",
    "account-myetherwallet.online",
    "acctxcoinbase.com",
    "binance-airdrops.com",
    "binance.com1125459345.cf",
    "binancesto.com",
    "binancewebsite.accountant",
    "bitfinexsto.com",
    "coimbase.online",
    "coinbase247.com",
    "idex-maket.info",
    "idexi-login.com",
    "idexmarketjoin.com",
    "kraken.email",
    "musicequipment.site",
    "myerhetwaller.com",
    "poloniexwallet.com",
    "poloniwallet.com",
    "restore-coinbase.com",
    "shapeshift.cash",
    "verifypaxful.com",
    "teslacoin.space",
    "officialairdrop.tech",
    "teslacoin.tumblr.com",
    "supportbinance.890m.com",
    "890m.com",
    "kralken.co",
    "bilttrex.co",
    "bimanrce.com",
    "exrno.eu",
    "polroneix.com",
    "bloclkchain.co",
    "hitlbtc.co",
    "yobitr.net",
    "yobilt.net",
    "xgivex.blogspot.com",
    "populous.network",
    "bianace.online",
    "blockchain-exchange.online",
    "bitterx.online",
    "blftinex.com",
    "bltmian.com",
    "cryptnoator.com",
    "cryptopla.online",
    "exwo.online",
    "kuckion.com",
    "logintwitter.ga",
    "myethecwallet.com",
    "myetherwallet-fix.space",
    "myetherwallet-rlx.space",
    "polnoiex.site",
    "twittergiris.gq",
    "twitterlockeding.ga",
    "twitterlogins.gq",
    "xn--poloiex-kqc.com",
    "xn--myethrewalle-9me.com",
    "xn--myethrewalet-k4b.com",
    "xn--myetherwalet-j4b.com",
    "xn--kuoin-zra.com",
    "xn--bitman-f9a.com",
    "dexlauncch.com",
    "line-crypto.com",
    "etherdelta.icu",
    "xtrony.blogspot.com",
    "bithumbvietnam.com",
    "bithumbvietnam.info",
    "coinbasebonus.co.uk",
    "coinbasebonus.thehostrunner.co.uk",
    "eth-binance.ru",
    "idex-market.ru",
    "idexmarket.ru",
    "mercatox.info",
    "myetherwallet.red",
    "xn--coinx-q51b.com",
    "biinance.online",
    "binance-login.com",
    "binarrce.com",
    "myelherwolett.info",
    "poloniexadvanced.com",
    "poloniexlogin.trade",
    "binance-token.com",
    "binance.com7812686236.space",
    "binance.page",
    "bitlttrex.com",
    "coinsbaseexchange.com",
    "hitbtlc.com",
    "hjjtbtc.com",
    "kraken.site",
    "krarcken.com",
    "myerhetwallet.com",
    "paxfull.com.yontsk.tk",
    "poloniex.com.zandei.online",
    "polonnix.com",
    "polonnix.site",
    "poloniex.com135i478847258477.ml",
    "com135i478847258477.ml",
    "mnyicthervvalliet.com",
    "dexchainevent.com",
    "myethereumwalket.com",
    "bnbdexchaincompetition.com",
    "bnbdexchaincompetition.info",
    "bnbethairdropp.com",
    "dexchaincampaign.com",
    "mniyehtcwallict.com",
    "okexcampaign.info",
    "okexspecialcampaign.info",
    "bnbchaincompetition.info",
    "bnbetherairdropp.com",
    "dexchaincompetition.info",
    "okexspecialcampaign.com",
    "okexcampaign.com",
    "binacampaign.com",
    "dexchaincampaign.info",
    "ethereum-corporation.org",
    "myvolt.site",
    "coindesk-login.com",
    "wwwcoindesk.com",
    "xn--condesk-gw4c.com",
    "coinbase-codepromo.com",
    "coinbase-customer-support.online",
    "coinbase-helpdesk.info",
    "coinbase-support.net",
    "coinbasecustomersupport.info",
    "coinbaseesupport.club",
    "coinbaseesupportservices.club",
    "coinbaselogin.support",
    "coinbasesupport.co.uk",
    "coinbasesupport.online",
    "coinbasesupportnumber.com",
    "localethereum-account.com",
    "myetherwallet.byethost11.com",
    "googl-access.com",
    "binance.com13867347.ml",
    "com13867347.ml",
    "com1735835.gq",
    "binance.com1735835.gq",
    "com56457.ml",
    "binance.com56457.ml",
    "myetherwallet.notextbook.net",
    "sslsecure-verifyid.tk",
    "coinsender.tech",
    "walmartleaf.com",
    "1dex.market",
    "birhumb.com",
    "bitmex1.info",
    "bittrex-io.com",
    "bittrex-oo.com",
    "coinbase-promo.com",
    "coinbasepropromos.com",
    "com12786312634.space",
    "form-myetherwallet.com",
    "hitbtc8.com",
    "hitsbtc.club",
    "loginmicrosoftexcel-online.com",
    "mercatox.club",
    "myetlrewallet.com",
    "poloniex-tm.com",
    "poloniex-x.com",
    "wallet-blockchian.info",
    "walletmobile.io",
    "walletlivesyncconnect.io",
    "walletconnectslive.io",
    "wvw-bittrex.com",
    "xn--blockchai-owb.com",
    "xn--blockchin-r2a.com",
    "xn--krake-d8a.com",
    "xn--krken-ucc.com",
    "xn--metherwllet-ife3465g.com",
    "xn--yetherwllet-tv8ex8b.com",
    "giftforfans.website",
    "etherium.org.payment.7t27-srv.site",
    "7t27-srv.site",
    "giveawey.tumblr.com",
    "johnmcaffe.tumblr.com",
    "medium.com.7t27-srv.site",
    "winplatform.pro",
    "icon.cash",
    "xn--dex-uma.market",
    "polonniex.online",
    "polonniex.top",
    "niceihash.com",
    "nicenhash.space",
    "b-crypto.me",
    "apexone.online",
    "moyluchshiyremont.top",
    "pizzaobaldinidostavka.site",
    "binanse.ch",
    "bittrex-web.com",
    "bittrex-ydd.com",
    "hitbtc.website",
    "scris.club",
    "electrun.org",
    "xn--mythwallet-n7ac.com",
    "hitloek.info",
    "myetherwallet-xbmc.space",
    "ethiz.blogspot.com",
    "gi-ve.blogspot.com",
    "elonmuskairdrop.tech",
    "binance.com1367347.ml",
    "binance.com71623781.ga",
    "binance.com76237831.gq",
    "inbox-redirect-binance.com1367347.ml",
    "com1367347.ml",
    "com76237831.gq",
    "com71623781.ga",
    "binance.com1897623.ga",
    "binance.com7816623.gq",
    "binanceexchange.us",
    "binancevietnam.net",
    "cors01.binanceview.com",
    "paxful.support",
    "promobittrex.website",
    "wwv-bittrex.com",
    "wwv-bittrex.com.cp-34.webhostbox.net",
    "xn--biinanc-z8a.com",
    "binancelogin.org",
    "idex.auroradapp.market",
    "auroradapp.market",
    "roadgridequipment.pw",
    "binance.com1786236.ml",
    "binance.com197623462.ml",
    "binanceix.com",
    "meyethcrwallet.com",
    "meyfherwallet.com",
    "meyfherwellet.com",
    "meyhferwellet.com",
    "meythrewellet.com",
    "meythrowallet.com",
    "mychtervvallet.com",
    "mychterwellet.com",
    "shapeshiift.xyz",
    "paxful.com-bitcoin-wallet-trade-escrow.paxfulsecure.com",
    "paxfulsecure.com",
    "mnyicthervallict.com",
    "mnyidthewalliot.com",
    "binchaincampaign.com",
    "binachaincompetition.info",
    "binachaincompetition.com",
    "binacompetition.com",
    "binacompetition.info",
    "firstcrypt.info",
    "binance.com6537261.ml",
    "binance.com762381.cf",
    "com762381.cf",
    "com6537261.ml",
    "com13734.space",
    "vitalik-campaign.xyz",
    "getgift.tech",
    "elongift.com",
    "muskmars.tech",
    "binance.com12754825.ml",
    "binance.com128236.ml",
    "vietnamese-binance.com",
    "vietnam-login-binance.com",
    "vietnam-binance.com",
    "loginviet-binance.com",
    "binance-login-vn.online",
    "com12754825.ml",
    "com12786312634",
    "com1865236.ga",
    "com763271231.gq",
    "com128236.ml",
    "com723781231.online",
    "elon-share.info",
    "ethereum-giveaway.ru",
    "login-blnance.space",
    "send-gift.website",
    "etherium.org.payment.7t24-srv.site",
    "7t24-srv.site",
    "airdrops.technology",
    "myetherwallet-cpt.space",
    "tron-network.info",
    "electrumwallet.org",
    "medium.com.7t23-srv.site",
    "7t23-srv.site",
    "etherium.org.payment.7t23-srv.site",
    "firecrypto.info",
    "bitbakocffice.site",
    "santechstroywalker.site",
    "airdrop-event.com",
    "sgivex.blogspot.com",
    "myetherwallet-shl.space",
    "get.fastcryptogift.com",
    "fastcryptogift.com",
    "poloniex.com.account2fa-login.com",
    "account2fa-login.com",
    "bittrex-login.account2fa-login.com",
    "g-ive.blogspot.com",
    "cryptopromo.justsharedthis.info",
    "btcgive.kissr.com",
    "binan-ceh.com",
    "ibcexofmarket.com",
    "ibexofmark.com",
    "icexofmark.com",
    "iclexmarket.com",
    "iclexofmarket",
    "iclexofmarket.com",
    "widgets.ibexofmark.com",
    "wighfghfh.ibexofmark.com",
    "idex.auroradao.market",
    "auroradao.market",
    "bnbdecentralizedcompetition.com",
    "bnbdecentralizedcompetition.info",
    "bnbdecentralizedevent.info",
    "bnbethairdropp.info",
    "bnbethereumairdropp.com",
    "bnbethereumairdroppevent.com",
    "bortnarnce.com",
    "check1.pw",
    "decentralizedspecialevent.info",
    "mniyehtcwalliot.com",
    "mnyicthervallat.com",
    "mnyicthervvallet.com",
    "mnyicthervwvallct.com",
    "getyourcoins.org",
    "binance-giveaway.webcindario.com",
    "gift-today.website",
    "cryptopromo.kissr.com",
    "etherium.org.payment.7t21-srv.site",
    "7t21-srv.site",
    "top-deals.pro",
    "medium.com.7t21-srv.site",
    "decentralizedbitcoincampaign.info",
    "bittrexl.in.us.bix-l.com",
    "bix-l.com",
    "binance.com18363462.ml",
    "binancebtcspecial.com",
    "brivnarnce.com",
    "brovinamce.com",
    "brovnarnce.com",
    "brtvnarnce.com",
    "cpanel.bittrex1.com",
    "decentralizedspecialcampaign.com",
    "decentralizedspecialevent.com",
    "hitbtc.com.co",
    "mietherwallet.com",
    "myeitherwallett.com",
    "myencryptwallet.com",
    "myetherwellet.com",
    "myethewallert.com",
    "shapeshift.biz",
    "bjttrex.com",
    "id-ex.market",
    "iidex-market.eu",
    "myetherwallet.biz",
    "myetherwallet.auth.slgnmsg.info",
    "slgnmsg.info",
    "spectrocoinlog-in.com",
    "giftethnow.website",
    "etherium.org.payment.7t20-srv.site",
    "7t20-srv.site",
    "x-gives.blogspot.com",
    "ethgive.kissr.com",
    "ico-neon.exchange",
    "myetherairdrop.com",
    "myetnerwallet.com.send-status.info",
    "send-status.info",
    "paxful.com.pl",
    "myetherwallet-id.space",
    "eth-databasecontract.website",
    "geteos.eu",
    "binance-campaign.info",
    "binance-campaign.site",
    "binance-exchange.cricket",
    "binance-exchange.fun",
    "binance-https.com",
    "binance.com-log-in.googl-access.com",
    "bittrex-log-in.com",
    "bittrex-login.asset2fa-exchange.com",
    "bittrex.asset2fa-exchange.com",
    "bittrex.com.asset2fa-exchange.com",
    "conidase.com",
    "mjetherwattet.com",
    "us.bittrex.asset2fa-exchange.com",
    "us.bittrex.com.asset2fa-exchange.com",
    "3dayprofits.info",
    "etherium.org.payment.7d19-srv.site",
    "7d19-srv.site",
    "atmbtc.biz",
    "best-gift.website",
    "airdrop.com.de",
    "vitalikpromo.eu",
    "medium.byethost10.com",
    "medium.com.7d19-srv.site",
    "promo2.etherbonus.top",
    "etherbonus.top",
    "xn--hibtc-leb.com",
    "hitbtc-eu.com",
    "hitbtc.cam",
    "get-5k-promo.website",
    "freshbonus.eu",
    "e-gives.blogspot.com",
    "etherium.org.payment.7d18-srv.site",
    "7d18-srv.site",
    "airdrops.life",
    "binance-com-clud.webcindario.com",
    "go7.giftether.top",
    "hitbtc.li",
    "xn--spectroconn-7zb.com",
    "paxfullwallet.com",
    "user.paxfulpolicy.com",
    "paxfulpolicy.com",
    "paxful.com.balums.gq",
    "forkdeilta.app",
    "xn--dex-tta.market",
    "verify.xn--mytherwalet-3qb10c.com",
    "getfreeethhh.blogspot.com",
    "getfreebitcoin.network",
    "coinaction.xyz",
    "cryptoxfan.info",
    "go6.giftether.top",
    "binance-giveawaypromo.banance.xyz",
    "banance.xyz",
    "mega-airdrop.website",
    "joinnow.info",
    "binance-campaign.com",
    "binance-eth.club",
    "binanceeth-campaign.com",
    "binanceeth-competition.com",
    "binanceethergiveaway.com",
    "binanco.live",
    "ethervvallet.com",
    "myctherwallet.net",
    "go5.giftether.top",
    "etherium.org.payment.7d17-srv.site",
    "7d17-srv.site",
    "bigbonus.eu",
    "medium.com.7d17-srv.site",
    "getnowcrypto.com",
    "bittcrex.com",
    "myetherwallet-knt.space",
    "myetherwallet-knc.space",
    "etherdelta.press",
    "xn--paxfl-nva.com",
    "goodaction.eu",
    "coinpromo.xyz",
    "september-bonus.us",
    "getbonus.eu",
    "airdrop-gift.website",
    "muskonline.tech",
    "cryptogivng.blogspot.com",
    "today-eth.pw",
    "binance-bonus.club",
    "binance-bonus.net",
    "binance-promo.org",
    "binance-t.com",
    "binanceethereumairdroppevent.info",
    "binancepromos.live",
    "blockchain-secure.info",
    "bonusbinance.org",
    "i-dex.market",
    "idex-rnarket.info",
    "idex.markel.transactions-wallet.info",
    "myetlherwallelt.com",
    "mymanero.com",
    "gramnetwork.net",
    "topcryptogift.org",
    "payetherer20.000webhostapp.com",
    "vggs.info",
    "go4.giftether.top",
    "etherium.org.payment.7d16-srv.site",
    "payment.7d16-srv.site",
    "givingsaway.blogspot.com",
    "msg.xn--mytherwalet-3qb10c.com",
    "myetherwallet.auth.sgnmsg.com",
    "sgnmsg.com",
    "hitbtcspace.herokuapp.com",
    "2fa-paxful.com",
    "eherpro.tumblr.com",
    "smart-gift.website",
    "coinshare.xyz",
    "buterintoday.eu",
    "tronics.tech",
    "giveaway-medium.top",
    "tesla-giveaway.live",
    "myetherwallet-knb.space",
    "wallets-crypto-bridge.org",
    "coinbaseblogiveawayhg.tumblr.com",
    "binance-ethpromo.org",
    "binance.fail",
    "binancevault.com",
    "get-btc-binance.com",
    "get-eth-binance.com",
    "myetherwallet-sign.fun",
    "teammyetherwallet.com",
    "xn--dex-yma.market",
    "trxgold.io",
    "signature.xn--mytherwalet-3qb10c.com",
    "blockchian-login.info",
    "login-blokchain.com",
    "login-blockchian.net",
    "blockchian-wallets.com",
    "blockchian.ca",
    "blockchian-wallet.com",
    "blockchian-login.com",
    "idex-market.pro",
    "biboyx.com",
    "bnb-ethcampaign.com",
    "cryptobtc.club",
    "perlin.global",
    "tesla-giveaways.space",
    "top-ethereum.info",
    "mnaxy.blogspot.com",
    "go3.giftether.top",
    "etherium.org.payment.promoaction.site",
    "promoaction.site",
    "airdropbtc.tech",
    "secure.topcoinsgift.com",
    "topcoinsgift.com",
    "musk-crypto.info",
    "5k-gift.website",
    "platform-give.com",
    "ethgiveaway.co.uk",
    "bi-nancer.com",
    "binance-eth-competition.com",
    "binance-ether.club",
    "binance-ethereum.com",
    "binance-ethereum.info",
    "binance-ethereum.tech",
    "binance-ethevent.net",
    "binance-ethevent.org",
    "binance-x.club",
    "binancebonus.net",
    "binancebonus.org",
    "binanceeth.club",
    "binanceethcompetition.com",
    "binanceether.club",
    "binanceethereum.club",
    "binancepromo.club",
    "binancespecialcompetition.com",
    "binancespecialethcompetition.com",
    "binanceth.club",
    "binancether.club",
    "binancethereum.club",
    "eth-binance.club",
    "ethbinance.club",
    "ethcompetitionbinance.com",
    "ether-binance.club",
    "etherbinance.club",
    "myetherwallet.com.ip13.icu",
    "myetherwelet.net",
    "myetherwolllet.com",
    "myethswallet.club",
    "suportbinance.com",
    "tokens.myetherwailet.cf",
    "medium-coinbaseblog.tumblr.com",
    "safe.geteasycrypto.com",
    "geteasycrypto.com",
    "lixozy.blogspot.com",
    "eloncrypto.info",
    "mediumcoinbase.tumblr.com",
    "cryptoeth.live",
    "crypto-win.club",
    "crypto-medium.com",
    "getairdrop.eu",
    "sending-smartcontract.website",
    "idex-market.exchange",
    "protect.minedcoins.online",
    "minedcoins.online",
    "go2.giftether.top",
    "contract-verify.space",
    "cryptogift.cn",
    "ethergifts.top",
    "medium-gifts.top",
    "get.officialcryptogiveaway.com",
    "officialcryptogiveaway.com",
    "cvifex.blogspot.com",
    "ethereum-ltd.net",
    "giveaway.ether-prize.com",
    "titan-g.pro",
    "coinbaseblogiveawaynews.tumblr.com",
    "eth-gift.wixsite.com",
    "btc-gift.wixsite.com",
    "rpmson-ethcampaign.com",
    "444eth.ml",
    "give-th.blogspot.com",
    "applex1.com",
    "riklex.blogspot.com",
    "ethpromo.xyz",
    "bitblender.me",
    "safe.paynowcoins.com",
    "paynowcoins.com",
    "go1.giftether.top",
    "enjoy.topcryptogift.com",
    "topcryptogift.com",
    "bigdrop.cn",
    "sekakux.blogspot.com",
    "4ever.fun",
    "thetrey.net",
    "myeclientsidewallet.com",
    "bnbethercompetitionlaunch.com",
    "ethereum-corporation.com",
    "binan-ce.com",
    "binance.security",
    "binoance.com",
    "ethereum-binance.club",
    "etheventbinance.org",
    "idex.center",
    "mmyethereumwallet.com",
    "myethereumwaller.com",
    "myethereumwwallet.com",
    "myethereuumwallet.com",
    "myethereymwallet.com",
    "myetherreumwallet.com",
    "myetherrumwallet.com",
    "myetherumeallet.com",
    "myetherummwallet.com",
    "myetherumwaallet.com",
    "myetherumwaklet.com",
    "myetherumwalelt.com",
    "myetherumwalle.com",
    "myetherumwalleet.com",
    "myetherumwaller.com",
    "myetherumwalley.com",
    "myetherumwallrt.com",
    "myetherumwallwt.com",
    "myetherumwlalet.com",
    "myetherumwsllet.com",
    "myetherumwwallet.com",
    "myetherunwallet.com",
    "myetheruumwallet.com",
    "myetheruwmallet.com",
    "myetherymwallet.com",
    "myetheteumwallet.com",
    "myethetumwallet.com",
    "myetheumwallet.com",
    "myetheurmwallet.com",
    "myethhereumwallet.com",
    "myethherumwallet.com",
    "myethrrumwallet.com",
    "myethrumwallet.com",
    "myetterwalet.com",
    "myetthereumwallet.com",
    "verify-binance.com",
    "earn.dailydivs.com",
    "safe.minedtokens.com",
    "smartsend-5000.website",
    "airdropeth.tech",
    "imyetherbonus.com",
    "minedtokens.com",
    "crypto-promo.org",
    "coinbasesecuritytokens.com",
    "coinbasepay.info",
    "hitbtcrecovery.com",
    "hitbtc-adv.com",
    "gemini-wallet.com",
    "gemini2fa.com",
    "geminiaccount.com",
    "binantlabsinfo.com",
    "binanetlabsinfo.com",
    "mymonerocom.com",
    "binantrustwaiiet.com",
    "binantrustwailet.com",
    "binantrustwaliet.com",
    "binancetrustwaiiet.com",
    "binancetrustwailet.com",
    "binancetrustwaliet.com",
    "binanctlabsinfo.com",
    "binanctrustwaiiet.com",
    "binanctrustwailet.com",
    "binanctrustwaliet.com",
    "binance-accounts.com",
    "binatrustwaiiet.com",
    "binatrustwailet.com",
    "binatrustwaliet.com",
    "bintrustwaiiet.com",
    "bintrustwailet.com",
    "bintrustwaliet.com",
    "ubex.us",
    "bnbdex-ethcampaign.com",
    "binance-ether.online",
    "binance.win",
    "binanceethevent.net",
    "etheventbinance.net",
    "metherumwallet.com",
    "mmyetherumwallet.com",
    "mtetherumwallet.com",
    "muetherumwallet.com",
    "myeethereumwallet.com",
    "myeherumwallet.com",
    "myerherumwallet.com",
    "myeterumwallet.com",
    "myetgerumwallet.com",
    "myetheeeumwallet.com",
    "myetheereumwallet.com",
    "myetheerumwallet.com",
    "myethereeumwallet.com",
    "myethereimwallet.com",
    "myethereumeallet.com",
    "myethereummwallet.com",
    "myethereumqallet.com",
    "myethereumwaallet.com",
    "myetherimwallet.com",
    "myethermuwallet.com",
    "myetheswallets.org",
    "myethwrumwallet.com",
    "myetjerumwallet.com",
    "myetnerwallet-com.review",
    "myetterwelllet.com",
    "myettherumwallet.com",
    "myeyherumwallet.com",
    "myrtherumwallet.com",
    "mytherumwallet.com",
    "mywtherumwallet.com",
    "myyetherumwallet.com",
    "nyethereumwallet.com",
    "nyetherumwallet.com",
    "ymetherumwallet.com",
    "airdrops-exchange.com",
    "buterindrop.eu",
    "campaign.etheraction.in",
    "etheraction.in",
    "ethtake.icu",
    "cryptocurrency-giveaway.com",
    "mcafee.coolpage.biz",
    "september-event.us",
    "september-promo.us",
    "freeethereum500.000webhostapp.com",
    "myetherwallet.com.webwallet-view.info",
    "webwallet-view.info",
    "binance-eth.net",
    "binance-ether.net",
    "binance-n.com",
    "binanceeth.org",
    "eth-binance.net",
    "ethereumwallets.tech",
    "meytherwallet.net",
    "myetheforwallet.com",
    "myetherwallet.com.update.privatekey.wallet-crypto-member.com",
    "myetherwallet.update.system.crypto-wallet-member.com",
    "myethswallet.net",
    "myethswallet.top",
    "myettwallet.bid",
    "myyetherwallet.online",
    "bnbethspecialcampaigns.com",
    "bnbchaineth.com",
    "bnbethchain.com",
    "bnbdexethlaunch.com",
    "bnbethpromotion.com",
    "binanethpromotion.com",
    "bnbpromotion.com",
    "bnbspecialcampaign.com",
    "bnbdexcampaign.com",
    "bnbexchangedex.com",
    "bnbexchangespecialcampaign.com",
    "bnbexchangespecial.com",
    "bnbdexethcampaign.com",
    "bnbexchangeethspecialcampaign.com",
    "bnbexchangespecialethcampaign.com",
    "bnbethexchangespecial.com",
    "bonus.client-stellarterm.com",
    "client-stellarterm.com",
    "mixprize.cn",
    "medium-secure.com",
    "ginexis.blogspot.com",
    "giftsatoshi.space",
    "myethcrwallet.net",
    "myetherewa11ets.com",
    "mvyetherwallet.com",
    "myehterwallets.xyz",
    "xn--meherwallet-yb9eup.com",
    "login-blockchain.top",
    "login-blockchain.gq",
    "eosauthority-accountpolicy.omastral.org",
    "claim.paysafecoins.com",
    "paysafecoins.com",
    "gooddrop.cn",
    "giveaway-eth-btc.euweb.cz",
    "eth4312left.pw",
    "secure.topcoingift.com",
    "topcoingift.com",
    "ethgold.pro",
    "send-smartcontract.space",
    "getyoureth.network",
    "geteth.pro",
    "lopixy.blogspot.com",
    "zilliqagold.co",
    "xn--tesl-tzb.com",
    "litecoinone.org",
    "medium-mcafee.top",
    "binanceth.net",
    "tesla-giveaways.org",
    "september-bonuss.com",
    "ethersclaim.blogspot.com",
    "free.giftether.top",
    "giftether.top",
    "get-bonus.online",
    "getether.eu",
    "easydrop.pro",
    "claim-event-eth.org.uk",
    "vecimax.blogspot.com",
    "ethpromo-binance.org",
    "myetherbonus.net",
    "get.safepaycoin.com",
    "safepaycoin.com",
    "ethereum4ever.com",
    "contagion.cf",
    "september-bonus.com",
    "ethereum-airdrop.tumblr.com",
    "giveaway.at.ua",
    "myeth-claim.com",
    "ethereumvert.com",
    "mediumposting.vip",
    "give-away.co.uk",
    "eth4323left.pw",
    "safe.coinspaynow.com",
    "coinspaynow.com",
    "mixgift.top",
    "blog-medium.com",
    "etherdelta.website",
    "blockhaine.blogspot.com",
    "geteth.cn",
    "medium.com.7a4c7b234069.site",
    "etherium.org.7a4c7b234069.site",
    "7a4c7b234069.site",
    "elctrurn.org",
    "jaxx.one",
    "lkraken.xbtxv.com",
    "bestbuildercompany.pw",
    "i-idexmarket.com",
    "myetherewallet.ga",
    "myetherwallet.com.signmessage.info",
    "myethrewallet.services",
    "toptireshop.pw",
    "indexmarx.com",
    "myetherewallet.online",
    "myetherrwallet.com",
    "myetherrwallet.signmessage.xyz",
    "myetherwallet-hydro.space",
    "myetherwallet.com.verifiy.icu",
    "myetherwallett.mining24.info",
    "myetherwallwet.com",
    "myethherwallet.com",
    "myethrwallet.com",
    "musk-prize.info",
    "medium-io.site",
    "claim.safepaycoins.com",
    "safepaycoins.com",
    "airdrop-exchange.com",
    "secure.eth-claim.online",
    "eth-claim.online",
    "airdrops.investments",
    "medium.in.net",
    "eth5321left.pw",
    "send-transaction.online",
    "medium-smartcontract.space",
    "access-myetherwallet.com",
    "mew-myetherwallet.com",
    "meythereumwallet.com",
    "mineetherwallet.com",
    "myehtereumwallet.com",
    "myetehreumwallet.com",
    "myetheremuwallet.com",
    "myethereumwallte.com",
    "myethereuwmallet.com",
    "myetherwailet.online",
    "myetherwallats.xyz",
    "myetherwallet.com.signmessage.xyz",
    "myetherwallet.wiki",
    "myetherwallwt.com",
    "myethetwallet.com",
    "mytehereumwallet.com",
    "wallet-myetherwallet.com",
    "login-coinone-co-kr.com",
    "pumpkinpro.co",
    "panemicav2.rf.gd",
    "ethbonus.live",
    "ethactive.online",
    "eth-take.com",
    "crypto-giveaway.xyz",
    "ether-prize.com",
    "smart-contract.space",
    "safe.justgetcrypto.com",
    "justgetcrypto.com",
    "september-event.com",
    "home-myether.top",
    "ethcoindesk.blogspot.com",
    "medium-airdrop.net",
    "airdrop.updog.co",
    "send.secureth.host",
    "secureth.host",
    "mixdrop.eu",
    "giveaway-btc.com",
    "binmeds.blogspot.com",
    "jidex.market",
    "mljetherwallet.com",
    "myehtermallert.com",
    "myetheeumwallet.com",
    "myethereumallet.com",
    "myethereumwalet.com",
    "myethereumwalle.com",
    "myethereumwallet.co",
    "myethereumwallt.com",
    "myethereumwllet.com",
    "myetheriwallet.online",
    "myetherrwallet.mining24.info",
    "myetherrwallnet.com",
    "myetherrwallnet.mining24.info",
    "myetherwalets.site",
    "myetherwallats.club",
    "myetherwallats.online",
    "myetherwalle-t.com",
    "myetherwalle-t.ve-ry.club",
    "myetherwallet-gram.website",
    "myetherwallet.com.gpg.services",
    "myetherwallet.signgpgmessage.co",
    "myethrewallet.club",
    "myettherwalet.net",
    "mythereumwallet.com",
    "youretherwallet.io",
    "ethmixdrop.pro",
    "axibovs.blogspot.com",
    "send.ethparty.us",
    "ethparty.us",
    "ethaway.000webhostapp.com",
    "blognance.blogspot.com",
    "september-promo.com",
    "cryptoairdrop.center",
    "air-drop.website",
    "tezbox.net",
    "wetimox.blogspot.com",
    "buterinpromo.cn",
    "eth24win.co.nf",
    "airdrop-portal.com",
    "give-eth.biz",
    "medium-promos.xyz",
    "buterinpromo.live",
    "ethclaim.online",
    "mywindorwallert.site",
    "binancegiveaway.com",
    "myethervvellet.co",
    "myethherwalletr.top",
    "xn--myethrewalle-xoc.com",
    "xn--myethrewaet-z3ba.com",
    "mevetherwalletr.site",
    "mvetnerwalletr.website",
    "mevetherwalletr.com",
    "myvetherwallets.com",
    "pumpkinpro.io",
    "binancethereum.com",
    "mailbinance.com",
    "btc-bonus-live2-binance.com",
    "monero-my.com",
    "eth4123left.pw",
    "xlblogz.blogspot.com",
    "eth-promo.borec.cz",
    "ether-take.org",
    "ethergot.xyz",
    "crypto-giveaway.net",
    "etherprize.net",
    "ethpromzone.space",
    "myetherwallet.com.ip14.icu",
    "ip14.icu",
    "statusico.com",
    "redeem-myetherwallet.pw",
    "omisegogold.io",
    "claim-wallet.com",
    "bhaskar.dx.am",
    "ethertoken.online",
    "mywindorwallert.space",
    "binance-ether.org",
    "neostracker.com",
    "elonmusk.ltd",
    "elonmusk.fund",
    "loginbinance-com.umbler.net",
    "selleth.io",
    "blokclnain.com",
    "giftreturn.mysteria.cz",
    "ethdrop.cn",
    "giveaways24.info",
    "airdrop-live.com",
    "grijub.blogspot.com",
    "etherdrop.space",
    "infoclaimeth.ucoz.org",
    "secure.ethaccess.online",
    "ethaccess.online",
    "tesla.center",
    "go.payeth.online",
    "payeth.online",
    "crypto-exchange.ro",
    "ethbonus.cn",
    "claim-here.com",
    "hizytox.blogspot.com",
    "claim-event-eth.biz",
    "localethereum-support.com",
    "zilliqa.plus",
    "claim-giftwaves.com",
    "pandemica.online",
    "btcdrop.cn",
    "eth-bonus-live-binance.com",
    "ethbinance.org",
    "xn--bockchain-0sb.com",
    "myetherwalllet.xyz",
    "myetherswallet.website",
    "blockchalh.com",
    "blokclhain.com",
    "blokclnaln.com",
    "blockchaijn.com",
    "blockchatn.com",
    "xn--blockchai-3vb.com",
    "xn--blockchai-t6a.com",
    "blockclhain.in",
    "blockchallns.info",
    "claim-nowgift.com",
    "air-drop-ethmark.website",
    "ethboom.eu",
    "dontmiss.info",
    "top-ethereum.net",
    "airdrops.services",
    "ethereum-award.club",
    "cryptocurrency-gift.tumblr.com",
    "secure.getcryptogift.com",
    "getcryptogift.com",
    "ethboom.io",
    "ethbinance.blogspot.com",
    "ether-airdrop-promo.info",
    "medium-ether-airdrop.net",
    "iost.gift",
    "ethactivate.com",
    "medium-promo.xyz",
    "access.eth-access.com",
    "eth-access.com",
    "secure.btcethgoldmine.com",
    "btcethgoldmine.com",
    "claim.ethsx.space",
    "ethsx.space",
    "asktollfree.com",
    "binance-exchange.online",
    "binance-exchange.xyz",
    "myetherwallet-wab.space",
    "myetherwallet.review",
    "myethrewallel.com",
    "binance-lgin.com",
    "ibx-l.com",
    "mvetnerwalletr.online",
    "mvetnerwalletr.site",
    "mvyetherwallett.online",
    "xn--methewallet-v48e1x.com",
    "info-myetherwallet.com",
    "xn--myeherwllet-wte7564g.com",
    "enternow.info",
    "claim-event-eth.com",
    "claim-giveaway.club",
    "binabins.blogspot.com",
    "medium-ethereum-promo.info",
    "ethereum-bonus.info",
    "ethereum-event-promotion.org.uk",
    "jblagz.blogspot.com",
    "event-eth.biz",
    "ethereumbonus.ru",
    "xn--cryptonaor-hcc.com",
    "poloni-ex.com",
    "xn--binanc-gpc.com",
    "accountlogin2fa.com",
    "ethpromo10.000webhostapp.com",
    "digitalasset-app.com",
    "log-in-binance.com",
    "myetherwallat.club",
    "myetherwallet.co.nz",
    "myethforkwallet.com.ru",
    "myethherwalletr.com",
    "ww25.myethereum.info",
    "myethswalet.com",
    "xn--myethrewallt-fwb.com",
    "view-webwallet.info",
    "myetnerwallet.com.view-webwallet.info",
    "lbitmex-in.com",
    "myetalonwindow.info",
    "bitmex-in.co",
    "airdrop-eth.website",
    "ethereumpromo.io",
    "ethreturn.euweb.cz",
    "bonus-claim.xf.cz",
    "eth-claim.info",
    "access.ethsupply.com",
    "ethsupply.com",
    "ethactive.com",
    "ltc-event-now.xyz",
    "biltmex.com",
    "lbtsx.com",
    "xn--bimex-leb.com",
    "bitmex-login.com",
    "binanblog.blogspot.com",
    "etherfast.eu",
    "ethreum.ru",
    "eth-official.fund",
    "bonuseth.top",
    "binance-eth-giveaways.online",
    "returneth.webz.cz",
    "exchange-airdrop.com",
    "ether-reward.info",
    "medium-airdrop.website",
    "eth-miner.info",
    "tron-event.network",
    "ether5000.in",
    "efiriumgiveaway.tk",
    "tedjang68.wixsite.com",
    "ethgivewayofficial.info",
    "giveawaybinance.com",
    "promoeth.000webhostapp.com",
    "imdex.market",
    "official-give-away.tumblr.com",
    "twgram.info",
    "ether-claim.net",
    "airdropvert.info",
    "bigcryptogift.net",
    "eth-give.io",
    "mcafeepromo.xyz",
    "crypto-gifts.ml",
    "amazing-smartcontract.space",
    "elon-shares.info",
    "blogsbina.blogspot.com",
    "medium-com.website",
    "big-giveaway.xf.cz",
    "cryptodrop.eu",
    "binc-blog.blogspot.com",
    "ethfreegiveaway.ga",
    "app-1524336311.000webhostapp.com",
    "etherium-com.site",
    "bonuseth10.000webhostapp.com",
    "medium-ethereum-promo.biz",
    "tokensale.ws",
    "google.com.tokensale.ws",
    "google-coin.io",
    "airdrop-binance.com",
    "auroradao.co.uk",
    "binanceethereum.com",
    "etherwalletlogin.club",
    "etherwalletlogin.online",
    "httpsmyetherwallet.pw",
    "idex.marketing",
    "myelherwallet.co",
    "myetherlwaliet.info",
    "myetherswallet.site",
    "myetherwalletly.com",
    "myetherwallets.live",
    "myethrwallet.com.co",
    "idexmark.online",
    "eth-gifting.com",
    "ethereum-bonus.biz",
    "bigcryptogift.borec.cz",
    "website-events.website",
    "satoshilite-eth.tumblr.com",
    "stellarterm.org",
    "giftseth10.000webhostapp.com",
    "promoeth10.000webhostapp.com",
    "xn--myethrewllet-jbb.com",
    "xls-log.com",
    "hitbtc1.website",
    "promo-giving.ga",
    "mediumlast.ml",
    "ethereumbonus.net",
    "secure-eth.info",
    "ethfs.blogspot.com",
    "bloggercom.info",
    "nblogiz.blogspot.com",
    "secure2.ethrewarding.com",
    "bigcryptogift.org",
    "mudium.xyz",
    "ethereum-gift.site",
    "claimeth.info",
    "go.ethsec.us",
    "ethsec.us",
    "eth-claim.pw",
    "xn--tronscn-mwa.com",
    "tron-scan.info",
    "ethereum-foundation.info",
    "bigcryptogift.info",
    "claim-binance.com",
    "bitcashout.wixsite.com",
    "get.safepaycrypto.com",
    "safepaycrypto.com",
    "aeternity.click",
    "airdrop-event.website",
    "claimeth10.000webhostapp.com",
    "cryptoprize.in",
    "coinbase.tx-pr0.com",
    "tx-pr0.com",
    "exploretransactions.info",
    "binahce.net",
    "blockcnalh.com",
    "blockcnaln.com",
    "bihahce.net",
    "biockchain.co",
    "blt-mex.com",
    "kueoin.com",
    "bittreq.com",
    "bjockchain.com",
    "blockcham.com",
    "blockclnam.com",
    "maytherwallet.com",
    "bjockchajn.com",
    "exmiu.com",
    "kuqoin.com",
    "nyethermallet.com",
    "poionlex.com",
    "blttinex.com",
    "myetnermallet.com",
    "bietmex.com",
    "kucoien.com",
    "kucoein.com",
    "verify.10000eth.pro",
    "10000eth.pro",
    "eth-twitter.com",
    "ethcap.info",
    "gift-promo.wz.cz",
    "vitd1.info",
    "reblogiz.blogspot.com",
    "promo-ether.org",
    "ethereum-promo.net",
    "ethereumpromo.eu",
    "get.bigcryptogift.com",
    "bigcryptogift.com",
    "exchanges.claims",
    "btc-promo.xf.cz",
    "ethpromogiving.com",
    "ethpromogiving.net",
    "ethpromosend.net",
    "ethpromodonate.com",
    "ethpromogive.info",
    "ethpromoget.info",
    "ethpromotake.info",
    "ethpromogivenow.info",
    "theethpromogive.info",
    "ethpromogiving.info",
    "ethpromo-give.org",
    "ethpromogive.org",
    "ethpromoget.org",
    "ethtw.info",
    "ethertake.org",
    "ethereum-giveaway.czweb.org",
    "ethshift.website",
    "gathereth.com",
    "hugedrop.eu",
    "ethpromo-give.info",
    "elonmusk.racing",
    "hitbtc.cc",
    "hitb-tco.com",
    "myethervvallet.pw",
    "myetherwallet.co.za",
    "myetherwallett.fhapp.xyz",
    "web-binance.com",
    "xn--bittrxx-vya.com",
    "memonero.co",
    "walletverify.info",
    "myetherwallet.com.walletverify.info",
    "myetherwwllet.github.io",
    "eth-secure.top",
    "freetokens.online",
    "ether-promo.biz",
    "medium-ether-blog.info",
    "eth-return-now.borec.cz",
    "etheasydrop.eu",
    "new-myethewallet-1a.com",
    "mewewallet.info",
    "electrumwallet.io",
    "binance-com.online",
    "shapeshiflt.com",
    "biffrex.com",
    "bittrexn.com",
    "shapeshifteu.com",
    "ethermywallet.com",
    "home-myetherwallat.com",
    "home-myetherwallat.top",
    "idex.space",
    "ildex.market",
    "mail.myetheforwallet.com",
    "mjeherwallet.com",
    "myeltherwallet.pw",
    "myethereumwallet.net",
    "myetherwallet-sigen.space",
    "myetherwallet.com-omisego.com",
    "myetnelwallet.com",
    "myetnelwallet.online",
    "wallet.idex.space",
    "webmail.myeltherwallet.pw",
    "xn--dex-mma.market",
    "bestchagne.com",
    "biftinex.org",
    "myehterwellet.org",
    "ethclaim.top",
    "bittrex-n.com",
    "eth-airdrop.biz",
    "ethfs.info",
    "ether-give-binance.com",
    "take.realcryptogift.com",
    "realcryptogift.com",
    "ether-airdrop.info",
    "ethereumaction.eu",
    "ether-airdrop.biz",
    "medium-ether-blog.biz",
    "info-live-binance.com",
    "wusd.cf",
    "binamedium.blogspot.com",
    "myethervvellet.net",
    "coinbase-news.tumblr.com",
    "exchangeth.online",
    "home-myetherwallat.info",
    "ethgetbonus.eu",
    "eth-official.claims",
    "ethresults.info",
    "ethereumdrop.eu",
    "go.ethgft.party",
    "ethgft.party",
    "safesclaim.info",
    "ethereum-airdrop.biz",
    "give-away.win",
    "giveaway-coinbase.club",
    "etherscan.space",
    "binmedium.blogspot.com",
    "ethereum-claim.ru",
    "coinbase-gift.tumblr.com",
    "medium-news.blogspot.com",
    "musk-air.org",
    "safe-claims.info",
    "bitstamp.pw",
    "binance-web.com",
    "eth-club.club",
    "ethgiving.000webhostapp.com",
    "mediumapp.org",
    "ethpromosend.com",
    "eth5000.in",
    "coinmyethers.ooo",
    "binance-exchange.updog.co",
    "xn--yetherallet-tv8es7a.com",
    "ethbonus.eu",
    "omiseqo.network",
    "smartcontract-5000.space",
    "medium-blog-airdrop.info",
    "airdrop-eth.net",
    "blog-coinbase.tumblr.com",
    "giveaway-coinbase.top",
    "elon-musk.team",
    "musk-share.info",
    "crypto-promo.czweb.org",
    "coinbas-esignin.com",
    "ee-myetherwallet-un.com",
    "myehterwallete.com",
    "myethervvalllett.com",
    "myetherwallet.api20.icu",
    "myethforkwallet.com",
    "myethirwaliet.info",
    "bittrex-sigin.com",
    "safe.justgeteth.com",
    "promotion-eth.net",
    "eth-airdrop.info",
    "mediurn.press",
    "ethereum10000.press",
    "site-binance.co",
    "bittrexup.com",
    "giveaway-ethereum.top",
    "smartsent.space",
    "giveaway-eth.tumblr.com",
    "medium-eth.net",
    "ether-giveaway.top",
    "airdrop.credit",
    "musk-share.com",
    "muethwaitt.info",
    "giveaway.xf.cz",
    "bittrex-br.com",
    "accounts-blockchain.info",
    "binance.com87654897.ml",
    "com87654897.ml",
    "binance-in.com",
    "nectracker.co",
    "myethervvallet.org",
    "ethereum10000.website",
    "xn--dx-ejao.market",
    "ethchange.online",
    "idex-logiin.com",
    "myetherwelliet.net",
    "mytherwailet.info",
    "myehtervvalliet.com",
    "myetherwellet.org",
    "kraken-tr.com",
    "kraken-logn.com",
    "kraken-sigin.com.ru",
    "api-binance.co",
    "binance.com.eth-bonus.me",
    "eth-bonus.me",
    "elon-musk.company",
    "safe-eth.info",
    "promotion-eth.com",
    "tronics.updog.co",
    "binance.updog.co",
    "airdrop-ether.info",
    "medium-blog-ethereum.org",
    "go.ethpays.us",
    "coinbasespromo.tumblr.com",
    "ethereum-award.top",
    "cryptoyodas.tumblr.com",
    "promo.ethx.site",
    "ethx.site",
    "send.tokenpromo.site",
    "tokenpromo.site",
    "ethereumprize.eu",
    "5000ethereum.in",
    "ethbinance.info",
    "ethofficial.000webhostapp.com",
    "medium-eth.com",
    "promotion-eth.info",
    "coinbaseboggether.tumblr.com",
    "promo.ethgft.us",
    "beethpromogive.com",
    "safe.confirmeth.com",
    "confirmeth.com",
    "promo.tokenpromo.site",
    "arkblock.net",
    "cbase-pro.com",
    "ethereumprize.io",
    "airdropsvert.xyz",
    "etherium.host",
    "claimeth.top",
    "medium.com.ru",
    "etherium.pro",
    "tesla.myetherget.info",
    "myetherget.info",
    "ethsecure.top",
    "coinsdrop.org",
    "blogmediums.blogspot.com",
    "ethereumprize.art",
    "getethereum200.000webhostapp.com",
    "safe.sharingeth.com",
    "sharingeth.com",
    "medium-blog-ethereum.net",
    "ethereum-airdrop.net",
    "eth-bonus-binance.com",
    "czofficial.site",
    "ethico.info",
    "elon-surprise.site",
    "xn--yetherallet-tv8eu6a.com",
    "eth-safe.info",
    "elon-musk.site",
    "ethofficial.site",
    "bestpromo.online",
    "crypto-giveaway.top",
    "airdrop-ether.com",
    "medium-blog-ethereum.info",
    "ethpromogivegroup.net",
    "idexwall.online",
    "muytherwallet.info",
    "myetherywallet.com",
    "myethirwalie.info",
    "myethirwalie.xyz",
    "myethwallet.com",
    "xn--omiseg-ul8b.com",
    "xn--myethrwalle-6qb4278g.com",
    "myehterwelliet.com",
    "mail.myewtherwallet.pw",
    "myetherwallet.com.ip11.icu",
    "ip11.icu",
    "ethcoin.store",
    "kralkem.com",
    "blockchalim.info",
    "neo-tracler.co",
    "app-bittrex.com",
    "myethereumwallet.org",
    "myethervvallet.net",
    "wmyetherwallet.pw",
    "xn--bnanc-r51bze.com",
    "ycbit.net",
    "kuccin.com",
    "lnitbtc.com",
    "www-nycryqto.com",
    "www-nycryptos.com",
    "go.ethers.pw",
    "ethers.pw",
    "airdropbox.site",
    "etherescan.net",
    "transaction.status-eth.top",
    "mediumblog.today",
    "ethereum-giveaway.top",
    "ethereum-airdop.com",
    "medium-blogpost.info",
    "bonus.status-eth.top",
    "status-eth.top",
    "ethereum.smart.contract.myeltherwallet.ml",
    "myeltherwallet.ml",
    "lelectrum.com",
    "get.10keth.com",
    "10keth.com",
    "airdrop-token.website",
    "ethvent.net",
    "ethclaim.live",
    "claim.status-eth.top",
    "gcox086.com",
    "gcoxkorea.com",
    "my-followers.ml",
    "market-idex.com",
    "myetherwallet.com.verification.mvkcaterer.com",
    "binancepromos.typeform.com",
    "bliovnarnce.com",
    "meyhferwallet.com",
    "ethereum-giveaway.tech",
    "bingmonces.com",
    "ethclaim.info",
    "ethgiftonline.com",
    "ether.blogmedium.top",
    "bnb.medium-air.org",
    "medium-air.org",
    "ether-airdrop.website",
    "giveaway.ether-claim.org",
    "ether-claim.org",
    "giftsforyou.online",
    "coinsprize.org",
    "ethereumwin.in",
    "smart-eth-contract.site",
    "safec41944.nichost.ru",
    "ide-x.market",
    "idex-market.com",
    "idex.network",
    "idexchange.info",
    "idexcorp.download",
    "idlex.market",
    "idwx.market",
    "iibex.market",
    "iidex.market",
    "myetherwalet.ga",
    "myetherwallet-info.com",
    "myetherwallet-tokens.com",
    "myetherwolet.gq",
    "omg-myetherwallet.com",
    "stickamgfs.com",
    "safeclaims.space",
    "safeclaims.net",
    "myethgift.net",
    "official.ethx10.com",
    "ethx10.com",
    "ether-airdrop.org",
    "elon-giveaway.org",
    "myehterwaillet.com",
    "tron-gift.blogspot.com",
    "dubai-oilcorp.company",
    "xn--yetherallet-iw8ew5a.com",
    "bjlttrex.com",
    "blocrkchein.com",
    "login.blocrkchein.com",
    "blrockchein.com",
    "login.blrockchein.com",
    "exrno.su",
    "gaterhub.net",
    "signin.gaterhub.net",
    "kuciorn.com",
    "lhitdtc.com",
    "lkralken.com",
    "polonreix.com",
    "yobirt.net",
    "forkdelta.biz",
    "https-myetherwallet.net",
    "etherdeita.top",
    "etherdeita.site",
    "myethervvallet.ru",
    "myethervvallet.top",
    "myethierwalet.com",
    "myethpromogive.com",
    "myethirvvale.info",
    "lbinanrce.com",
    "medeum-airdrop-news.com",
    "ethereum-transfer.net",
    "safeclaim.info",
    "tesla-giveaway.getforge.io",
    "eth.getforge.io",
    "elon-musk.fun",
    "getethfree.com",
    "airdrop-event.site",
    "xn--methewallet-638e95e.com",
    "bigethereum.org",
    "giftofeth.info",
    "crypto-promo.website",
    "ethdrop.in",
    "ethinvesting.info",
    "newsmedium.info",
    "bnb.newsmedium.info",
    "mediumvert.xyz",
    "getethernow.top",
    "vechainx.net",
    "hadica.com",
    "goastra.ga",
    "jax-x.com",
    "mfoundation.cf",
    "myetheatrwallet.com",
    "myethertawallet.com",
    "myetherwallet.com.api12.icu",
    "api12.icu",
    "xn--etereum-yt3c.com",
    "myetheruwlleet.site",
    "myetherwallet.com.signmsg.api11.icu",
    "api11.icu",
    "myetzwallet.com",
    "aronum.com",
    "vechainx.io",
    "etherdrop.top",
    "btcdrop.in",
    "promo-claims.org",
    "myetherwallet.com.api10.icu",
    "api10.icu",
    "ether-gather.com",
    "safeclaims.info",
    "ethverify.info",
    "elon-musk.org",
    "ethereumfast.io",
    "tron-gifts.blogspot.com",
    "ethereumswallet.com",
    "ethereumwallets.com",
    "myelherwallel.info",
    "myetheruwalleet.site",
    "myetheruwlleet.website",
    "myetherwallet.com.api11.icu",
    "myetherwallet.com.api8.icu",
    "myetherwallet.com.api9.icu",
    "myetherwallet.tv",
    "myetherwelleit.com",
    "myetherwelliet.com",
    "ethereum-promotion.org",
    "ethmore.io",
    "official-promotion.org",
    "airdropseth.info",
    "medium-airdrop-promo.com",
    "ethereum-airdrop.org",
    "air-drop.org",
    "ethereum-return.top",
    "ethereum-promotion.website",
    "kraken-ixz.com",
    "kraken-check.com",
    "airdrops.delivery",
    "buzovacoin.io",
    "buz-coin.io",
    "buzcoinio.com",
    "clubeth.live",
    "clubbtc.live",
    "binance-official.com",
    "shapeshift-exchange.io",
    "myethgift.com",
    "view-wallel.info",
    "carliftcatalog.site",
    "hvmoecjpxn.info",
    "idex.im",
    "idex.site",
    "ldex.su",
    "ldexchange.info",
    "myeherwallel.info",
    "myetheruvvalleet.com",
    "myetheruvvalleet.site",
    "myetheruvvalleet.website",
    "myetheruvvalleet.xyz",
    "myethervvalle.info",
    "myethervvalle.top",
    "muethereswallet.com",
    "myeetherwallets.com",
    "myetherwallet.com.verification.cohencues.com",
    "myetherwallet.company",
    "myetherwolet.us",
    "mytherwallet.com",
    "topbit.info",
    "giveaway-promo.net",
    "eth-pro.co.nf",
    "blokckchian.com",
    "coinbaselogin.com.ru",
    "hub.xn--myterwallet-3qb9087g.com",
    "binconarnce.com",
    "binconamce.com",
    "hitbtc.mobi",
    "kraken-portal.com",
    "kraken-validation.com",
    "grabeth.cf",
    "eos-airdrop.info",
    "ether-claim.com",
    "myethervallet.000webhostapp.com",
    "myetheruvvalet.com",
    "mail.mynetherwallet.site",
    "mycryrptto.com",
    "myetherwallet.com.api7.icu",
    "myetherwllaet.com",
    "mynetherwallet.mining24.info",
    "mynetherwallet.site",
    "xn--idex-upa.market",
    "fantom-foundation.de",
    "bincomance.com",
    "kraken-authentication.com",
    "kraken-we.com",
    "kraken-ix.com",
    "kraken-on.com",
    "binance-validation.com",
    "ethersdrop.online",
    "ethdrop.top",
    "elon-musk.promo",
    "cryptocandies.updog.co",
    "elon-gift.club",
    "elon-gift.info",
    "ether-free.tech",
    "myetherwallet-coins.space",
    "tron-presents.blogspot.com",
    "airdropeth.info",
    "myetherwallet-coinss.space",
    "blovrnance.com",
    "bingmancol.com",
    "bnbnews.org",
    "btcdrop.top",
    "johnmcafee.promo",
    "safe.getbesteth.com",
    "getbesteth.com",
    "mediumblogsot.top",
    "biflnex.com",
    "blfinex.com",
    "binance-app.com",
    "binance-club.com",
    "binance-coins.com",
    "binance-daytrading.com",
    "binance-ethh.com",
    "binance-market.com",
    "binancep.com",
    "https-binance.com",
    "m-binance.com",
    "pay-binance.com",
    "site-binance.com",
    "xn--idex-vpa.market",
    "eth-giveaway.space",
    "claimprize.xyz",
    "ethereum-transfer.com",
    "ethfast.top",
    "medium-promo.com",
    "betaclient-wbtcgwap.cf",
    "ethbonus-binance.com",
    "fast.getether.xyz",
    "getether.xyz",
    "btcbonus-binance.com",
    "my-cry-pto.com",
    "myerthewallet.com",
    "myerthewallet.hosstinger.info",
    "myethaewallet.com",
    "myethaewallet1.hosstinger.info",
    "my-crypto.com",
    "kuciorn.hosstinger.info",
    "lhitlbtc.hosstinger.info",
    "shapeshift-exchange.online",
    "shapeshlft.net",
    "fgcoin.io",
    "evotrustllc.com",
    "john-mcafee.com",
    "amazy-eth.com",
    "eth-drop.io",
    "ethermone.info",
    "ethpromos.info",
    "mycyrptto.com",
    "blgem.blogspot.com",
    "airdrop.delivery",
    "giveawayofficial.info",
    "eth-binance.com",
    "ethgoldmin.com",
    "take-eth.website",
    "safe.earnethnow.com",
    "earnethnow.com",
    "myetnerwallet.com.checkbalance.info",
    "checkbalance.info",
    "autodiscover.myetherwailet.cf",
    "binance-home.com",
    "binance.delivery",
    "bitfilinex.com",
    "bitfinex.me.uk",
    "cpanel.myetherwailet.cf",
    "mail.myetherwailet.cf",
    "mail.myetherwallet.icu",
    "myetherwailet.cf",
    "myetherwalet.watchfullmovie.download",
    "myetherwallert.org",
    "myetherwallet-click.date",
    "myetherwallet-click.loan",
    "myetherwallet-online.download",
    "myetherwallet.icu",
    "myetherwallet.mining24.info",
    "webdisk.myetherwailet.cf",
    "webmail.myetherwailet.cf",
    "ethcryptocomp.cx",
    "ethpromoui.com",
    "ethpromonow.com",
    "eth-give-away-promo.com",
    "eth-promo-give-away.com",
    "eth-pronogive.com",
    "eth-promosgivex.com",
    "ethpramengive.com",
    "et-gi.net",
    "getethereumforfree.com",
    "idex-market.biz.pl",
    "medium-hitbtc.tumblr.com",
    "ethereum-return.com",
    "btc-binance.com",
    "descentx.com",
    "eth-away.com",
    "theethpromogive.net",
    "ethpromotake.net",
    "ethpromogivenow.net",
    "ethpromoget.net",
    "ethpromogivecare.com",
    "ethnewpromo.com",
    "aethpromogive.com",
    "receiveethpromo.cx",
    "eth-promosgive.com",
    "eth-promoui.com",
    "elon-musk.me",
    "eth-promo-awayx.com",
    "ethpromo-give.com",
    "eth-pronosgive.com",
    "receiveethfree.cx",
    "ethpoolcompet.cx",
    "coinleft.org",
    "blogmedium.tk",
    "209.159.154.156",
    "idex-market.trade",
    "justinsun.promo",
    "ettereum.info",
    "binanace.sizemedium.top",
    "sizemedium.top",
    "etherwallet.adamluvshis.com",
    "myelherwaltet.info",
    "myetheiwallett.com",
    "myether-vvallet.com",
    "myethereumswallet.com",
    "myetherwalleet.org",
    "myetherwalletv.org",
    "mymoneero.com",
    "mysetherwalled.club",
    "totaly-myetherwallet.com",
    "youretherwallet.net",
    "myetherwallet-hydrosign.space",
    "dailycurrency.promo",
    "claimsafe.org",
    "musk-present.blogspot.com",
    "binance-get.claims",
    "dodoflyer.com",
    "eth-transfer.com",
    "savetoken.org",
    "followers-special.ml",
    "giveaway.ethereum-promo.com",
    "claimprize.org",
    "eosgas.net",
    "myetherwallet.com.api6.icu",
    "api6.icu",
    "api7.icu",
    "api8.icu",
    "api9.icu",
    "api10.uicu",
    "myetherwallet.com.api5.icu",
    "api5.icu",
    "nuetheriumllet.com",
    "myelhervvalet.com",
    "seositesworld.online",
    "get-ethereum.net",
    "eosgas.co",
    "api4.icu",
    "airdrops.promo",
    "binance.claims",
    "verify.mediumpromos.top",
    "mediumpromos.top",
    "safecrypt.net",
    "binance-claims.com",
    "medium-promotions.com",
    "prize-eth.com",
    "ethsafe.promo",
    "ethpresent.io",
    "givecoins.info",
    "musk-official-promo.com",
    "coinsair.org",
    "myetherwallet.com.api.root3.icu",
    "myetherwallet.com.api3.icu",
    "myetherwallet.com.api4.icu",
    "myetherwallet.com.root4.icu",
    "myetherwallet.com.signinverication.karaokekiralama.club",
    "myethrwelllet.net",
    "xn--mycypto-xld.com",
    "xn--mycrpto-8i4c.com",
    "xn--mcrypto-5i4c.com",
    "xn--c1arhhdidc.com",
    "xn--ycrypto-uz3c.com",
    "xn--myetherwale-jb9e.com",
    "promo.etherpay.site",
    "etherpay.site",
    "bnb-token.org",
    "blog.mediumpromo.top",
    "medium-promotion.com",
    "eosgas.io",
    "internationalstudy.online",
    "myetherwallet.com.root5.icu",
    "root5.icu",
    "ideix.market",
    "idex-free.online",
    "idexwallet.com",
    "meytherwalett.com",
    "myefheerwallet.com",
    "myefherwallett.com",
    "myehtcrwallett.com",
    "myelherwalet.info",
    "myetferwallett.com",
    "myetharwallett.com",
    "myetheerwalet.com",
    "myetheirwallett.com",
    "myetherwallet.com.signinverication.signmessage.karaokekiralama.info",
    "myetherwallet.com.verification.karaokesepeti.com",
    "myetherwallet.com.walletverification.kardeslergunu.com",
    "myetherwallet.men",
    "myetherwayllet.com",
    "myethrawallett.com",
    "myethrevvallet.com",
    "bitfanex.com",
    "idex-market.ph",
    "idex-market.com.ru",
    "idex.com.ua",
    "idex-markef.org",
    "idexx-corpcom.com.ph",
    "idex-markef.io",
    "idex-market.ch",
    "idex-market.club",
    "idex-market.biz",
    "idexhub.market",
    "idexmarkt.de",
    "idex-app.store",
    "giveaway-binance.com",
    "myetherwallet-coinin.top",
    "medium-promo.top",
    "ethereumclaim.net",
    "ethescan.info",
    "verify.getbigeth.com",
    "getbigeth.com",
    "binance.bnb-token.sale",
    "bnb-token.sale",
    "okexgiveaway.com",
    "hitbtc.stream",
    "promohitbtc.website",
    "hitbtc.ltd",
    "en-hitbtc.com",
    "hitbtc.icu",
    "hitbtc.ooo",
    "hitbtcsupport.co",
    "hitbtc.at",
    "hitbtcchain.com",
    "hitbtcsupport.site",
    "hitbtc-ads.com",
    "hitbtc-il.com",
    "hitbtc-on.com",
    "hitbt.co",
    "black-wallet.co",
    "dailycurrency.ml",
    "ethgivewaypromo.info",
    "xn--etherem-y24c.com",
    "stellar-w.com",
    "bitfinex.im",
    "idex-markt-roosen-gmbh.com",
    "idex-market.me",
    "iclex-market.com",
    "xn--dex-market-58a.com",
    "idex-markett.com",
    "verify.ethereumnow.top",
    "ethereumnow.top",
    "sociall.ooo",
    "ether-gift.website",
    "authorize-transfer.droppages.com",
    "login-binance.com",
    "authhitbtc.com",
    "hltbtc.cam",
    "hiitdtc.com",
    "getethernow.org",
    "binance-acess.com",
    "officialairdrop.com",
    "eth-event.com",
    "ethclose.info",
    "freecoindrop.com",
    "myeetherwallet.ga",
    "myehtlerwallet.com",
    "myetherrwallet.ga",
    "myetherswalleit.top",
    "myetherwallet-coinsign.top",
    "myetherwallet.party",
    "myetherwallet.win-eth.org",
    "myethrerewallet.com",
    "myethrwallet.top",
    "myletherwalletes.com",
    "myletherwallets.com",
    "coinssafe.org",
    "idex.group",
    "mcafee.promo",
    "eth60.top",
    "getfree-eth.org",
    "vaxx.co",
    "cryptoether.info",
    "coincapitals.org",
    "bonancre.com",
    "login.blockchaim.co",
    "blockchaim.co",
    "transactionlist.info",
    "idexx-corpcom.com",
    "metherwallet.info",
    "meytherwallete.com",
    "myertherwwellet.com",
    "myetferwallete.com",
    "myetferwalllet.com",
    "myetherwallet-coinl.top",
    "myetherwallet-signcoin.top",
    "myettheriwallet.win",
    "myheriwallet.trade",
    "mymoenero.com",
    "blocokchain.top",
    "xn--binanc-n4a.exchange",
    "idex.market.transactlon.info",
    "transactlon.info",
    "go.ether10000.win",
    "eth10000.win",
    "bdinamce.com",
    "buterinfree.org",
    "satoshi-giveaway.org",
    "event-eth-giveaway.com",
    "ethzerdelta.com",
    "forkdelta.su",
    "forkdeltagithub.info",
    "myethrewallett.com",
    "dxchain.eu",
    "www-bitfinex.com",
    "blvonance.com",
    "airdrop-event.info",
    "currency.promo",
    "czgive.site",
    "verify.bonuseth.info",
    "bonuseth.info",
    "get.bigethgift.com",
    "bigethgift.com",
    "ethsafe.info",
    "ethnewpromoaway.com",
    "btcgiveaway.org",
    "btcpromogivegroup.com",
    "metamaskpro.io",
    "idexchange.pro",
    "mye1herwallet.co",
    "myetherswalet.com",
    "myetherwalles.net",
    "myetherwallet-rebl.top",
    "myetlherwalle.com",
    "myetlherwalle.myettherrwallett.com",
    "myletherwalletest.com",
    "myletherwalletest.myettherrwallett.com",
    "myletherwallets.info",
    "myvetherwallet.com",
    "ether-event.com",
    "w-eos.com",
    "idexmarket.me",
    "johnmcafee.ethgivings.net",
    "ethpays99.top",
    "idex.press",
    "tronics.promo",
    "ethgiveawaygift.info",
    "blockchaingiveaway.biz",
    "ether-bonus.net",
    "vitalikgiveaway.com",
    "ethergiftnow.com",
    "ethtwitter.org",
    "elon-bounty.blogspot.com",
    "bounty-eth.com",
    "bounty-btc.com",
    "eth60.getmyeth.top",
    "getmyeth.top",
    "musk-official-giveaway.com",
    "secure.ethgivings.net",
    "myeltherwalleet.com",
    "myerherwellet.com",
    "myertherwwellet.online",
    "myertherwwellet.site",
    "myertherwwellet.space",
    "myethervalet.cf",
    "myethervuallet.cf",
    "myetherwelet.ga",
    "myetherwellet.ml",
    "myethrerwaellet.com",
    "myettherrwallett.com",
    "myewhterallet.com",
    "myewhterallet.info",
    "myewhterallet.net",
    "myewhterallet.pw",
    "mywtherwaliet.com",
    "index-markett-network.com",
    "idexmarkketslogin.com",
    "ideeweb1.com",
    "myetherwalle.net",
    "myetherwallet-send.top",
    "myetherwallet.com.verify.apisign.me",
    "elonmusk.ethgivings.net",
    "ethgivings.net",
    "refundcontract-etherwallet.net",
    "idexr.market",
    "autodiscover.mvetherwallet.ml",
    "etherwallet.ethsign.icu",
    "mvetherwallet.ml",
    "myetherwalled.us",
    "myetherwalles.com",
    "myetherwallet-coins.top",
    "myetherwallet-sigen.top",
    "myetherwallet-singmsg.top",
    "myetherwallet.cn.com",
    "myetherwallet.com.apisign.me",
    "myetherwallet.com.eos-bounty.com",
    "mymonoro.com",
    "webdisk.mvetherwallet.ml",
    "walletico.com",
    "idixmarket.info",
    "coinbaise.com",
    "neotracler.co",
    "brimance.com",
    "brilmance.com",
    "blirmance.com",
    "brinonce.com",
    "cashaaprivate.com",
    "signcontract-etherwallet.net",
    "ether-idex.online",
    "mediumpost.ga",
    "ocntoken.com",
    "rootsign.icu",
    "ether4free.com",
    "givefreecoin.com",
    "giveusether.com",
    "giveusethereum.com",
    "promoethermnew.com",
    "newethpromo.com",
    "eth-giveavvay.com",
    "instant-ethaway.com",
    "ethpromoget.com",
    "theethpromogive.com",
    "ethpromogivenow.com",
    "ethpromo-give-away.com",
    "ethpramengyve.com",
    "ethpromotake.com",
    "ethpromo-give.net",
    "ethpromogivegroup.com",
    "ethpromogive.net",
    "ethpromogiveback.com",
    "mgetherwalllat.com",
    "myaetherwallet.org",
    "myelherwallet.us",
    "myerherwalllet.com",
    "myethedwalliet.info",
    "myetherwaliet.io",
    "myetherwalled.club",
    "myetherwallet-kr.info",
    "myetherwallet-sinng.top",
    "myetherwallet-ssign.top",
    "myetherwallet.com.api.myetherwallet.com.verifymsg.icu",
    "myetherwallet.com.rootsign.icu",
    "myettheriwalleti.men",
    "mytherwalet.com",
    "token-emrify.com",
    "myethwallofficiiall.com",
    "myetherwallet-hydrogen.top",
    "myetherwallet.com.apisign.icu",
    "apisign.icu",
    "hydrogen-platform.com",
    "bitpayng.typeform.com",
    "myetherwalletverification.signmsg.services",
    "signmsg.services",
    "myetherwallet.com.signapi.icu",
    "signapi.icu",
    "idexd.market",
    "ethbounty.info",
    "eosbounty.co",
    "ethpromotion.info",
    "secure.ethgiftnow.com",
    "btcpromotion.info",
    "betaclient-rzcoinwaps.cf",
    "ethmore.live",
    "myehtewallet.com",
    "meyehterwallet.com",
    "indexmarkket-site.com",
    "idexnetone.com",
    "myetherwallet.com.verifymsg.icu",
    "verifymsg.icu",
    "ethcontracts.org",
    "ethdrop.co",
    "twittethpromo.cx",
    "ethaway-instant.com",
    "trx.promo",
    "ethcompet.cx",
    "ethrewards.cx",
    "claimyour-eth.org",
    "ethcomprules.cx",
    "ethereumpromo.win",
    "safe.ethgiftnow.com",
    "ethgiftnow.com",
    "claimyour-btc.org",
    "btcpromo.win",
    "ettheriwallet.trade",
    "getherwallet.com",
    "mail.myethierwallet.com",
    "meyetherwealletr.space",
    "mjetherwellet.com",
    "my-etherwallet.site",
    "myetherwalle.online",
    "myetherwalle.top",
    "myetherwalle.xyz",
    "myetherwallet-coin.top",
    "myetherwallet.com.api.signmsgs.icu",
    "myetherwallet.com.astrofun.co.il",
    "myetherwallet.signmsg.services",
    "myethlrwallet.com",
    "myettheriwallet.com",
    "myettherwallet.win",
    "mytherwallets.com",
    "5000eth-giving.online",
    "hydrogen-raindrop.bitballoon.com",
    "airtoken.typeform.com",
    "myetherwallet.ethersignmsg.services",
    "ethersignmsg.services",
    "idex.xyz",
    "teslagifts.tumblr.com",
    "brinannce.com",
    "bittrexl.com",
    "getethtoday.com",
    "safe.getethtoday.com",
    "elon-fun.blogspot.com",
    "cryptolinknet.com",
    "zilliqa.name",
    "jenniferaustin.typeform.com",
    "omisegoclassic.com",
    "xn--myetherwalet-yk6f.com",
    "myethierwallet.com",
    "miyetherwallet.com",
    "signmsgs.icu",
    "myehtrerwallett.com",
    "1e-myetherwallet-zn.com",
    "anetherwallet.com",
    "asia-binance.com",
    "client-crypto-bridge.com",
    "cpanel.client-crypto-bridge.com",
    "ethereumwallet.gdn",
    "eu-binance.com",
    "lmyetherwalletr.com",
    "localetherwallet.net",
    "mail.client-crypto-bridge.com",
    "mail.myetherwalilet.com",
    "mail.myetherwallets.io",
    "meyetherwealletr.online",
    "meyhterwallett.com",
    "mjetherwalet.com",
    "mjetherwelllet.com",
    "mvetherwallet.com",
    "my-etherwallet.trade",
    "my-monerc.com",
    "myaetherwalet.com",
    "mycryipto.com",
    "myeatherwaliet.com",
    "myecterwallet.com",
    "myectherwallet.com",
    "myehtcrwallet.com",
    "myehtearwallet.com",
    "myehteswallet.com",
    "myeithierwllet.info",
    "myeithierwllet.net",
    "myelfherwallet.com",
    "myelherwallet.site",
    "myendtherwallet.info",
    "myeteherwallet.info",
    "myeteherwallet.net",
    "myeteherwellet.com",
    "myeterewalled.com",
    "myeterwalled.com",
    "myetharwallet.ml",
    "myetharwollet.com",
    "myetharwolllet.com",
    "myethdwallet.info",
    "myethenrwallet.com",
    "myethererwallet.com",
    "myethereumwallet-v.com",
    "myetherewalet.info",
    "myetherewalet.net",
    "myetherewalled.com",
    "myetherewallets.com",
    "myetheriwalet.date",
    "myetheriwallet.club",
    "myetherrwallat.co",
    "myetherrwallet.club",
    "myetherumwallet.com",
    "myethervalet.us",
    "myethervallet.net",
    "myethervellet.us",
    "myethervualet.us",
    "myethervuallet.pw",
    "myetherwalet.pw",
    "myetherwalet.space",
    "myetherwalie.com",
    "myetherwalle.org",
    "myetherwalle.su",
    "myetherwalled.cf",
    "myetherwallet-click.download",
    "myetherwallet-free.download",
    "myetherwallet-hydro.top",
    "myetherwallet-mgs.top",
    "myetherwallet-msg.com",
    "myetherwallet-msg.top",
    "myetherwallet-msgsign.top",
    "myetherwallet-open.top",
    "myetherwallet-opensign.top",
    "myetherwallet-oppen.top",
    "myetherwallet-signi.top",
    "myetherwallet-signmsq.top",
    "myetherwallet-signn.top",
    "myetherwallet-signopen.top",
    "myetherwallet-sing.top",
    "myetherwallet-singg.top",
    "myetherwallet-ver.top",
    "myetherwallet-veriffication.top",
    "myetherwallet-verification.top",
    "myetherwallet-verify.top",
    "myetherwallet-verrification.top",
    "myetherwallet.com.signinverication.claimtokens.nesekaraarslan.com",
    "myetherwallet.com.signinverication.signmessage.mesutkaraarslan.com",
    "myetherwallet.com.signmsgs.icu",
    "myetherwallet.re",
    "myetherwallet.schneimi.de",
    "myetherwallet.systems",
    "myetherwalletk.org",
    "myetherwallets.io",
    "myetherwallets.site",
    "myetherwallett.club",
    "myetherwalllets.com",
    "myetherwaullet.com",
    "myetherwelet.pw",
    "myetherwellet.club",
    "myetherwellet.net",
    "myetherwellet.press",
    "myetherwelllet.net",
    "myetherwollet.ga",
    "myetherwollet.us",
    "myetherwolllot.com",
    "myetheswallet.com",
    "myethherwwllet.space",
    "myethrewallet.de.com",
    "myethrwaliet.info",
    "myethrwalt.com",
    "myethrwelet.com",
    "myethrwelet.net",
    "myethrwellet.com",
    "myethrwellet.net",
    "myethrwelllet.com",
    "myethswallet.org",
    "myetiherwallet.com",
    "myetnerwailet.info",
    "myetrherwallett.com",
    "myetshewallet.info",
    "myettearwallet.com",
    "myetterwalllet.com",
    "myetterwellet.com",
    "myettheriwallett.bid",
    "myettheriwalletti.men",
    "myettherwallet.trade",
    "myletherwallet.com",
    "mymonaro.com",
    "mymonerc.com",
    "mymonero.eu",
    "mymonero.in",
    "mymorero.com",
    "mymornero.com",
    "mymornero.net",
    "mypcrypto.com",
    "myterwallet.info",
    "wallet.crypto-bridge.top",
    "webdisk.client-crypto-bridge.com",
    "webmail.client-crypto-bridge.com",
    "wwwidex.market",
    "myetherwalilet.com",
    "ethereumpromote.wixsite.com",
    "ethgive.club",
    "etherclaims22.top",
    "officialmcafee.github.io",
    "eth10000.org",
    "safe.eth10000.org",
    "gift-eth.org",
    "ethonline.io",
    "meyetherwealletr.site",
    "myetherwa1et.com",
    "myetherwallet-virificationsign.top",
    "forkdeltas.net",
    "idexairdrop.com",
    "secure.ethsoffer.com",
    "ethsoffer.com",
    "ethpromo-giveaway.atspace.cc",
    "meyetherwealletr.com",
    "myerhterwallett.com",
    "ethcryptopromos.com",
    "ether-foundation.website",
    "ethofficial.net",
    "medium.ethereumfoundation.top",
    "ethereumfoundation.top",
    "bittrcex.com",
    "binance.promoting.world",
    "promoting.world",
    "ether-promotion.info",
    "eventeth.com",
    "btcpromofree.com",
    "ethbonus.me",
    "idex.ga",
    "binanyce.com",
    "login-binance.net",
    "admin.safe-eth.top",
    "myetherwallet.com.signmessage.icu",
    "signmessage.icu",
    "riseeth.com",
    "pokerbox.io",
    "pokerboxairdrop1.typeform.com",
    "myetherwallet.com.apis.icu",
    "apis.icu",
    "official-promo.org",
    "mmyetlherwallett.com",
    "mychterwallet.com",
    "ethmore.net",
    "electrunn.org",
    "myehterwallct.com",
    "get.lotsofeth.com",
    "lotsofeth.com",
    "ethcountdown.ga",
    "ethpromofree.com",
    "sparkster.com.de",
    "buterineth.org",
    "ethereum-promo.website",
    "myertnerwalletr.com",
    "myetherweallett.com",
    "idex.su",
    "imetamask.io",
    "myetherwallet-msgg.top",
    "tokenaway.com",
    "trontoken.tk",
    "bitcryptonex.com",
    "satoshilitegift.tumblr.com",
    "yoniex.com",
    "get.ethinwallet.com",
    "lizstarkgift.tumblr.com",
    "secure.ethoffers.net",
    "ethoffers.net",
    "etherdeltha.info",
    "forcdelta.com",
    "ethereumfoundationgift.tumblr.com",
    "btcpramengyve.com",
    "claim-btc.org",
    "btcbig.org",
    "btcbonus.win",
    "btcpromogiveback.com",
    "btcpromoget.com",
    "bit-airdrop.com",
    "giveaway.claimeth.net",
    "claimeth.net",
    "encoreofficial.com",
    "ethcompetitionrules.cx",
    "offer.supporteth.com",
    "supporteth.com",
    "safe.ethdeliver.com",
    "ethdeliver.com",
    "claimeth.org",
    "instantethpromotion.cx",
    "ethpromotionnow.cx",
    "ethvert.com",
    "event-eth-ada.uk",
    "myeleherwaret.com",
    "meytherwellat.com",
    "btc-giveaway.info",
    "node82.btc-giveaway.info",
    "texacon-verify-547fcd.bitballoon.com",
    "kinetictokenforms.typeform.com",
    "etherclaim.org",
    "xatrainvest.com",
    "xn--myethrwalt-f7a07c4r.com",
    "trx.claims",
    "coinscrypto.info",
    "giveaway.eth-safe.net",
    "eth-safe.net",
    "bonus-ethereum.com",
    "myetherwalletverification.signmsg.work",
    "signmsg.work",
    "xn--con-vta.site",
    "xn--ethrdelta-iib.com",
    "ethergiveaway.site",
    "eosclassic.network",
    "eosauthority-kyc.com",
    "eoscountdown.network",
    "petraforbinance.com",
    "idex.market.xn--con-vta.site",
    "ethbig.net",
    "vechain-platform.org",
    "vechain-block.com",
    "eosauthority.com.globatalent.network",
    "globatalent.network",
    "eth-gift.club",
    "buterin-giveaway.org",
    "freegiveaway-eth.com",
    "support.eth3rdyear.io",
    "eth3rdyear.io",
    "daily-free-eth.net",
    "eth-news.co",
    "ethpromogive.com",
    "eth-give.net",
    "xrp-address.org",
    "hitbtc-login.com",
    "promobinance.com",
    "bittrex-ix.com",
    "bittrex-app.com",
    "bittrecx.com",
    "pumphash.com",
    "tronplay.network",
    "xn--mytherwalet-srb35c.com",
    "eosauthority.bitballoon.com",
    "better-hash.com",
    "promo.ethtake.com",
    "myetherwallet-sign.top",
    "hederahashgraph.publictoken.icu",
    "publictoken.icu",
    "safepayeth.org",
    "eth2018.ethtoeth.com",
    "bitfainex.com",
    "ethinwallet.com",
    "secure.ethinwallet.com",
    "ethereumpro.net",
    "giveawaycrypto.info",
    "dapp.doubledouble.io",
    "doubledouble.io",
    "bitcoinvest.cc",
    "celebration-eth.com",
    "ethers444.online",
    "eth5000.io",
    "ethtoeth.com",
    "cryptoseth.top",
    "ethsfor.top",
    "walleteth.top",
    "ethair.top",
    "wineth.top",
    "ethgive.credit",
    "wineths.top",
    "eosauthority.website",
    "yobit.tilda.ws",
    "eth2018.net",
    "ethtwitter.com",
    "ethereumstash.org",
    "idext.market",
    "etherdelta.com.ua",
    "etzerdelta.com",
    "forkdelta.co",
    "myeftervvellet.com",
    "teslaforfree.wordpress.com",
    "go.ethtake.com",
    "ethtake.com",
    "eossauthorithy.com",
    "electrum.ink",
    "electrumwallet.ml",
    "myethenrwallet.site",
    "myetherium.ru",
    "myetherwalleft.ru",
    "myethrewallets.com",
    "myethrwalet.com",
    "myethswallets.info",
    "myetherwallet-singmgs.top",
    "safe.ethincrease.com",
    "ethincrease.com",
    "myetherwall-et.com",
    "myethre-wallet.com",
    "myether-wallet.com",
    "m-yetherwallet.com",
    "myehferwallet.com",
    "myetherwallet-signmgs.top",
    "eosauthorithy.info",
    "ankr-network.tech",
    "ankr-network.com.de",
    "validbtc.com",
    "ethcelebration.io",
    "crsafepay.com",
    "ethgoldmine.com",
    "verify.ethgoldmine.com",
    "ethcompetition.cx",
    "officialgiveaway.info",
    "ethercontest.site",
    "btcdrop.org",
    "eosauthorithy.com",
    "ethereumanniversary.org",
    "xn--eosauthorty-jzb.com",
    "xn--eosuthority-m7a.com",
    "xn--eosauthorty-kcb.com",
    "tronbonus.network",
    "ethaway.com",
    "eth-gift.net",
    "eosdark.com",
    "xn--mytherwaet-y7a46ha.com",
    "freepromoeth.com",
    "wallet.eostoolkits.io",
    "eostoolkits.io",
    "chanfelly.com",
    "idiex.market",
    "ethtransfer.online",
    "telegram.market",
    "ethgift.net",
    "ethfortune.com",
    "ethereumdrop.info",
    "ethpays.info",
    "eth-give-away.com",
    "safe.ethpaynet.com",
    "ethpaynet.com",
    "getyoureths.com",
    "eth.fanclub.rocks",
    "fanclub.rocks",
    "get-bitcoins-now.com",
    "ethsc32821.nichost.ru",
    "gelepo.com",
    "musk-shares.com",
    "elon-gift.com",
    "elon-gifts.com",
    "elon-giveaways.com",
    "valideth.com",
    "eth-verified.com",
    "grab-eth.com",
    "mediumdotcom.top",
    "eos-authority.com",
    "myethrawallet.com",
    "freeethpromo.com",
    "ethereum-event.com",
    "ethereum-giveaway.safe-eth.top",
    "safe-eth.top",
    "myautocentmarks.com",
    "io-tron.com",
    "ethereum-platform.org",
    "w-tron.org",
    "bonus.eth-promo.org",
    "eth-promo.org",
    "binance-eth.github.io",
    "5000eth.io",
    "twitterpromo.info",
    "promo-binance.site",
    "wallet-top-up.org",
    "binance-btc.github.io",
    "ethextra.net",
    "ethofficialpage.us",
    "ethers-free.org",
    "claimethers.org",
    "myetherwalett.000webhostapp.com",
    "giveaway.ethsafe.net",
    "ethereum-promo.info",
    "myetherwallet.com.signmsg.icu",
    "signmsg.icu",
    "anatomia.io",
    "anatomiaairdrop.typeform.com",
    "give-ethprize.com",
    "odyssey.center",
    "world-market.online",
    "ethereum.odyssey.center",
    "xn--eosauthorty-wcb.com",
    "etherfree.info",
    "free-ethers.org",
    "myeostrust.com",
    "eosdrop.xn--mythrwallt-c7a86c5a.com",
    "eth-claim.net",
    "ethfreegift.org",
    "myenterworlld.com",
    "localetherwallet.info",
    "ethsupport.net",
    "newsair.info",
    "officialgiveaway.org",
    "collectionseth.com",
    "airdropeos.com",
    "neo-x.info",
    "myetherplace.com",
    "ether-give.live",
    "btc-give.org",
    "ethgpromo.com",
    "eosauthority.info",
    "eosauthority.unstake.xyz",
    "unstake.xyz",
    "xn--mythrwalet-c7a29cyq.com",
    "ethgivers.com",
    "secure.ethgivers.com",
    "ethergift.io",
    "suretytoken.com",
    "getethers.org",
    "indexmaker-network.com",
    "idexmarket-corp.com",
    "idexontime.com",
    "idexmarketcorp.com",
    "idex-marketssite.com",
    "idexmarket-llc.com",
    "eth-air-com.1gb.ru",
    "idexxsoftload.com",
    "idexmarket-corps.com",
    "eos-platform.net",
    "btcfast.io",
    "giveawaypromo.org",
    "event-eth.org",
    "ethaction.io",
    "24h.szakdoga.net",
    "luno-help-desk-update.weebly.com",
    "airdropform900.typeform.com",
    "myetherwallet.com.api.root.signmsg.me",
    "myetherwallet.token.signmsg.network",
    "signmsg.me",
    "signmsg.network",
    "idexmarketllc.com",
    "idexwebaa.com",
    "ethfast.io",
    "givewaypromo.org",
    "ethereum-givaway.social",
    "personaleth.com",
    "indexmarket-inc.com",
    "mnyctervailliet.com",
    "mnyidthewallot.com",
    "c-kamowski.fr",
    "eosprivate.io",
    "signmessage.me",
    "myetherwallet.com.api.signmessage.me",
    "shapeshiftv.com",
    "get-ether-now.com",
    "waves-platform.net",
    "myefherwaliet.com",
    "ethsafe.net",
    "xn--coinbas-z8a.tk",
    "ethshare.org",
    "ethergive.info",
    "myetherwalet.heliohost.org",
    "keyfundairdrop.typeform.com",
    "eosdash.io",
    "ethereum-claim.org",
    "safesteth.com",
    "ethscan.us",
    "get.perfecteth.com",
    "perfecteth.com",
    "newsair.org",
    "top-ethereum.com",
    "s-msg-myetherwallet.com",
    "elon-shares.com",
    "xn--myeterwallet-o0b.com",
    "myetherwallett.net",
    "magntech.tk",
    "ico.metronome.bz",
    "metronome.bz",
    "metronome.foundation",
    "ethereum-prize.com",
    "etherbonus.live",
    "fantom-foundation.tech",
    "sparkster.site",
    "idex-exchange.market",
    "idex-narket.com",
    "idexmarket-inc.com",
    "idexmarket-incs.com",
    "indexmarkett-corp.com",
    "giveth.ws",
    "giveeth.org",
    "ethereum.org.give-eth.today",
    "give-eth.today",
    "collect-ethaway.com",
    "aireth.today",
    "index-marker.com",
    "iddexmarket.com",
    "iddexmark.et.com",
    "iddexma.rket.com",
    "ideexmarket.com",
    "idexmarket.com",
    "myetherwalllet.online",
    "odyssey.plus",
    "ethereumgw.org",
    "epromo.cc",
    "index-marketz.com",
    "68.168.123.85",
    "eth-promos.org",
    "ethxinfo.com",
    "ethereumpromo.org",
    "eth-giveaway.surge.sh",
    "10000ethereum.com",
    "ethcrypto.info",
    "huobitalk.ga",
    "verified.myethergift.com",
    "myethergift.com",
    "ethairdrop.org",
    "claim.ethairdrop.org",
    "bitcoin-promo.club",
    "today-ethereum.com",
    "ethnow.org",
    "eoscountdown.co",
    "xn--mythrwalet-smb0a05c.com",
    "go.boosteth.com",
    "boosteth.com",
    "claims.payeth.promo",
    "payeth.promo",
    "get-eth-now.com",
    "ethpromo.win",
    "ethereumgift.org",
    "get-btc-now.com",
    "ethpays.org",
    "safe.ethpaynow.com",
    "ethpaynow.com",
    "elon-gives.com",
    "index-markels.com",
    "etherbonus.win",
    "getethpro.com",
    "event-ethereum.org.uk",
    "xn--myethrwllt-y4a7gf.com",
    "giveawaypromo.byethost14.com",
    "ploloneix.com",
    "porloneix1.domen-hosting.org",
    "porloneix.com",
    "polroniex.com",
    "porloniex.com",
    "porloniex1.domen-hosting.org",
    "getbigdeals.org",
    "ethpromotions.org",
    "wincheck.org",
    "ethfor.info",
    "hederahashgraph.tokenico.me",
    "tokenico.me",
    "secure.ethxchanges.com",
    "ethgift.io",
    "verify.officialeth.com",
    "officialeth.com",
    "welcome.promotionaleth.com",
    "promotionaleth.com",
    "binance-giveaway.com",
    "walleteos.io",
    "myefhervvallet.com",
    "sparkster.be",
    "etherguide.info",
    "app-myethervvaiiet.com",
    "myethehearwallet.com",
    "myethervellet.gq",
    "myetherwallek.org",
    "myetherwallet.gifts",
    "myethewalle.com",
    "myethrewallet.net",
    "myethwallet.top",
    "xn--myethrrwallet-m0b.net",
    "gonetvvork.com",
    "airtake.info",
    "ethergive.net",
    "idix-market.info",
    "icon-block.org",
    "masterthecrypto.org",
    "xn--myetherwllet-ncb.org",
    "ethpromoaction.com",
    "ethinfo.org",
    "airgws.org",
    "eth.blogmedium.top",
    "blogmedium.top",
    "eosregistry.site",
    "giveethers.info",
    "creteprint-driveways.co.uk",
    "ethype.org",
    "etherpromotion.org",
    "idexs.market",
    "itex.market",
    "ideh.market",
    "xn--idx-kma.market",
    "xn--idx-cma.market",
    "iclex.market",
    "xn--idx-4qa.market",
    "xn--dex-qma.market",
    "xn--idx-gma.market",
    "iddex.market",
    "eteclum.org",
    "myighther.net",
    "ethpubs.com",
    "binancegiveaway.org",
    "ethgws.org",
    "ethereumreturns.com",
    "takeeth.org",
    "idex-market.at",
    "wallet-idex.net",
    "bittrex-id.com",
    "putty-portal.com",
    "arweave.pw",
    "xn--myethrwalt-inbe64c.com",
    "kentra.tech",
    "xn--myetherwalle-mm5f.com",
    "xn--myeherwallet-4j5f.net",
    "xn--myethrwllet-q7a5h.com",
    "xn--dexmarket-98d.com",
    "xn--mythrwalet-smb0a15c.com",
    "signmsg.info",
    "myetherwallet.com.signmsg.info",
    "oracon.io",
    "eth-bonus.org",
    "piscorealestate.com",
    "myethrwatt.info",
    "defraggler-code.com",
    "ethbonus.io",
    "ethxpromo.com",
    "omise-go.info",
    "xn--myetherrwalet-5hc.net",
    "idice.epizy.com",
    "gene.network",
    "bahs.edu.tt",
    "etheroll.io",
    "meta-mask.com",
    "metamaskwallet.com",
    "myethertrust.com",
    "academiconswap.typeform.com",
    "zillowblockchain.org",
    "myetherwallet.signmsg.online",
    "signmsg.online",
    "falconswap.typeform.com",
    "idex-market.co",
    "sparkster.pro",
    "viberate.bettermost.net",
    "bettermost.net",
    "quarkchain.typeform.com",
    "myetherwalletprize.top",
    "rebellious-airdrop.top",
    "mvyetherwallet.top",
    "kycverification.typeform.com",
    "xn--myetherwalett-5hc.net",
    "xn--mytherallet-3qb2119g.com",
    "xn--myethewllet-738en7a.com",
    "myetferwellet.com",
    "myetherethwallet.com",
    "myethervualet.gq",
    "myetherwallea.org",
    "myetherwallee.org",
    "myetherwalletl.org",
    "myetherwalleu.org",
    "xn--myethrwalett-8vb19c.net",
    "free-ethereum.us",
    "tron-mainnet.network",
    "receive-crypto.com",
    "receive-eth.com",
    "receive-ether.com",
    "ton.vu",
    "etherfree.org",
    "ethgain.org",
    "gifteth.org",
    "myeatherwalletr2.domen-hosting.org",
    "domen-hosting.org",
    "myethearwellet.com",
    "myeatherwalletr.com",
    "myeatherwallert.com",
    "myethearrwallet5.domen-hosting.org",
    "myetherwallet1.domen-hosting.org",
    "myethearrwallet.com",
    "xn--myetherwllt-f7a13e.com",
    "ethspace.promo",
    "ethexchans.com",
    "safe.ethxchanges.com",
    "ethxchanges.com",
    "xn--mythrwalet-c7ac47i.com",
    "xn--mythrwallt-c7a86c5a.com",
    "cryptoaway.org",
    "ethdeals.org",
    "ethgiveaway.io",
    "claimeth.me",
    "ethereumgiveaway.typeform.com",
    "xn--myetherwalett-4hc.net",
    "zecblock.info",
    "litecoin-chain.info",
    "ripple-chain.org",
    "online-stellar.info",
    "coin-monero.org",
    "myethrwatt.com",
    "ether-share.com",
    "btcs-share.com",
    "etherepromo.win",
    "ethtowallet.com",
    "ethsclaim.com",
    "ethaward.com",
    "airdrop24.com",
    "eth.mediumblog.top",
    "mediumblog.top",
    "dropeth.org",
    "get.ethpublic.com",
    "ethpublic.com",
    "ethereum-get.org",
    "ethereum.website.tk",
    "ethereum-bonus.com",
    "blttrex.us",
    "myetherwallat.co",
    "xn--mythrwalet-umbv35c.com",
    "helbiz-token.trade",
    "eostoken-eos-io.typeform.com",
    "switcheo-login.com",
    "switchee.exchange",
    "falconetwork.de",
    "xn--myetherwaett-lcca.net",
    "secure.ethtogive.com",
    "ethtogive.com",
    "fantom.pub",
    "kucroin.com",
    "fantoms.foundation",
    "etherskan.io",
    "etherscan.ltd",
    "myiteher.com",
    "musk-giveaway.com",
    "get-ether.cash",
    "free-ethers.com",
    "ethershares.blogspot.nl",
    "ripple-gives-eth.com",
    "telegram.vu",
    "mydeliverycv.com",
    "ethereumbonus.org",
    "ether-giveaway.online",
    "idex-market.io",
    "xn--mytherwalt-smb5a54c.com",
    "xn--myethrwalet-vrb15c.com",
    "xn--metherwallt-5hb16a.com",
    "get-ethers.net",
    "ethfreebie.icu",
    "gather-gift.com",
    "swdwd.etherget22.zone",
    "etherget22.zone",
    "giveaway.neocities.org",
    "etherdrop.org",
    "safepay-eth.org",
    "electrocoin.typeform.com",
    "myetherwalllet.trade",
    "btcoin.vu",
    "btc-giveaway.com",
    "btcofficial.info",
    "collect.bestethgift.com",
    "bestethgift.com",
    "idek.io",
    "idex24.io",
    "eth-get.com",
    "giveaway-ether.info",
    "ether-give.club",
    "eth.promo-etherum.com",
    "promo-etherum.com",
    "winplatform.io",
    "index-macro.com",
    "185.156.173.87",
    "eos-paperwallet.com",
    "promotoeth.org",
    "ethpromo.cc",
    "idex-market.eu",
    "idex-login.net",
    "eos-swap.com",
    "keyfund.io",
    "ethereum-promo.xf.cz",
    "myetherwallet.comsigninverication.signmessage.crocweb.online",
    "crocweb.online",
    "myeosdac.top",
    "ethofficial.info",
    "getsomeeth.com",
    "giveawaycrypto.org",
    "idexmarket.io",
    "myetehrewallet.com",
    "lbex.market",
    "idex-info.net",
    "get-eth.win",
    "eth-claim.org",
    "eth-givebacknow.tumblr.com",
    "ethfreebie.com",
    "ethpayethers.com",
    "kinetictokenform.typeform.com",
    "kinetictoken.net",
    "xn--myetherwllt-r7a44e.com",
    "saferpayether.com",
    "ethgive.global",
    "ethpromo.info",
    "ethereum-promo.org",
    "crypto-claims.org",
    "getethnow.com",
    "tron.gg",
    "tronfoundation.cc",
    "tronfoundation.gift",
    "ethn.gift",
    "geth.fyi",
    "ethc.live",
    "eths.fyi",
    "shr.st",
    "gate1.eths.vu",
    "ethc.cash",
    "ethn.li",
    "ethc.cc",
    "ethn.pw",
    "get-eth.top",
    "ethgw.info",
    "ethbigpromo-com.1gb.ru",
    "claimcrypto.org",
    "ethpromo.io",
    "verifcaon.site",
    "myetherwallet.com.signinverication.verifcaon.site",
    "verifywallet.typeform.com",
    "xn--myethewallet-4nf.net",
    "xn--myetherwllt-f7a75e.com",
    "ethgive.me",
    "ethgives.me",
    "promaestros.co.uk",
    "ethaddress.neocities.org",
    "changellyico.bitballoon.com",
    "etherfaucet.tech",
    "transaction-authorization.droppages.com",
    "bitcoinbravado.io",
    "coin-secure-transaction.com",
    "ethereum-pay.com",
    "ethereumgiveaway.win",
    "calchain.net",
    "ethpays.me",
    "idex-info.com",
    "idex-market.org",
    "myetherewallete.com",
    "xn--myetherwlet-37a36j.com",
    "xn--myetherwllt-37a50e.com",
    "rnyetheswallet.com",
    "meymonerro.com",
    "myenterwellet.com",
    "myetnerwellet.top",
    "waillbtc.com",
    "myeltherwalletr.com",
    "myerhterwellet.com",
    "meyetherwalllet.com",
    "meytherwallent.com",
    "meytherwallret.com",
    "etherbonus.net",
    "ethtopromo.org",
    "register-eos.io",
    "ethereum-get.info",
    "xn--myethrwaet-inb90ca.com",
    "myetherwallet.com.token.signinverication.signmessage.carpediem.legal",
    "carpediem.legal",
    "myetherwailet.pw",
    "xn--myethrallet-ol9e8v.com",
    "keytron.io",
    "xn--mytherwalt-smbh17c.com",
    "bitcointalk.to",
    "bitcointolk.org",
    "sebiltv.com.tr",
    "ethbonus.net",
    "etherspromo.org",
    "ethergiving.org",
    "ethn.cc",
    "xn--myethrwalt-zmbt05c.com",
    "eth.share-coin.net",
    "share-coin.net",
    "safe.ethgiver.com",
    "ethgiver.com",
    "ethereumup.top",
    "idexmarkets-official.com",
    "idex-marketsin.com",
    "xn--myetherwlet-r7a67j.com",
    "sparkster.tech",
    "flashblocks.io",
    "ethnow.me",
    "quarkchain.supply",
    "fastethget.com",
    "securepeth.club",
    "tron-online.info",
    "anatomia.co",
    "xn--myethrwalt-vmbe17c.com",
    "myetherwallet.com.verification.atlaserbil.com",
    "myetherwalleti.org",
    "myetherwallatt.com",
    "idex-marketslogin.com",
    "iedx.market",
    "myetherwallet.com.signinverication.signmessage.karaokesepeti.com",
    "more-eth.com",
    "myetherwallet.com.signinverication.signmessage.wbaa.co",
    "tubig.co",
    "myetherwallet.com.signinverication.signmessage.carpediem.legal",
    "sentinel-protocol.com",
    "xn--myetherwalt-kbb96i.com",
    "dfinitydrop.ml",
    "coinbaseverifier.com",
    "ether-giveaway.net",
    "ethget.me",
    "ethbonus.org",
    "eth-give.me",
    "ethgetnow.com",
    "ethnowpromo.org",
    "ethergifting.com",
    "ethgrab.com",
    "ethg.me",
    "jdex.market",
    "idex-myaccount.com",
    "index-markct.com",
    "ldox.market",
    "10000eth.net",
    "eoslaunch.io",
    "coinbase.pro-fork.com",
    "pro-fork.com",
    "ethgiveaway.zkr.kr",
    "eth-promo.wixsite.com",
    "calchain.io",
    "air-eos.com",
    "got-eth.com",
    "geteth.online",
    "get.etherofficial.com",
    "etherofficial.com",
    "tomochain.tech",
    "xn--ehterdeta-wd6d.com",
    "mycryiptowaliet.com",
    "lendium.tech",
    "xn--myethrwalet-vrb05c.com",
    "kineticairdrop.typeform.com",
    "elon-gives-eth.paperplane.io",
    "rebl984.9999eth.com",
    "9999eth.com",
    "ethclaimer.byethost32.com",
    "essentialairdrop.typeform.com",
    "myetherwallets-official.com",
    "udex.market",
    "icex.market",
    "idexx.market",
    "starkware.online",
    "myetherwalleta.org",
    "myetherwalleto.org",
    "myetherwallett.org",
    "onemew.online",
    "myethervvalet.io",
    "eth-request.org",
    "eths.space",
    "btc-gift.org",
    "eth-free.github.io",
    "ethergiveme.com",
    "ether-give.com",
    "eth-share.org",
    "myerherwallet.tk",
    "myetherwallet.news",
    "myetherwalletz.org",
    "myethrwallet.org",
    "myrvnwallet.com",
    "myetherwanllet.com",
    "myetherwellat.com",
    "myetherwellets.com",
    "xn--myetherwalt-crb17c.com",
    "quarkchain.pub",
    "claim-eth.com",
    "send.ethergot.com",
    "ethergot.com",
    "securepay-eth.org",
    "gift-10000eth.com",
    "my-etherwallsecure.com",
    "secure375446884521.safeethpay.com",
    "safeethpay.com",
    "quarkchain.in",
    "rnyetherwallel.com",
    "xn--methrwallet-uib92a.com",
    "domain501dom.com",
    "myethwalllet.info",
    "secure75405732935.safethpay.com",
    "wallets-ether.com",
    "brm.10000eth-gift.com",
    "ethsecure.info",
    "get.ico-eth.net",
    "ico-eth.net",
    "collectmyethers.org",
    "givefree-eth.com",
    "now-5000ether.paperplane.io",
    "eth-give.info",
    "xn--mytherwallet-fvb.net",
    "xn--myethewllet-ife2794g.com",
    "xn--metherwallt-crb6719g.com",
    "xn--myeterwllet-nl8er2d.com",
    "xn--metherallet-ol9e03c.com",
    "xn--mytherwalet-srb45c.com",
    "xn--myetherwlet-48a42j.com",
    "xn--myetherwllt-s8a7g.com",
    "xn--myethrwaet-mlb18ca.com",
    "xn--metherwalle-uib05k.com",
    "xn--mytherwalet-obb56i.com",
    "xn--myethrwalet-6qb77c.com",
    "xn--myetherwallt-fwb.net",
    "ethgive.net",
    "tron-block.com",
    "idex-market.site",
    "eth4everyone.com",
    "mew-ehterwallat.com",
    "94.100.18.96",
    "get.it-now-eth.com",
    "it-now-eth.com",
    "give.promoeth.net",
    "promoeth.net",
    "etherkickstart.com",
    "eth-hype.com",
    "instant-ether.com",
    "pay.ethwitheth.com",
    "ethwitheth.com",
    "10000eth-gift.com",
    "klareol5.ru",
    "20000.paperplane.io",
    "secure093555613.safethpay.com",
    "get.ico-eth.org",
    "ico-eth.org",
    "payment-ethereum.online",
    "tron-block.info",
    "neo-online.info",
    "ethconfirm.info",
    "offer.ethsn.com",
    "ethsn.com",
    "hydroraindrop.typeform.com",
    "ethgift.org",
    "etherdelta.githiub.io",
    "githiub.io",
    "ether-promo.org",
    "atn437.ethgiveeth.com",
    "ethgiveeth.com",
    "5000eth-promo.com",
    "myetherofficial.com",
    "myetherwallat.online",
    "myetherwalletw.org",
    "myetherwallte.net",
    "myetherwalret.ru",
    "xn--metherwalet-uib39f.com",
    "myetlherwallet.pro",
    "bittrexa.com",
    "xn--bttrx-7ra5a.com",
    "bittrexr.com",
    "bittrex-account-verification.com",
    "bittrex-login.com",
    "biitbay.com",
    "kcucoin.com",
    "vvallbtc.com",
    "eth-promo.net",
    "tdex.market",
    "login-myetherwallets.com",
    "claimeth.epizy.com",
    "walleteos.org",
    "nathanielpopper.promo-eths.com",
    "promo-eths.com",
    "pay.ethconfirm.com",
    "ethconfirm.com",
    "eth-share.com",
    "eth-gift.com.paperplane.io",
    "iidexmarket.com",
    "ebtweinfinance.com",
    "cardanoethereum.com",
    "ethergiveaway.website",
    "get-ethereum.info",
    "get-event-ethereum.info",
    "give-eth.news",
    "eth-box.xf.cz",
    "ethersforme.net",
    "giftethers.com",
    "m342edium.ethersforme.net",
    "10000-eth.com",
    "icostarex.mipropia.com",
    "ethsgive.com",
    "giveaway-ether.com",
    "bonus.giftethers.com",
    "get-eths.com",
    "get-ethereum.site",
    "cryptos-promos.com",
    "safethpay.com",
    "paygiveaway.com",
    "tokenpublicsales.com",
    "ethgive.online",
    "ether.vu",
    "getnoweth.com",
    "waves-ethereum-eth.org",
    "ethereum-eth.life",
    "mycrypto-com.com",
    "quarkchain.pl",
    "get-5001-ethereum.com",
    "get-5000-ethereum.com",
    "myetzerwallet.com",
    "promobtc.win",
    "tokenairdrop.typeform.com",
    "transfer.saferpayeth.com",
    "saferpayeth.com",
    "r5.ms",
    "xn--mytherwalet-3qb97c.com",
    "xn--myethrwllet-pjb5u.com",
    "xn--myetherwalt-0rb64c.com",
    "cryptofaze.com",
    "hederaheshgraph.com",
    "ethergift.org",
    "myetheerwallet.pw",
    "secure-give-eth.com",
    "kann.io",
    "pundix.tech",
    "quarkchains.io",
    "ethcollection.paperplane.io",
    "hydroggenplatform.com",
    "ldcx.market",
    "eth-airdrop.com",
    "ether-promo.unas.cz",
    "xn--tbtc-zpa34a.com",
    "xn--myetherwalt-crb27c.com",
    "hydroplatform.org",
    "eth-giveaway.today",
    "etherget.online",
    "ethplatform.org",
    "mycrypton.net",
    "5000ethereum.online",
    "hederahashgaph.com",
    "5000-eth.paperplane.io",
    "zilliqablockchain.org",
    "idec.market",
    "ihex.market",
    "zclassiccoins.com",
    "omisegowallet.network",
    "musk.vu",
    "quarkchain-presale.io",
    "ethairdrop.live",
    "ethgiveavvay.site",
    "etherums-givingaway.atspace.tv",
    "etherfree.tech",
    "secure-ethereum.tw1.su",
    "phantasma-ico.io",
    "sentinelprotocol.pw",
    "24h.infora.hu",
    "eth-securepay.com",
    "secureceth.com",
    "eth-giving.ga",
    "free-eths.paperplane.io",
    "nexotoken.org",
    "quarkchain-tokens.io",
    "giveavvay-10000eth.online",
    "ethpromo.org",
    "i-dexmarkets.com",
    "edenchain.site",
    "xn--mytherwallet-5vb.net",
    "i-dexmarket.com",
    "bi-ttrex.com",
    "www-bittrex.com",
    "xn--bifinex-fb4c.com",
    "xn--blockcain-g95d.com",
    "xn--coinbas-z8a.info",
    "xn--htbt-3oa0a.com",
    "xn--myethewallt-crb9748g.com",
    "xn--polonix-17a.com",
    "xn--tro-k5y.com",
    "privcoin.io",
    "free-eth.paperplane.io",
    "ihcx.market",
    "helbizcoin.net",
    "telegram-token.io",
    "icostats.io",
    "musk-party-gifts.updog.co",
    "yobittrading.net",
    "yobit-trading.net",
    "securetransfer.ethpromotion.com",
    "ethpromotion.com",
    "brickblockio.info",
    "collect.ethforyou.com",
    "ethforyou.com",
    "getmyetho.paperplane.io",
    "xn--myetherwallt-ovb.net",
    "idexmarkets.com",
    "ethsafepay.net",
    "presale.getmyethers.net",
    "getmyethers.net",
    "xn--tbtc-upa94a.com",
    "xn--itbtc-9g1b.com",
    "myetherwalleth.org",
    "brickblocks.io",
    "zilliqanetwork.com",
    "brickblock.cc",
    "quarkchain.de",
    "promo-give-ethereum.org",
    "give-ethereum.org",
    "ethereum-giveaway.site",
    "forkdelta.net",
    "i-idex.market",
    "kinecosystem.io",
    "quark-chain.io",
    "quarkchain.org",
    "quarkchaln.io",
    "quarkchain.website",
    "get-ethereum.ml",
    "5000eth.net",
    "claim.payeths.com",
    "payeths.com",
    "gameofdeception.get-5000-eth.com",
    "zilliqablockchain.com",
    "ethgiveavvay.com",
    "rebellios.com",
    "kinecosystems.org",
    "zilliqa.online",
    "mycrypto.get-5000-eth.com",
    "get-5000-eth.com",
    "eden-chain.io",
    "coinbtcnews.com",
    "xn--polomex-cza.com",
    "helpcoinbase.com",
    "account-coinbase.com",
    "coinbase-eth-giveaway.com",
    "free-eth.news",
    "forkdeltas.com",
    "elon-giveaway.com",
    "myetherwallet.secure.access-checker.com",
    "access-checker.com",
    "etherget.us",
    "freecoingifts.com",
    "quick.payeths.com",
    "take-eth.online",
    "ether-giveaway.tech",
    "xn--shapeshft-c5a.com",
    "xn--mycrpto-k64c.com",
    "orchidprotocols.com",
    "hadeplatform.net",
    "quarkchain.tech",
    "hederahashgraph.store",
    "myetherwallet.access-checker.com",
    "freeeth.info",
    "coinbasle.com",
    "eth-payment.online",
    "ethereum5000.com",
    "get-eth.us",
    "ethsecurepay.com",
    "bonus.ethergives.com",
    "ethergives.com",
    "ocoins.tech",
    "hederahashgraph.online",
    "5000.ethereumgive.com",
    "ethereumgive.com",
    "ethergive.000webhostapp.com",
    "verifiedeth.com",
    "eth-giveaway.co.nf",
    "giveavvay10000eth.host",
    "5000eth.org",
    "eth-giveaway.updog.co",
    "gift-ether.com",
    "bonus.gift-ether.com",
    "mycrypto.cm",
    "tronlabsnetwork.com",
    "cdnsfiles.com",
    "xn--conbase-cfb.com",
    "blockschajn.info",
    "blockchajns.info",
    "blockchaljn.info",
    "xn--myeherwallet-fcc.com",
    "xn--myetherwlle-3kb01f.com",
    "blocks-chains.info",
    "blockschaln.info",
    "xn--blockchaj-3vb.info",
    "blokclnain.info",
    "blokclnaln.info",
    "xn--myetherwllet-edb.com",
    "xn--blockchln-hdb.info",
    "xn--blockchln-c3a.info",
    "xn--blockchln-61a.info",
    "xn--blckchaln-c6a.info",
    "xn--blckchaln-66a.info",
    "xn--blockhai-48a72d.info",
    "cken.site",
    "blockchaihs.info",
    "ethereum.vu",
    "myetherewallet.net",
    "myetharwallet.stream",
    "meythcrrwallet.ru.com",
    "get-ethereum.org",
    "axpire.tech",
    "eth-givea-way.com",
    "eosreward.io",
    "bitfinex.eu",
    "www-mycryptos.com",
    "www-mycryqto.com",
    "mycrypto4cash.com",
    "mycrylto.com",
    "mycrypt9.com",
    "mycryptoc.com",
    "giveaway-eth.com",
    "quarkchain-ico.io",
    "eth-24h.com",
    "ethgiveaways.net",
    "myetherwallet-start.download",
    "myethereumwalletpro.com",
    "myehretewallet.com",
    "myetherwallet-cash.download",
    "myetherwallet-official.download",
    "myetrhrerwallet.com",
    "mynerthwallet.com",
    "mynethwallet.com",
    "mynetwalleteth.com",
    "mynewalleteth.com",
    "bancatoken.org",
    "zilliqa.site",
    "free-give-eth.com",
    "iconfoundaton.com",
    "geteths.live",
    "etherdrops.com",
    "ethereumdrop.batcave.net",
    "batcave.net",
    "eth-platform.com",
    "main-myetherwallet.com",
    "eth-get.online",
    "collecteth.com",
    "promo-ether.com",
    "ethereumwalletgenerator.com",
    "ethereums.live",
    "ethpromo.net",
    "gift-5000eth.org",
    "promotioneth.com",
    "bonus.gift-ethers.com",
    "gift-ethers.com",
    "gram-token-sale.com",
    "myetherwalt.com",
    "nnycrypto.com",
    "myrcrypto.com",
    "myerypto.com",
    "mrycrypto.com",
    "mycryrpto.com",
    "mycrypto.ltd",
    "mycrypto.group",
    "mycrypto.ink",
    "mycrypto.promo",
    "eth-reward.com",
    "give-eth.online",
    "mvmonero.co",
    "5000ethgift.com",
    "quarkchain-tokensale.io",
    "ethereumgiveaway5000.com",
    "get-5000eth.com",
    "take5000eth.com",
    "ether_promo.kissr.com",
    "kissr.com",
    "eth-giveavvay.online",
    "ethereums.cloud",
    "ico-telegram.net",
    "icotelegramgroup.com",
    "ico-telegram.is",
    "ico-telegramcoin.com",
    "ico-telegram.cc",
    "tokentelegram.info",
    "tokentelegram.live",
    "letherwindows.com",
    "5000eth-gift.com",
    "get-ethereum.gift",
    "ethereum-give.czweb.org",
    "czweb.org",
    "5000eth-giveaway.com",
    "ether-giveaway.atspace.eu",
    "atspace.eu",
    "eth-airdrop.online",
    "polymath-network.com",
    "securepayeth.com",
    "gift5000eth.com",
    "localetherieum.com",
    "give-5000eth.org",
    "bonus.ethersgifts.com",
    "ethersgifts.com",
    "myoknawell.com",
    "myletherwarlet.com",
    "mywindorwallet.com",
    "tron-coin.org",
    "gift-5000eth.com",
    "daostack-ico.io",
    "xn--myethewalet-ms8erq.com",
    "xn--mythewallet-3qb3158g.com",
    "xn--myeerwallet-ml8el7a.com",
    "xn--mythrwallet-5qbx.com",
    "xn--myethewallt-crb5058g.com",
    "xn--meherwallet-998e27d.com",
    "xn--mytherwllet-xt9e0k.com",
    "xn--myetherwlle-jb9e0y.com",
    "xn--myeterallet-cm8eo0c.com",
    "xn--myehewalle-iw2e1gi.com",
    "xn--mycypto-c63c.com",
    "xn--myeterwallt-crb1087g.com",
    "xn--myterwallet-3qb9087g.com",
    "xn--myeherwae-xd6da13dia.com",
    "xn--ytherwallet-2qb6918g.com",
    "xn--mytherwalet-ms8e53d.com",
    "eosrewards.io",
    "tron-network.org",
    "bonus.ethersgift.com",
    "ethersgift.com",
    "quarkchain-token.io",
    "gift5000-eth.com",
    "myetherwallet-xn1.com",
    "xn--htbtc-q81b.com",
    "hittbte.com",
    "hitlbtc.com",
    "poloneix.co",
    "polomeix.co",
    "myetherwallet0.com",
    "myehterwallet-ht.com",
    "clo-airdrop.info",
    "freecoiners.com",
    "get-ethereum.cc",
    "nmyetlerwailet.com",
    "eth-promo.webz.cz",
    "etherclaims.rf.gd",
    "5000eth.rf.gd",
    "eth-promo.kissr.com",
    "nmyetlerwaiiet.com",
    "getyoureth.com",
    "eth-today.rf.gd",
    "ethereum.org-giveaway.live",
    "bonus.ether-gift.com",
    "ether-gift.com",
    "eth-givingaway.com",
    "ethgiveaway.live",
    "ethgiveaway.org",
    "get5000eth.com",
    "5000eth-giveaway.getforge.io",
    "shapeslhift.io",
    "shapeskift.io",
    "bonus.eth-gifts.com",
    "eth-gifts.com",
    "offpromoeth.com",
    "ethpromoverge.com",
    "poloniex-withdrawals.bitballoon.com",
    "gether-gift.com",
    "get-ether.fund",
    "eth-airdrop.live",
    "classicetherwallt.com",
    "hederahashgraph.infotokensale.com",
    "nmyetlerwaliet.com",
    "eth-drop.com",
    "mnycryptoethwallet.com",
    "bonus.ether-gives.com",
    "ether-gives.com",
    "ethforeth.com",
    "ethereumpomo.online",
    "mnyetnherwaliet.com",
    "eth-foundation.github.io",
    "forkdeltagithub.io",
    "wwwetherdelta.com",
    "xn--etherdlta-lib.com",
    "xn--etherdelt-876d.com",
    "xn--etherdela-ss6d.com",
    "xn--therdelta-uf7d.com",
    "xn--etherwallet-tv8eq7f.com",
    "xn--meherwalle-212ei17o.com",
    "xn--myetewallet-4dc4796g.com",
    "xn--myetherallt-0k9ejx.com",
    "xn--eterelta-ou9c9h.com",
    "wallet-mew.com",
    "xn--etherelta-u05d.com",
    "xn--mcrypto-rpd.com",
    "give-5000eth.com",
    "bonus.ether-gifts.com",
    "give5000-eth.com",
    "5000ethgive.com",
    "xn--myethrwalet-ns8e73d.com",
    "aelftoken.com",
    "dfinity.ml",
    "myethverwallet.com",
    "mithriltoken.tech",
    "win-eth.org",
    "eth-today.epizy.com",
    "give5000eth.com",
    "ethhit.org",
    "nkn-token.io",
    "get-ether.me",
    "xn--myetherwalle-occ.com",
    "xn--myethewllet-w48ep6a.com",
    "promo.ethereumbonus.online",
    "ethereumbonus.online",
    "ethtoget.com",
    "myetherwalletru.com",
    "i-myetherwallet.com",
    "eos-candy.com",
    "neonexchange.website",
    "get-ether.gift",
    "etherscan.tech",
    "xn--myethewllet-ife6494g.com",
    "ncashtoken.org",
    "eth.kissr.com",
    "ethtransaction.ezyro.com",
    "eth-give.org",
    "ethtotrade.com",
    "tokentelegram.net",
    "eth-private-key.webz.cz",
    "collect-eth.com",
    "myetherwallet.lt",
    "myetherwallet-register.com",
    "eth-promotion.getforge.io",
    "btc-gifts.info",
    "eos-dac.com",
    "localetherwallet.com",
    "free5000eth.com",
    "ethpaysafe.com",
    "ico-telegram.co",
    "eth-giving.com",
    "xn--conbas-gva1a.com",
    "www-colnbase.com",
    "5000eth-giveaway.online",
    "givefreeeth.com",
    "ether-promo.getforge.io",
    "gether.fund",
    "ethereum-giveaway.tekcities.com",
    "tron-airdrop.info",
    "ethn.cash",
    "eos-airdrop.com",
    "xn--medim-9d2b.com",
    "xn--myethrallet-zk9e6w.com",
    "ethereums-2018-give-away.bitballoon.com",
    "givingawayeth.com",
    "ethereum-giveaway.com",
    "ethsafe.trade",
    "check-ethpayments1.kissr.com",
    "ethereum-giveaway.kissr.com",
    "smartolinks.com",
    "livivid.com",
    "clickmoneysystem1.com",
    "ethereum-give.byethost16.com",
    "givingawayethereum.com",
    "ethereum.czweb.org",
    "ethc.fund",
    "eth-giveaway.trade",
    "gram-ico.io",
    "etherscans.net",
    "io-eos.com",
    "telegram-ico.tech",
    "ico-telegram.money",
    "icontoken.foundation",
    "eth-give-away.webz.cz",
    "5000eth.info",
    "authorize.live",
    "azone-web.com",
    "binance-giveaway.firebaseapp.com",
    "bitwelfare.biz",
    "cryptocurrencies-bitcoin.com",
    "eth-freesharing.com",
    "eth-gives.com",
    "eth-private.com",
    "eth-trans.bitballoon.com",
    "eth-transactions.com",
    "ether-giveaway.com",
    "ether-transfer.online",
    "etherblessings.com",
    "etherclaims.byethost8.com",
    "ethereumdrop.com",
    "ethereumdrop.org",
    "ethereumone.info",
    "ethergiveaway.win",
    "ethergiveaways.tumblr.com",
    "etheriumairdrop.com",
    "etherum.site123.me",
    "ethf.bid",
    "ethgive.info",
    "ethgiveaway.online",
    "ethsend.online",
    "ethtransaction.unaux.com",
    "get-ethers.com.cp-32.webhostbox.net",
    "give-binance.party",
    "ip222.ip-54-38-120.eu",
    "myetherpromo.com",
    "neonexchange.online",
    "tokencrowdsale.info",
    "ethergiftwallet.com",
    "ethpromo.gift",
    "giveaway-ethereum.com",
    "giveawayether.com",
    "ethereumpromo.info",
    "ethhit.com",
    "free-5000eth.com",
    "ethc.gift",
    "dfnity.org",
    "coinbase.droppages.com",
    "meythapvettal.com",
    "get-ethers.com",
    "gramfoundation.io",
    "check-ethpayments.kissr.com",
    "centratoken.site",
    "gramtokenico.com",
    "eth-gifting.site",
    "ethereums-promo.bitballoon.com",
    "ethereum-promo2018.bitballoon.com",
    "ethpromo.com",
    "free-ethereum.czweb.org",
    "ethn.vu",
    "etherpromo.org",
    "ethpay.site",
    "ethgift.info",
    "tokenpublicsale.com",
    "etherpromo.online",
    "tron-nextlevel.bitballoon.com",
    "mycrypto.company",
    "myetherapywaillet.com",
    "myetherapywalilet.com",
    "myetherapywallet.com",
    "myetherapywalliet.com",
    "mybethernvwallet.com",
    "myotherapywallet.com",
    "myuuetheraswallet.com",
    "nnyctncrwalliet.com",
    "nnyctncrvvallet.com",
    "myetheurwallet.com",
    "ico-telegram-ton.com.ru",
    "ton-ico.ga",
    "mailingserver2.com",
    "gram-token.org",
    "lco-telegram.org",
    "tonogram.org",
    "eth-give.kissr.com",
    "myegethercowwallet.com",
    "tron-giveavay-weeklyreport.bitballoon.com",
    "ethdropnew.ml",
    "cryptoplus.be",
    "dfinity.org.in",
    "payforfees.online",
    "nnyctncrwaillet.com",
    "myunetherhawallet.com",
    "airdrop-bluzelle.com",
    "tronfoundation.tech",
    "safely-transfer.com",
    "eth.vu",
    "xn--myeterallet-nl8eo0c.com",
    "get-eth.pl",
    "cz-binance.com",
    "signalsx.com",
    "eth-gift.tw1.su",
    "myetnarvellat.com",
    "mynbethernvwallet.com",
    "myehcrwalilet.com",
    "gdaxsupport.com",
    "coinbaseexchange.org",
    "coinbasehelp.info",
    "coinbaseassist.info",
    "kinecosystem.net",
    "telegramtoken.global",
    "telcoinairdrop.com",
    "xn--mytherwalet-3qb10c.com",
    "ethgiveaway.club",
    "coinnbase.com",
    "dailyinequality.org",
    "ethg.cz",
    "crypto-payout.tk",
    "vechain-ven.com",
    "tokensale-telegram.com",
    "ethr.cc",
    "nnyecthenwellat.com",
    "nnyiicteherwailiatt.com",
    "themisnetwork.org",
    "www-myetherwellet.com",
    "eth-today.com",
    "ethg.gift",
    "ether-zero.info",
    "ethgiveaway.info",
    "bonus.ethersgive.com",
    "ethersgive.com",
    "tronfoundation.me",
    "eths.li",
    "auctus.network",
    "auctuss.org",
    "auctus.org.in",
    "auctus-ico.network",
    "xn--aucts-1gb.org",
    "coinmakerbot.com",
    "blnnance.com",
    "myetherwallet.heliohost.org",
    "ton-telegram.com",
    "tonpublic.org",
    "claim.ethdeal.info",
    "telegram.trade",
    "telegram-coin.org",
    "nnyiictehervvailiatt.com",
    "eths.vu",
    "shivoms.io",
    "telegramsale.com",
    "hederashashgraph.com",
    "eth-transaction.site44.com",
    "xn--metherwllet-ln9eqi.com",
    "xn--bitcointlk-85a.org",
    "coinbaase.cf",
    "coinnbase.ml",
    "coinnbase.tk",
    "binaance.ga",
    "binaance.cf",
    "binancce.cf",
    "binancce.ml",
    "xn--myetlherallet-341g.com",
    "paveldurov.bitballoon.com",
    "secure-eth-transactions.bitballoon.com",
    "giveaway-ethereum.org",
    "ethpayd.com",
    "ethdrop.info",
    "i-myetherwalnet.com",
    "metronome-token.io",
    "coin-zc.com",
    "xn--bitcon-mwa.com",
    "myettherwallet.xyz",
    "ethpayment.bitballoon.com",
    "ethopen.com",
    "telegramnetwork.org",
    "geth.cc",
    "telegram.ceo",
    "etherscan-giveaway.epizy.com",
    "eths.bz",
    "swaapy.network",
    "binance.ethdeal.info",
    "ethdeal.info",
    "gramnetwork.org",
    "galaxy-es0lutions.com",
    "eth.altervista.org",
    "musk.gift",
    "mycrypto.bz",
    "eth.vg",
    "eth-giveaway-vote.bitballoon.com",
    "eth-promo.com",
    "work.nelsconsult.com.ng",
    "etherfreegive.com",
    "secure-s28h3h2j54jehdh43jh3k5h42l4h23hk6l49sjxvsatoshilite.bitballoon.com",
    "giveaway-payment-add.bitballoon.com",
    "big-promo-march.tumblr.com",
    "ethgive.github.io",
    "myetherwalletradeico.blogspot.de",
    "owainpritchard.co.uk",
    "et.gl",
    "xn--condesk-ww4c.com",
    "xn--myethrwllet-6qb2249g.com",
    "airdrop-ether.bitballoon.com",
    "info-transaction.com",
    "eth.hn",
    "binance-promo.net",
    "trust-cryptopayment.com",
    "ethereum-transfer.online",
    "icotonsale.com",
    "etherbonuses.com",
    "ethfreeget.com",
    "tongram.me",
    "funfaircoin.org",
    "coinbase-secure-a2k34j.bitballoon.com",
    "ethereumtrans.com",
    "xn--condes-8bb1661d.com",
    "ethergiveawaytweet.tk",
    "eth-giveaway.gq",
    "nnyettiervwallat.com",
    "nnyettiervwallet.com",
    "eth.vote",
    "eth-promo.bitballoon.com",
    "ethfreepay.com",
    "promo-trx.tk",
    "paymentaddress.tumblr.com",
    "cryptongram.org",
    "campaigntoken.blogspot.de",
    "coin-promos.com",
    "xn--ytherwallet-iw8ex8c.com",
    "smartexchangecenter.tk",
    "xn--oindesk-15a.com",
    "eth-transaction.secure.kissr.com",
    "otoeveryday.info",
    "ethfreecandy.bitballoon.com",
    "etherscanio.github.io",
    "ico-gram.net",
    "gramtoken.network",
    "ethfreegive.com",
    "ether-promo.bitballoon.com",
    "xn--cindesk-cx4c.com",
    "theadsleader.000webhostapp.com",
    "myetherwalletico.blogspot.de",
    "eth-giveaway.info",
    "syncfab.eu",
    "eth-giveaway.com",
    "icoeth.tk",
    "eth-giveaway-706.htmlcomponentservice.com",
    "mybinance.info",
    "xn--myethewallet-kjc.com",
    "polyswamr.io",
    "polyswarm.me",
    "polyswarms.io",
    "eth4free.ml",
    "ico-telegram-ton.com",
    "telegram.tw",
    "gramton.info",
    "gramsap.enterprises",
    "ico-telegram.club",
    "telegram.one",
    "etharscan.io",
    "xn--coindes-jhb.com",
    "blocikchair.info",
    "eth-cz-319.htmlcomponentservice.com",
    "xn--myetherwaet-0t8ea.com",
    "eth-giveaway-514.htmlcomponentservice.com",
    "xn--mtherwallet-z19ex1a.com",
    "xn--eo-e9a.com",
    "cosss.io",
    "callistonetwork.tech",
    "xn--metherwallt-819eo1a.com",
    "ethfreepays.com",
    "nnyettiervwailet.com",
    "xn--hapehift-oh0de.com",
    "gram.vc",
    "bonus.etherpayout.com",
    "etherpayout.com",
    "ethereum-giveaway.info",
    "xn--bnanc-fsax.com",
    "xn--binnce-y0a.com",
    "eth-giveaway-209.statichtmlapp.com",
    "binance.bitballoon.com",
    "binance-give.com",
    "ilil.pw",
    "myetherwallet.com.send-transaction_8hlg6z8mgt6zyg.ilil.pw",
    "telegram.site",
    "telegram.auction",
    "miroskii.com",
    "eth-transactions.neocities.org",
    "online-eos.org",
    "data-token.org",
    "eth953883.htmlcomponentservice.com",
    "reeveclancy.wixsite.com",
    "transfer-eth.neocities.org",
    "eth.secure-transactionssecure.com",
    "secure-transactionssecure.com",
    "nnyiictehervvailiat.com",
    "odachi.neocities.org",
    "bittrex-give.com",
    "policypal.info",
    "changlley.org",
    "rnyertherwallet.com",
    "xn--thabyss-u8a.com",
    "callisto-airdrop.com",
    "telegramfoundation.org",
    "polymathnetwork.org",
    "ethereum-promo.bitballoon.com",
    "dfintty.org",
    "dftnity.org",
    "usermd.net",
    "xn--gemn-nzab.com",
    "xn--bnance-3va.com",
    "xn--binnce-yc8b.com",
    "xn--bnance-p9a.com",
    "xn--binane-0ua.com",
    "binalce.com",
    "binince.com",
    "xn--conbase-pza.com",
    "xn--conbase-sfb.com",
    "xn--coinbas-xya.com",
    "xn--coinbas-z8a.com",
    "xn--coinbse-9wa.com",
    "xn--coinbse-lwa.com",
    "xn--polonex-vfb.com",
    "xn--ploniex-l0a.com",
    "xn--plniex-bxab.com",
    "xn--havvn-9za.io",
    "havvenio.com",
    "nucelus.vision",
    "metronometoken.io",
    "meganfoxloveyou.com",
    "xn--yetherwalle-iw8e1s.com",
    "tron-online.org",
    "myenthereumwallet.com",
    "myetherwallet-team.com",
    "myetherwallet.usermd.net",
    "xn--yetherwalle-tv8ezt.com",
    "xn--coindek-873c.com",
    "dflinity.org",
    "ipsx.promo",
    "havven-sale.com",
    "tokensale-adhive.com",
    "ataritoken.ltd",
    "transfer-address-confirmation.droppages.com",
    "dfinlty.org",
    "poloniex.work",
    "tokensale-havven.in",
    "ico-havven.org",
    "secure.poloniex.work",
    "vechain-foundation.org",
    "telegram.tokyo",
    "forkdelta.io",
    "ton-sale.com",
    "ico-telegram.online",
    "telegramtoken.io",
    "gonetwork-airdrop.co",
    "secure-transaction-confirmation.droppages.com",
    "neonexchanges.org",
    "eth-transact.secure.droppages.com",
    "6khb.payment-checker-ethereum-id-bslyftexjuwcgv8.filesusr.com",
    "akasha-world.com",
    "address-transfer-confirmation.droppages.com",
    "b5z.net",
    "p.b5z.net",
    "tokensale.xn--havve-7l1b.com",
    "xn--coindes-bx3c.com",
    "xn--coindek-s73c.com",
    "locaeltherum.com",
    "myetherwallet.tokenimport.com",
    "tokenimport.com",
    "leadscoin.network",
    "localethereom.com",
    "havvens.win",
    "xn--metherwalle-jb9ejq.com",
    "xn--myetheralle-jb9exm.com",
    "tefood.me",
    "havventoken.com",
    "havven.cc",
    "havven.eu",
    "havven.top",
    "mywalletether.com",
    "myetherwallett.site",
    "xn--myethewalle-w48erh.com",
    "el-petro-coin.com",
    "xn--yeterwallet-bm8eym.com",
    "sale-orchid.com",
    "electrify-asia.info",
    "tron-foundation.org",
    "dflnlty.org",
    "polyswarm.tech",
    "tokensale.polyswarm.tech",
    "polyswarm.ru",
    "dock.click",
    "leadcoins.network",
    "dock-tokensale.eu",
    "polyswarm.pw",
    "dock-io.org",
    "heavven.io",
    "havven.live",
    "havven.sale",
    "havven.info",
    "dock.network",
    "blocklancer.me",
    "tokensale-havven.io",
    "havven.pro",
    "tokentelegram.com",
    "ico-telegram.me",
    "myetherzero.com",
    "seele-token.pro",
    "tokensale-havven.com",
    "polyswarm.in",
    "sale-dock.com",
    "polyswarm.co",
    "polyswarm.bid",
    "ton.fund",
    "forkdeita.github.io",
    "xn--binnce-5nf.com",
    "xn--biace-4l1bb.com",
    "jiocoins.io",
    "xn--polonx-0va26t.com",
    "myetlherewallet.org",
    "myeithereiuwallet.com",
    "fin-trux.com",
    "finetrux.com",
    "telcoin.pro",
    "xn--es-8bb.com",
    "xn--myetherallt-pl9elw.com",
    "ico-dock.org",
    "dock.io-bonus.online",
    "docks.site",
    "dock-ico.pro",
    "dock-ico.eu",
    "dock.su",
    "tokensale-dock.io",
    "dock-ico.site",
    "openplatform.tech",
    "rightmesh.in",
    "waxtoken.in",
    "metamaskgiveaway.xyz",
    "nebulastoken.in",
    "vechain-foundation.com",
    "icotoken-current.top",
    "xn--myethrwalle-jb9e19a.com",
    "xn--myetheralle-7b9ezl.com",
    "iconfoundation.co",
    "fundrequest.info",
    "xn--myetherwale-os8e7x.com",
    "remme-ico.eu",
    "gonetwork.live",
    "token.gonetwork.pro",
    "gonetwork.pro",
    "gonetwork.eu",
    "nucleus-vision.cc",
    "jibreltoken.in",
    "dock.so",
    "dock.promo",
    "xn--mycrypt-r0a.com",
    "xn--mycrypt-g1a.com",
    "xn--mycrpto-y2a.com",
    "ethexploit.org",
    "remme.in",
    "remme.ws",
    "remme.com.ng",
    "nyeitthervvallet.com",
    "xn--myeerhwailet-ooc.com",
    "myeterhwaliot.com",
    "remme.live",
    "xn--yethewalle-to2exkhi.com",
    "myetherwallet.custom-token.com",
    "custom-token.com",
    "sale-earn.com",
    "bankera.live",
    "originprotocol.io",
    "originprotocol.online",
    "originprotocols.com",
    "origirprotocol.com",
    "originprotocol.tokenpublicsales.com",
    "originprotocol.typeform.com",
    "originprofocol.com",
    "hcepro.com",
    "trx.foundation",
    "tokensale.adhive.net",
    "adhive.net",
    "decentral.market",
    "cryptoexploite.com",
    "blockclain.net",
    "xn--blckchin-5za9o.info",
    "xn--blkhain-m0a4pb.info",
    "xn--blocchal-gmb8m.info",
    "xn--blocchaln-orb.info",
    "xn--blocchan-gmb7c.info",
    "xn--blockaden-lsen-5pb.com",
    "xn--blockchai-3vb.info",
    "xn--blockchai-jvb.info",
    "xn--blockchal-3vb.info",
    "xn--blockcham-ipb.info",
    "xn--blockchan-2pb.com",
    "xn--blockchan-75a.com",
    "xn--blockchan-7sb.info",
    "xn--blockchan-d5a.net",
    "xn--blockchan-dob.info",
    "xn--blockchan-ipb.com",
    "xn--blockchan-ipb.info",
    "xn--blockchan-nk7d.com",
    "xn--blockchan-xub.info",
    "xn--blockchann-4ub.com",
    "xn--blockchi-n7a50e.info",
    "xn--blockchi-o8a54d.info",
    "xn--blockchi-p99co8a.com",
    "xn--blockchim-hdb.info",
    "xn--blockchin-1xb.info",
    "xn--blockchin-61a.info",
    "xn--blockchin-61a.net",
    "xn--blockchin-6ib.info",
    "xn--blockchin-ccb.info",
    "xn--blockchin-h4a.com",
    "xn--blockchin-h4a.info",
    "xn--blockchin-hdb.info",
    "xn--blockchin-hhb.info",
    "xn--blockchin-mib.net",
    "xn--blockchin-wcb.com",
    "xn--blockchn-fza4j.com",
    "xn--blockchn-fza4j.info",
    "xn--blockchn-n7a43b.info",
    "xn--blockchn-p0a.info",
    "xn--blockchn-tx0d4p.com",
    "xn--blockclai-3vb.info",
    "xn--blockclin-hdb.com",
    "xn--blockclin-hdb.info",
    "xn--blockclin-hdb.org",
    "xn--blockflte-kirchrode-w6b.de",
    "xn--blockfltenquartett-windspiel-81c.de",
    "xn--blockhai-obb78c.info",
    "xn--blockhain-4eb.com",
    "xn--blockhain-pfb.com",
    "xn--blockhain-pfb.info",
    "xn--blockhain-zdb.info",
    "xn--blockhan-obb65a.info",
    "xn--blockhas-d6a.com",
    "xn--blockwallt-j7a.com",
    "xn--blokchai-fqb.info",
    "xn--blokchain-nfb.info",
    "xn--blokhain-28ab.info",
    "xn--bockclnain-eyb.info",
    "xn--mymoeo-zt7bzf.com",
    "xn--mymoer-nqc1368c.com",
    "xn--mymoero-c13c.com",
    "xn--mymoero-s13c.com",
    "xn--mymoneo-f63c.com",
    "xn--mymoneo-v63c.com",
    "xn--mymoneo-y53c.com",
    "xn--mymoner-j0a.com",
    "xn--mymoner-j5b.com",
    "xn--mymoner-r0a.com",
    "xn--mymoner-z0a.com",
    "xn--mymoner-z2c.com",
    "xn--mymonro-fya.com",
    "xn--mymonro-x8a.com",
    "xn--myetheallet-l58emu.com",
    "xn--myetheraet-9k2ea77h.com",
    "xn--myetheralet-ms8e21b.com",
    "xn--myetheralle-7b9exm.com",
    "xn--myetherallet-5s5f.com",
    "xn--myetherallet-fs5f.com",
    "xn--myetherewalle-1t1g.com",
    "xn--myetherllet-pl9e6k.com",
    "xn--myethervvalle-8vc.com",
    "xn--myetherwaet-61ea.com",
    "xn--myetherwaet-8eda.com",
    "xn--myetherwaet-ns8ea.com",
    "xn--myetherwale-ns8e8x.com",
    "xn--myetherwalet-0fb.com",
    "xn--myetherwalet-0z4f.com",
    "xn--myetherwalet-814f.com",
    "xn--myetherwalet-d9b.com",
    "xn--myetherwalet-h14f.com",
    "xn--myetherwalle-9me.com",
    "xn--myetherwalle-ek5f.com",
    "xn--myetherwalle-fqc.com",
    "xn--myetherwalle-opc.com",
    "xn--myetherwalle-q05f.com",
    "xn--myetherwllet-wob.com",
    "xn--myetherwllt-r7a0i.com",
    "xn--myethewaliet-9d5f.com",
    "xn--myethewalle-3ic0947g.com",
    "xn--myethewallet-0e5f.com",
    "xn--myethewallet-1kc.com",
    "xn--myethewallet-bkc.com",
    "xn--myethewallet-vof.com",
    "xn--myethewalliet-nm1g.com",
    "xn--myethewallt-kbb3019g.com",
    "xn--myethewallt-w48ew7b.com",
    "xn--myethrwalet-6qb6408g.com",
    "xn--myethrwalet-ms8e83d.com",
    "xn--myethrwallet-1db.com",
    "xn--myethrwallt-29af.com",
    "xn--myethrwallt-29as.com",
    "xn--myethrwllet-q7a31e.com",
    "xn--myethrwllet-r8a3c.com",
    "fintrux.eu",
    "refereum-ico.eu",
    "arcblock-ico.org",
    "xn--fuson-1sa.org",
    "refereum-token.com",
    "fintrux.co",
    "ico-ton.org",
    "xn--mytherwallt-cbbv.com",
    "xmoneta.co",
    "data-wallet.co",
    "tokensale.data-wallet.co",
    "xn--myeerhwallot-ooc.com",
    "xn--myeterwalet-cm8epi.com",
    "xn--myeterwalle-cm8ev6a.com",
    "rnyetherumwallet.com",
    "republic-protocol.net",
    "nyeihitervvallatt.com",
    "arcblock.eu",
    "republicprotocol.eu",
    "tokensale-fusion.com",
    "myetherwalletjoin.com",
    "medicalchian.com",
    "myeahteirwaliet.com",
    "myenhtersvvailct.com",
    "trinity-token.com",
    "xn--eo-yzs.com",
    "zilliqa.in",
    "sparc.pro",
    "myetherwallet.import-tokens.com",
    "token-gram.org",
    "xn--shapshift-e4a.com",
    "xn--shapshift-y4a.com",
    "xn--shpeshift-c2a.com",
    "xn--shpeshift-r1a.com",
    "xn--shapshift-o4a.com",
    "xn--shpeshift-w2a.com",
    "xn--shapeshft-w5a.com",
    "tokensale-fusion.org",
    "fusion-ico.com",
    "beetolen.com",
    "tokencrowdsale.online",
    "fusion.tokencrowdsale.online",
    "beetokem.com",
    "block.chaiins.in",
    "origintrail.in",
    "bit-z.ru",
    "xn--myetherallet-nu5f.com",
    "xn--mytherwalet-3qb08c.com",
    "xn--myeterwllet-cm8et1d.com",
    "xn--mytherwllet-q7a01e.com",
    "xn--biance-xt7b.com",
    "xn--bnance-wic.com",
    "xn--biance-jeb.com",
    "xn--bttrx-9za8334c.com",
    "wwwkodakcoin.com",
    "myetherwallet.uk.com",
    "kodakone.cc",
    "nyeihitervvallet.com",
    "xn--myeterwalet-cm8eoi.com",
    "nucleus.foundation",
    "beetoken-ico.com",
    "data-token.com",
    "tron-labs.com",
    "ocoin.tech",
    "aionfoundation.com",
    "ico-telegram.org",
    "nyeihitervvallat.com",
    "telegramcoin.us",
    "daddi.cloud",
    "daditoken.com",
    "blockarray.org",
    "dadi-cloud.net",
    "wanchainfunding.org",
    "ico-telegram.io",
    "iconfoundation.site",
    "iost.co",
    "beetoken-ico.eu",
    "cindicator.network",
    "wanchainetwork.org",
    "wamchain.org",
    "wanchainltd.org",
    "wanchainalliance.org",
    "nucleus-vision.net",
    "ledgerwallet.by",
    "nucleuss.vision",
    "myenhterswailct.com",
    "cobin-hood.com",
    "wanchainfoundation.org",
    "xn--polniex-ex4c.com",
    "xn--polniex-s1a.com",
    "xn--polonex-ieb.com",
    "xn--polonex-sza.com",
    "xn--polonex-zw4c.com",
    "xn--polonix-ws4c.com",
    "xn--polonix-y8a.com",
    "xn--pooniex-ojb.com",
    "gramico.info",
    "dimnsions.network",
    "www-gemini.com",
    "login-kucoin.net",
    "venchain.foundation",
    "grampreico.com",
    "tgram.cc",
    "ton-gramico.com",
    "wwwpaywithink.com",
    "coniomi.com",
    "paywithnk.com",
    "paywithlnk.com",
    "iluminatto.com.br",
    "pundix.eu",
    "xn--bttrx-esay.com",
    "xn--bttrex-w8a.com",
    "xn--bnance-bwa.com",
    "xn--shpeshift-11a.com",
    "xn--shapeshif-ts6d.com",
    "xn--shapshift-yf7d.com",
    "wwwbluzelle.com",
    "bluzelie.com",
    "nucleus-vision.org",
    "omisegonetwork.site",
    "etlherzero.com",
    "etlherdelta.com",
    "xn--condesk-0ya.com",
    "xn--condesk-sfb.com",
    "xn--coindsk-vs4c.com",
    "iexecplatform.com",
    "tongramico.com",
    "nucleus-vision.eu",
    "intchain.network",
    "wanchain.cloud",
    "bluzelle-ico.com",
    "ethzero-wallet.com",
    "xn--metherwalle-jb9et7d.com",
    "xn--coinesk-jo3c.com",
    "venchainfoundation.com",
    "myenhtersvvailot.com",
    "ether-zero.net",
    "ins.foundation",
    "nastoken.org",
    "telcointoken.com",
    "ether0.org",
    "eterzero.org",
    "bluzelle-ico.eu",
    "bleuzelle.com",
    "appcoinstoken.org",
    "xn--quanstamp-8s6d.com",
    "myehntersvvailct.com",
    "myeherwalllet.com",
    "ico-bluzelle.com",
    "bluzelle.im",
    "bluzelle.one",
    "bluzele.sale",
    "bluzele.co",
    "sether.ws",
    "xn--myetherwalet-6gf.com",
    "xn--rnyethewaliet-om1g.com",
    "rnyethervailet.com",
    "mvetherwaliet.com",
    "rnyetherwailet.com",
    "myethervaliet.com",
    "rnyethervaliet.com",
    "mvetherwalilet.com",
    "xn--myethewalie-3ic0947g.com",
    "xn--mthrwallet-z6ac3y.com",
    "xn--myeherwalie-vici.com",
    "xn--myethervvalie-8vc.com",
    "xn--mythrwallt-06acf.com",
    "xn--mtherwallet-y9a6y.com",
    "myetherwallet.applytoken.tk",
    "ethereum-zero.com",
    "quanstamptoken.tk",
    "bluzelle.network",
    "ether-wallet.org",
    "tron-wallet.info",
    "appcoinsproject.com",
    "vechain.foundation",
    "tronlab.site",
    "tronlabs.network",
    "bluzelle.cc",
    "ethblender.com",
    "ethpaperwallet.net",
    "waltontoken.org",
    "icoselfkey.org",
    "etherzeroclaim.com",
    "etherzero.promo",
    "bluzelle.pro",
    "token-selfkey.org",
    "xn--etherdlta-0f7d.com",
    "sether.in",
    "xn--ttrex-ysa9423c.com",
    "bluzelle.eu",
    "bluzelle.site",
    "gifto.tech",
    "xn--os-g7s.com",
    "selfkey.co",
    "xn--myeherwalet-ns8exy.com",
    "xn--coinelegraph-wk5f.com",
    "dai-stablecoin.com",
    "eos-token.org",
    "venchain.org",
    "gatcoins.io",
    "deepbrainchain.co",
    "myetherwalililet.info",
    "myehvterwallet.com",
    "myehterumswallet.com",
    "nucleusico.com",
    "tronlab.tech",
    "0x-project.com",
    "gift-token-events.mywebcommunity.org",
    "funfairtoken.org",
    "breadtokenapp.com",
    "cloudpetstore.com",
    "myethwalilet.com",
    "selfkeys.org",
    "wallet-ethereum.com",
    "xn--methrwallt-26ar0z.com",
    "xn--mytherwllet-r8a0c.com",
    "bluzelle.promo",
    "tokensale.bluzelle.promo",
    "cedarlake.org",
    "marketingleads4u.com",
    "cashaa.co",
    "xn--inance-hrb.com",
    "wanchain.tech",
    "zenprolocol.com",
    "ethscan.io",
    "etherscan.in",
    "props-project.com",
    "zilliaq.com",
    "reqestnetwork.com",
    "etherdelta.pw",
    "ethereum-giveaway.org",
    "mysimpletoken.org",
    "binancc.com",
    "blnance.org",
    "elherdelta.io",
    "xn--hapeshit-ez9c2y.com",
    "tenxwallet.co",
    "singularitynet.info",
    "mytlherwaliet.info",
    "iconmainnet.ml",
    "tokenselfkey.org",
    "xn--myetewallet-cm8e5y.com",
    "envione.org",
    "myetherwalletet.com",
    "claimbcd.com",
    "ripiocreditnetwork.in",
    "xn--yeterwallet-ml8euo.com",
    "ethclassicwallet.info",
    "myltherwallet.ru.com",
    "etherdella.com",
    "xn--yeterwallet-bm8ewn.com",
    "singularty.net",
    "cloudkitties.co",
    "iconfoundation.io",
    "kittystat.com",
    "gatscoin.io",
    "singularitynet.in",
    "sale.canay.io",
    "canay.io",
    "wabicoin.co",
    "envion.top",
    "sirinslabs.com",
    "tronlab.co",
    "paxful.com.ng",
    "changellyli.com",
    "ethereum-code.com",
    "xn--plonex-6va6c.com",
    "envion.co",
    "envion.cc",
    "envion.site",
    "ethereumchain.info",
    "xn--envon-1sa.org",
    "xn--btstamp-rfb.net",
    "envlon.org",
    "envion-ico.org",
    "spectivvr.org",
    "sirinlbs.com",
    "ethereumdoubler.life",
    "xn--myetherwllet-fnb.com",
    "sirin-labs.com",
    "sirin-labs.org",
    "envion.one",
    "envion.live",
    "propsproject.org",
    "propsprojects.com",
    "decentralland.org",
    "xn--metherwalet-ns8ep4b.com",
    "redpulsetoken.co",
    "propsproject.tech",
    "xn--myeterwalet-nl8emj.com",
    "powrerledger.com",
    "cryptokitties.com",
    "sirinlabs.pro",
    "sirinlabs.co",
    "sirnlabs.com",
    "superbitcoin-blockchain.info",
    "hellobloom.me",
    "mobus.network",
    "powrrledger.com",
    "xn--myeherwalet-ms8eyy.com",
    "qlink-ico.com",
    "gatcoin.in",
    "tokensale.gamefllp.com",
    "gamefllp.com",
    "xn--myeherwalle-vici.com",
    "xn--myetherwalet-39b.com",
    "xn--polonex-ffb.com",
    "xn--birex-leba.com",
    "raiden-network.org",
    "sirintabs.com",
    "xn--metherwallt-79a30a.com",
    "xn--myethrwllet-2kb3p.com",
    "myethlerwallet.eu",
    "xn--btrex-b4a.com",
    "powerrledger.com",
    "xn--cointeegraph-wz4f.com",
    "myerherwalet.com",
    "qauntstanp.com",
    "myetherermwallet.com",
    "xn--myethewalet-ns8eqq.com",
    "xn--nvion-hza.org",
    "nnyetherwallelt.ru.com",
    "ico-wacoin.com",
    "xn--myeterwalet-nl8enj.com",
    "bitcoinsilver.io",
    "t0zero.com",
    "tokensale.gizer.in",
    "gizer.in",
    "wabitoken.com",
    "gladius.ws",
    "xn--metherwallt-8bb4w.com",
    "quanttstamp.com",
    "gladius.im",
    "ethereumstorage.net",
    "powerledgerr.com",
    "xn--myeherwallet-4j5f.com",
    "quamtstamp.com",
    "quntstamp.com",
    "xn--changely-j59c.com",
    "shapeshlft.com",
    "coinbasenews.co.uk",
    "xn--metherwallet-hmb.com",
    "envoin.org",
    "powerledger.com",
    "bitstannp.net",
    "xn--myetherallet-4k5fwn.com",
    "xn--coinbas-pya.com",
    "requestt.network",
    "oracls.network",
    "sirinlabs.website",
    "powrledger.io",
    "slackconfirm.com",
    "shape-shift.io",
    "oracles-network.org",
    "xn--myeherwalle-zb9eia.com",
    "blockstack.one",
    "urtust.io",
    "bittrex.one",
    "t0-ico.com",
    "xn--cinbase-90a.com",
    "xn--metherwalet-ns8ez1g.com",
    "tzero-ico.com",
    "tzero.su",
    "tzero.website",
    "blockstack.network",
    "ico-tzero.com",
    "spectre.site",
    "tzero.pw",
    "spectre-ai.net",
    "xn--waxtokn-y8a.com",
    "dmarket.pro",
    "bittrex.com11648724328774.cf",
    "bittrex.com1987465798.ga",
    "autcus.org",
    "t-zero.org",
    "xn--zero-zxb.com",
    "myetherwalletfork.com",
    "blokclbain.info",
    "datum.sale",
    "spectre-ai.org",
    "powerledgr.com",
    "simpletoken.live",
    "sale.simpletoken.live",
    "qauntstamp.com",
    "raiden-network.com",
    "metalpayme.com",
    "quantstamp-ico.com",
    "myetherwailetclient.com",
    "biockchain.biz",
    "wallets-blockchain.com",
    "golemairdrop.com",
    "omisegoairdrop.net",
    "blodkchainwallet.info",
    "walton-chain.org",
    "elite888-ico.com",
    "bitflyerjp.com",
    "chainlinksmartcontract.com",
    "stormtoken.eu",
    "omise-go.tech",
    "saltending.com",
    "stormltoken.com",
    "xn--quanttamp-42b.com",
    "stormtoken.co",
    "storntoken.com",
    "stromtoken.com",
    "storm-token.com",
    "stormtokens.io",
    "ether-delta.com",
    "ethconnect.live",
    "ethconnect.trade",
    "xn--bttrex-3va.net",
    "quantstamp.com.co",
    "wancha.in",
    "augur-network.com",
    "quantstamp.com.ua",
    "myetherwalletmew.com",
    "myetherumwalletts.com",
    "xn--quanstamp-tmd.com",
    "quantsstamps.com",
    "changellyl.net",
    "xn--myetherwalet-1fb.com",
    "myethereumwallets.com",
    "xn--myetherwalet-e9b.com",
    "quantslamp.com",
    "metelpay.com",
    "xn--eterdelta-m75d.com",
    "linksmartcontract.com",
    "myetherwalletaccess.com",
    "myetherwalletcheck.com",
    "myetherwalletcheck.info",
    "myetherwalletconf.com",
    "myetherwalleteal.com",
    "myetherwalletec.com",
    "myetherwalletgeth.com",
    "myetherwalletmetamask.com",
    "myetherwalletmm.com",
    "myetherwalletmy.com",
    "myetherwalletnh.com",
    "myetherwalletnod.com",
    "myetherwalletrr.com",
    "myetherwalletrty.com",
    "myetherwalletsec.com",
    "myetherwalletsecure.com",
    "myetherwalletutc.com",
    "myetherwalletver.info",
    "myetherwalletview.com",
    "myetherwalletview.info",
    "myetherwalletvrf.com",
    "myetherwalletmist.com",
    "myetherwalletext.com",
    "myetherwalletjson.com",
    "mettalpay.com",
    "bricklblock.io",
    "bittrexy.com",
    "utrust.so",
    "myethierwallet.org",
    "metallpay.com",
    "kraken-wallet.com",
    "dmarkt.io",
    "etherdeltla.com",
    "unlversa.io",
    "universa.sale",
    "mercuryprotocol.live",
    "ripiocredlt.network",
    "myetlherwa11et.com",
    "dentacoin.in",
    "rdrtg.com",
    "myetherwallet.com.rdrgh.com",
    "rdrgh.com",
    "ripiocreditnetwork.co",
    "riaden.network",
    "hydrominer.biz",
    "rdrblock.com",
    "reqest.network",
    "senstoken.com",
    "myetherwallat.services",
    "ripiocredit.net",
    "xn--metherwallet-c06f.com",
    "ico.ripiocredits.com",
    "ripiocredits.com",
    "raidens.network",
    "artoken.co",
    "myetherwalletlgn.com",
    "etherblog.click",
    "stormtoken.site",
    "httpmyetherwallet.com",
    "myetherwalletverify.com",
    "byzantiumfork.com",
    "myetherwallet.com.byzantiumfork.com",
    "www-myethervvallet.com",
    "ether24.info",
    "block-v.io",
    "bittrex.cash",
    "shapishift.io",
    "ripiocerdit.network",
    "rnyetherwa11et.com",
    "claimether.com",
    "enigmatokensale.com",
    "ethereum-org.com",
    "mvetnerwallet.com",
    "myctherwallet.com",
    "myetherwaltet.com",
    "myetherwatlet.com",
    "privatix.me",
    "myetherwalletcnf.com",
    "myetherwalletver.com",
    "privatix.top",
    "privatix.pro",
    "stormtoken.cc",
    "raiden.online",
    "stormstoken.com",
    "myetereumwallet.com",
    "stormtokens.net",
    "myetherwalletconf.info",
    "storrntoken.com",
    "worldofbattles.io",
    "ico.worldofbattles.io",
    "privatix.live",
    "riden.network",
    "raidan.network",
    "ralden.network",
    "mymyetherwallet.com",
    "myetherwallets.net",
    "myetherwalletverify.info",
    "stormxtoken.com",
    "myethereum-wallet.com",
    "myetherwallet-forkprep.pagedemo.co",
    "myetnerwailet.com",
    "www-mvetherwallet.com",
    "etheirdelta.com",
    "myetherwalletiu.com",
    "myetherwaiiett.com",
    "xn--mytherwalet-cbb87i.com",
    "xn--myethrwallet-ivb.co",
    "xn--myeterwallet-f1b.com",
    "myehterwaliet.com",
    "omegaone.co",
    "myetherwaiietw.com",
    "slack.com.ru",
    "polkodot.network",
    "request-network.net",
    "requestnetwork.live",
    "binancie.com",
    "first-eth.info",
    "myewerthwalliet.com",
    "enjincoin.pw",
    "xn--bitrex-k17b.com",
    "alrswap.io",
    "www-request.network",
    "myetnenwallet.com",
    "www-enigma.co",
    "cryptoinsidenews.com",
    "air-swap.tech",
    "launch.airswap.cc",
    "airswap.cc",
    "airswaptoken.com",
    "launch.airswap.in",
    "airswap.in",
    "security-steemit.com.mx",
    "blockchalnwallet.com",
    "blodkchainwallet.com",
    "blodkchaln.com",
    "myethereumwaiiet.com",
    "myethereumwaliet.com",
    "myethereumwalilet.com",
    "myetherswailet.com",
    "myetherswaliet.com",
    "myetherswalilet.com",
    "myetherwalilett.com",
    "myetherwalletl.com",
    "myetherwalletww.com",
    "myethereunwallet.com",
    "myethereumwallct.com",
    "myetherwaiieti.com",
    "myetherwaiiete.com",
    "upfirng.com",
    "paypie.net",
    "paypie.tech",
    "soam.co",
    "myetherwaiict.com",
    "numerai-token.com",
    "www-bankera.com",
    "vvanchain.org",
    "omisegoairdrop.com",
    "xn--enjncoin-41a.io",
    "suncontract.su",
    "myetherwaiietr.com",
    "shapeshiff.io",
    "warchain.org",
    "myethwallett.com",
    "myethervvaliet.com",
    "wanchains.org",
    "etherparty.in",
    "enjincoin.me",
    "etiam.io",
    "invest.smartlands.tech",
    "smartlands.tech",
    "enijncoin.io",
    "wanchain.network",
    "nimiq.su",
    "enjincoin.sale",
    "tenxwallet.io",
    "golem-network.net",
    "myyethwallet.ml",
    "mywetherwailiet.com",
    "omg-omise.com",
    "district0x.tech",
    "centra-token.com",
    "etherdetla.com",
    "etnerparty.io",
    "etherdelta.su",
    "myetherwallett.neocities.org",
    "myetherwallet-secure.com",
    "myethereumwalletntw.info",
    "real-markets.io",
    "wallet-ethereum.org",
    "request-network.com",
    "shapeshifth.io",
    "shiapeshift.in",
    "coin.red-puise.com",
    "ibittreix.com",
    "coinkbase.com",
    "cindicator.pro",
    "myetherwallet.com.ailogin.me",
    "eventchain.co",
    "kinkik.in",
    "myetherumwalletview.com",
    "protostokenhub.com",
    "coinrbase.com",
    "myetherwalletlogin.com",
    "omisegotoken.com",
    "myethereumwalletntw.com",
    "reall.markets",
    "cobinhood.org",
    "cobinhood.io",
    "happy-coin.org",
    "bitfinex.com.co",
    "bitfienex.com",
    "iconn.foundation",
    "centra.vip",
    "smartcontract.live",
    "air-token.com",
    "centra.credit",
    "myetherwallet-singin.com",
    "smartcontractlink.com",
    "shapesshift.io",
    "0xtoken.io",
    "augurproject.co",
    "ethereumus.one",
    "myetherumwalet.com",
    "myetherwalletsignin.com",
    "change-bank.org",
    "charge-bank.com",
    "myetherwalletsingin.com",
    "myetherwalletcontract.com",
    "change-bank.io",
    "chainlink.tech",
    "myetherwallet-confirm.com",
    "tokensale.kybernet.network",
    "kybernet.network",
    "kyberr.network",
    "kybernetwork.io",
    "myetherwalletconfirm.com",
    "kvnuke.github.io",
    "kin.kikpro.co",
    "myethereumwallet.co.uk",
    "tokensale-kyber.network",
    "kyber-network.co",
    "tokensale.kyber-network.co",
    "pyro0.github.io",
    "tokensale.kyber.digital",
    "kyber.digital",
    "omise-go.me",
    "my.etherwallet.com.de",
    "bepartof.change-bank.co",
    "change-bank.co",
    "enigma-tokens.co",
    "coinbase.com.eslogin.co",
    "xn--bittrx-mva.com",
    "ethrdelta.github.io",
    "etherdellta.com",
    "ico-nexus.social",
    "red-pulse.tech",
    "bitj0b.io",
    "xn--bttrex-bwa.com",
    "kin-klk.com",
    "kin-crowdsale.com",
    "ethedelta.com",
    "coindash.su",
    "myethwallet.co.uk",
    "swarm.credit",
    "myethereumwallet.uk",
    "iconexu.social",
    "wanchain.co",
    "enigrna.co",
    "linknetwork.co",
    "qtum-token.com",
    "omisego.com.co",
    "rivetzintl.org",
    "etherdelta.one",
    "the-ether.pro",
    "etherdelta.gitnub.io",
    "kirkik.com",
    "monetha.ltd",
    "vlberate.io",
    "ethereumwallet-kr.info",
    "omise-go.org",
    "iconexus.social",
    "bittirrex.com",
    "aventus.pro",
    "atlant.solutions",
    "aventus.group",
    "metamak.io",
    "omise.com.co",
    "herotokens.io",
    "starbase.pro",
    "etherdelta.githulb.io",
    "herotoken.co",
    "kinico.net",
    "dmarket.ltd",
    "etherdelta.gilthub.io",
    "golem-network.com",
    "etnerscan.io",
    "bllttriex.com",
    "monetha.me",
    "monetha.co",
    "monetha-crowdsale.com",
    "starbase.tech",
    "aventus-crowdsale.com",
    "shapeshift.pro",
    "bllttrex.com",
    "kickico.co",
    "statustoken.im",
    "bilttrex.com",
    "tenxpay.io",
    "bittrex.ltd",
    "metalpay.im",
    "aragon.im",
    "coindash.tech",
    "decentraland.tech",
    "decentraland.pro",
    "status-token.com",
    "bittrex.cam",
    "enigmatoken.com",
    "unocoin.company",
    "unocoin.fund",
    "0xproject.io",
    "0xtoken.com",
    "numerai.tech",
    "decentraiand.org",
    "blockcrein.info",
    "blockchealn.info",
    "bllookchain.info",
    "blockcbhain.info",
    "myetherwallet.com.ethpromonodes.com",
    "mettamask.io",
    "tokenswap.org",
    "netherum.com",
    "etherexx.org",
    "etherume.io",
    "ethereum.plus",
    "ehtereum.org",
    "etereurm.org",
    "etheream.com",
    "ethererum.org",
    "ethereum.io",
    "etherdelta-glthub.com",
    "cryptoalliance.herokuapp.com",
    "bitspark2.com",
    "indorsetoken.com",
    "iconexus.tk",
    "iconexus.ml",
    "iconexus.ga",
    "iconexus.cf",
    "etherwallet.online",
    "wallet-ethereum.net",
    "bitsdigit.com",
    "etherswap.org",
    "eos.ac",
    "uasfwallet.com",
    "ziber.io",
    "multiply-ethereum.info",
    "bittrex.comze.com",
    "karbon.vacau.com",
    "etherdelta.gitlhub.io",
    "etherdelta.glthub.io",
    "digitaldevelopersfund.vacau.com",
    "district-0x.io",
    "coin-dash.com",
    "coindash.ru",
    "district0x.net",
    "aragonproject.io",
    "coin-wallet.info",
    "coinswallet.info",
    "contribute-status.im",
    "ether-api.com",
    "ether-wall.com",
    "mycoinwallet.net",
    "ethereumchamber.com",
    "ethereumchamber.net",
    "ethereumchest.com",
    "ethewallet.com",
    "myetherwallet.com.vc",
    "myetherwallet.com.pe",
    "myetherwallet.us.com",
    "myetherwallet.com.u0387831.cp.regruhosting.ru",
    "myethereumwallet.su",
    "myetherweb.com.de",
    "myetherieumwallet.com",
    "myetehrwallet.com",
    "myeterwalet.com",
    "myetherwaiiet.com",
    "myetherwallet.info",
    "myetherwallet.ch",
    "myetherwallet.om",
    "myethervallet.com",
    "myetherwallet.com.cm",
    "myetherwallet.com.co",
    "myetherwallet.com.de",
    "myetherwallet.com.gl",
    "myetherwallet.com.im",
    "myetherwallet.com.ua",
    "secure-myetherwallet.com",
    "update-myetherwallet.com",
    "wwwmyetherwallet.com",
    "myeatherwallet.com",
    "myetharwallet.com",
    "myelherwallel.com",
    "myetherwaillet.com",
    "myetherwaliet.com",
    "myetherwallel.com",
    "myetherwallet.cam",
    "myetherwallet.cc",
    "myetherwallet.co",
    "myetherwallet.cm",
    "myetherwallet.cz",
    "myetherwallet.org",
    "myetherwallet.tech",
    "myetherwallet.top",
    "myetherwallet.net",
    "myetherwallet.ru.com",
    "myetherwallet.com.ru",
    "metherwallet.com",
    "myetrerwallet.com",
    "myetlerwallet.com",
    "myethterwallet.com",
    "myethwallet.io",
    "myethterwallet.co",
    "myehterwallet.co",
    "myaetherwallet.com",
    "myetthterwallet.com",
    "myetherwallet.one",
    "myelterwallet.com",
    "myetherwallet.gdn",
    "myetherwallt.com",
    "myeterwallet.com",
    "myeteherwallet.com",
    "myethearwailet.com",
    "myetherwallelt.com",
    "myetherwallett.com",
    "etherwallet.org",
    "myetherewallet.com",
    "myeherwallet.com",
    "myethcrwallet.com",
    "myetherwallet.link",
    "myetherwallets.com",
    "myethearwaillet.com",
    "myethearwallet.com",
    "myetherawllet.com",
    "myethereallet.com",
    "myetherswallet.com",
    "myetherwalet.com",
    "myetherwaller.com",
    "myetherwalliet.com",
    "myetherwllet.com",
    "etherwallet.io",
    "myetherwallet.ca",
    "myetherwallet.me",
    "myetherwallet.ru",
    "myetherwallet.xyz",
    "myetherwallte.com",
    "myethirwallet.com",
    "myethrewallet.com",
    "etherwallet.net",
    "maetherwallet.com",
    "meyetherwallet.com",
    "my.ether-wallet.pw",
    "myehterwallet.com",
    "myeitherwallet.com",
    "myelherwallet.com",
    "myeltherwallet.com",
    "myerherwallet.com",
    "myethearwalet.com",
    "myetherewalle.com",
    "myethervvallet.com",
    "myetherwallent.com",
    "myetherwallet.fm",
    "myetherwalllet.com",
    "myetherwalltet.com",
    "myetherwollet.com",
    "myetlherwalet.com",
    "myetlherwallet.com",
    "rnyetherwallet.com",
    "etherclassicwallet.com",
    "omg-omise.co",
    "omise-go.com",
    "omise-go.net",
    "omise-omg.com",
    "omise-go.io",
    "tenx-tech.com",
    "bitclaive.com",
    "tokensale-tenx.tech",
    "ubiqcoin.org",
    "metamask.com",
    "ethtrade.io",
    "myetcwallet.com",
    "account-kigo.net",
    "bitcoin-wallet.net",
    "blocklichan.info",
    "bloclkicihan.info",
    "coindash.ml",
    "eos-bonus.com",
    "eos-io.info",
    "ether-wallet.net",
    "ethereum-wallet.info",
    "ethereum-wallet.net",
    "ethereumchest.net",
    "reservations-kigo.net",
    "reservations-lodgix.com",
    "secure-liverez.com",
    "secure-onerooftop.com",
    "settings-liverez.com",
    "software-liverez.com",
    "software-lodgix.com",
    "unhackableetherwallets.com",
    "www-myetherwallet.com",
    "etherwallet.co.za",
    "etherwalletchain.com",
    "etherwallets.net",
    "etherwallets.nl",
    "my-ethwallet.com",
    "my.ether-wallet.co",
    "myetherwallet.com.am",
    "myetherwallet.com.ht",
    "myetherwalletcom.com",
    "myehterwailet.com",
    "xn--myetherwalle-xoc.com",
    "xn--myetherwalle-44i.com",
    "xn--myetherwalle-xhk.com",
    "xn--myetherwallt-cfb.com",
    "xn--myetherwallt-6tb.com",
    "xn--myetherwallt-xub.com",
    "xn--myetherwallt-ovb.com",
    "xn--myetherwallt-fwb.com",
    "xn--myetherwallt-5wb.com",
    "xn--myetherwallt-jzi.com",
    "xn--myetherwallt-2ck.com",
    "xn--myetherwallt-lok.com",
    "xn--myetherwallt-lsl.com",
    "xn--myetherwallt-ce6f.com",
    "xn--myetherwalet-mcc.com",
    "xn--myetherwalet-xhf.com",
    "xn--myetherwalet-lcc.com",
    "xn--myetherwaet-15ba.com",
    "xn--myetherwalet-whf.com",
    "xn--myetherwaet-v2ea.com",
    "xn--myetherwllet-59a.com",
    "xn--myetherwllet-jbb.com",
    "xn--myetherwllet-wbb.com",
    "xn--myetherwllet-9bb.com",
    "xn--myetherwllet-ncb.com",
    "xn--myetherwllet-0cb.com",
    "xn--myetherwllet-5nb.com",
    "xn--myetherwllet-ktd.com",
    "xn--myetherwllet-mre.com",
    "xn--myetherwllet-76e.com",
    "xn--myetherwllet-o0l.com",
    "xn--myetherwllet-c45f.com",
    "xn--myetherallet-ejn.com",
    "xn--myethewallet-4nf.com",
    "xn--myethewallet-iof.com",
    "xn--myethewallet-mpf.com",
    "xn--myethewallet-6bk.com",
    "xn--myethewallet-i31f.com",
    "xn--myethrwallet-feb.com",
    "xn--myethrwallt-fbbf.com",
    "xn--myethrwallet-seb.com",
    "xn--myethrwallt-rbbf.com",
    "xn--myethrwallet-5eb.com",
    "xn--myethrwallt-3bbf.com",
    "xn--myethrwallet-0tb.com",
    "xn--myethrwallt-tpbf.com",
    "xn--myethrwallet-rub.com",
    "xn--myethrwallt-iqbf.com",
    "xn--myethrwallet-ivb.com",
    "xn--myethrwallt-6qbf.com",
    "xn--myethrwallet-8vb.com",
    "xn--myethrwallt-vrbf.com",
    "xn--myethrwallet-zwb.com",
    "xn--myethrwallt-ksbf.com",
    "xn--myethrwallet-dzi.com",
    "xn--myethrwallt-wbif.com",
    "xn--myethrwallet-wck.com",
    "xn--myethrwallt-skjf.com",
    "xn--myethrwallet-fok.com",
    "xn--myethrwallt-fvjf.com",
    "xn--myethrwallet-fsl.com",
    "xn--myethrwallt-fwkf.com",
    "xn--myethrwallet-5d6f.com",
    "xn--myethrwallt-319ef.com",
    "xn--myeterwallet-ufk.com",
    "xn--myeterwallet-nrl.com",
    "xn--myeterwallet-von.com",
    "xn--myeterwallet-jl6c.com",
    "xn--myeherwallet-ooc.com",
    "xn--myeherwalle-6hci.com",
    "xn--myeherwallet-v4i.com",
    "xn--myeherwalle-zgii.com",
    "xn--myeherwallet-ohk.com",
    "xn--myeherwalle-6oji.com",
    "xn--mytherwallet-ceb.com",
    "xn--mythrwallet-cbbc.com",
    "xn--mythrwallt-c7acf.com",
    "xn--mytherwallet-peb.com",
    "xn--mythrwallet-obbc.com",
    "xn--mythrwallt-n7acf.com",
    "xn--mytherwallet-2eb.com",
    "xn--mythrwallet-0bbc.com",
    "xn--mythrwallt-y7acf.com",
    "xn--mytherwallet-xtb.com",
    "xn--mythrwallet-qpbc.com",
    "xn--mythrwallt-jlbcf.com",
    "xn--mytherwallet-oub.com",
    "xn--mythrwallet-fqbc.com",
    "xn--mythrwallt-5lbcf.com",
    "xn--mythrwallet-3qbc.com",
    "xn--mythrwallt-smbcf.com",
    "xn--mytherwallet-5vb.com",
    "xn--mythrwallet-srbc.com",
    "xn--mythrwallt-fnbcf.com",
    "xn--mytherwallet-wwb.com",
    "xn--mythrwallet-hsbc.com",
    "xn--mythrwallt-1nbcf.com",
    "xn--mytherwallet-9yi.com",
    "xn--mythrwallet-tbic.com",
    "xn--mythrwallt-dnhcf.com",
    "xn--mytherwallet-tck.com",
    "xn--mythrwallet-pkjc.com",
    "xn--mythrwallt-lsicf.com",
    "xn--mytherwallet-cok.com",
    "xn--mythrwallet-cvjc.com",
    "xn--mythrwallt-c2icf.com",
    "xn--mytherwallet-csl.com",
    "xn--mythrwallet-cwkc.com",
    "xn--mythrwallt-c0jcf.com",
    "xn--mytherwallet-2d6f.com",
    "xn--mythrwallet-019ec.com",
    "xn--mythrwallt-yq3ecf.com",
    "xn--metherwallet-qlb.com",
    "xn--metherwallet-1uf.com",
    "xn--metherwallet-iyi.com",
    "xn--metherwallet-zhk.com",
    "xn--metherwallet-3ml.com",
    "xn--mytherwallet-fvb.com",
    "xn--myetherwallt-7db.com",
    "xn--myetherwallt-leb.com",
    "xn--myetherwallt-yeb.com",
    "xn--yetherwallet-vjf.com",
    "xn--yetherwallet-dfk.com",
    "xn--yetherwallet-1t1f.com",
    "xn--yetherwallet-634f.com",
    "xn--myeherwallet-fpc.com",
    "xn--myethewallt-crb.com",
    "xn--metherwallet-1vc.com",
    "xn--myeherwallt-kbb8039g.com",
    "xn--myeherwallet-vk5f.com",
    "xn--yethewallet-iw8ejl.com",
    "xn--bittrx-th8b.com",
    "xn--polniex-n0a.com",
    "thekey.vin",
    "thekey-vip.com",
    "digitexftures.com",
    "ethzero-wallet.org",
    "zeepln.io",
    "wepowers.network",
    "wepower.vision",
    "seele.promo",
    "seele-ico.eu",
    "seele-ico.pro",
    "syncfab.tech",
    "tokensale.syncfab.tech",
    "havven.promo",
    "havven-ico.com",
    "havven-ico.eu",
    "hawen.io",
    "havven.xyz",
    "tomo-coin.io",
    "tomocoln.io",
    "docai.science",
    "tomocoin.network",
    "celsius-ico.network",
    "celsiuss.network",
    "coti.cf",
    "xn--mercadobtcon-mfbd.com",
    "quantstump.com",
    "quantstampcoin.com",
    "quantistamp.com",
    "electrum.com",
    "tronfoundation.us",
    "dav-network.io",
    "pyapay.co",
    "daostack-token.io",
    "icolist.sale",
    "shivom.sale",
    "daostack.onuniverse.com",
    "dav.icocrowdsale.io",
    "myethcrwallet-f.com",
    "myethcrwallet-g.com",
    "myetherewallet.cf",
    "myetherwallet-i.com",
    "myetherwalletc.org",
    "myeterwallct-p.com",
    "myethcrwallct-a.com",
    "myethcrwallet-b.com",
    "myethcrwallet-c.com",
    "myethcrwallet-d.com",
    "myethervvallet.win",
    "myetherwallat.date",
    "myetherwallet.accountant",
    "quarkchain.live",
    "verasiity.co",
    "monerozero.trade",
    "dav.systems",
    "eth.mediumblog.org",
    "ethe.mediumblog.top",
    "claim.ether33.online",
    "any.ether33.online",
    "mediumblog.org",
    "swswd.ether33.online",
    "swdwd.ethers444.online",
    "eth22.mediumblog.top",
    "etoroglobal.com",
    "bcrypto.club",
    "airdrop-bitnational.com",
    "wasabibitcoinwallet.org",
    "xeniumx.com",
    "idex-claim.su",
    "fulcrum.click",
    "bitbank.guru",
    "bitbank.land",
    "fulcrum.run",
    "curve.fm",
    "curve.frl",
    "curve.fyi",
    "curves.fi",
    "curves.exchange",
    "xn--ledgr-9za.com",
    "xn--ledgr-esa.com",
    "xn--leder-b3b.com",
    "xn--ldger-j0a.com",
    "xn--ledgr-7ra.com",
    "xn--ldgr-bpac.com",
    "xn--ledr-xva3d.com",
    "xn--leder-b2a.com",
    "xn--leder-k0b.com",
    "xn--edger-i6a.com",
    "xn--edger-j7a.com",
    "xn--ldger-bsa.app",
    "xn--edger-u6a.com",
    "xn--ledger-bla.com",
    "xn--edger-mnb.com",
    "xn--edger-dqb.com",
    "xn--edger-0ec.com",
    "xn--edger-cj1b.com",
    "xn--edger-oj1b.com",
    "xn--edger-dk1b.com",
    "xn--edger-fe3s.com",
    "xn--edger-sl3s.com",
    "xn--ldger-4ra.com",
    "xn--ldger-hsa.com",
    "xn--ldger-iza.com",
    "xn--ldger-v0a.com",
    "xn--ldger-c6b.com",
    "xn--ldger-bic.com",
    "xn--ldger-vd1b.com",
    "xn--ldger-ke1b.com",
    "xn--ldger-c61b.com",
    "xn--ldger-061b.com",
    "xn--ldger-p71b.com",
    "xn--ldger-we9c.com",
    "xn--leger-6ya.com",
    "xn--leger-9kb.com",
    "xn--leger-tbc.com",
    "xn--leger-6b1b.com",
    "xn--leger-vc1b.com",
    "xn--leger-ol3s.com",
    "xn--leder-m1a.com",
    "xn--leder-nf1b.com",
    "xn--ledgr-ksa.com",
    "xn--ledgr-lza.com",
    "xn--ledgr-m0a.com",
    "xn--ledgr-25b.com",
    "xn--ledgr-8cc.com",
    "xn--ledgr-md1b.com",
    "xn--ledgr-be1b.com",
    "xn--ledgr-ze1b.com",
    "xn--ledgr-f61b.com",
    "xn--ledgr-361b.com",
    "xn--ledgr-s71b.com",
    "xn--ledgr-ze9c.com",
    "xn--ledge-57b.com",
    "xn--ledge-gjc.com",
    "xn--ledge-np1b.com",
    "xn--ledge-cq1b.com",
    "xn--ledge-gm3s.com",
    "xn--ledge-6o3s.com",
    "xn--ldgr-vva2366b.com",
    "xn--ldgr-xva7266b.com",
    "xn--lder-vva5d.com",
    "xn--ldr-krab3d.com",
    "xn--ledqr-9za.com",
    "ledgersupport.io",
    "loldevs.com",
    "curve.si",
    "curve.so",
    "curvefi.io",
    "curwe.fi",
    "lecdger.com",
    "ledcger.com",
    "ledqer.cc",
    "ledgerwalletrestore.com",
    "ledlqer.com",
    "labger.com",
    "xn--edgr-z1a5736b.com",
    "xn--ledger-mcb.com",
    "ledger.com-device.id73457.app",
    "ledger.com-device.id45663.app",
    "ledger.com-device.id46267.app",
    "xn--ledr-dxa0756b.com",
    "ledger-live.org",
    "ledger.com.634644.app",
    "ledger.com.837729.app",
    "ledger.com.565333.app",
    "ledger.com.453455.app",
    "ledger.com.342344.app",
    "ledger.com.device.id.837729.app",
    "ledger.com.device.id.634644.app",
    "ledger.com.device.id.565333.app",
    "ledger.com.device.id.453455.app",
    "ledger.com.device.id.342344.app",
    "ledger.com.device.id.756728.app",
    "ledger.com.device.id.727783.app",
    "ledger.com.device.id.657377.app",
    "ledger.com.device.id.893900.app",
    "ledger.com.device.id.745583.app",
    "ledger.com.device.id.688338.app",
    "ledger.com.device.id.883882.app",
    "ledger.com.device-u23-verification.app",
    "ledger.com.device-e72-verification.app",
    "ledger.com.verification-login-s61.app",
    "ledger.com.acc-verification-login.app",
    "ledger.com.device.id.7537472.app",
    "ledger.com.hardware.id.54656346.app",
    "ledger.com.device.id.6567288.app",
    "ledger.com.hardware.id.953781832.app",
    "xn--ldr-qsa2998aca.com",
    "ledger.com-settings.device-id-45682.app",
    "xn--lede-dxa93a.com",
    "xn--ledr-xva5e.com",
    "ledger.com-settings.device-id-68399.app",
    "xn--lder-vva7e.com",
    "xn--eder-mxa9k.com",
    "ledger.com134678976581.info",
    "ledger.com.login-wallet.app",
    "ledger.com.verification-login.app",
    "ledger.com-login-authorization.app",
    "ledger.com-login-verification.app",
    "balanscer.exchange",
    "xn--ldr-krab5e.com",
    "xn--ledr-nxa8556b.com",
    "ledger.com.login-account.app",
    "ledger.com.wallet-login.app",
    "ledger.com.login-verification.app",
    "ledger.com-login-account.app",
    "ledger.com-login-activity.app",
    "xn--lder-cxa8656b.com",
    "ledger.com1628.support",
    "ledger.com17266548295643.info",
    "ledger.com-login-wallet.app",
    "ledger.com-login-secure.app",
    "ledger.com-activity-login.app",
    "ledger.com-account-login.app",
    "ledger.com-authorization-login.app",
    "ledger.com-verification-login.app",
    "ledger.com1927572.info",
    "ledger.com1829582.info",
    "ledger.com401.support",
    "ledger.com172.support",
    "ledgdr.com",
    "lelger.com",
    "www-ledger.com",
    "ledgerrecovery.com",
    "ledger.com-viewaccount.com",
    "walletconnects.org",
    "walletconnect.com.se",
    "tornadocash.org",
    "login.xn--bockchaln-vpb.com",
    "www.lblhblockchain.com",
    "walletconnecl.org",
    "walletsconnect.host",
    "walletsconnectapp.com",
    "walletsconnect.dev",
    "walletconnectlive.vip",
    "walletsynchronize.live",
    "dropelon.io",
    "givemusk.space",
    "muskx.digital",
    "muskfree.com",
    "muskx.io",
    "uni2021.com",
    "uniaward.net",
    "unipromo.org",
    "unireward.org",
    "uniswap.supply",
    "tlp-invest.com",
    "coinwoz.com",
    "btcdire.com",
    "btcshade.com",
    "lemmexrp.com",
    "smellbit.com",
    "uniwsap.io",
    "uniswnap.io",
    "uniwsap.com",
    "uniswnap.com",
    "app.uniswap.airdrop-token-holder.com",
    "app.uniswap.token-protocol-airdrop.com",
    "uniswap-v3.org",
    "uniswapv2node.net",
    "uniswapv2v1.network",
    "lirbit.com",
    "peetdecentralized.finance",
    "coinmik.com",
    "bitzau.com",
    "yfinew.com",
    "metamaskrestores.link",
    "hohbit.com",
    "metamasksite.live",
    "metamaskwallet.help",
    "imtokenpay.xyz",
    "imtoken.tours",
    "imtoken-1.com",
    "imtokenusa.top",
    "intoken.top",
    "imtokensdt.xyz",
    "imtokeng.com",
    "imtoken-ic.com",
    "imtoken-login.com",
    "imtoken.show",
    "imtokeng.xyz",
    "imtoken.express",
    "imtoken.gold",
    "imtokenh.net",
    "imtoken.zone",
    "imtokens.net",
    "imtoken.la",
    "imtoken.com.cn",
    "www.im-token.cc",
    "imtoken.cn",
    "www.im-token.me",
    "tokenim.com.cn",
    "wallet3.imtokens.live",
    "tokeni.cn",
    "polkastarter.gr.com",
    "polkastarter.world",
    "polkastarter.ltd",
    "polkaslarter.com",
    "polkastarter.cn.com",
    "atomicwalletwebs.net",
    "myeflherwallet.com",
    "pancakeswap.fit",
    "trustwalletts.net",
    "wallectconect.xyz",
    "walletauthentication.org",
    "walletauthenticator.org",
    "wallets-reauthorization.com",
    "walletsecure.app",
    "walletsecureonline.com",
    "walletsecureonline.org",
    "polkastarter.to",
    "polkaastarter.com",
    "polkastarfer.com",
    "polkastarteido.com",
    "polkastarter.app",
    "polkastarter.com.co",
    "polkastarter.community",
    "polkastarter.fun",
    "polkastarter.group",
    "polkastarter.llc",
    "polkastarter.one",
    "polkastarter.trade",
    "polkatsarter.com",
    "polkastarterbonus.live",
    "polkastarterconnect.com",
    "polkastarters.sale",
    "polkastarter.cash",
    "polkastarterapp.com",
    "polka-starter.info",
    "polkastarter.tools",
    "polkarstarter.com",
    "polkalstarter.com",
    "polka-starters.com",
    "polkastarter.de.com",
    "polkasrtarter.com",
    "beefy.financial",
    "fortes.life",
    "mooncakebsc.com",
    "polkastartrer.com",
    "polkastarter.fit",
    "polkastarter.codes",
    "polkastarter.gdn",
    "polkastarter.mom",
    "polllkastarter.com",
    "polkastarter.tel",
    "polkastarter.contact",
    "polkastarter.party",
    "polkastarter.legal",
    "polkastarter.solar",
    "polkastarter.solutions",
    "polkastarter.social",
    "polkastarter.domains",
    "polkastarter.stream",
    "polkastarter.events",
    "polkastarter.watch",
    "polkastarter.bar",
    "polkastarter.media",
    "polkastarter.monster",
    "polkastarter.quest",
    "polkastarter.camp",
    "polkastarter.fyi",
    "polkastarter.futbol",
    "polkastarter.gold",
    "polkastarter.study",
    "polkastarter.com.es",
    "orion-money.sale",
    "polkastarters.one",
    "polkastarter.rehab",
    "gnosis-safe.org",
    "gnosis-airdrop.live",
    "abchange.io",
    "polkasfarter.com",
    "polkastarter.cam",
    "polkastarter.direct",
    "polkastarter.care",
    "polkastarter.directory",
    "polkastarter.express",
    "polkastarter.supply",
    "polkastarter.lighting",
    "polkastarter.auction",
    "polkastarter.cards",
    "polkastarter.computer",
    "polkastarter.sa.com",
    "polkastartre.com",
    "polkastrarter.com",
    "polkastarter.cool",
    "polkastarter.cyou",
    "polkastarter.expert",
    "polkastarter.team",
    "polkastorter.com",
    "polkastarter.homes",
    "polkastarter.farm",
    "polkastarter.wtf",
    "synapseprotocolmigration.com",
    "convexfinance.org",
    "metalmask.me",
    "walletaccesspass.online",
    "dydxexchange.net",
    "aaxswap.com",
    "reposwap.co",
    "eslab.io",
    "bscspin.com",
    "mellobsc.com",
    "chromiacoin.io",
    "wxfi.io",
    "immcoin.io",
    "punketh.io",
    "usdtw.info",
    "xch5.io",
    "dydex.io",
    "velochain.io",
    "charpunk.com",
    "test.com",
    "yui.finance",
    "pupdogeclaim.com",
    "bsctoken.io",
    "payou.finance",
    "alpacaairdrop.live",
    "deapy.org",
    "beezex.net",
    "alicedrop.com",
    "supdao.com",
    "airstack.net",
    "twtloan.com",
    "bscmello.io",
    "key7.net",
    "kryoss.net",
    "bioswap.finance",
    "ff9.io",
    "safemoon-dividend.com",
    "sfar.io",
    "optimism.trade",
    "cowswap.sale",
    "metamask-wallet-security.web.app",
    "lyra.sale",
    "racketpool.com",
    "colabration.cc",
    "revokecash.com",
    "thor.fund",
    "dogaml.net",
    "acros.to",
    "trezor.run",
    "trezor.us",
    "satoshilabs.co",
    "trezornews.io",
    "suite.trezor.run",
    "trezorwallet.org",
    "dapp-fix.net"
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/phishing-warning>eth-phishing-detect",file:"node_modules\\eth-phishing-detect\\src\\config.json",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-phishing-detect\\src\\detector.js", {"fast-levenshtein":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-levenshtein\\levenshtein.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-phishing-detect%5Csrc%5Cdetector.js
      return function (require, module, exports) {
const levenshtein = require('fast-levenshtein')
const DEFAULT_TOLERANCE = 3

class PhishingDetector {

  /**
   * Legacy phishing detector configuration.
   *
   * @typedef {object} LegacyPhishingDetectorConfiguration
   * @property {string[]} [whitelist] - Origins that should not be blocked.
   * @property {string[]} [blacklist] - Origins to block.
   * @property {string[]} [fuzzylist] - Origins of common phishing targets.
   * @property {number} [tolerance] - Tolerance to use for the fuzzylist levenshtein match.
   */

  /**
   * A configuration object for phishing detection.
   *
   * @typedef {object} PhishingDetectorConfiguration
   * @property {string[]} [allowlist] - Origins that should not be blocked.
   * @property {string[]} [blocklist] - Origins to block.
   * @property {string[]} [fuzzylist] - Origins of common phishing targets.
   * @property {string} name - The name of this configuration. Used to explain to users why a site is being blocked.
   * @property {number} [tolerance] - Tolerance to use for the fuzzylist levenshtein match.
   * @property {number} version - The current version of the configuration.
   */

  /**
   * Construct a phishing detector, which can check whether origins are known
   * to be malicious or similar to common phishing targets.
   *
   * A list of configurations is accepted. Each origin checked is processed
   * using each configuration in sequence, so the order defines which
   * configurations take precedence.
   *
   * @param {LegacyPhishingDetectorConfiguration | PhishingDetectorConfiguration[]} opts - Phishing detection options
   */
  constructor (opts) {
    // recommended configuration
    if (Array.isArray(opts)) {
      this.configs = processConfigs(opts)
      this.legacyConfig = false
    // legacy configuration
    } else {
      this.configs = [{
        allowlist: processDomainList(opts.whitelist || []),
        blocklist: processDomainList(opts.blacklist || []),
        fuzzylist: processDomainList(opts.fuzzylist || []),
        tolerance: ('tolerance' in opts) ? opts.tolerance : DEFAULT_TOLERANCE
      }]
      this.legacyConfig = true
    }
  }

  check(domain) {
    const result = this._check(domain)

    if (this.legacyConfig) {
      let legacyType = result.type;
      if (legacyType === 'allowlist') {
        legacyType = 'whitelist'
      } else if (legacyType === 'blocklist') {
        legacyType = 'blacklist'
      }
      return {
        match: result.match,
        result: result.result,
        type: legacyType,
      }
    }
    return result
  }

  _check (domain) {
    let fqdn = domain.substring(domain.length - 1) === "."
      ? domain.slice(0, -1)
      : domain;

    const source = domainToParts(fqdn)

    for (const { allowlist, name, version } of this.configs) {
      // if source matches whitelist domain (or subdomain thereof), PASS
      const whitelistMatch = matchPartsAgainstList(source, allowlist)
      if (whitelistMatch) return { name, result: false, type: 'allowlist', version }
    }

    for (const { blocklist, fuzzylist, name, tolerance, version } of this.configs) {
      // if source matches blacklist domain (or subdomain thereof), FAIL
      const blacklistMatch = matchPartsAgainstList(source, blocklist)
      if (blacklistMatch) return { name, result: true, type: 'blocklist', version }

      if (tolerance > 0) {
        // check if near-match of whitelist domain, FAIL
        let fuzzyForm = domainPartsToFuzzyForm(source)
        // strip www
        fuzzyForm = fuzzyForm.replace('www.', '')
        // check against fuzzylist
        const levenshteinMatched = fuzzylist.find((targetParts) => {
          const fuzzyTarget = domainPartsToFuzzyForm(targetParts)
          const distance = levenshtein.get(fuzzyForm, fuzzyTarget)
          return distance <= tolerance
        })
        if (levenshteinMatched) {
          const match = domainPartsToDomain(levenshteinMatched)
          return { name, match, result: true, type: 'fuzzy', version }
        }
      }
    }

    // matched nothing, PASS
    return { result: false, type: 'all' }
  }

}

module.exports = PhishingDetector

// util

function processConfigs(configs = []) {
  return configs.map((config) => {
    validateConfig(config)
    return Object.assign({}, config, {
      allowlist: processDomainList(config.allowlist || []),
      blocklist: processDomainList(config.blocklist || []),
      fuzzylist: processDomainList(config.fuzzylist || []),
      tolerance: ('tolerance' in config) ? config.tolerance : DEFAULT_TOLERANCE
    })
  });
}

function validateConfig(config) {
  if (config === null || typeof config !== 'object') {
    throw new Error('Invalid config')
  }

  if (config.tolerance && !config.fuzzylist) {
    throw new Error('Fuzzylist tolerance provided without fuzzylist')
  }

  if (
    typeof config.name !== 'string' ||
    config.name === ''
  ) {
    throw new Error("Invalid config parameter: 'name'")
  }

  if (
    !['number', 'string'].includes(typeof config.version) ||
    config.version === ''
  ) {
    throw new Error("Invalid config parameter: 'version'")
  }
}

function processDomainList (list) {
  return list.map(domainToParts)
}

function domainToParts (domain) {
  try {
  return domain.split('.').reverse()
  } catch (e) {
    throw new Error(JSON.stringify(domain))
  }
}

function domainPartsToDomain(domainParts) {
  return domainParts.slice().reverse().join('.')
}

// for fuzzy search, drop TLD and re-stringify
function domainPartsToFuzzyForm(domainParts) {
  return domainParts.slice(1).reverse().join('.')
}

// match the target parts, ignoring extra subdomains on source
//   source: [io, metamask, xyz]
//   target: [io, metamask]
//   result: PASS
function matchPartsAgainstList(source, list) {
  return list.some((target) => {
    // target domain has more parts than source, fail
    if (target.length > source.length) return false
    // source matches target or (is deeper subdomain)
    return target.every((part, index) => source[index] === part)
  })
}

      };
    };
  }
  }
}, {package:"@metamask/phishing-warning>eth-phishing-detect",file:"node_modules\\eth-phishing-detect\\src\\detector.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\dist\\index.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","tweetnacl":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverTypedSignature_v4 = exports.recoverTypedSignature = exports.signTypedData_v4 = exports.signTypedData = exports.recoverTypedMessage = exports.signTypedMessage = exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = exports.recoverTypedSignatureLegacy = exports.signTypedDataLegacy = exports.typedSignatureHash = exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = exports.normalize = exports.concatSig = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = void 0;
const ethUtil = __importStar(require("ethereumjs-util"));
const ethAbi = __importStar(require("ethereumjs-abi"));
const nacl = __importStar(require("tweetnacl"));
const naclUtil = __importStar(require("tweetnacl-util"));
const TYPED_MESSAGE_SCHEMA = {
    type: 'object',
    properties: {
        types: {
            type: 'object',
            additionalProperties: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        type: { type: 'string' },
                    },
                    required: ['name', 'type'],
                },
            },
        },
        primaryType: { type: 'string' },
        domain: { type: 'object' },
        message: { type: 'object' },
    },
    required: ['types', 'primaryType', 'domain', 'message'],
};
exports.TYPED_MESSAGE_SCHEMA = TYPED_MESSAGE_SCHEMA;
/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {
    /**
     * Encodes an object by encoding and concatenating each of its members
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to encode
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Encoded representation of an object
     */
    encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ['bytes32'];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
            const encodeField = (name, type, value) => {
                if (types[type] !== undefined) {
                    return [
                        'bytes32',
                        value == null // eslint-disable-line no-eq-null
                            ? '0x0000000000000000000000000000000000000000000000000000000000000000'
                            : ethUtil.keccak(this.encodeData(type, value, types, useV4)),
                    ];
                }
                if (value === undefined) {
                    throw new Error(`missing value for field ${name} of type ${type}`);
                }
                if (type === 'bytes') {
                    return ['bytes32', ethUtil.keccak(value)];
                }
                if (type === 'string') {
                    // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                    if (typeof value === 'string') {
                        value = Buffer.from(value, 'utf8');
                    }
                    return ['bytes32', ethUtil.keccak(value)];
                }
                if (type.lastIndexOf(']') === type.length - 1) {
                    const parsedType = type.slice(0, type.lastIndexOf('['));
                    const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
                    return [
                        'bytes32',
                        ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
                    ];
                }
                return [type, value];
            };
            for (const field of types[primaryType]) {
                const [type, value] = encodeField(field.name, field.type, data[field.name]);
                encodedTypes.push(type);
                encodedValues.push(value);
            }
        }
        else {
            for (const field of types[primaryType]) {
                let value = data[field.name];
                if (value !== undefined) {
                    if (field.type === 'bytes') {
                        encodedTypes.push('bytes32');
                        value = ethUtil.keccak(value);
                        encodedValues.push(value);
                    }
                    else if (field.type === 'string') {
                        encodedTypes.push('bytes32');
                        // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                        if (typeof value === 'string') {
                            value = Buffer.from(value, 'utf8');
                        }
                        value = ethUtil.keccak(value);
                        encodedValues.push(value);
                    }
                    else if (types[field.type] !== undefined) {
                        encodedTypes.push('bytes32');
                        value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4));
                        encodedValues.push(value);
                    }
                    else if (field.type.lastIndexOf(']') === field.type.length - 1) {
                        throw new Error('Arrays are unimplemented in encodeData; use V4 extension');
                    }
                    else {
                        encodedTypes.push(field.type);
                        encodedValues.push(value);
                    }
                }
            }
        }
        return ethAbi.rawEncode(encodedTypes, encodedValues);
    },
    /**
     * Encodes the type of an object by encoding a comma delimited list of its members
     *
     * @param {string} primaryType - Root type to encode
     * @param {Object} types - Type definitions
     * @returns {string} - Encoded representation of the type of an object
     */
    encodeType(primaryType, types) {
        let result = '';
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
            const children = types[type];
            if (!children) {
                throw new Error(`No type definition specified: ${type}`);
            }
            result += `${type}(${types[type]
                .map(({ name, type: t }) => `${t} ${name}`)
                .join(',')})`;
        }
        return result;
    },
    /**
     * Finds all types within a type definition object
     *
     * @param {string} primaryType - Root type
     * @param {Object} types - Type definitions
     * @param {Array} results - current set of accumulated types
     * @returns {Array} - Set of all types found in the type definition
     */
    findTypeDependencies(primaryType, types, results = []) {
        [primaryType] = primaryType.match(/^\w*/u);
        if (results.includes(primaryType) || types[primaryType] === undefined) {
            return results;
        }
        results.push(primaryType);
        for (const field of types[primaryType]) {
            for (const dep of this.findTypeDependencies(field.type, types, results)) {
                !results.includes(dep) && results.push(dep);
            }
        }
        return results;
    },
    /**
     * Hashes an object
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to hash
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Hash of an object
     */
    hashStruct(primaryType, data, types, useV4 = true) {
        return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));
    },
    /**
     * Hashes the type of an object
     *
     * @param {string} primaryType - Root type to hash
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Hash of an object
     */
    hashType(primaryType, types) {
        return ethUtil.keccak(this.encodeType(primaryType, types));
    },
    /**
     * Removes properties from a message object that are not defined per EIP-712
     *
     * @param {Object} data - typed message object
     * @returns {Object} - typed message object with only allowed fields
     */
    sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
            if (data[key]) {
                sanitizedData[key] = data[key];
            }
        }
        if ('types' in sanitizedData) {
            sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
    },
    /**
     * Signs a typed message as per EIP-712 and returns its keccak hash
     *
     * @param {Object} typedData - Types message data to sign
     * @returns {Buffer} - keccak hash of the resulting signed message
     */
    sign(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer.from('1901', 'hex')];
        parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== 'EIP712Domain') {
            parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return ethUtil.keccak(Buffer.concat(parts));
    },
};
exports.TypedDataUtils = TypedDataUtils;
function concatSig(v, r, s) {
    const rSig = ethUtil.fromSigned(r);
    const sSig = ethUtil.fromSigned(s);
    const vSig = ethUtil.bufferToInt(v);
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');
}
exports.concatSig = concatSig;
function normalize(input) {
    if (!input) {
        return undefined;
    }
    if (typeof input === 'number') {
        const buffer = ethUtil.toBuffer(input);
        input = ethUtil.bufferToHex(buffer);
    }
    if (typeof input !== 'string') {
        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
    }
    return ethUtil.addHexPrefix(input.toLowerCase());
}
exports.normalize = normalize;
function personalSign(privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data);
    const msgHash = ethUtil.hashPersonalMessage(message);
    const sig = ethUtil.ecsign(msgHash, privateKey);
    const serialized = ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
    return serialized;
}
exports.personalSign = personalSign;
function recoverPersonalSignature(msgParams) {
    const publicKey = getPublicKeyFor(msgParams);
    const sender = ethUtil.publicToAddress(publicKey);
    const senderHex = ethUtil.bufferToHex(sender);
    return senderHex;
}
exports.recoverPersonalSignature = recoverPersonalSignature;
function extractPublicKey(msgParams) {
    const publicKey = getPublicKeyFor(msgParams);
    return `0x${publicKey.toString('hex')}`;
}
exports.extractPublicKey = extractPublicKey;
function externalTypedSignatureHash(typedData) {
    const hashBuffer = typedSignatureHash(typedData);
    return ethUtil.bufferToHex(hashBuffer);
}
exports.typedSignatureHash = externalTypedSignatureHash;
function signTypedDataLegacy(privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data);
    const sig = ethUtil.ecsign(msgHash, privateKey);
    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
}
exports.signTypedDataLegacy = signTypedDataLegacy;
function recoverTypedSignatureLegacy(msgParams) {
    const msgHash = typedSignatureHash(msgParams.data);
    const publicKey = recoverPublicKey(msgHash, msgParams.sig);
    const sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
}
exports.recoverTypedSignatureLegacy = recoverTypedSignatureLegacy;
function encrypt(receiverPublicKey, msgParams, version) {
    switch (version) {
        case 'x25519-xsalsa20-poly1305': {
            if (typeof msgParams.data !== 'string') {
                throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ');
            }
            // generate ephemeral keypair
            const ephemeralKeyPair = nacl.box.keyPair();
            // assemble encryption parameters - from string to UInt8
            let pubKeyUInt8Array;
            try {
                pubKeyUInt8Array = naclUtil.decodeBase64(receiverPublicKey);
            }
            catch (err) {
                throw new Error('Bad public key');
            }
            const msgParamsUInt8Array = naclUtil.decodeUTF8(msgParams.data);
            const nonce = nacl.randomBytes(nacl.box.nonceLength);
            // encrypt
            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
            // handle encrypted data
            const output = {
                version: 'x25519-xsalsa20-poly1305',
                nonce: naclUtil.encodeBase64(nonce),
                ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
                ciphertext: naclUtil.encodeBase64(encryptedMessage),
            };
            // return encrypted msg data
            return output;
        }
        default:
            throw new Error('Encryption type/version not supported');
    }
}
exports.encrypt = encrypt;
function encryptSafely(receiverPublicKey, msgParams, version) {
    const DEFAULT_PADDING_LENGTH = 2 ** 11;
    const NACL_EXTRA_BYTES = 16;
    const { data } = msgParams;
    if (!data) {
        throw new Error('Cannot encrypt empty msg.data');
    }
    if (typeof data === 'object' && 'toJSON' in data) {
        // remove toJSON attack vector
        // TODO, check all possible children
        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');
    }
    // add padding
    const dataWithPadding = {
        data,
        padding: '',
    };
    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');
    const modVal = dataLength % DEFAULT_PADDING_LENGTH;
    let padLength = 0;
    // Only pad if necessary
    if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength);
    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) };
    return encrypt(receiverPublicKey, paddedMsgParams, version);
}
exports.encryptSafely = encryptSafely;
function decrypt(encryptedData, receiverPrivateKey) {
    switch (encryptedData.version) {
        case 'x25519-xsalsa20-poly1305': {
            // string to buffer to UInt8Array
            const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);
            const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;
            // assemble decryption parameters
            const nonce = naclUtil.decodeBase64(encryptedData.nonce);
            const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
            const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
            // decrypt
            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);
            // return decrypted msg data
            let output;
            try {
                output = naclUtil.encodeUTF8(decryptedMessage);
            }
            catch (err) {
                throw new Error('Decryption failed.');
            }
            if (output) {
                return output;
            }
            throw new Error('Decryption failed.');
        }
        default:
            throw new Error('Encryption type/version not supported.');
    }
}
exports.decrypt = decrypt;
function decryptSafely(encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(decrypt(encryptedData, receiverPrivateKey));
    return dataWithPadding.data;
}
exports.decryptSafely = decryptSafely;
function getEncryptionPublicKey(privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey);
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
    return naclUtil.encodeBase64(encryptionPublicKey);
}
exports.getEncryptionPublicKey = getEncryptionPublicKey;
/**
 * A generic entry point for all typed data methods to be passed, includes a version parameter.
 */
function signTypedMessage(privateKey, msgParams, version = 'V4') {
    switch (version) {
        case 'V1':
            return signTypedDataLegacy(privateKey, msgParams);
        case 'V3':
            return signTypedData(privateKey, msgParams);
        case 'V4':
        default:
            return signTypedData_v4(privateKey, msgParams);
    }
}
exports.signTypedMessage = signTypedMessage;
function recoverTypedMessage(msgParams, version = 'V4') {
    switch (version) {
        case 'V1':
            return recoverTypedSignatureLegacy(msgParams);
        case 'V3':
            return recoverTypedSignature(msgParams);
        case 'V4':
        default:
            return recoverTypedSignature_v4(msgParams);
    }
}
exports.recoverTypedMessage = recoverTypedMessage;
function signTypedData(privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false);
    const sig = ethUtil.ecsign(message, privateKey);
    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
}
exports.signTypedData = signTypedData;
function signTypedData_v4(privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data);
    const sig = ethUtil.ecsign(message, privateKey);
    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
}
exports.signTypedData_v4 = signTypedData_v4;
function recoverTypedSignature(msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false);
    const publicKey = recoverPublicKey(message, msgParams.sig);
    const sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
}
exports.recoverTypedSignature = recoverTypedSignature;
function recoverTypedSignature_v4(msgParams) {
    const message = TypedDataUtils.sign(msgParams.data);
    const publicKey = recoverPublicKey(message, msgParams.sig);
    const sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
}
exports.recoverTypedSignature_v4 = recoverTypedSignature_v4;
/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash(typedData) {
    const error = new Error('Expect argument to be non-empty array');
    if (typeof typedData !== 'object' ||
        !('length' in typedData) ||
        !typedData.length) {
        throw error;
    }
    const data = typedData.map(function (e) {
        return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;
    });
    const types = typedData.map(function (e) {
        return e.type;
    });
    const schema = typedData.map(function (e) {
        if (!e.name) {
            throw error;
        }
        return `${e.type} ${e.name}`;
    });
    return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [
        ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
        ethAbi.soliditySHA3(types, data),
    ]);
}
function recoverPublicKey(hash, sig) {
    const signature = ethUtil.toBuffer(sig);
    const sigParams = ethUtil.fromRpcSig(signature);
    return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);
}
function getPublicKeyFor(msgParams) {
    const message = ethUtil.toBuffer(msgParams.data);
    const msgHash = ethUtil.hashPersonalMessage(message);
    return recoverPublicKey(msgHash, msgParams.sig);
}
function padWithZeroes(number, length) {
    let myString = `${number}`;
    while (myString.length < length) {
        myString = `0${myString}`;
    }
    return myString;
}
// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex(msgHex) {
    const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');
    return naclUtil.decodeBase64(msgBase64);
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-sig-util",file:"node_modules\\eth-sig-util\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\hash-utils.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereum-cryptography%5Chash-utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createHashFunction(hashConstructor) {
    return function (msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
    };
}
exports.createHashFunction = createHashFunction;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\hash-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\keccak.js", {"./hash-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\hash-utils.js","keccak":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\keccak\\js.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hash_utils_1 = require("./hash-utils");
var createKeccakHash = require("keccak");
exports.keccak224 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak224");
});
exports.keccak256 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak256");
});
exports.keccak384 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak384");
});
exports.keccak512 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak512");
});
//# sourceMappingURL=keccak.js.map
      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\keccak.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\random.js", {"randombytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\randombytes\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereum-cryptography%5Crandom.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var randombytes = require("randombytes");
function getRandomBytes(bytes) {
    return new Promise(function (resolve, reject) {
        randombytes(bytes, function (err, resp) {
            if (err) {
                reject(err);
                return;
            }
            resolve(resp);
        });
    });
}
exports.getRandomBytes = getRandomBytes;
function getRandomBytesSync(bytes) {
    return randombytes(bytes);
}
exports.getRandomBytesSync = getRandomBytesSync;
//# sourceMappingURL=random.js.map
      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\random.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\secp256k1.js", {"./random":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\random.js","secp256k1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereum-cryptography%5Csecp256k1.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var secp256k1_1 = require("secp256k1");
var random_1 = require("./random");
var SECP256K1_PRIVATE_KEY_SIZE = 32;
function createPrivateKey() {
    return __awaiter(this, void 0, void 0, function () {
        var pk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!true) return [3 /*break*/, 2];
                    return [4 /*yield*/, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
                case 1:
                    pk = _a.sent();
                    if (secp256k1_1.privateKeyVerify(pk)) {
                        return [2 /*return*/, pk];
                    }
                    return [3 /*break*/, 0];
                case 2: return [2 /*return*/];
            }
        });
    });
}
exports.createPrivateKey = createPrivateKey;
function createPrivateKeySync() {
    while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
            return pk;
        }
    }
}
exports.createPrivateKeySync = createPrivateKeySync;
__export(require("secp256k1"));
//# sourceMappingURL=secp256k1.js.map
      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\secp256k1.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"./secp256k1-adapter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js","assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\assert\\assert.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util",file:"node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", {"./secp256k1-lib/der":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js","./secp256k1-lib/index":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

function getSecp256k1 () { return require('./secp256k1-lib/index'); }
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  var secp256k1v3 = getSecp256k1();
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();
  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util",file:"node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-lib%5Cder.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

exports.signatureImportLax = function (signature) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);

  var length = signature.length;
  var index = 0;

  // sequence tag byte
  if (signature[index++] !== 0x30) {
    return null;
  }

  // sequence length byte
  var lenbyte = signature[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) {
      return null;
    }
  }

  // sequence tag byte for r
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for r
  var rlen = signature[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }
  if (rlen > length - index) {
    return null;
  }
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for s
  var slen = signature[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }
  if (slen > length - index) {
    return null;
  }
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {}
  // copy r value
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {}
  // copy s value
  if (slen > 32) {
    return null;
  }
  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);

  return { r: r, s: s };
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util",file:"node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", {"bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-lib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var BN = require('bn.js');
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve;

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN(0);
  }

  var s = new BN(sigObj.s);
  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec.keyFromPublic(publicKey);

  var scalar = new BN(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util",file:"node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethjs-util%5Clib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-sig-util>ethereumjs-util>ethjs-util",file:"node_modules\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereum-cryptography\\hdkey.js", {"@scure/bip32":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@scure\\bip32\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereum-cryptography%5Chdkey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = exports.HARDENED_OFFSET = void 0;
var bip32_1 = require("@scure/bip32");
Object.defineProperty(exports, "HARDENED_OFFSET", { enumerable: true, get: function () { return bip32_1.HARDENED_OFFSET; } });
Object.defineProperty(exports, "HDKey", { enumerable: true, get: function () { return bip32_1.HDKey; } });

      };
    };
  }
  }
}, {package:"@ethereumjs/tx>ethereum-cryptography",file:"node_modules\\ethereum-cryptography\\hdkey.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\index.js", {"bs58check":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bs58check\\index.js","crypto":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\crypto-browserify\\index.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js","randombytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\randombytes\\browser.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js","scryptsy":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\scryptsy\\lib\\scrypt.js","uuid/v4":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\v4.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cindex.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Buffer = require('safe-buffer').Buffer;
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var randomBytes = require('randombytes');
var scryptsy = require('scryptsy');
var uuidv4 = require('uuid/v4');
var bs58check = require('bs58check');

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Wallet = function Wallet(priv, pub) {
  if (priv && pub) {
    throw new Error('Cannot supply both a private and a public key to the constructor');
  }

  if (priv && !ethUtil.isValidPrivate(priv)) {
    throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
  }

  if (pub && !ethUtil.isValidPublic(pub)) {
    throw new Error('Invalid public key');
  }

  this._privKey = priv;
  this._pubKey = pub;
};

Object.defineProperty(Wallet.prototype, 'privKey', {
  get: function get() {
    assert(this._privKey, 'This is a public key only wallet');
    return this._privKey;
  }
});

Object.defineProperty(Wallet.prototype, 'pubKey', {
  get: function get() {
    if (!this._pubKey) {
      this._pubKey = ethUtil.privateToPublic(this.privKey);
    }
    return this._pubKey;
  }
});

Wallet.generate = function (icapDirect) {
  if (icapDirect) {
    var max = new ethUtil.BN('088f924eeceeda7fe92e1f5b0fffffffffffffff', 16);
    while (true) {
      var privKey = randomBytes(32);
      if (new ethUtil.BN(ethUtil.privateToAddress(privKey)).lte(max)) {
        return new Wallet(privKey);
      }
    }
  } else {
    return new Wallet(randomBytes(32));
  }
};

Wallet.generateVanityAddress = function (pattern) {
  if ((typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) !== 'object') {
    pattern = new RegExp(pattern);
  }

  while (true) {
    var privKey = randomBytes(32);
    var address = ethUtil.privateToAddress(privKey);

    if (pattern.test(address.toString('hex'))) {
      return new Wallet(privKey);
    }
  }
};

Wallet.prototype.getPrivateKey = function () {
  return this.privKey;
};

Wallet.prototype.getPrivateKeyString = function () {
  return ethUtil.bufferToHex(this.getPrivateKey());
};

Wallet.prototype.getPublicKey = function () {
  return this.pubKey;
};

Wallet.prototype.getPublicKeyString = function () {
  return ethUtil.bufferToHex(this.getPublicKey());
};

Wallet.prototype.getAddress = function () {
  return ethUtil.publicToAddress(this.pubKey);
};

Wallet.prototype.getAddressString = function () {
  return ethUtil.bufferToHex(this.getAddress());
};

Wallet.prototype.getChecksumAddressString = function () {
  return ethUtil.toChecksumAddress(this.getAddressString());
};

// https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
Wallet.prototype.toV3 = function (password, opts) {
  assert(this._privKey, 'This is a public key only wallet');

  opts = opts || {};
  var salt = opts.salt || randomBytes(32);
  var iv = opts.iv || randomBytes(16);

  var derivedKey;
  var kdf = opts.kdf || 'scrypt';
  var kdfparams = {
    dklen: opts.dklen || 32,
    salt: salt.toString('hex')
  };

  if (kdf === 'pbkdf2') {
    kdfparams.c = opts.c || 262144;
    kdfparams.prf = 'hmac-sha256';
    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');
  } else if (kdf === 'scrypt') {
    // FIXME: support progress reporting callback
    kdfparams.n = opts.n || 262144;
    kdfparams.r = opts.r || 8;
    kdfparams.p = opts.p || 1;
    derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else {
    throw new Error('Unsupported kdf');
  }

  var cipher = crypto.createCipheriv(opts.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);
  if (!cipher) {
    throw new Error('Unsupported cipher');
  }

  var ciphertext = runCipherBuffer(cipher, this.privKey);

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')]));

  return {
    version: 3,
    id: uuidv4({ random: opts.uuid || randomBytes(16) }),
    address: this.getAddress().toString('hex'),
    crypto: {
      ciphertext: ciphertext.toString('hex'),
      cipherparams: {
        iv: iv.toString('hex')
      },
      cipher: opts.cipher || 'aes-128-ctr',
      kdf: kdf,
      kdfparams: kdfparams,
      mac: mac.toString('hex')
    }
  };
};

Wallet.prototype.getV3Filename = function (timestamp) {
  /*
   * We want a timestamp like 2016-03-15T17-11-33.007598288Z. Date formatting
   * is a pain in Javascript, everbody knows that. We could use moment.js,
   * but decide to do it manually in order to save space.
   *
   * toJSON() returns a pretty close version, so let's use it. It is not UTC though,
   * but does it really matter?
   *
   * Alternative manual way with padding and Date fields: http://stackoverflow.com/a/7244288/4964819
   *
   */
  var ts = timestamp ? new Date(timestamp) : new Date();

  return ['UTC--', ts.toJSON().replace(/:/g, '-'), '--', this.getAddress().toString('hex')].join('');
};

Wallet.prototype.toV3String = function (password, opts) {
  return JSON.stringify(this.toV3(password, opts));
};

Wallet.fromPublicKey = function (pub, nonStrict) {
  if (nonStrict) {
    pub = ethUtil.importPublic(pub);
  }
  return new Wallet(null, pub);
};

Wallet.fromExtendedPublicKey = function (pub) {
  assert(pub.slice(0, 4) === 'xpub', 'Not an extended public key');
  pub = bs58check.decode(pub).slice(45);
  // Convert to an Ethereum public key
  return Wallet.fromPublicKey(pub, true);
};

Wallet.fromPrivateKey = function (priv) {
  return new Wallet(priv);
};

Wallet.fromExtendedPrivateKey = function (priv) {
  assert(priv.slice(0, 4) === 'xprv', 'Not an extended private key');
  var tmp = bs58check.decode(priv);
  assert(tmp[45] === 0, 'Invalid extended private key');
  return Wallet.fromPrivateKey(tmp.slice(46));
};

// https://github.com/ethereum/go-ethereum/wiki/Passphrase-protected-key-store-spec
Wallet.fromV1 = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  if (json.Version !== '1') {
    throw new Error('Not a V1 wallet');
  }

  if (json.Crypto.KeyHeader.Kdf !== 'scrypt') {
    throw new Error('Unsupported key derivation scheme');
  }

  var kdfparams = json.Crypto.KeyHeader.KdfParams;
  var derivedKey = scryptsy(Buffer.from(password), Buffer.from(json.Crypto.Salt, 'hex'), kdfparams.N, kdfparams.R, kdfparams.P, kdfparams.DkLen);

  var ciphertext = Buffer.from(json.Crypto.CipherText, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));

  if (mac.toString('hex') !== json.Crypto.MAC) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv('aes-128-cbc', ethUtil.keccak256(derivedKey.slice(0, 16)).slice(0, 16), Buffer.from(json.Crypto.IV, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

Wallet.fromV3 = function (input, password, nonStrict) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);

  if (json.version !== 3) {
    throw new Error('Not a V3 wallet');
  }

  var derivedKey;
  var kdfparams;
  if (json.crypto.kdf === 'scrypt') {
    kdfparams = json.crypto.kdfparams;

    // FIXME: support progress reporting callback
    derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else if (json.crypto.kdf === 'pbkdf2') {
    kdfparams = json.crypto.kdfparams;

    if (kdfparams.prf !== 'hmac-sha256') {
      throw new Error('Unsupported parameters to PBKDF2');
    }

    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');
  } else {
    throw new Error('Unsupported key derivation scheme');
  }

  var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));
  if (mac.toString('hex') !== json.crypto.mac) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

/*
 * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py
 * JSON fields: encseed, ethaddr, btcaddr, email
 */
Wallet.fromEthSale = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var encseed = Buffer.from(json.encseed, 'hex');

  // key derivation
  var derivedKey = crypto.pbkdf2Sync(password, password, 2000, 32, 'sha256').slice(0, 16);

  // seed decoding (IV is first 16 bytes)
  // NOTE: crypto (derived from openssl) when used with aes-*-cbc will handle PKCS#7 padding internally
  //       see also http://stackoverflow.com/a/31614770/4964819
  var decipher = crypto.createDecipheriv('aes-128-cbc', derivedKey, encseed.slice(0, 16));
  var seed = runCipherBuffer(decipher, encseed.slice(16));

  var wallet = new Wallet(ethUtil.keccak256(seed));
  if (wallet.getAddress().toString('hex') !== json.ethaddr) {
    throw new Error('Decoded key mismatch - possibly wrong passphrase');
  }
  return wallet;
};

module.exports = Wallet;
      };
    };
  }
  }
}, {package:"ethereumjs-wallet",file:"node_modules\\ethereumjs-wallet\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\hash-utils.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereum-cryptography%5Chash-utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createHashFunction(hashConstructor) {
    return function (msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
    };
}
exports.createHashFunction = createHashFunction;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereum-cryptography",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\hash-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\keccak.js", {"./hash-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\hash-utils.js","keccak":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\keccak\\js.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hash_utils_1 = require("./hash-utils");
var createKeccakHash = require("keccak");
exports.keccak224 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak224");
});
exports.keccak256 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak256");
});
exports.keccak384 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak384");
});
exports.keccak512 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak512");
});
//# sourceMappingURL=keccak.js.map
      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereum-cryptography",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\keccak.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\random.js", {"randombytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\randombytes\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereum-cryptography%5Crandom.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var randombytes = require("randombytes");
function getRandomBytes(bytes) {
    return new Promise(function (resolve, reject) {
        randombytes(bytes, function (err, resp) {
            if (err) {
                reject(err);
                return;
            }
            resolve(resp);
        });
    });
}
exports.getRandomBytes = getRandomBytes;
function getRandomBytesSync(bytes) {
    return randombytes(bytes);
}
exports.getRandomBytesSync = getRandomBytesSync;
//# sourceMappingURL=random.js.map
      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereum-cryptography",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\random.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\secp256k1.js", {"./random":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\random.js","secp256k1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereum-cryptography%5Csecp256k1.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var secp256k1_1 = require("secp256k1");
var random_1 = require("./random");
var SECP256K1_PRIVATE_KEY_SIZE = 32;
function createPrivateKey() {
    return __awaiter(this, void 0, void 0, function () {
        var pk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!true) return [3 /*break*/, 2];
                    return [4 /*yield*/, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
                case 1:
                    pk = _a.sent();
                    if (secp256k1_1.privateKeyVerify(pk)) {
                        return [2 /*return*/, pk];
                    }
                    return [3 /*break*/, 0];
                case 2: return [2 /*return*/];
            }
        });
    });
}
exports.createPrivateKey = createPrivateKey;
function createPrivateKeySync() {
    while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
            return pk;
        }
    }
}
exports.createPrivateKeySync = createPrivateKeySync;
__export(require("secp256k1"));
//# sourceMappingURL=secp256k1.js.map
      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereum-cryptography",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\secp256k1.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\account.js", {"./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js","./secp256k1v3-adapter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js","assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\assert\\assert.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Caccount.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns a zero address.
 */
exports.zeroAddress = function () {
    var addressLength = 20;
    var addr = bytes_1.zeros(addressLength);
    return bytes_1.bufferToHex(addr);
};
/**
 * Checks if the address is a valid. Accepts checksummed addresses too.
 */
exports.isValidAddress = function (address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
};
/**
 * Checks if a given address is a zero address.
 */
exports.isZeroAddress = function (address) {
    var zeroAddr = exports.zeroAddress();
    return zeroAddr === bytes_1.addHexPrefix(address);
};
/**
 * Returns a checksummed address.
 *
 * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
 * has the effect of checksummed addresses for one chain having invalid checksums for others.
 * For more details, consult EIP-1191.
 *
 * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly
 * used variation in Ethereum was without the chainId. This may change in the future.
 */
exports.toChecksumAddress = function (address, eip1191ChainId) {
    address = ethjsUtil.stripHexPrefix(address).toLowerCase();
    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';
    var hash = hash_1.keccak(prefix + address).toString('hex');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            ret += address[i].toUpperCase();
        }
        else {
            ret += address[i];
        }
    }
    return ret;
};
/**
 * Checks if the address is a valid checksummed address.
 *
 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
 */
exports.isValidChecksumAddress = function (address, eip1191ChainId) {
    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
};
/**
 * Generates an address of a newly created contract.
 * @param from The address which is creating this new address
 * @param nonce The nonce of the from account
 */
exports.generateAddress = function (from, nonce) {
    from = bytes_1.toBuffer(from);
    var nonceBN = new BN(nonce);
    if (nonceBN.isZero()) {
        // in RLP we want to encode null in the case of zero nonce
        // read the RLP documentation for an answer if you dare
        return hash_1.rlphash([from, null]).slice(-20);
    }
    // Only take the lower 160bits of the hash
    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);
};
/**
 * Generates an address for a contract created using CREATE2.
 * @param from The address which is creating this new address
 * @param salt A salt
 * @param initCode The init code of the contract being created
 */
exports.generateAddress2 = function (from, salt, initCode) {
    var fromBuf = bytes_1.toBuffer(from);
    var saltBuf = bytes_1.toBuffer(salt);
    var initCodeBuf = bytes_1.toBuffer(initCode);
    assert(fromBuf.length === 20);
    assert(saltBuf.length === 32);
    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
    return address.slice(-20);
};
/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium).
 */
exports.isPrecompiled = function (address) {
    var a = bytes_1.unpad(address);
    return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};
/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 */
exports.isValidPrivate = function (privateKey) {
    return secp256k1.privateKeyVerify(privateKey);
};
/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.isValidPublic = function (publicKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    if (publicKey.length === 64) {
        // Convert to SEC1 for secp256k1
        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
    }
    if (!sanitize) {
        return false;
    }
    return secp256k1.publicKeyVerify(publicKey);
};
/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.pubToAddress = function (pubKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    pubKey = bytes_1.toBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
    }
    assert(pubKey.length === 64);
    // Only take the lower 160bits of the hash
    return hash_1.keccak(pubKey).slice(-20);
};
exports.publicToAddress = exports.pubToAddress;
/**
 * Returns the ethereum address of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(exports.privateToPublic(privateKey));
};
/**
 * Returns the ethereum public key of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToPublic = function (privateKey) {
    privateKey = bytes_1.toBuffer(privateKey);
    // skip the type flag and use the X, Y points
    return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};
/**
 * Converts a public key to the Ethereum format.
 */
exports.importPublic = function (publicKey) {
    publicKey = bytes_1.toBuffer(publicKey);
    if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\account.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js", {"bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */
exports.zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @param right whether to start padding form the left or right
 * @return (Buffer|Array)
 */
exports.setLengthLeft = function (msg, length, right) {
    if (right === void 0) { right = false; }
    var buf = exports.zeros(length);
    msg = exports.toBuffer(msg);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
exports.setLength = exports.setLengthLeft;
/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @return (Buffer|Array)
 */
exports.setLengthRight = function (msg, length) {
    return exports.setLength(msg, length, true);
};
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
exports.unpad = function (a) {
    a = ethjsUtil.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
exports.stripZeros = exports.unpad;
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
exports.toBuffer = function (v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjsUtil.isHexString(v)) {
                v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjsUtil.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (BN.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
};
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
    return new BN(exports.toBuffer(buf)).toNumber();
};
/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */
exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
};
/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param num Signed integer value
 */
exports.fromSigned = function (num) {
    return new BN(num).fromTwos(256);
};
/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param num
 */
exports.toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;
};
/**
 * Converts a `Buffer` or `Array` to JSON.
 * @param ba (Buffer|Array)
 * @return (Array|String|null)
 */
exports.baToJSON = function (ba) {
    if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString('hex');
    }
    else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
            array.push(exports.baToJSON(ba[i]));
        }
        return array;
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\constants.js", {"bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cconstants.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
var BN = require("bn.js");
/**
 * The max integer that this VM can handle
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
/**
 * 2^256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\constants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js", {"./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","create-hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Chash.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
var _a = require('ethereum-cryptography/keccak'), keccak224 = _a.keccak224, keccak384 = _a.keccak384, k256 = _a.keccak256, keccak512 = _a.keccak512;
var createHash = require('create-hash');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Creates Keccak hash of the input
 * @param a The input data (Buffer|Array|String|Number) If the string is a 0x-prefixed hex value
 * it's interpreted as hexadecimal, otherwise as utf8.
 * @param bits The Keccak width
 */
exports.keccak = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    if (typeof a === 'string' && !ethjsUtil.isHexString(a)) {
        a = Buffer.from(a, 'utf8');
    }
    else {
        a = bytes_1.toBuffer(a);
    }
    if (!bits)
        bits = 256;
    switch (bits) {
        case 224: {
            return keccak224(a);
        }
        case 256: {
            return k256(a);
        }
        case 384: {
            return keccak384(a);
        }
        case 512: {
            return keccak512(a);
        }
        default: {
            throw new Error("Invald algorithm: keccak" + bits);
        }
    }
};
/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.keccak256 = function (a) {
    return exports.keccak(a);
};
/**
 * Creates SHA256 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.sha256 = function (a) {
    a = bytes_1.toBuffer(a);
    return createHash('sha256')
        .update(a)
        .digest();
};
/**
 * Creates RIPEMD160 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160 = function (a, padded) {
    a = bytes_1.toBuffer(a);
    var hash = createHash('rmd160')
        .update(a)
        .digest();
    if (padded === true) {
        return bytes_1.setLength(hash, 32);
    }
    else {
        return hash;
    }
};
/**
 * Creates SHA-3 hash of the RLP encoded version of the input.
 * @param a The input data
 */
exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js", {"./account":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\account.js","./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\constants.js","./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js","./object":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\object.js","./secp256k1v3-adapter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js","./signature":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\signature.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","ethjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.secp256k1 = exports.rlp = exports.BN = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
exports.secp256k1 = secp256k1;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
exports.BN = BN;
var rlp = require("rlp");
exports.rlp = rlp;
Object.assign(exports, ethjsUtil);
/**
 * Constants
 */
__exportStar(require("./constants"), exports);
/**
 * Public-key cryptography (secp256k1) and addresses
 */
__exportStar(require("./account"), exports);
/**
 * Hash functions
 */
__exportStar(require("./hash"), exports);
/**
 * ECDSA signature
 */
__exportStar(require("./signature"), exports);
/**
 * Utilities for manipulating Buffers, byte arrays, etc.
 */
__exportStar(require("./bytes"), exports);
/**
 * Function for definining properties on an object
 */
__exportStar(require("./object"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\object.js", {"./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","assert":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\assert\\assert.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cobject.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineProperties = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */
exports.defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = [];
    // attach the `toJSON`
    self.toJSON = function (label) {
        if (label === void 0) { label = false; }
        if (label) {
            var obj_1 = {};
            self._fields.forEach(function (field) {
                obj_1[field] = "0x" + self[field].toString('hex');
            });
            return obj_1;
        }
        return bytes_1.baToJSON(self.raw);
    };
    self.serialize = function serialize() {
        return rlp.encode(self.raw);
    };
    fields.forEach(function (field, i) {
        self._fields.push(field.name);
        function getter() {
            return self.raw[i];
        }
        function setter(v) {
            v = bytes_1.toBuffer(v);
            if (v.toString('hex') === '00' && !field.allowZero) {
                v = Buffer.allocUnsafe(0);
            }
            if (field.allowLess && field.length) {
                v = bytes_1.stripZeros(v);
                assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
            }
            else if (!(field.allowZero && v.length === 0) && field.length) {
                assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
            }
            self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
            enumerable: true,
            configurable: true,
            get: getter,
            set: setter,
        });
        if (field.default) {
            self[field.name] = field.default;
        }
        // attach alias
        if (field.alias) {
            Object.defineProperty(self, field.alias, {
                enumerable: false,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    });
    // if the constuctor is passed data
    if (data) {
        if (typeof data === 'string') {
            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');
        }
        if (Buffer.isBuffer(data)) {
            data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
            if (data.length > self._fields.length) {
                throw new Error('wrong number of fields in data');
            }
            // make sure all the items are buffers
            data.forEach(function (d, i) {
                self[self._fields[i]] = bytes_1.toBuffer(d);
            });
        }
        else if (typeof data === 'object') {
            var keys_1 = Object.keys(data);
            fields.forEach(function (field) {
                if (keys_1.indexOf(field.name) !== -1)
                    self[field.name] = data[field.name];
                if (keys_1.indexOf(field.alias) !== -1)
                    self[field.alias] = data[field.alias];
            });
        }
        else {
            throw new Error('invalid data');
        }
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\object.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js", {"./secp256k1v3-lib/der":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\der.js","./secp256k1v3-lib/index":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1v3-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
var secp256k1 = require('ethereum-cryptography/secp256k1');
var secp256k1v3 = require('./secp256k1v3-lib/index');
var der = require('./secp256k1v3-lib/der');
/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
exports.privateKeyVerify = function (privateKey) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        return false;
    }
    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};
/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
exports.privateKeyExport = function (privateKey, compressed) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
    return der.privateKeyExport(privateKey, publicKey, compressed);
};
/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyImport = function (privateKey) {
    // privateKeyImport method is not part of secp256k1 v4 package
    // this implementation is based on v3
    privateKey = der.privateKeyImport(privateKey);
    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
    }
    throw new Error("couldn't import from DER format");
};
/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyNegate = function (privateKey) {
    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};
/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyModInverse = function (privateKey) {
    if (privateKey.length !== 32) {
        throw new Error('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};
/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakAdd = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};
/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakMul = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};
/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCreate = function (privateKey, compressed) {
    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};
/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyConvert = function (publicKey, compressed) {
    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};
/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.publicKeyVerify = function (publicKey) {
    // secp256k1 v4 version throws when publicKey length is not 33 or 65
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
    }
    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};
/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCombine = function (publicKeys, compressed) {
    var keys = [];
    publicKeys.forEach(function (publicKey) {
        keys.push(Uint8Array.from(publicKey));
    });
    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};
/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureNormalize = function (signature) {
    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};
/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureExport = function (signature) {
    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImport = function (signature) {
    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImportLax = function (signature) {
    // signatureImportLax method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure that signature is greater than 0
    if (signature.length === 0) {
        throw new RangeError('signature length is invalid');
    }
    var sigObj = der.signatureImportLax(signature);
    if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
    }
    return secp256k1v3.signatureImport(sigObj);
};
/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
exports.sign = function (message, privateKey, options) {
    if (options === null) {
        throw new TypeError('options should be an Object');
    }
    var signOptions = undefined;
    if (options) {
        signOptions = {};
        if (options.data === null) {
            // validate option.data length
            throw new TypeError('options.data should be a Buffer');
        }
        if (options.data) {
            if (options.data.length != 32) {
                throw new RangeError('options.data length is invalid');
            }
            signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
            throw new TypeError('options.noncefn should be a Function');
        }
        if (options.noncefn) {
            // convert option.noncefn function signature
            signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
                var bufferAlgo = algo != null ? Buffer.from(algo) : null;
                var bufferData = data != null ? Buffer.from(data) : null;
                var buffer = Buffer.from('');
                if (options.noncefn) {
                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
                }
                return new Uint8Array(buffer);
            };
        }
    }
    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
    return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid,
    };
};
/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.verify = function (message, signature, publicKey) {
    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};
/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.recover = function (message, signature, recid, compressed) {
    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};
/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.ecdh = function (publicKey, privateKey) {
    // note: secp256k1 v3 doesn't allow optional parameter
    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    // ecdhUnsafe method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure valid publicKey length
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError('public key length is invalid');
    }
    // ensure valid privateKey length
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\der.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1v3-lib%5Cder.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
    // begin
    0x30,
    0x81,
    0xd3,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0x85,
    0x30,
    0x81,
    0x82,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x21,
    0x02,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x24,
    0x03,
    0x22,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
    // begin
    0x30,
    0x82,
    0x01,
    0x13,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0xa5,
    0x30,
    0x81,
    0xa2,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x41,
    0x04,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x48,
    0x3a,
    0xda,
    0x77,
    0x26,
    0xa3,
    0xc4,
    0x65,
    0x5d,
    0xa4,
    0xfb,
    0xfc,
    0x0e,
    0x11,
    0x08,
    0xa8,
    0xfd,
    0x17,
    0xb4,
    0x48,
    0xa6,
    0x85,
    0x54,
    0x19,
    0x9c,
    0x47,
    0xd0,
    0x8f,
    0xfb,
    0x10,
    0xd4,
    0xb8,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x44,
    0x03,
    0x42,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
exports.privateKeyExport = function (privateKey, publicKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
    privateKey.copy(result, compressed ? 8 : 9);
    publicKey.copy(result, compressed ? 181 : 214);
    return result;
};
exports.privateKeyImport = function (privateKey) {
    var length = privateKey.length;
    // sequence header
    var index = 0;
    if (length < index + 1 || privateKey[index] !== 0x30)
        return null;
    index += 1;
    // sequence length constructor
    if (length < index + 1 || !(privateKey[index] & 0x80))
        return null;
    var lenb = privateKey[index] & 0x7f;
    index += 1;
    if (lenb < 1 || lenb > 2)
        return null;
    if (length < index + lenb)
        return null;
    // sequence length
    var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
    index += lenb;
    if (length < index + len)
        return null;
    // sequence element 0: version number (=1)
    if (length < index + 3 ||
        privateKey[index] !== 0x02 ||
        privateKey[index + 1] !== 0x01 ||
        privateKey[index + 2] !== 0x01) {
        return null;
    }
    index += 3;
    // sequence element 1: octet string, up to 32 bytes
    if (length < index + 2 ||
        privateKey[index] !== 0x04 ||
        privateKey[index + 1] > 0x20 ||
        length < index + 2 + privateKey[index + 1]) {
        return null;
    }
    return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};
exports.signatureImportLax = function (signature) {
    var r = Buffer.alloc(32, 0);
    var s = Buffer.alloc(32, 0);
    var length = signature.length;
    var index = 0;
    // sequence tag byte
    if (signature[index++] !== 0x30) {
        return null;
    }
    // sequence length byte
    var lenbyte = signature[index++];
    if (lenbyte & 0x80) {
        index += lenbyte - 0x80;
        if (index > length) {
            return null;
        }
    }
    // sequence tag byte for r
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for r
    var rlen = signature[index++];
    if (rlen & 0x80) {
        lenbyte = rlen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            rlen = (rlen << 8) + signature[index];
    }
    if (rlen > length - index) {
        return null;
    }
    var rindex = index;
    index += rlen;
    // sequence tag byte for s
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for s
    var slen = signature[index++];
    if (slen & 0x80) {
        lenbyte = slen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            slen = (slen << 8) + signature[index];
    }
    if (slen > length - index) {
        return null;
    }
    var sindex = index;
    index += slen;
    // ignore leading zeros in r
    for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1)
        ;
    // copy r value
    if (rlen > 32) {
        return null;
    }
    var rvalue = signature.slice(rindex, rindex + rlen);
    rvalue.copy(r, 32 - rvalue.length);
    // ignore leading zeros in s
    for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1)
        ;
    // copy s value
    if (slen > 32) {
        return null;
    }
    var svalue = signature.slice(sindex, sindex + slen);
    svalue.copy(s, 32 - svalue.length);
    return { r: r, s: s };
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\der.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\index.js", {"bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1v3-lib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var BN = require("bn.js");
var EC = require('elliptic').ec;
var ec = new EC('secp256k1');
var ecparams = ec.curve;
exports.privateKeyExport = function (privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var d = new BN(privateKey);
    if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
    }
    var point = ec.g.mul(d);
    return toPublicKey(point.getX(), point.getY(), compressed);
};
exports.privateKeyModInverse = function (privateKey) {
    var bn = new BN(privateKey);
    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error('private key range is invalid');
    }
    return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};
exports.signatureImport = function (sigObj) {
    var r = new BN(sigObj.r);
    if (r.ucmp(ecparams.n) >= 0) {
        r = new BN(0);
    }
    var s = new BN(sigObj.s);
    if (s.ucmp(ecparams.n) >= 0) {
        s = new BN(0);
    }
    return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var point = ec.keyFromPublic(publicKey);
    var scalar = new BN(privateKey);
    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error('scalar was invalid (zero or overflow)');
    }
    var shared = point.pub.mul(scalar);
    return toPublicKey(shared.getX(), shared.getY(), compressed);
};
var toPublicKey = function (x, y, compressed) {
    var publicKey;
    if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 0x03 : 0x02;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    }
    else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 0x04;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\signature.js", {"./bytes":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js","./secp256k1v3-adapter":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csignature.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns the ECDSA signature of a message hash.
 */
exports.ecsign = function (msgHash, privateKey, chainId) {
    var sig = secp256k1.sign(msgHash, privateKey);
    var recovery = sig.recovery;
    var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27,
    };
    return ret;
};
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */
exports.ecrecover = function (msgHash, v, r, s, chainId) {
    var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */
exports.toRpcSig = function (v, r, s, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));
};
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */
exports.fromRpcSig = function (sig) {
    var buf = bytes_1.toBuffer(sig);
    // NOTE: with potential introduction of chainId this might need to be updated
    if (buf.length !== 65) {
        throw new Error('Invalid signature length');
    }
    var v = buf[64];
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v: v,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64),
    };
};
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
exports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {
    if (homesteadOrLater === void 0) { homesteadOrLater = true; }
    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
    }
    var rBN = new BN(r);
    var sBN = new BN(s);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
    }
    return true;
};
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
exports.hashPersonalMessage = function (message) {
    var prefix = Buffer.from("\u0019Ethereum Signed Message:\n" + message.length.toString(), 'utf-8');
    return hash_1.keccak(Buffer.concat([prefix, message]));
};
function calculateSigRecovery(v, chainId) {
    return chainId ? v - (2 * chainId + 35) : v - 27;
}
function isValidSigRecovery(recovery) {
    return recovery === 0 || recovery === 1;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\signature.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cethjs-util%5Clib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>ethereumjs-util>ethjs-util",file:"node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\bytesToUuid.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cuuid%5Clib%5CbytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>uuid",file:"node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\bytesToUuid.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\rng-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cuuid%5Clib%5Crng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>uuid",file:"node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\rng-browser.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\v4.js", {"./lib/bytesToUuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\bytesToUuid.js","./lib/rng":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\rng-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cnode_modules%5Cuuid%5Cv4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>uuid",file:"node_modules\\ethereumjs-wallet\\node_modules\\uuid\\v4.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\thirdparty.js", {"./index.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\index.js","aes-js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\aes-js\\index.js","crypto":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\crypto-browserify\\index.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js","scryptsy":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\scryptsy\\lib\\scrypt.js","utf8":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\utf8\\utf8.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cethereumjs-wallet%5Cthirdparty.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Wallet = require('./index.js');
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var scryptsy = require('scryptsy');
var utf8 = require('utf8');
var aesjs = require('aes-js');
var Buffer = require('safe-buffer').Buffer;

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Thirdparty = {};

/*
 * opts:
 * - digest - digest algorithm, defaults to md5
 * - count - hash iterations
 * - keysize - desired key size
 * - ivsize - desired IV size
 *
 * Algorithm form https://www.openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html
 *
 * FIXME: not optimised at all
 */
function evp_kdf(data, salt, opts) {
  // eslint-disable-line
  // A single EVP iteration, returns `D_i`, where block equlas to `D_(i-1)`
  function iter(block) {
    var hash = crypto.createHash(opts.digest || 'md5');
    hash.update(block);
    hash.update(data);
    hash.update(salt);
    block = hash.digest();

    for (var i = 1; i < (opts.count || 1); i++) {
      hash = crypto.createHash(opts.digest || 'md5');
      hash.update(block);
      block = hash.digest();
    }

    return block;
  }

  var keysize = opts.keysize || 16;
  var ivsize = opts.ivsize || 16;

  var ret = [];

  var i = 0;
  while (Buffer.concat(ret).length < keysize + ivsize) {
    ret[i] = iter(i === 0 ? Buffer.alloc(0) : ret[i - 1]);
    i++;
  }

  var tmp = Buffer.concat(ret);

  return {
    key: tmp.slice(0, keysize),
    iv: tmp.slice(keysize, keysize + ivsize)
  };
}

// http://stackoverflow.com/questions/25288311/cryptojs-aes-pattern-always-ends-with
function decodeCryptojsSalt(input) {
  var ciphertext = Buffer.from(input, 'base64');
  if (ciphertext.slice(0, 8).toString() === 'Salted__') {
    return {
      salt: ciphertext.slice(8, 16),
      ciphertext: ciphertext.slice(16)
    };
  } else {
    return {
      ciphertext: ciphertext
    };
  }
}

/*
 * This wallet format is created by https://github.com/SilentCicero/ethereumjs-accounts
 * and used on https://www.myetherwallet.com/
 */
Thirdparty.fromEtherWallet = function (input, password) {
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var privKey;
  if (!json.locked) {
    if (json.private.length !== 64) {
      throw new Error('Invalid private key length');
    }

    privKey = Buffer.from(json.private, 'hex');
  } else {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }
    if (password.length < 7) {
      throw new Error('Password must be at least 7 characters');
    }

    // the "encrypted" version has the low 4 bytes
    // of the hash of the address appended
    var cipher = json.encrypted ? json.private.slice(0, 128) : json.private;

    // decode openssl ciphertext + salt encoding
    cipher = decodeCryptojsSalt(cipher);

    if (!cipher.salt) {
      throw new Error('Unsupported EtherWallet key format');
    }

    // derive key/iv using OpenSSL EVP as implemented in CryptoJS
    var evp = evp_kdf(Buffer.from(password), cipher.salt, { keysize: 32, ivsize: 16 });

    var decipher = crypto.createDecipheriv('aes-256-cbc', evp.key, evp.iv);
    privKey = runCipherBuffer(decipher, Buffer.from(cipher.ciphertext));

    // NOTE: yes, they've run it through UTF8
    privKey = Buffer.from(utf8.decode(privKey.toString()), 'hex');
  }

  var wallet = new Wallet(privKey);

  if (wallet.getAddressString() !== json.address) {
    throw new Error('Invalid private key or address');
  }

  return wallet;
};

Thirdparty.fromEtherCamp = function (passphrase) {
  return new Wallet(ethUtil.keccak256(Buffer.from(passphrase)));
};

Thirdparty.fromKryptoKit = function (entropy, password) {
  function kryptoKitBrokenScryptSeed(buf) {
    // js-scrypt calls `Buffer.from(String(salt), 'utf8')` on the seed even though it is a buffer
    //
    // The `buffer`` implementation used does the below transformation (doesn't matches the current version):
    // https://github.com/feross/buffer/blob/67c61181b938b17d10dbfc0a545f713b8bd59de8/index.js

    function decodeUtf8Char(str) {
      try {
        return decodeURIComponent(str);
      } catch (err) {
        return String.fromCharCode(0xFFFD); // UTF 8 invalid char
      }
    }

    var res = '';
    var tmp = '';

    for (var i = 0; i < buf.length; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }

    return Buffer.from(res + decodeUtf8Char(tmp));
  }

  if (entropy[0] === '#') {
    entropy = entropy.slice(1);
  }

  var type = entropy[0];
  entropy = entropy.slice(1);

  var privKey;
  if (type === 'd') {
    privKey = ethUtil.sha256(Buffer.from(entropy));
  } else if (type === 'q') {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }

    var encryptedSeed = ethUtil.sha256(Buffer.from(entropy.slice(0, 30)));
    var checksum = entropy.slice(30, 46);

    var salt = kryptoKitBrokenScryptSeed(encryptedSeed);
    var aesKey = scryptsy(Buffer.from(password, 'utf8'), salt, 16384, 8, 1, 32);

    /* FIXME: try to use `crypto` instead of `aesjs`
     // NOTE: ECB doesn't use the IV, so it can be anything
    var decipher = crypto.createDecipheriv("aes-256-ecb", aesKey, Buffer.from(0))
     // FIXME: this is a clear abuse, but seems to match how ECB in aesjs works
    privKey = Buffer.concat([
      decipher.update(encryptedSeed).slice(0, 16),
      decipher.update(encryptedSeed).slice(0, 16),
    ])
    */

    /* eslint-disable new-cap */
    var decipher = new aesjs.ModeOfOperation.ecb(aesKey);
    /* eslint-enable new-cap */
    /* decrypt returns an Uint8Array, perhaps there is a better way to concatenate */
    privKey = Buffer.concat([Buffer.from(decipher.decrypt(encryptedSeed.slice(0, 16))), Buffer.from(decipher.decrypt(encryptedSeed.slice(16, 32)))]);

    if (checksum.length > 0) {
      if (checksum !== ethUtil.sha256(ethUtil.sha256(privKey)).slice(0, 8).toString('hex')) {
        throw new Error('Failed to decrypt input - possibly invalid passphrase');
      }
    }
  } else {
    throw new Error('Unsupported or invalid entropy type');
  }

  return new Wallet(privKey);
};

Thirdparty.fromQuorumWallet = function (passphrase, userid) {
  assert(passphrase.length >= 10);
  assert(userid.length >= 10);

  var seed = passphrase + userid;
  seed = crypto.pbkdf2Sync(seed, seed, 2000, 32, 'sha256');

  return new Wallet(seed);
};

module.exports = Thirdparty;
      };
    };
  }
  }
}, {package:"ethereumjs-wallet",file:"node_modules\\ethereumjs-wallet\\thirdparty.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\core.js", {"./helpers.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\helpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cfast-json-patch%5Ccommonjs%5Ccore.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_js_1 = require("./helpers.js");
exports.JsonPatchError = helpers_js_1.PatchError;
exports.deepClone = helpers_js_1._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = helpers_js_1._deepClone(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: helpers_js_1._deepClone(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: _areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if (helpers_js_1.isInteger(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
exports.getValueByPointer = getValueByPointer;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = _areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = helpers_js_1._deepClone(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (key && key.indexOf('~') != -1) {
                key = helpers_js_1.unescapePathComponent(key);
            }
            if (banPrototypeModifications &&
                (key == '__proto__' ||
                    (key == 'prototype' && t > 0 && keys[t - 1] == 'constructor'))) {
                throw new TypeError('JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !helpers_js_1.isInteger(key)) {
                        throw new exports.JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if (helpers_js_1.isInteger(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new exports.JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
            // If we have more keys in the path, but the next value isn't a non-null object,
            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.
            if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
                throw new exports.JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.applyOperation = applyOperation;
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = helpers_js_1._deepClone(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
exports.applyPatch = applyPatch;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
exports.applyReducer = applyReducer;
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new exports.JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_js_1.hasUndefined(operation.value)) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.validator = validator;
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch(helpers_js_1._deepClone(document), helpers_js_1._deepClone(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof exports.JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
exports.validate = validate;
// based on https://github.com/epoberezkin/fast-deep-equal
// MIT License
// Copyright (c) 2017 Evgeny Poberezkin
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
function _areEquals(a, b) {
    if (a === b)
        return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
            length = a.length;
            if (length != b.length)
                return false;
            for (i = length; i-- !== 0;)
                if (!_areEquals(a[i], b[i]))
                    return false;
            return true;
        }
        if (arrA != arrB)
            return false;
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
            return false;
        for (i = length; i-- !== 0;)
            if (!b.hasOwnProperty(keys[i]))
                return false;
        for (i = length; i-- !== 0;) {
            key = keys[i];
            if (!_areEquals(a[key], b[key]))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
exports._areEquals = _areEquals;
;

      };
    };
  }
  }
}, {package:"fast-json-patch",file:"node_modules\\fast-json-patch\\commonjs\\core.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\duplex.js", {"./core.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\core.js","./helpers.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\helpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cfast-json-patch%5Ccommonjs%5Cduplex.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */
var helpers_js_1 = require("./helpers.js");
var core_js_1 = require("./core.js");
var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
exports.unobserve = unobserve;
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = helpers_js_1._deepClone(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
exports.observe = observe;
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        core_js_1.applyPatch(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
exports.generate = generate;
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = helpers_js_1._objectKeys(obj);
    var oldKeys = helpers_js_1._objectKeys(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if (helpers_js_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
                _generate(oldVal, newVal, patches, path + "/" + helpers_js_1.escapePathComponent(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + helpers_js_1.escapePathComponent(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!helpers_js_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}
exports.compare = compare;

      };
    };
  }
  }
}, {package:"fast-json-patch",file:"node_modules\\fast-json-patch\\commonjs\\duplex.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\helpers.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cfast-json-patch%5Ccommonjs%5Chelpers.js
      return function (require, module, exports) {
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
Object.defineProperty(exports, "hasOwnProperty", { value: hasOwnProperty });
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys_1 = new Array(obj.length);
        for (var k = 0; k < keys_1.length; k++) {
            keys_1[k] = "" + k;
        }
        return keys_1;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
exports._objectKeys = _objectKeys;
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
exports._deepClone = _deepClone;
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
exports.isInteger = isInteger;
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
exports.escapePathComponent = escapePathComponent;
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
exports.unescapePathComponent = unescapePathComponent;
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
exports._getPathRecursive = _getPathRecursive;
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return "/" + path;
}
exports.getPath = getPath;
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
                if (hasUndefined(obj[i_1])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
exports.hasUndefined = hasUndefined;
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));
exports.PatchError = PatchError;

      };
    };
  }
  }
}, {package:"fast-json-patch",file:"node_modules\\fast-json-patch\\commonjs\\helpers.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\index.js", {"./commonjs/core.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\core.js","./commonjs/duplex.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\duplex.js","./commonjs/helpers.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-json-patch\\commonjs\\helpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cfast-json-patch%5Cindex.js
      return function (require, module, exports) {
var core = require("./commonjs/core.js");
Object.assign(exports, core);

var duplex = require("./commonjs/duplex.js");
Object.assign(exports, duplex);

var helpers = require("./commonjs/helpers.js");
exports.JsonPatchError = helpers.PatchError;
exports.deepClone = helpers._deepClone;
exports.escapePathComponent = helpers.escapePathComponent;
exports.unescapePathComponent = helpers.unescapePathComponent;

      };
    };
  }
  }
}, {package:"fast-json-patch",file:"node_modules\\fast-json-patch\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\fast-levenshtein\\levenshtein.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cfast-levenshtein%5Clevenshtein.js
      return function (require, module, exports) {
(function() {
  'use strict';
  
  var collator;
  try {
    collator = (typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined") ? Intl.Collator("generic", { sensitivity: "base" }) : null;
  } catch (err){
    console.log("Collator could not be initialized and wouldn't be used");
  }
  // arrays to re-use
  var prevRow = [],
    str2Char = [];
  
  /**
   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.
   */
  var Levenshtein = {
    /**
     * Calculate levenshtein distance of the two strings.
     *
     * @param str1 String the first string.
     * @param str2 String the second string.
     * @param [options] Additional options.
     * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.
     * @return Integer the levenshtein distance (0 and above).
     */
    get: function(str1, str2, options) {
      var useCollator = (options && collator && options.useCollator);
      
      var str1Len = str1.length,
        str2Len = str2.length;
      
      // base cases
      if (str1Len === 0) return str2Len;
      if (str2Len === 0) return str1Len;

      // two rows
      var curCol, nextCol, i, j, tmp;

      // initialise previous row
      for (i=0; i<str2Len; ++i) {
        prevRow[i] = i;
        str2Char[i] = str2.charCodeAt(i);
      }
      prevRow[str2Len] = str2Len;

      var strCmp;
      if (useCollator) {
        // calculate current row distance from previous row using collator
        for (i = 0; i < str1Len; ++i) {
          nextCol = i + 1;

          for (j = 0; j < str2Len; ++j) {
            curCol = nextCol;

            // substution
            strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));

            nextCol = prevRow[j] + (strCmp ? 0 : 1);

            // insertion
            tmp = curCol + 1;
            if (nextCol > tmp) {
              nextCol = tmp;
            }
            // deletion
            tmp = prevRow[j + 1] + 1;
            if (nextCol > tmp) {
              nextCol = tmp;
            }

            // copy current col value into previous (in preparation for next iteration)
            prevRow[j] = curCol;
          }

          // copy last col value into previous (in preparation for next iteration)
          prevRow[j] = nextCol;
        }
      }
      else {
        // calculate current row distance from previous row without collator
        for (i = 0; i < str1Len; ++i) {
          nextCol = i + 1;

          for (j = 0; j < str2Len; ++j) {
            curCol = nextCol;

            // substution
            strCmp = str1.charCodeAt(i) === str2Char[j];

            nextCol = prevRow[j] + (strCmp ? 0 : 1);

            // insertion
            tmp = curCol + 1;
            if (nextCol > tmp) {
              nextCol = tmp;
            }
            // deletion
            tmp = prevRow[j + 1] + 1;
            if (nextCol > tmp) {
              nextCol = tmp;
            }

            // copy current col value into previous (in preparation for next iteration)
            prevRow[j] = curCol;
          }

          // copy last col value into previous (in preparation for next iteration)
          prevRow[j] = nextCol;
        }
      }
      return nextCol;
    }

  };

  // amd
  if (typeof define !== "undefined" && define !== null && define.amd) {
    define(function() {
      return Levenshtein;
    });
  }
  // commonjs
  else if (typeof module !== "undefined" && module !== null && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = Levenshtein;
  }
  // web worker
  else if (typeof self !== "undefined" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {
    self.Levenshtein = Levenshtein;
  }
  // browser main thread
  else if (typeof window !== "undefined" && window !== null) {
    window.Levenshtein = Levenshtein;
  }
}());


      };
    };
  }
  }
}, {package:"eslint>optionator>fast-levenshtein",file:"node_modules\\fast-levenshtein\\levenshtein.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\addressTags.js", {"../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\utilities.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Capi%5CaddressTags.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeAddressTags = exports.fetchAddressTags = exports.addAddressTags = void 0;
var constants_1 = require("../constants");
var utilities_1 = require("./utilities");
var addAddressTags = function (tags) { return __awaiter(void 0, void 0, void 0, function () {
    var records;
    return __generator(this, function (_a) {
        records = tags.reduce(function (acc, tag) {
            var key = Object.keys(tag)[0];
            acc[key] = tag[key];
            return acc;
        }, {});
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.addKvRecords({ records: records }); })];
    });
}); };
exports.addAddressTags = addAddressTags;
var fetchAddressTags = function (_a) {
    var _b = _a === void 0 ? { n: constants_1.MAX_ADDR, start: 0 } : _a, n = _b.n, start = _b.start;
    return __awaiter(void 0, void 0, void 0, function () {
        var addressTags, remainingToFetch, fetched;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    addressTags = [];
                    remainingToFetch = n;
                    fetched = start;
                    _c.label = 1;
                case 1:
                    if (!(remainingToFetch > 0)) return [3 /*break*/, 3];
                    return [4 /*yield*/, (0, utilities_1.queue)(function (client) {
                            return client
                                .getKvRecords({
                                start: fetched,
                                n: remainingToFetch > constants_1.MAX_ADDR ? constants_1.MAX_ADDR : remainingToFetch,
                            })
                                .then(function (res) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    addressTags.push.apply(addressTags, res.records);
                                    fetched = res.fetched + fetched;
                                    remainingToFetch = res.total - fetched;
                                    return [2 /*return*/];
                                });
                            }); });
                        })];
                case 2:
                    _c.sent();
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/, addressTags];
            }
        });
    });
};
exports.fetchAddressTags = fetchAddressTags;
var removeAddressTags = function (tags) { return __awaiter(void 0, void 0, void 0, function () {
    var ids;
    return __generator(this, function (_a) {
        ids = tags.map(function (tag) { return "".concat(tag.id); });
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.removeKvRecords({ ids: ids }); })];
    });
}); };
exports.removeAddressTags = removeAddressTags;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\api\\addressTags.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\addresses.js", {"../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\utilities.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Capi%5Caddresses.js
      return function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchLedgerLegacyAddresses = exports.fetchLedgerLiveAddresses = exports.fetchSolanaAddresses = exports.fetchBtcWrappedSegwitAddresses = exports.fetchBtCSegwitAddresses = exports.fetchBtcLegacyAddresses = exports.fetchAddresses = void 0;
var constants_1 = require("../constants");
var utilities_1 = require("./utilities");
var fetchAddresses = function (overrides) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, (0, utilities_1.queue)(function (client) {
                return client
                    .getAddresses(__assign({ startPath: constants_1.DEFAULT_ETH_DERIVATION, n: constants_1.MAX_ADDR }, overrides))
                    .then(function (addrs) { return addrs.map(function (addr) { return "".concat(addr); }); });
            })];
    });
}); };
exports.fetchAddresses = fetchAddresses;
var fetchBtcLegacyAddresses = function (n, startPathIndex) {
    if (n === void 0) { n = constants_1.MAX_ADDR; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (0, exports.fetchAddresses)({
                    startPath: (0, utilities_1.getStartPath)(constants_1.BTC_LEGACY_DERIVATION, startPathIndex),
                    n: n,
                })];
        });
    });
};
exports.fetchBtcLegacyAddresses = fetchBtcLegacyAddresses;
var fetchBtCSegwitAddresses = function (n, startPathIndex) {
    if (n === void 0) { n = constants_1.MAX_ADDR; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (0, exports.fetchAddresses)({
                    startPath: (0, utilities_1.getStartPath)(constants_1.BTC_SEGWIT_DERIVATION, startPathIndex),
                    n: n,
                })];
        });
    });
};
exports.fetchBtCSegwitAddresses = fetchBtCSegwitAddresses;
var fetchBtcWrappedSegwitAddresses = function (n, startPathIndex) {
    if (n === void 0) { n = constants_1.MAX_ADDR; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (0, exports.fetchAddresses)({
                    startPath: (0, utilities_1.getStartPath)(constants_1.BTC_WRAPPED_SEGWIT_DERIVATION, startPathIndex),
                    n: n,
                })];
        });
    });
};
exports.fetchBtcWrappedSegwitAddresses = fetchBtcWrappedSegwitAddresses;
var fetchSolanaAddresses = function (n, startPathIndex) {
    if (n === void 0) { n = constants_1.MAX_ADDR; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (0, exports.fetchAddresses)({
                    startPath: (0, utilities_1.getStartPath)(constants_1.SOLANA_DERIVATION, startPathIndex, 2),
                    n: n,
                })];
        });
    });
};
exports.fetchSolanaAddresses = fetchSolanaAddresses;
var fetchLedgerLiveAddresses = function (n, startPathIndex) {
    if (n === void 0) { n = constants_1.MAX_ADDR; }
    return __awaiter(void 0, void 0, void 0, function () {
        var addresses, _loop_1, i;
        return __generator(this, function (_a) {
            addresses = [];
            _loop_1 = function (i) {
                addresses.push((0, utilities_1.queue)(function (client) {
                    return client
                        .getAddresses({
                        startPath: (0, utilities_1.getStartPath)(constants_1.LEDGER_LIVE_DERIVATION, startPathIndex + i, 2),
                        n: 1,
                    })
                        .then(function (addresses) { return addresses.map(function (address) { return "".concat(address); }); });
                }));
            };
            for (i = 0; i < n; i++) {
                _loop_1(i);
            }
            return [2 /*return*/, Promise.all(addresses)];
        });
    });
};
exports.fetchLedgerLiveAddresses = fetchLedgerLiveAddresses;
var fetchLedgerLegacyAddresses = function (n, startPathIndex) {
    if (n === void 0) { n = constants_1.MAX_ADDR; }
    return __awaiter(void 0, void 0, void 0, function () {
        var addresses, _loop_2, i;
        return __generator(this, function (_a) {
            addresses = [];
            _loop_2 = function (i) {
                addresses.push((0, utilities_1.queue)(function (client) {
                    return client
                        .getAddresses({
                        startPath: (0, utilities_1.getStartPath)(constants_1.LEDGER_LEGACY_DERIVATION, startPathIndex + i, 3),
                        n: 1,
                    })
                        .then(function (addresses) { return addresses.map(function (address) { return "".concat(address); }); });
                }));
            };
            for (i = 0; i < n; i++) {
                _loop_2(i);
            }
            return [2 /*return*/, Promise.all(addresses)];
        });
    });
};
exports.fetchLedgerLegacyAddresses = fetchLedgerLegacyAddresses;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\api\\addresses.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\index.js", {"./addressTags":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\addressTags.js","./addresses":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\addresses.js","./signing":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\signing.js","./utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\utilities.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Capi%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchActiveWallets = exports.pair = exports.connect = exports.setup = exports.getClient = void 0;
var utilities_1 = require("./utilities");
Object.defineProperty(exports, "getClient", { enumerable: true, get: function () { return utilities_1.getClient; } });
Object.defineProperty(exports, "setup", { enumerable: true, get: function () { return utilities_1.setup; } });
var utilities_2 = require("./utilities");
var connect = function (deviceId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, (0, utilities_2.queue)(function (client) { return client.connect(deviceId); })];
    });
}); };
exports.connect = connect;
var pair = function (pairingCode) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, (0, utilities_2.queue)(function (client) { return client.pair(pairingCode); })];
    });
}); };
exports.pair = pair;
var fetchActiveWallets = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, (0, utilities_2.queue)(function (client) { return client.fetchActiveWallet(); })];
    });
}); };
exports.fetchActiveWallets = fetchActiveWallets;
__exportStar(require("./addresses"), exports);
__exportStar(require("./addressTags"), exports);
__exportStar(require("./signing"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\api\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\signing.js", {"..":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js","../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\utilities.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Capi%5Csigning.js
      return function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signSolanaTx = exports.signBtcWrappedSegwitTx = exports.signBtcSegwitTx = exports.signBtcLegacyTx = exports.signMessage = exports.sign = void 0;
var __1 = require("..");
var constants_1 = require("../constants");
var utilities_1 = require("./utilities");
var sign = function (payload, overrides) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        tx = __assign({ data: {
                signerPath: constants_1.DEFAULT_ETH_DERIVATION,
                curveType: __1.Constants.SIGNING.CURVES.SECP256K1,
                hashType: __1.Constants.SIGNING.HASHES.KECCAK256,
                encodingType: __1.Constants.SIGNING.ENCODINGS.EVM,
                payload: payload,
            } }, overrides);
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.sign(tx); })];
    });
}); };
exports.sign = sign;
var signMessage = function (payload, overrides) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        tx = {
            data: __assign({ signerPath: constants_1.DEFAULT_ETH_DERIVATION, curveType: __1.Constants.SIGNING.CURVES.SECP256K1, hashType: __1.Constants.SIGNING.HASHES.KECCAK256, protocol: 'signPersonal', payload: payload }, overrides),
            currency: constants_1.CURRENCIES.ETH_MSG,
        };
        if ((0, utilities_1.isEIP712Payload)(payload)) {
            tx.data.protocol = 'eip712';
        }
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.sign(tx); })];
    });
}); };
exports.signMessage = signMessage;
var signBtcLegacyTx = function (payload) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        tx = {
            data: __assign({ signerPath: constants_1.BTC_LEGACY_DERIVATION }, payload),
            currency: 'BTC',
        };
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.sign(tx); })];
    });
}); };
exports.signBtcLegacyTx = signBtcLegacyTx;
var signBtcSegwitTx = function (payload) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        tx = {
            data: __assign({ signerPath: constants_1.BTC_SEGWIT_DERIVATION }, payload),
            currency: 'BTC',
        };
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.sign(tx); })];
    });
}); };
exports.signBtcSegwitTx = signBtcSegwitTx;
var signBtcWrappedSegwitTx = function (payload) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        tx = {
            data: __assign({ signerPath: constants_1.BTC_WRAPPED_SEGWIT_DERIVATION }, payload),
            currency: 'BTC',
        };
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.sign(tx); })];
    });
}); };
exports.signBtcWrappedSegwitTx = signBtcWrappedSegwitTx;
var signSolanaTx = function (payload, overrides) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        tx = {
            data: __assign({ signerPath: constants_1.SOLANA_DERIVATION, curveType: __1.Constants.SIGNING.CURVES.ED25519, hashType: __1.Constants.SIGNING.HASHES.NONE, encodingType: __1.Constants.SIGNING.ENCODINGS.SOLANA, payload: payload }, overrides),
        };
        return [2 /*return*/, (0, utilities_1.queue)(function (client) { return client.sign(tx); })];
    });
}); };
exports.signSolanaTx = signSolanaTx;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\api\\signing.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\state.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Capi%5Cstate.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setFunctionQueue = exports.getFunctionQueue = exports.setLoadClient = exports.loadClient = exports.setSaveClient = exports.saveClient = void 0;
var setSaveClient = function (fn) {
    exports.saveClient = fn;
};
exports.setSaveClient = setSaveClient;
var setLoadClient = function (fn) {
    exports.loadClient = fn;
};
exports.setLoadClient = setLoadClient;
var functionQueue;
var getFunctionQueue = function () { return functionQueue; };
exports.getFunctionQueue = getFunctionQueue;
var setFunctionQueue = function (queue) {
    functionQueue = queue;
};
exports.setFunctionQueue = setFunctionQueue;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\api\\state.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\utilities.js", {"..":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js","../client":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\client.js","./state":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\state.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Capi%5Cutilities.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEIP712Payload = exports.getStartPath = exports.getClient = exports.queue = exports.setup = void 0;
var __1 = require("..");
var client_1 = require("../client");
var state_1 = require("./state");
/**
 * `setup` initializes the Client and executes `connect()` if necessary. It returns a promise that
 * resolves to a boolean that indicates whether the Client is paired to the application to which it's
 * attempting to connect.
 */
var setup = function (_a) {
    var deviceId = _a.deviceId, password = _a.password, name = _a.name, getStoredClient = _a.getStoredClient, setStoredClient = _a.setStoredClient;
    return __awaiter(void 0, void 0, void 0, function () {
        var privKey, client_2, client, deviceId_1;
        return __generator(this, function (_b) {
            if (!getStoredClient)
                throw new Error('Client data getter required');
            (0, state_1.setSaveClient)(buildSaveClientFn(setStoredClient));
            if (!setStoredClient)
                throw new Error('Client data setter required');
            (0, state_1.setLoadClient)(buildLoadClientFn(getStoredClient));
            if (deviceId && password && name) {
                privKey = __1.Utils.generateAppSecret(deviceId, password, name);
                client_2 = new client_1.Client({ deviceId: deviceId, privKey: privKey, name: name });
                return [2 /*return*/, client_2.connect(deviceId).then(function (isPaired) {
                        (0, state_1.saveClient)(client_2.getStateData());
                        return isPaired;
                    })];
            }
            else {
                client = (0, state_1.loadClient)();
                if (!client)
                    throw new Error('Client not initialized');
                deviceId_1 = client.getDeviceId();
                if (!client.ephemeralPub && deviceId_1) {
                    return [2 /*return*/, (0, __1.connect)(deviceId_1)];
                }
                else {
                    (0, state_1.saveClient)(client.getStateData());
                    return [2 /*return*/, Promise.resolve(true)];
                }
            }
            return [2 /*return*/];
        });
    });
};
exports.setup = setup;
/**
 * `queue` is a function that wraps all functional API calls. It limits the number of concurrent
 * requests to the server to 1, and ensures that the client state data is saved after each call.
 * This is necessary because the ephemeral public key must be updated after each successful request,
 * and two concurrent requests could result in the same key being used twice or the wrong key being
 * written to memory locally.
 */
var queue = function (fn) {
    var client = (0, state_1.loadClient)();
    if (!client)
        throw new Error('Client not initialized');
    if (!(0, state_1.getFunctionQueue)()) {
        (0, state_1.setFunctionQueue)(Promise.resolve());
    }
    (0, state_1.setFunctionQueue)((0, state_1.getFunctionQueue)().then(function () {
        return fn(client)
            .catch(function (err) {
            // Empty the queue if any function call fails
            (0, state_1.setFunctionQueue)(Promise.resolve());
            throw err;
        })
            .then(function (returnValue) {
            (0, state_1.saveClient)(client.getStateData());
            return returnValue;
        });
    }));
    return (0, state_1.getFunctionQueue)();
};
exports.queue = queue;
var getClient = function () { return (state_1.loadClient ? (0, state_1.loadClient)() : null); };
exports.getClient = getClient;
var encodeClientData = function (clientData) {
    return Buffer.from(clientData).toString('base64');
};
var decodeClientData = function (clientData) {
    return Buffer.from(clientData, 'base64').toString();
};
var buildSaveClientFn = function (setStoredClient) {
    return function (clientData) {
        if (!clientData)
            return;
        var encodedData = encodeClientData(clientData);
        setStoredClient(encodedData);
    };
};
var buildLoadClientFn = function (getStoredClient) {
    return function () {
        var clientData = getStoredClient();
        if (!clientData)
            return undefined;
        var stateData = decodeClientData(clientData);
        if (!stateData)
            return undefined;
        var client = new client_1.Client({ stateData: stateData });
        if (!client)
            throw new Error('Client not initialized');
        return client;
    };
};
var getStartPath = function (defaultStartPath, addressIndex, // The value to increment `defaultStartPath`
pathIndex) {
    if (addressIndex === void 0) { addressIndex = 0; }
    if (pathIndex === void 0) { pathIndex = 4; }
    var startPath = defaultStartPath;
    if (addressIndex > 0) {
        startPath[pathIndex] = defaultStartPath[pathIndex] + addressIndex;
    }
    return startPath;
};
exports.getStartPath = getStartPath;
var isEIP712Payload = function (payload) {
    return typeof payload !== 'string' &&
        'types' in payload &&
        'domain' in payload &&
        'primaryType' in payload &&
        'message' in payload;
};
exports.isEIP712Payload = isEIP712Payload;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\api\\utilities.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\bitcoin.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","bech32":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\bech32\\dist\\index.js","bs58check":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bs58check\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js/lib/hash/ripemd":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\ripemd.js","hash.js/lib/hash/sha":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\sha.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cbitcoin.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Util for Bitcoin-specific functionality
var bech32_1 = require("bech32");
var bs58check_1 = __importDefault(require("bs58check"));
var ripemd_1 = require("hash.js/lib/hash/ripemd");
var sha_1 = require("hash.js/lib/hash/sha");
var constants_1 = require("./constants");
var protocol_1 = require("./protocol");
var DEFAULT_SEQUENCE = 0xffffffff;
var DEFAULT_SIGHASH_BUFFER = Buffer.from('01', 'hex'); // SIGHASH_ALL = 0x01
var PURPOSES = constants_1.BIP_CONSTANTS.PURPOSES, COINS = constants_1.BIP_CONSTANTS.COINS;
var OP = {
    ZERO: 0x00,
    HASH160: 0xa9,
    DUP: 0x76,
    EQUAL: 0x87,
    EQUALVERIFY: 0x88,
    CHECKSIG: 0xac,
};
var SEGWIT_V0 = 0x00;
var SEGWIT_NATIVE_V0_PREFIX = 'bc';
var SEGWIT_NATIVE_V0_TESTNET_PREFIX = 'tb';
var FMT_SEGWIT_NATIVE_V0 = 0xd0;
var FMT_SEGWIT_NATIVE_V0_TESTNET = 0xf0;
var FMT_SEGWIT_WRAPPED = 0x05;
var FMT_SEGWIT_WRAPPED_TESTNET = 0xc4;
var FMT_LEGACY = 0x00;
var FMT_LEGACY_TESTNET = 0x6f;
var BTC_SCRIPT_TYPE_P2PKH = 0x01;
var BTC_SCRIPT_TYPE_P2SH_P2WPKH = 0x03;
var BTC_SCRIPT_TYPE_P2WPKH_V0 = 0x04;
// We need to build two different objects here:
// 1. bitcoinjs-lib TransactionBuilder object, which will be used in conjunction
//    with the returned signatures to build and serialize the transaction before
//    broadcasting it. We will replace `bitcoinjs-lib`'s signatures with the ones
//    we get from the Lattice
// 2. The serialized Lattice request, which includes data (outlined in the specification)
//    that is needed to sign all of the inputs and build a change output.
// @inputs (contained in `data`)
// `prevOuts`: an array of objects with the following properties:
//           a. txHash
//           b. value
//           c. index          -- the index of the output in the transaction
//           d. signerPath -- the path of the address in our wallet that is signing this input
// `recipient`: Receiving address, which must be converted to a pubkeyhash
// `value`:     Number of satoshis to send the recipient
// `fee`:       Number of satoshis to use for a transaction fee (should have been calculated)
//              already based on the number of inputs plus two outputs
// `version`:   Transaction version of the inputs. All inputs must be of the same version!
// `isSegwit`: a boolean which determines how we serialize the data and parameterize txb
var buildBitcoinTxRequest = function (data) {
    var prevOuts = data.prevOuts, recipient = data.recipient, value = data.value, changePath = data.changePath, fee = data.fee;
    if (!changePath)
        throw new Error('No changePath provided.');
    if (changePath.length !== 5)
        throw new Error('Please provide a full change path.');
    // Serialize the request
    var payload = Buffer.alloc(59 + 69 * prevOuts.length);
    var off = 0;
    // Change version byte (a.k.a. address format byte)
    var changeFmt = getAddressFormat(changePath);
    payload.writeUInt8(changeFmt, 0);
    off++;
    // Build the change data
    payload.writeUInt32LE(changePath.length, off);
    off += 4;
    for (var i = 0; i < changePath.length; i++) {
        payload.writeUInt32LE(changePath[i], off);
        off += 4;
    }
    // Fee is a param
    payload.writeUInt32LE(fee, off);
    off += 4;
    var dec = decodeAddress(recipient);
    // Parameterize the recipient output
    payload.writeUInt8(dec.versionByte, off);
    off++;
    dec.pkh.copy(payload, off);
    off += dec.pkh.length;
    writeUInt64LE(value, payload, off);
    off += 8;
    // Build the inputs from the previous outputs
    payload.writeUInt8(prevOuts.length, off);
    off++;
    var inputSum = 0;
    prevOuts.forEach(function (input) {
        if (!input.signerPath || input.signerPath.length !== 5) {
            throw new Error('Full recipient path not specified ');
        }
        payload.writeUInt32LE(input.signerPath.length, off);
        off += 4;
        for (var i = 0; i < input.signerPath.length; i++) {
            payload.writeUInt32LE(input.signerPath[i], off);
            off += 4;
        }
        payload.writeUInt32LE(input.index, off);
        off += 4;
        writeUInt64LE(input.value, payload, off);
        off += 8;
        inputSum += input.value;
        var scriptType = getScriptType(input);
        payload.writeUInt8(scriptType, off);
        off++;
        if (!Buffer.isBuffer(input.txHash))
            input.txHash = Buffer.from(input.txHash, 'hex');
        input.txHash.copy(payload, off);
        off += input.txHash.length;
    });
    // Send them back!
    return {
        payload: payload,
        schema: protocol_1.LatticeSignSchema.bitcoin,
        origData: data,
        changeData: {
            // This data helps fill in the change output
            value: inputSum - (value + fee),
        },
    };
};
// Serialize a transaction consisting of inputs, outputs, and some
// metadata
// -- inputs  = { hash, index, sig, pubkey }
// -- outputs = { value, recipient }  // expects an address string for `recipient`
// -- isSegwitSpend = true if the inputs are being spent using segwit
//                    (NOTE: either ALL are being spent, or none are)
// -- lockTime = Will probably always be 0
var serializeTx = function (data) {
    var inputs = data.inputs, outputs = data.outputs, _a = data.lockTime, lockTime = _a === void 0 ? 0 : _a;
    var payload = Buffer.alloc(4);
    var off = 0;
    // Always use version 2
    var version = 2;
    var useWitness = needsWitness(inputs);
    payload.writeUInt32LE(version, off);
    off += 4;
    if (useWitness) {
        payload = concat(payload, Buffer.from('00', 'hex')); // marker = 0x00
        payload = concat(payload, Buffer.from('01', 'hex')); // flag = 0x01
    }
    // Serialize signed inputs
    var numInputs = getVarInt(inputs.length);
    payload = concat(payload, numInputs);
    off += numInputs.length;
    inputs.forEach(function (input) {
        payload = concat(payload, input.hash.reverse());
        off += input.hash.length;
        var index = getU32LE(input.index);
        payload = concat(payload, index);
        off += index.length;
        var scriptType = getScriptType(input);
        // Build the sigScript. Note that p2wpkh does not have a scriptSig.
        if (scriptType === BTC_SCRIPT_TYPE_P2SH_P2WPKH) {
            // Build a vector (varSlice of varSlice) containing the redeemScript
            var redeemScript = buildRedeemScript(input.pubkey);
            var redeemScriptLen = getVarInt(redeemScript.length);
            var slice = Buffer.concat([redeemScriptLen, redeemScript]);
            var sliceLen = getVarInt(slice.length);
            payload = concat(payload, sliceLen);
            off += sliceLen.length;
            payload = concat(payload, slice);
            off += slice.length;
        }
        else if (scriptType === BTC_SCRIPT_TYPE_P2PKH) {
            // Build the signature + pubkey script to spend this input
            var slice = buildSig(input.sig, input.pubkey);
            payload = concat(payload, slice);
            off += slice.length;
        }
        else if (scriptType === BTC_SCRIPT_TYPE_P2WPKH_V0) {
            var emptyScript = Buffer.from('00', 'hex');
            payload = concat(payload, emptyScript);
            off += 1;
        }
        // Use the default sequence for all transactions
        var sequence = getU32LE(DEFAULT_SEQUENCE);
        payload = concat(payload, sequence);
        off += sequence.length;
    });
    // Serialize outputs
    var numOutputs = getVarInt(outputs.length);
    payload = concat(payload, numOutputs);
    off += numOutputs.length;
    outputs.forEach(function (output) {
        var value = getU64LE(output.value);
        payload = concat(payload, value);
        off += value.length;
        // Build the output locking script and write it as a var slice
        var script = buildLockingScript(output.recipient);
        var scriptLen = getVarInt(script.length);
        payload = concat(payload, scriptLen);
        off += scriptLen.length;
        payload = concat(payload, script);
        off += script.length;
    });
    // Add witness data if needed
    if (useWitness) {
        var sigs = [];
        var pubkeys = [];
        for (var i = 0; i < inputs.length; i++) {
            sigs.push(inputs[i].sig);
            pubkeys.push(inputs[i].pubkey);
        }
        var witnessSlice = buildWitness(sigs, pubkeys);
        payload = concat(payload, witnessSlice);
        off += witnessSlice.length;
    }
    // Finish with locktime
    return Buffer.concat([payload, getU32LE(lockTime)]).toString('hex');
};
// Convert a pubkeyhash to a bitcoin base58check address with a version byte
var getBitcoinAddress = function (pubkeyhash, version) {
    var bech32Prefix = null;
    var bech32Version = null;
    if (version === FMT_SEGWIT_NATIVE_V0) {
        bech32Prefix = SEGWIT_NATIVE_V0_PREFIX;
        bech32Version = SEGWIT_V0;
    }
    else if (version === FMT_SEGWIT_NATIVE_V0_TESTNET) {
        bech32Prefix = SEGWIT_NATIVE_V0_TESTNET_PREFIX;
        bech32Version = SEGWIT_V0;
    }
    if (bech32Prefix !== null && bech32Version !== null) {
        var words = bech32_1.bech32.toWords(pubkeyhash);
        words.unshift(bech32Version);
        return bech32_1.bech32.encode(bech32Prefix, words);
    }
    else {
        return bs58check_1.default.encode(Buffer.concat([Buffer.from([version]), pubkeyhash]));
    }
};
// Builder utils
//-----------------------
function buildRedeemScript(pubkey) {
    var redeemScript = Buffer.alloc(22);
    var shaHash = Buffer.from((0, sha_1.sha256)().update(pubkey).digest('hex'), 'hex');
    var pubkeyhash = Buffer.from((0, ripemd_1.ripemd160)().update(shaHash).digest('hex'), 'hex');
    redeemScript.writeUInt8(OP.ZERO, 0);
    redeemScript.writeUInt8(pubkeyhash.length, 1);
    pubkeyhash.copy(redeemScript, 2);
    return redeemScript;
}
// Var slice of signature + var slice of pubkey
function buildSig(sig, pubkey) {
    sig = Buffer.concat([sig, DEFAULT_SIGHASH_BUFFER]);
    var sigLen = getVarInt(sig.length);
    var pubkeyLen = getVarInt(pubkey.length);
    var slice = Buffer.concat([sigLen, sig, pubkeyLen, pubkey]);
    var len = getVarInt(slice.length);
    return Buffer.concat([len, slice]);
}
// Witness is written as a "vector", which is a list of varSlices
// prefixed by the number of items
function buildWitness(sigs, pubkeys) {
    var witness = Buffer.alloc(0);
    // Two items in each vector (sig, pubkey)
    var len = Buffer.alloc(1);
    len.writeUInt8(2, 0);
    for (var i = 0; i < sigs.length; i++) {
        var sig = Buffer.concat([sigs[i], DEFAULT_SIGHASH_BUFFER]);
        var sigLen = getVarInt(sig.length);
        var pubkey = pubkeys[i];
        var pubkeyLen = getVarInt(pubkey.length);
        witness = Buffer.concat([witness, len, sigLen, sig, pubkeyLen, pubkey]);
    }
    return witness;
}
// Locking script buiders
//-----------------------
function buildLockingScript(address) {
    var dec = decodeAddress(address);
    switch (dec.versionByte) {
        case FMT_SEGWIT_NATIVE_V0:
        case FMT_SEGWIT_NATIVE_V0_TESTNET:
            return buildP2wpkhLockingScript(dec.pkh);
        case FMT_SEGWIT_WRAPPED:
        case FMT_SEGWIT_WRAPPED_TESTNET:
            return buildP2shLockingScript(dec.pkh);
        case FMT_LEGACY:
        case FMT_LEGACY_TESTNET:
            return buildP2pkhLockingScript(dec.pkh);
        default:
            throw new Error("Unknown version byte: ".concat(dec.versionByte, ". Cannot build BTC transaction."));
    }
}
function buildP2pkhLockingScript(pubkeyhash) {
    var out = Buffer.alloc(5 + pubkeyhash.length);
    var off = 0;
    out.writeUInt8(OP.DUP, off);
    off++;
    out.writeUInt8(OP.HASH160, off);
    off++;
    out.writeUInt8(pubkeyhash.length, off);
    off++;
    pubkeyhash.copy(out, off);
    off += pubkeyhash.length;
    out.writeUInt8(OP.EQUALVERIFY, off);
    off++;
    out.writeUInt8(OP.CHECKSIG, off);
    off++;
    return out;
}
function buildP2shLockingScript(pubkeyhash) {
    var out = Buffer.alloc(3 + pubkeyhash.length);
    var off = 0;
    out.writeUInt8(OP.HASH160, off);
    off++;
    out.writeUInt8(pubkeyhash.length, off);
    off++;
    pubkeyhash.copy(out, off);
    off += pubkeyhash.length;
    out.writeUInt8(OP.EQUAL, off);
    off++;
    return out;
}
function buildP2wpkhLockingScript(pubkeyhash) {
    var out = Buffer.alloc(2 + pubkeyhash.length);
    out.writeUInt8(OP.ZERO, 0);
    out.writeUInt8(pubkeyhash.length, 1);
    pubkeyhash.copy(out, 2);
    return out;
}
// Static Utils
//----------------------
function concat(base, addition) {
    return Buffer.concat([base, addition]);
}
function getU64LE(x) {
    var buffer = Buffer.alloc(8);
    writeUInt64LE(x, buffer, 0);
    return buffer;
}
function getU32LE(x) {
    var buffer = Buffer.alloc(4);
    buffer.writeUInt32LE(x, 0);
    return buffer;
}
function getVarInt(x) {
    var buffer;
    if (x < 0xfd) {
        buffer = Buffer.alloc(1);
        buffer.writeUInt8(x, 0);
    }
    else if (x <= 0xffff) {
        buffer = Buffer.alloc(3);
        buffer.writeUInt8(0xfd, 0);
        buffer.writeUInt16LE(x, 1);
    }
    else if (x < 0xffffffff) {
        buffer = Buffer.alloc(5);
        buffer.writeUInt8(0xfe, 0);
        buffer.writeUInt32LE(x, 1);
    }
    else {
        buffer = Buffer.alloc(9);
        buffer.writeUInt8(0xff, 0);
        buffer.writeUInt32LE(x >>> 0, 1);
        buffer.writeUInt32LE((x / 0x100000000) | 0, 5);
    }
    return buffer;
}
function writeUInt64LE(n, buf, off) {
    if (typeof n === 'number')
        n = n.toString(16);
    var preBuf = Buffer.alloc(8);
    var nStr = n.length % 2 === 0 ? n.toString(16) : "0".concat(n.toString(16));
    var nBuf = Buffer.from(nStr, 'hex');
    nBuf.reverse().copy(preBuf, 0);
    preBuf.copy(buf, off);
    return preBuf;
}
function decodeAddress(address) {
    var versionByte, pkh;
    try {
        // Attempt to base58 decode the address. This will work for older
        // P2PKH, P2SH, and P2SH-P2WPKH addresses
        versionByte = bs58check_1.default.decode(address)[0];
        pkh = bs58check_1.default.decode(address).slice(1);
    }
    catch (err) {
        // If we could not base58 decode, the address must be bech32 encoded.
        // If neither decoding method works, the address is invalid.
        try {
            var bech32Dec = bech32_1.bech32.decode(address);
            if (bech32Dec.prefix === SEGWIT_NATIVE_V0_PREFIX) {
                versionByte = FMT_SEGWIT_NATIVE_V0;
            }
            else if (bech32Dec.prefix === SEGWIT_NATIVE_V0_TESTNET_PREFIX) {
                versionByte = FMT_SEGWIT_NATIVE_V0_TESTNET;
            }
            else {
                throw new Error('Unsupported prefix: must be bc or tb.');
            }
            // Make sure we decoded
            if (bech32Dec.words[0] !== 0) {
                throw new Error("Unsupported segwit version: must be 0, got ".concat(bech32Dec.words[0]));
            }
            // Make sure address type is supported.
            // We currently only support P2WPKH addresses, which bech-32decode to 33 words.
            // P2WSH addresses are 53 words, but we do not support them.
            // Not sure what other address types could exist, but if they exist we don't
            // support them either.
            if (bech32Dec.words.length !== 33) {
                var isP2wpsh = bech32Dec.words.length === 53;
                throw new Error("Unsupported address".concat(isP2wpsh ? ' (P2WSH not supported)' : '', ": ").concat(address));
            }
            pkh = Buffer.from(bech32_1.bech32.fromWords(bech32Dec.words.slice(1)));
        }
        catch (err) {
            throw new Error("Unable to decode address: ".concat(address, ": ").concat(err.message));
        }
    }
    return { versionByte: versionByte, pkh: pkh };
}
// Determine the address format (a.k.a. "version") depending on the
// purpose of the dervation path.
function getAddressFormat(path) {
    if (path.length < 2)
        throw new Error('Path must be >1 index');
    var purpose = path[0];
    var coin = path[1];
    if (purpose === PURPOSES.BTC_SEGWIT && coin === COINS.BTC) {
        return FMT_SEGWIT_NATIVE_V0;
    }
    else if (purpose === PURPOSES.BTC_SEGWIT && coin === COINS.BTC_TESTNET) {
        return FMT_SEGWIT_NATIVE_V0_TESTNET;
    }
    else if (purpose === PURPOSES.BTC_WRAPPED_SEGWIT && coin === COINS.BTC) {
        return FMT_SEGWIT_WRAPPED;
    }
    else if (purpose === PURPOSES.BTC_WRAPPED_SEGWIT &&
        coin === COINS.BTC_TESTNET) {
        return FMT_SEGWIT_WRAPPED_TESTNET;
    }
    else if (purpose === PURPOSES.BTC_LEGACY && coin === COINS.BTC) {
        return FMT_LEGACY;
    }
    else if (purpose === PURPOSES.BTC_LEGACY && coin === COINS.BTC_TESTNET) {
        return FMT_LEGACY_TESTNET;
    }
    else {
        throw new Error('Invalid Bitcoin path provided. Cannot determine address format.');
    }
}
// Determine the script type for an input based on its owner's derivation
// path's `purpose` index.
// We do not support p2sh and only issue single-key addresses from the Lattice
// so we can determine this based on path alone.
function getScriptType(input) {
    switch (input.signerPath[0]) {
        case PURPOSES.BTC_LEGACY:
            return BTC_SCRIPT_TYPE_P2PKH;
        case PURPOSES.BTC_WRAPPED_SEGWIT:
            return BTC_SCRIPT_TYPE_P2SH_P2WPKH;
        case PURPOSES.BTC_SEGWIT:
            return BTC_SCRIPT_TYPE_P2WPKH_V0;
        default:
            throw new Error("Unsupported path purpose (".concat(input.signerPath[0], "): cannot determine BTC script type."));
    }
}
// Determine if a a transaction should have a witness portion.
// This will return true if any input is p2sh(p2wpkh) or p2wpkh.
// We determine the script type based on the derivation path.
function needsWitness(inputs) {
    var w = false;
    inputs.forEach(function (input) {
        if (input.signerPath[0] === PURPOSES.BTC_SEGWIT ||
            input.signerPath[0] === PURPOSES.BTC_WRAPPED_SEGWIT) {
            w = true;
        }
    });
    return w;
}
exports.default = {
    buildBitcoinTxRequest: buildBitcoinTxRequest,
    serializeTx: serializeTx,
    getBitcoinAddress: getBitcoinAddress,
    getAddressFormat: getAddressFormat,
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\bitcoin.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\calldata\\evm.js", {"@ethersproject/abi":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethersproject\\abi\\lib\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","js-sha3":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Ccalldata%5Cevm.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceNestedDefs = exports.getNestedCalldata = exports.parseCanonicalName = exports.parseSolidityJSONABI = void 0;
var js_sha3_1 = require("js-sha3");
var abi_1 = require("@ethersproject/abi");
/**
 * Look through an ABI definition to see if there is a function that matches the signature provided.
 * @param sig    a 0x-prefixed hex string containing 4 bytes of info
 * @param abi    a Solidity JSON ABI structure ([external link](https://docs.ethers.io/v5/api/utils/abi/formats/#abi-formats--solidity))
 * @returns      Buffer containing RLP-serialized array of calldata info to pass to signing request
 * @public
 */
var parseSolidityJSONABI = function (sig, abi) {
    sig = coerceSig(sig);
    // Find the first match in the ABI
    var match = abi
        .filter(function (item) { return item.type === 'function'; })
        .find(function (item) {
        var def = parseDef(item);
        var funcSig = getFuncSig(def.canonicalName);
        return funcSig === sig;
    });
    if (match) {
        var def = parseDef(match).def;
        return { def: def };
    }
    throw new Error('Unable to find matching function in ABI');
};
exports.parseSolidityJSONABI = parseSolidityJSONABI;
/**
 * Convert a canonical name into an ABI definition that can be included with calldata to a general
 * "2", "2.1", "3")
 * @param sig    a 0x-prefixed hex string containing 4 bytes of info
 * @param name   canonical name of the function
 * @returns      Buffer containing RLP-serialized array of calldata info to pass to signing request
 * @public
 */
var parseCanonicalName = function (sig, name) {
    sig = coerceSig(sig);
    if (sig !== getFuncSig(name)) {
        throw new Error('Name does not match provided sig.');
    }
    var def = [];
    // Get the function name
    var paramStart = name.indexOf('(');
    if (paramStart < 0) {
        throw new Error(BAD_CANONICAL_ERR);
    }
    def.push(name.slice(0, paramStart));
    name = name.slice(paramStart + 1);
    var paramDef = [];
    while (name.length > 1) {
        // scan until the terminating ')'
        var typeStr = popTypeStrFromCanonical(name);
        paramDef = paramDef.concat(parseTypeStr(typeStr));
        name = name.slice(typeStr.length + 1);
    }
    var parsedParamDef = parseParamDef(paramDef);
    return def.concat(parsedParamDef);
};
exports.parseCanonicalName = parseCanonicalName;
/**
 * Pull out nested calldata which may correspond to nested ABI definitions.
 * This is relevant for e.g. `multicall` patterns.
 * A def may be nested if the underlying type is `bytes` or `bytes[]` and
 * the calldata parm is of size (4 + 32*n).
 * @param def - calldata decoder data for a def
 * @param calldata - Buffer containing full calldata payload
 * @return -  Array of calldata params, or null values. If the return
 *            item has data (0x-prefixed hex string), it should be
 *            checked as a possible nested def
 */
var getNestedCalldata = function (def, calldata) {
    var possibleNestedDefs = [];
    // Skip past first item, which is the function name
    var defParams = def.slice(1);
    var strParams = getParamStrNames(defParams);
    var coder = new abi_1.AbiCoder();
    var decoded = coder.decode(strParams, '0x' + calldata.slice(4).toString('hex'));
    function couldBeNestedDef(x) {
        return (x.length - 4) % 32 === 0;
    }
    decoded.forEach(function (paramData, i) {
        if (isBytesType(defParams[i])) {
            var nestedDefIsPossible_1 = true;
            if (isBytesArrItem(defParams[i])) {
                // `bytes[]` type. Decode all underlying `bytes` items and
                // do size checks on those.
                // NOTE: We only do this for `bytes[]` but could, in the future,
                // extend to more complex array structures if we see nested defs
                // in this pattern. However, we have only ever seen `bytes[]`, which
                // is typically used in `multicall` patterns
                paramData.forEach(function (nestedParamDatum) {
                    var nestedParamDatumBuf = Buffer.from(nestedParamDatum.slice(2), 'hex');
                    if (!couldBeNestedDef(nestedParamDatumBuf)) {
                        nestedDefIsPossible_1 = false;
                    }
                });
            }
            else if (isBytesItem(defParams[i])) {
                // Regular `bytes` type - perform size check
                var paramDataBuf = Buffer.from(paramData.slice(2), 'hex');
                nestedDefIsPossible_1 = couldBeNestedDef(paramDataBuf);
            }
            else {
                // Unknown `bytes` item type
                nestedDefIsPossible_1 = false;
            }
            // If the data could contain a nested def (determined based on
            // data size of the item), add the paramData to the return array.
            possibleNestedDefs.push(nestedDefIsPossible_1 ? paramData : null);
        }
        else {
            // No nested defs for non-bytes types
            possibleNestedDefs.push(null);
        }
    });
    return possibleNestedDefs;
};
exports.getNestedCalldata = getNestedCalldata;
/**
 * If applicable, update decoder data to represent nested
 * definitions, which are used in e.g. multicall patterns.
 * This will update `def` in place and return it with any
 * additional info necessary.
 * @param def - Decoder data for a specific calldata function (def)
 * @param nestedDefs - Array containing a possible set of nested
 *                     defs which must be added to `def`
 * @return - Possibly modified version of `def`
 */
var replaceNestedDefs = function (def, nestedDefs) {
    for (var i = 0; i < nestedDefs.length; i++) {
        var isArrItem = isBytesArrItem(def[1 + i]);
        var isItem = isBytesItem(def[1 + i]);
        if (nestedDefs[i] !== null && (isArrItem || isItem)) {
            // Update the def item type to indicate it will hold
            // one or more nested definitions
            def[1 + i][1] = EVM_TYPES.indexOf('nestedDef');
            // Add nested def(s) in in an array. If this is an array
            // item it means the nestedDefs should already be in an
            // array. Otherwise we need to wrap the single nested
            // def in an array to keep the data type consistent.
            var defs = isArrItem ? nestedDefs[i] : [nestedDefs[i]];
            def[1 + i] = def[1 + i].concat([defs]);
        }
    }
    return def;
};
exports.replaceNestedDefs = replaceNestedDefs;
/**
 * Convert a canonical name to a function selector (a.k.a. "sig")
 * @internal
 */
function getFuncSig(canonicalName) {
    return "0x".concat((0, js_sha3_1.keccak256)(canonicalName).slice(0, 8));
}
/**
 * Ensure the sig is properly formatted
 */
function coerceSig(sig) {
    if (typeof sig !== 'string' || (sig.length !== 10 && sig.length !== 8)) {
        throw new Error('`sig` must be a hex string with 4 bytes of data.');
    }
    if (sig.length === 8) {
        sig = "0x".concat(sig);
    }
    return sig;
}
/**
 * Convert calldata param definitions into an array of their
 * canonical string names.
 * Returns an array of string names that are consumable by
 * the @ethersproject/abi AbiCoder decoder instance.
 * @param defParams - Array of def params
 * @internal
 */
function getParamStrNames(defParams) {
    var strNames = [];
    var _loop_1 = function (i) {
        var param = defParams[i];
        var s = EVM_TYPES[param[1]];
        if (param[2]) {
            s = "".concat(s).concat(param[2] * 8);
        }
        if (param[3].length > 0) {
            param[3].forEach(function (d) {
                if (param[3][d] === 0) {
                    s = "".concat(s, "[]");
                }
                else {
                    s = "".concat(s, "[").concat(param[3][d], "]");
                }
            });
        }
        if (param[4]) {
            // Tuple - get nested type names
            var nested = getParamStrNames(param[4]);
            s = "".concat(s, "(").concat(nested.join(','), ")");
        }
        strNames.push(s);
    };
    for (var i = 0; i < defParams.length; i++) {
        _loop_1(i);
    }
    return strNames;
}
/**
 * Take the next type from a canonical definition string. Note that the string can be that of a
 * tuple. NOTE: The string should start at the index after the leading '('
 * @internal
 */
function popTypeStrFromCanonical(subName) {
    if (isTuple(subName)) {
        return getTupleName(subName);
    }
    else if (subName.indexOf(',') > -1) {
        // Normal non-tuple param
        return subName.slice(0, subName.indexOf(','));
    }
    else if (subName.indexOf(')') > -1) {
        // Last non-tuple param in the name
        return subName.slice(0, subName.indexOf(')'));
    }
    throw new Error(BAD_CANONICAL_ERR);
}
/**
 * Parse a type string, e.g. 'uint256'. Converts the string to an array of EVMParamInfo, which may
 * have nested structure if there are tuples.
 * @internal
 */
function parseTypeStr(typeStr) {
    // Non-tuples can be decoded without worrying about recursion
    if (!isTuple(typeStr)) {
        return [parseBasicTypeStr(typeStr)];
    }
    // Tuples may require recursion
    var param = {
        szBytes: 0,
        typeIdx: EVM_TYPES.indexOf('tuple'),
        arraySzs: [],
    };
    // Get the full tuple param name and separate out the array stuff
    var typeStrLessArr = getTupleName(typeStr, false);
    var typeStrArr = typeStr.slice(typeStrLessArr.length);
    param.arraySzs = getArraySzs(typeStrArr);
    // Slice off the leading paren
    typeStrLessArr = typeStrLessArr.slice(1);
    // Parse each nested param
    var paramArr = [];
    while (typeStrLessArr.length > 0) {
        var subType = popTypeStrFromCanonical(typeStrLessArr);
        typeStrLessArr = typeStrLessArr.slice(subType.length + 1);
        paramArr = paramArr.concat(parseTypeStr(subType));
    }
    // There must be at least one sub-param in the tuple
    if (!paramArr.length) {
        throw new Error(BAD_CANONICAL_ERR);
    }
    return [param, paramArr];
}
/**
 * Convert a basic type (e.g. 'uint256') from a string to EVMParamInfo type.
 * @internal
 */
function parseBasicTypeStr(typeStr) {
    var param = {
        szBytes: 0,
        typeIdx: 0,
        arraySzs: [],
    };
    var found = false;
    EVM_TYPES.forEach(function (t, i) {
        if (typeStr.indexOf(t) > -1 && !found) {
            param.typeIdx = i;
            param.arraySzs = getArraySzs(typeStr);
            var arrStart = param.arraySzs.length > 0 ? typeStr.indexOf('[') : typeStr.length;
            var typeStrNum = typeStr.slice(t.length, arrStart);
            if (parseInt(typeStrNum)) {
                param.szBytes = parseInt(typeStrNum) / 8;
                if (param.szBytes > 32) {
                    throw new Error(BAD_CANONICAL_ERR);
                }
            }
            found = true;
        }
    });
    if (!found) {
        throw new Error(BAD_CANONICAL_ERR);
    }
    return param;
}
/**
 * Parse an Etherscan definition into a calldata structure that the Lattice EVM decoder can handle
 * (EVMDef). This function may recurse if there are tuple types.
 * @internal
 */
function parseDef(item, canonicalName, def, recursed) {
    if (canonicalName === void 0) { canonicalName = ''; }
    if (def === void 0) { def = []; }
    if (recursed === void 0) { recursed = false; }
    // Function name. Can be an empty string.
    if (!recursed) {
        var nameStr = item.name || '';
        def.push(nameStr);
        canonicalName += nameStr;
    }
    // Loop through params
    if (item.inputs) {
        canonicalName += '(';
        item.inputs.forEach(function (input) {
            // Convert the input to a flat param that we can serialize
            var flatParam = getFlatParam(input);
            if (input.type.indexOf('tuple') > -1 && input.components) {
                // For tuples we need to recurse
                var recursed_1 = parseDef({ inputs: input.components }, canonicalName, [], true);
                canonicalName = recursed_1.canonicalName;
                // Add brackets if this is a tuple array and also add a comma
                canonicalName += "".concat(input.type.slice(5), ",");
                flatParam.push(recursed_1.def);
            }
            else {
                canonicalName += input.type;
                canonicalName += ',';
            }
            def.push(flatParam);
        });
        // Take off the last comma. Note that we do not want to slice if the last param was a tuple,
        // since we want to keep that `)`
        if (canonicalName[canonicalName.length - 1] === ',') {
            canonicalName = canonicalName.slice(0, canonicalName.length - 1);
        }
        // Add the closing parens
        canonicalName += ')';
    }
    return { def: def, canonicalName: canonicalName };
}
/**
 * Convert a set of EVMParamInfo objects into an array that can be serialized into decoder info that
 * can be passed with the signing request. NOTE: We do not know parameter names, so we just number
 * them
 * @internal
 */
function parseParamDef(def, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var parsedDef = [];
    var numTuples = 0;
    def.forEach(function (param, i) {
        if (Array.isArray(param)) {
            // Arrays indicate nested params inside a tuple and always come after the initial tuple type
            // info. Recurse to parse nested tuple params and append them to the most recent.
            parsedDef[parsedDef.length - 1].push(parseParamDef(param, "".concat(i, "-")));
        }
        else {
            // If this is not tuple info, add the flat param info to the def
            parsedDef.push([
                "#".concat(prefix).concat(i + 1 - numTuples),
                param.typeIdx,
                param.szBytes,
                param.arraySzs,
            ]);
        }
        // Tuple
        if (param.typeIdx === EVM_TYPES.indexOf('tuple')) {
            numTuples += 1;
        }
    });
    return parsedDef;
}
/**
 * Convert a param into an EVMParamInfo object before flattening its data into an array.
 * @internal
 */
function getFlatParam(input) {
    if (!input.type) {
        throw new Error('No type in input');
    }
    var param = [input.name];
    var _a = getParamTypeInfo(input.type), typeIdx = _a.typeIdx, szBytes = _a.szBytes, arraySzs = _a.arraySzs;
    param.push(typeIdx);
    param.push(szBytes);
    param.push(arraySzs);
    return param;
}
/**
 * Convert a param type string into an EVMParamInfo object with attributes:
 * 1. paramName -     name of the parameter. This piece of data is unverified, so it will display
 *                    differently if the user has the function saved in secure storage.
 * 2. paramType -     basic type of param. Firmware has an enum with 7 values.
 * 3. paramSzBytes -  number of bytes representing this param. Only certain types can have nonzero
 *                    value for this. For example, a `uint` with a 4 in this slot would be uint32
 *                    (8*4 = 32). Maximum number of bytes is always 32 because these types can only
 *                    be used in single 32 byte words.
 * @internal
 */
function getParamTypeInfo(type) {
    var param = {
        szBytes: 0,
        typeIdx: 0,
        arraySzs: [],
    };
    var baseType;
    EVM_TYPES.forEach(function (t, i) {
        if (type.indexOf(t) > -1 && !baseType) {
            baseType = t;
            param.typeIdx = i;
        }
    });
    // Get the array size, if any
    param.arraySzs = getArraySzs(type);
    // Determine where to search for expanded size
    var szIdx = param.arraySzs.length > 0 ? type.indexOf('[') : type.length;
    if (['uint', 'int', 'bytes'].indexOf(baseType) > -1) {
        // If this can have a fixed size, capture that
        var szBits = parseInt(type.slice(baseType.length, szIdx)) || 0;
        if (szBits > 256) {
            throw new Error('Invalid param size');
        }
        param.szBytes = szBits / 8;
    }
    else {
        // No fixed size in the type
        param.szBytes = 0;
    }
    return param;
}
/**
 * Determine the dimensions of an array type. These dimensions can be either fixed or variable size.
 * Returns an array of sizes. Ex: uint256[][] -> [0, 0], uint256[1][3] -> [1, 3], uint256 -> []
 * @internal
 */
function getArraySzs(type) {
    if (typeof type !== 'string') {
        throw new Error('Invalid type');
    }
    var szs = [];
    var t1 = type;
    while (t1.length > 0) {
        var openIdx = t1.indexOf('[');
        if (openIdx < 0) {
            return szs;
        }
        var t2 = t1.slice(openIdx);
        var closeIdx = t2.indexOf(']');
        if (closeIdx < 0) {
            throw new Error('Bad param type');
        }
        var t3 = t2.slice(1, closeIdx);
        if (t3.length === 0) {
            // Variable size
            szs.push(0);
        }
        else {
            // Fixed size
            szs.push(parseInt(t3));
        }
        t1 = t2.slice(closeIdx + 1);
    }
    return szs;
}
/** @internal */
function getTupleName(name, withArr) {
    if (withArr === void 0) { withArr = true; }
    var brackets = 0, addedFirstBracket = false;
    for (var i = 0; i < name.length; i++) {
        if (name[i] === '(') {
            brackets += 1;
            addedFirstBracket = true;
        }
        else if (name[i] === ')') {
            brackets -= 1;
        }
        var canBreak = name[i + 1] === ',' || name[i + 1] === ')' || i === name.length - 1;
        if (!withArr && name[i + 1] === '[') {
            canBreak = true;
        }
        if (!brackets && addedFirstBracket && canBreak) {
            return name.slice(0, i + 1);
        }
    }
    throw new Error(BAD_CANONICAL_ERR);
}
/** @internal */
function isTuple(type) {
    return type[0] === '(';
}
/** @internal */
function isBytesType(param) {
    return EVM_TYPES[param[1]] === 'bytes';
}
function isBytesItem(param) {
    return isBytesType(param) && param[3].length === 0;
}
function isBytesArrItem(param) {
    return isBytesType(param) && param[3].length === 1 && param[3][0] === 0;
}
var BAD_CANONICAL_ERR = 'Could not parse canonical function name.';
var EVM_TYPES = [
    null,
    'address',
    'bool',
    'uint',
    'int',
    'bytes',
    'string',
    'tuple',
    'nestedDef',
];

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\calldata\\evm.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\calldata\\index.js", {"./evm":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\calldata\\evm.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Ccalldata%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLDATA = void 0;
/**
 * Exports containing utils that allow inclusion of calldata decoder info in signing requests. If
 * calldata decoder info is packed into the request, it is used to decode the calldata in the
 * request. It is optional.
 */
var evm_1 = require("./evm");
exports.CALLDATA = {
    EVM: {
        type: 1,
        parsers: {
            parseSolidityJSONABI: evm_1.parseSolidityJSONABI,
            parseCanonicalName: evm_1.parseCanonicalName,
        },
        processors: {
            getNestedCalldata: evm_1.getNestedCalldata,
            replaceNestedDefs: evm_1.replaceNestedDefs,
        }
    },
};

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\calldata\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\client.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./functions/index":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\index.js","./shared/functions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\functions.js","./shared/utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js","./shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cclient.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var constants_1 = require("./constants");
var index_1 = require("./functions/index");
var functions_1 = require("./shared/functions");
var utilities_1 = require("./shared/utilities");
var validators_1 = require("./shared/validators");
var util_1 = require("./util");
/**
 * `Client` is a class-based interface for managing a Lattice device.
 */
var Client = /** @class */ (function () {
    /**
     * @param params - Parameters are passed as an object.
     */
    function Client(_a) {
        var baseUrl = _a.baseUrl, name = _a.name, privKey = _a.privKey, stateData = _a.stateData, timeout = _a.timeout, retryCount = _a.retryCount, skipRetryOnWrongWallet = _a.skipRetryOnWrongWallet, deviceId = _a.deviceId;
        this.name = name || 'Unknown';
        this.baseUrl = baseUrl || constants_1.BASE_URL;
        this.deviceId = deviceId;
        this.isPaired = false;
        this.activeWallets = constants_1.DEFAULT_ACTIVE_WALLETS;
        this.timeout = timeout || 60000;
        this.retryCount = retryCount || 3;
        this.skipRetryOnWrongWallet = skipRetryOnWrongWallet || false;
        this.privKey = privKey || (0, util_1.randomBytes)(32);
        this.key = (0, util_1.getP256KeyPair)(this.privKey);
        this.retryWrapper = (0, functions_1.buildRetryWrapper)(this, this.retryCount);
        /** The user may pass in state data to rehydrate a session that was previously cached */
        if (stateData) {
            this.unpackAndApplyStateData(stateData);
        }
    }
    Object.defineProperty(Client.prototype, "publicKey", {
        /**
         * Get the public key associated with the client's static keypair.
         * The public key is used for identifying the client to the Lattice.
         * @internal
         * @returns Buffer
         */
        get: function () {
            return (0, utilities_1.getPubKeyBytes)(this.key);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get the pairing name for this client instance
     */
    Client.prototype.getAppName = function () {
        return this.name;
    };
    /**
     * Get the `deviceId` for this client instance
     */
    Client.prototype.getDeviceId = function () {
        return this.deviceId;
    };
    Object.defineProperty(Client.prototype, "sharedSecret", {
        /**
         * Get the shared secret, derived via ECDH from the local private key and the ephemeral public key
         * @internal
         * @returns Buffer
         */
        get: function () {
            // Once every ~256 attempts, we will get a key that starts with a `00` byte, which can lead to
            // problems initializing AES if we don't force a 32 byte BE buffer.
            return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Client.prototype, "ephemeralPub", {
        /** @internal */
        get: function () {
            return this._ephemeralPub;
        },
        /** @internal */
        set: function (ephemeralPub) {
            (0, validators_1.validateEphemeralPub)(ephemeralPub);
            this._ephemeralPub = ephemeralPub;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Attempt to contact a device based on its `deviceId`. The response should include an ephemeral
     * public key, which is used to pair with the device in a later request.
     * @category Lattice
     */
    Client.prototype.connect = function (deviceId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.retryWrapper(index_1.connect, { id: deviceId })];
            });
        });
    };
    /**
     * If a pairing secret is provided, `pair` uses it to sign a hash of the public key, name, and
     * pairing secret. It then sends the name and signature to the device. If no pairing secret is
     * provided, `pair` sends a zero-length name buffer to the device.
     * @category Lattice
     */
    Client.prototype.pair = function (pairingSecret) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.retryWrapper(index_1.pair, { pairingSecret: pairingSecret })];
            });
        });
    };
    /**
     * Takes a starting path and a number to get the addresses associated with the active wallet.
     * @category Lattice
     */
    Client.prototype.getAddresses = function (_a) {
        var startPath = _a.startPath, _b = _a.n, n = _b === void 0 ? 1 : _b, _c = _a.flag, flag = _c === void 0 ? 0 : _c;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_d) {
                return [2 /*return*/, this.retryWrapper(index_1.getAddresses, { startPath: startPath, n: n, flag: flag })];
            });
        });
    };
    /**
     * Builds and sends a request for signing to the Lattice.
     * @category Lattice
     */
    Client.prototype.sign = function (_a) {
        var data = _a.data, currency = _a.currency, cachedData = _a.cachedData, nextCode = _a.nextCode;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, this.retryWrapper(index_1.sign, { data: data, currency: currency, cachedData: cachedData, nextCode: nextCode })];
            });
        });
    };
    /**
     * Fetch the active wallet in the Lattice.
     */
    Client.prototype.fetchActiveWallet = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.retryWrapper(index_1.fetchActiveWallet)];
            });
        });
    };
    /**
     * Takes in a set of key-value records and sends a request to add them to the Lattice.
     * @category Lattice
     */
    Client.prototype.addKvRecords = function (_a) {
        var _b = _a.type, type = _b === void 0 ? 0 : _b, records = _a.records, _c = _a.caseSensitive, caseSensitive = _c === void 0 ? false : _c;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_d) {
                return [2 /*return*/, this.retryWrapper(index_1.addKvRecords, { type: type, records: records, caseSensitive: caseSensitive, })];
            });
        });
    };
    /**
     * Fetches a list of key-value records from the Lattice.
     * @category Lattice
     */
    Client.prototype.getKvRecords = function (_a) {
        var _b = _a.type, type = _b === void 0 ? 0 : _b, _c = _a.n, n = _c === void 0 ? 1 : _c, _d = _a.start, start = _d === void 0 ? 0 : _d;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_e) {
                return [2 /*return*/, this.retryWrapper(index_1.getKvRecords, { type: type, n: n, start: start, })];
            });
        });
    };
    /**
     * Takes in an array of ids and sends a request to remove them from the Lattice.
     * @category Lattice
     */
    Client.prototype.removeKvRecords = function (_a) {
        var _b = _a.type, type = _b === void 0 ? 0 : _b, _c = _a.ids, ids = _c === void 0 ? [] : _c;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_d) {
                return [2 /*return*/, this.retryWrapper(index_1.removeKvRecords, { type: type, ids: ids, })];
            });
        });
    };
    /**
     * Fetch a record of encrypted data from the Lattice.
     * Must specify a data type. Returns a Buffer containing
     * data formatted according to the specified type.
     * @category Lattice
     */
    Client.prototype.fetchEncryptedData = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.retryWrapper(index_1.fetchEncData, params)];
            });
        });
    };
    /** Get the active wallet */
    Client.prototype.getActiveWallet = function () {
        if (this.activeWallets.external.uid &&
            !constants_1.EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {
            return this.activeWallets.external;
        }
        else if (this.activeWallets.internal.uid &&
            !constants_1.EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {
            return this.activeWallets.internal;
        }
        else {
            return undefined;
        }
    };
    /** Check if the user has an active wallet */
    Client.prototype.hasActiveWallet = function () {
        return !!this.getActiveWallet();
    };
    /**
     * Reset the active wallets to empty values.
     * @category Device Response
     * @internal
     */
    Client.prototype.resetActiveWallets = function () {
        this.activeWallets = constants_1.DEFAULT_ACTIVE_WALLETS;
    };
    /**
     * Get a JSON string containing state data that can be used to rehydrate a session. Pass the
     * contents of this to the constructor as `stateData` to rehydrate.
     * @internal
     */
    Client.prototype.getStateData = function () {
        return this.packStateData();
    };
    /**
     * Returns the firmware version constants for the given firmware version.
     * @internal
     */
    Client.prototype.getFwConstants = function () {
        var _a;
        return (0, constants_1.getFwVersionConst)((_a = this.fwVersion) !== null && _a !== void 0 ? _a : Buffer.alloc(0));
    };
    /**
     * `getFwVersion` gets the firmware version of the paired device.
     * @internal
     */
    Client.prototype.getFwVersion = function () {
        if (this.fwVersion && this.fwVersion.length >= 3) {
            return {
                fix: this.fwVersion[0],
                minor: this.fwVersion[1],
                major: this.fwVersion[2],
            };
        }
        return { fix: 0, minor: 0, major: 0 };
    };
    /**
     * Handles the mutation of Client state in the primary functions.
     */
    Client.prototype.mutate = function (_a) {
        var deviceId = _a.deviceId, ephemeralPub = _a.ephemeralPub, url = _a.url, isPaired = _a.isPaired, fwVersion = _a.fwVersion, activeWallets = _a.activeWallets;
        if (deviceId !== undefined)
            this.deviceId = deviceId;
        if (ephemeralPub !== undefined)
            this.ephemeralPub = ephemeralPub;
        if (url !== undefined)
            this.url = url;
        if (isPaired !== undefined)
            this.isPaired = isPaired;
        if (fwVersion !== undefined)
            this.fwVersion = fwVersion;
        if (activeWallets !== undefined)
            this.activeWallets = activeWallets;
    };
    /**
     * Return JSON-stringified version of state data. Can be used to rehydrate an SDK session without
     * reconnecting to the target Lattice.
     * @internal
     */
    Client.prototype.packStateData = function () {
        var _a, _b, _c, _d, _e, _f, _g;
        try {
            var data = {
                activeWallets: {
                    internal: {
                        uid: (_a = this.activeWallets.internal.uid) === null || _a === void 0 ? void 0 : _a.toString('hex'),
                        name: (_b = this.activeWallets.internal.name) === null || _b === void 0 ? void 0 : _b.toString(),
                        capabilities: this.activeWallets.internal.capabilities,
                    },
                    external: {
                        uid: (_c = this.activeWallets.external.uid) === null || _c === void 0 ? void 0 : _c.toString('hex'),
                        name: (_d = this.activeWallets.external.name) === null || _d === void 0 ? void 0 : _d.toString(),
                        capabilities: this.activeWallets.external.capabilities,
                    },
                },
                ephemeralPub: (_f = (_e = this.ephemeralPub) === null || _e === void 0 ? void 0 : _e.getPublic()) === null || _f === void 0 ? void 0 : _f.encode('hex'),
                fwVersion: (_g = this.fwVersion) === null || _g === void 0 ? void 0 : _g.toString('hex'),
                deviceId: this.deviceId,
                name: this.name,
                baseUrl: this.baseUrl,
                privKey: this.privKey.toString('hex'),
                retryCount: this.retryCount,
                timeout: this.timeout,
            };
            return JSON.stringify(data);
        }
        catch (err) {
            console.warn('Could not pack state data.');
            return null;
        }
    };
    /**
     * Unpack a JSON-stringified version of state data and apply it to state. This will allow us to
     * rehydrate an old session.
     * @internal
     */
    Client.prototype.unpackAndApplyStateData = function (data) {
        try {
            var unpacked = JSON.parse(data);
            // Attempt to parse the data
            var internalWallet = {
                uid: Buffer.from(unpacked.activeWallets.internal.uid, 'hex'),
                name: unpacked.activeWallets.internal.name ?
                    Buffer.from(unpacked.activeWallets.internal.name) :
                    null,
                capabilities: unpacked.activeWallets.internal.capabilities,
                external: false,
            };
            var externalWallet = {
                uid: Buffer.from(unpacked.activeWallets.external.uid, 'hex'),
                name: unpacked.activeWallets.external.name ?
                    Buffer.from(unpacked.activeWallets.external.name) :
                    null,
                capabilities: unpacked.activeWallets.external.capabilities,
                external: true,
            };
            var ephemeralPubBytes = Buffer.from(unpacked.ephemeralPub, 'hex');
            var fwVersionBytes = Buffer.from(unpacked.fwVersion, 'hex');
            var privKeyBytes = Buffer.from(unpacked.privKey, 'hex');
            // Apply unpacked params
            this.activeWallets.internal = internalWallet;
            this.activeWallets.external = externalWallet;
            this.ephemeralPub = (0, util_1.getP256KeyPairFromPub)(ephemeralPubBytes);
            this.fwVersion = fwVersionBytes;
            this.deviceId = unpacked.deviceId;
            this.name = unpacked.name;
            this.baseUrl = unpacked.baseUrl;
            this.url = "".concat(this.baseUrl, "/").concat(this.deviceId);
            this.privKey = privKeyBytes;
            this.key = (0, util_1.getP256KeyPair)(this.privKey);
            this.retryCount = unpacked.retryCount;
            this.timeout = unpacked.timeout;
            this.retryWrapper = (0, functions_1.buildRetryWrapper)(this, this.retryCount);
        }
        catch (err) {
            console.warn('Could not apply state data.');
        }
    };
    return Client;
}());
exports.Client = Client;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\client.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js", {"./protocol/latticeConstants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cconstants.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PUBLIC = exports.ETH_ABI_LATTICE_FW_TYPE_MAP = exports.MAX_CHAIN_ID_BYTES = exports.HANDLE_LARGER_CHAIN_ID = exports.HARDENED_OFFSET = exports.VERSION_BYTE = exports.REQUEST_TYPE_BYTE = exports.signingSchema = exports.ethMsgProtocol = exports.addressSizes = exports.EXTERNAL_NETWORKS_BY_CHAIN_ID_URL = exports.NETWORKS_BY_CHAIN_ID = exports.MAX_ADDR = exports.CURRENCIES = exports.BASE_URL = exports.BIP_CONSTANTS = exports.getFwVersionConst = exports.ASCII_REGEX = exports.LEDGER_LEGACY_DERIVATION = exports.LEDGER_LIVE_DERIVATION = exports.SOLANA_DERIVATION = exports.BTC_WRAPPED_SEGWIT_DERIVATION = exports.BTC_SEGWIT_DERIVATION = exports.BTC_LEGACY_DERIVATION = exports.DEFAULT_ETH_DERIVATION = exports.DEFAULT_ACTIVE_WALLETS = exports.EMPTY_WALLET_UID = exports.EXTERNAL = void 0;
var latticeConstants_1 = require("./protocol/latticeConstants");
/**
 * Externally exported constants used for building requests
 * @public
 */
exports.EXTERNAL = {
    // Optional flags for `getAddresses`
    GET_ADDR_FLAGS: {
        SECP256K1_PUB: latticeConstants_1.LatticeGetAddressesFlag.secp256k1Pubkey,
        ED25519_PUB: latticeConstants_1.LatticeGetAddressesFlag.ed25519Pubkey,
        BLS12_381_G1_PUB: latticeConstants_1.LatticeGetAddressesFlag.bls12_381Pubkey,
    },
    // Options for building general signing requests
    SIGNING: {
        HASHES: {
            NONE: latticeConstants_1.LatticeSignHash.none,
            KECCAK256: latticeConstants_1.LatticeSignHash.keccak256,
            SHA256: latticeConstants_1.LatticeSignHash.sha256,
        },
        CURVES: {
            SECP256K1: latticeConstants_1.LatticeSignCurve.secp256k1,
            ED25519: latticeConstants_1.LatticeSignCurve.ed25519,
            BLS12_381_G2: latticeConstants_1.LatticeSignCurve.bls12_381,
        },
        ENCODINGS: {
            NONE: latticeConstants_1.LatticeSignEncoding.none,
            SOLANA: latticeConstants_1.LatticeSignEncoding.solana,
            EVM: latticeConstants_1.LatticeSignEncoding.evm,
            ETH_DEPOSIT: latticeConstants_1.LatticeSignEncoding.eth_deposit,
        },
        BLS_DST: {
            BLS_DST_NUL: latticeConstants_1.LatticeSignBlsDst.NUL,
            BLS_DST_POP: latticeConstants_1.LatticeSignBlsDst.POP,
        },
    },
    // Options for exporting encrypted data
    ENC_DATA: {
        SCHEMAS: {
            BLS_KEYSTORE_EIP2335_PBKDF_V4: latticeConstants_1.LatticeEncDataSchema.eip2335,
        },
    },
    ETH_CONSENSUS_SPEC: {
        NETWORKS: {
            MAINNET_GENESIS: {
                networkName: 'mainnet',
                forkVersion: Buffer.alloc(4),
                // Empty root because there were no validators at genesis
                validatorsRoot: Buffer.alloc(32),
            },
        },
        DOMAINS: {
            DEPOSIT: Buffer.from('03000000', 'hex'),
            VOLUNTARY_EXIT: Buffer.from('04000000', 'hex'),
        },
    },
};
exports.PUBLIC = exports.EXTERNAL;
//===============================
// INTERNAL CONSTANTS
//===============================
/** @internal */
var addressSizes = {
    BTC: 20,
    ETH: 20, // 20 byte address not including 0x prefix
};
exports.addressSizes = addressSizes;
/** @internal */
var CURRENCIES = {
    ETH: 'ETH',
    BTC: 'BTC',
    ETH_MSG: 'ETH_MSG',
};
exports.CURRENCIES = CURRENCIES;
/** @internal */
// THIS NEEDS TO BE A PROTOCOL CONSTANT TOO
var signingSchema = {
    BTC_TRANSFER: 0,
    ETH_TRANSFER: 1,
    ERC20_TRANSFER: 2,
    ETH_MSG: 3,
    EXTRA_DATA: 4,
    GENERAL_SIGNING: 5,
};
exports.signingSchema = signingSchema;
/** @internal */
var HARDENED_OFFSET = 0x80000000; // Hardened offset
exports.HARDENED_OFFSET = HARDENED_OFFSET;
/** @internal */
var BIP_CONSTANTS = {
    PURPOSES: {
        ETH: HARDENED_OFFSET + 44,
        BTC_LEGACY: HARDENED_OFFSET + 44,
        BTC_WRAPPED_SEGWIT: HARDENED_OFFSET + 49,
        BTC_SEGWIT: HARDENED_OFFSET + 84,
    },
    COINS: {
        ETH: HARDENED_OFFSET + 60,
        BTC: HARDENED_OFFSET,
        BTC_TESTNET: HARDENED_OFFSET + 1,
    },
};
exports.BIP_CONSTANTS = BIP_CONSTANTS;
/** @internal For all HSM-bound requests */
var REQUEST_TYPE_BYTE = 0x02;
exports.REQUEST_TYPE_BYTE = REQUEST_TYPE_BYTE;
/** @internal */
var VERSION_BYTE = 1;
exports.VERSION_BYTE = VERSION_BYTE;
/** @internal ChainId value to signify larger chainID is in data buffer */
var HANDLE_LARGER_CHAIN_ID = 255;
exports.HANDLE_LARGER_CHAIN_ID = HANDLE_LARGER_CHAIN_ID;
/** @internal Max number of bytes to contain larger chainID in data buffer */
var MAX_CHAIN_ID_BYTES = 8;
exports.MAX_CHAIN_ID_BYTES = MAX_CHAIN_ID_BYTES;
/** @internal */
var BASE_URL = 'https://signing.gridpl.us';
exports.BASE_URL = BASE_URL;
/** @internal */
var EIP712_ABI_LATTICE_FW_TYPE_MAP = {
    address: 1,
    bool: 2,
    uint8: 3,
    uint16: 4,
    uint24: 5,
    uint32: 6,
    uint40: 7,
    uint48: 8,
    uint56: 9,
    uint64: 10,
    uint72: 11,
    uint80: 12,
    uint88: 13,
    uint96: 14,
    uint104: 15,
    uint112: 16,
    uint120: 17,
    uint128: 18,
    uint136: 19,
    uint144: 20,
    uint152: 21,
    uint160: 22,
    uint168: 23,
    uint176: 24,
    uint184: 25,
    uint192: 26,
    uint200: 27,
    uint208: 28,
    uint216: 29,
    uint224: 30,
    uint232: 31,
    uint240: 32,
    uint248: 33,
    uint256: 34,
    int8: 35,
    int16: 36,
    int24: 37,
    int32: 38,
    int40: 39,
    int48: 40,
    int56: 41,
    int64: 42,
    int72: 43,
    int80: 44,
    int88: 45,
    int96: 46,
    int104: 47,
    int112: 48,
    int120: 49,
    int128: 50,
    int136: 51,
    int144: 52,
    int152: 53,
    int160: 54,
    int168: 55,
    int176: 56,
    int184: 57,
    int192: 58,
    int200: 59,
    int208: 60,
    int216: 61,
    int224: 62,
    int232: 63,
    int240: 64,
    int248: 65,
    int256: 66,
    uint: 67,
    bytes1: 69,
    bytes2: 70,
    bytes3: 71,
    bytes4: 72,
    bytes5: 73,
    bytes6: 74,
    bytes7: 75,
    bytes8: 76,
    bytes9: 77,
    bytes10: 78,
    bytes11: 79,
    bytes12: 80,
    bytes13: 81,
    bytes14: 82,
    bytes15: 83,
    bytes16: 84,
    bytes17: 85,
    bytes18: 86,
    bytes19: 87,
    bytes20: 88,
    bytes21: 89,
    bytes22: 90,
    bytes23: 91,
    bytes24: 92,
    bytes25: 93,
    bytes26: 94,
    bytes27: 95,
    bytes28: 96,
    bytes29: 97,
    bytes30: 98,
    bytes31: 99,
    bytes32: 100,
    bytes: 101,
    string: 102,
};
/** @internal */
var ETH_ABI_LATTICE_FW_TYPE_MAP = __assign(__assign({}, EIP712_ABI_LATTICE_FW_TYPE_MAP), { tuple1: 103, tuple2: 104, tuple3: 105, tuple4: 106, tuple5: 107, tuple6: 108, tuple7: 109, tuple8: 110, tuple9: 111, tuple10: 112, tuple11: 113, tuple12: 114, tuple13: 115, tuple14: 116, tuple15: 117, tuple16: 118, tuple17: 119 });
exports.ETH_ABI_LATTICE_FW_TYPE_MAP = ETH_ABI_LATTICE_FW_TYPE_MAP;
/** @internal */
var ethMsgProtocol = {
    SIGN_PERSONAL: {
        str: 'signPersonal',
        enumIdx: 0, // Enum index of this protocol in Lattice firmware
    },
    TYPED_DATA: {
        str: 'typedData',
        enumIdx: 1,
        rawDataMaxLen: 1629,
        typeCodes: EIP712_ABI_LATTICE_FW_TYPE_MAP, // Enum indices of data types in Lattice firmware
    },
};
exports.ethMsgProtocol = ethMsgProtocol;
/** @internal */
function getFwVersionConst(v) {
    var c = {
        extraDataFrameSz: 0,
        extraDataMaxFrames: 0,
        genericSigning: {},
    };
    function gte(v, exp) {
        // Note that `v` fields come in as [fix|minor|major]
        return (v[2] > exp[0] ||
            (v[2] === exp[0] && v[1] > exp[1]) ||
            (v[2] === exp[0] && v[1] === exp[1] && v[0] > exp[2]) ||
            (v[2] === exp[0] && v[1] === exp[1] && v[0] === exp[2]));
    }
    // Very old legacy versions do not give a version number
    var legacy = v.length === 0;
    // BASE FIELDS
    //--------------------------------------
    // Various size constants have changed on the firmware side over time and
    // are captured here
    if (!legacy && gte(v, [0, 10, 4])) {
        // >=0.10.3
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    }
    else if (!legacy && gte(v, [0, 10, 0])) {
        // >=0.10.0
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    }
    else {
        // Legacy or <0.10.0
        c.reqMaxDataSz = 1152;
        c.ethMaxGasPrice = 500000000000; // 500 gwei
        c.addrFlagsAllowed = false;
    }
    // These transformations apply to all versions. The subtraction
    // of 128 bytes accounts for metadata and is for legacy reasons.
    // For all modern versions, these are 1550 bytes.
    // NOTE: Non-legacy ETH txs (e.g. EIP1559) will shrink
    // this number.
    // See `ETH_BASE_TX_MAX_DATA_SZ` and `ETH_MAX_BASE_MSG_SZ` in firmware
    c.ethMaxDataSz = c.reqMaxDataSz - 128;
    c.ethMaxMsgSz = c.ethMaxDataSz;
    // Max number of params in an EIP712 type. This was added to firmware
    // to avoid blowing stack size.
    c.eip712MaxTypeParams = 18;
    // -----
    // EXTRA FIELDS ADDED IN LATER FIRMWARE VERSIONS
    // -----
    // --- V0.10.X ---
    // V0.10.4 introduced the ability to send signing requests over multiple
    // data frames (i.e. in multiple requests)
    if (!legacy && gte(v, [0, 10, 4])) {
        c.extraDataFrameSz = 1500; // 1500 bytes per frame of extraData allowed
        c.extraDataMaxFrames = 1; // 1 frame of extraData allowed
    }
    // V0.10.5 added the ability to use flexible address path sizes, which
    // changes the `getAddress` API. It also added support for EIP712
    if (!legacy && gte(v, [0, 10, 5])) {
        c.varAddrPathSzAllowed = true;
        c.eip712Supported = true;
    }
    // V0.10.8 allows a user to sign a prehashed transaction if the payload
    // is too big
    if (!legacy && gte(v, [0, 10, 8])) {
        c.prehashAllowed = true;
    }
    // V0.10.10 allows a user to sign a prehashed ETH message if payload too big
    if (!legacy && gte(v, [0, 10, 10])) {
        c.ethMsgPreHashAllowed = true;
    }
    // --- 0.11.X ---
    // V0.11.0 allows new ETH transaction types
    if (!legacy && gte(v, [0, 11, 0])) {
        c.allowedEthTxTypes = [
            1,
            2, // eip1559
        ];
        // This version added extra data fields to the ETH tx
        c.ethMaxDataSz -= 10;
        c.ethMaxMsgSz = c.ethMaxDataSz;
    }
    // V0.11.2 changed how messages are displayed. For personal_sign messages
    // we now write the header (`Signer: <path>`) into the main body of the screen.
    // This means personal sign message max size is slightly smaller than for
    // EIP712 messages because in the latter case there is no header
    // Note that `<path>` has max size of 62 bytes (`m/X/X/...`)
    if (!legacy && gte(v, [0, 11, 2])) {
        c.personalSignHeaderSz = 72;
    }
    // --- V0.12.X ---
    // V0.12.0 added an API for creating, removing, and fetching key-val file
    // records. For the purposes of this SDK, we only hook into one type of kv
    // file: address names.
    if (!legacy && gte(v, [0, 12, 0])) {
        c.kvActionsAllowed = true;
        c.kvKeyMaxStrSz = 63;
        c.kvValMaxStrSz = 63;
        c.kvActionMaxNum = 10;
        c.kvRemoveMaxNum = 100;
    }
    // --- V0.13.X ---
    // V0.13.0 added native segwit addresses and fixed a bug in exporting
    // legacy bitcoin addresses
    if (!legacy && gte(v, [0, 13, 0])) {
        c.allowBtcLegacyAndSegwitAddrs = true;
        // Random address to be used when trying to deploy a contract
        c.contractDeployKey = '0x08002e0fec8e6acf00835f43c9764f7364fa3f42';
    }
    // --- V0.14.X ---
    // V0.14.0 added support for a more robust API around ABI definitions
    // and generic signing functionality
    if (!legacy && gte(v, [0, 14, 0])) {
        // Size of `category` buffer. Inclusive of null terminator byte.
        c.abiCategorySz = 32;
        c.abiMaxRmv = 200; // Max number of ABI defs that can be removed with
        // a single request
        // See `sizeof(GenericSigningRequest_t)` in firmware
        c.genericSigning.baseReqSz = 1552;
        // See `GENERIC_SIGNING_BASE_MSG_SZ` in firmware
        c.genericSigning.baseDataSz = 1519;
        c.genericSigning.hashTypes = exports.EXTERNAL.SIGNING.HASHES;
        c.genericSigning.curveTypes = exports.EXTERNAL.SIGNING.CURVES;
        c.genericSigning.encodingTypes = {
            NONE: exports.EXTERNAL.SIGNING.ENCODINGS.NONE,
            SOLANA: exports.EXTERNAL.SIGNING.ENCODINGS.SOLANA,
        };
        // Supported flags for `getAddresses`
        c.getAddressFlags = [
            exports.EXTERNAL.GET_ADDR_FLAGS.ED25519_PUB,
            exports.EXTERNAL.GET_ADDR_FLAGS.SECP256K1_PUB,
        ];
        // We updated the max number of params in EIP712 types
        c.eip712MaxTypeParams = 36;
    }
    // DEPRECATED
    // V0.14.1 Added the Terra decoder
    // if (!legacy && gte(v, [0, 14, 1])) {
    //   c.genericSigning.encodingTypes.TERRA = EXTERNAL.SIGNING.ENCODINGS.TERRA;
    // }
    // --- V0.15.X ---
    // V0.15.0 added an EVM decoder and removed the legacy ETH signing pathway
    if (!legacy && gte(v, [0, 15, 0])) {
        c.genericSigning.encodingTypes.EVM = exports.EXTERNAL.SIGNING.ENCODINGS.EVM;
        // We now use the general signing data field as the base
        // Note that we have NOT removed the ETH_MSG type so we should
        // not change ethMaxMsgSz
        c.ethMaxDataSz = 1550 - 31;
        // Max buffer size for get/add decoder requests
        c.maxDecoderBufSz = 1600;
        // Code used to write a calldata decoder
        c.genericSigning.calldataDecoding = {
            reserved: 2895728,
            maxSz: 1024,
        };
    }
    // --- V0.17.X ---
    // V0.17.0 added support for BLS12-381-G1 pubkeys and G2 sigs
    if (!legacy && gte(v, [0, 17, 0])) {
        c.getAddressFlags.push(exports.EXTERNAL.GET_ADDR_FLAGS.BLS12_381_G1_PUB);
        c.genericSigning.encodingTypes.ETH_DEPOSIT = exports.EXTERNAL.SIGNING.ENCODINGS.ETH_DEPOSIT;
    }
    return c;
}
exports.getFwVersionConst = getFwVersionConst;
/** @internal */
// eslint-disable-next-line no-control-regex
var ASCII_REGEX = /^[\x00-\x7F]+$/;
exports.ASCII_REGEX = ASCII_REGEX;
/** @internal */
var EXTERNAL_NETWORKS_BY_CHAIN_ID_URL = 'https://gridplus.github.io/chains/chains.json';
exports.EXTERNAL_NETWORKS_BY_CHAIN_ID_URL = EXTERNAL_NETWORKS_BY_CHAIN_ID_URL;
/** @internal - Max number of addresses to fetch */
var MAX_ADDR = 10;
exports.MAX_ADDR = MAX_ADDR;
/** @internal */
var NETWORKS_BY_CHAIN_ID = {
    1: {
        name: 'ethereum',
        baseUrl: 'https://api.etherscan.io',
        apiRoute: 'api?module=contract&action=getabi',
    },
    137: {
        name: 'polygon',
        baseUrl: 'https://api.polygonscan.com',
        apiRoute: 'api?module=contract&action=getabi',
    },
    56: {
        name: 'binance',
        baseUrl: 'https://api.bscscan.com',
        apiRoute: 'api?module=contract&action=getabi',
    },
    42220: {
        name: 'celo',
        baseUrl: 'https://api.celoscan.io',
        apiRoute: 'api?module=contract&action=getabi',
    },
    43114: {
        name: 'avalanche',
        baseUrl: 'https://api.snowtrace.io',
        apiRoute: 'api?module=contract&action=getabi',
    },
};
exports.NETWORKS_BY_CHAIN_ID = NETWORKS_BY_CHAIN_ID;
/** @internal */
exports.EMPTY_WALLET_UID = Buffer.alloc(32);
/** @internal */
exports.DEFAULT_ACTIVE_WALLETS = {
    internal: {
        uid: exports.EMPTY_WALLET_UID,
        external: false,
        name: Buffer.alloc(0),
        capabilities: 0,
    },
    external: {
        uid: exports.EMPTY_WALLET_UID,
        external: true,
        name: Buffer.alloc(0),
        capabilities: 0,
    },
};
/** @internal */
exports.DEFAULT_ETH_DERIVATION = [
    HARDENED_OFFSET + 44,
    HARDENED_OFFSET + 60,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.BTC_LEGACY_DERIVATION = [
    HARDENED_OFFSET + 44,
    HARDENED_OFFSET + 0,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.BTC_SEGWIT_DERIVATION = [
    HARDENED_OFFSET + 84,
    HARDENED_OFFSET,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.BTC_WRAPPED_SEGWIT_DERIVATION = [
    HARDENED_OFFSET + 49,
    HARDENED_OFFSET,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.SOLANA_DERIVATION = [
    HARDENED_OFFSET + 44,
    HARDENED_OFFSET + 501,
    HARDENED_OFFSET,
];
/** @internal */
exports.LEDGER_LIVE_DERIVATION = [
    HARDENED_OFFSET + 49,
    HARDENED_OFFSET + 60,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.LEDGER_LEGACY_DERIVATION = [
    HARDENED_OFFSET + 49,
    HARDENED_OFFSET + 60,
    HARDENED_OFFSET,
    0,
];

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\constants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\ethereum.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","@ethereumjs/common":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\common\\dist\\index.js","@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js","borc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\borc\\src\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-eip712-util-browser":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\eth-eip712-util-browser\\index.js","js-sha3":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\rlp\\dist\\index.js","secp256k1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cethereum.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which
// does not have browser (or, by proxy, React-Native) support.
var common_1 = require("@ethereumjs/common");
var tx_1 = require("@ethereumjs/tx");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var borc_1 = __importDefault(require("borc"));
//@ts-expect-error - This third-party package is not typed properly
var eth_eip712_util_browser_1 = require("eth-eip712-util-browser");
var js_sha3_1 = require("js-sha3");
var rlp_1 = require("rlp");
var secp256k1_1 = __importDefault(require("secp256k1"));
var constants_1 = require("./constants");
var protocol_1 = require("./protocol");
var util_1 = require("./util");
var buildEthereumMsgRequest = function (input) {
    if (!input.payload || !input.protocol || !input.signerPath)
        throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');
    if (input.signerPath.length > 5 || input.signerPath.length < 2)
        throw new Error('Please provide a signer path with 2-5 indices');
    var req = {
        schema: protocol_1.LatticeSignSchema.ethereumMsg,
        payload: null,
        input: input,
        msg: null, // Save the buffered message for later
    };
    switch (input.protocol) {
        case 'signPersonal':
            return buildPersonalSignRequest(req, input);
        case 'eip712':
            if (!input.fwConstants.eip712Supported)
                throw new Error('EIP712 is not supported by your Lattice firmware version. Please upgrade.');
            return buildEIP712Request(req, input);
        default:
            throw new Error('Unsupported protocol');
    }
};
var validateEthereumMsgResponse = function (res, req) {
    var signer = res.signer, sig = res.sig;
    var input = req.input, msg = req.msg, _a = req.prehash, prehash = _a === void 0 ? null : _a;
    if (input.protocol === 'signPersonal') {
        // NOTE: We are currently hardcoding networkID=1 and useEIP155=false but these
        //       may be configurable in future versions
        var hash_1 = prehash
            ? prehash
            : Buffer.from((0, js_sha3_1.keccak256)(Buffer.concat([get_personal_sign_prefix(msg.length), msg])), 'hex');
        // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
        return addRecoveryParam(hash_1, sig, signer, {
            chainId: 1,
            useEIP155: false,
        });
    }
    else if (input.protocol === 'eip712') {
        var encoded = eth_eip712_util_browser_1.TypedDataUtils.hash(req.input.payload);
        var digest = prehash ? prehash : encoded;
        // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
        return addRecoveryParam(digest, sig, signer, { useEIP155: false });
    }
    else {
        throw new Error('Unsupported protocol');
    }
};
var buildEthereumTxRequest = function (data) {
    try {
        var _a = data.chainId, chainId = _a === void 0 ? 1 : _a;
        var signerPath = data.signerPath, _b = data.eip155, eip155 = _b === void 0 ? null : _b, fwConstants = data.fwConstants, _c = data.type, type = _c === void 0 ? null : _c;
        var contractDeployKey = fwConstants.contractDeployKey, extraDataFrameSz = fwConstants.extraDataFrameSz, extraDataMaxFrames = fwConstants.extraDataMaxFrames, prehashAllowed = fwConstants.prehashAllowed;
        var EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
        var MAX_BASE_DATA_SZ = fwConstants.ethMaxDataSz;
        var VAR_PATH_SZ = fwConstants.varAddrPathSzAllowed;
        // Sanity checks:
        // There are a handful of named chains we allow the user to reference (`chainIds`)
        // Custom chainIDs should be either numerical or hex strings
        if (typeof chainId !== 'number' &&
            isValidChainIdHexNumStr(chainId) === false) {
            chainId = chainIds[chainId];
        }
        // If this was not a custom chainID and we cannot find the name of it, exit
        if (!chainId)
            throw new Error('Unsupported chain ID or name');
        // Sanity check on signePath
        if (!signerPath)
            throw new Error('`signerPath` not provided');
        // Is this a contract deployment?
        if (data.to === null && !contractDeployKey) {
            throw new Error('Contract deployment not supported. Please update your Lattice firmware.');
        }
        var isDeployment = data.to === null && contractDeployKey;
        // We support eip1559 and eip2930 types (as well as legacy)
        var eip1559IsAllowed = fwConstants.allowedEthTxTypes &&
            fwConstants.allowedEthTxTypes.indexOf(2) > -1;
        var eip2930IsAllowed = fwConstants.allowedEthTxTypes &&
            fwConstants.allowedEthTxTypes.indexOf(1) > -1;
        var isEip1559 = eip1559IsAllowed && (type === 2 || type === 'eip1559');
        var isEip2930 = eip2930IsAllowed && (type === 1 || type === 'eip2930');
        if (type !== null && !isEip1559 && !isEip2930)
            throw new Error('Unsupported Ethereum transaction type');
        // Determine if we should use EIP155 given the chainID.
        // If we are explicitly told to use eip155, we will use it. Otherwise,
        // we will look up if the specified chainId is associated with a chain
        // that does not use EIP155 by default. Note that most do use EIP155.
        var useEIP155 = chainUsesEIP155(chainId);
        if (eip155 !== null && typeof eip155 === 'boolean') {
            useEIP155 = eip155;
        }
        else if (isEip1559 || isEip2930) {
            // Newer transaction types do not use EIP155 since the chainId is serialized
            useEIP155 = false;
        }
        // Hack for metamask, which sends value=null for 0 ETH transactions
        if (!data.value)
            data.value = 0;
        //--------------
        // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING
        //--------------
        // Ensure all fields are 0x-prefixed hex strings
        var rawTx = [];
        // Build the transaction buffer array
        var chainIdBytes = (0, util_1.ensureHexBuffer)(chainId);
        var nonceBytes = (0, util_1.ensureHexBuffer)(data.nonce);
        var gasPriceBytes = void 0;
        var gasLimitBytes = (0, util_1.ensureHexBuffer)(data.gasLimit);
        // Handle contract deployment (indicated by `to` being `null`)
        // For contract deployment we write a 20-byte key to the request
        // buffer, which gets swapped for an empty buffer in firmware.
        var toRlpElem = void 0, toBytes = void 0;
        if (isDeployment) {
            toRlpElem = Buffer.alloc(0);
            toBytes = (0, util_1.ensureHexBuffer)(contractDeployKey);
        }
        else {
            toRlpElem = (0, util_1.ensureHexBuffer)(data.to);
            toBytes = (0, util_1.ensureHexBuffer)(data.to);
        }
        var valueBytes = (0, util_1.ensureHexBuffer)(data.value);
        var dataBytes = (0, util_1.ensureHexBuffer)(data.data);
        if (isEip1559 || isEip2930) {
            // EIP1559 and EIP2930 transactions have a chainID field
            rawTx.push(chainIdBytes);
        }
        rawTx.push(nonceBytes);
        var maxPriorityFeePerGasBytes = void 0, maxFeePerGasBytes = void 0;
        if (isEip1559) {
            if (!data.maxPriorityFeePerGas)
                throw new Error('EIP1559 transactions must include `maxPriorityFeePerGas`');
            maxPriorityFeePerGasBytes = (0, util_1.ensureHexBuffer)(data.maxPriorityFeePerGas);
            rawTx.push(maxPriorityFeePerGasBytes);
            maxFeePerGasBytes = (0, util_1.ensureHexBuffer)(data.maxFeePerGas);
            rawTx.push(maxFeePerGasBytes);
            // EIP1559 renamed "gasPrice" to "maxFeePerGas", but firmware still
            // uses `gasPrice` in the struct, so update that value here.
            gasPriceBytes = maxFeePerGasBytes;
        }
        else {
            // EIP1559 transactions do not have the gasPrice field
            gasPriceBytes = (0, util_1.ensureHexBuffer)(data.gasPrice);
            rawTx.push(gasPriceBytes);
        }
        rawTx.push(gasLimitBytes);
        rawTx.push(toRlpElem);
        rawTx.push(valueBytes);
        rawTx.push(dataBytes);
        // We do not currently support accessList in firmware so we need to prehash if
        // the list is non-null
        var PREHASH_FROM_ACCESS_LIST_1 = false;
        if (isEip1559 || isEip2930) {
            var accessList_1 = [];
            if (Array.isArray(data.accessList)) {
                data.accessList.forEach(function (listItem) {
                    var keys = [];
                    listItem.storageKeys.forEach(function (key) {
                        keys.push((0, util_1.ensureHexBuffer)(key));
                    });
                    accessList_1.push([(0, util_1.ensureHexBuffer)(listItem.address), keys]);
                    PREHASH_FROM_ACCESS_LIST_1 = true;
                });
            }
            rawTx.push(accessList_1);
        }
        else if (useEIP155 === true) {
            // Add empty v,r,s values for EIP155 legacy transactions
            rawTx.push(chainIdBytes); // v (which is the same as chainId in EIP155 txs)
            rawTx.push((0, util_1.ensureHexBuffer)(null)); // r
            rawTx.push((0, util_1.ensureHexBuffer)(null)); // s
        }
        //--------------
        // 2. BUILD THE LATTICE REQUEST PAYLOAD
        //--------------
        var ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params
        var txReqPayload = Buffer.alloc(MAX_BASE_DATA_SZ + ETH_TX_NON_DATA_SZ);
        var off = 0;
        // 1. EIP155 switch and chainID
        //------------------
        txReqPayload.writeUInt8(Number(useEIP155), off);
        off++;
        // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger
        // chainID values. To account for these, we will put the chainID into the `data` buffer if it
        // is >=255. Values up to UINT64_MAX will be allowed.
        var chainIdBuf = void 0;
        var chainIdBufSz = 0;
        if (useChainIdBuffer(chainId) === true) {
            chainIdBuf = getChainIdBuf(chainId);
            chainIdBufSz = chainIdBuf.length;
            if (chainIdBufSz > constants_1.MAX_CHAIN_ID_BYTES)
                throw new Error('ChainID provided is too large.');
            // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer
            txReqPayload.writeUInt8(constants_1.HANDLE_LARGER_CHAIN_ID, off);
            off++;
        }
        else {
            // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer
            chainIdBuf = (0, util_1.ensureHexBuffer)(chainId);
            if (chainIdBuf.length !== 1)
                throw new Error('Error parsing chainID');
            chainIdBuf.copy(txReqPayload, off);
            off += chainIdBuf.length;
        }
        // 2. Signer Path
        //------------------
        var signerPathBuf = (0, util_1.buildSignerPathBuf)(signerPath, VAR_PATH_SZ);
        signerPathBuf.copy(txReqPayload, off);
        off += signerPathBuf.length;
        // 3. ETH TX request data
        //------------------
        if (nonceBytes.length > 4)
            throw new Error('Nonce too large');
        nonceBytes.copy(txReqPayload, off + (4 - nonceBytes.length));
        off += 4;
        if (gasPriceBytes.length > 8)
            throw new Error('Gas price too large');
        gasPriceBytes.copy(txReqPayload, off + (8 - gasPriceBytes.length));
        off += 8;
        if (gasLimitBytes.length > 4)
            throw new Error('Gas limit too large');
        gasLimitBytes.copy(txReqPayload, off + (4 - gasLimitBytes.length));
        off += 4;
        if (toBytes.length !== 20)
            throw new Error('Invalid `to` address');
        toBytes.copy(txReqPayload, off);
        off += 20;
        if (valueBytes.length > 32)
            throw new Error('Value too large');
        valueBytes.copy(txReqPayload, off + (32 - valueBytes.length));
        off += 32;
        // Extra Tx data comes before `data` in the struct
        var PREHASH_UNSUPPORTED = false;
        if (fwConstants.allowedEthTxTypes) {
            // Some types may not be supported by firmware, so we will need to prehash
            if (PREHASH_FROM_ACCESS_LIST_1) {
                PREHASH_UNSUPPORTED = true;
            }
            txReqPayload.writeUInt8(PREHASH_UNSUPPORTED ? 1 : 0, off);
            off += 1;
            // EIP1559 & EIP2930 struct version
            if (isEip1559) {
                txReqPayload.writeUInt8(2, off);
                off += 1; // Eip1559 type enum value
                if (maxPriorityFeePerGasBytes.length > 8)
                    throw new Error('maxPriorityFeePerGasBytes too large');
                maxPriorityFeePerGasBytes.copy(txReqPayload, off + (8 - maxPriorityFeePerGasBytes.length));
                off += 8; // Skip EIP1559 params
            }
            else if (isEip2930) {
                txReqPayload.writeUInt8(1, off);
                off += 1; // Eip2930 type enum value
                off += 8; // Skip EIP1559 params
            }
            else {
                off += 9; // Skip EIP1559 and EIP2930 params
            }
        }
        // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable
        var extraDataPayloads_1 = [];
        var prehash = null;
        // Create the buffer, prefix with chainId (if needed) and add data slice
        var dataSz = dataBytes.length || 0;
        var chainIdExtraSz = chainIdBufSz > 0 ? chainIdBufSz + 1 : 0;
        var dataToCopy = Buffer.alloc(dataSz + chainIdExtraSz);
        if (chainIdExtraSz > 0) {
            dataToCopy.writeUInt8(chainIdBufSz, 0);
            chainIdBuf.copy(dataToCopy, 1);
        }
        dataBytes.copy(dataToCopy, chainIdExtraSz);
        if (dataSz > MAX_BASE_DATA_SZ) {
            // Determine sizes and run through sanity checks
            var totalSz = dataSz + chainIdExtraSz;
            var maxSzAllowed = MAX_BASE_DATA_SZ + extraDataMaxFrames * extraDataFrameSz;
            if (prehashAllowed && totalSz > maxSzAllowed) {
                // If this payload is too large to send, but the Lattice allows a prehashed message, do that
                prehash = Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(rawTx, type)), 'hex');
            }
            else {
                if (!EXTRA_DATA_ALLOWED ||
                    (EXTRA_DATA_ALLOWED && totalSz > maxSzAllowed))
                    throw new Error("Data field too large (got ".concat(dataBytes.length, "; must be <=").concat(maxSzAllowed - chainIdExtraSz, " bytes)"));
                // Split overflow data into extraData frames
                var frames_1 = (0, util_1.splitFrames)(dataToCopy.slice(MAX_BASE_DATA_SZ), extraDataFrameSz);
                frames_1.forEach(function (frame) {
                    var szLE = Buffer.alloc(4);
                    szLE.writeUInt32LE(frame.length, 0);
                    extraDataPayloads_1.push(Buffer.concat([szLE, frame]));
                });
            }
        }
        else if (PREHASH_UNSUPPORTED) {
            // If something is unsupported in firmware but we want to allow such transactions,
            // we prehash the message here.
            prehash = Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(rawTx, type)), 'hex');
        }
        // Write the data size (does *NOT* include the chainId buffer, if that exists)
        txReqPayload.writeUInt16BE(dataBytes.length, off);
        off += 2;
        // Copy in the chainId buffer if needed
        if (chainIdBufSz > 0) {
            txReqPayload.writeUInt8(chainIdBufSz, off);
            off++;
            chainIdBuf.copy(txReqPayload, off);
            off += chainIdBufSz;
        }
        // Copy the first slice of the data itself. If this payload has been pre-hashed, include it
        // in the `data` field. This will result in a different Lattice screen being drawn.
        if (prehash) {
            prehash.copy(txReqPayload, off);
            off += MAX_BASE_DATA_SZ;
        }
        else {
            dataBytes.slice(0, MAX_BASE_DATA_SZ).copy(txReqPayload, off);
            off += MAX_BASE_DATA_SZ;
        }
        return {
            rawTx: rawTx,
            type: type,
            payload: txReqPayload.slice(0, off),
            extraDataPayloads: extraDataPayloads_1,
            schema: protocol_1.LatticeSignSchema.ethereum,
            chainId: chainId,
            useEIP155: useEIP155,
            signerPath: signerPath,
        };
    }
    catch (err) {
        return { err: err.message };
    }
};
// From ethereumjs-util
function stripZeros(a) {
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
}
// Given a 64-byte signature [r,s] we need to figure out the v value
// and attah the full signature to the end of the transaction payload
var buildEthRawTx = function (tx, sig, address) {
    // RLP-encode the data we sent to the lattice
    var hash = Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(tx.rawTx, tx.type)), 'hex');
    var newSig = addRecoveryParam(hash, sig, address, tx);
    // Use the signature to generate a new raw transaction payload
    // Strip the last 3 items and replace them with signature components
    var newRawTx = tx.useEIP155 ? tx.rawTx.slice(0, -3) : tx.rawTx;
    newRawTx.push(newSig.v);
    // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros
    // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187
    newRawTx.push(stripZeros(newSig.r));
    newRawTx.push(stripZeros(newSig.s));
    var rlpEncodedWithSig = Buffer.from((0, rlp_1.encode)(newRawTx));
    if (tx.type) {
        rlpEncodedWithSig = Buffer.concat([
            Buffer.from([tx.type]),
            rlpEncodedWithSig,
        ]);
    }
    return { rawTx: rlpEncodedWithSig.toString('hex'), sigWithV: newSig };
};
// Attach a recovery parameter to a signature by brute-forcing ECRecover
function addRecoveryParam(hashBuf, sig, address, txData) {
    if (txData === void 0) { txData = {}; }
    try {
        // Rebuild the keccak256 hash here so we can `ecrecover`
        var hash_2 = new Uint8Array(hashBuf);
        var v = 0;
        // Fix signature componenet lengths to 32 bytes each
        var r = (0, util_1.fixLen)(sig.r, 32);
        sig.r = r;
        var s = (0, util_1.fixLen)(sig.s, 32);
        sig.s = s;
        // Calculate the recovery param
        var rs = new Uint8Array(Buffer.concat([r, s]));
        var pubkey = secp256k1_1.default.ecdsaRecover(rs, v, hash_2, false).slice(1);
        // If the first `v` value is a match, return the sig!
        if (pubToAddrStr(pubkey) === address.toString('hex')) {
            sig.v = getRecoveryParam(v, txData);
            return sig;
        }
        // Otherwise, try the other `v` value
        v = 1;
        pubkey = secp256k1_1.default.ecdsaRecover(rs, v, hash_2, false).slice(1);
        if (pubToAddrStr(pubkey) === address.toString('hex')) {
            sig.v = getRecoveryParam(v, txData);
            return sig;
        }
        else {
            // If neither is a match, we should return an error
            throw new Error('Invalid Ethereum signature returned.');
        }
    }
    catch (err) {
        throw new Error(err);
    }
}
// Convert an RLP-serialized transaction (plus signature) into a transaction hash
var hashTransaction = function (serializedTx) {
    return (0, js_sha3_1.keccak256)(Buffer.from(serializedTx, 'hex'));
};
// Returns address string given public key buffer
function pubToAddrStr(pub) {
    return (0, js_sha3_1.keccak256)(pub).slice(-40);
}
// Convert a 0/1 `v` into a recovery param:
// * For non-EIP155 transactions, return `27 + v`
// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`
function getRecoveryParam(v, txData) {
    if (txData === void 0) { txData = {}; }
    var chainId = txData.chainId, useEIP155 = txData.useEIP155, type = txData.type;
    // For EIP1559 and EIP2930 transactions, we want the recoveryParam (0 or 1)
    // rather than the `v` value because the `chainId` is already included in the
    // transaction payload.
    if (type === 1 || type === 2) {
        return (0, util_1.ensureHexBuffer)(v, true); // 0 or 1, with 0 expected as an empty buffer
    }
    else if (false === useEIP155 || chainId === null) {
        // For ETH messages and non-EIP155 chains the set should be [27, 28] for `v`
        return Buffer.from(new bignumber_js_1.default(v).plus(27).toString(16), 'hex');
    }
    // We will use EIP155 in most cases. Convert v to a bignum and operate on it.
    // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36
    // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1
    // so we add 35 to that.
    var chainIdBuf = getChainIdBuf(chainId);
    var chainIdBN = new bignumber_js_1.default(chainIdBuf.toString('hex'), 16);
    return (0, util_1.ensureHexBuffer)("0x".concat(chainIdBN.times(2).plus(35).plus(v).toString(16)));
}
var chainIds = {
    mainnet: 1,
    roptsten: 3,
    rinkeby: 4,
    kovan: 42,
    goerli: 5,
};
// Get a buffer containing the chainId value.
// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian
function getChainIdBuf(chainId) {
    var b;
    // If our chainID is a hex string, we can convert it to a hex
    // buffer directly
    if (true === isValidChainIdHexNumStr(chainId))
        b = (0, util_1.ensureHexBuffer)(chainId);
    // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer
    else
        b = (0, util_1.ensureHexBuffer)("0x".concat(new bignumber_js_1.default(chainId).toString(16)));
    // Make sure the buffer is an allowed size
    if (b.length > 8)
        throw new Error('ChainID provided is too large.');
    // If this matches a u16, u32, or u64 size, return it now
    if (b.length <= 2 || b.length === 4 || b.length === 8)
        return b;
    // For other size buffers, we need to pack into u32 or u64 before returning;
    var buf;
    if (b.length === 3) {
        buf = Buffer.alloc(4);
        buf.writeUInt32BE(chainId);
    }
    else if (b.length <= 8) {
        buf = Buffer.alloc(8);
        b.copy(buf, 8 - b.length);
    }
    return buf;
}
// Determine if the chain uses EIP155 by default, based on the chainID
function chainUsesEIP155(chainID) {
    switch (chainID) {
        case 3: // ropsten
        case 4: // rinkeby
            return false;
        case 1: // mainnet
        case 42: // kovan
        case 5: // goerli
        default:
            // all others should use eip155
            return true;
    }
}
// Determine if a valid number was passed in as a hex string
function isValidChainIdHexNumStr(s) {
    if (typeof s !== 'string')
        return false;
    if (s.slice(0, 2) !== '0x')
        return false;
    try {
        var b = new bignumber_js_1.default(s, 16);
        return b.isNaN() === false;
    }
    catch (err) {
        return false;
    }
}
// If this is a nubmer that fits in one byte, we don't need to add it
// to the `data` buffer of the main transaction.
// Note the one edge case: we still need to use the `data` field for chainID=255.
function useChainIdBuffer(id) {
    var buf = getChainIdBuf(id);
    if (buf.length === 1)
        return buf.readUInt8(0) === 255;
    return true;
}
function buildPersonalSignRequest(req, input) {
    var MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;
    var VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;
    var L = 24 + MAX_BASE_MSG_SZ + 4;
    var off = 0;
    req.payload = Buffer.alloc(L);
    req.payload.writeUInt8(constants_1.ethMsgProtocol.SIGN_PERSONAL, 0);
    off += 1;
    // Write the signer path into the buffer
    var signerPathBuf = (0, util_1.buildSignerPathBuf)(input.signerPath, VAR_PATH_SZ);
    signerPathBuf.copy(req.payload, off);
    off += signerPathBuf.length;
    // Write the payload buffer. The payload can come in either as a buffer or as a string
    var payload = input.payload;
    // Determine if this is a hex string
    var displayHex = false;
    if (typeof input.payload === 'string') {
        if (input.payload.slice(0, 2) === '0x') {
            payload = (0, util_1.ensureHexBuffer)(input.payload);
            displayHex =
                false ===
                    constants_1.ASCII_REGEX.test(Buffer.from(input.payload.slice(2), 'hex').toString());
        }
        else {
            if (false === (0, util_1.isAsciiStr)(input.payload))
                throw new Error('Currently, the Lattice can only display ASCII strings.');
            payload = Buffer.from(input.payload);
        }
    }
    else if (typeof input.displayHex === 'boolean') {
        // If this is a buffer and the user has specified whether or not this
        // is a hex buffer with the optional argument, write that
        displayHex = input.displayHex;
    }
    else {
        // Otherwise, determine if this buffer is an ASCII string. If it is, set `displayHex` accordingly.
        // NOTE: THIS MEANS THAT NON-ASCII STRINGS WILL DISPLAY AS HEX SINCE WE CANNOT KNOW IF THE REQUESTER
        //        EXPECTED NON-ASCII CHARACTERS TO DISPLAY IN A STRING
        // TODO: Develop a more elegant solution for this
        if (!input.payload.toString)
            throw new Error('Unsupported input data type');
        displayHex = false === constants_1.ASCII_REGEX.test(input.payload.toString());
    }
    var fwConst = input.fwConstants;
    var maxSzAllowed = MAX_BASE_MSG_SZ + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;
    if (fwConst.personalSignHeaderSz) {
        // Account for the personal_sign header string
        maxSzAllowed -= fwConst.personalSignHeaderSz;
    }
    if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {
        // If this message will not fit and pre-hashing is allowed, do that
        req.payload.writeUInt8(displayHex, off);
        off += 1;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        var prehash = Buffer.from((0, js_sha3_1.keccak256)(Buffer.concat([get_personal_sign_prefix(payload.length), payload])), 'hex');
        prehash.copy(req.payload, off);
        req.prehash = prehash;
    }
    else {
        // Otherwise we can fit the payload.
        // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable
        var extraDataPayloads = getExtraData(payload, input);
        // Write the payload and metadata into our buffer
        req.extraDataPayloads = extraDataPayloads;
        req.msg = payload;
        req.payload.writeUInt8(displayHex, off);
        off += 1;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        payload.copy(req.payload, off);
    }
    return req;
}
function buildEIP712Request(req, input) {
    var _a = input.fwConstants, ethMaxMsgSz = _a.ethMaxMsgSz, varAddrPathSzAllowed = _a.varAddrPathSzAllowed, eip712MaxTypeParams = _a.eip712MaxTypeParams;
    var TYPED_DATA = constants_1.ethMsgProtocol.TYPED_DATA;
    var L = 24 + ethMaxMsgSz + 4;
    var off = 0;
    req.payload = Buffer.alloc(L);
    req.payload.writeUInt8(TYPED_DATA.enumIdx, 0);
    off += 1;
    // Write the signer path
    var signerPathBuf = (0, util_1.buildSignerPathBuf)(input.signerPath, varAddrPathSzAllowed);
    signerPathBuf.copy(req.payload, off);
    off += signerPathBuf.length;
    // Parse/clean the EIP712 payload, serialize with CBOR, and write to the payload
    var data = JSON.parse(JSON.stringify(input.payload));
    if (!data.primaryType || !data.types[data.primaryType])
        throw new Error('primaryType must be specified and the type must be included.');
    if (!data.message || !data.domain)
        throw new Error('message and domain must be specified.');
    if (0 > Object.keys(data.types).indexOf('EIP712Domain'))
        throw new Error('EIP712Domain type must be defined.');
    // Parse the payload to ensure we have valid EIP712 data types and that
    // they are encoded such that Lattice firmware can parse them.
    // We need two different encodings: one to send to the Lattice in a format that plays
    // nicely with our firmware CBOR decoder. The other is formatted to be consumable by
    // our EIP712 validation module.
    input.payload.message = parseEIP712Msg(JSON.parse(JSON.stringify(data.message)), JSON.parse(JSON.stringify(data.primaryType)), JSON.parse(JSON.stringify(data.types)), true);
    input.payload.domain = parseEIP712Msg(JSON.parse(JSON.stringify(data.domain)), 'EIP712Domain', JSON.parse(JSON.stringify(data.types)), true);
    data.domain = parseEIP712Msg(data.domain, 'EIP712Domain', data.types, false);
    data.message = parseEIP712Msg(data.message, data.primaryType, data.types, false);
    // Now build the message to be sent to the Lattice
    var payload = Buffer.from(borc_1.default.encode(data));
    var fwConst = input.fwConstants;
    var maxSzAllowed = ethMaxMsgSz + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;
    // Determine if we need to prehash
    var shouldPrehash = payload.length > maxSzAllowed;
    Object.keys(data.types).forEach(function (k) {
        if (data.types[k].length > eip712MaxTypeParams) {
            shouldPrehash = true;
        }
    });
    if (fwConst.ethMsgPreHashAllowed && shouldPrehash) {
        // If this payload is too large to send, but the Lattice allows a prehashed message, do that
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        var prehash = eth_eip712_util_browser_1.TypedDataUtils.hash(req.input.payload);
        var prehashBuf = Buffer.from(prehash);
        prehashBuf.copy(req.payload, off);
        req.prehash = prehash;
    }
    else {
        var extraDataPayloads = getExtraData(payload, input);
        req.extraDataPayloads = extraDataPayloads;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        payload.copy(req.payload, off);
        off += payload.length;
        // Slice out the part of the buffer that we didn't use.
        req.payload = req.payload.slice(0, off);
    }
    return req;
}
function getExtraData(payload, input) {
    var _a = input.fwConstants, ethMaxMsgSz = _a.ethMaxMsgSz, extraDataFrameSz = _a.extraDataFrameSz, extraDataMaxFrames = _a.extraDataMaxFrames;
    var MAX_BASE_MSG_SZ = ethMaxMsgSz;
    var EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
    var extraDataPayloads = [];
    if (payload.length > MAX_BASE_MSG_SZ) {
        // Determine sizes and run through sanity checks
        var maxSzAllowed = MAX_BASE_MSG_SZ + extraDataMaxFrames * extraDataFrameSz;
        if (!EXTRA_DATA_ALLOWED)
            throw new Error("Your message is ".concat(payload.length, " bytes, but can only be a maximum of ").concat(MAX_BASE_MSG_SZ));
        else if (EXTRA_DATA_ALLOWED && payload.length > maxSzAllowed)
            throw new Error("Your message is ".concat(payload.length, " bytes, but can only be a maximum of ").concat(maxSzAllowed));
        // Split overflow data into extraData frames
        var frames_2 = (0, util_1.splitFrames)(payload.slice(MAX_BASE_MSG_SZ), extraDataFrameSz);
        frames_2.forEach(function (frame) {
            var szLE = Buffer.alloc(4);
            szLE.writeUInt32LE(frame.length, 0);
            extraDataPayloads.push(Buffer.concat([szLE, frame]));
        });
    }
    return extraDataPayloads;
}
function parseEIP712Msg(msg, typeName, types, forJSParser) {
    if (forJSParser === void 0) { forJSParser = false; }
    var type = types[typeName];
    type.forEach(function (item) {
        var isArrayType = item.type.indexOf('[') > -1;
        var singularType = isArrayType
            ? item.type.slice(0, item.type.indexOf('['))
            : item.type;
        var isCustomType = Object.keys(types).indexOf(singularType) > -1;
        if (isCustomType && Array.isArray(msg)) {
            // For custom types we need to jump into the `msg` using the key (name of type) and
            // parse that entire sub-struct as if it were a message.
            // We will recurse into sub-structs until we reach a level where every item is an
            // elementary (i.e. non-custom) type.
            // For arrays, we need to loop through each message item.
            for (var i = 0; i < msg.length; i++) {
                msg[i][item.name] = parseEIP712Msg(msg[i][item.name], singularType, types, forJSParser);
            }
        }
        else if (isCustomType) {
            // Not an array means we can jump directly into the sub-struct to convert
            msg[item.name] = parseEIP712Msg(msg[item.name], singularType, types, forJSParser);
        }
        else if (Array.isArray(msg)) {
            // If we have an array for this particular type and the type we are parsing
            // is *not* a custom type, loop through the array elements and convert the types.
            for (var i = 0; i < msg.length; i++) {
                if (isArrayType) {
                    // If this type is itself an array, loop through those elements and parse individually.
                    // This code is not reachable for custom types so we assume these are arrays of
                    // elementary types.
                    for (var j = 0; j < msg[i][item.name].length; j++) {
                        msg[i][item.name][j] = parseEIP712Item(msg[i][item.name][j], singularType, forJSParser);
                    }
                }
                else {
                    // Non-arrays parse + replace one value for the elementary type
                    msg[i][item.name] = parseEIP712Item(msg[i][item.name], singularType, forJSParser);
                }
            }
        }
        else if (isArrayType) {
            // If we have an elementary array type and a non-array message level,
            //loop through the array and parse + replace  each item individually.
            for (var i = 0; i < msg[item.name].length; i++) {
                msg[item.name][i] = parseEIP712Item(msg[item.name][i], singularType, forJSParser);
            }
        }
        else {
            // If this is a singular elementary type, simply parse + replace.
            msg[item.name] = parseEIP712Item(msg[item.name], singularType, forJSParser);
        }
    });
    return msg;
}
function parseEIP712Item(data, type, forJSParser) {
    if (forJSParser === void 0) { forJSParser = false; }
    if (type === 'bytes') {
        // Variable sized bytes need to be buffer type
        data = (0, util_1.ensureHexBuffer)(data);
        if (forJSParser) {
            // For EIP712 encoding module it's easier to encode hex strings
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (type.slice(0, 5) === 'bytes') {
        // Fixed sizes bytes need to be buffer type. We also add some sanity checks.
        var nBytes = parseInt(type.slice(5));
        data = (0, util_1.ensureHexBuffer)(data);
        if (data.length !== nBytes)
            throw new Error("Expected ".concat(type, " type, but got ").concat(data.length, " bytes"));
        if (forJSParser) {
            // For EIP712 encoding module it's easier to encode hex strings
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (type === 'address') {
        // Address must be a 20 byte buffer
        data = (0, util_1.ensureHexBuffer)(data);
        // Edge case to handle the 0-address
        if (data.length === 0) {
            data = Buffer.alloc(20);
        }
        if (data.length !== 20)
            throw new Error("Address type must be 20 bytes, but got ".concat(data.length, " bytes"));
        // For EIP712 encoding module it's easier to encode hex strings
        if (forJSParser) {
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (constants_1.ethMsgProtocol.TYPED_DATA.typeCodes[type] &&
        (type.indexOf('uint') > -1 || type.indexOf('int') > -1)) {
        var b = (0, util_1.ensureHexBuffer)(data);
        // Edge case to handle 0-value bignums
        if (b.length === 0) {
            b = Buffer.from('00', 'hex');
        }
        // Uint256s should be encoded as bignums.
        if (forJSParser) {
            // For EIP712 encoding in this module we need strings to represent the numbers
            data = "0x".concat(b.toString('hex'));
        }
        else {
            // `bignumber.js` is needed for `cbor` encoding, which gets sent to the Lattice and plays
            // nicely with its firmware cbor lib.
            // NOTE: If we instantiate a `bignumber.js` object, it will not match what `borc` creates
            // when run inside of the browser (i.e. MetaMask). Thus we introduce this hack to make sure
            // we are creating a compatible type.
            // TODO: Find another cbor lib that is compataible with the firmware's lib in a browser
            // context. This is surprisingly difficult - I tried several libs and only cbor/borc have
            // worked (borc is a supposedly "browser compatible" version of cbor)
            data = new borc_1.default.Encoder().semanticTypes[1][0](b.toString('hex'), 16);
        }
    }
    else if (type === 'bool') {
        // Booleans need to be cast to a u8
        data = data === true ? 1 : 0;
    }
    // Other types don't need to be modified
    return data;
}
function get_personal_sign_prefix(L) {
    return Buffer.from("\u0019Ethereum Signed Message:\n".concat(L.toString()), 'utf-8');
}
function get_rlp_encoded_preimage(rawTx, txType) {
    if (txType) {
        return Buffer.concat([Buffer.from([txType]), Buffer.from((0, rlp_1.encode)(rawTx))]);
    }
    else {
        return Buffer.from((0, rlp_1.encode)(rawTx));
    }
}
// ======
// TEMPORARY BRIDGE
// We are migrating from all legacy signing paths to a single generic
// signing route. If users are attempting a legacy transaction request
// against a Lattice on firmware v0.15.0 and above, we need to convert
// that to a generic signing request.
//
// NOTE: Once we deprecate, we will remove this entire file
// ======
var ethConvertLegacyToGenericReq = function (req) {
    var common;
    if (!req.chainId || (0, util_1.ensureHexBuffer)(req.chainId).toString('hex') === '01') {
        common = new common_1.Common({ chain: common_1.Chain.Mainnet, hardfork: common_1.Hardfork.London });
    }
    else {
        // Not every network will support these EIPs but we will allow
        // signing of transactions using them
        common = common_1.Common.custom({ chainId: Number(req.chainId) }, { hardfork: common_1.Hardfork.London, eips: [1559, 2930] });
    }
    var tx = tx_1.TransactionFactory.fromTxData(req, { common: common });
    // Get the raw transaction payload to be hashed and signed.
    // Different `@ethereumjs/tx` Transaction object types have
    // slightly different APIs around this.
    if (req.type) {
        // Newer transaction types
        return tx.getMessageToSign(false);
    }
    else {
        // Legacy transaction type
        return Buffer.from((0, rlp_1.encode)(tx.getMessageToSign(false)));
    }
};
exports.default = {
    buildEthereumMsgRequest: buildEthereumMsgRequest,
    validateEthereumMsgResponse: validateEthereumMsgResponse,
    buildEthereumTxRequest: buildEthereumTxRequest,
    buildEthRawTx: buildEthRawTx,
    hashTransaction: hashTransaction,
    chainIds: chainIds,
    ensureHexBuffer: util_1.ensureHexBuffer,
    ethConvertLegacyToGenericReq: ethConvertLegacyToGenericReq,
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\ethereum.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\addKvRecords.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CaddKvRecords.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeAddKvRecordsRequest = exports.validateAddKvRequest = exports.addKvRecords = void 0;
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
/**
 * `addKvRecords` takes in a set of key-value records and sends a request to add them to the
 * Lattice.
 * @category Lattice
 * @returns A callback with an error or null.
 */
function addKvRecords(_a) {
    var client = _a.client, records = _a.records, type = _a.type, caseSensitive = _a.caseSensitive;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, data, _c, decryptedData, newEphemeralPub;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    (0, exports.validateAddKvRequest)({ records: records, fwConstants: fwConstants });
                    data = (0, exports.encodeAddKvRecordsRequest)({
                        records: records,
                        type: type,
                        caseSensitive: caseSensitive,
                        fwConstants: fwConstants,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.addKvRecords,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _c = _d.sent(), decryptedData = _c.decryptedData, newEphemeralPub = _c.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, decryptedData];
            }
        });
    });
}
exports.addKvRecords = addKvRecords;
var validateAddKvRequest = function (_a) {
    var records = _a.records, fwConstants = _a.fwConstants;
    (0, validators_1.validateKvRecords)(records, fwConstants);
};
exports.validateAddKvRequest = validateAddKvRequest;
var encodeAddKvRecordsRequest = function (_a) {
    var records = _a.records, type = _a.type, caseSensitive = _a.caseSensitive, fwConstants = _a.fwConstants;
    var payload = Buffer.alloc(1 + 139 * fwConstants.kvActionMaxNum);
    payload.writeUInt8(Object.keys(records).length, 0);
    var off = 1;
    Object.entries(records).forEach(function (_a) {
        var _key = _a[0], _val = _a[1];
        var _b = (0, validators_1.validateKvRecord)({ key: _key, val: _val }, fwConstants), key = _b.key, val = _b.val;
        // Skip the ID portion. This will get added by firmware.
        payload.writeUInt32LE(0, off);
        off += 4;
        payload.writeUInt32LE(type, off);
        off += 4;
        payload.writeUInt8(caseSensitive ? 1 : 0, off);
        off += 1;
        payload.writeUInt8(String(key).length + 1, off);
        off += 1;
        Buffer.from(String(key)).copy(payload, off);
        off += fwConstants.kvKeyMaxStrSz + 1;
        payload.writeUInt8(String(val).length + 1, off);
        off += 1;
        Buffer.from(String(val)).copy(payload, off);
        off += fwConstants.kvValMaxStrSz + 1;
    });
    return payload;
};
exports.encodeAddKvRecordsRequest = encodeAddKvRecordsRequest;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\addKvRecords.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\connect.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/predicates":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\predicates.js","../shared/utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Cconnect.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeConnectResponse = exports.validateConnectRequest = exports.connect = void 0;
var protocol_1 = require("../protocol");
var predicates_1 = require("../shared/predicates");
var utilities_1 = require("../shared/utilities");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
function connect(_a) {
    var client = _a.client, id = _a.id;
    return __awaiter(this, void 0, void 0, function () {
        var _b, deviceId, key, baseUrl, url, respPayloadData, _c, isPaired, fwVersion, activeWallets, ephemeralPub;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, exports.validateConnectRequest)({
                        deviceId: id,
                        key: client.key,
                        baseUrl: client.baseUrl,
                    }), deviceId = _b.deviceId, key = _b.key, baseUrl = _b.baseUrl;
                    url = "".concat(baseUrl, "/").concat(deviceId);
                    return [4 /*yield*/, (0, protocol_1.connectSecureRequest)({
                            url: url,
                            pubkey: client.publicKey,
                        })];
                case 1:
                    respPayloadData = _d.sent();
                    return [4 /*yield*/, (0, exports.decodeConnectResponse)(respPayloadData, key)];
                case 2:
                    _c = _d.sent(), isPaired = _c.isPaired, fwVersion = _c.fwVersion, activeWallets = _c.activeWallets, ephemeralPub = _c.ephemeralPub;
                    // Update client state with response data
                    client.mutate({
                        deviceId: deviceId,
                        ephemeralPub: ephemeralPub,
                        url: url,
                        isPaired: isPaired,
                        fwVersion: fwVersion,
                        activeWallets: activeWallets,
                    });
                    if (!(isPaired && !(0, predicates_1.doesFetchWalletsOnLoad)(client.getFwVersion()))) return [3 /*break*/, 4];
                    return [4 /*yield*/, client.fetchActiveWallet()];
                case 3:
                    _d.sent();
                    _d.label = 4;
                case 4: 
                // Return flag indicating whether we are paired or not.
                // If we are *not* already paired, the Lattice is now in
                // pairing mode and expects a `finalizePairing` encrypted
                // request as a follow up.
                return [2 /*return*/, isPaired];
            }
        });
    });
}
exports.connect = connect;
var validateConnectRequest = function (_a) {
    var deviceId = _a.deviceId, key = _a.key, baseUrl = _a.baseUrl;
    var validDeviceId = (0, validators_1.validateDeviceId)(deviceId);
    var validKey = (0, validators_1.validateKey)(key);
    var validBaseUrl = (0, validators_1.validateBaseUrl)(baseUrl);
    return {
        deviceId: validDeviceId,
        key: validKey,
        baseUrl: validBaseUrl,
    };
};
exports.validateConnectRequest = validateConnectRequest;
/**
 * `decodeConnectResponse` will call `StartPairingMode` on the device, which gives the user 60 seconds to
 * finalize the pairing. This will return an ephemeral public key, which is needed for the next
 * request.
 * - If the device is already paired, this ephemPub is simply used to encrypt the next request.
 * - If the device is not paired, it is needed to pair the device within 60 seconds.
 * @category Device Response
 * @internal
 * @returns true if we are paired to the device already
 */
var decodeConnectResponse = function (response, key) {
    var off = 0;
    var isPaired = response.readUInt8(off) === protocol_1.ProtocolConstants.pairingStatus.paired;
    off++;
    // If we are already paired, we get the next ephemeral key
    var pub = response.slice(off, off + 65).toString('hex');
    off += 65; // Set the public key
    var ephemeralPub = (0, util_1.getP256KeyPairFromPub)(pub);
    // Grab the firmware version (will be 0-length for older fw versions) It is of format
    // |fix|minor|major|reserved|
    var fwVersion = response.slice(off, off + 4);
    off += 4;
    // If we are already paired, the response will include some encrypted data about the current
    // wallets This data was added in Lattice firmware v0.14.1
    if (isPaired) {
        //TODO && this._fwVersionGTE(0, 14, 1)) {
        // Later versions of firmware added wallet info
        var encWalletData = response.slice(off, off + 160);
        off += 160;
        var sharedSecret = (0, utilities_1.getSharedSecret)(key, ephemeralPub);
        var decWalletData = (0, util_1.aes256_decrypt)(encWalletData, sharedSecret);
        // Sanity check to make sure the last part of the decrypted data is empty. The last 2 bytes
        // are AES padding
        if (decWalletData[decWalletData.length - 2] !== 0 ||
            decWalletData[decWalletData.length - 1] !== 0) {
            throw new Error('Failed to connect to Lattice.');
        }
        var activeWallets = (0, utilities_1.parseWallets)(decWalletData);
        return { isPaired: isPaired, fwVersion: fwVersion, activeWallets: activeWallets, ephemeralPub: ephemeralPub };
    }
    // return the state of our pairing
    return { isPaired: isPaired, fwVersion: fwVersion, activeWallets: undefined, ephemeralPub: ephemeralPub };
};
exports.decodeConnectResponse = decodeConnectResponse;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\connect.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchActiveWallet.js", {"../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CfetchActiveWallet.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeFetchActiveWalletResponse = exports.fetchActiveWallet = void 0;
var constants_1 = require("../constants");
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
/**
 * Fetch the active wallet in the device.
 *
 * The Lattice has two wallet interfaces: internal and external. If a SafeCard is inserted and
 * unlocked, the external interface is considered "active" and this will return its {@link Wallet}
 * data. Otherwise it will return the info for the internal Lattice wallet.
 */
function fetchActiveWallet(_a) {
    var client = _a.client;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, _c, decryptedData, newEphemeralPub, activeWallets, validActiveWallets;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub;
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: Buffer.alloc(0),
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.getWallets,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _c = _d.sent(), decryptedData = _c.decryptedData, newEphemeralPub = _c.newEphemeralPub;
                    activeWallets = (0, exports.decodeFetchActiveWalletResponse)(decryptedData);
                    validActiveWallets = (0, validators_1.validateActiveWallets)(activeWallets);
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                        activeWallets: validActiveWallets,
                    });
                    return [2 /*return*/, validActiveWallets];
            }
        });
    });
}
exports.fetchActiveWallet = fetchActiveWallet;
var decodeFetchActiveWalletResponse = function (data) {
    // Read the external wallet data first. If it is non-null, the external wallet will be the
    // active wallet of the device and we should save it. If the external wallet is blank, it means
    // there is no card present and we should save and use the interal wallet. If both wallets are
    // empty, it means the device still needs to be set up.
    var walletDescriptorLen = 71;
    // Internal first
    var activeWallets = {
        internal: {
            uid: constants_1.EMPTY_WALLET_UID,
            external: false,
            name: Buffer.alloc(0),
            capabilities: 0,
        },
        external: {
            uid: constants_1.EMPTY_WALLET_UID,
            external: true,
            name: Buffer.alloc(0),
            capabilities: 0,
        },
    };
    var off = 0;
    activeWallets.internal.uid = data.slice(off, off + 32);
    activeWallets.internal.capabilities = data.readUInt32BE(off + 32);
    activeWallets.internal.name = data.slice(off + 36, off + walletDescriptorLen);
    // Offset the first item
    off += walletDescriptorLen;
    // External
    activeWallets.external.uid = data.slice(off, off + 32);
    activeWallets.external.capabilities = data.readUInt32BE(off + 32);
    activeWallets.external.name = data.slice(off + 36, off + walletDescriptorLen);
    return activeWallets;
};
exports.decodeFetchActiveWalletResponse = decodeFetchActiveWalletResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\fetchActiveWallet.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchEncData.js", {"../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","uuid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CfetchEncData.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeFetchEncData = exports.encodeFetchEncDataRequest = exports.validateFetchEncDataRequest = exports.fetchEncData = void 0;
/**
 * Export encrypted data from the Lattice. Data must conform
 * to known schema, e.g. EIP2335 derived privkey export.
 */
var uuid_1 = require("uuid");
var constants_1 = require("../constants");
var protocol_1 = require("../protocol");
var utilities_1 = require("../shared/utilities");
var validators_1 = require("../shared/validators");
var ENC_DATA = constants_1.EXTERNAL.ENC_DATA;
var ENC_DATA_ERR_STR = 'Unknown encrypted data export type requested. Exiting.';
var ENC_DATA_REQ_DATA_SZ = 1025;
var ENC_DATA_RESP_SZ = {
    EIP2335: {
        CIPHERTEXT: 32,
        SALT: 32,
        CHECKSUM: 32,
        IV: 16,
        PUBKEY: 48,
    },
};
function fetchEncData(_a) {
    var client = _a.client, schema = _a.schema, params = _a.params;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwVersion, activeWallet, data, _c, decryptedData, newEphemeralPub;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwVersion = _b.fwVersion;
                    activeWallet = (0, validators_1.validateWallet)(client.getActiveWallet());
                    (0, exports.validateFetchEncDataRequest)({ params: params });
                    data = (0, exports.encodeFetchEncDataRequest)({
                        schema: schema,
                        params: params,
                        fwVersion: fwVersion,
                        activeWallet: activeWallet,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.fetchEncryptedData,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _c = _d.sent(), decryptedData = _c.decryptedData, newEphemeralPub = _c.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, (0, exports.decodeFetchEncData)({ data: decryptedData, schema: schema, params: params })];
            }
        });
    });
}
exports.fetchEncData = fetchEncData;
var validateFetchEncDataRequest = function (_a) {
    var params = _a.params;
    // Validate derivation path
    (0, validators_1.validateStartPath)(params.path);
};
exports.validateFetchEncDataRequest = validateFetchEncDataRequest;
var encodeFetchEncDataRequest = function (_a) {
    var schema = _a.schema, params = _a.params, fwVersion = _a.fwVersion, activeWallet = _a.activeWallet;
    // Check firmware version
    if (fwVersion.major < 1 && fwVersion.minor < 17) {
        throw new Error('Firmware version >=v0.17.0 is required for encrypted data export.');
    }
    // Update params depending on what type of data is being exported
    if (schema === ENC_DATA.SCHEMAS.BLS_KEYSTORE_EIP2335_PBKDF_V4) {
        // Set the wallet UID to the client's current active wallet
        params.walletUID = activeWallet.uid;
    }
    else {
        throw new Error(ENC_DATA_ERR_STR);
    }
    // Build the payload data
    var payload = Buffer.alloc(ENC_DATA_REQ_DATA_SZ);
    var off = 0;
    payload.writeUInt8(schema, off);
    off += 1;
    if (schema === ENC_DATA.SCHEMAS.BLS_KEYSTORE_EIP2335_PBKDF_V4) {
        params.walletUID.copy(payload, off);
        off += params.walletUID.length;
        payload.writeUInt8(params.path.length, off);
        off += 1;
        for (var i = 0; i < 5; i++) {
            if (i <= params.path.length) {
                payload.writeUInt32LE(params.path[i], off);
            }
            off += 4;
        }
        if (params.c) {
            payload.writeUInt32LE(params.c, off);
        }
        off += 4;
        return payload;
    }
    else {
        throw new Error(ENC_DATA_ERR_STR);
    }
};
exports.encodeFetchEncDataRequest = encodeFetchEncDataRequest;
var decodeFetchEncData = function (_a) {
    var data = _a.data, schema = _a.schema, params = _a.params;
    var off = 0;
    if (schema === ENC_DATA.SCHEMAS.BLS_KEYSTORE_EIP2335_PBKDF_V4) {
        var respData = {};
        var _b = ENC_DATA_RESP_SZ.EIP2335, CIPHERTEXT = _b.CIPHERTEXT, SALT = _b.SALT, CHECKSUM = _b.CHECKSUM, IV = _b.IV, PUBKEY = _b.PUBKEY;
        var expectedSz = 4 + // iterations = u32
            CIPHERTEXT +
            SALT +
            CHECKSUM +
            IV +
            PUBKEY;
        var dataSz = data.readUInt32LE(off);
        off += 4;
        if (dataSz !== expectedSz) {
            throw new Error('Invalid data returned from Lattice. Expected EIP2335 data.');
        }
        respData.iterations = data.readUInt32LE(off);
        off += 4;
        respData.cipherText = data.slice(off, off + CIPHERTEXT);
        off += CIPHERTEXT;
        respData.salt = data.slice(off, off + SALT);
        off += SALT;
        respData.checksum = data.slice(off, off + CHECKSUM);
        off += CHECKSUM;
        respData.iv = data.slice(off, off + IV);
        off += IV;
        respData.pubkey = data.slice(off, off + PUBKEY);
        off += PUBKEY;
        return formatEIP2335ExportData(respData, params.path);
    }
    else {
        throw new Error(ENC_DATA_ERR_STR);
    }
};
exports.decodeFetchEncData = decodeFetchEncData;
var formatEIP2335ExportData = function (resp, path) {
    try {
        var iterations = resp.iterations, salt = resp.salt, checksum = resp.checksum, iv = resp.iv, cipherText = resp.cipherText, pubkey = resp.pubkey;
        return Buffer.from(JSON.stringify({
            'version': 4,
            'uuid': (0, uuid_1.v4)(),
            'path': (0, utilities_1.getPathStr)(path),
            'pubkey': pubkey.toString('hex'),
            'crypto': {
                'kdf': {
                    'function': 'pbkdf2',
                    'params': {
                        'dklen': 32,
                        'c': iterations,
                        'prf': 'hmac-sha256',
                        'salt': salt.toString('hex'),
                    },
                    'message': ''
                },
                'checksum': {
                    'function': 'sha256',
                    'params': {},
                    'message': checksum.toString('hex'),
                },
                'cipher': {
                    'function': 'aes-128-ctr',
                    'params': {
                        'iv': iv.toString('hex'),
                    },
                    'message': cipherText.toString('hex')
                }
            }
        }));
    }
    catch (err) {
        throw Error("Failed to format EIP2335 return data: ".concat(err.toString()));
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\fetchEncData.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getAddresses.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","bitwise":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bitwise\\index.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CgetAddresses.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeGetAddressesResponse = exports.encodeGetAddressesRequest = exports.validateGetAddressesRequest = exports.getAddresses = void 0;
var bitwise_1 = __importDefault(require("bitwise"));
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
/**
 * `getAddresses` takes a starting path and a number to get the addresses or public keys associated
 * with the active wallet.
 * @category Lattice
 * @returns An array of addresses or public keys.
 */
function getAddresses(_a) {
    var client = _a.client, _startPath = _a.startPath, _n = _a.n, _flag = _a.flag;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, activeWallet, _c, startPath, n, flag, data, _d, decryptedData, newEphemeralPub;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    activeWallet = (0, validators_1.validateWallet)(client.getActiveWallet());
                    _c = (0, exports.validateGetAddressesRequest)({
                        startPath: _startPath,
                        n: _n,
                        flag: _flag,
                    }), startPath = _c.startPath, n = _c.n, flag = _c.flag;
                    data = (0, exports.encodeGetAddressesRequest)({
                        startPath: startPath,
                        n: n,
                        flag: flag,
                        fwConstants: fwConstants,
                        wallet: activeWallet,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.getAddresses,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _d = _e.sent(), decryptedData = _d.decryptedData, newEphemeralPub = _d.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, (0, exports.decodeGetAddressesResponse)(decryptedData, flag)];
            }
        });
    });
}
exports.getAddresses = getAddresses;
var validateGetAddressesRequest = function (_a) {
    var startPath = _a.startPath, n = _a.n, flag = _a.flag;
    return {
        startPath: (0, validators_1.validateStartPath)(startPath),
        n: (0, validators_1.validateNAddresses)(n),
        flag: (0, validators_1.validateIsUInt4)(flag),
    };
};
exports.validateGetAddressesRequest = validateGetAddressesRequest;
var encodeGetAddressesRequest = function (_a) {
    var _b;
    var startPath = _a.startPath, n = _a.n, flag = _a.flag, fwConstants = _a.fwConstants, wallet = _a.wallet;
    var flags = fwConstants.getAddressFlags || [];
    var isPubkeyOnly = flags.indexOf(flag) > -1 &&
        (flag === protocol_1.LatticeGetAddressesFlag.ed25519Pubkey ||
            flag === protocol_1.LatticeGetAddressesFlag.secp256k1Pubkey ||
            flag === protocol_1.LatticeGetAddressesFlag.bls12_381Pubkey);
    if (!isPubkeyOnly && !(0, util_1.isValidAssetPath)(startPath, fwConstants)) {
        throw new Error('Derivation path or flag is not supported. Try updating Lattice firmware.');
    }
    var sz = 32 + 20 + 1; // walletUID + 5 u32 indices + count/flag
    if (fwConstants.varAddrPathSzAllowed) {
        sz += 1; // pathDepth
    }
    else if (startPath.length !== 5) {
        throw new Error('Your Lattice firmware only supports derivation paths with 5 indices. Please upgrade.');
    }
    var payload = Buffer.alloc(sz);
    var off = 0;
    wallet.uid.copy(payload, off);
    off += 32;
    // Build the start path (5x u32 indices)
    if (fwConstants.varAddrPathSzAllowed) {
        payload.writeUInt8(startPath.length, off);
        off += 1;
    }
    for (var i = 0; i < 5; i++) {
        if (i <= startPath.length) {
            var val_1 = (_b = startPath[i]) !== null && _b !== void 0 ? _b : 0;
            payload.writeUInt32BE(val_1, off);
        }
        off += 4;
    }
    // Specify the number of subsequent addresses to request. We also allow the user to skip the
    // cache and request any address related to the asset in the wallet.
    var val, flagVal = 0;
    if (fwConstants.addrFlagsAllowed) {
        // A 4-bit flag can be used for non-standard address requests Client needs to be combined with
        // `n` as a 4 bit value
        flagVal =
            fwConstants.getAddressFlags &&
                fwConstants.getAddressFlags.indexOf(flag) > -1
                ? flag
                : 0;
        var flagBits = bitwise_1.default.nibble.read(flagVal);
        var countBits = bitwise_1.default.nibble.read(n);
        val = bitwise_1.default.byte.write(flagBits.concat(countBits));
    }
    else {
        // Very old firmware does not support client flag. We can deprecate client soon.
        val = n;
    }
    payload.writeUInt8(val, off);
    off++;
    return payload;
};
exports.encodeGetAddressesRequest = encodeGetAddressesRequest;
/**
 * @internal
 * @return an array of address strings or pubkey buffers
 */
var decodeGetAddressesResponse = function (data, flag) {
    var off = 0;
    // Look for addresses until we reach the end (a 4 byte checksum)
    var addrs = [];
    // Pubkeys are formatted differently in the response
    var arePubkeys = flag === protocol_1.LatticeGetAddressesFlag.secp256k1Pubkey ||
        flag === protocol_1.LatticeGetAddressesFlag.ed25519Pubkey ||
        flag === protocol_1.LatticeGetAddressesFlag.bls12_381Pubkey;
    if (arePubkeys) {
        off += 1; // skip uint8 representing pubkey type
    }
    var respDataLength = protocol_1.ProtocolConstants.msgSizes.secure.data.response.encrypted[protocol_1.LatticeSecureEncryptedRequestType.getAddresses];
    while (off < respDataLength) {
        if (arePubkeys) {
            // Pubkeys are shorter and are returned as buffers
            var pubBytes = data.slice(off, off + 65);
            var isEmpty = pubBytes.every(function (byte) { return byte === 0x00; });
            if (!isEmpty && flag === protocol_1.LatticeGetAddressesFlag.ed25519Pubkey) {
                // ED25519 pubkeys are 32 bytes
                addrs.push(pubBytes.slice(0, 32));
            }
            else if (!isEmpty && flag === protocol_1.LatticeGetAddressesFlag.bls12_381Pubkey) {
                // BLS12_381_G1 keys are 48 bytes
                addrs.push(pubBytes.slice(0, 48));
            }
            else if (!isEmpty) {
                // Only other returned pubkeys are ECC, or 65 bytes Note that we return full
                // (uncompressed) ECC pubkeys
                addrs.push(pubBytes);
            }
            off += 65;
        }
        else {
            // Otherwise we are dealing with address strings
            var addrBytes = data.slice(off, off + protocol_1.ProtocolConstants.addrStrLen);
            off += protocol_1.ProtocolConstants.addrStrLen;
            // Return the UTF-8 representation
            var len = addrBytes.indexOf(0); // First 0 is the null terminator
            if (len > 0) {
                addrs.push(addrBytes.slice(0, len).toString());
            }
        }
    }
    return addrs;
};
exports.decodeGetAddressesResponse = decodeGetAddressesResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\getAddresses.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getKvRecords.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CgetKvRecords.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeGetKvRecordsResponse = exports.encodeGetKvRecordsRequest = exports.validateGetKvRequest = exports.getKvRecords = void 0;
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
function getKvRecords(_a) {
    var client = _a.client, _type = _a.type, _n = _a.n, _start = _a.start;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, _c, type, n, start, data, _d, decryptedData, newEphemeralPub;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    _c = (0, exports.validateGetKvRequest)({
                        type: _type,
                        n: _n,
                        start: _start,
                        fwConstants: fwConstants,
                    }), type = _c.type, n = _c.n, start = _c.start;
                    data = (0, exports.encodeGetKvRecordsRequest)({ type: type, n: n, start: start });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.getKvRecords,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _d = _e.sent(), decryptedData = _d.decryptedData, newEphemeralPub = _d.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, (0, exports.decodeGetKvRecordsResponse)(decryptedData, fwConstants)];
            }
        });
    });
}
exports.getKvRecords = getKvRecords;
var validateGetKvRequest = function (_a) {
    var fwConstants = _a.fwConstants, n = _a.n, type = _a.type, start = _a.start;
    if (!fwConstants.kvActionsAllowed) {
        throw new Error('Unsupported. Please update firmware.');
    }
    if (!n || n < 1) {
        throw new Error('You must request at least one record.');
    }
    if (n > fwConstants.kvActionMaxNum) {
        throw new Error("You may only request up to ".concat(fwConstants.kvActionMaxNum, " records at once."));
    }
    if (type !== 0 && !type) {
        throw new Error('You must specify a type.');
    }
    if (start !== 0 && !start) {
        throw new Error('You must specify a type.');
    }
    return { fwConstants: fwConstants, n: n, type: type, start: start };
};
exports.validateGetKvRequest = validateGetKvRequest;
var encodeGetKvRecordsRequest = function (_a) {
    var type = _a.type, n = _a.n, start = _a.start;
    var payload = Buffer.alloc(9);
    payload.writeUInt32LE(type, 0);
    payload.writeUInt8(n, 4);
    payload.writeUInt32LE(start, 5);
    return payload;
};
exports.encodeGetKvRecordsRequest = encodeGetKvRecordsRequest;
var decodeGetKvRecordsResponse = function (data, fwConstants) {
    var off = 0;
    var nTotal = data.readUInt32BE(off);
    off += 4;
    var nFetched = parseInt(data.slice(off, off + 1).toString('hex'), 16);
    off += 1;
    if (nFetched > fwConstants.kvActionMaxNum)
        throw new Error('Too many records fetched. Firmware error.');
    var records = [];
    for (var i = 0; i < nFetched; i++) {
        var r = {};
        r.id = data.readUInt32BE(off);
        off += 4;
        r.type = data.readUInt32BE(off);
        off += 4;
        r.caseSensitive =
            parseInt(data.slice(off, off + 1).toString('hex'), 16) === 1
                ? true
                : false;
        off += 1;
        var keySz = parseInt(data.slice(off, off + 1).toString('hex'), 16);
        off += 1;
        r.key = data.slice(off, off + keySz - 1).toString();
        off += fwConstants.kvKeyMaxStrSz + 1;
        var valSz = parseInt(data.slice(off, off + 1).toString('hex'), 16);
        off += 1;
        r.val = data.slice(off, off + valSz - 1).toString();
        off += fwConstants.kvValMaxStrSz + 1;
        records.push(r);
    }
    return {
        records: records,
        total: nTotal,
        fetched: nFetched,
    };
};
exports.decodeGetKvRecordsResponse = decodeGetKvRecordsResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\getKvRecords.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\index.js", {"./addKvRecords":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\addKvRecords.js","./connect":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\connect.js","./fetchActiveWallet":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchActiveWallet.js","./fetchEncData":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchEncData.js","./getAddresses":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getAddresses.js","./getKvRecords":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getKvRecords.js","./pair":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\pair.js","./removeKvRecords":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\removeKvRecords.js","./sign":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\sign.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./addKvRecords"), exports);
__exportStar(require("./connect"), exports);
__exportStar(require("./fetchEncData"), exports);
__exportStar(require("./fetchActiveWallet"), exports);
__exportStar(require("./getAddresses"), exports);
__exportStar(require("./getKvRecords"), exports);
__exportStar(require("./pair"), exports);
__exportStar(require("./removeKvRecords"), exports);
__exportStar(require("./sign"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\pair.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Cpair.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePairRequest = exports.pair = void 0;
var protocol_1 = require("../protocol");
var utilities_1 = require("../shared/utilities");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
/**
 * If a pairing secret is provided, `pair` uses it to sign a hash of the public key, name, and
 * pairing secret. It then sends the name and signature to the device. If no pairing secret is
 * provided, `pair` sends a zero-length name buffer to the device.
 * @category Lattice
 * @returns The active wallet object.
 */
function pair(_a) {
    var client = _a.client, pairingSecret = _a.pairingSecret;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, appName, key, data, newEphemeralPub;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, appName = _b.appName, key = _b.key;
                    data = (0, exports.encodePairRequest)({ pairingSecret: pairingSecret, key: key, appName: appName });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.finalizePairing,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    newEphemeralPub = (_c.sent()).newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                        isPaired: true,
                    });
                    return [4 /*yield*/, client.fetchActiveWallet()];
                case 2:
                    _c.sent();
                    return [2 /*return*/, client.hasActiveWallet()];
            }
        });
    });
}
exports.pair = pair;
var encodePairRequest = function (_a) {
    var key = _a.key, pairingSecret = _a.pairingSecret, appName = _a.appName;
    // Build the payload data
    var pubKeyBytes = (0, utilities_1.getPubKeyBytes)(key);
    var nameBuf = Buffer.alloc(25);
    if (pairingSecret.length > 0) {
        // If a pairing secret of zero length is passed in, it usually indicates we want to cancel
        // the pairing attempt. In this case we pass a zero-length name buffer so the firmware can
        // know not to draw the error screen. Note that we still expect an error to come back
        // (RESP_ERR_PAIR_FAIL)
        nameBuf.write(appName);
    }
    var hash = (0, util_1.generateAppSecret)(pubKeyBytes, nameBuf, Buffer.from(pairingSecret));
    var sig = key.sign(hash); // returns an array, not a buffer
    var derSig = (0, util_1.toPaddedDER)(sig);
    var payload = Buffer.concat([nameBuf, derSig]);
    return payload;
};
exports.encodePairRequest = encodePairRequest;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\pair.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\removeKvRecords.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CremoveKvRecords.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeRemoveKvRecordsRequest = exports.validateRemoveKvRequest = exports.removeKvRecords = void 0;
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
/**
 * `removeKvRecords` takes in an array of ids and sends a request to remove them from the Lattice.
 * @category Lattice
 * @returns A callback with an error or null.
 */
function removeKvRecords(_a) {
    var client = _a.client, _type = _a.type, _ids = _a.ids;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, _c, type, ids, data, _d, decryptedData, newEphemeralPub;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    _c = (0, exports.validateRemoveKvRequest)({
                        fwConstants: fwConstants,
                        type: _type,
                        ids: _ids,
                    }), type = _c.type, ids = _c.ids;
                    data = (0, exports.encodeRemoveKvRecordsRequest)({
                        type: type,
                        ids: ids,
                        fwConstants: fwConstants,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.removeKvRecords,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _d = _e.sent(), decryptedData = _d.decryptedData, newEphemeralPub = _d.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, decryptedData];
            }
        });
    });
}
exports.removeKvRecords = removeKvRecords;
var validateRemoveKvRequest = function (_a) {
    var fwConstants = _a.fwConstants, type = _a.type, ids = _a.ids;
    if (!fwConstants.kvActionsAllowed) {
        throw new Error('Unsupported. Please update firmware.');
    }
    if (!Array.isArray(ids) || ids.length < 1) {
        throw new Error('You must include one or more `ids` to removed.');
    }
    if (ids.length > fwConstants.kvRemoveMaxNum) {
        throw new Error("Only up to ".concat(fwConstants.kvRemoveMaxNum, " records may be removed at once."));
    }
    if (type !== 0 && !type) {
        throw new Error('You must specify a type.');
    }
    return { type: type, ids: ids };
};
exports.validateRemoveKvRequest = validateRemoveKvRequest;
var encodeRemoveKvRecordsRequest = function (_a) {
    var fwConstants = _a.fwConstants, type = _a.type, ids = _a.ids;
    var payload = Buffer.alloc(5 + 4 * fwConstants.kvRemoveMaxNum);
    payload.writeUInt32LE(type, 0);
    payload.writeUInt8(ids.length, 4);
    for (var i = 0; i < ids.length; i++) {
        var id = parseInt(ids[i]);
        payload.writeUInt32LE(id, 5 + 4 * i);
    }
    return payload;
};
exports.encodeRemoveKvRecordsRequest = encodeRemoveKvRecordsRequest;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\removeKvRecords.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\sign.js", {"../bitcoin":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\bitcoin.js","../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../ethereum":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\ethereum.js","../genericSigning":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\genericSigning.js","../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/functions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\functions.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hash.js\\lib\\hash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Csign.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeSignResponse = exports.encodeSignRequest = exports.sign = void 0;
var hash_js_1 = require("hash.js");
var bitcoin_1 = __importDefault(require("../bitcoin"));
var constants_1 = require("../constants");
var ethereum_1 = __importDefault(require("../ethereum"));
var genericSigning_1 = require("../genericSigning");
var protocol_1 = require("../protocol");
var functions_1 = require("../shared/functions");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
/**
 * `sign` builds and sends a request for signing to the device.
 * @category Lattice
 * @returns The response from the device.
 */
function sign(_a) {
    var client = _a.client, data = _a.data, currency = _a.currency, cachedData = _a.cachedData, nextCode = _a.nextCode;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, wallet, _c, requestData, isGeneric, _d, payload, hasExtraPayloads, _e, decryptedData, newEphemeralPub, decodedResponse;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    wallet = (0, validators_1.validateWallet)(client.getActiveWallet());
                    _c = (0, functions_1.buildTransaction)({
                        data: data,
                        currency: currency,
                        fwConstants: fwConstants,
                    }), requestData = _c.requestData, isGeneric = _c.isGeneric;
                    _d = (0, exports.encodeSignRequest)({
                        fwConstants: fwConstants,
                        wallet: wallet,
                        requestData: requestData,
                        cachedData: cachedData,
                        nextCode: nextCode,
                    }), payload = _d.payload, hasExtraPayloads = _d.hasExtraPayloads;
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: payload,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.sign,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _e = _f.sent(), decryptedData = _e.decryptedData, newEphemeralPub = _e.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    // If this request has multiple payloads, we need to recurse
                    // so that we can make the next request.
                    // It is chained to the first request using `nextCode`
                    if (hasExtraPayloads) {
                        return [2 /*return*/, client.sign({
                                data: data,
                                currency: currency,
                                cachedData: requestData,
                                nextCode: decryptedData.slice(0, 8),
                            })];
                    }
                    decodedResponse = (0, exports.decodeSignResponse)({
                        data: decryptedData,
                        request: requestData,
                        isGeneric: isGeneric,
                        currency: currency,
                    });
                    return [2 /*return*/, decodedResponse];
            }
        });
    });
}
exports.sign = sign;
var encodeSignRequest = function (_a) {
    var _b, _c, _d;
    var fwConstants = _a.fwConstants, wallet = _a.wallet, requestData = _a.requestData, cachedData = _a.cachedData, nextCode = _a.nextCode;
    var reqPayload, schema;
    if (cachedData && nextCode) {
        requestData = cachedData;
        reqPayload = Buffer.concat([
            nextCode,
            requestData.extraDataPayloads.shift(),
        ]);
        schema = protocol_1.LatticeSignSchema.extraData;
    }
    else {
        reqPayload = requestData.payload;
        schema = requestData.schema;
    }
    var payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);
    var off = 0;
    var hasExtraPayloads = requestData.extraDataPayloads &&
        Number(requestData.extraDataPayloads.length > 0);
    payload.writeUInt8(hasExtraPayloads, off);
    off += 1;
    // Copy request schema (e.g. ETH or BTC transfer)
    payload.writeUInt8(schema, off);
    off += 1;
    // Copy the wallet UID
    (_b = wallet.uid) === null || _b === void 0 ? void 0 : _b.copy(payload, off);
    off += (_d = (_c = wallet.uid) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
    // Build data based on the type of request
    reqPayload.copy(payload, off);
    return { payload: payload, hasExtraPayloads: hasExtraPayloads };
};
exports.encodeSignRequest = encodeSignRequest;
var decodeSignResponse = function (_a) {
    var _b;
    var data = _a.data, request = _a.request, isGeneric = _a.isGeneric, currency = _a.currency;
    var off = 0;
    var derSigLen = 74; // DER signatures are 74 bytes
    if (currency === constants_1.CURRENCIES.BTC) {
        var btcRequest = request;
        var pkhLen = 20; // Pubkeyhashes are 20 bytes
        var sigsLen = 740; // Up to 10x DER signatures
        var changeVersion = bitcoin_1.default.getAddressFormat(btcRequest.origData.changePath);
        var changePubKeyHash = data.slice(off, off + pkhLen);
        off += pkhLen;
        var changeRecipient = bitcoin_1.default.getBitcoinAddress(changePubKeyHash, changeVersion);
        var compressedPubLength = 33; // Size of compressed public key
        var pubkeys = [];
        var sigs = [];
        var n = 0;
        // Parse the signature for each output -- they are returned in the serialized payload in form
        // [pubkey, sig] There is one signature per output
        while (off < data.length) {
            // Exit out if we have seen all the returned sigs and pubkeys
            if (data[off] !== 0x30)
                break;
            // Otherwise grab another set Note that all DER sigs returned fill the maximum 74 byte
            // buffer, but also contain a length at off+1, which we use to parse the non-zero data.
            // First get the signature from its slot
            var sigStart = off;
            var sigEnd = off + 2 + data[off + 1];
            sigs.push(data.slice(sigStart, sigEnd));
            off += derSigLen;
            // Next, shift by the full set of signatures to hit the respective pubkey NOTE: The data
            // returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]
            var pubStart = n * compressedPubLength + sigsLen;
            var pubEnd = (n + 1) * compressedPubLength + sigsLen;
            pubkeys.push(data.slice(pubStart, pubEnd));
            // Update offset to hit the next signature slot
            n += 1;
        }
        // Build the transaction data to be serialized
        var preSerializedData = {
            inputs: [],
            outputs: [],
        };
        // First output comes from request dta
        preSerializedData.outputs.push({
            value: btcRequest.origData.value,
            recipient: btcRequest.origData.recipient,
        });
        if (((_b = btcRequest.changeData) === null || _b === void 0 ? void 0 : _b.value) && btcRequest.changeData.value > 0) {
            // Second output comes from change data
            preSerializedData.outputs.push({
                value: btcRequest.changeData.value,
                recipient: changeRecipient,
            });
        }
        // Add the inputs
        for (var i = 0; i < sigs.length; i++) {
            preSerializedData.inputs.push({
                hash: btcRequest.origData.prevOuts[i].txHash,
                index: btcRequest.origData.prevOuts[i].index,
                sig: sigs[i],
                pubkey: pubkeys[i],
                signerPath: btcRequest.origData.prevOuts[i].signerPath,
            });
        }
        // Finally, serialize the transaction
        var serializedTx = bitcoin_1.default.serializeTx(preSerializedData);
        // Generate the transaction hash so the user can look this transaction up later
        var preImageTxHash = serializedTx;
        var txHashPre = Buffer.from((0, hash_js_1.sha256)().update(Buffer.from(preImageTxHash, 'hex')).digest('hex'), 'hex');
        // Add extra data for debugging/lookup purposes
        return {
            tx: serializedTx,
            txHash: (0, hash_js_1.sha256)().update(txHashPre).digest('hex'),
            changeRecipient: changeRecipient,
            sigs: sigs,
        };
    }
    else if (currency === constants_1.CURRENCIES.ETH && !isGeneric) {
        var sig = (0, util_1.parseDER)(data.slice(off, off + 2 + data[off + 1]));
        off += derSigLen;
        var ethAddr = data.slice(off, off + 20);
        // Determine the `v` param and add it to the sig before returning
        var _c = ethereum_1.default.buildEthRawTx(request, sig, ethAddr), rawTx = _c.rawTx, sigWithV = _c.sigWithV;
        return {
            tx: "0x".concat(rawTx),
            txHash: "0x".concat(ethereum_1.default.hashTransaction(rawTx)),
            sig: {
                v: sigWithV.v,
                r: sigWithV.r.toString('hex'),
                s: sigWithV.s.toString('hex'),
            },
            signer: ethAddr,
        };
    }
    else if (currency === constants_1.CURRENCIES.ETH_MSG) {
        var sig = (0, util_1.parseDER)(data.slice(off, off + 2 + data[off + 1]));
        off += derSigLen;
        var signer = data.slice(off, off + 20);
        var validatedSig = ethereum_1.default.validateEthereumMsgResponse({ signer: signer, sig: sig }, request);
        return {
            sig: {
                v: validatedSig.v,
                r: validatedSig.r.toString('hex'),
                s: validatedSig.s.toString('hex'),
            },
            signer: signer,
        };
    }
    else {
        // Generic signing request
        return (0, genericSigning_1.parseGenericSigningResponse)(data, off, request);
    }
};
exports.decodeSignResponse = decodeSignResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\sign.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\genericSigning.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./index":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js","./protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js/lib/hash/sha":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\sha.js","js-sha3":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5CgenericSigning.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncodedPayload = exports.parseGenericSigningResponse = exports.buildGenericSigningMsgRequest = void 0;
/**
Generic signing module. Any payload can be sent to the Lattice and
will be displayed in full (note that \n and \t characters will be
displayed as line breaks and tabs on the screen).

This payload should be coupled with:
* Signer's BIP44 path
* Curve on which to derive the signing key
* Hash function to use on the message
*/
var sha_1 = require("hash.js/lib/hash/sha");
var js_sha3_1 = require("js-sha3");
var constants_1 = require("./constants");
var index_1 = require("./index");
var protocol_1 = require("./protocol");
var util_1 = require("./util");
var buildGenericSigningMsgRequest = function (req) {
    var signerPath = req.signerPath, curveType = req.curveType, hashType = req.hashType, _a = req.encodingType, encodingType = _a === void 0 ? null : _a, _b = req.decoder, decoder = _b === void 0 ? null : _b, _c = req.omitPubkey, omitPubkey = _c === void 0 ? false : _c, fwConstants = req.fwConstants, _d = req.blsDst, blsDst = _d === void 0 ? index_1.Constants.SIGNING.BLS_DST.BLS_DST_NUL : _d;
    var extraDataFrameSz = fwConstants.extraDataFrameSz, extraDataMaxFrames = fwConstants.extraDataMaxFrames, prehashAllowed = fwConstants.prehashAllowed, genericSigning = fwConstants.genericSigning, varAddrPathSzAllowed = fwConstants.varAddrPathSzAllowed;
    var curveTypes = genericSigning.curveTypes, encodingTypes = genericSigning.encodingTypes, hashTypes = genericSigning.hashTypes, baseDataSz = genericSigning.baseDataSz, baseReqSz = genericSigning.baseReqSz, calldataDecoding = genericSigning.calldataDecoding;
    var encodedPayload = (0, exports.getEncodedPayload)(req.payload, encodingType, encodingTypes);
    var encoding = encodedPayload.encoding;
    var payloadBuf = encodedPayload.payloadBuf;
    var origPayloadBuf = payloadBuf;
    var payloadDataSz = payloadBuf.length;
    // Size of data payload that can be included in the first/base request
    var maxExpandedSz = baseDataSz + extraDataMaxFrames * extraDataFrameSz;
    // Sanity checks
    if (!payloadDataSz) {
        throw new Error('Payload could not be handled.');
    }
    else if (!genericSigning ||
        !extraDataFrameSz ||
        !extraDataMaxFrames ||
        !prehashAllowed) {
        throw new Error('Unsupported. Please update your Lattice firmware.');
    }
    else if (!(0, util_1.existsIn)(curveType, curveTypes)) {
        throw new Error('Unsupported curve type.');
    }
    else if (!(0, util_1.existsIn)(hashType, hashTypes)) {
        throw new Error('Unsupported hash type.');
    }
    // If there is a decoder attached to our payload, add it to
    // the data field of the request.
    var hasDecoder = (decoder && calldataDecoding && decoder.length <= calldataDecoding.maxSz);
    // Make sure the payload AND decoder data fits in the firmware buffer.
    // If it doesn't, we can't include the decoder because the payload will likely
    // be pre-hashed and the decoder data isn't part of the message to sign.
    var decoderFits = (hasDecoder && payloadBuf.length + decoder.length <= maxExpandedSz);
    if (hasDecoder && decoderFits) {
        var decoderBuf = Buffer.alloc(8 + decoder.length);
        // First write th reserved word
        decoderBuf.writeUInt32LE(calldataDecoding.reserved, 0);
        // Then write size, then the data
        decoderBuf.writeUInt32LE(decoder.length, 4);
        Buffer.from(decoder).copy(decoderBuf, 8);
        payloadBuf = Buffer.concat([payloadBuf, decoderBuf]);
    }
    // Ed25519 specific sanity checks
    if (curveType === curveTypes.ED25519) {
        if (hashType !== hashTypes.NONE) {
            throw new Error('Signing on ed25519 requires unhashed message');
        }
        signerPath.forEach(function (idx) {
            if (idx < constants_1.HARDENED_OFFSET) {
                throw new Error('Signing on ed25519 requires all signer path indices be hardened.');
            }
        });
    }
    // BLS12_381 specific processing
    else if (curveType === curveTypes.BLS12_381_G2) {
        // For BLS signing we need to prefix 4 bytes to represent the
        // domain separator (DST). If none is provided, we use the default
        // value of DST_NUL.
        var blsDstBuf = Buffer.alloc(4);
        blsDstBuf.writeUInt32LE(blsDst);
        payloadBuf = Buffer.concat([blsDstBuf, payloadBuf]);
        payloadDataSz += blsDstBuf.length;
    }
    // Build the request buffer with metadata and then the payload to sign.
    var buf = Buffer.alloc(baseReqSz);
    var off = 0;
    buf.writeUInt32LE(encoding, off);
    off += 4;
    buf.writeUInt8(hashType, off);
    off += 1;
    buf.writeUInt8(curveType, off);
    off += 1;
    var signerPathBuf = (0, util_1.buildSignerPathBuf)(signerPath, varAddrPathSzAllowed);
    signerPathBuf.copy(buf, off);
    off += signerPathBuf.length;
    buf.writeUInt8(omitPubkey ? 1 : 0, off);
    off += 1;
    // Flow data into extraData requests if applicable
    var extraDataPayloads = [];
    var prehash = null;
    var didPrehash = false;
    if (payloadBuf.length > baseDataSz) {
        if (prehashAllowed && payloadBuf.length > maxExpandedSz) {
            // If we prehash, we need to provide the full payload size
            buf.writeUInt16LE(payloadBuf.length, off);
            off += 2;
            didPrehash = true;
            // If we have to prehash, only hash the actual payload data, i.e. exclude
            // any optional calldata decoder data.
            var payloadData = payloadBuf.slice(0, payloadDataSz);
            // If this payload is too large to send, but the Lattice allows a prehashed message, do that
            if (hashType === hashTypes.NONE) {
                // This cannot be done for ED25519 signing, which must sign the full message
                throw new Error('Message too large to send and could not be prehashed (hashType=NONE).');
            }
            else if (hashType === hashTypes.KECCAK256) {
                prehash = Buffer.from((0, js_sha3_1.keccak256)(payloadData), 'hex');
            }
            else if (hashType === hashTypes.SHA256) {
                prehash = Buffer.from((0, sha_1.sha256)().update(payloadData).digest('hex'), 'hex');
            }
            else {
                throw new Error('Unsupported hash type.');
            }
        }
        else {
            // Split overflow data into extraData frames
            var frames_1 = (0, util_1.splitFrames)(payloadBuf.slice(baseDataSz), extraDataFrameSz);
            frames_1.forEach(function (frame) {
                var szLE = Buffer.alloc(4);
                szLE.writeUInt32LE(frame.length, 0);
                extraDataPayloads.push(Buffer.concat([szLE, frame]));
            });
        }
    }
    // If we didn't prehash, we know the full request (including calldata info) fits.
    // Set the payload size to only include message data. This will inform firmware
    // where to slice off calldata info.
    if (!didPrehash) {
        buf.writeUInt16LE(payloadDataSz, off);
        off += 2;
    }
    // If the message had to be prehashed, we will only copy the hash data into the request.
    // Otherwise copy as many payload bytes into the request as possible. Follow up data
    // from `frames` will come in follow up requests.
    var toCopy = prehash ? prehash : payloadBuf;
    toCopy.copy(buf, off);
    // Return all the necessary data
    return {
        payload: buf,
        extraDataPayloads: extraDataPayloads,
        schema: protocol_1.LatticeSignSchema.generic,
        curveType: curveType,
        encodingType: encodingType,
        hashType: hashType,
        omitPubkey: omitPubkey,
        origPayloadBuf: origPayloadBuf,
    };
};
exports.buildGenericSigningMsgRequest = buildGenericSigningMsgRequest;
var parseGenericSigningResponse = function (res, off, req) {
    var parsed = {
        pubkey: null,
        sig: null,
    };
    // Parse BIP44 path
    // Parse pubkey and then sig
    if (req.curveType === index_1.Constants.SIGNING.CURVES.SECP256K1) {
        // Handle `GpEccPubkey256_t`
        if (!req.omitPubkey) {
            var compression = res.readUInt8(off);
            off += 1;
            if (compression === 0x02 || compression === 0x03) {
                // Compressed key - only copy x
                parsed.pubkey = Buffer.alloc(33);
                parsed.pubkey.writeUInt8(compression, 0);
                res.slice(off, off + 32).copy(parsed.pubkey, 1);
            }
            else if (compression === 0x04) {
                // Uncompressed key
                parsed.pubkey = Buffer.alloc(65);
                parsed.pubkey.writeUInt8(compression, 0);
                res.slice(off).copy(parsed.pubkey, 1);
            }
            else {
                throw new Error('Bad compression byte in signing response.');
            }
            off += 64;
        }
        else {
            // Skip pubkey section
            off += 65;
        }
        // Handle `GpECDSASig_t`
        parsed.sig = (0, util_1.parseDER)(res.slice(off, off + 2 + res[off + 1]));
        // Remove any leading zeros in signature components to ensure
        // the result is a 64 byte sig
        parsed.sig.r = (0, util_1.fixLen)(parsed.sig.r, 32);
        parsed.sig.s = (0, util_1.fixLen)(parsed.sig.s, 32);
        // If this is an EVM request, we want to add a `v`. Other request
        // types do not require this additional signature param.
        if (req.encodingType === index_1.Constants.SIGNING.ENCODINGS.EVM) {
            var vBn = (0, util_1.getV)(req.origPayloadBuf, parsed);
            // NOTE: For backward-compatibility reasons we are returning
            // a Buffer for `v` here. In the future, we will switch to
            // returning `v` as a BN and `r`,`s` as Buffers (they are hex
            // strings right now).
            parsed.sig.v = vBn.toArrayLike(Buffer);
        }
    }
    else if (req.curveType === index_1.Constants.SIGNING.CURVES.ED25519) {
        if (!req.omitPubkey) {
            // Handle `GpEdDSAPubkey_t`
            parsed.pubkey = Buffer.alloc(32);
            res.slice(off, off + 32).copy(parsed.pubkey);
        }
        off += 32;
        // Handle `GpEdDSASig_t`
        parsed.sig = {
            r: res.slice(off, off + 32),
            s: res.slice(off + 32, off + 64),
        };
    }
    else if (req.curveType === index_1.Constants.SIGNING.CURVES.BLS12_381_G2) {
        if (!req.omitPubkey) {
            // Handle `GpBLS12_381_G1Pub_t`
            parsed.pubkey = Buffer.alloc(48);
            res.slice(off, off + 48).copy(parsed.pubkey);
        }
        off += 48;
        // Handle `GpBLS12_381_G2Sig_t`
        parsed.sig = Buffer.alloc(96);
        res.slice(off, off + 96).copy(parsed.sig);
    }
    else {
        throw new Error('Unsupported curve.');
    }
    return parsed;
};
exports.parseGenericSigningResponse = parseGenericSigningResponse;
var getEncodedPayload = function (payload, encoding, allowedEncodings) {
    if (!encoding) {
        encoding = index_1.Constants.SIGNING.ENCODINGS.NONE;
    }
    // Make sure the encoding type specified is supported by firmware
    if (!(0, util_1.existsIn)(encoding, allowedEncodings)) {
        throw new Error('Encoding not supported by Lattice firmware. You may want to update.');
    }
    var payloadBuf;
    if (!payload) {
        throw new Error('No payload included');
    }
    if (typeof payload === 'string' && payload.slice(0, 2) === '0x') {
        payloadBuf = Buffer.from(payload.slice(2), 'hex');
    }
    else {
        payloadBuf = Buffer.from(payload);
    }
    // Build the request with the specified encoding type
    return {
        payloadBuf: payloadBuf,
        encoding: encoding,
    };
};
exports.getEncodedPayload = getEncodedPayload;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\genericSigning.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js", {"./api":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\index.js","./calldata/index":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\calldata\\index.js","./client":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\client.js","./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = exports.Constants = exports.Client = exports.Calldata = void 0;
var index_1 = require("./calldata/index");
Object.defineProperty(exports, "Calldata", { enumerable: true, get: function () { return index_1.CALLDATA; } });
var client_1 = require("./client");
Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
var constants_1 = require("./constants");
Object.defineProperty(exports, "Constants", { enumerable: true, get: function () { return constants_1.EXTERNAL; } });
var util_1 = require("./util");
Object.defineProperty(exports, "Utils", { enumerable: true, get: function () { return util_1.EXTERNAL; } });
__exportStar(require("./api"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js", {"./latticeConstants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js","./secureMessages":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\secureMessages.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cprotocol%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./latticeConstants"), exports);
__exportStar(require("./secureMessages"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\protocol\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cprotocol%5ClatticeConstants.js
      return function (require, module, exports) {
"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtocolConstants = exports.LatticeEncDataSchema = exports.LatticeSignBlsDst = exports.LatticeSignEncoding = exports.LatticeSignCurve = exports.LatticeSignHash = exports.LatticeSignSchema = exports.LatticeGetAddressesFlag = exports.LatticeSecureEncryptedRequestType = exports.LatticeMsgType = exports.LatticeProtocolVersion = exports.LatticeSecureMsgType = exports.LatticeResponseCode = void 0;
var LatticeResponseCode;
(function (LatticeResponseCode) {
    LatticeResponseCode[LatticeResponseCode["success"] = 0] = "success";
    LatticeResponseCode[LatticeResponseCode["invalidMsg"] = 128] = "invalidMsg";
    LatticeResponseCode[LatticeResponseCode["unsupportedVersion"] = 129] = "unsupportedVersion";
    LatticeResponseCode[LatticeResponseCode["deviceBusy"] = 130] = "deviceBusy";
    LatticeResponseCode[LatticeResponseCode["userTimeout"] = 131] = "userTimeout";
    LatticeResponseCode[LatticeResponseCode["userDeclined"] = 132] = "userDeclined";
    LatticeResponseCode[LatticeResponseCode["pairFailed"] = 133] = "pairFailed";
    LatticeResponseCode[LatticeResponseCode["pairDisabled"] = 134] = "pairDisabled";
    LatticeResponseCode[LatticeResponseCode["permissionDisabled"] = 135] = "permissionDisabled";
    LatticeResponseCode[LatticeResponseCode["internalError"] = 136] = "internalError";
    LatticeResponseCode[LatticeResponseCode["gceTimeout"] = 137] = "gceTimeout";
    LatticeResponseCode[LatticeResponseCode["wrongWallet"] = 138] = "wrongWallet";
    LatticeResponseCode[LatticeResponseCode["deviceLocked"] = 139] = "deviceLocked";
    LatticeResponseCode[LatticeResponseCode["disabled"] = 140] = "disabled";
    LatticeResponseCode[LatticeResponseCode["already"] = 141] = "already";
    LatticeResponseCode[LatticeResponseCode["invalidEphemId"] = 142] = "invalidEphemId";
})(LatticeResponseCode = exports.LatticeResponseCode || (exports.LatticeResponseCode = {}));
var LatticeSecureMsgType;
(function (LatticeSecureMsgType) {
    LatticeSecureMsgType[LatticeSecureMsgType["connect"] = 1] = "connect";
    LatticeSecureMsgType[LatticeSecureMsgType["encrypted"] = 2] = "encrypted";
})(LatticeSecureMsgType = exports.LatticeSecureMsgType || (exports.LatticeSecureMsgType = {}));
var LatticeProtocolVersion;
(function (LatticeProtocolVersion) {
    LatticeProtocolVersion[LatticeProtocolVersion["v1"] = 1] = "v1";
})(LatticeProtocolVersion = exports.LatticeProtocolVersion || (exports.LatticeProtocolVersion = {}));
var LatticeMsgType;
(function (LatticeMsgType) {
    LatticeMsgType[LatticeMsgType["response"] = 0] = "response";
    LatticeMsgType[LatticeMsgType["secure"] = 2] = "secure";
})(LatticeMsgType = exports.LatticeMsgType || (exports.LatticeMsgType = {}));
var LatticeSecureEncryptedRequestType;
(function (LatticeSecureEncryptedRequestType) {
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["finalizePairing"] = 0] = "finalizePairing";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["getAddresses"] = 1] = "getAddresses";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["sign"] = 3] = "sign";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["getWallets"] = 4] = "getWallets";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["getKvRecords"] = 7] = "getKvRecords";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["addKvRecords"] = 8] = "addKvRecords";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["removeKvRecords"] = 9] = "removeKvRecords";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["fetchEncryptedData"] = 12] = "fetchEncryptedData";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["test"] = 13] = "test";
})(LatticeSecureEncryptedRequestType = exports.LatticeSecureEncryptedRequestType || (exports.LatticeSecureEncryptedRequestType = {}));
var LatticeGetAddressesFlag;
(function (LatticeGetAddressesFlag) {
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["none"] = 0] = "none";
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["secp256k1Pubkey"] = 3] = "secp256k1Pubkey";
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["ed25519Pubkey"] = 4] = "ed25519Pubkey";
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["bls12_381Pubkey"] = 5] = "bls12_381Pubkey";
})(LatticeGetAddressesFlag = exports.LatticeGetAddressesFlag || (exports.LatticeGetAddressesFlag = {}));
var LatticeSignSchema;
(function (LatticeSignSchema) {
    LatticeSignSchema[LatticeSignSchema["bitcoin"] = 0] = "bitcoin";
    LatticeSignSchema[LatticeSignSchema["ethereum"] = 1] = "ethereum";
    LatticeSignSchema[LatticeSignSchema["ethereumMsg"] = 3] = "ethereumMsg";
    LatticeSignSchema[LatticeSignSchema["extraData"] = 4] = "extraData";
    LatticeSignSchema[LatticeSignSchema["generic"] = 5] = "generic";
})(LatticeSignSchema = exports.LatticeSignSchema || (exports.LatticeSignSchema = {}));
var LatticeSignHash;
(function (LatticeSignHash) {
    LatticeSignHash[LatticeSignHash["none"] = 0] = "none";
    LatticeSignHash[LatticeSignHash["keccak256"] = 1] = "keccak256";
    LatticeSignHash[LatticeSignHash["sha256"] = 2] = "sha256";
})(LatticeSignHash = exports.LatticeSignHash || (exports.LatticeSignHash = {}));
var LatticeSignCurve;
(function (LatticeSignCurve) {
    LatticeSignCurve[LatticeSignCurve["secp256k1"] = 0] = "secp256k1";
    LatticeSignCurve[LatticeSignCurve["ed25519"] = 1] = "ed25519";
    LatticeSignCurve[LatticeSignCurve["bls12_381"] = 2] = "bls12_381";
})(LatticeSignCurve = exports.LatticeSignCurve || (exports.LatticeSignCurve = {}));
var LatticeSignEncoding;
(function (LatticeSignEncoding) {
    LatticeSignEncoding[LatticeSignEncoding["none"] = 1] = "none";
    LatticeSignEncoding[LatticeSignEncoding["solana"] = 2] = "solana";
    LatticeSignEncoding[LatticeSignEncoding["evm"] = 4] = "evm";
    LatticeSignEncoding[LatticeSignEncoding["eth_deposit"] = 5] = "eth_deposit";
})(LatticeSignEncoding = exports.LatticeSignEncoding || (exports.LatticeSignEncoding = {}));
var LatticeSignBlsDst;
(function (LatticeSignBlsDst) {
    LatticeSignBlsDst[LatticeSignBlsDst["NUL"] = 1] = "NUL";
    LatticeSignBlsDst[LatticeSignBlsDst["POP"] = 2] = "POP";
})(LatticeSignBlsDst = exports.LatticeSignBlsDst || (exports.LatticeSignBlsDst = {}));
var LatticeEncDataSchema;
(function (LatticeEncDataSchema) {
    LatticeEncDataSchema[LatticeEncDataSchema["eip2335"] = 0] = "eip2335";
})(LatticeEncDataSchema = exports.LatticeEncDataSchema || (exports.LatticeEncDataSchema = {}));
exports.ProtocolConstants = {
    // Lattice firmware uses a static initialization vector for
    // message encryption/decryption. This is generally considered
    // fine because each encryption/decryption uses a unique encryption
    // secret (derived from the per-message ephemeral key pair).
    aesIv: [
        0x6d, 0x79, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x70, 0x61, 0x73, 0x73,
        0x77, 0x6f, 0x72, 0x64,
    ],
    // Constant size of address buffers from the Lattice.
    // Note that this size also captures public keys returned
    // by the Lattice (addresses = strings, pubkeys = buffers)
    addrStrLen: 129,
    // Status of the client's pairing with the target Lattice
    pairingStatus: {
        notPaired: 0x00,
        paired: 0x01,
    },
    // Response types, codes, and error messages
    responseMsg: (_a = {},
        _a[LatticeResponseCode.success] = '',
        _a[LatticeResponseCode.invalidMsg] = 'Invalid Request',
        _a[LatticeResponseCode.unsupportedVersion] = 'Unsupported Version',
        _a[LatticeResponseCode.deviceBusy] = 'Device Busy',
        _a[LatticeResponseCode.userTimeout] = 'Timeout waiting for user',
        _a[LatticeResponseCode.userDeclined] = 'Request declined by user',
        _a[LatticeResponseCode.pairFailed] = 'Pairing failed',
        _a[LatticeResponseCode.pairDisabled] = 'Pairing is currently disabled',
        _a[LatticeResponseCode.permissionDisabled] = 'Automated signing is currently disabled',
        _a[LatticeResponseCode.internalError] = 'Device Error',
        _a[LatticeResponseCode.gceTimeout] = 'Device Timeout',
        _a[LatticeResponseCode.wrongWallet] = 'Active wallet does not match request',
        _a[LatticeResponseCode.deviceLocked] = 'Device Locked',
        _a[LatticeResponseCode.disabled] = 'Feature Disabled',
        _a[LatticeResponseCode.already] = 'Record already exists on device',
        _a[LatticeResponseCode.invalidEphemId] = 'Request failed - needs resync',
        _a),
    msgSizes: {
        // General message header size. Valid for all Lattice messages
        header: 8,
        // Checksum must be appended to each message
        checksum: 4,
        // Lattice secure message constants. All requests from this SDK
        // are secure messages.
        secure: {
            // Sizes of full payloads for secure messages
            payload: {
                request: {
                    // [ requestType (1 byte) | pubkey (65 bytes) ]
                    connect: 66,
                    // [ requestType (1 byte) | ephemeralId (4 bytes) | encryptedData (1728 bytes) ]
                    encrypted: 1733,
                },
                // Note that the response payload always has status code as the
                // first byte. This byte is removed as part of `request`, inside
                // `parseLattice1Response`. These constants include the status
                // code byte.
                response: {
                    connect: 215,
                    // Encrypted responses are as follows:
                    // encryptedData (1728) | empty (1728)
                    // The latter half is empty due to an invalid type definition
                    // in Lattice firmware. (Someone made a C `struct` instead of
                    // a `union`, oops).
                    encrypted: 3457,
                },
            },
            // Sizes for data inside secure message payloads
            data: {
                // All requests also have a `requestCode`, which is omitted
                // from these constants.
                request: {
                    connect: 65,
                    encrypted: (_b = {
                            // All encrypted requests are encrypted into a 1728 byte buffer
                            encryptedData: 1728
                        },
                        // Individual request types have different data sizes.
                        _b[LatticeSecureEncryptedRequestType.finalizePairing] = 99,
                        _b[LatticeSecureEncryptedRequestType.getAddresses] = 54,
                        _b[LatticeSecureEncryptedRequestType.sign] = 1680,
                        _b[LatticeSecureEncryptedRequestType.getWallets] = 0,
                        _b[LatticeSecureEncryptedRequestType.getKvRecords] = 9,
                        _b[LatticeSecureEncryptedRequestType.addKvRecords] = 1391,
                        _b[LatticeSecureEncryptedRequestType.removeKvRecords] = 405,
                        _b[LatticeSecureEncryptedRequestType.fetchEncryptedData] = 1025,
                        _b[LatticeSecureEncryptedRequestType.test] = 506,
                        _b),
                },
                // All responses also have a `responseCode`, which is omitted
                // from these constants.
                response: {
                    encrypted: (_c = {
                            encryptedData: 1728
                        },
                        // Once decrypted, the data size of the response
                        // payload will be determined by the request type.
                        // NOTE: All requests also have ephemeralPublicKey (65 bytes) and
                        // checksum (4 bytes), which are excluded from these sizes.
                        _c[LatticeSecureEncryptedRequestType.finalizePairing] = 0,
                        _c[LatticeSecureEncryptedRequestType.getAddresses] = 1290,
                        _c[LatticeSecureEncryptedRequestType.sign] = 1090,
                        _c[LatticeSecureEncryptedRequestType.getWallets] = 142,
                        _c[LatticeSecureEncryptedRequestType.getKvRecords] = 1395,
                        _c[LatticeSecureEncryptedRequestType.addKvRecords] = 0,
                        _c[LatticeSecureEncryptedRequestType.removeKvRecords] = 0,
                        _c[LatticeSecureEncryptedRequestType.fetchEncryptedData] = 1608,
                        _c[LatticeSecureEncryptedRequestType.test] = 1646,
                        _c),
                },
            },
        },
    },
};

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\secureMessages.js", {"../shared/functions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\functions.js","../shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","./latticeConstants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cprotocol%5CsecureMessages.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encryptedSecureRequest = exports.connectSecureRequest = void 0;
/**
 * All messages sent to the Lattice from this SDK will be
 * "secure messages", of which there are two types:
 *
 * 1. Connect requests are *unencrypted* and serve to establish
 *    a connection between the SDK Client instance and the target
 *    Lattice. If the client is already paired to the target Lattice,
 *    the response will indicate that. If the client has never paired
 *    with this Lattice, the Lattice will go into "pairing mode" and
 *    will expect a follow up `finalizePairing` request, which is
 *    an encrypted request. This will return an ephemeral public key,
 *    which is used to encrypt the next request.
 * 2. Encrypted requests are *encrypted* (obviously) and from a Lattice
 *    protocol perspective they are all constructed the same way:
 *    create a buffer of `payload` length and fill it with unencrypted
 *    data, then encrypt the entire payload (not just the data you filled)
 *    with the ECDH secret formed from the last ephemeral public key.
 *    The response to this request will contain a new ephemral public
 *    key, which you will need for the next encrypted request.
 */
var latticeConstants_1 = require("./latticeConstants");
var util_1 = require("../util");
var functions_1 = require("../shared/functions");
var validators_1 = require("../shared/validators");
var msgSizes = latticeConstants_1.ProtocolConstants.msgSizes;
var szs = msgSizes.secure;
/**
 * Build and make a request to connect to a specific Lattice
 * based on its `deviceId`.
 * @param deviceId - Device ID for the target Lattice. Must be in
 *                   the same `client.baseUrl` domain to be found.
 * @return {Buffer} - Connection response payload data, which contains
 *                    information about the connected Lattice.
 */
function connectSecureRequest(_a) {
    var url = _a.url, pubkey = _a.pubkey;
    return __awaiter(this, void 0, void 0, function () {
        var payloadData, msgId, msg, resp;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    payloadData = serializeSecureRequestConnectPayloadData({
                        pubkey: pubkey,
                    });
                    msgId = (0, util_1.randomBytes)(4);
                    msg = serializeSecureRequestMsg(msgId, latticeConstants_1.LatticeSecureMsgType.connect, payloadData);
                    return [4 /*yield*/, (0, functions_1.request)({ url: url, payload: msg })];
                case 1:
                    resp = _b.sent();
                    if (resp.length !== szs.payload.response.connect - 1) {
                        throw new Error('Wrong Lattice response message size.');
                    }
                    return [2 /*return*/, resp];
            }
        });
    });
}
exports.connectSecureRequest = connectSecureRequest;
/**
 * Build an encrypted secure request using raw data,
 * then send that request to the target Lattice, handle
 * the response, and return the *decrypted* response
 * payload data.
 * Also updates ephemeral public key in the client.
 * This is a wrapper around several local util functions.
 * @param data - Unencrypted raw calldata for function
 * @param requestType - Type of encrypted reques to make
 * @return {Buffer} Decrypted response data (excluding metadata)
 */
function encryptedSecureRequest(_a) {
    var data = _a.data, requestType = _a.requestType, sharedSecret = _a.sharedSecret, ephemeralPub = _a.ephemeralPub, url = _a.url;
    return __awaiter(this, void 0, void 0, function () {
        var msgId, payloadData, msg, resp, encPayloadData;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    msgId = (0, util_1.randomBytes)(4);
                    payloadData = serializeSecureRequestEncryptedPayloadData({
                        data: data,
                        requestType: requestType,
                        ephemeralPub: ephemeralPub,
                        sharedSecret: sharedSecret,
                    });
                    msg = serializeSecureRequestMsg(msgId, latticeConstants_1.LatticeSecureMsgType.encrypted, payloadData);
                    return [4 /*yield*/, (0, functions_1.request)({
                            url: url,
                            payload: msg,
                        })];
                case 1:
                    resp = _b.sent();
                    // Deserialize the response payload data
                    if (resp.length !== szs.payload.response.encrypted - 1) {
                        throw new Error('Wrong Lattice response message size.');
                    }
                    encPayloadData = resp.slice(0, szs.data.response.encrypted.encryptedData);
                    // Return decrypted response payload data
                    return [2 /*return*/, decryptEncryptedLatticeResponseData({
                            encPayloadData: encPayloadData,
                            requestType: requestType,
                            sharedSecret: sharedSecret,
                        })];
            }
        });
    });
}
exports.encryptedSecureRequest = encryptedSecureRequest;
/**
 * @internal
 * Serialize a Secure Request message for the Lattice.
 * All outgoing SDK requests are of this form.
 * @param msgId - Random 4 bytes of data for internally tracking this message
 * @param secureRequestType - 0x01 for connect, 0x02 for encrypted
 * @param payloadData - Request data
 * @return {Buffer} Serialized message to be sent to Lattice
 */
function serializeSecureRequestMsg(msgId, secureRequestType, payloadData) {
    // Sanity check request data
    if (msgId.length !== 4) {
        throw new Error('msgId must be four bytes');
    }
    if (secureRequestType !== latticeConstants_1.LatticeSecureMsgType.connect &&
        secureRequestType !== latticeConstants_1.LatticeSecureMsgType.encrypted) {
        throw new Error('Invalid Lattice secure request type');
    }
    // Validate the incoming payload data size. Note that the payload
    // data is prepended with a secure request type byte, so the
    // payload data size is one less than the expected size.
    var isValidConnectPayloadDataSz = secureRequestType === latticeConstants_1.LatticeSecureMsgType.connect &&
        payloadData.length === szs.payload.request.connect - 1;
    var isValidEncryptedPayloadDataSz = secureRequestType === latticeConstants_1.LatticeSecureMsgType.encrypted &&
        payloadData.length === szs.payload.request.encrypted - 1;
    // Build payload and size
    var msgSz = msgSizes.header + msgSizes.checksum;
    var payloadLen;
    var payload = {
        requestType: secureRequestType,
        data: payloadData,
    };
    if (isValidConnectPayloadDataSz) {
        payloadLen = szs.payload.request.connect;
    }
    else if (isValidEncryptedPayloadDataSz) {
        payloadLen = szs.payload.request.encrypted;
    }
    else {
        throw new Error('Invalid Lattice secure request payload size');
    }
    msgSz += payloadLen;
    // Construct the request in object form
    var header = {
        version: latticeConstants_1.LatticeProtocolVersion.v1,
        type: latticeConstants_1.LatticeMsgType.secure,
        id: msgId,
        len: payloadLen,
    };
    var req = {
        header: header,
        payload: payload,
    };
    // Now serialize the whole message
    // Header | requestType | payloadData | checksum
    var msg = Buffer.alloc(msgSz);
    var off = 0;
    // Header
    msg.writeUInt8(req.header.version, off);
    off += 1;
    msg.writeUInt8(req.header.type, off);
    off += 1;
    req.header.id.copy(msg, off);
    off += req.header.id.length;
    msg.writeUInt16BE(req.header.len, off);
    off += 2;
    // Payload
    msg.writeUInt8(req.payload.requestType, off);
    off += 1;
    req.payload.data.copy(msg, off);
    off += req.payload.data.length;
    // Checksum
    msg.writeUInt32BE((0, util_1.checksum)(msg.slice(0, off)), off);
    off += 4;
    if (off !== msgSz) {
        throw new Error('Failed to build request message');
    }
    // We have our serialized secure message!
    return msg;
}
/**
 * @internal
 * Serialize payload data for a Lattice secure request: connect
 * @return {Buffer} - 1700 bytes, of which only 65 are used
 */
function serializeSecureRequestConnectPayloadData(payloadData) {
    var serPayloadData = Buffer.alloc(szs.data.request.connect);
    payloadData.pubkey.copy(serPayloadData, 0);
    return serPayloadData;
}
/**
 * @internal
 * Serialize payload data for Lattice secure request: encrypted
 * @param data - Raw (unencrypted) request data
 * @return {Buffer} - 1700 bytes, all of which should be used
 */
function serializeSecureRequestEncryptedPayloadData(_a) {
    var data = _a.data, requestType = _a.requestType, ephemeralPub = _a.ephemeralPub, sharedSecret = _a.sharedSecret;
    // Sanity checks request size
    if (data.length > szs.data.request.encrypted.encryptedData) {
        throw new Error('Encrypted request data too large');
    }
    // Make sure we have a shared secret. An error will be thrown
    // if there is no ephemeral pub, indicating we need to reconnect.
    (0, validators_1.validateEphemeralPub)(ephemeralPub);
    // Validate the request data size matches the desired request
    var requestDataSize = szs.data.request.encrypted[requestType];
    if (data.length !== requestDataSize) {
        throw new Error("Invalid request datasize (wanted ".concat(requestDataSize, ", got ").concat(data.length, ")"));
    }
    // Build the pre-encrypted data payload, which variable sized and of form:
    // encryptedRequestType | data | checksum
    var preEncryptedData = Buffer.alloc(1 + requestDataSize);
    preEncryptedData[0] = requestType;
    data.copy(preEncryptedData, 1);
    var preEncryptedDataChecksum = (0, util_1.checksum)(preEncryptedData);
    // Encrypt the data into a fixed size buffer. The buffer size should
    // equal to the full message request less the 4-byte ephemeral id.
    var _encryptedData = Buffer.alloc(szs.data.request.encrypted.encryptedData);
    preEncryptedData.copy(_encryptedData, 0);
    _encryptedData.writeUInt32LE(preEncryptedDataChecksum, preEncryptedData.length);
    var encryptedData = (0, util_1.aes256_encrypt)(_encryptedData, sharedSecret);
    // Calculate ephemeral ID
    var ephemeralId = (0, functions_1.getEphemeralId)(sharedSecret);
    // Now we will serialize the payload data.
    var serPayloadData = Buffer.alloc(szs.payload.request.encrypted - 1);
    serPayloadData.writeUInt32LE(ephemeralId);
    encryptedData.copy(serPayloadData, 4);
    return serPayloadData;
}
/**
 * @internal
 * Decrypt the response data from an encrypted request.
 * @param encPayloadData - Encrypted payload data in response
 * @return {Buffer} Decrypted response data (excluding metadata)
 */
function decryptEncryptedLatticeResponseData(_a) {
    var encPayloadData = _a.encPayloadData, requestType = _a.requestType, sharedSecret = _a.sharedSecret;
    // Decrypt data using the *current* shared secret
    var decData = (0, util_1.aes256_decrypt)(encPayloadData, sharedSecret);
    // Bulid the object
    var ephemeralPubSz = 65; // secp256r1 pubkey
    var checksumOffset = ephemeralPubSz + szs.data.response.encrypted[requestType];
    var respData = {
        ephemeralPub: decData.slice(0, ephemeralPubSz),
        data: decData.slice(ephemeralPubSz, checksumOffset),
        checksum: decData.readUInt32BE(checksumOffset),
    };
    // Validate the checksum
    var validChecksum = (0, util_1.checksum)(decData.slice(0, checksumOffset));
    if (respData.checksum !== validChecksum) {
        throw new Error('Checksum mismatch in decrypted Lattice data');
    }
    // Validate the response data size
    var validSz = szs.data.response.encrypted[requestType];
    if (respData.data.length !== validSz) {
        throw new Error('Incorrect response data returned from Lattice');
    }
    var newEphemeralPub = (0, util_1.getP256KeyPairFromPub)(respData.ephemeralPub);
    // Returned the decrypted data
    return { decryptedData: respData.data, newEphemeralPub: newEphemeralPub };
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\protocol\\secureMessages.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\errors.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cerrors.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatticeResponseError = void 0;
var protocol_1 = require("../protocol");
var buildLatticeResponseErrorMessage = function (_a) {
    var responseCode = _a.responseCode, errorMessage = _a.errorMessage;
    var msg = [];
    if (responseCode) {
        msg.push("".concat(protocol_1.ProtocolConstants.responseMsg[responseCode]));
    }
    if (errorMessage) {
        msg.push('Error Message: ');
        msg.push(errorMessage);
    }
    return msg.join('\n');
};
var LatticeResponseError = /** @class */ (function (_super) {
    __extends(LatticeResponseError, _super);
    function LatticeResponseError(responseCode, errorMessage) {
        var _this = this;
        var message = buildLatticeResponseErrorMessage({
            responseCode: responseCode,
            errorMessage: errorMessage,
        });
        _this = _super.call(this, message) || this;
        _this.responseCode = responseCode;
        _this.errorMessage = errorMessage;
        _this.name = 'LatticeResponseError';
        _this.responseCode = responseCode;
        _this.errorMessage = errorMessage;
        return _this;
    }
    return LatticeResponseError;
}(Error));
exports.LatticeResponseError = LatticeResponseError;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\errors.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\functions.js", {"../bitcoin":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\bitcoin.js","../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../ethereum":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\ethereum.js","../genericSigning":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\genericSigning.js","../util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","./errors":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\errors.js","./predicates":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\predicates.js","./validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js/lib/hash/sha":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\sha.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cfunctions.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEphemeralId = exports.retryWrapper = exports.buildRetryWrapper = exports.request = exports.buildTransaction = void 0;
var sha_1 = require("hash.js/lib/hash/sha");
var bitcoin_1 = __importDefault(require("../bitcoin"));
var constants_1 = require("../constants");
var ethereum_1 = __importDefault(require("../ethereum"));
var genericSigning_1 = require("../genericSigning");
var util_1 = require("../util");
var errors_1 = require("./errors");
var predicates_1 = require("./predicates");
var validators_1 = require("./validators");
var buildTransaction = function (_a) {
    // All transaction requests must be put into the same sized buffer. This comes from
    // sizeof(GpTransactionRequest_t), but note we remove the 2-byte schemaId since it is not
    // returned from our resolver. Note that different firmware versions may have different data
    // sizes.
    var data = _a.data, currency = _a.currency, fwConstants = _a.fwConstants;
    // TEMPORARY BRIDGE -- DEPRECATE ME In v0.15.0 Lattice firmware removed the legacy ETH
    // signing path, so we need to convert such requests to general signing requests using the
    // EVM decoder. NOTE: Not every request can be converted, so users should switch to using
    // general signing requests for newer firmware versions. EIP1559 and EIP155 legacy
    // requests will convert, but others may not.
    if (currency === 'ETH' && (0, predicates_1.shouldUseEVMLegacyConverter)(fwConstants)) {
        console.log('Using the legacy ETH signing path. This will soon be deprecated. ' +
            'Please switch to general signing request.');
        var payload = void 0;
        try {
            payload = ethereum_1.default.ethConvertLegacyToGenericReq(data);
        }
        catch (err) {
            throw new Error('Could not convert legacy request. Please switch to a general signing ' +
                'request. See gridplus-sdk docs for more information.');
        }
        data = {
            fwConstants: fwConstants,
            encodingType: constants_1.EXTERNAL.SIGNING.ENCODINGS.EVM,
            curveType: constants_1.EXTERNAL.SIGNING.CURVES.SECP256K1,
            hashType: constants_1.EXTERNAL.SIGNING.HASHES.KECCAK256,
            signerPath: data.signerPath,
            payload: payload,
        };
        return {
            requestData: (0, genericSigning_1.buildGenericSigningMsgRequest)(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: true,
        };
    }
    else if (currency === 'ETH') {
        // Legacy signing pathway -- should deprecate in the future
        return {
            requestData: ethereum_1.default.buildEthereumTxRequest(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: false,
        };
    }
    else if (currency === 'ETH_MSG') {
        return {
            requestData: ethereum_1.default.buildEthereumMsgRequest(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: false,
        };
    }
    else if (currency === 'BTC') {
        return {
            requestData: bitcoin_1.default.buildBitcoinTxRequest(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: false,
        };
    }
    return {
        requestData: (0, genericSigning_1.buildGenericSigningMsgRequest)(__assign(__assign({}, data), { fwConstants: fwConstants })),
        isGeneric: true,
    };
};
exports.buildTransaction = buildTransaction;
var request = function (_a) {
    var url = _a.url, payload = _a.payload, _b = _a.timeout, timeout = _b === void 0 ? 60000 : _b;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_c) {
            return [2 /*return*/, (0, util_1.fetchWithTimeout)(url, {
                    method: 'POST',
                    body: JSON.stringify({ data: payload }),
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    timeout: timeout,
                })
                    .catch(validators_1.validateRequestError)
                    .then(function (res) { return res.json(); })
                    .then(function (body) {
                    // Handle formatting or generic HTTP errors
                    if (!body || !body.message) {
                        throw new Error('Invalid response');
                    }
                    else if (body.status !== 200) {
                        throw new Error("Error code ".concat(body.status, ": ").concat(body.message));
                    }
                    var _a = (0, util_1.parseLattice1Response)(body.message), data = _a.data, errorMessage = _a.errorMessage, responseCode = _a.responseCode;
                    if (errorMessage || responseCode) {
                        throw new errors_1.LatticeResponseError(responseCode, errorMessage);
                    }
                    return data;
                })];
        });
    });
};
exports.request = request;
/**
 * `sleep()` returns a Promise that resolves after a given number of milliseconds.
 */
function sleep(ms) {
    return new Promise(function (resolve) { return setTimeout(resolve, ms); });
}
/**
 * Takes a function and a set of parameters, and returns a function that will retry the original
 * function with the given parameters a number of times
 *
 * @param client - a {@link Client} instance that is passed to the {@link retryWrapper}
 * @param retries - the number of times to retry the function before giving up
 * @returns a {@link retryWrapper} function for handing retry logic
 */
var buildRetryWrapper = function (client, retries) {
    return function (fn, params) {
        return (0, exports.retryWrapper)({
            fn: fn,
            params: __assign(__assign({}, params), { client: client }),
            retries: retries,
            client: client,
        });
    };
};
exports.buildRetryWrapper = buildRetryWrapper;
/**
 * Retries a function call if the error message or response code is present and the number of
 * retries is greater than 0.
 *
 * @param fn - The function to retry
 * @param params - The parameters to pass to the function
 * @param retries - The number of times to retry the function
 * @param client - The {@link Client} to use for side-effects
 */
var retryWrapper = function (_a) {
    var fn = _a.fn, params = _a.params, retries = _a.retries, client = _a.client;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            return [2 /*return*/, fn(__assign({}, params)).catch(function (err) { return __awaiter(void 0, void 0, void 0, function () {
                    var errorMessage, responseCode;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                errorMessage = err.errorMessage;
                                responseCode = err.responseCode;
                                if (!((errorMessage || responseCode) && retries)) return [3 /*break*/, 8];
                                if (!(0, predicates_1.isDeviceBusy)(responseCode)) return [3 /*break*/, 2];
                                return [4 /*yield*/, sleep(3000)];
                            case 1:
                                _a.sent();
                                return [3 /*break*/, 7];
                            case 2:
                                if (!((0, predicates_1.isWrongWallet)(responseCode) &&
                                    !client.skipRetryOnWrongWallet)) return [3 /*break*/, 4];
                                return [4 /*yield*/, client.fetchActiveWallet()];
                            case 3:
                                _a.sent();
                                return [3 /*break*/, 7];
                            case 4:
                                if (!(0, predicates_1.isInvalidEphemeralId)(responseCode)) return [3 /*break*/, 6];
                                return [4 /*yield*/, client.connect(client.deviceId)];
                            case 5:
                                _a.sent();
                                return [3 /*break*/, 7];
                            case 6: throw err;
                            case 7: return [2 /*return*/, (0, exports.retryWrapper)({
                                    fn: fn,
                                    params: params,
                                    retries: retries - 1,
                                    client: client,
                                })];
                            case 8: throw err;
                        }
                    });
                }); })];
        });
    });
};
exports.retryWrapper = retryWrapper;
/**
 * Get the ephemeral id, which is the first 4 bytes of the shared secret generated from the local
 * private key and the ephemeral public key from the device.
 * @internal
 * @returns Buffer
 */
var getEphemeralId = function (sharedSecret) {
    // EphemId is the first 4 bytes of the hash of the shared secret
    var hash = Buffer.from((0, sha_1.sha256)().update(sharedSecret).digest('hex'), 'hex');
    return parseInt(hash.slice(0, 4).toString('hex'), 16);
};
exports.getEphemeralId = getEphemeralId;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\functions.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\predicates.js", {"../protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./utilities":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cpredicates.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldUseEVMLegacyConverter = exports.doesFetchWalletsOnLoad = exports.isInvalidEphemeralId = exports.isWrongWallet = exports.isDeviceBusy = void 0;
var protocol_1 = require("../protocol");
var utilities_1 = require("./utilities");
var isDeviceBusy = function (responseCode) {
    return responseCode === protocol_1.LatticeResponseCode.deviceBusy ||
        responseCode === protocol_1.LatticeResponseCode.gceTimeout;
};
exports.isDeviceBusy = isDeviceBusy;
var isWrongWallet = function (responseCode) {
    return responseCode === protocol_1.LatticeResponseCode.wrongWallet;
};
exports.isWrongWallet = isWrongWallet;
var isInvalidEphemeralId = function (responseCode) {
    return responseCode === protocol_1.LatticeResponseCode.invalidEphemId;
};
exports.isInvalidEphemeralId = isInvalidEphemeralId;
var doesFetchWalletsOnLoad = function (fwVersion) {
    return (0, utilities_1.isFWSupported)(fwVersion, { major: 0, minor: 14, fix: 1 });
};
exports.doesFetchWalletsOnLoad = doesFetchWalletsOnLoad;
var shouldUseEVMLegacyConverter = function (fwConstants) {
    return fwConstants.genericSigning &&
        fwConstants.genericSigning.encodingTypes &&
        fwConstants.genericSigning.encodingTypes.EVM;
};
exports.shouldUseEVMLegacyConverter = shouldUseEVMLegacyConverter;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\predicates.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js", {"../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cutilities.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPathStr = exports.isFWSupported = exports.parseWallets = exports.getSharedSecret = exports.getPubKeyBytes = void 0;
var constants_1 = require("../constants");
/**
 * Get 64 bytes representing the public key This is the uncompressed key without the leading 04
 * byte
 * @param KeyPair - //TODO Describe the keypair
 * @param LE - Whether to return the public key in little endian format.
 * @returns A Buffer containing the public key.
 */
var getPubKeyBytes = function (key, LE) {
    if (LE === void 0) { LE = false; }
    var k = key.getPublic();
    var p = k.encode('hex');
    var pb = Buffer.from(p, 'hex');
    if (LE === true) {
        // Need to flip X and Y components to little endian
        var x = pb.slice(1, 33).reverse();
        var y = pb.slice(33, 65).reverse();
        // @ts-expect-error - TODO: Find out why Buffer won't accept pb[0]
        return Buffer.concat([pb[0], x, y]);
    }
    else {
        return pb;
    }
};
exports.getPubKeyBytes = getPubKeyBytes;
/**
 * Get the shared secret, derived via ECDH from the local private key and the ephemeral public key
 * @internal
 * @returns Buffer
 */
var getSharedSecret = function (key, ephemeralPub) {
    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which can lead to
    // problems initializing AES if we don't force a 32 byte BE buffer.
    return Buffer.from(key.derive(ephemeralPub.getPublic()).toArray('be', 32));
};
exports.getSharedSecret = getSharedSecret;
// Given a set of wallet data, which contains two wallet descriptors, parse the data and save it
// to memory
var parseWallets = function (walletData) {
    // Read the external wallet data first. If it is non-null, the external wallet will be the
    // active wallet of the device and we should save it. If the external wallet is blank, it means
    // there is no card present and we should save and use the interal wallet. If both wallets are
    // empty, it means the device still needs to be set up.
    var walletDescriptorLen = 71;
    // Internal first
    var off = 0;
    var activeWallets = {
        internal: {
            uid: undefined,
            capabilities: undefined,
            name: undefined,
            external: false,
        },
        external: {
            uid: undefined,
            capabilities: undefined,
            name: undefined,
            external: true,
        },
    };
    activeWallets.internal.uid = walletData.slice(off, off + 32);
    // NOTE: `capabilities` and `name` were deprecated in Lattice firmware.
    // They never provided any real information, but have been archived here
    // since the response size has been preserved and we may bring them back
    // in a different form.
    // activeWallets.internal.capabilities = walletData.readUInt32BE(off + 32);
    // activeWallets.internal.name = walletData.slice(
    // off + 36,
    // off + walletDescriptorLen,
    // );
    // Offset the first item
    off += walletDescriptorLen;
    // External
    activeWallets.external.uid = walletData.slice(off, off + 32);
    // activeWallets.external.capabilities = walletData.readUInt32BE(off + 32);
    // activeWallets.external.name = walletData.slice(
    // off + 36,
    // off + walletDescriptorLen,
    // );
    return activeWallets;
};
exports.parseWallets = parseWallets;
// Determine if a provided firmware version matches or exceeds the current firmware version
var isFWSupported = function (fwVersion, versionSupported) {
    var major = fwVersion.major, minor = fwVersion.minor, fix = fwVersion.fix;
    var _major = versionSupported.major, _minor = versionSupported.minor, _fix = versionSupported.fix;
    return (major > _major ||
        (major >= _major && minor > _minor) ||
        (major >= _major && minor >= _minor && fix >= _fix));
};
exports.isFWSupported = isFWSupported;
/**
 * Convert a set of BIP39 path indices to a string
 * @param path - Set of indices
 */
var getPathStr = function (path) {
    var pathStr = 'm';
    path.forEach(function (idx) {
        if (idx >= constants_1.HARDENED_OFFSET) {
            pathStr += "/".concat(idx - constants_1.HARDENED_OFFSET, "'");
        }
        else {
            pathStr += "/".concat(idx);
        }
    });
    return pathStr;
};
exports.getPathStr = getPathStr;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\utilities.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js", {"../constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","lodash/isEmpty":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\isEmpty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cvalidators.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValid4ByteResponse = exports.isValidBlockExplorerResponse = exports.validateKvRecord = exports.validateKvRecords = exports.validateActiveWallets = exports.validateKey = exports.validateSharedSecret = exports.validateEphemeralPub = exports.validateConnectedClient = exports.validateWallet = exports.validateRequestError = exports.validateFwVersion = exports.validateFwConstants = exports.validateBaseUrl = exports.validateUrl = exports.validateAppName = exports.validateDeviceId = exports.validateStartPath = exports.validateNAddresses = exports.validateIsUInt4 = void 0;
var constants_1 = require("../constants");
var util_1 = require("../util");
var isEmpty_1 = __importDefault(require("lodash/isEmpty"));
var validateIsUInt4 = function (n) {
    if (typeof n !== 'number' || !(0, util_1.isUInt4)(n)) {
        throw new Error('Must be an integer between 0 and 15 inclusive');
    }
    return n;
};
exports.validateIsUInt4 = validateIsUInt4;
var validateNAddresses = function (n) {
    if (!n) {
        throw new Error('The number of addresses is required.');
    }
    if (n > constants_1.MAX_ADDR) {
        throw new Error("You may only request ".concat(constants_1.MAX_ADDR, " addresses at once."));
    }
    return n;
};
exports.validateNAddresses = validateNAddresses;
var validateStartPath = function (startPath) {
    if (!startPath) {
        throw new Error('Start path is required');
    }
    if (startPath.length < 1 || startPath.length > 5)
        throw new Error('Path must include between 1 and 5 indices');
    return startPath;
};
exports.validateStartPath = validateStartPath;
var validateDeviceId = function (deviceId) {
    if (!deviceId) {
        throw new Error('No device ID has been stored. Please connect with your device ID first.');
    }
    return deviceId;
};
exports.validateDeviceId = validateDeviceId;
var validateAppName = function (name) {
    if (!name) {
        throw new Error('Name is required.');
    }
    if (name.length < 5 || name.length > 24) {
        throw new Error('Invalid length for name provided. Must be 5-24 characters.');
    }
    return name;
};
exports.validateAppName = validateAppName;
var validateUrl = function (url) {
    if (!url) {
        throw new Error('URL does not exist. Please reconnect.');
    }
    try {
        new URL(url);
    }
    catch (err) {
        throw new Error('Invalid URL provided. Please use a valid URL.');
    }
    return url;
};
exports.validateUrl = validateUrl;
var validateBaseUrl = function (baseUrl) {
    if (!baseUrl) {
        throw new Error('Base URL is required.');
    }
    try {
        new URL(baseUrl);
    }
    catch (err) {
        throw new Error('Invalid Base URL provided. Please use a valid URL.');
    }
    return baseUrl;
};
exports.validateBaseUrl = validateBaseUrl;
var validateFwConstants = function (fwConstants) {
    if (!fwConstants) {
        throw new Error('Firmware constants do not exist. Please reconnect.');
    }
    return fwConstants;
};
exports.validateFwConstants = validateFwConstants;
var validateFwVersion = function (fwVersion) {
    if (!fwVersion) {
        throw new Error('Firmware version does not exist. Please reconnect.');
    }
    if (typeof fwVersion.fix !== 'number' ||
        typeof fwVersion.minor !== 'number' ||
        typeof fwVersion.major !== 'number') {
        throw new Error('Firmware version improperly formatted. Please reconnect.');
    }
    return fwVersion;
};
exports.validateFwVersion = validateFwVersion;
var validateRequestError = function (err) {
    var isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';
    if (isTimeout) {
        throw new Error('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.');
    }
    throw new Error("Failed to make request to device:\n".concat(err.message));
};
exports.validateRequestError = validateRequestError;
var validateWallet = function (wallet) {
    if (!wallet || wallet === null) {
        throw new Error('No active wallet.');
    }
    return wallet;
};
exports.validateWallet = validateWallet;
var validateConnectedClient = function (client) {
    var appName = (0, exports.validateAppName)(client.getAppName());
    var ephemeralPub = (0, exports.validateEphemeralPub)(client.ephemeralPub);
    var sharedSecret = (0, exports.validateSharedSecret)(client.sharedSecret);
    var url = (0, exports.validateUrl)(client.url);
    var fwConstants = (0, exports.validateFwConstants)(client.getFwConstants());
    var fwVersion = (0, exports.validateFwVersion)(client.getFwVersion());
    // @ts-expect-error - Key is private
    var key = (0, exports.validateKey)(client.key);
    return {
        appName: appName,
        ephemeralPub: ephemeralPub,
        sharedSecret: sharedSecret,
        url: url,
        fwConstants: fwConstants,
        fwVersion: fwVersion,
        key: key,
    };
};
exports.validateConnectedClient = validateConnectedClient;
var validateEphemeralPub = function (ephemeralPub) {
    if (!ephemeralPub) {
        throw new Error('`ephemeralPub` (ephemeral public key) is required. Please reconnect.');
    }
    return ephemeralPub;
};
exports.validateEphemeralPub = validateEphemeralPub;
var validateSharedSecret = function (sharedSecret) {
    if (!sharedSecret) {
        throw new Error('Shared secret required. Please reconnect.');
    }
    return sharedSecret;
};
exports.validateSharedSecret = validateSharedSecret;
var validateKey = function (key) {
    if (!key) {
        throw new Error('Key is required. Please reconnect.');
    }
    return key;
};
exports.validateKey = validateKey;
var validateActiveWallets = function (activeWallets) {
    var _a, _b, _c, _d;
    if (!activeWallets ||
        (((_b = (_a = activeWallets === null || activeWallets === void 0 ? void 0 : activeWallets.internal) === null || _a === void 0 ? void 0 : _a.uid) === null || _b === void 0 ? void 0 : _b.equals(constants_1.EMPTY_WALLET_UID)) &&
            ((_d = (_c = activeWallets === null || activeWallets === void 0 ? void 0 : activeWallets.external) === null || _c === void 0 ? void 0 : _c.uid) === null || _d === void 0 ? void 0 : _d.equals(constants_1.EMPTY_WALLET_UID)))) {
        throw new Error('No active wallet.');
    }
    return activeWallets;
};
exports.validateActiveWallets = validateActiveWallets;
var validateKvRecords = function (records, fwConstants) {
    if (!fwConstants || !fwConstants.kvActionsAllowed) {
        throw new Error('Unsupported. Please update firmware.');
    }
    else if (typeof records !== 'object' || Object.keys(records).length < 1) {
        throw new Error('One or more key-value mapping must be provided in `records` param.');
    }
    else if (Object.keys(records).length > fwConstants.kvActionMaxNum) {
        throw new Error("Too many keys provided. Please only provide up to ".concat(fwConstants.kvActionMaxNum, "."));
    }
    return records;
};
exports.validateKvRecords = validateKvRecords;
var validateKvRecord = function (_a, fwConstants) {
    var key = _a.key, val = _a.val;
    if (typeof key !== 'string' ||
        String(key).length > fwConstants.kvKeyMaxStrSz) {
        throw new Error("Key ".concat(key, " too large. Must be <=").concat(fwConstants.kvKeyMaxStrSz, " characters."));
    }
    else if (typeof val !== 'string' ||
        String(val).length > fwConstants.kvValMaxStrSz) {
        throw new Error("Value ".concat(val, " too large. Must be <=").concat(fwConstants.kvValMaxStrSz, " characters."));
    }
    else if (String(key).length === 0 || String(val).length === 0) {
        throw new Error('Keys and values must be >0 characters.');
    }
    else if (!constants_1.ASCII_REGEX.test(key) || !constants_1.ASCII_REGEX.test(val)) {
        throw new Error('Unicode characters are not supported.');
    }
    return { key: key, val: val };
};
exports.validateKvRecord = validateKvRecord;
var isValidBlockExplorerResponse = function (data) {
    try {
        var result = JSON.parse(data.result);
        return !(0, isEmpty_1.default)(result);
    }
    catch (err) {
        return false;
    }
};
exports.isValidBlockExplorerResponse = isValidBlockExplorerResponse;
var isValid4ByteResponse = function (data) {
    try {
        return !(0, isEmpty_1.default)(data.results);
    }
    catch (err) {
        return false;
    }
};
exports.isValid4ByteResponse = isValid4ByteResponse;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\validators.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js", {".":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js","./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./protocol":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./shared/validators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","aes-js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\aes-js\\index.js","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","crc-32":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\crc-32\\crc32.js","elliptic":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js","hash.js/lib/hash/sha":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\sha.js","js-sha3":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js","lodash/inRange":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\inRange.js","lodash/isInteger":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\isInteger.js","rlp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\rlp\\dist\\index.js","secp256k1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cutil.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTERNAL = exports.getV = exports.generateAppSecret = exports.fetchCalldataDecoder = exports.fetchWithTimeout = exports.selectDefFrom4byteABI = exports.isUInt4 = exports.randomBytes = exports.existsIn = exports.isAsciiStr = exports.buildSignerPathBuf = exports.getP256KeyPairFromPub = exports.getP256KeyPair = exports.parseDER = exports.aes256_decrypt = exports.aes256_encrypt = exports.fixLen = exports.ensureHexBuffer = exports.splitFrames = exports.isValidAssetPath = exports.toPaddedDER = exports.checksum = exports.parseLattice1Response = void 0;
// Static utility functions
var tx_1 = require("@ethereumjs/tx");
var aes_js_1 = __importDefault(require("aes-js"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var bn_js_1 = require("bn.js");
var crc_32_1 = __importDefault(require("crc-32"));
var elliptic_1 = __importDefault(require("elliptic"));
var sha_1 = require("hash.js/lib/hash/sha");
var js_sha3_1 = require("js-sha3");
var inRange_1 = __importDefault(require("lodash/inRange"));
var isInteger_1 = __importDefault(require("lodash/isInteger"));
var rlp_1 = require("rlp");
var secp256k1_1 = require("secp256k1");
var _1 = require(".");
var constants_1 = require("./constants");
var protocol_1 = require("./protocol");
var validators_1 = require("./shared/validators");
var COINS = constants_1.BIP_CONSTANTS.COINS, PURPOSES = constants_1.BIP_CONSTANTS.PURPOSES;
var EC = elliptic_1.default.ec;
var ec;
//--------------------------------------------------
// LATTICE UTILS
//--------------------------------------------------
/** @internal Parse a response from the Lattice1 */
var parseLattice1Response = function (r) {
    var parsed = {
        errorMessage: null,
        data: null,
    };
    var b = Buffer.from(r, 'hex');
    var off = 0;
    // Get protocol version
    var protoVer = b.readUInt8(off);
    off++;
    if (protoVer !== constants_1.VERSION_BYTE) {
        parsed.errorMessage = 'Incorrect protocol version. Please update your SDK';
        return parsed;
    }
    // Get the type of response
    // Should always be 0x00
    var msgType = b.readUInt8(off);
    off++;
    if (msgType !== 0x00) {
        parsed.errorMessage = 'Incorrect response from Lattice1';
        return parsed;
    }
    // Get the payload
    b.readUInt32BE(off);
    off += 4; // First 4 bytes is the id, but we don't need that anymore
    var len = b.readUInt16BE(off);
    off += 2;
    var payload = b.slice(off, off + len);
    off += len;
    // Get response code
    var responseCode = payload.readUInt8(0);
    if (responseCode !== protocol_1.LatticeResponseCode.success) {
        var errMsg = protocol_1.ProtocolConstants.responseMsg[responseCode];
        parsed.errorMessage = "[Lattice] ".concat(errMsg ? errMsg : 'Unknown Error');
        parsed.responseCode = responseCode;
        return parsed;
    }
    else {
        parsed.data = payload.slice(1, payload.length);
    }
    // Verify checksum
    var cs = b.readUInt32BE(off);
    var expectedCs = (0, exports.checksum)(b.slice(0, b.length - 4));
    if (cs !== expectedCs) {
        parsed.errorMessage = 'Invalid checksum from device response';
        parsed.data = null;
        return parsed;
    }
    return parsed;
};
exports.parseLattice1Response = parseLattice1Response;
/** @internal */
var checksum = function (x) {
    // crc32 returns a signed integer - need to cast it to unsigned
    // Note that this uses the default 0xedb88320 polynomial
    return crc_32_1.default.buf(x) >>> 0; // Need this to be a uint, hence the bit shift
};
exports.checksum = checksum;
// Get a 74-byte padded DER-encoded signature buffer
// `sig` must be the signature output from elliptic.js
/** @internal */
var toPaddedDER = function (sig) {
    // We use 74 as the maximum length of a DER signature. All sigs must
    // be right-padded with zeros so that this can be a fixed size field
    var b = Buffer.alloc(74);
    var ds = Buffer.from(sig.toDER());
    ds.copy(b);
    return b;
};
exports.toPaddedDER = toPaddedDER;
//--------------------------------------------------
// TRANSACTION UTILS
//--------------------------------------------------
/** @internal */
var isValidAssetPath = function (path, fwConstants) {
    var allowedPurposes = [
        PURPOSES.ETH,
        PURPOSES.BTC_LEGACY,
        PURPOSES.BTC_WRAPPED_SEGWIT,
        PURPOSES.BTC_SEGWIT,
    ];
    var allowedCoins = [COINS.ETH, COINS.BTC, COINS.BTC_TESTNET];
    // These coin types were given to us by MyCrypto. They should be allowed, but we expect
    // an Ethereum-type address with these coin types.
    // These all use SLIP44: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    var allowedMyCryptoCoins = [
        60, 61, 966, 700, 9006, 9000, 1007, 553, 178, 137, 37310, 108, 40, 889,
        1987, 820, 6060, 1620, 1313114, 76, 246529, 246785, 1001, 227, 916, 464,
        2221, 344, 73799, 246,
    ];
    // Make sure firmware supports this Bitcoin path
    var isBitcoin = path[1] === COINS.BTC || path[1] === COINS.BTC_TESTNET;
    var isBitcoinNonWrappedSegwit = isBitcoin && path[0] !== PURPOSES.BTC_WRAPPED_SEGWIT;
    if (isBitcoinNonWrappedSegwit && !fwConstants.allowBtcLegacyAndSegwitAddrs)
        return false;
    // Make sure this path is otherwise valid
    return (allowedPurposes.indexOf(path[0]) >= 0 &&
        (allowedCoins.indexOf(path[1]) >= 0 ||
            allowedMyCryptoCoins.indexOf(path[1] - constants_1.HARDENED_OFFSET) > 0));
};
exports.isValidAssetPath = isValidAssetPath;
/** @internal */
var splitFrames = function (data, frameSz) {
    var frames = [];
    var n = Math.ceil(data.length / frameSz);
    var off = 0;
    for (var i = 0; i < n; i++) {
        frames.push(data.slice(off, off + frameSz));
        off += frameSz;
    }
    return frames;
};
exports.splitFrames = splitFrames;
/** @internal */
function isBase10NumStr(x) {
    var bn = new bignumber_js_1.default(x).toFixed().split('.').join('');
    var s = new String(x);
    // Note that the JS native `String()` loses precision for large numbers, but we only
    // want to validate the base of the number so we don't care about far out precision.
    return bn.slice(0, 8) === s.slice(0, 8);
}
/** @internal Ensure a param is represented by a buffer */
var ensureHexBuffer = function (x, zeroIsNull) {
    if (zeroIsNull === void 0) { zeroIsNull = true; }
    try {
        // For null values, return a 0-sized buffer. For most situations we assume
        // 0 should be represented with a zero-length buffer (e.g. for RLP-building
        // txs), but it can also be treated as a 1-byte buffer (`00`) if needed
        if (x === null || (x === 0 && zeroIsNull === true))
            return Buffer.alloc(0);
        var isNumber = typeof x === 'number' || isBase10NumStr(x);
        // Otherwise try to get this converted to a hex string
        if (isNumber) {
            // If this is a number or a base-10 number string, convert it to hex
            x = "".concat(new bignumber_js_1.default(x).toString(16));
        }
        else if (typeof x === 'string' && x.slice(0, 2) === '0x') {
            x = x.slice(2);
        }
        else {
            x = x.toString('hex');
        }
        if (x.length % 2 > 0)
            x = "0".concat(x);
        if (x === '00' && !isNumber)
            return Buffer.alloc(0);
        return Buffer.from(x, 'hex');
    }
    catch (err) {
        throw new Error("Cannot convert ".concat(x.toString(), " to hex buffer (").concat(err.toString(), ")"));
    }
};
exports.ensureHexBuffer = ensureHexBuffer;
/** @internal */
var fixLen = function (msg, length) {
    var buf = Buffer.alloc(length);
    if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
    }
    return msg.slice(-length);
};
exports.fixLen = fixLen;
//--------------------------------------------------
// CRYPTO UTILS
//--------------------------------------------------
/** @internal */
var aes256_encrypt = function (data, key) {
    var iv = Buffer.from(protocol_1.ProtocolConstants.aesIv);
    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    var paddedData = data.length % 16 === 0 ? data : aes_js_1.default.padding.pkcs7.pad(data);
    return Buffer.from(aesCbc.encrypt(paddedData));
};
exports.aes256_encrypt = aes256_encrypt;
/** @internal */
var aes256_decrypt = function (data, key) {
    var iv = Buffer.from(protocol_1.ProtocolConstants.aesIv);
    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    return Buffer.from(aesCbc.decrypt(data));
};
exports.aes256_decrypt = aes256_decrypt;
// Decode a DER signature. Returns signature object {r, s } or null if there is an error
/** @internal */
var parseDER = function (sigBuf) {
    if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02)
        throw new Error('Failed to decode DER signature');
    var off = 3;
    var rLen = sigBuf[off];
    off++;
    var r = sigBuf.slice(off, off + rLen);
    off += rLen;
    if (sigBuf[off] !== 0x02)
        throw new Error('Failed to decode DER signature');
    off++;
    var sLen = sigBuf[off];
    off++;
    var s = sigBuf.slice(off, off + sLen);
    return { r: r, s: s };
};
exports.parseDER = parseDER;
/** @internal */
var getP256KeyPair = function (priv) {
    if (ec === undefined)
        ec = new EC('p256');
    return ec.keyFromPrivate(priv, 'hex');
};
exports.getP256KeyPair = getP256KeyPair;
/** @internal */
var getP256KeyPairFromPub = function (pub) {
    if (ec === undefined)
        ec = new EC('p256');
    return ec.keyFromPublic(pub, 'hex');
};
exports.getP256KeyPairFromPub = getP256KeyPairFromPub;
/** @internal */
var buildSignerPathBuf = function (signerPath, varAddrPathSzAllowed) {
    var buf = Buffer.alloc(24);
    var off = 0;
    if (varAddrPathSzAllowed && signerPath.length > 5)
        throw new Error('Signer path must be <=5 indices.');
    if (!varAddrPathSzAllowed && signerPath.length !== 5)
        throw new Error('Your Lattice firmware only supports 5-index derivation paths. Please upgrade.');
    buf.writeUInt32LE(signerPath.length, off);
    off += 4;
    for (var i = 0; i < 5; i++) {
        if (i < signerPath.length)
            buf.writeUInt32LE(signerPath[i], off);
        else
            buf.writeUInt32LE(0, off);
        off += 4;
    }
    return buf;
};
exports.buildSignerPathBuf = buildSignerPathBuf;
//--------------------------------------------------
// OTHER UTILS
//--------------------------------------------------
/** @internal */
var isAsciiStr = function (str, allowFormatChars) {
    if (allowFormatChars === void 0) { allowFormatChars = false; }
    if (typeof str !== 'string') {
        return false;
    }
    var extraChars = allowFormatChars ?
        [
            0x0020,
            0x000a, // New line
        ] : [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (extraChars.indexOf(c) < 0 && (c < 0x0020 || c > 0x007f)) {
            return false;
        }
    }
    return true;
};
exports.isAsciiStr = isAsciiStr;
/** @internal Check if a value exists in an object. Only checks first level of keys. */
var existsIn = function (val, obj) {
    return Object.keys(obj).some(function (key) { return obj[key] === val; });
};
exports.existsIn = existsIn;
/** @internal Create a buffer of size `n` and fill it with random data */
var randomBytes = function (n) {
    var buf = Buffer.alloc(n);
    for (var i = 0; i < n; i++) {
        buf[i] = Math.round(Math.random() * 255);
    }
    return buf;
};
exports.randomBytes = randomBytes;
/** @internal `isUInt4` accepts a number and returns true if it is a UInt4 */
var isUInt4 = function (n) { return (0, isInteger_1.default)(n) && (0, inRange_1.default)(n, 0, 16); };
exports.isUInt4 = isUInt4;
/**
 * Fetches an external JSON file containing networks indexed by chain id from a GridPlus repo, and
 * returns the parsed JSON.
 */
function fetchExternalNetworkForChainId(chainId) {
    return __awaiter(this, void 0, void 0, function () {
        var body, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, fetch(constants_1.EXTERNAL_NETWORKS_BY_CHAIN_ID_URL)
                            .then(function (res) { return res.json(); })];
                case 1:
                    body = _a.sent();
                    if (body) {
                        return [2 /*return*/, body[chainId]];
                    }
                    else {
                        return [2 /*return*/, undefined];
                    }
                    return [3 /*break*/, 3];
                case 2:
                    err_1 = _a.sent();
                    console.warn('Fetching external networks failed.\n', err_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
/**
 * Builds a URL for fetching calldata from block explorers for any supported chains
 * */
function buildUrlForSupportedChainAndAddress(_a) {
    var supportedChain = _a.supportedChain, address = _a.address;
    var baseUrl = supportedChain.baseUrl;
    var apiRoute = supportedChain.apiRoute;
    var urlWithRoute = "".concat(baseUrl, "/").concat(apiRoute, "&address=").concat(address);
    var apiKey = null;
    var apiKeyParam = apiKey ? "&apiKey=".concat(null) : '';
    return urlWithRoute + apiKeyParam;
}
/**
 * Takes a list of ABI data objects and a selector, and returns the earliest ABI data object that
 * matches the selector.
 */
function selectDefFrom4byteABI(abiData, selector) {
    if (abiData.length > 1) {
        console.warn('WARNING: There are multiple results. Using the first one.');
    }
    var def;
    abiData
        .sort(function (a, b) {
        var aTime = new Date(a.created_at).getTime();
        var bTime = new Date(b.created_at).getTime();
        return aTime - bTime;
    })
        .find(function (result) {
        try {
            def = _1.Calldata.EVM.parsers.parseCanonicalName(selector, result.text_signature);
            return !!def;
        }
        catch (err) {
            return false;
        }
    });
    if (def) {
        return def;
    }
    else {
        throw new Error('Could not find definition for selector');
    }
}
exports.selectDefFrom4byteABI = selectDefFrom4byteABI;
function fetchWithTimeout(url, options) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, timeout, controller, timeoutId, response;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = options.timeout, timeout = _a === void 0 ? 8000 : _a;
                    controller = new AbortController();
                    timeoutId = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, fetch(url, __assign(__assign({}, options), { signal: controller.signal }))];
                case 1:
                    response = _b.sent();
                    clearTimeout(timeoutId);
                    return [2 /*return*/, response];
            }
        });
    });
}
exports.fetchWithTimeout = fetchWithTimeout;
function fetchAndCache(url, opts) {
    return __awaiter(this, void 0, void 0, function () {
        var cache, request, match, response, responseClone, data, err_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 11, , 12]);
                    if (!(globalThis.caches && globalThis.Request)) return [3 /*break*/, 9];
                    return [4 /*yield*/, caches.open('gp-calldata')];
                case 1:
                    cache = _a.sent();
                    request = new Request(url, opts);
                    return [4 /*yield*/, cache.match(request)];
                case 2:
                    match = _a.sent();
                    if (!match) return [3 /*break*/, 3];
                    return [2 /*return*/, match];
                case 3: return [4 /*yield*/, fetch(request, opts)];
                case 4:
                    response = _a.sent();
                    responseClone = response.clone();
                    return [4 /*yield*/, response.json()];
                case 5:
                    data = _a.sent();
                    if (!(response.ok &&
                        ((0, validators_1.isValidBlockExplorerResponse)(data) || (0, validators_1.isValid4ByteResponse)(data)))) return [3 /*break*/, 7];
                    return [4 /*yield*/, cache.put(request, responseClone)];
                case 6:
                    _a.sent();
                    return [2 /*return*/, cache.match(request, opts)];
                case 7: return [2 /*return*/, response];
                case 8: return [3 /*break*/, 10];
                case 9: return [2 /*return*/, fetch(url, opts)];
                case 10: return [3 /*break*/, 12];
                case 11:
                    err_2 = _a.sent();
                    console.error(err_2);
                    throw err_2;
                case 12: return [2 /*return*/];
            }
        });
    });
}
function fetchSupportedChainData(address, supportedChain) {
    return __awaiter(this, void 0, void 0, function () {
        var url;
        return __generator(this, function (_a) {
            url = buildUrlForSupportedChainAndAddress({ address: address, supportedChain: supportedChain });
            return [2 /*return*/, fetchAndCache(url)
                    .then(function (res) { return res.json(); })
                    .then(function (body) {
                    if (body && body.result) {
                        return JSON.parse(body.result);
                    }
                    else {
                        throw new Error('Server response was malformed');
                    }
                })
                    .catch(function () {
                    throw new Error('Fetching data from external network failed');
                })];
        });
    });
}
function fetch4byteData(selector) {
    return __awaiter(this, void 0, void 0, function () {
        var url;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    url = "https://www.4byte.directory/api/v1/signatures/?hex_signature=0x".concat(selector);
                    return [4 /*yield*/, fetch(url)
                            .then(function (res) { return res.json(); })
                            .then(function (body) {
                            if (body && body.results) {
                                return body.results;
                            }
                            else {
                                throw new Error('No results found');
                            }
                        })
                            .catch(function (err) {
                            throw new Error("Fetching data from 4byte failed: ".concat(err.message));
                        })];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function encodeDef(def) {
    return Buffer.from((0, rlp_1.encode)(def));
}
/**
 * Post-process fetched ABI definition.
 * @param def - Calldata decoder data definition for calling function
 * @param calldata - Raw transaction calldata
 * @return - Updated `def`
 */
function postProcessDef(def, calldata) {
    var e_1, _a, e_2, _b;
    return __awaiter(this, void 0, void 0, function () {
        var nestedCalldata, nestedDefs, _c, _e, i, _f, _g, j, _h, _j, e_2_1, _k, _l, e_1_1, newDef;
        return __generator(this, function (_m) {
            switch (_m.label) {
                case 0:
                    nestedCalldata = _1.Calldata.EVM.processors.getNestedCalldata(def, calldata);
                    return [4 /*yield*/, replaceNestedDefs(nestedCalldata)];
                case 1:
                    nestedDefs = _m.sent();
                    _m.label = 2;
                case 2:
                    _m.trys.push([2, 22, 23, 28]);
                    _c = __asyncValues(nestedDefs.entries());
                    _m.label = 3;
                case 3: return [4 /*yield*/, _c.next()];
                case 4:
                    if (!(_e = _m.sent(), !_e.done)) return [3 /*break*/, 21];
                    i = _e.value[0];
                    if (!(Array.isArray(nestedDefs[i]) && typeof nestedDefs[i][0] !== 'string')) return [3 /*break*/, 18];
                    _m.label = 5;
                case 5:
                    _m.trys.push([5, 11, 12, 17]);
                    _f = (e_2 = void 0, __asyncValues(nestedDefs[i].entries()));
                    _m.label = 6;
                case 6: return [4 /*yield*/, _f.next()];
                case 7:
                    if (!(_g = _m.sent(), !_g.done)) return [3 /*break*/, 10];
                    j = _g.value[0];
                    if (!(nestedDefs[i][j] !== null)) return [3 /*break*/, 9];
                    _h = nestedDefs[i];
                    _j = j;
                    return [4 /*yield*/, postProcessDef(nestedDefs[i][j], Buffer.from(nestedCalldata[i][j].slice(2), 'hex'))];
                case 8:
                    _h[_j] = _m.sent();
                    _m.label = 9;
                case 9: return [3 /*break*/, 6];
                case 10: return [3 /*break*/, 17];
                case 11:
                    e_2_1 = _m.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 17];
                case 12:
                    _m.trys.push([12, , 15, 16]);
                    if (!(_g && !_g.done && (_b = _f.return))) return [3 /*break*/, 14];
                    return [4 /*yield*/, _b.call(_f)];
                case 13:
                    _m.sent();
                    _m.label = 14;
                case 14: return [3 /*break*/, 16];
                case 15:
                    if (e_2) throw e_2.error;
                    return [7 /*endfinally*/];
                case 16: return [7 /*endfinally*/];
                case 17: return [3 /*break*/, 20];
                case 18:
                    if (!(nestedDefs[i] !== null)) return [3 /*break*/, 20];
                    _k = nestedDefs;
                    _l = i;
                    return [4 /*yield*/, postProcessDef(nestedDefs[i], Buffer.from(nestedCalldata[i].slice(2), 'hex'))];
                case 19:
                    _k[_l] = _m.sent();
                    _m.label = 20;
                case 20: return [3 /*break*/, 3];
                case 21: return [3 /*break*/, 28];
                case 22:
                    e_1_1 = _m.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 28];
                case 23:
                    _m.trys.push([23, , 26, 27]);
                    if (!(_e && !_e.done && (_a = _c.return))) return [3 /*break*/, 25];
                    return [4 /*yield*/, _a.call(_c)];
                case 24:
                    _m.sent();
                    _m.label = 25;
                case 25: return [3 /*break*/, 27];
                case 26:
                    if (e_1) throw e_1.error;
                    return [7 /*endfinally*/];
                case 27: return [7 /*endfinally*/];
                case 28:
                    newDef = _1.Calldata.EVM.processors.replaceNestedDefs(def, nestedDefs);
                    return [2 /*return*/, newDef];
            }
        });
    });
}
/**
 * Given a set of possible nested defs, slice out selectors and look up
 * definitions on 4byte.
 * @param possNestedDefs - result of `getPossibleNestedDefs` processor
 * @return Array containing calldata decoding data for each parameter
 *          that had a possible nested def. If there was no possible
 *          nested def or if a def could not be fetched from 4byte, the
 *          array item will be `null`. In the case of multiple possible
 *          defs behind one param (e.g. multicall pattern), ALL nested
 *          items must have defs associated or the item will map to a
 *          single `null` value in the return array.
 *
 */
function replaceNestedDefs(possNestedDefs) {
    var possNestedDefs_1, possNestedDefs_1_1;
    var e_3, _a, e_4, _b;
    return __awaiter(this, void 0, void 0, function () {
        var nestedDefs, d, _nestedDefs, shouldInclude, d_1, d_1_1, _d, _nestedSelector, _nestedAbi, _nestedDef, err_3, e_4_1, nestedSelector, nestedAbi, nestedDef, err_4, e_3_1;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    nestedDefs = [];
                    _c.label = 1;
                case 1:
                    _c.trys.push([1, 26, 27, 32]);
                    possNestedDefs_1 = __asyncValues(possNestedDefs);
                    _c.label = 2;
                case 2: return [4 /*yield*/, possNestedDefs_1.next()];
                case 3:
                    if (!(possNestedDefs_1_1 = _c.sent(), !possNestedDefs_1_1.done)) return [3 /*break*/, 25];
                    d = possNestedDefs_1_1.value;
                    if (!(d !== null)) return [3 /*break*/, 23];
                    if (!Array.isArray(d)) return [3 /*break*/, 19];
                    _nestedDefs = [];
                    shouldInclude = true;
                    _c.label = 4;
                case 4:
                    _c.trys.push([4, 12, 13, 18]);
                    d_1 = (e_4 = void 0, __asyncValues(d));
                    _c.label = 5;
                case 5: return [4 /*yield*/, d_1.next()];
                case 6:
                    if (!(d_1_1 = _c.sent(), !d_1_1.done)) return [3 /*break*/, 11];
                    _d = d_1_1.value;
                    _c.label = 7;
                case 7:
                    _c.trys.push([7, 9, , 10]);
                    _nestedSelector = _d.slice(2, 10);
                    return [4 /*yield*/, fetch4byteData(_nestedSelector)];
                case 8:
                    _nestedAbi = _c.sent();
                    _nestedDef = selectDefFrom4byteABI(_nestedAbi, _nestedSelector);
                    _nestedDefs.push(_nestedDef);
                    return [3 /*break*/, 10];
                case 9:
                    err_3 = _c.sent();
                    shouldInclude = false;
                    _nestedDefs.push(null);
                    return [3 /*break*/, 10];
                case 10: return [3 /*break*/, 5];
                case 11: return [3 /*break*/, 18];
                case 12:
                    e_4_1 = _c.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 18];
                case 13:
                    _c.trys.push([13, , 16, 17]);
                    if (!(d_1_1 && !d_1_1.done && (_b = d_1.return))) return [3 /*break*/, 15];
                    return [4 /*yield*/, _b.call(d_1)];
                case 14:
                    _c.sent();
                    _c.label = 15;
                case 15: return [3 /*break*/, 17];
                case 16:
                    if (e_4) throw e_4.error;
                    return [7 /*endfinally*/];
                case 17: return [7 /*endfinally*/];
                case 18:
                    if (shouldInclude) {
                        nestedDefs.push(_nestedDefs);
                    }
                    else {
                        nestedDefs.push(null);
                    }
                    return [3 /*break*/, 22];
                case 19:
                    _c.trys.push([19, 21, , 22]);
                    nestedSelector = d.slice(2, 10);
                    return [4 /*yield*/, fetch4byteData(nestedSelector)];
                case 20:
                    nestedAbi = _c.sent();
                    nestedDef = selectDefFrom4byteABI(nestedAbi, nestedSelector);
                    nestedDefs.push(nestedDef);
                    return [3 /*break*/, 22];
                case 21:
                    err_4 = _c.sent();
                    nestedDefs.push(null);
                    return [3 /*break*/, 22];
                case 22: return [3 /*break*/, 24];
                case 23:
                    nestedDefs.push(null);
                    _c.label = 24;
                case 24: return [3 /*break*/, 2];
                case 25: return [3 /*break*/, 32];
                case 26:
                    e_3_1 = _c.sent();
                    e_3 = { error: e_3_1 };
                    return [3 /*break*/, 32];
                case 27:
                    _c.trys.push([27, , 30, 31]);
                    if (!(possNestedDefs_1_1 && !possNestedDefs_1_1.done && (_a = possNestedDefs_1.return))) return [3 /*break*/, 29];
                    return [4 /*yield*/, _a.call(possNestedDefs_1)];
                case 28:
                    _c.sent();
                    _c.label = 29;
                case 29: return [3 /*break*/, 31];
                case 30:
                    if (e_3) throw e_3.error;
                    return [7 /*endfinally*/];
                case 31: return [7 /*endfinally*/];
                case 32: 
                // For all nested defs, replace the 
                return [2 /*return*/, nestedDefs];
            }
        });
    });
}
//--------------------------------------------------
//--------------------------------------------------
// EXTERNAL UTILS
//--------------------------------------------------
//--------------------------------------------------
/**
 *  Fetches calldata from a remote scanner based on the transaction's `chainId`
 */
function fetchCalldataDecoder(_data, to, _chainId, recurse) {
    if (recurse === void 0) { recurse = true; }
    return __awaiter(this, void 0, void 0, function () {
        var isHexString, data, selector, chainId, cachedNetwork, supportedChain, _a, abi_1, parsedAbi, def_1, err_5, abi, def, err_6;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 15, , 16]);
                    // Exit if there is no data. The 2 comes from the 0x prefix, but a later
                    // check will confirm that there are at least 4 bytes of data in the buffer.
                    if (!_data || _data.length < 2) {
                        throw new Error('Data is either undefined or less than two bytes');
                    }
                    isHexString = typeof _data === 'string' && _data.slice(0, 2) === '0x';
                    data = isHexString ?
                        Buffer.from(_data.slice(2), 'hex') :
                        //@ts-expect-error - Buffer doesn't recognize Uint8Array type properly
                        Buffer.from(_data, 'hex');
                    if (data.length < 4) {
                        throw new Error('Data must contain at least 4 bytes of data to define the selector');
                    }
                    selector = Buffer.from(data.slice(0, 4)).toString('hex');
                    chainId = Number(_chainId);
                    cachedNetwork = constants_1.NETWORKS_BY_CHAIN_ID[chainId];
                    if (!cachedNetwork) return [3 /*break*/, 1];
                    _a = cachedNetwork;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, fetchExternalNetworkForChainId(chainId)];
                case 2:
                    _a = _b.sent();
                    _b.label = 3;
                case 3:
                    supportedChain = _a;
                    _b.label = 4;
                case 4:
                    _b.trys.push([4, 10, , 11]);
                    if (!supportedChain) return [3 /*break*/, 8];
                    return [4 /*yield*/, fetchSupportedChainData(to, supportedChain)];
                case 5:
                    abi_1 = _b.sent();
                    parsedAbi = _1.Calldata.EVM.parsers.parseSolidityJSONABI(selector, abi_1);
                    def_1 = parsedAbi.def;
                    if (!recurse) return [3 /*break*/, 7];
                    return [4 /*yield*/, postProcessDef(def_1, data)];
                case 6:
                    def_1 = _b.sent();
                    _b.label = 7;
                case 7: return [2 /*return*/, { abi: abi_1, def: encodeDef(def_1) }];
                case 8: throw new Error("Chain (id: ".concat(chainId, ") is not supported"));
                case 9: return [3 /*break*/, 11];
                case 10:
                    err_5 = _b.sent();
                    console.warn(err_5.message, '\n', 'Falling back to 4byte');
                    return [3 /*break*/, 11];
                case 11: return [4 /*yield*/, fetch4byteData(selector)];
                case 12:
                    abi = _b.sent();
                    def = selectDefFrom4byteABI(abi, selector);
                    if (!recurse) return [3 /*break*/, 14];
                    return [4 /*yield*/, postProcessDef(def, data)];
                case 13:
                    def = _b.sent();
                    _b.label = 14;
                case 14: return [2 /*return*/, { abi: abi, def: encodeDef(def) }];
                case 15:
                    err_6 = _b.sent();
                    console.warn("Fetching calldata failed: ".concat(err_6.message));
                    return [3 /*break*/, 16];
                case 16: return [2 /*return*/, { def: null, abi: null }];
            }
        });
    });
}
exports.fetchCalldataDecoder = fetchCalldataDecoder;
/**
 * Generates an application secret for use in maintaining connection to device.
 * @param deviceId - The device ID of the device you want to generate a token for.
 * @param password - The password entered when connecting to the device.
 * @param appName - The name of the application.
 * @returns an application secret as a Buffer
 * @public
 */
var generateAppSecret = function (deviceId, password, appName) {
    var deviceIdBuffer = typeof deviceId === 'string' ? Buffer.from(deviceId) : deviceId;
    var passwordBuffer = typeof password === 'string' ? Buffer.from(password) : password;
    var appNameBuffer = typeof appName === 'string' ? Buffer.from(appName) : appName;
    var preImage = Buffer.concat([
        deviceIdBuffer,
        passwordBuffer,
        appNameBuffer,
    ]);
    return Buffer.from((0, sha_1.sha256)().update(preImage).digest('hex'), 'hex');
};
exports.generateAppSecret = generateAppSecret;
/**
 * Generic signing does not return a `v` value like legacy ETH signing requests did.
 * Get the `v` component of the signature as well as an `initV`
 * parameter, which is what you need to use to re-create an `@ethereumjs/tx`
 * object. There is a lot of tech debt in `@ethereumjs/tx` which also
 * inherits the tech debt of ethereumjs-util.
 * 1.  The legacy `Transaction` type can call `_processSignature` with the regular
 *     `v` value.
 * 2.  Newer transaction types such as `FeeMarketEIP1559Transaction` will subtract
 *     27 from the `v` that gets passed in, so we need to add `27` to create `initV`
 * @param tx - An @ethereumjs/tx Transaction object or Buffer (serialized tx)
 * @param resp - response from Lattice. Can be either legacy or generic signing variety
 * @returns bn.js BN object containing the `v` param
 */
var getV = function (tx, resp) {
    var chainId, hash, type;
    var txIsBuf = Buffer.isBuffer(tx);
    if (txIsBuf) {
        hash = Buffer.from((0, js_sha3_1.keccak256)(tx), 'hex');
        try {
            var legacyTxArray = (0, rlp_1.decode)(tx);
            if (legacyTxArray.length === 6) {
                // Six item array means this is a pre-EIP155 transaction
                chainId = null;
            }
            else {
                // Otherwise the `v` param is the `chainId`
                chainId = new bn_js_1.BN(legacyTxArray[6]);
            }
            // Legacy tx = type 0
            type = 0;
        }
        catch (err) {
            // This is likely a typed transaction
            try {
                var txObj = tx_1.TransactionFactory.fromSerializedData(tx);
                //@ts-expect-error -- Accessing private property
                type = txObj._type;
            }
            catch (err) {
                // If we can't RLP decode and can't hydrate an @ethereumjs/tx object,
                // we don't know what this is and should abort.
                throw new Error('Could not recover V. Bad transaction data.');
            }
        }
    }
    else {
        // @ethereumjs/tx object passed in
        type = tx._type;
        hash = type ?
            tx.getMessageToSign(true) : // newer tx types
            (0, rlp_1.encode)(tx.getMessageToSign(false)); // legacy tx
        if (tx.supports(tx_1.Capability.EIP155ReplayProtection)) {
            chainId = tx.common.chainIdBN().toNumber();
        }
    }
    var rs = new Uint8Array(Buffer.concat([resp.sig.r, resp.sig.s]));
    var pubkey = new Uint8Array(resp.pubkey);
    var recovery0 = (0, secp256k1_1.ecdsaRecover)(rs, 0, hash, false);
    var recovery1 = (0, secp256k1_1.ecdsaRecover)(rs, 1, hash, false);
    var pubkeyStr = Buffer.from(pubkey).toString('hex');
    var recovery0Str = Buffer.from(recovery0).toString('hex');
    var recovery1Str = Buffer.from(recovery1).toString('hex');
    var recovery;
    if (pubkeyStr === recovery0Str) {
        recovery = 0;
    }
    else if (pubkeyStr === recovery1Str) {
        recovery = 1;
    }
    else {
        // If we fail a second time, exit here.
        throw new Error('Failed to recover V parameter. Bad signature or transaction data.');
    }
    // Newer transaction types just use the [0, 1] value
    if (type) {
        return new bn_js_1.BN(recovery);
    }
    // If there is no chain ID, this is a pre-EIP155 tx
    if (!chainId) {
        return new bn_js_1.BN(recovery).addn(27);
    }
    // EIP155 replay protection is included in the `v` param
    // and uses the chainId value.
    return chainId.muln(2).addn(35).addn(recovery);
};
exports.getV = getV;
/** @internal */
exports.EXTERNAL = {
    fetchCalldataDecoder: fetchCalldataDecoder,
    generateAppSecret: exports.generateAppSecret,
    getV: exports.getV,
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\util.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9kaXN0L1BvbGxpbmdCbG9ja1RyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9TdWJzY3JpYmVCbG9ja1RyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9ieXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2xsZWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1laXA3MTItdXRpbC1icm93c2VyL2FiaS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtZWlwNzEyLXV0aWwtYnJvd3Nlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtZWlwNzEyLXV0aWwtYnJvd3Nlci9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1laXA3MTItdXRpbC1icm93c2VyL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWVpcDcxMi11dGlsLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2pzLXNoYTMvc3JjL3NoYTMuanMiLCJub2RlX21vZHVsZXMvZXRoLWVpcDcxMi11dGlsLWJyb3dzZXIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtZmlsdGVycy9iYXNlLWZpbHRlci1oaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1maWx0ZXJzL2Jhc2UtZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1maWx0ZXJzL2Jsb2NrLWZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtZmlsdGVycy9nZXRCbG9ja3NGb3JSYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtZmlsdGVycy9oZXhVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtZmlsdGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtZmlsdGVycy9sb2ctZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1maWx0ZXJzL3N1YnNjcmlwdGlvbk1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLWZpbHRlcnMvdHgtZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1sYXR0aWNlLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWxhdHRpY2Uta2V5cmluZy9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1sYXR0aWNlLWtleXJpbmcvbm9kZV9tb2R1bGVzL3JscC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1waGlzaGluZy1kZXRlY3Qvc3JjL2NvbmZpZy5qc29uIiwibm9kZV9tb2R1bGVzL2V0aC1waGlzaGluZy1kZXRlY3Qvc3JjL2RldGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2hhc2gtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEuanMiLCJub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWxpYi9kZXIuanMiLCJub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoanMtdXRpbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2hka2V5LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvaGFzaC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMS5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxdjMtYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxdjMtbGliL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxdjMtbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGpzLXV0aWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvdGhpcmRwYXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvY29tbW9uanMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvY29tbW9uanMvZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9jb21tb25qcy9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWxldmVuc2h0ZWluL2xldmVuc2h0ZWluLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2FwaS9hZGRyZXNzVGFncy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9hcGkvYWRkcmVzc2VzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2FwaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9hcGkvc2lnbmluZy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9hcGkvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvYXBpL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9iaXRjb2luLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2NhbGxkYXRhL2V2bS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9jYWxsZGF0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2V0aGVyZXVtLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2Z1bmN0aW9ucy9hZGRLdlJlY29yZHMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZnVuY3Rpb25zL2Nvbm5lY3QuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZnVuY3Rpb25zL2ZldGNoQWN0aXZlV2FsbGV0LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2Z1bmN0aW9ucy9mZXRjaEVuY0RhdGEuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZnVuY3Rpb25zL2dldEFkZHJlc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9mdW5jdGlvbnMvZ2V0S3ZSZWNvcmRzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2Z1bmN0aW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9mdW5jdGlvbnMvcGFpci5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9mdW5jdGlvbnMvcmVtb3ZlS3ZSZWNvcmRzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2Z1bmN0aW9ucy9zaWduLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2dlbmVyaWNTaWduaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L3Byb3RvY29sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L3Byb3RvY29sL2xhdHRpY2VDb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvcHJvdG9jb2wvc2VjdXJlTWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3Qvc2hhcmVkL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9zaGFyZWQvZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L3NoYXJlZC9wcmVkaWNhdGVzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L3NoYXJlZC91dGlsaXRpZXMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3Qvc2hhcmVkL3ZhbGlkYXRvcnMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDMWpFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2hwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN2d0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbmtkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDem5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2xlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDM2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImJhY2tncm91bmQtNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfcmFuZG9tX2lkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLXJhbmRvbS1pZFwiKSk7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgQmFzZUJsb2NrVHJhY2tlcl8xID0gcmVxdWlyZShcIi4vQmFzZUJsb2NrVHJhY2tlclwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBsb2cgPSAoMCwgbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcikobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdwb2xsaW5nLWJsb2NrLXRyYWNrZXInKTtcbmNvbnN0IGNyZWF0ZVJhbmRvbUlkID0gKDAsIGpzb25fcnBjX3JhbmRvbV9pZF8xLmRlZmF1bHQpKCk7XG5jb25zdCBzZWMgPSAxMDAwO1xuY2xhc3MgUG9sbGluZ0Jsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBwYXJzZSArIHZhbGlkYXRlIGFyZ3NcbiAgICAgICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYmxvY2tSZXNldER1cmF0aW9uOiAoX2EgPSBvcHRzLmJsb2NrUmVzZXREdXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0cy5wb2xsaW5nSW50ZXJ2YWwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25maWdcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSBvcHRzLnBvbGxpbmdJbnRlcnZhbCB8fCAyMCAqIHNlYztcbiAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gb3B0cy5yZXRyeVRpbWVvdXQgfHwgdGhpcy5fcG9sbGluZ0ludGVydmFsIC8gMTA7XG4gICAgICAgIHRoaXMuX2tlZXBFdmVudExvb3BBY3RpdmUgPVxuICAgICAgICAgICAgb3B0cy5rZWVwRXZlbnRMb29wQWN0aXZlID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5rZWVwRXZlbnRMb29wQWN0aXZlO1xuICAgICAgICB0aGlzLl9zZXRTa2lwQ2FjaGVGbGFnID0gb3B0cy5zZXRTa2lwQ2FjaGVGbGFnIHx8IGZhbHNlO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGJsb2NrIHBvbGxpbmdcbiAgICBhc3luYyBjaGVja0ZvckxhdGVzdEJsb2NrKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVMYXRlc3RCbG9jaygpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9jaygpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuX3N5bmNocm9uaXplKCk7XG4gICAgfVxuICAgIGFzeW5jIF9lbmQoKSB7XG4gICAgICAgIC8vIE5vLW9wXG4gICAgfVxuICAgIGFzeW5jIF9zeW5jaHJvbml6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB3aGlsZSAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUxhdGVzdEJsb2NrKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRpbWVvdXQodGhpcy5fcG9sbGluZ0ludGVydmFsLCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdfd2FpdGluZ0Zvck5leHRJdGVyYXRpb24nKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VyciA9IG5ldyBFcnJvcihgUG9sbGluZ0Jsb2NrVHJhY2tlciAtIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gdXBkYXRlIGxhdGVzdCBibG9jazpcXG4keyhfYSA9IGVyci5zdGFjaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXJyfWApO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXdFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZW1pdEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ld0Vycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aW1lb3V0KHRoaXMuX3JldHJ5VGltZW91dCwgIXRoaXMuX2tlZXBFdmVudExvb3BBY3RpdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnX3dhaXRpbmdGb3JOZXh0SXRlcmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIC8vIGZldGNoICsgc2V0IGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IHRoaXMuX2ZldGNoTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgdGhpcy5fbmV3UG90ZW50aWFsTGF0ZXN0KGxhdGVzdEJsb2NrKTtcbiAgICB9XG4gICAgYXN5bmMgX2ZldGNoTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgaWQ6IGNyZWF0ZVJhbmRvbUlkKCksXG4gICAgICAgICAgICBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInLFxuICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldFNraXBDYWNoZUZsYWcpIHtcbiAgICAgICAgICAgIHJlcS5za2lwQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxvZygnTWFraW5nIHJlcXVlc3QnLCByZXEpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCAoMCwgcGlmeV8xLmRlZmF1bHQpKChjYikgPT4gdGhpcy5fcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSwgY2IpKSgpO1xuICAgICAgICBsb2coJ0dvdCByZXNwb25zZScsIHJlcyk7XG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9sbGluZ0Jsb2NrVHJhY2tlciAtIGVuY291bnRlcmVkIGVycm9yIGZldGNoaW5nIGJsb2NrOlxcbiR7cmVzLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nQmxvY2tUcmFja2VyID0gUG9sbGluZ0Jsb2NrVHJhY2tlcjtcbi8qKlxuICogV2FpdHMgZm9yIHRoZSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIGR1cmF0aW9uIC0gVGhlIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB1bnJlZiAtIEFzc3VtaW5nIHRoaXMgZnVuY3Rpb24gaXMgcnVuIGluIGEgTm9kZSBjb250ZXh0LCBnb3Zlcm5zXG4gKiB3aGV0aGVyIE5vZGUgc2hvdWxkIHdhaXQgYmVmb3JlIHRoZSBgc2V0VGltZW91dGAgaGFzIGNvbXBsZXRlZCBiZWZvcmUgZW5kaW5nXG4gKiB0aGUgcHJvY2VzcyAodHJ1ZSBmb3Igbm8sIGZhbHNlIGZvciB5ZXMpLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHdhaXQuXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24sIHVucmVmKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICAgICAgLy8gZG9uJ3Qga2VlcCBwcm9jZXNzIG9wZW5cbiAgICAgICAgaWYgKHRpbWVvdXRSZWYudW5yZWYgJiYgdW5yZWYpIHtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9sbGluZ0Jsb2NrVHJhY2tlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Vic2NyaWJlQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfcmFuZG9tX2lkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLXJhbmRvbS1pZFwiKSk7XG5jb25zdCBCYXNlQmxvY2tUcmFja2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlQmxvY2tUcmFja2VyXCIpO1xuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSAoMCwganNvbl9ycGNfcmFuZG9tX2lkXzEuZGVmYXVsdCkoKTtcbmNsYXNzIFN1YnNjcmliZUJsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgICAgIGlmICghb3B0cy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpYmVCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFzZUJsb2NrVHJhY2tlciBjb25zdHJ1Y3RvclxuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gb3B0cy5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uSWQgPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBjaGVja0ZvckxhdGVzdEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9jaygpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3N1YnNjcmlwdGlvbklkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gKGF3YWl0IHRoaXMuX2NhbGwoJ2V0aF9ibG9ja051bWJlcicpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25JZCA9IChhd2FpdCB0aGlzLl9jYWxsKCdldGhfc3Vic2NyaWJlJywgJ25ld0hlYWRzJykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyLm9uKCdkYXRhJywgdGhpcy5faGFuZGxlU3ViRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSBudWxsICYmIHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FsbCgnZXRoX3Vuc3Vic2NyaWJlJywgdGhpcy5fc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbklkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWxsKG1ldGhvZCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm92aWRlci5zZW5kQXN5bmMoe1xuICAgICAgICAgICAgICAgIGlkOiBjcmVhdGVSYW5kb21JZCgpLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICB9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVTdWJEYXRhKF8sIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gJ2V0aF9zdWJzY3JpcHRpb24nICYmXG4gICAgICAgICAgICAoKF9hID0gcmVzcG9uc2UucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaXB0aW9uKSA9PT0gdGhpcy5fc3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25ld1BvdGVudGlhbExhdGVzdChyZXNwb25zZS5wYXJhbXMucmVzdWx0Lm51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmliZUJsb2NrVHJhY2tlciA9IFN1YnNjcmliZUJsb2NrVHJhY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZUJsb2NrVHJhY2tlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1BvbGxpbmdCbG9ja1RyYWNrZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1N1YnNjcmliZUJsb2NrVHJhY2tlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNb2R1bGVMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyOyB9IH0pO1xuZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvamVjdExvZ2dlcikoJ2V0aC1ibG9jay10cmFja2VyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgbWVzc2FnZWAgcHJvcGVydHksIHN1Y2ggYXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgb3IgZmFsc2UsIGRlcGVuZGluZyBvbiB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBjb25zdHJ1Y3RvciwgaS5lLiwgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aFxuICogdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RhYmxlKGZuKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiAoKF9iID0gKF9hID0gZm4gPT09IG51bGwgfHwgZm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZuLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogR2V0IHRoZSBlcnJvciBtZXNzYWdlIGZyb20gYW4gdW5rbm93biBlcnJvciBvYmplY3QuIElmIHRoZSBlcnJvciBvYmplY3QgaGFzXG4gKiBhIGBtZXNzYWdlYCBwcm9wZXJ0eSwgdGhhdCBwcm9wZXJ0eSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgc3RyaW5naWZpZWRcbiAqIGVycm9yIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgLy8gSWYgdGhlIGVycm9yIGVuZHMgd2l0aCBhIHBlcmlvZCwgcmVtb3ZlIGl0LCBhcyB3ZSdsbCBhZGQgb3VyIG93biBwZXJpb2QuXG4gICAgaWYgKG1lc3NhZ2UuZW5kc1dpdGgoJy4nKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2U2NCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwcm92aWRlZCBzdHJpbmctYmFzZWQgc3RydWN0IGlzIHZhbGlkIGJhc2U2NC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cmluZyBiYXNlZCBzdHJ1Y3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgdG8gc3BlY2lhbGl6ZSBiYXNlNjQgdmFsaWRhdGlvbi4gU2VlIHtAbGluayBCYXNlNjRPcHRpb25zfSBkb2N1bWVudGF0aW9uLlxuICogQHJldHVybnMgQSBzdXBlcnN0cnVjdCB2YWxpZGF0aW5nIGJhc2U2NC5cbiAqL1xuY29uc3QgYmFzZTY0ID0gKHN0cnVjdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwYWRkaW5nUmVxdWlyZWQgPSAoX2EgPSBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gKF9iID0gb3B0aW9ucy5jaGFyYWN0ZXJTZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8vICcwJy5jaGFyQ29kZUF0KDApID09PSA0OFxuY29uc3QgSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDQ4O1xuLy8gJzknLmNoYXJDb2RlQXQoMCkgPT09IDU3XG5jb25zdCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNTg7XG5jb25zdCBIRVhfQ0hBUkFDVEVSX09GRlNFVCA9IDg3O1xuLyoqXG4gKiBNZW1vaXplZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgdG8gYmUgdXNlZCBhcyBhIGxvb2t1cCB0YWJsZSBmb3JcbiAqIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4YWRlY2ltYWwgdmFsdWVzLlxuICpcbiAqIFRoZSBhcnJheSBpcyBjcmVhdGVkIGxhemlseSBhbmQgdGhlbiBjYWNoZWQgZm9yIGZ1dHVyZSB1c2UuIFRoZSBiZW5lZml0IG9mXG4gKiB0aGlzIGFwcHJvYWNoIGlzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4IGlzIG11Y2hcbiAqIGJldHRlciB0aGFuIGlmIHdlIHdlcmUgdG8gY2FsbCBgdG9TdHJpbmcoMTYpYCBvbiBlYWNoIGJ5dGUuXG4gKlxuICogVGhlIGRvd25zaWRlIGlzIHRoYXQgdGhlIGFycmF5IGlzIGNyZWF0ZWQgb25jZSBhbmQgdGhlbiBuZXZlciBnYXJiYWdlXG4gKiBjb2xsZWN0ZWQuIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBpbiBwcmFjdGljZSBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IDI1NlxuICogZWxlbWVudHMgbG9uZy5cbiAqXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbG9va3VwIHRhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKSB7XG4gICAgLy8gVG8gYXZvaWQgaXNzdWVzIHdpdGggdHJlZSBzaGFraW5nLCB3ZSBuZWVkIHRvIHVzZSBhIGZ1bmN0aW9uIHRvIHJldHVybiB0aGVcbiAgICAvLyBhcnJheS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IHVzZWQgaW4gdGhlIGBieXRlc1RvSGV4YCBmdW5jdGlvblxuICAgIC8vIGFuZCBpZiB3ZSB3ZXJlIHRvIHVzZSBhIGdsb2JhbCB2YXJpYWJsZSwgdGhlIGFycmF5IG1pZ2h0IGJlIHJlbW92ZWQgYnkgdGhlXG4gICAgLy8gdHJlZSBzaGFrZXIuXG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBbXTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobG9va3VwVGFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUucHVzaChpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9va3VwVGFibGU7XG4gICAgfTtcbn1cbi8qKlxuICogRnVuY3Rpb24gaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXJ9XG4gKiBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNCeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzQnl0ZXModmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIFVpbnQ4QXJyYXkuJyk7XG59XG5leHBvcnRzLmFzc2VydElzQnl0ZXMgPSBhc3NlcnRJc0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMoKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IG5ldyBBcnJheShieXRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgaGV4YWRlY2ltYWxbaV0gPSBsb29rdXBUYWJsZVtieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKGhleGFkZWNpbWFsLmpvaW4oJycpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvTnVtYmVyfS5cbiAqIFRvIGNvbnZlcnQgYSB0d28ncyBjb21wbGVtZW50IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9TaWduZWRCaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9CaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IGJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgIHJldHVybiBCaWdJbnQoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gYnl0ZXNUb0JpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIHNpZ25lZCBgYmlnaW50YC4gVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGJ5dGVzIGFyZVxuICogZW5jb2RlZCBpbiB0d28ncyBjb21wbGVtZW50LlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYW4gdW5zaWduZWQgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc2lnbmVkIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIHNpZ25lZCBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1NpZ25lZEJpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYnl0ZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgQmlnSW50KDgpKSArIEJpZ0ludChieXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oYnl0ZXMubGVuZ3RoICogOCwgdmFsdWUpO1xufVxuZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gYnl0ZXNUb1NpZ25lZEJpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHJlc3VsdGluZyBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgYmlnaW50ID0gYnl0ZXNUb0JpZ0ludChieXRlcyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnaW50IDw9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksICdOdW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJ5dGVzVG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIE51bWJlcihiaWdpbnQpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gYnl0ZXNUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYHN0cmluZ2AuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgc3RyaW5nIGNhbiBvcHRpb25hbGx5IGJlXG4gKiBwcmVmaXhlZCB3aXRoIGAweGAuIEl0IGFjY2VwdHMgZXZlbiBhbmQgb2RkIGxlbmd0aCBzdHJpbmdzLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBcIjB4XCIsIGFuIGVtcHR5IGBVaW50OEFycmF5YCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFwiMHhcIiBpcyBvZnRlbiB1c2VkIGFzIGVtcHR5IGJ5dGUgYXJyYXkuXG4gICAgaWYgKCgoX2EgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9Mb3dlckNhc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlKSkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFJlbW92ZSB0aGUgYDB4YCBwcmVmaXggaWYgaXQgZXhpc3RzLCBhbmQgcGFkIHRoZSBzdHJpbmcgdG8gaGF2ZSBhbiBldmVuXG4gICAgLy8gbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9ICgwLCBoZXhfMS5yZW1vdmUweCkodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gc3RyaXBwZWRWYWx1ZS5sZW5ndGggJSAyID09PSAwID8gc3RyaXBwZWRWYWx1ZSA6IGAwJHtzdHJpcHBlZFZhbHVlfWA7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShub3JtYWxpemVkVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIG5vdCB0aGUgcHJldHRpZXN0IHdheSB0byBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXlgLCBpdCBpcyBhIGxvdCBmYXN0ZXIgdGhhbiB1c2luZyBgcGFyc2VJbnRgIHRvIGNvbnZlcnQgZWFjaFxuICAgICAgICAvLyBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0IGMxID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIpO1xuICAgICAgICBjb25zdCBjMiA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gICAgICAgIGNvbnN0IG4xID0gYzEgLVxuICAgICAgICAgICAgKGMxIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBjb25zdCBuMiA9IGMyIC1cbiAgICAgICAgICAgIChjMiA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgYnl0ZXNbaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYGJpZ2ludGAgaXMgYW4gdW5zaWduZWQgaW50ZWdlci4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYmlnaW50IHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBiaWdJbnRUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gQmlnSW50KDApLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gYmlnSW50VG9CeXRlcztcbi8qKlxuICogQ2hlY2sgaWYgYSBgYmlnaW50YCBmaXRzIGluIGEgY2VydGFpbiBudW1iZXIgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNoZWNrLlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIG51bWJlciBvZiBieXRlcy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGBiaWdpbnRgIGZpdHMgaW4gdGhlIG51bWJlciBvZiBieXRlcy5cbiAqL1xuZnVuY3Rpb24gYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZXMpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlcyA+IDApO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBtYXNrID0gdmFsdWUgPj4gQmlnSW50KDMxKTtcbiAgICByZXR1cm4gISgoKH52YWx1ZSAmIG1hc2spICsgKHZhbHVlICYgfm1hc2spKSA+PiBCaWdJbnQoYnl0ZXMgKiA4ICsgfjApKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC4gVGhpcyB1c2VzIHR3bydzIGNvbXBsZW1lbnRcbiAqIGVuY29kaW5nIHRvIHJlcHJlc2VudCBuZWdhdGl2ZSBudW1iZXJzLlxuICpcbiAqIFRvIGNvbnZlcnQgYW4gdW5zaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9CeXRlc30uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIGBVaW50OEFycmF5YC4gSWYgdGhlIG51bWJlclxuICogaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGxlbmd0aCxcbiAqIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZEJpZ0ludFRvQnl0ZXModmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicsICdCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJ5dGVMZW5ndGggPiAwLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdJbnRGaXRzKHZhbHVlLCBieXRlTGVuZ3RoKSwgJ0J5dGUgbGVuZ3RoIGlzIHRvbyBzbWFsbCB0byByZXByZXNlbnQgdGhlIGdpdmVuIHZhbHVlLicpO1xuICAgIC8vIEVTTGludCBkb2Vzbid0IGxpa2UgbXV0YXRpbmcgZnVuY3Rpb24gcGFyYW1ldGVycywgc28gdG8gYXZvaWQgaGF2aW5nIHRvXG4gICAgLy8gZGlzYWJsZSB0aGUgcnVsZSwgd2UgY3JlYXRlIGEgbmV3IHZhcmlhYmxlLlxuICAgIGxldCBudW1iZXJWYWx1ZSA9IHZhbHVlO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IE51bWJlcihCaWdJbnQuYXNVaW50Tig4LCBudW1iZXJWYWx1ZSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBudW1iZXJWYWx1ZSA+Pj0gQmlnSW50KDgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gc2lnbmVkQmlnSW50VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBudW1iZXJgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0J5dGVzYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IG51bWJlclRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgc3RyaW5nYCB0byBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBieXRlLWxpa2UgdmFsdWUgdG8gYSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZSBjYW4gYmUgYSBgVWludDhBcnJheWAsXG4gKiBhIGBiaWdpbnRgLCBhIGBudW1iZXJgLCBvciBhIGBzdHJpbmdgLlxuICpcbiAqIFRoaXMgd2lsbCBhdHRlbXB0IHRvIGd1ZXNzIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBiYXNlZCBvbiBpdHMgdHlwZSBhbmRcbiAqIGNvbnRlbnRzLiBGb3IgbW9yZSBjb250cm9sIG92ZXIgdGhlIGNvbnZlcnNpb24sIHVzZSB0aGUgbW9yZSBzcGVjaWZpY1xuICogY29udmVyc2lvbiBmdW5jdGlvbnMsIHN1Y2ggYXMge0BsaW5rIGhleFRvQnl0ZXN9IG9yIHtAbGluayBzdHJpbmdUb0J5dGVzfS5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgc3RyaW5nYCwgYW5kIGl0IGlzIHByZWZpeGVkIHdpdGggYDB4YCwgaXQgd2lsbCBiZVxuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhXG4gKiBVVEYtOCBzdHJpbmcuIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYnl0ZXMgd2l0aG91dCBpbnRlcnByZXRpbmdcbiAqIGl0IGFzIGEgVVRGLTggc3RyaW5nLCB1c2Uge0BsaW5rIGhleFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIGFzc3VtZWQgdG8gYmUgdW5zaWduZWQuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIHRvIGJ5dGVzLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gdmFsdWVUb0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGJpZ0ludFRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZSB0eXBlOiBcIiR7dHlwZW9mIHZhbHVlfVwiLmApO1xufVxuZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSB2YWx1ZVRvQnl0ZXM7XG4vKipcbiAqIENvbmNhdGVuYXRlIG11bHRpcGxlIGJ5dGUtbGlrZSB2YWx1ZXMgaW50byBhIHNpbmdsZSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZXNcbiAqIGNhbiBiZSBgVWludDhBcnJheWAsIGBiaWdpbnRgLCBgbnVtYmVyYCwgb3IgYHN0cmluZ2AuIFRoaXMgdXNlc1xuICoge0BsaW5rIHZhbHVlVG9CeXRlc30gdW5kZXIgdGhlIGhvb2QgdG8gY29udmVydCBlYWNoIHZhbHVlIHRvIGJ5dGVzLiBSZWZlciB0b1xuICogdGhlIGRvY3VtZW50YXRpb24gb2YgdGhhdCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWVzID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlVG9CeXRlcyh2YWx1ZXNbaV0pO1xuICAgICAgICBub3JtYWxpemVkVmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgIGJ5dGVMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgbm9ybWFsaXplZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB3ZSBjb3VsZCBzaW1wbHkgc3ByZWFkIHRoZSB2YWx1ZXMgaW50byBhbiBhcnJheSBhbmQgdXNlXG4gICAgICAgIC8vIGBVaW50OEFycmF5LmZyb21gLCB0aGF0IGlzIGEgbG90IHNsb3dlciB0aGFuIHVzaW5nIGBVaW50OEFycmF5LnNldGAuXG4gICAgICAgIGJ5dGVzLnNldChub3JtYWxpemVkVmFsdWVzW2ldLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gbm9ybWFsaXplZFZhbHVlc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBmcm9tIGEge0BsaW5rIFVpbnQ4QXJyYXl9LiBUaGlzIGlzIGEgY29udmVuaWVuY2VcbiAqIGZ1bmN0aW9uIHRoYXQgYXZvaWRzIGhhdmluZyB0byBjcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IG1hbnVhbGx5LCB3aGljaFxuICogcmVxdWlyZXMgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBldmVyeSB0aW1lLlxuICpcbiAqIE5vdCBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGNhbiByZXN1bHQgaW5cbiAqIHVuZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiB0aGUge0BsaW5rIFVpbnQ4QXJyYXl9IGlzIGEgdmlldyBvZiBhIGxhcmdlclxuICoge0BsaW5rIEFycmF5QnVmZmVyfSwgZS5nLiwgd2hlbiB1c2luZyB7QGxpbmsgVWludDhBcnJheS5zdWJhcnJheX0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHNvIHN1cHBvcnRzIE5vZGUuanMge0BsaW5rIEJ1ZmZlcn1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSk7XG4gKlxuICogLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvOlxuICogLy8gY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAqIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpO1xuICogYGBgXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY3JlYXRlIHRoZSB7QGxpbmsgRGF0YVZpZXd9IGZyb20uXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIERhdGFWaWV3fS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpIHtcbiAgICAvLyBUbyBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggTm9kZS5qcywgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgYnl0ZXMgYXJlXG4gICAgLy8gYSBCdWZmZXIuIElmIHNvLCB3ZSBuZWVkIHRvIHNsaWNlIHRoZSBidWZmZXIgdG8gZ2V0IHRoZSB1bmRlcmx5aW5nXG4gICAgLy8gQXJyYXlCdWZmZXIuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBieXRlcy5idWZmZXIuc2xpY2UoYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZU9mZnNldCArIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbn1cbmV4cG9ydHMuY3JlYXRlRGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NFwiKTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5zaXplKSgoMCwgYmFzZTY0XzEuYmFzZTY0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIHsgcGFkZGluZ1JlcXVpcmVkOiB0cnVlIH0pLCA0NCwgNDQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzdW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUhleCA9IGV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBleHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGV4cG9ydHMuY3JlYXRlTnVtYmVyID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRnJvemVuTWFwX21hcCwgX0Zyb3plblNldF9zZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyb3plblNldCA9IGV4cG9ydHMuRnJvemVuTWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seU1hcH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIG1hcCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgbWFwLlxuICovXG5jbGFzcyBGcm96ZW5NYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgX0Zyb3plbk1hcF9tYXAuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIG5ldyBNYXAoZW50cmllcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBtYXAuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZm9yRWFjaCgodmFsdWUsIGtleSwgX21hcCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuaGFzKGtleSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plbk1hcCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke1N0cmluZyhrZXkpfSA9PiAke1N0cmluZyh2YWx1ZSl9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plbk1hcCA9IEZyb3plbk1hcDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlTZXR9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBzZXQgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIHNldC5cbiAqL1xuY2xhc3MgRnJvemVuU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgX0Zyb3plblNldF9zZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plblNldF9zZXQsIG5ldyBTZXQodmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5TZXRfc2V0ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIHNldC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwgdmFsdWUyLCBfc2V0KSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlMiwgdGhpcykpO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5TZXQoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy52YWx1ZXMoKV0ubWFwKChtZW1iZXIpID0+IFN0cmluZyhtZW1iZXIpKS5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuU2V0ID0gRnJvemVuU2V0O1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXApO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXAucHJvdG90eXBlKTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0KTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0LnByb3RvdHlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlMHggPSBleHBvcnRzLmFkZDB4ID0gZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gZXhwb3J0cy5IZXhTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5leHBvcnRzLkhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG5leHBvcnRzLlN0cmljdEhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14weFswLTlhLWZdKyQvaXUpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8qKlxuICogU3RyaWN0bHkgY2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdFxuICogc3RhcnQgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGlzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzSGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG59XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBzdGFydCB3aXRoXG4gKiB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGFzc2VydElzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBZGQgdGhlIGAweGAtcHJlZml4IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaGFzIHRoZVxuICogcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFkZCB0aGUgcHJlZml4IHRvLlxuICogQHJldHVybnMgVGhlIHByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZXhwb3J0cy5hZGQweCA9IGFkZDB4O1xuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW1vdmUweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpIHx8IGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xufVxuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXJ0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlNjRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGVja3N1bVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29lcmNlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21pc2NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3BhcXVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90aW1lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92ZXJzaW9uc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVKc29uQW5kR2V0U2l6ZSA9IGV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmlzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9IGV4cG9ydHMuanNvbnJwYzIgPSBleHBvcnRzLmlzVmFsaWRKc29uID0gZXhwb3J0cy5Kc29uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgbWlzY18xID0gcmVxdWlyZShcIi4vbWlzY1wiKTtcbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZSkoJ0pzb24nLCAodmFsdWUpID0+IHtcbiAgICBjb25zdCBbaXNWYWxpZF0gPSB2YWxpZGF0ZUpzb25BbmRHZXRTaXplKHZhbHVlLCB0cnVlKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuICdFeHBlY3RlZCBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlJztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLCBpLmUuLCBhIHZhbHVlIHRoYXQgaXNcbiAqIHNlcmlhbGl6YWJsZSB0byBKU09OLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIFRoZSBzdHJpbmcgJzIuMCcuXG4gKi9cbmV4cG9ydHMuanNvbnJwYzIgPSAnMi4wJztcbmV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5saXRlcmFsKShleHBvcnRzLmpzb25ycGMyKTtcbmV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubnVsbGFibGUpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCldKSk7XG5leHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGNvZGU6ICgwLCBzdXBlcnN0cnVjdF8xLmludGVnZXIpKCksXG4gICAgbWVzc2FnZTogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIGRhdGE6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpKSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSkpO1xuZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIG1ldGhvZDogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIHBhcmFtczogZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vbWl0KShleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCBbJ2lkJ10pO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259XG4gKiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGlzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIG5vdGlmaWNhdGlvbicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVxdWVzdCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gaXNKc29uUnBjUmVxdWVzdDtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIEpTT04tUlBDIHJlcXVlc3Qgb3Igbm90aWZpY2F0aW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0KHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXF1ZXN0JywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGFzc2VydElzSnNvblJwY1JlcXVlc3Q7XG5leHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmtub3duKSgpKSxcbiAgICBlcnJvcjogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogZXhwb3J0cy5Kc29uU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgZXJyb3I6IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbXG4gICAgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCxcbiAgICBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0LFxuXSk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgd2hldGhlciBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgYVxuICoge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBwZW5kaW5nLlxuICovXG5mdW5jdGlvbiBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkocmVzcG9uc2UsIGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCwgJ0ludmFsaWQgcGVuZGluZyBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGEge0BsaW5rIEpzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIEpzb25ScGNSZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gaXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXNwb25zZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gaXNKc29uUnBjU3VjY2Vzcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNTdWNjZXNzKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBzdWNjZXNzIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGFzc2VydElzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0ZhaWx1cmUodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGlzSnNvblJwY0ZhaWx1cmU7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZmFpbHVyZSByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBhc3NlcnRJc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0Vycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGlzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRXJyb3IodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBlcnJvcicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gYXNzZXJ0SXNKc29uUnBjRXJyb3I7XG4vKipcbiAqIEdldHMgYSBmdW5jdGlvbiBmb3IgdmFsaWRhdGluZyBKU09OLVJQQyByZXF1ZXN0IC8gcmVzcG9uc2UgYGlkYCB2YWx1ZXMuXG4gKlxuICogQnkgbWFuaXB1bGF0aW5nIHRoZSBvcHRpb25zIG9mIHRoaXMgZmFjdG9yeSwgeW91IGNhbiBjb250cm9sIHRoZSBiZWhhdmlvclxuICogb2YgdGhlIHJlc3VsdGluZyB2YWxpZGF0b3IgZm9yIHNvbWUgZWRnZSBjYXNlcy4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBlLmcuXG4gKiBgbnVsbGAgc2hvdWxkIHNvbWV0aW1lcyBidXQgbm90IGFsd2F5cyBiZSBwZXJtaXR0ZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBlbXB0eSBzdHJpbmcgKGAnJ2ApIGlzIGFsd2F5cyBwZXJtaXR0ZWQgYnkgdGhlIEpTT04tUlBDXG4gKiBzcGVjaWZpY2F0aW9uLCBidXQgdGhhdCBraW5kIG9mIHN1Y2tzIGFuZCB5b3UgbWF5IHdhbnQgdG8gZm9yYmlkIGl0IGluIHNvbWVcbiAqIGluc3RhbmNlcyBhbnl3YXkuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZVxuICogW0pTT04tUlBDIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmpzb25ycGMub3JnL3NwZWNpZmljYXRpb24pLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRFbXB0eVN0cmluZyAtIFdoZXRoZXIgdGhlIGVtcHR5IHN0cmluZyAoaS5lLiBgJydgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC4gRGVmYXVsdDogYHRydWVgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRGcmFjdGlvbnMgLSBXaGV0aGVyIGZyYWN0aW9uYWwgbnVtYmVycyAoZS5nLiBgMS4yYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkIElEcy4gRGVmYXVsdDogYGZhbHNlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0TnVsbCAtIFdoZXRoZXIgYG51bGxgIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuXG4gKiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEByZXR1cm5zIFRoZSBKU09OLVJQQyBJRCB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25ScGNJZFZhbGlkYXRvcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwZXJtaXRFbXB0eVN0cmluZywgcGVybWl0RnJhY3Rpb25zLCBwZXJtaXROdWxsIH0gPSBPYmplY3QuYXNzaWduKHsgcGVybWl0RW1wdHlTdHJpbmc6IHRydWUsIHBlcm1pdEZyYWN0aW9uczogZmFsc2UsIHBlcm1pdE51bGw6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3Ige0BsaW5rIEpzb25ScGNJZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSlNPTi1SUEMgSUQgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gSUQgaXMgdmFsaWQgcGVyIHRoZSBvcHRpb25zIGdpdmVuIHRvIHRoZVxuICAgICAqIGZhY3RvcnkuXG4gICAgICovXG4gICAgY29uc3QgaXNWYWxpZEpzb25ScGNJZCA9IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbigodHlwZW9mIGlkID09PSAnbnVtYmVyJyAmJiAocGVybWl0RnJhY3Rpb25zIHx8IE51bWJlci5pc0ludGVnZXIoaWQpKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmIChwZXJtaXRFbXB0eVN0cmluZyB8fCBpZC5sZW5ndGggPiAwKSkgfHxcbiAgICAgICAgICAgIChwZXJtaXROdWxsICYmIGlkID09PSBudWxsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gaXNWYWxpZEpzb25ScGNJZDtcbn1cbmV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZ2V0SnNvblJwY0lkVmFsaWRhdG9yO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIEpTT04gc2VyaWFsaXphYmxlIGFuZCBjb3VudHMgdGhlIHRvdGFsIG51bWJlclxuICogb2YgYnl0ZXMgbmVlZGVkIHRvIHN0b3JlIHRoZSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBqc09iamVjdCAtIFBvdGVudGlhbCBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcGFyYW0gc2tpcFNpemluZ1Byb2Nlc3MgLSBTa2lwIEpTT04gc2l6ZSBjYWxjdWxhdGlvbiAoZGVmYXVsdDogZmFsc2UpLlxuICogQHJldHVybnMgVHVwbGUgW2lzVmFsaWQsIHBsYWluVGV4dFNpemVJbkJ5dGVzXSBjb250YWluaW5nIGEgYm9vbGVhbiB0aGF0IHNpZ25hbHMgd2hldGhlclxuICogdGhlIHZhbHVlIHdhcyBzZXJpYWxpemFibGUgYW5kIGEgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaXQgd2lsbCB1c2Ugd2hlbiBzZXJpYWxpemVkIHRvIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSnNvbkFuZEdldFNpemUoanNPYmplY3QsIHNraXBTaXppbmdQcm9jZXNzID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIEpTT04gc2VyaWFsaXphYmxlIGFuZCBjb3VudHMgdGhlIHRvdGFsIG51bWJlclxuICAgICAqIG9mIGJ5dGVzIG5lZWRlZCB0byBzdG9yZSB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgZW5jb2Rpbmcgb2YgdGhlIEpTT04gaXMgZG9uZSBpbiBVVEYtOC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFBvdGVudGlhbCBKU09OIHNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gc2tpcFNpemluZyAtIFNraXAgSlNPTiBzaXplIGNhbGN1bGF0aW9uIChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICogQHJldHVybnMgVHVwbGUgW2lzVmFsaWQsIHBsYWluVGV4dFNpemVJbkJ5dGVzXSBjb250YWluaW5nIGEgYm9vbGVhbiB0aGF0IHNpZ25hbHMgd2hldGhlclxuICAgICAqIHRoZSB2YWx1ZSB3YXMgc2VyaWFsaXphYmxlIGFuZCBhIG51bWJlciBvZiBieXRlcyB0aGF0IGl0IHdpbGwgdXNlIHdoZW4gc2VyaWFsaXplZCB0byBKU09OLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEpzb25TZXJpYWxpemFibGVJbmZvKHZhbHVlLCBza2lwU2l6aW5nKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGFscmVhZHkgc3BlY2lmaWVkIGNvbnN0YW50IHNpemUgZm9yIG51bGwgKHNwZWNpYWwgb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBza2lwU2l6aW5nID8gMCA6IG1pc2NfMS5Kc29uU2l6ZS5OdWxsXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBhbmQgY2FsY3VsYXRlIHNpemVzIGZvciBiYXNpYyAoYW5kIHNvbWUgc3BlY2lhbCkgdHlwZXNcbiAgICAgICAgY29uc3QgdHlwZU9mVmFsdWUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZU9mVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaXppbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoMCwgbWlzY18xLmNhbGN1bGF0ZVN0cmluZ1NpemUpKHZhbHVlKSArIG1pc2NfMS5Kc29uU2l6ZS5RdW90ZSAqIDIsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgdmFsdWUgPT0gdHJ1ZSA/IG1pc2NfMS5Kc29uU2l6ZS5UcnVlIDogbWlzY18xLkpzb25TaXplLkZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVPZlZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgKDAsIG1pc2NfMS5jYWxjdWxhdGVOdW1iZXJTaXplKSh2YWx1ZSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogSW52YWxpZCBkYXRlcyB3aWxsIHNlcmlhbGl6ZSB0byBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlzTmFOKHZhbHVlLmdldERhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbWlzY18xLkpzb25TaXplLk51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWlzY18xLkpzb25TaXplLkRhdGUgKyBtaXNjXzEuSnNvblNpemUuUXVvdGUgKiAyLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG9iamVjdCBpcyBub3QgcGxhaW4gYW5kIGNhbm5vdCBiZSBzZXJpYWxpemVkIHByb3Blcmx5LFxuICAgICAgICAvLyBzdG9wIGhlcmUgYW5kIHJldHVybiBmYWxzZSBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAoISgwLCBtaXNjXzEuaXNQbGFpbk9iamVjdCkodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2lyY3VsYXIgb2JqZWN0IGRldGVjdGlvbiAoaGFuZGxpbmcpXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzYW1lIG9iamVjdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAoc2Vlbk9iamVjdHMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG5ldyBvYmplY3QgdG8gdGhlIHNlZW4gb2JqZWN0cyBzZXRcbiAgICAgICAgLy8gT25seSB0aGUgcGxhaW4gb2JqZWN0cyBzaG91bGQgYmUgYWRkZWQgKFByaW1pdGl2ZSB0eXBlcyBhcmUgc2tpcHBlZClcbiAgICAgICAgc2Vlbk9iamVjdHMuYWRkKHZhbHVlKTtcbiAgICAgICAgLy8gQ29udGludWUgb2JqZWN0IGRlY29tcG9zaXRpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkucmVkdWNlKChzdW0sIFtrZXksIG5lc3RlZFZhbHVlXSwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvY2VzcyBuZXh0IG5lc3RlZCBvYmplY3Qgb3IgcHJpbWl0aXZlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICAgICAgICAgICAgICBsZXQgW3ZhbGlkLCBzaXplXSA9IGdldEpzb25TZXJpYWxpemFibGVJbmZvKG5lc3RlZFZhbHVlLCBza2lwU2l6aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OIHZhbGlkYXRpb24gZGlkIG5vdCBwYXNzLiBWYWxpZGF0aW9uIHByb2Nlc3Mgc3RvcHBlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaXJjdWxhciBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2UgYSBjaGlsZCBub2RlIGlzIHZpc2l0ZWQgYW5kIHByb2Nlc3NlZCByZW1vdmUgaXQgZnJvbSB0aGUgc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBmYWxzZSBwb3NpdGl2ZXMgd2l0aCB0aGUgc2FtZSBhZGphY2VudCBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICBzZWVuT2JqZWN0cy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0cyB3aWxsIGhhdmUgYmUgc2VyaWFsaXplZCB3aXRoIFwia2V5XCI6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZWZvcmUgd2UgaW5jbHVkZSB0aGUga2V5IGluIHRoZSBjYWxjdWxhdGlvbiBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVNpemUgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGtleS5sZW5ndGggKyBtaXNjXzEuSnNvblNpemUuQ29tbWEgKyBtaXNjXzEuSnNvblNpemUuQ29sb24gKiAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBpZHggPCBhcnIubGVuZ3RoIC0gMSA/IG1pc2NfMS5Kc29uU2l6ZS5Db21tYSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyBrZXlTaXplICsgc2l6ZSArIHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTdGFydHMgYXQgMiBiZWNhdXNlIHRoZSBzZXJpYWxpemVkIEpTT04gc3RyaW5nIGRhdGEgKHBsYWluIHRleHQpXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBtaW5pbWFsbHkgY29udGFpbiB7fS9bXVxuICAgICAgICAgICAgICAgIHNraXBTaXppbmcgPyAwIDogbWlzY18xLkpzb25TaXplLldyYXBwZXIgKiAyKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyhqc09iamVjdCwgc2tpcFNpemluZ1Byb2Nlc3MpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUpzb25BbmRHZXRTaXplID0gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGV4cG9ydHMuY3JlYXRlUHJvamVjdExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGdsb2JhbExvZ2dlciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdtZXRhbWFzaycpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZFxuICogdXNpbmcgdGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBCeSBkZWZhdWx0LCBzdWNoIG1lc3NhZ2VzIHdpbGwgYmVcbiAqIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtIGJ5IHNldHRpbmcgdGhlIGBERUJVR2AgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlIHRvIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cyB0aGF0XG4gKiBhcmUgYWxzbyB1c2luZyB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGVpciBsb2dnZXJzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gVGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2ZcbiAqIHlvdXIgTlBNIHBhY2thZ2UgaWYgeW91J3JlIGRldmVsb3Bpbmcgb25lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvamVjdExvZ2dlcihwcm9qZWN0TmFtZSkge1xuICAgIHJldHVybiBnbG9iYWxMb2dnZXIuZXh0ZW5kKHByb2plY3ROYW1lKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvamVjdExvZ2dlciA9IGNyZWF0ZVByb2plY3RMb2dnZXI7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hpY2ggaXMgZGVyaXZlZCBmcm9tIHRoZSBsb2dnZXIgZm9yXG4gKiB0aGUgd2hvbGUgcHJvamVjdCB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWQgdXNpbmcgdGhlIG5hbWUgb2YgeW91clxuICogbW9kdWxlLiBCeSBkZWZhdWx0LCBzdWNoIG1lc3NhZ2VzIHdpbGwgYmUgc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW1cbiAqIGJ5IHNldHRpbmcgdGhlIGBERUJVR2AgZW52aXJvbm1lbnQgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+Ojxtb2R1bGVOYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIHRoZSBwcm9qZWN0LFxuICogb3IgYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMuXG4gKlxuICogQHBhcmFtIHByb2plY3RMb2dnZXIgLSBUaGUgbG9nZ2VyIGNyZWF0ZWQgdmlhIHtAbGluayBjcmVhdGVQcm9qZWN0TG9nZ2VyfS5cbiAqIEBwYXJhbSBtb2R1bGVOYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBtb2R1bGUuIFlvdSBjb3VsZCB1c2UgdGhlIG5hbWUgb2YgdGhlXG4gKiBmaWxlIHdoZXJlIHlvdSdyZSB1c2luZyB0aGlzIGxvZ2dlciBvciBzb21lIG90aGVyIG5hbWUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2R1bGVMb2dnZXIocHJvamVjdExvZ2dlciwgbW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBwcm9qZWN0TG9nZ2VyLmV4dGVuZChtb2R1bGVOYW1lKTtcbn1cbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gY3JlYXRlTW9kdWxlTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vXG4vLyBUeXBlc1xuLy9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGV4cG9ydHMuaXNBU0NJSSA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gZXhwb3J0cy5Kc29uU2l6ZSA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogUHJlZGVmaW5lZCBzaXplcyAoaW4gQnl0ZXMpIG9mIHNwZWNpZmljIHBhcnRzIG9mIEpTT04gc3RydWN0dXJlLlxuICovXG52YXIgSnNvblNpemU7XG4oZnVuY3Rpb24gKEpzb25TaXplKSB7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJOdWxsXCJdID0gNF0gPSBcIk51bGxcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbW1hXCJdID0gMV0gPSBcIkNvbW1hXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJXcmFwcGVyXCJdID0gMV0gPSBcIldyYXBwZXJcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlRydWVcIl0gPSA0XSA9IFwiVHJ1ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRmFsc2VcIl0gPSA1XSA9IFwiRmFsc2VcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlF1b3RlXCJdID0gMV0gPSBcIlF1b3RlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb2xvblwiXSA9IDFdID0gXCJDb2xvblwiO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJEYXRlXCJdID0gMjRdID0gXCJEYXRlXCI7XG59KShKc29uU2l6ZSA9IGV4cG9ydHMuSnNvblNpemUgfHwgKGV4cG9ydHMuSnNvblNpemUgPSB7fSkpO1xuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBwYXR0ZXJuIG1hdGNoaW5nIGZvciAoc3BlY2lhbCkgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IC9cInxcXFxcfFxcbnxcXHJ8XFx0L2d1O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFuIG9iamVjdCBpcyB0aGUgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsXG4gKiBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBwbGFpbiAoZS5nLiBmdW5jdGlvbikuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4vKipcbiAqIENoZWNrIGlmIGNoYXJhY3RlciBpcyBBU0NJSS5cbiAqXG4gKiBAcGFyYW0gY2hhcmFjdGVyIC0gQ2hhcmFjdGVyLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhIGNoYXJhY3RlciBjb2RlIGlzIEFTQ0lJLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUkoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDEyNztcbn1cbmV4cG9ydHMuaXNBU0NJSSA9IGlzQVNDSUk7XG4vKipcbiAqIENhbGN1bGF0ZSBzdHJpbmcgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBzdHJpbmcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN0cmluZ1NpemUodmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICgoX2EgPSB2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBjYWxjdWxhdGVTdHJpbmdTaXplO1xuLyoqXG4gKiBDYWxjdWxhdGUgc2l6ZSBvZiBhIG51bWJlciBvZnRlciBKU09OIHNlcmlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgbnVtYmVyIGluIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU51bWJlclNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBjYWxjdWxhdGVOdW1iZXJTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlzYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGV4VG9CaWdJbnQgPSBleHBvcnRzLmhleFRvTnVtYmVyID0gZXhwb3J0cy5iaWdJbnRUb0hleCA9IGV4cG9ydHMubnVtYmVyVG9IZXggPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBleHBvcnRzLmd0UmFuZ2UgPSBleHBvcnRzLmd0VmVyc2lvbiA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSBleHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIi8vIEV4dHJhY3RlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL2V0aGVyZXVtanMtYWJpIGFuZCBzdHJpcHBlZCBvdXQgaXJyZWxldmFudCBjb2RlXG4vLyBPcmlnaW5hbCBjb2RlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAtIENvcHlyaWdodCAoYykgMjAxNSBBbGV4IEJlcmVnc3phc3ppXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgQk4gPSByZXF1aXJlKCdibi5qcycpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyXG5cbi8vIENvbnZlcnQgZnJvbSBzaG9ydCB0byBjYW5vbmljYWwgbmFtZXNcbi8vIEZJWE1FOiBvcHRpbWlzZSBvciBtYWtlIHRoaXMgbmljZXI/XG5mdW5jdGlvbiBlbGVtZW50YXJ5TmFtZSAobmFtZSkge1xuICBpZiAobmFtZS5zdGFydHNXaXRoKCdpbnRbJykpIHtcbiAgICByZXR1cm4gJ2ludDI1NicgKyBuYW1lLnNsaWNlKDMpXG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2ludCcpIHtcbiAgICByZXR1cm4gJ2ludDI1NidcbiAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VpbnRbJykpIHtcbiAgICByZXR1cm4gJ3VpbnQyNTYnICsgbmFtZS5zbGljZSg0KVxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICd1aW50Jykge1xuICAgIHJldHVybiAndWludDI1NidcbiAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ZpeGVkWycpKSB7XG4gICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnICsgbmFtZS5zbGljZSg1KVxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gJ2ZpeGVkMTI4eDEyOCdcbiAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZFsnKSkge1xuICAgIHJldHVybiAndWZpeGVkMTI4eDEyOCcgKyBuYW1lLnNsaWNlKDYpXG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3VmaXhlZCcpIHtcbiAgICByZXR1cm4gJ3VmaXhlZDEyOHgxMjgnXG4gIH1cbiAgcmV0dXJuIG5hbWVcbn1cblxuLy8gUGFyc2UgTiBmcm9tIHR5cGU8Tj5cbmZ1bmN0aW9uIHBhcnNlVHlwZU4gKHR5cGUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KC9eXFxEKyhcXGQrKSQvLmV4ZWModHlwZSlbMV0sIDEwKVxufVxuXG4vLyBQYXJzZSBOLE0gZnJvbSB0eXBlPE4+eDxNPlxuZnVuY3Rpb24gcGFyc2VUeXBlTnhNICh0eXBlKSB7XG4gIHZhciB0bXAgPSAvXlxcRCsoXFxkKyl4KFxcZCspJC8uZXhlYyh0eXBlKVxuICByZXR1cm4gWyBwYXJzZUludCh0bXBbMV0sIDEwKSwgcGFyc2VJbnQodG1wWzJdLCAxMCkgXVxufVxuXG4vLyBQYXJzZSBOIGluIHR5cGVbPE4+XSB3aGVyZSBcInR5cGVcIiBjYW4gaXRzZWxmIGJlIGFuIGFycmF5IHR5cGUuXG5mdW5jdGlvbiBwYXJzZVR5cGVBcnJheSAodHlwZSkge1xuICB2YXIgdG1wID0gdHlwZS5tYXRjaCgvKC4qKVxcWyguKj8pXFxdJC8pXG4gIGlmICh0bXApIHtcbiAgICByZXR1cm4gdG1wWzJdID09PSAnJyA/ICdkeW5hbWljJyA6IHBhcnNlSW50KHRtcFsyXSwgMTApXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VOdW1iZXIgKGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmdcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHV0aWwuaXNIZXhTdHJpbmcoYXJnKSkge1xuICAgICAgcmV0dXJuIG5ldyBCTih1dGlsLnN0cmlwSGV4UHJlZml4KGFyZyksIDE2KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEJOKGFyZywgMTApXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5ldyBCTihhcmcpXG4gIH0gZWxzZSBpZiAoYXJnLnRvQXJyYXkpIHtcbiAgICAvLyBhc3N1bWUgdGhpcyBpcyBhIEJOIGZvciB0aGUgbW9tZW50LCByZXBsYWNlIHdpdGggQk4uaXNCTiBzb29uXG4gICAgcmV0dXJuIGFyZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgaXMgbm90IGEgbnVtYmVyJylcbiAgfVxufVxuXG4vLyBFbmNvZGVzIGEgc2luZ2xlIGl0ZW0gKGNhbiBiZSBkeW5hbWljIGFycmF5KVxuLy8gQHJldHVybnM6IEJ1ZmZlclxuZnVuY3Rpb24gZW5jb2RlU2luZ2xlICh0eXBlLCBhcmcpIHtcbiAgdmFyIHNpemUsIG51bSwgcmV0LCBpXG5cbiAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQxNjAnLCBwYXJzZU51bWJlcihhcmcpKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQ4JywgYXJnID8gMSA6IDApXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdieXRlcycsIG5ldyBCdWZmZXIoYXJnLCAndXRmOCcpKVxuICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAvLyB0aGlzIHBhcnQgaGFuZGxlcyBmaXhlZC1sZW5ndGggKFsyXSkgYW5kIHZhcmlhYmxlIGxlbmd0aCAoW10pIGFycmF5c1xuICAgIC8vIE5PVEU6IHdlIGNhdGNoIGhlcmUgYWxsIGNhbGxzIHRvIGFycmF5cywgdGhhdCBzaW1wbGlmaWVzIHRoZSByZXN0XG4gICAgaWYgKHR5cGVvZiBhcmcubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gYXJyYXk/JylcbiAgICB9XG4gICAgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpXG4gICAgaWYgKHNpemUgIT09ICdkeW5hbWljJyAmJiBzaXplICE9PSAwICYmIGFyZy5sZW5ndGggPiBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnRzIGV4Y2VlZCBhcnJheSBzaXplOiAnICsgc2l6ZSlcbiAgICB9XG4gICAgcmV0ID0gW11cbiAgICB0eXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhcmcgPSBKU09OLnBhcnNlKGFyZylcbiAgICB9XG4gICAgZm9yIChpIGluIGFyZykge1xuICAgICAgcmV0LnB1c2goZW5jb2RlU2luZ2xlKHR5cGUsIGFyZ1tpXSkpXG4gICAgfVxuICAgIGlmIChzaXplID09PSAnZHluYW1pYycpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBhcmcubGVuZ3RoKVxuICAgICAgcmV0LnVuc2hpZnQobGVuZ3RoKVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgIGFyZyA9IG5ldyBCdWZmZXIoYXJnKVxuXG4gICAgcmV0ID0gQnVmZmVyLmNvbmNhdChbIGVuY29kZVNpbmdsZSgndWludDI1NicsIGFyZy5sZW5ndGgpLCBhcmcgXSlcblxuICAgIGlmICgoYXJnLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChbIHJldCwgdXRpbC56ZXJvcygzMiAtIChhcmcubGVuZ3RoICUgMzIpKSBdKVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlczxOPiB3aWR0aDogJyArIHNpemUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwuc2V0TGVuZ3RoUmlnaHQoYXJnLCAzMilcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXG4gICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1aW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICB9XG5cbiAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcbiAgICB9XG5cbiAgICBpZiAobnVtIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGlzIG5lZ2F0aXZlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXG4gICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQ8Tj4gd2lkdGg6ICcgKyBzaXplKVxuICAgIH1cblxuICAgIG51bSA9IHBhcnNlTnVtYmVyKGFyZylcbiAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bS50b1R3b3MoMjU2KS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWZpeGVkJykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTnhNKHR5cGUpXG5cbiAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpXG5cbiAgICBpZiAobnVtIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1Zml4ZWQgaXMgbmVnYXRpdmUnKVxuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBudW0ubXVsKG5ldyBCTigyKS5wb3cobmV3IEJOKHNpemVbMV0pKSkpXG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdmaXhlZCcpKSB7XG4gICAgc2l6ZSA9IHBhcnNlVHlwZU54TSh0eXBlKVxuXG4gICAgcmV0dXJuIGVuY29kZVNpbmdsZSgnaW50MjU2JywgcGFyc2VOdW1iZXIoYXJnKS5tdWwobmV3IEJOKDIpLnBvdyhuZXcgQk4oc2l6ZVsxXSkpKSlcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiAnICsgdHlwZSlcbn1cblxuLy8gSXMgYSB0eXBlIGR5bmFtaWM/XG5mdW5jdGlvbiBpc0R5bmFtaWMgKHR5cGUpIHtcbiAgLy8gRklYTUU6IGhhbmRsZSBhbGwgdHlwZXM/IEkgZG9uJ3QgdGhpbmsgYW55dGhpbmcgaXMgbWlzc2luZyBub3dcbiAgcmV0dXJuICh0eXBlID09PSAnc3RyaW5nJykgfHwgKHR5cGUgPT09ICdieXRlcycpIHx8IChwYXJzZVR5cGVBcnJheSh0eXBlKSA9PT0gJ2R5bmFtaWMnKVxufVxuXG4vLyBJcyBhIHR5cGUgYW4gYXJyYXk/XG5mdW5jdGlvbiBpc0FycmF5ICh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMVxufVxuXG4vLyBFbmNvZGUgYSBtZXRob2QvZXZlbnQgd2l0aCBhcmd1bWVudHNcbi8vIEB0eXBlcyBhbiBhcnJheSBvZiBzdHJpbmcgdHlwZSBuYW1lc1xuLy8gQGFyZ3MgIGFuIGFycmF5IG9mIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHJhd0VuY29kZSAodHlwZXMsIHZhbHVlcykge1xuICB2YXIgb3V0cHV0ID0gW11cbiAgdmFyIGRhdGEgPSBbXVxuXG4gIHZhciBoZWFkTGVuZ3RoID0gMzIgKiB0eXBlcy5sZW5ndGhcblxuICBmb3IgKHZhciBpIGluIHR5cGVzKSB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50YXJ5TmFtZSh0eXBlc1tpXSlcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV1cbiAgICB2YXIgY3VyID0gZW5jb2RlU2luZ2xlKHR5cGUsIHZhbHVlKVxuXG4gICAgLy8gVXNlIHRoZSBoZWFkL3RhaWwgbWV0aG9kIGZvciBzdG9yaW5nIGR5bmFtaWMgZGF0YVxuICAgIGlmIChpc0R5bmFtaWModHlwZSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGVuY29kZVNpbmdsZSgndWludDI1NicsIGhlYWRMZW5ndGgpKVxuICAgICAgZGF0YS5wdXNoKGN1cilcbiAgICAgIGhlYWRMZW5ndGggKz0gY3VyLmxlbmd0aFxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChjdXIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0cHV0LmNvbmNhdChkYXRhKSlcbn1cblxuZnVuY3Rpb24gc29saWRpdHlQYWNrICh0eXBlcywgdmFsdWVzKSB7XG4gIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiB0eXBlcyBhcmUgbm90IG1hdGNoaW5nIHRoZSB2YWx1ZXMnKVxuICB9XG5cbiAgdmFyIHNpemUsIG51bVxuICB2YXIgcmV0ID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50YXJ5TmFtZSh0eXBlc1tpXSlcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV1cblxuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICByZXQucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQucHVzaChuZXcgQnVmZmVyKHZhbHVlLCAndXRmOCcpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICByZXQucHVzaChuZXcgQnVmZmVyKHZhbHVlID8gJzAxJyA6ICcwMCcsICdoZXgnKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgcmV0LnB1c2godXRpbC5zZXRMZW5ndGgodmFsdWUsIDIwKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcbiAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGVzPE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2godXRpbC5zZXRMZW5ndGhSaWdodCh2YWx1ZSwgc2l6ZSkpXG4gICAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcbiAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1aW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICAgIH1cblxuICAgICAgbnVtID0gcGFyc2VOdW1iZXIodmFsdWUpXG4gICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpXG4gICAgICB9XG5cbiAgICAgIHJldC5wdXNoKG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIHNpemUgLyA4KSlcbiAgICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXG4gICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICAgIH1cblxuICAgICAgbnVtID0gcGFyc2VOdW1iZXIodmFsdWUpXG4gICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIGludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2gobnVtLnRvVHdvcyhzaXplKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIHNpemUgLyA4KSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgYWxsIG90aGVyIHR5cGVzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KVxufVxuXG5mdW5jdGlvbiBzb2xpZGl0eVNIQTMgKHR5cGVzLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHV0aWwua2VjY2FrKHNvbGlkaXR5UGFjayh0eXBlcywgdmFsdWVzKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJhd0VuY29kZSxcbiAgc29saWRpdHlQYWNrLFxuICBzb2xpZGl0eVNIQTNcbn1cbiIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgYWJpID0gcmVxdWlyZSgnLi9hYmknKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyLycpLkJ1ZmZlclxuXG5jb25zdCBUWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICB0eXBlOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcHJpbWFyeVR5cGU6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgZG9tYWluOiB7dHlwZTogJ29iamVjdCd9LFxuICAgIG1lc3NhZ2U6IHt0eXBlOiAnb2JqZWN0J30sXG4gIH0sXG4gIHJlcXVpcmVkOiBbJ3R5cGVzJywgJ3ByaW1hcnlUeXBlJywgJ2RvbWFpbicsICdtZXNzYWdlJ10sXG59XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgZm9yIHNpZ25pbmcgdHlwZWQgZGF0YVxuICovXG5jb25zdCBUeXBlZERhdGFVdGlscyA9IHtcbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGVuY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3RcbiAgICovXG4gIGVuY29kZURhdGEgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ11cbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW3RoaXMuaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKV1cblxuICAgIGlmKHVzZVY0KSB7XG4gICAgICBjb25zdCBlbmNvZGVGaWVsZCA9IChuYW1lLCB0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZXNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCB2YWx1ZSA9PSBudWxsID9cbiAgICAgICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnIDpcbiAgICAgICAgICAgIHV0aWwua2VjY2FrKHRoaXMuZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSwgdHlwZXMsIHVzZVY0KSldXG4gICAgICAgIH1cblxuICAgICAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgZmllbGQgJHtuYW1lfSBvZiB0eXBlICR7dHlwZX1gKVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHV0aWwua2VjY2FrKHZhbHVlKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCB1dGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5sYXN0SW5kZXhPZignXScpID09PSB0eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoaXRlbSA9PlxuICAgICAgICAgICAgZW5jb2RlRmllbGQobmFtZSwgcGFyc2VkVHlwZSwgaXRlbSkpXG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHV0aWwua2VjY2FrKGFiaS5yYXdFbmNvZGUoXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFt0eXBlXSkgPT4gdHlwZSksXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFssIHZhbHVlXSkgPT4gdmFsdWUpLFxuICAgICAgICAgICkpXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0pXG4gICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKHR5cGUpXG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtmaWVsZC5uYW1lXVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCgnYnl0ZXMzMicpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLmtlY2Nhayh2YWx1ZSlcbiAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2ZpZWxkLnR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKGZpZWxkLnR5cGUsIHZhbHVlLCB0eXBlcywgdXNlVjQpKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZS5sYXN0SW5kZXhPZignXScpID09PSBmaWVsZC50eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXlzIGN1cnJlbnRseSB1bmltcGxlbWVudGVkIGluIGVuY29kZURhdGEnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaChmaWVsZC50eXBlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhYmkucmF3RW5jb2RlKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcylcbiAgfSxcblxuICAvKipcbiAgICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gZW5jb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgZW5jb2RlVHlwZSAocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgbGV0IGRlcHMgPSB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcykuZmlsdGVyKGRlcCA9PiBkZXAgIT09IHByaW1hcnlUeXBlKVxuICAgIGRlcHMgPSBbcHJpbWFyeVR5cGVdLmNvbmNhdChkZXBzLnNvcnQoKSlcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGVwcykge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlc1t0eXBlXVxuICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHR5cGUgZGVmaW5pdGlvbiBzcGVjaWZpZWQ6ICcgKyB0eXBlKVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IHR5cGUgKyAnKCcgKyB0eXBlc1t0eXBlXS5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB0eXBlICsgJyAnICsgbmFtZSkuam9pbignLCcpICsgJyknXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIHR5cGVzIHdpdGhpbiBhIHR5cGUgZGVmaW50aW9uIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHRzIC0gY3VycmVudCBzZXQgb2YgYWNjdW11bGF0ZWQgdHlwZXNcbiAgICogQHJldHVybnMge0FycmF5fSAtIFNldCBvZiBhbGwgdHlwZXMgZm91bmQgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxuICAgKi9cbiAgZmluZFR5cGVEZXBlbmRlbmNpZXMgKHByaW1hcnlUeXBlLCB0eXBlcywgcmVzdWx0cyA9IFtdKSB7XG4gICAgcHJpbWFyeVR5cGUgPSBwcmltYXJ5VHlwZS5tYXRjaCgvXlxcdyovKVswXVxuICAgIGlmIChyZXN1bHRzLmluY2x1ZGVzKHByaW1hcnlUeXBlKSB8fCB0eXBlc1twcmltYXJ5VHlwZV0gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gcmVzdWx0cyB9XG4gICAgcmVzdWx0cy5wdXNoKHByaW1hcnlUeXBlKVxuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKSkge1xuICAgICAgICAhcmVzdWx0cy5pbmNsdWRlcyhkZXApICYmIHJlc3VsdHMucHVzaChkZXApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzXG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhc2hlcyBhbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEhhc2ggb2YgYW4gb2JqZWN0XG4gICAqL1xuICBoYXNoU3RydWN0IChwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB1dGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCkpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhc2hlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlIHRvIGhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEhhc2ggb2YgYW4gb2JqZWN0XG4gICAqL1xuICBoYXNoVHlwZSAocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgcmV0dXJuIHV0aWwua2VjY2FrKHRoaXMuZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHByb3BlcnRpZXMgZnJvbSBhIG1lc3NhZ2Ugb2JqZWN0IHRoYXQgYXJlIG5vdCBkZWZpbmVkIHBlciBFSVAtNzEyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdHlwZWQgbWVzc2FnZSBvYmplY3RcbiAgICogQHJldHVybnMge09iamVjdH0gLSB0eXBlZCBtZXNzYWdlIG9iamVjdCB3aXRoIG9ubHkgYWxsb3dlZCBmaWVsZHNcbiAgICovXG4gIHNhbml0aXplRGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IGluIFRZUEVEX01FU1NBR0VfU0NIRU1BLnByb3BlcnRpZXMpIHtcbiAgICAgIGRhdGFba2V5XSAmJiAoc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldKVxuICAgIH1cbiAgICBpZiAoc2FuaXRpemVkRGF0YS50eXBlcykge1xuICAgICAgc2FuaXRpemVkRGF0YS50eXBlcyA9IE9iamVjdC5hc3NpZ24oeyBFSVA3MTJEb21haW46IFtdIH0sIHNhbml0aXplZERhdGEudHlwZXMpXG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWREYXRhXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhhc2ggb2YgYSB0eXBlZCBtZXNzYWdlIGFzIHBlciBFSVAtNzEyIGZvciBzaWduaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZERhdGEgLSBUeXBlcyBtZXNzYWdlIGRhdGEgdG8gc2lnblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHNoYTMgaGFzaCBmb3Igc2lnbmluZ1xuICAgKi9cbiAgaGFzaCAodHlwZWREYXRhLCB1c2VWNCA9IHRydWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gdGhpcy5zYW5pdGl6ZURhdGEodHlwZWREYXRhKVxuICAgIGNvbnN0IHBhcnRzID0gW0J1ZmZlci5mcm9tKCcxOTAxJywgJ2hleCcpXVxuICAgIHBhcnRzLnB1c2godGhpcy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBzYW5pdGl6ZWREYXRhLmRvbWFpbiwgc2FuaXRpemVkRGF0YS50eXBlcywgdXNlVjQpKVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlICE9PSAnRUlQNzEyRG9tYWluJykge1xuICAgICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3Qoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgfVxuICAgIHJldHVybiB1dGlsLmtlY2NhayhCdWZmZXIuY29uY2F0KHBhcnRzKSlcbiAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRZUEVEX01FU1NBR0VfU0NIRU1BLFxuICBUeXBlZERhdGFVdGlscyxcblxuICBoYXNoRm9yU2lnblR5cGVkRGF0YUxlZ2FjeTogZnVuY3Rpb24gKG1zZ1BhcmFtcykge1xuICAgIHJldHVybiB0eXBlZFNpZ25hdHVyZUhhc2hMZWdhY3kobXNnUGFyYW1zLmRhdGEpXG4gIH0sXG5cbiAgaGFzaEZvclNpZ25UeXBlZERhdGFfdjM6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICByZXR1cm4gVHlwZWREYXRhVXRpbHMuaGFzaChtc2dQYXJhbXMuZGF0YSwgZmFsc2UpXG4gIH0sXG5cbiAgaGFzaEZvclNpZ25UeXBlZERhdGFfdjQ6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICByZXR1cm4gVHlwZWREYXRhVXRpbHMuaGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgfSxcbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaExlZ2FjeSh0eXBlZERhdGEpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKVxuICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHwgIXR5cGVkRGF0YS5sZW5ndGgpIHRocm93IGVycm9yXG5cbiAgY29uc3QgZGF0YSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlID09PSAnYnl0ZXMnID8gdXRpbC50b0J1ZmZlcihlLnZhbHVlKSA6IGUudmFsdWVcbiAgfSlcbiAgY29uc3QgdHlwZXMgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnR5cGUgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBlLnR5cGUgKyAnICcgKyBlLm5hbWVcbiAgfSlcblxuICByZXR1cm4gYWJpLnNvbGlkaXR5U0hBMyhcbiAgICBbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLFxuICAgIFtcbiAgICAgIGFiaS5zb2xpZGl0eVNIQTMobmV3IEFycmF5KHR5cGVkRGF0YS5sZW5ndGgpLmZpbGwoJ3N0cmluZycpLCBzY2hlbWEpLFxuICAgICAgYWJpLnNvbGlkaXR5U0hBMyh0eXBlcywgZGF0YSlcbiAgICBdXG4gIClcbn1cbiIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQnVmZmVyID0gd2luZG93LkJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbbnVtYmVyICYgMHgzZmZmZmZmXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIC8vICcwJyAtICc5J1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHtcbiAgICAgIHJldHVybiBjIC0gNDg7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgfSBlbHNlIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgIHJldHVybiBjIC0gNTU7XG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG4gICAgICByZXR1cm4gYyAtIDg3O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdJbnZhbGlkIGNoYXJhY3RlciBpbiAnICsgc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgYiA9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgYiA9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gYztcbiAgICAgIH1cbiAgICAgIGFzc2VydChjID49IDAgJiYgYiA8IG11bCwgJ0ludmFsaWQgY2hhcmFjdGVyJyk7XG4gICAgICByICs9IGI7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1vdmUgKGRlc3QsIHNyYykge1xuICAgIGRlc3Qud29yZHMgPSBzcmMud29yZHM7XG4gICAgZGVzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSBzcmMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSBzcmMucmVkO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gX21vdmUgKGRlc3QpIHtcbiAgICBtb3ZlKGRlc3QsIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIENoZWNrIFN5bWJvbC5mb3IgYmVjYXVzZSBub3QgZXZlcnl3aGVyZSB3aGVyZSBTeW1ib2wgZGVmaW5lZFxuICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgQk4ucHJvdG90eXBlW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gaW5zcGVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kcm4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYsIDIpO1xuICB9O1xuXG4gIGlmIChCdWZmZXIpIHtcbiAgICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZSAoQXJyYXlUeXBlLCBzaXplKSB7XG4gICAgaWYgKEFycmF5VHlwZS5hbGxvY1Vuc2FmZSkge1xuICAgICAgcmV0dXJuIEFycmF5VHlwZS5hbGxvY1Vuc2FmZShzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoc2l6ZSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdmFyIHJlcyA9IGFsbG9jYXRlKEFycmF5VHlwZSwgcmVxTGVuZ3RoKTtcbiAgICB2YXIgcG9zdGZpeCA9IGVuZGlhbiA9PT0gJ2xlJyA/ICdMRScgOiAnQkUnO1xuICAgIHRoaXNbJ190b0FycmF5TGlrZScgKyBwb3N0Zml4XShyZXMsIGJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlTEUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24rK10gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VCRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUJFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSByZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gPj4+IHdiaXQpICYgMHgwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICAvLyBUZW1wb3JhcnkgZGlzYWJsZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL2lzc3Vlcy8yMTFcbiAgICAvLyB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgLy8gcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gICAgcmV0dXJuIGJpZ011bFRvKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDw9IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5fc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuX3N0cmlwKCk7XG4gICAgfVxuICAgIGEuX3N0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IChyMiA9PT0gMSAmJiBjbXAgPT09IDApKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RybiA9IGZ1bmN0aW9uIG1vZHJuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IC1hY2MgOiBhY2M7XG4gIH07XG5cbiAgLy8gV0FSTklORzogREVQUkVDQVRFRFxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLm1vZHJuKG51bSk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIuc3RyaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjQgaW5zdGFuY2VcbiAgICAgICAgci5zdHJpcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICBtb3ZlKGEsIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsIi8qKlxuICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cbiAqXG4gKiBAdmVyc2lvbiAwLjguMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJTlBVVF9FUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgRklOQUxJWkVfRVJST1IgPSAnZmluYWxpemUgYWxyZWFkeSBjYWxsZWQnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTNfTk9fV0lORE9XKSB7XG4gICAgV0lORE9XID0gZmFsc2U7XG4gIH1cbiAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuICBpZiAoTk9ERV9KUykge1xuICAgIHJvb3QgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoV0VCX1dPUktFUikge1xuICAgIHJvb3QgPSBzZWxmO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5KU19TSEEzX05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuICB2YXIgU0hBS0VfUEFERElORyA9IFszMSwgNzkzNiwgMjAzMTYxNiwgNTIwMDkzNjk2XTtcbiAgdmFyIENTSEFLRV9QQURESU5HID0gWzQsIDEwMjQsIDI2MjE0NCwgNjcxMDg4NjRdO1xuICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xuICB2YXIgUEFERElORyA9IFs2LCAxNTM2LCAzOTMyMTYsIDEwMDY2MzI5Nl07XG4gIHZhciBTSElGVCA9IFswLCA4LCAxNiwgMjRdO1xuICB2YXIgUkMgPSBbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSxcbiAgICAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsXG4gICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXG4gICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXG4gICAgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xuICB2YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xuICB2YXIgU0hBS0VfQklUUyA9IFsxMjgsIDI1Nl07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdidWZmZXInLCAnYXJyYXlCdWZmZXInLCAnYXJyYXknLCAnZGlnZXN0J107XG4gIHZhciBDU0hBS0VfQllURVBBRCA9IHtcbiAgICAnMTI4JzogMTY4LFxuICAgICcyNTYnOiAxMzZcbiAgfTtcblxuICBpZiAocm9vdC5KU19TSEEzX05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcgfHwgIUFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmJ1ZmZlciAmJiBvYmouYnVmZmVyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2NzaGFrZScgKyBiaXRzXS51cGRhdGUobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2ttYWMnICsgYml0c10udXBkYXRlKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZCwgY3JlYXRlTWV0aG9kLCBiaXRzLCBwYWRkaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlTWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAob3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlU2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICBpZiAoIW4gJiYgIXMpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHNbJ3NoYWtlJyArIGJpdHNdLmNyZWF0ZShvdXRwdXRCaXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoW24sIHNdLCB3KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cywgbiwgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdO1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG5ldyBLbWFjKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoWydLTUFDJywgc10sIHcpLmJ5dGVwYWQoW2tleV0sIHcpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UsIG91dHB1dEJpdHMsIHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKGtleSwgb3V0cHV0Qml0cywgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtcyA9IFtcbiAgICB7IG5hbWU6ICdrZWNjYWsnLCBwYWRkaW5nOiBLRUNDQUtfUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGEzJywgcGFkZGluZzogUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdjc2hha2UnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVDc2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdrbWFjJywgcGFkZGluZzogQ1NIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlS21hY01ldGhvZCB9XG4gIF07XG5cbiAgdmFyIG1ldGhvZHMgPSB7fSwgbWV0aG9kTmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZ29yaXRobXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tpXTtcbiAgICB2YXIgYml0cyA9IGFsZ29yaXRobS5iaXRzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYml0cy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArICdfJyArIGJpdHNbal07XG4gICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGFsZ29yaXRobS5jcmVhdGVNZXRob2QoYml0c1tqXSwgYWxnb3JpdGhtLnBhZGRpbmcpO1xuICAgICAgaWYgKGFsZ29yaXRobS5uYW1lICE9PSAnc2hhMycpIHtcbiAgICAgICAgdmFyIG5ld01ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArIGJpdHNbal07XG4gICAgICAgIG1ldGhvZE5hbWVzLnB1c2gobmV3TWV0aG9kTmFtZSk7XG4gICAgICAgIG1ldGhvZHNbbmV3TWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICB0aGlzLnMgPSBbXTtcbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIHRoaXMub3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XG4gICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJsb2NrID0gMDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gdGhpcy5ibG9ja0NvdW50IDw8IDI7XG4gICAgdGhpcy5vdXRwdXRCbG9ja3MgPSBvdXRwdXRCaXRzID4+IDU7XG4gICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkge1xuICAgICAgdGhpcy5zW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRklOQUxJWkVfRVJST1IpO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsXG4gICAgICBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBpbmRleCA9IDAsIHMgPSB0aGlzLnMsIGksIGNvZGU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLnJlc2V0KSB7XG4gICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgZihzKTtcbiAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoeCwgcmlnaHQpIHtcbiAgICB2YXIgbyA9IHggJiAyNTUsIG4gPSAxO1xuICAgIHZhciBieXRlcyA9IFtvXTtcbiAgICB4ID0geCA+PiA4O1xuICAgIG8gPSB4ICYgMjU1O1xuICAgIHdoaWxlIChvID4gMCkge1xuICAgICAgYnl0ZXMudW5zaGlmdChvKTtcbiAgICAgIHggPSB4ID4+IDg7XG4gICAgICBvID0geCAmIDI1NTtcbiAgICAgICsrbjtcbiAgICB9XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICBieXRlcy5wdXNoKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG4pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzLmxlbmd0aDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIHN0cjtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgc3RyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHN0ciA9IG5ldyBVaW50OEFycmF5KHN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc3RyKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYnl0ZXMgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgIGJ5dGVzID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICBieXRlcyArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpKTtcbiAgICAgICAgICBieXRlcyArPSA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlKGJ5dGVzICogOCk7XG4gICAgdGhpcy51cGRhdGUoc3RyKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5ieXRlcGFkID0gZnVuY3Rpb24gKHN0cnMsIHcpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmVuY29kZSh3KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlU3RyaW5nKHN0cnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcGFkZGluZ0J5dGVzID0gdyAtIGJ5dGVzICUgdztcbiAgICB2YXIgemVyb3MgPSBbXTtcbiAgICB6ZXJvcy5sZW5ndGggPSBwYWRkaW5nQnl0ZXM7XG4gICAgdGhpcy51cGRhdGUoemVyb3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnM7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gdGhpcy5wYWRkaW5nW2kgJiAzXTtcbiAgICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgYmxvY2tzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xuICAgIH1cbiAgICBmKHMpO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUudG9TdHJpbmcgPSBLZWNjYWsucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGhleCA9ICcnLCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAyNCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgICBpID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXTtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5vdXRwdXRCaXRzID4+IDM7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKChvdXRwdXRCbG9ja3MgKyAxKSA8PCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICAgIGFycmF5W2pdID0gc1tpXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYXJyYXlbaV0gPSBzW2ldO1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5kaWdlc3QgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSAoYmxvY2sgPj4gMjQpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xuICAgIEtlY2Nhay5jYWxsKHRoaXMsIGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpO1xuICB9XG5cbiAgS21hYy5wcm90b3R5cGUgPSBuZXcgS2VjY2FrKCk7XG5cbiAgS21hYy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmNvZGUodGhpcy5vdXRwdXRCaXRzLCB0cnVlKTtcbiAgICByZXR1cm4gS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHZhciBmID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksXG4gICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXG4gICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXG4gICAgICBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XG4gICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcbiAgICAgIGMwID0gc1swXSBeIHNbMTBdIF4gc1syMF0gXiBzWzMwXSBeIHNbNDBdO1xuICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XG4gICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcbiAgICAgIGMzID0gc1szXSBeIHNbMTNdIF4gc1syM10gXiBzWzMzXSBeIHNbNDNdO1xuICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XG4gICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcbiAgICAgIGM2ID0gc1s2XSBeIHNbMTZdIF4gc1syNl0gXiBzWzM2XSBeIHNbNDZdO1xuICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XG4gICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcbiAgICAgIGM5ID0gc1s5XSBeIHNbMTldIF4gc1syOV0gXiBzWzM5XSBeIHNbNDldO1xuXG4gICAgICBoID0gYzggXiAoKGMyIDw8IDEpIHwgKGMzID4+PiAzMSkpO1xuICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcbiAgICAgIHNbMF0gXj0gaDtcbiAgICAgIHNbMV0gXj0gbDtcbiAgICAgIHNbMTBdIF49IGg7XG4gICAgICBzWzExXSBePSBsO1xuICAgICAgc1syMF0gXj0gaDtcbiAgICAgIHNbMjFdIF49IGw7XG4gICAgICBzWzMwXSBePSBoO1xuICAgICAgc1szMV0gXj0gbDtcbiAgICAgIHNbNDBdIF49IGg7XG4gICAgICBzWzQxXSBePSBsO1xuICAgICAgaCA9IGMwIF4gKChjNCA8PCAxKSB8IChjNSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XG4gICAgICBzWzJdIF49IGg7XG4gICAgICBzWzNdIF49IGw7XG4gICAgICBzWzEyXSBePSBoO1xuICAgICAgc1sxM10gXj0gbDtcbiAgICAgIHNbMjJdIF49IGg7XG4gICAgICBzWzIzXSBePSBsO1xuICAgICAgc1szMl0gXj0gaDtcbiAgICAgIHNbMzNdIF49IGw7XG4gICAgICBzWzQyXSBePSBoO1xuICAgICAgc1s0M10gXj0gbDtcbiAgICAgIGggPSBjMiBeICgoYzYgPDwgMSkgfCAoYzcgPj4+IDMxKSk7XG4gICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xuICAgICAgc1s0XSBePSBoO1xuICAgICAgc1s1XSBePSBsO1xuICAgICAgc1sxNF0gXj0gaDtcbiAgICAgIHNbMTVdIF49IGw7XG4gICAgICBzWzI0XSBePSBoO1xuICAgICAgc1syNV0gXj0gbDtcbiAgICAgIHNbMzRdIF49IGg7XG4gICAgICBzWzM1XSBePSBsO1xuICAgICAgc1s0NF0gXj0gaDtcbiAgICAgIHNbNDVdIF49IGw7XG4gICAgICBoID0gYzQgXiAoKGM4IDw8IDEpIHwgKGM5ID4+PiAzMSkpO1xuICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcbiAgICAgIHNbNl0gXj0gaDtcbiAgICAgIHNbN10gXj0gbDtcbiAgICAgIHNbMTZdIF49IGg7XG4gICAgICBzWzE3XSBePSBsO1xuICAgICAgc1syNl0gXj0gaDtcbiAgICAgIHNbMjddIF49IGw7XG4gICAgICBzWzM2XSBePSBoO1xuICAgICAgc1szN10gXj0gbDtcbiAgICAgIHNbNDZdIF49IGg7XG4gICAgICBzWzQ3XSBePSBsO1xuICAgICAgaCA9IGM2IF4gKChjMCA8PCAxKSB8IChjMSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XG4gICAgICBzWzhdIF49IGg7XG4gICAgICBzWzldIF49IGw7XG4gICAgICBzWzE4XSBePSBoO1xuICAgICAgc1sxOV0gXj0gbDtcbiAgICAgIHNbMjhdIF49IGg7XG4gICAgICBzWzI5XSBePSBsO1xuICAgICAgc1szOF0gXj0gaDtcbiAgICAgIHNbMzldIF49IGw7XG4gICAgICBzWzQ4XSBePSBoO1xuICAgICAgc1s0OV0gXj0gbDtcblxuICAgICAgYjAgPSBzWzBdO1xuICAgICAgYjEgPSBzWzFdO1xuICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XG4gICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTtcbiAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpO1xuICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XG4gICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTtcbiAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpO1xuICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xuICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpO1xuICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpO1xuICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xuICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7XG4gICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTtcbiAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcbiAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTtcbiAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTtcbiAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcbiAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApO1xuICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7XG4gICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XG4gICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7XG4gICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTtcbiAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xuICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7XG4gICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTtcbiAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcbiAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTtcbiAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpO1xuICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XG4gICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7XG4gICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7XG4gICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcbiAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpO1xuICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7XG4gICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcbiAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpO1xuICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7XG4gICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcbiAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpO1xuICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpO1xuICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xuICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpO1xuICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpO1xuICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XG4gICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTtcbiAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpO1xuICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XG4gICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTtcbiAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpO1xuXG4gICAgICBzWzBdID0gYjAgXiAofmIyICYgYjQpO1xuICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcbiAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xuICAgICAgc1sxMV0gPSBiMTEgXiAofmIxMyAmIGIxNSk7XG4gICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcbiAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xuICAgICAgc1szMF0gPSBiMzAgXiAofmIzMiAmIGIzNCk7XG4gICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcbiAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xuICAgICAgc1s0MV0gPSBiNDEgXiAofmI0MyAmIGI0NSk7XG4gICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xuICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcbiAgICAgIHNbMTJdID0gYjEyIF4gKH5iMTQgJiBiMTYpO1xuICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XG4gICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcbiAgICAgIHNbMjNdID0gYjIzIF4gKH5iMjUgJiBiMjcpO1xuICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XG4gICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcbiAgICAgIHNbNDJdID0gYjQyIF4gKH5iNDQgJiBiNDYpO1xuICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XG4gICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xuICAgICAgc1s1XSA9IGI1IF4gKH5iNyAmIGI5KTtcbiAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xuICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XG4gICAgICBzWzI0XSA9IGIyNCBeICh+YjI2ICYgYjI4KTtcbiAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xuICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XG4gICAgICBzWzM1XSA9IGIzNSBeICh+YjM3ICYgYjM5KTtcbiAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xuICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XG4gICAgICBzWzZdID0gYjYgXiAofmI4ICYgYjApO1xuICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcbiAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xuICAgICAgc1sxN10gPSBiMTcgXiAofmIxOSAmIGIxMSk7XG4gICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcbiAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xuICAgICAgc1szNl0gPSBiMzYgXiAofmIzOCAmIGIzMCk7XG4gICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcbiAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xuICAgICAgc1s0N10gPSBiNDcgXiAofmI0OSAmIGI0MSk7XG4gICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xuICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcbiAgICAgIHNbMThdID0gYjE4IF4gKH5iMTAgJiBiMTIpO1xuICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XG4gICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcbiAgICAgIHNbMjldID0gYjI5IF4gKH5iMjEgJiBiMjMpO1xuICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XG4gICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcbiAgICAgIHNbNDhdID0gYjQ4IF4gKH5iNDAgJiBiNDIpO1xuICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XG5cbiAgICAgIHNbMF0gXj0gUkNbbl07XG4gICAgICBzWzFdIF49IFJDW24gKyAxXTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJvb3RbbWV0aG9kTmFtZXNbaV1dID0gbWV0aG9kc1ttZXRob2ROYW1lc1tpXV07XG4gICAgfVxuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIiwiLy8gRXh0cmFjdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvZXRoZXJldW1qcy11dGlsIGFuZCBzdHJpcHBlZCBvdXQgaXJyZWxldmFudCBjb2RlXG4vLyBPcmlnaW5hbCBjb2RlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIFZlcnNpb24gMi4wXG5cbmNvbnN0IEJOID0gcmVxdWlyZSgnYm4uanMnKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyLycpLkJ1ZmZlclxuY29uc3Qga2VjY2FrMjU2ID0gcmVxdWlyZSgnanMtc2hhMycpLmtlY2NhazI1NlxuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHNcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiB6ZXJvcyAoYnl0ZXMpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKVxufVxuXG4vKipcbiAqIExlZnQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAbWV0aG9kIHNldExlbmd0aFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JpZ2h0PWZhbHNlXSB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5mdW5jdGlvbiBzZXRMZW5ndGggKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICBjb25zdCBidWYgPSB6ZXJvcyhsZW5ndGgpXG4gIG1zZyA9IHRvQnVmZmVyKG1zZylcbiAgaWYgKHJpZ2h0KSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1ZilcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aClcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKVxuICB9XG59XG5cbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5mdW5jdGlvbiBzZXRMZW5ndGhSaWdodCAobXNnLCBsZW5ndGgpIHtcbiAgcmV0dXJuIHNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSlcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0cyBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHsqfSB2IHRoZSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0J1ZmZlciAodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2ID0gQnVmZmVyLmZyb20odilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbShwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICB2ID0gaW50VG9CdWZmZXIodilcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gICAgfSBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpXG4gICAgfSBlbHNlIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdlxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBidWZmZXJUb0hleCAoYnVmKSB7XG4gIGJ1ZiA9IHRvQnVmZmVyKGJ1ZilcbiAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24ga2VjY2FrIChhKSB7XG4gIGEgPSB0b0J1ZmZlcihhKVxuICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrMjU2KGEpLCAnaGV4Jylcbn1cblxuZnVuY3Rpb24gcGFkVG9FdmVuIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGggJSAyID8gJzAnICsgc3RyIDogc3RyXG59XG5cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIHN0ci5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pXG59XG5cbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4IChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIHN0ci5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgyKVxuICB9XG4gIHJldHVybiBzdHJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHplcm9zLFxuICBzZXRMZW5ndGgsXG4gIHNldExlbmd0aFJpZ2h0LFxuICBpc0hleFN0cmluZyxcbiAgc3RyaXBIZXhQcmVmaXgsXG4gIHRvQnVmZmVyLFxuICBidWZmZXJUb0hleCxcbiAga2VjY2FrXG59XG4iLCJjb25zdCBCYXNlRmlsdGVyID0gcmVxdWlyZSgnLi9iYXNlLWZpbHRlcicpXG5cbi8vIHRyYWNrcyBhbGwgcmVzdWx0cyBldmVyIHJlY29yZGVkXG5jbGFzcyBCYXNlRmlsdGVyV2l0aEhpc3RvcnkgZXh0ZW5kcyBCYXNlRmlsdGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuYWxsUmVzdWx0cyA9IFtdXG4gIH1cblxuICBhc3luYyB1cGRhdGUgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFzZUZpbHRlcldpdGhIaXN0b3J5IC0gbm8gdXBkYXRlIG1ldGhvZCBzcGVjaWZpZWQnKVxuICB9XG5cbiAgYWRkUmVzdWx0cyAobmV3UmVzdWx0cykge1xuICAgIHRoaXMuYWxsUmVzdWx0cyA9IHRoaXMuYWxsUmVzdWx0cy5jb25jYXQobmV3UmVzdWx0cylcbiAgICBzdXBlci5hZGRSZXN1bHRzKG5ld1Jlc3VsdHMpXG4gIH1cblxuICBhZGRJbml0aWFsUmVzdWx0cyAobmV3UmVzdWx0cykge1xuICAgIHRoaXMuYWxsUmVzdWx0cyA9IHRoaXMuYWxsUmVzdWx0cy5jb25jYXQobmV3UmVzdWx0cylcbiAgICBzdXBlci5hZGRJbml0aWFsUmVzdWx0cyhuZXdSZXN1bHRzKVxuICB9XG5cbiAgZ2V0QWxsUmVzdWx0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsUmVzdWx0c1xuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyV2l0aEhpc3RvcnkiLCJjb25zdCBTYWZlRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlcicpLmRlZmF1bHRcblxuY2xhc3MgQmFzZUZpbHRlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy51cGRhdGVzID0gW11cbiAgfVxuXG4gIGFzeW5jIGluaXRpYWxpemUgKCkge31cblxuICBhc3luYyB1cGRhdGUgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFzZUZpbHRlciAtIG5vIHVwZGF0ZSBtZXRob2Qgc3BlY2lmaWVkJylcbiAgfVxuXG4gIGFkZFJlc3VsdHMgKG5ld1Jlc3VsdHMpIHtcbiAgICB0aGlzLnVwZGF0ZXMgPSB0aGlzLnVwZGF0ZXMuY29uY2F0KG5ld1Jlc3VsdHMpXG4gICAgbmV3UmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB0aGlzLmVtaXQoJ3VwZGF0ZScsIHJlc3VsdCkpXG4gIH1cblxuICBhZGRJbml0aWFsUmVzdWx0cyAobmV3UmVzdWx0cykge31cblxuICBnZXRDaGFuZ2VzQW5kQ2xlYXIgKCkge1xuICAgIGNvbnN0IHVwZGF0ZXMgPSB0aGlzLnVwZGF0ZXNcbiAgICB0aGlzLnVwZGF0ZXMgPSBbXVxuICAgIHJldHVybiB1cGRhdGVzXG4gIH1cbiAgXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZUZpbHRlclxuIiwiY29uc3QgQmFzZUZpbHRlciA9IHJlcXVpcmUoJy4vYmFzZS1maWx0ZXInKVxuY29uc3QgZ2V0QmxvY2tzRm9yUmFuZ2UgPSByZXF1aXJlKCcuL2dldEJsb2Nrc0ZvclJhbmdlJylcbmNvbnN0IHsgaW5jcmVtZW50SGV4SW50IH0gPSByZXF1aXJlKCcuL2hleFV0aWxzJylcblxuY2xhc3MgQmxvY2tGaWx0ZXIgZXh0ZW5kcyBCYXNlRmlsdGVyIHtcblxuICBjb25zdHJ1Y3RvciAoeyBwcm92aWRlciwgcGFyYW1zIH0pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0gJ2Jsb2NrJ1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlclxuICB9XG5cbiAgYXN5bmMgdXBkYXRlICh7IG9sZEJsb2NrLCBuZXdCbG9jayB9KSB7XG4gICAgY29uc3QgdG9CbG9jayA9IG5ld0Jsb2NrXG4gICAgY29uc3QgZnJvbUJsb2NrID0gaW5jcmVtZW50SGV4SW50KG9sZEJsb2NrKVxuICAgIGNvbnN0IGJsb2NrQm9kaWVzID0gYXdhaXQgZ2V0QmxvY2tzRm9yUmFuZ2UoeyBwcm92aWRlcjogdGhpcy5wcm92aWRlciwgZnJvbUJsb2NrLCB0b0Jsb2NrIH0pXG4gICAgY29uc3QgYmxvY2tIYXNoZXMgPSBibG9ja0JvZGllcy5tYXAoKGJsb2NrKSA9PiBibG9jay5oYXNoKVxuICAgIHRoaXMuYWRkUmVzdWx0cyhibG9ja0hhc2hlcylcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2tGaWx0ZXJcbiIsIm1vZHVsZS5leHBvcnRzID0gZ2V0QmxvY2tzRm9yUmFuZ2VcblxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvY2tzRm9yUmFuZ2UoeyBwcm92aWRlciwgZnJvbUJsb2NrLCB0b0Jsb2NrIH0pIHtcbiAgaWYgKCFmcm9tQmxvY2spIGZyb21CbG9jayA9IHRvQmxvY2tcblxuICBjb25zdCBmcm9tQmxvY2tOdW1iZXIgPSBoZXhUb0ludChmcm9tQmxvY2spXG4gIGNvbnN0IHRvQmxvY2tOdW1iZXIgPSBoZXhUb0ludCh0b0Jsb2NrKVxuICBjb25zdCBibG9ja0NvdW50VG9RdWVyeSA9IHRvQmxvY2tOdW1iZXIgLSBmcm9tQmxvY2tOdW1iZXIgKyAxXG4gIC8vIGxvYWQgYWxsIGJsb2NrcyBmcm9tIG9sZCB0byBuZXcgKGluY2x1c2l2ZSlcbiAgY29uc3QgbWlzc2luZ0Jsb2NrTnVtYmVycyA9IEFycmF5KGJsb2NrQ291bnRUb1F1ZXJ5KS5maWxsKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKF8saW5kZXgpID0+IGZyb21CbG9ja051bWJlciArIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChpbnRUb0hleClcbiAgbGV0IGJsb2NrQm9kaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbWlzc2luZ0Jsb2NrTnVtYmVycy5tYXAoYmxvY2tOdW0gPT4gcXVlcnkocHJvdmlkZXIsICdldGhfZ2V0QmxvY2tCeU51bWJlcicsIFtibG9ja051bSwgZmFsc2VdKSlcbiAgKVxuICBibG9ja0JvZGllcyA9IGJsb2NrQm9kaWVzLmZpbHRlcihibG9jayA9PiBibG9jayAhPT0gbnVsbCk7XG4gIHJldHVybiBibG9ja0JvZGllc1xufVxuXG5mdW5jdGlvbiBoZXhUb0ludChoZXhTdHJpbmcpIHtcbiAgaWYgKGhleFN0cmluZyA9PT0gdW5kZWZpbmVkIHx8IGhleFN0cmluZyA9PT0gbnVsbCkgcmV0dXJuIGhleFN0cmluZ1xuICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGhleFN0cmluZywgMTYpXG59XG5cbmZ1bmN0aW9uIGluY3JlbWVudEhleEludChoZXhTdHJpbmcpe1xuICBpZiAoaGV4U3RyaW5nID09PSB1bmRlZmluZWQgfHwgaGV4U3RyaW5nID09PSBudWxsKSByZXR1cm4gaGV4U3RyaW5nXG4gIGNvbnN0IHZhbHVlID0gaGV4VG9JbnQoaGV4U3RyaW5nKVxuICByZXR1cm4gaW50VG9IZXgodmFsdWUgKyAxKVxufVxuXG5mdW5jdGlvbiBpbnRUb0hleChpbnQpIHtcbiAgaWYgKGludCA9PT0gdW5kZWZpbmVkIHx8IGludCA9PT0gbnVsbCkgcmV0dXJuIGludFxuICBjb25zdCBoZXhTdHJpbmcgPSBpbnQudG9TdHJpbmcoMTYpXG4gIHJldHVybiAnMHgnICsgaGV4U3RyaW5nXG59XG5cbmZ1bmN0aW9uIHNlbmRBc3luYyhwcm92aWRlciwgcmVxdWVzdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHByb3ZpZGVyLnNlbmRBc3luYyhyZXF1ZXN0LCAoZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJSZXN1bHQgd2FzIGVtcHR5XCIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KHByb3ZpZGVyLCBtZXRob2QsIHBhcmFtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc2VuZEFzeW5jKHByb3ZpZGVyLCB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgcHJvdmlkZXIuc2VuZEFzeW5jIGZhaWxlZDogJHtlcnJvci5zdGFjayB8fCBlcnJvci5tZXNzYWdlIHx8IGVycm9yfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWluQmxvY2tSZWYsXG4gIG1heEJsb2NrUmVmLFxuICBzb3J0QmxvY2tSZWZzLFxuICBiblRvSGV4LFxuICBibG9ja1JlZklzTnVtYmVyLFxuICBoZXhUb0ludCxcbiAgaW5jcmVtZW50SGV4SW50LFxuICBpbnRUb0hleCxcbiAgdW5zYWZlUmFuZG9tQnl0ZXMsXG59XG5cbmZ1bmN0aW9uIG1pbkJsb2NrUmVmKC4uLnJlZnMpIHtcbiAgY29uc3Qgc29ydGVkUmVmcyA9IHNvcnRCbG9ja1JlZnMocmVmcylcbiAgcmV0dXJuIHNvcnRlZFJlZnNbMF1cbn1cblxuZnVuY3Rpb24gbWF4QmxvY2tSZWYoLi4ucmVmcykge1xuICBjb25zdCBzb3J0ZWRSZWZzID0gc29ydEJsb2NrUmVmcyhyZWZzKVxuICByZXR1cm4gc29ydGVkUmVmc1tzb3J0ZWRSZWZzLmxlbmd0aC0xXVxufVxuXG5mdW5jdGlvbiBzb3J0QmxvY2tSZWZzKHJlZnMpIHtcbiAgcmV0dXJuIHJlZnMuc29ydCgocmVmQSwgcmVmQikgPT4ge1xuICAgIGlmIChyZWZBID09PSAnbGF0ZXN0JyB8fCByZWZCID09PSAnZWFybGllc3QnKSByZXR1cm4gMVxuICAgIGlmIChyZWZCID09PSAnbGF0ZXN0JyB8fCByZWZBID09PSAnZWFybGllc3QnKSByZXR1cm4gLTFcbiAgICByZXR1cm4gaGV4VG9JbnQocmVmQSkgLSBoZXhUb0ludChyZWZCKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiblRvSGV4KGJuKSB7XG4gIHJldHVybiAnMHgnICsgYm4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIGJsb2NrUmVmSXNOdW1iZXIoYmxvY2tSZWYpe1xuICByZXR1cm4gYmxvY2tSZWYgJiYgIVsnZWFybGllc3QnLCAnbGF0ZXN0JywgJ3BlbmRpbmcnXS5pbmNsdWRlcyhibG9ja1JlZilcbn1cblxuZnVuY3Rpb24gaGV4VG9JbnQoaGV4U3RyaW5nKSB7XG4gIGlmIChoZXhTdHJpbmcgPT09IHVuZGVmaW5lZCB8fCBoZXhTdHJpbmcgPT09IG51bGwpIHJldHVybiBoZXhTdHJpbmdcbiAgcmV0dXJuIE51bWJlci5wYXJzZUludChoZXhTdHJpbmcsIDE2KVxufVxuXG5mdW5jdGlvbiBpbmNyZW1lbnRIZXhJbnQoaGV4U3RyaW5nKXtcbiAgaWYgKGhleFN0cmluZyA9PT0gdW5kZWZpbmVkIHx8IGhleFN0cmluZyA9PT0gbnVsbCkgcmV0dXJuIGhleFN0cmluZ1xuICBjb25zdCB2YWx1ZSA9IGhleFRvSW50KGhleFN0cmluZylcbiAgcmV0dXJuIGludFRvSGV4KHZhbHVlICsgMSlcbn1cblxuZnVuY3Rpb24gaW50VG9IZXgoaW50KSB7XG4gIGlmIChpbnQgPT09IHVuZGVmaW5lZCB8fCBpbnQgPT09IG51bGwpIHJldHVybiBpbnRcbiAgbGV0IGhleFN0cmluZyA9IGludC50b1N0cmluZygxNilcbiAgY29uc3QgbmVlZHNMZWZ0UGFkID0gaGV4U3RyaW5nLmxlbmd0aCAlIDJcbiAgaWYgKG5lZWRzTGVmdFBhZCkgaGV4U3RyaW5nID0gJzAnICsgaGV4U3RyaW5nXG4gIHJldHVybiAnMHgnICsgaGV4U3RyaW5nXG59XG5cbmZ1bmN0aW9uIHVuc2FmZVJhbmRvbUJ5dGVzKGJ5dGVDb3VudCkge1xuICBsZXQgcmVzdWx0ID0gJzB4J1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVDb3VudDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IHVuc2FmZVJhbmRvbU5pYmJsZSgpXG4gICAgcmVzdWx0ICs9IHVuc2FmZVJhbmRvbU5pYmJsZSgpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiB1bnNhZmVSYW5kb21OaWJibGUoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNikudG9TdHJpbmcoMTYpXG59XG4iLCJjb25zdCBNdXRleCA9IHJlcXVpcmUoJ2FzeW5jLW11dGV4JykuTXV0ZXhcbmNvbnN0IHsgY3JlYXRlQXN5bmNNaWRkbGV3YXJlLCBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUgfSA9IHJlcXVpcmUoJ2pzb24tcnBjLWVuZ2luZScpXG5jb25zdCBMb2dGaWx0ZXIgPSByZXF1aXJlKCcuL2xvZy1maWx0ZXIuanMnKVxuY29uc3QgQmxvY2tGaWx0ZXIgPSByZXF1aXJlKCcuL2Jsb2NrLWZpbHRlci5qcycpXG5jb25zdCBUeEZpbHRlciA9IHJlcXVpcmUoJy4vdHgtZmlsdGVyLmpzJylcbmNvbnN0IHsgaW50VG9IZXgsIGhleFRvSW50IH0gPSByZXF1aXJlKCcuL2hleFV0aWxzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFdGhGaWx0ZXJNaWRkbGV3YXJlXG5cbmZ1bmN0aW9uIGNyZWF0ZUV0aEZpbHRlck1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0pIHtcblxuICAvLyBjcmVhdGUgZmlsdGVyIGNvbGxlY3Rpb25cbiAgbGV0IGZpbHRlckluZGV4ID0gMFxuICBsZXQgZmlsdGVycyA9IHt9XG4gIC8vIGNyZWF0ZSB1cGRhdGUgbXV0ZXhcbiAgY29uc3QgbXV0ZXggPSBuZXcgTXV0ZXgoKVxuICBjb25zdCB3YWl0Rm9yRnJlZSA9IG11dGV4TWlkZGxld2FyZVdyYXBwZXIoeyBtdXRleCB9KVxuXG4gIGNvbnN0IG1pZGRsZXdhcmUgPSBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgIC8vIGluc3RhbGwgZmlsdGVyc1xuICAgIGV0aF9uZXdGaWx0ZXI6ICAgICAgICAgICAgICAgICAgIHdhaXRGb3JGcmVlKHRvRmlsdGVyQ3JlYXRpb25NaWRkbGV3YXJlKG5ld0xvZ0ZpbHRlcikpLFxuICAgIGV0aF9uZXdCbG9ja0ZpbHRlcjogICAgICAgICAgICAgIHdhaXRGb3JGcmVlKHRvRmlsdGVyQ3JlYXRpb25NaWRkbGV3YXJlKG5ld0Jsb2NrRmlsdGVyKSksXG4gICAgZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcjogd2FpdEZvckZyZWUodG9GaWx0ZXJDcmVhdGlvbk1pZGRsZXdhcmUobmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyKSksXG4gICAgLy8gdW5pbnN0YWxsIGZpbHRlcnNcbiAgICBldGhfdW5pbnN0YWxsRmlsdGVyOiAgICAgICAgICAgICB3YWl0Rm9yRnJlZSh0b0FzeW5jUnBjTWlkZGxld2FyZSh1bmluc3RhbGxGaWx0ZXJIYW5kbGVyKSksXG4gICAgLy8gY2hlY2tpbmcgZmlsdGVyIGNoYW5nZXNcbiAgICBldGhfZ2V0RmlsdGVyQ2hhbmdlczogICAgICAgICAgICB3YWl0Rm9yRnJlZSh0b0FzeW5jUnBjTWlkZGxld2FyZShnZXRGaWx0ZXJDaGFuZ2VzKSksXG4gICAgZXRoX2dldEZpbHRlckxvZ3M6ICAgICAgICAgICAgICAgd2FpdEZvckZyZWUodG9Bc3luY1JwY01pZGRsZXdhcmUoZ2V0RmlsdGVyTG9ncykpLFxuICB9KVxuXG4gIC8vIHNldHVwIGZpbHRlciB1cGRhdGluZyBhbmQgZGVzdHJveSBoYW5kbGVyXG4gIGNvbnN0IGZpbHRlclVwZGF0ZXIgPSBhc3luYyAoeyBvbGRCbG9jaywgbmV3QmxvY2sgfSkgPT4ge1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gICAgLy8gbG9jayB1cGRhdGUgcmVhZHNcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IG11dGV4LmFjcXVpcmUoKVxuICAgIHRyeSB7XG4gICAgICAvLyBwcm9jZXNzIGFsbCBmaWx0ZXJzIGluIHBhcmFsbGVsXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChvYmpWYWx1ZXMoZmlsdGVycykubWFwKGFzeW5jIChmaWx0ZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgIGF3YWl0IGZpbHRlci51cGRhdGUoeyBvbGRCbG9jaywgbmV3QmxvY2sgfSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gaGFuZGxlIGVhY2ggZXJyb3IgaW5kaXZpZHVhbGx5IHNvIGZpbHRlciB1cGRhdGUgZXJyb3JzIGRvbid0IGFmZmVjdCBvdGhlciBmaWx0ZXJzXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gbG9nIGVycm9yIHNvIHdlIGRvbid0IHNraXAgdGhlIHJlbGVhc2VMb2NrXG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gICAgLy8gdW5sb2NrIHVwZGF0ZSByZWFkc1xuICAgIHJlbGVhc2VMb2NrKClcbiAgfVxuXG4gIC8vIGV4cG9zZSBmaWx0ZXIgbWV0aG9kcyBkaXJlY3RseVxuICBtaWRkbGV3YXJlLm5ld0xvZ0ZpbHRlciA9IG5ld0xvZ0ZpbHRlclxuICBtaWRkbGV3YXJlLm5ld0Jsb2NrRmlsdGVyID0gbmV3QmxvY2tGaWx0ZXJcbiAgbWlkZGxld2FyZS5uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIgPSBuZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcbiAgbWlkZGxld2FyZS51bmluc3RhbGxGaWx0ZXIgPSB1bmluc3RhbGxGaWx0ZXJIYW5kbGVyXG4gIG1pZGRsZXdhcmUuZ2V0RmlsdGVyQ2hhbmdlcyA9IGdldEZpbHRlckNoYW5nZXNcbiAgbWlkZGxld2FyZS5nZXRGaWx0ZXJMb2dzID0gZ2V0RmlsdGVyTG9nc1xuXG4gIC8vIGV4cG9zZSBkZXN0cm95IG1ldGhvZCBmb3IgY2xlYW51cFxuICBtaWRkbGV3YXJlLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgdW5pbnN0YWxsQWxsRmlsdGVycygpXG4gIH1cblxuICByZXR1cm4gbWlkZGxld2FyZVxuXG4gIC8vXG4gIC8vIG5ldyBmaWx0ZXJzXG4gIC8vXG5cbiAgYXN5bmMgZnVuY3Rpb24gbmV3TG9nRmlsdGVyKHBhcmFtcykge1xuICAgIGNvbnN0IGZpbHRlciA9IG5ldyBMb2dGaWx0ZXIoeyBwcm92aWRlciwgcGFyYW1zIH0pXG4gICAgY29uc3QgZmlsdGVySW5kZXggPSBhd2FpdCBpbnN0YWxsRmlsdGVyKGZpbHRlcilcbiAgICByZXR1cm4gZmlsdGVyXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBuZXdCbG9ja0ZpbHRlcigpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSBuZXcgQmxvY2tGaWx0ZXIoeyBwcm92aWRlciB9KVxuICAgIGNvbnN0IGZpbHRlckluZGV4ID0gYXdhaXQgaW5zdGFsbEZpbHRlcihmaWx0ZXIpXG4gICAgcmV0dXJuIGZpbHRlclxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyKCkge1xuICAgIGNvbnN0IGZpbHRlciA9IG5ldyBUeEZpbHRlcih7IHByb3ZpZGVyIH0pXG4gICAgY29uc3QgZmlsdGVySW5kZXggPSBhd2FpdCBpbnN0YWxsRmlsdGVyKGZpbHRlcilcbiAgICByZXR1cm4gZmlsdGVyXG4gIH1cblxuICAvL1xuICAvLyBnZXQgZmlsdGVyIGNoYW5nZXNcbiAgLy9cblxuICBhc3luYyBmdW5jdGlvbiBnZXRGaWx0ZXJDaGFuZ2VzKGZpbHRlckluZGV4SGV4KSB7XG4gICAgY29uc3QgZmlsdGVySW5kZXggPSBoZXhUb0ludChmaWx0ZXJJbmRleEhleClcbiAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ZpbHRlckluZGV4XVxuICAgIGlmICghZmlsdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGZpbHRlciBmb3IgaW5kZXggXCIke2ZpbHRlckluZGV4fVwiYClcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IGZpbHRlci5nZXRDaGFuZ2VzQW5kQ2xlYXIoKVxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBnZXRGaWx0ZXJMb2dzKGZpbHRlckluZGV4SGV4KSB7XG4gICAgY29uc3QgZmlsdGVySW5kZXggPSBoZXhUb0ludChmaWx0ZXJJbmRleEhleClcbiAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ZpbHRlckluZGV4XVxuICAgIGlmICghZmlsdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGZpbHRlciBmb3IgaW5kZXggXCIke2ZpbHRlckluZGV4fVwiYClcbiAgICB9XG4gICAgLy8gb25seSByZXR1cm4gcmVzdWx0cyBmb3IgbG9nIGZpbHRlcnNcbiAgICBsZXQgcmVzdWx0cyA9IFtdXG4gICAgaWYgKGZpbHRlci50eXBlID09PSAnbG9nJykge1xuICAgICAgcmVzdWx0cyA9IGZpbHRlci5nZXRBbGxSZXN1bHRzKClcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG5cbiAgLy9cbiAgLy8gcmVtb3ZlIGZpbHRlcnNcbiAgLy9cblxuXG4gIGFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbEZpbHRlckhhbmRsZXIoZmlsdGVySW5kZXhIZXgpIHtcbiAgICAvLyBjaGVjayBmaWx0ZXIgZXhpc3RzXG4gICAgY29uc3QgZmlsdGVySW5kZXggPSBoZXhUb0ludChmaWx0ZXJJbmRleEhleClcbiAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ZpbHRlckluZGV4XVxuICAgIGNvbnN0IHJlc3VsdCA9IEJvb2xlYW4oZmlsdGVyKVxuICAgIC8vIHVuaW5zdGFsbCBmaWx0ZXJcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBhd2FpdCB1bmluc3RhbGxGaWx0ZXIoZmlsdGVySW5kZXgpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vXG4gIC8vIHV0aWxzXG4gIC8vXG5cbiAgYXN5bmMgZnVuY3Rpb24gaW5zdGFsbEZpbHRlcihmaWx0ZXIpIHtcbiAgICBjb25zdCBwcmV2RmlsdGVyQ291bnQgPSBvYmpWYWx1ZXMoZmlsdGVycykubGVuZ3RoXG4gICAgLy8gaW5zdGFsbCBmaWx0ZXJcbiAgICBjb25zdCBjdXJyZW50QmxvY2sgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKVxuICAgIGF3YWl0IGZpbHRlci5pbml0aWFsaXplKHsgY3VycmVudEJsb2NrIH0pXG4gICAgZmlsdGVySW5kZXgrK1xuICAgIGZpbHRlcnNbZmlsdGVySW5kZXhdID0gZmlsdGVyXG4gICAgZmlsdGVyLmlkID0gZmlsdGVySW5kZXhcbiAgICBmaWx0ZXIuaWRIZXggPSBpbnRUb0hleChmaWx0ZXJJbmRleClcbiAgICAvLyB1cGRhdGUgYmxvY2sgdHJhY2tlciBzdWJzXG4gICAgY29uc3QgbmV3RmlsdGVyQ291bnQgPSBvYmpWYWx1ZXMoZmlsdGVycykubGVuZ3RoXG4gICAgdXBkYXRlQmxvY2tUcmFja2VyU3Vicyh7IHByZXZGaWx0ZXJDb3VudCwgbmV3RmlsdGVyQ291bnQgfSlcbiAgICByZXR1cm4gZmlsdGVySW5kZXhcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbEZpbHRlcihmaWx0ZXJJbmRleCkge1xuICAgIGNvbnN0IHByZXZGaWx0ZXJDb3VudCA9IG9ialZhbHVlcyhmaWx0ZXJzKS5sZW5ndGhcbiAgICBkZWxldGUgZmlsdGVyc1tmaWx0ZXJJbmRleF1cbiAgICAvLyB1cGRhdGUgYmxvY2sgdHJhY2tlciBzdWJzXG4gICAgY29uc3QgbmV3RmlsdGVyQ291bnQgPSBvYmpWYWx1ZXMoZmlsdGVycykubGVuZ3RoXG4gICAgdXBkYXRlQmxvY2tUcmFja2VyU3Vicyh7IHByZXZGaWx0ZXJDb3VudCwgbmV3RmlsdGVyQ291bnQgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbEFsbEZpbHRlcnMoKSB7XG4gICAgY29uc3QgcHJldkZpbHRlckNvdW50ID0gb2JqVmFsdWVzKGZpbHRlcnMpLmxlbmd0aFxuICAgIGZpbHRlcnMgPSB7fVxuICAgIC8vIHVwZGF0ZSBibG9jayB0cmFja2VyIHN1YnNcbiAgICB1cGRhdGVCbG9ja1RyYWNrZXJTdWJzKHsgcHJldkZpbHRlckNvdW50LCBuZXdGaWx0ZXJDb3VudDogMCB9KVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tUcmFja2VyU3Vicyh7IHByZXZGaWx0ZXJDb3VudCwgbmV3RmlsdGVyQ291bnQgfSkge1xuICAgIC8vIHN1YnNjcmliZVxuICAgIGlmIChwcmV2RmlsdGVyQ291bnQgPT09IDAgJiYgbmV3RmlsdGVyQ291bnQgPiAwKSB7XG4gICAgICBibG9ja1RyYWNrZXIub24oJ3N5bmMnLCBmaWx0ZXJVcGRhdGVyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHVuc3Vic2NyaWJlXG4gICAgaWYgKHByZXZGaWx0ZXJDb3VudCA+IDAgJiYgbmV3RmlsdGVyQ291bnQgPT09IDApIHtcbiAgICAgIGJsb2NrVHJhY2tlci5yZW1vdmVMaXN0ZW5lcignc3luYycsIGZpbHRlclVwZGF0ZXIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxufVxuXG4vLyBoZWxwZXIgZm9yIHR1cm5pbmcgZmlsdGVyIGNvbnN0cnVjdG9ycyBpbnRvIHJwYyBtaWRkbGV3YXJlXG5mdW5jdGlvbiB0b0ZpbHRlckNyZWF0aW9uTWlkZGxld2FyZShjcmVhdGVGaWx0ZXJGbikge1xuICByZXR1cm4gdG9Bc3luY1JwY01pZGRsZXdhcmUoYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBmaWx0ZXIgPSBhd2FpdCBjcmVhdGVGaWx0ZXJGbiguLi5hcmdzKVxuICAgIGNvbnN0IHJlc3VsdCA9IGludFRvSGV4KGZpbHRlci5pZClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59XG5cbi8vIGhlbHBlciBmb3IgcHVsbGluZyBvdXQgcmVxLnBhcmFtcyBhbmQgc2V0dGluZyByZXMucmVzdWx0XG5mdW5jdGlvbiB0b0FzeW5jUnBjTWlkZGxld2FyZShhc3luY0ZuKSB7XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXN5bmNGbi5hcHBseShudWxsLCByZXEucGFyYW1zKVxuICAgIHJlcy5yZXN1bHQgPSByZXN1bHRcbiAgfSlcbn1cblxuZnVuY3Rpb24gbXV0ZXhNaWRkbGV3YXJlV3JhcHBlcih7IG11dGV4IH0pIHtcbiAgcmV0dXJuIChtaWRkbGV3YXJlKSA9PiB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgICAvLyB3YWl0IGZvciBtdXRleCBhdmFpbGFibGVcbiAgICAgIC8vIHdlIGNhbiByZWxlYXNlIGltbWVkaWF0ZWx5IGJlY2F1c2VcbiAgICAgIC8vIHdlIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgdXBkYXRlcyBhcmVuJ3QgYWN0aXZlXG4gICAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IG11dGV4LmFjcXVpcmUoKVxuICAgICAgcmVsZWFzZUxvY2soKVxuICAgICAgbWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgZW5kKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvYmpWYWx1ZXMob2JqLCBmbil7XG4gIGNvbnN0IHZhbHVlcyA9IFtdXG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICB2YWx1ZXMucHVzaChvYmpba2V5XSlcbiAgfVxuICByZXR1cm4gdmFsdWVzXG59XG4iLCJjb25zdCBFdGhRdWVyeSA9IHJlcXVpcmUoJ2V0aC1xdWVyeScpXG5jb25zdCBwaWZ5ID0gcmVxdWlyZSgncGlmeScpXG5jb25zdCBCYXNlRmlsdGVyV2l0aEhpc3RvcnkgPSByZXF1aXJlKCcuL2Jhc2UtZmlsdGVyLWhpc3RvcnknKVxuY29uc3QgeyBiblRvSGV4LCBoZXhUb0ludCwgaW5jcmVtZW50SGV4SW50LCBtaW5CbG9ja1JlZiwgYmxvY2tSZWZJc051bWJlciB9ID0gcmVxdWlyZSgnLi9oZXhVdGlscycpXG5cbmNsYXNzIExvZ0ZpbHRlciBleHRlbmRzIEJhc2VGaWx0ZXJXaXRoSGlzdG9yeSB7XG5cbiAgY29uc3RydWN0b3IgKHsgcHJvdmlkZXIsIHBhcmFtcyB9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudHlwZSA9ICdsb2cnXG4gICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBFdGhRdWVyeShwcm92aWRlcilcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZnJvbUJsb2NrOiAnbGF0ZXN0JyxcbiAgICAgIHRvQmxvY2s6ICdsYXRlc3QnLFxuICAgICAgYWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgdG9waWNzOiBbXSxcbiAgICB9LCBwYXJhbXMpXG4gICAgLy8gbm9ybWFsaXplIGFkZHJlc3MgcGFyYW1ldGVyXG4gICAgaWYgKHRoaXMucGFyYW1zLmFkZHJlc3MpIHtcbiAgICAgIC8vIGVuc3VyZSBhcnJheVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMucGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLmFkZHJlc3MgPSBbdGhpcy5wYXJhbXMuYWRkcmVzc11cbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBsb3dlcmNhc2VcbiAgICAgIHRoaXMucGFyYW1zLmFkZHJlc3MgPSB0aGlzLnBhcmFtcy5hZGRyZXNzLm1hcChhZGRyZXNzID0+IGFkZHJlc3MudG9Mb3dlckNhc2UoKSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplKHsgY3VycmVudEJsb2NrIH0pIHtcbiAgICAvLyByZXNvbHZlIHBhcmFtcy5mcm9tQmxvY2tcbiAgICBsZXQgZnJvbUJsb2NrID0gdGhpcy5wYXJhbXMuZnJvbUJsb2NrXG4gICAgaWYgKFsnbGF0ZXN0JywgJ3BlbmRpbmcnXS5pbmNsdWRlcyhmcm9tQmxvY2spKSBmcm9tQmxvY2sgPSBjdXJyZW50QmxvY2tcbiAgICBpZiAoJ2VhcmxpZXN0JyA9PT0gZnJvbUJsb2NrKSBmcm9tQmxvY2sgPSAnMHgwJ1xuICAgIHRoaXMucGFyYW1zLmZyb21CbG9jayA9IGZyb21CbG9ja1xuICAgIC8vIHNldCB0b0Jsb2NrIGZvciBpbml0aWFsIGxvb2t1cFxuICAgIGNvbnN0IHRvQmxvY2sgPSBtaW5CbG9ja1JlZih0aGlzLnBhcmFtcy50b0Jsb2NrLCBjdXJyZW50QmxvY2spXG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdG9CbG9jayB9KVxuICAgIC8vIGZldGNoIGxvZ3MgYW5kIGFkZCB0byByZXN1bHRzXG4gICAgY29uc3QgbmV3TG9ncyA9IGF3YWl0IHRoaXMuX2ZldGNoTG9ncyhwYXJhbXMpXG4gICAgdGhpcy5hZGRJbml0aWFsUmVzdWx0cyhuZXdMb2dzKVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlICh7IG9sZEJsb2NrLCBuZXdCbG9jayB9KSB7XG4gICAgLy8gY29uZmlndXJlIHBhcmFtcyBmb3IgdGhpcyB1cGRhdGVcbiAgICBjb25zdCB0b0Jsb2NrID0gbmV3QmxvY2tcbiAgICBsZXQgZnJvbUJsb2NrXG4gICAgLy8gb2xkQmxvY2sgaXMgZW1wdHkgb24gZmlyc3Qgc3luY1xuICAgIGlmIChvbGRCbG9jaykge1xuICAgICAgZnJvbUJsb2NrID0gaW5jcmVtZW50SGV4SW50KG9sZEJsb2NrKVxuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tQmxvY2sgPSBuZXdCbG9ja1xuICAgIH1cbiAgICAvLyBmZXRjaCBsb2dzXG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgZnJvbUJsb2NrLCB0b0Jsb2NrIH0pXG4gICAgY29uc3QgbmV3TG9ncyA9IGF3YWl0IHRoaXMuX2ZldGNoTG9ncyhwYXJhbXMpXG4gICAgY29uc3QgbWF0Y2hpbmdMb2dzID0gbmV3TG9ncy5maWx0ZXIobG9nID0+IHRoaXMubWF0Y2hMb2cobG9nKSlcblxuICAgIC8vIGFkZCB0byByZXN1bHRzXG4gICAgdGhpcy5hZGRSZXN1bHRzKG1hdGNoaW5nTG9ncylcbiAgfVxuXG4gIGFzeW5jIF9mZXRjaExvZ3MgKHBhcmFtcykge1xuICAgIGNvbnN0IG5ld0xvZ3MgPSBhd2FpdCBwaWZ5KGNiID0+IHRoaXMuZXRoUXVlcnkuZ2V0TG9ncyhwYXJhbXMsIGNiKSkoKVxuICAgIC8vIGFkZCB0byByZXN1bHRzXG4gICAgcmV0dXJuIG5ld0xvZ3NcbiAgfVxuXG4gIG1hdGNoTG9nKGxvZykge1xuICAgIC8vIGNoZWNrIGlmIGJsb2NrIG51bWJlciBpbiBib3VuZHM6XG4gICAgaWYgKGhleFRvSW50KHRoaXMucGFyYW1zLmZyb21CbG9jaykgPj0gaGV4VG9JbnQobG9nLmJsb2NrTnVtYmVyKSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGJsb2NrUmVmSXNOdW1iZXIodGhpcy5wYXJhbXMudG9CbG9jaykgJiYgaGV4VG9JbnQodGhpcy5wYXJhbXMudG9CbG9jaykgPD0gaGV4VG9JbnQobG9nLmJsb2NrTnVtYmVyKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBhZGRyZXNzIGlzIGNvcnJlY3Q6XG4gICAgY29uc3Qgbm9ybWFsaXplZExvZ0FkZHJlc3MgPSBsb2cuYWRkcmVzcyAmJiBsb2cuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKHRoaXMucGFyYW1zLmFkZHJlc3MgJiYgbm9ybWFsaXplZExvZ0FkZHJlc3MgJiYgIXRoaXMucGFyYW1zLmFkZHJlc3MuaW5jbHVkZXMobm9ybWFsaXplZExvZ0FkZHJlc3MpKSByZXR1cm4gZmFsc2VcblxuICAgIC8vIHRvcGljcyBtYXRjaDpcbiAgICAvLyB0b3BpY3MgYXJlIHBvc2l0aW9uLWRlcGVuZGFudFxuICAgIC8vIHRvcGljcyBjYW4gYmUgbmVzdGVkIHRvIHJlcHJlc2VudCBgb3JgIFtbYSB8fCBiXSwgY11cbiAgICAvLyB0b3BpY3MgY2FuIGJlIG51bGwsIHJlcHJlc2VudGluZyBhIHdpbGQgY2FyZCBmb3IgdGhhdCBwb3NpdGlvblxuICAgIGNvbnN0IHRvcGljc01hdGNoID0gdGhpcy5wYXJhbXMudG9waWNzLmV2ZXJ5KCh0b3BpY1BhdHRlcm4sIGluZGV4KSA9PiB7XG4gICAgICAvLyBwYXR0ZXJuIGlzIGxvbmdlciB0aGFuIGFjdHVhbCB0b3BpY3NcbiAgICAgIGxldCBsb2dUb3BpYyA9IGxvZy50b3BpY3NbaW5kZXhdXG4gICAgICBpZiAoIWxvZ1RvcGljKSByZXR1cm4gZmFsc2VcbiAgICAgIGxvZ1RvcGljID0gbG9nVG9waWMudG9Mb3dlckNhc2UoKVxuICAgICAgLy8gbm9ybWFsaXplIHN1YlRvcGljc1xuICAgICAgbGV0IHN1YnRvcGljc1RvTWF0Y2ggPSBBcnJheS5pc0FycmF5KHRvcGljUGF0dGVybikgPyB0b3BpY1BhdHRlcm4gOiBbdG9waWNQYXR0ZXJuXVxuICAgICAgLy8gY2hlY2sgZm9yIHdpbGQgY2FyZFxuICAgICAgY29uc3Qgc3VidG9waWNzSW5jbHVkZVdpbGRjYXJkID0gc3VidG9waWNzVG9NYXRjaC5pbmNsdWRlcyhudWxsKVxuICAgICAgaWYgKHN1YnRvcGljc0luY2x1ZGVXaWxkY2FyZCkgcmV0dXJuIHRydWVcbiAgICAgIHN1YnRvcGljc1RvTWF0Y2ggPSBzdWJ0b3BpY3NUb01hdGNoLm1hcCh0b3BpYyA9PiB0b3BpYy50b0xvd2VyQ2FzZSgpKVxuICAgICAgLy8gY2hlY2sgZWFjaCBwb3NzaWJsZSBtYXRjaGluZyB0b3BpY1xuICAgICAgY29uc3QgdG9waWNEb2VzTWF0Y2ggPSBzdWJ0b3BpY3NUb01hdGNoLmluY2x1ZGVzKGxvZ1RvcGljKVxuICAgICAgcmV0dXJuIHRvcGljRG9lc01hdGNoXG4gICAgfSlcblxuICAgIHJldHVybiB0b3BpY3NNYXRjaFxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2dGaWx0ZXJcbiIsImNvbnN0IFNhZmVFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyJykuZGVmYXVsdFxuY29uc3QgeyBjcmVhdGVBc3luY01pZGRsZXdhcmUsIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSB9ID0gcmVxdWlyZSgnanNvbi1ycGMtZW5naW5lJylcbmNvbnN0IGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2luZGV4LmpzJylcbmNvbnN0IHsgdW5zYWZlUmFuZG9tQnl0ZXMsIGluY3JlbWVudEhleEludCB9ID0gcmVxdWlyZSgnLi9oZXhVdGlscy5qcycpXG5jb25zdCBnZXRCbG9ja3NGb3JSYW5nZSA9IHJlcXVpcmUoJy4vZ2V0QmxvY2tzRm9yUmFuZ2UuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVN1YnNjcmlwdGlvbk1pZGRsZXdhcmVcblxuXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpcHRpb25NaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCBwcm92aWRlciB9KSB7XG4gIC8vIHN0YXRlIGFuZCB1dGlsaXRpZXMgZm9yIGhhbmRsaW5nIHN1YnNjcmlwdGlvbnNcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHt9XG4gIGNvbnN0IGZpbHRlck1hbmFnZXIgPSBjcmVhdGVGaWx0ZXJNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCBwcm92aWRlciB9KVxuXG4gIC8vIGludGVybmFsIGZsYWdcbiAgbGV0IGlzRGVzdHJveWVkID0gZmFsc2VcblxuICAvLyBjcmVhdGUgc3Vic2NyaXB0aW9uTWFuYWdlciBhcGkgb2JqZWN0XG4gIGNvbnN0IGV2ZW50cyA9IG5ldyBTYWZlRXZlbnRFbWl0dGVyKClcbiAgY29uc3QgbWlkZGxld2FyZSA9IGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSh7XG4gICAgZXRoX3N1YnNjcmliZTogY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHN1YnNjcmliZSksXG4gICAgZXRoX3Vuc3Vic2NyaWJlOiBjcmVhdGVBc3luY01pZGRsZXdhcmUodW5zdWJzY3JpYmUpLFxuICB9KVxuICBtaWRkbGV3YXJlLmRlc3Ryb3kgPSBkZXN0cm95XG4gIHJldHVybiB7IGV2ZW50cywgbWlkZGxld2FyZSB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlKHJlcSwgcmVzKSB7XG5cbiAgICBpZiAoaXNEZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdTdWJzY3JpcHRpb25NYW5hZ2VyIC0gYXR0ZW1wdGluZyB0byB1c2UgYWZ0ZXIgZGVzdHJveWluZydcbiAgICApXG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb25UeXBlID0gcmVxLnBhcmFtc1swXVxuICAgIC8vIHN1YklkIGlzIDE2IGJ5dGUgaGV4IHN0cmluZ1xuICAgIGNvbnN0IHN1YklkID0gdW5zYWZlUmFuZG9tQnl0ZXMoMTYpXG5cbiAgICAvLyBjcmVhdGUgc3ViXG4gICAgbGV0IHN1YlxuICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uVHlwZSkge1xuICAgICAgY2FzZSAnbmV3SGVhZHMnOlxuICAgICAgICBzdWIgPSBjcmVhdGVTdWJOZXdIZWFkcyh7IHN1YklkIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdsb2dzJzpcbiAgICAgICAgY29uc3QgZmlsdGVyUGFyYW1zID0gcmVxLnBhcmFtc1sxXVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXJNYW5hZ2VyLm5ld0xvZ0ZpbHRlcihmaWx0ZXJQYXJhbXMpXG4gICAgICAgIHN1YiA9IGNyZWF0ZVN1YkZyb21GaWx0ZXIoeyBzdWJJZCwgZmlsdGVyIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YnNjcmlwdGlvbk1hbmFnZXIgLSB1bnN1cHBvcnRlZCBzdWJzY3JpcHRpb24gdHlwZSBcIiR7c3Vic2NyaXB0aW9uVHlwZX1cImApXG5cbiAgICB9XG4gICAgc3Vic2NyaXB0aW9uc1tzdWJJZF0gPSBzdWJcblxuICAgIHJlcy5yZXN1bHQgPSBzdWJJZFxuICAgIHJldHVyblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU3ViTmV3SGVhZHMoeyBzdWJJZCB9KSB7XG4gICAgICBjb25zdCBzdWIgPSB7XG4gICAgICAgIHR5cGU6IHN1YnNjcmlwdGlvblR5cGUsXG4gICAgICAgIGRlc3Ryb3k6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBibG9ja1RyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ3N5bmMnLCBzdWIudXBkYXRlKVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IGFzeW5jICh7IG9sZEJsb2NrLCBuZXdCbG9jayB9KSA9PiB7XG4gICAgICAgICAgLy8gZm9yIG5ld0hlYWRzXG4gICAgICAgICAgY29uc3QgdG9CbG9jayA9IG5ld0Jsb2NrXG4gICAgICAgICAgY29uc3QgZnJvbUJsb2NrID0gaW5jcmVtZW50SGV4SW50KG9sZEJsb2NrKVxuICAgICAgICAgIGNvbnN0IHJhd0Jsb2NrcyA9IGF3YWl0IGdldEJsb2Nrc0ZvclJhbmdlKHsgcHJvdmlkZXIsIGZyb21CbG9jaywgdG9CbG9jayB9KVxuICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSByYXdCbG9ja3MubWFwKG5vcm1hbGl6ZUJsb2NrKS5maWx0ZXIoYmxvY2sgPT4gYmxvY2sgIT09IG51bGwpXG4gICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgX2VtaXRTdWJzY3JpcHRpb25SZXN1bHQoc3ViSWQsIHZhbHVlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGZvciBzdWJzY3JpcHRpb24gdXBkYXRlcyBvbiBuZXcgYmxvY2tcbiAgICAgIGJsb2NrVHJhY2tlci5vbignc3luYycsIHN1Yi51cGRhdGUpXG4gICAgICByZXR1cm4gc3ViXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU3ViRnJvbUZpbHRlcih7IHN1YklkLCBmaWx0ZXIgfSkge1xuICAgICAgZmlsdGVyLm9uKCd1cGRhdGUnLCByZXN1bHQgPT4gX2VtaXRTdWJzY3JpcHRpb25SZXN1bHQoc3ViSWQsIHJlc3VsdCkpXG4gICAgICBjb25zdCBzdWIgPSB7XG4gICAgICAgIHR5cGU6IHN1YnNjcmlwdGlvblR5cGUsXG4gICAgICAgIGRlc3Ryb3k6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZmlsdGVyTWFuYWdlci51bmluc3RhbGxGaWx0ZXIoZmlsdGVyLmlkSGV4KVxuICAgICAgICB9LFxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YlxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKHJlcSwgcmVzKSB7XG5cbiAgICBpZiAoaXNEZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdTdWJzY3JpcHRpb25NYW5hZ2VyIC0gYXR0ZW1wdGluZyB0byB1c2UgYWZ0ZXIgZGVzdHJveWluZydcbiAgICApXG5cbiAgICBjb25zdCBpZCA9IHJlcS5wYXJhbXNbMF1cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb25zW2lkXVxuICAgIC8vIGlmIG1pc3NpbmcsIHJldHVybiBcImZhbHNlXCIgdG8gaW5kaWNhdGUgaXQgd2FzIG5vdCByZW1vdmVkXG4gICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgIHJlcy5yZXN1bHQgPSBmYWxzZVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGNsZWFudXAgc3Vic2NyaXB0aW9uXG4gICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNbaWRdXG4gICAgYXdhaXQgc3Vic2NyaXB0aW9uLmRlc3Ryb3koKVxuICAgIHJlcy5yZXN1bHQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBfZW1pdFN1YnNjcmlwdGlvblJlc3VsdChmaWx0ZXJJZEhleCwgdmFsdWUpIHtcbiAgICBldmVudHMuZW1pdCgnbm90aWZpY2F0aW9uJywge1xuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBtZXRob2Q6ICdldGhfc3Vic2NyaXB0aW9uJyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBzdWJzY3JpcHRpb246IGZpbHRlcklkSGV4LFxuICAgICAgICByZXN1bHQ6IHZhbHVlLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgICBmb3IgKGNvbnN0IGlkIGluIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHN1YnNjcmlwdGlvbnNbaWRdLmRlc3Ryb3koKVxuICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNbaWRdXG4gICAgfVxuICAgIGlzRGVzdHJveWVkID0gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsb2NrKGJsb2NrKSB7XG4gIGlmIChibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoYXNoOiBibG9jay5oYXNoLFxuICAgIHBhcmVudEhhc2g6IGJsb2NrLnBhcmVudEhhc2gsXG4gICAgc2hhM1VuY2xlczogYmxvY2suc2hhM1VuY2xlcyxcbiAgICBtaW5lcjogYmxvY2subWluZXIsXG4gICAgc3RhdGVSb290OiBibG9jay5zdGF0ZVJvb3QsXG4gICAgdHJhbnNhY3Rpb25zUm9vdDogYmxvY2sudHJhbnNhY3Rpb25zUm9vdCxcbiAgICByZWNlaXB0c1Jvb3Q6IGJsb2NrLnJlY2VpcHRzUm9vdCxcbiAgICBsb2dzQmxvb206IGJsb2NrLmxvZ3NCbG9vbSxcbiAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5LFxuICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxuICAgIGdhc0xpbWl0OiBibG9jay5nYXNMaW1pdCxcbiAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxuICAgIG5vbmNlOiBibG9jay5ub25jZSxcbiAgICBtaXhIYXNoOiBibG9jay5taXhIYXNoLFxuICAgIHRpbWVzdGFtcDogYmxvY2sudGltZXN0YW1wLFxuICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICB9XG59XG4iLCJjb25zdCBCYXNlRmlsdGVyID0gcmVxdWlyZSgnLi9iYXNlLWZpbHRlcicpXG5jb25zdCBnZXRCbG9ja3NGb3JSYW5nZSA9IHJlcXVpcmUoJy4vZ2V0QmxvY2tzRm9yUmFuZ2UnKVxuY29uc3QgeyBpbmNyZW1lbnRIZXhJbnQgfSA9IHJlcXVpcmUoJy4vaGV4VXRpbHMnKVxuXG5jbGFzcyBUeEZpbHRlciBleHRlbmRzIEJhc2VGaWx0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICh7IHByb3ZpZGVyIH0pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0gJ3R4J1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlclxuICB9XG5cbiAgYXN5bmMgdXBkYXRlICh7IG9sZEJsb2NrIH0pIHtcbiAgICBjb25zdCB0b0Jsb2NrID0gb2xkQmxvY2tcbiAgICBjb25zdCBmcm9tQmxvY2sgPSBpbmNyZW1lbnRIZXhJbnQob2xkQmxvY2spXG4gICAgY29uc3QgYmxvY2tzID0gYXdhaXQgZ2V0QmxvY2tzRm9yUmFuZ2UoeyBwcm92aWRlcjogdGhpcy5wcm92aWRlciwgZnJvbUJsb2NrLCB0b0Jsb2NrIH0pXG4gICAgY29uc3QgYmxvY2tUeEhhc2hlcyA9IFtdXG4gICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgIGJsb2NrVHhIYXNoZXMucHVzaCguLi5ibG9jay50cmFuc2FjdGlvbnMpXG4gICAgfVxuICAgIC8vIGFkZCB0byByZXN1bHRzXG4gICAgdGhpcy5hZGRSZXN1bHRzKGJsb2NrVHhIYXNoZXMpXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR4RmlsdGVyXG4iLCJjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbmNvbnN0IFNESyA9IHJlcXVpcmUoJ2dyaWRwbHVzLXNkaycpO1xuY29uc3QgRXRoVHggPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpO1xuY29uc3QgeyBhZGRIZXhQcmVmaXggfSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgcmxwID0gcmVxdWlyZSgncmxwJyk7XG5jb25zdCBrZXlyaW5nVHlwZSA9ICdMYXR0aWNlIEhhcmR3YXJlJztcbmNvbnN0IEhBUkRFTkVEX09GRlNFVCA9IDB4ODAwMDAwMDA7XG5jb25zdCBQRVJfUEFHRSA9IDU7XG5jb25zdCBDTE9TRV9DT0RFID0gLTEwMDA7XG5jb25zdCBTVEFOREFSRF9IRF9QQVRIID0gYG0vNDQnLzYwJy8wJy8wL3hgO1xuY29uc3QgU0RLX1RJTUVPVVQgPSAxMjAwMDA7XG5jb25zdCBDT05ORUNUX1RJTUVPVVQgPSAyMDAwMDtcblxuY2xhc3MgTGF0dGljZUtleXJpbmcgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cz17fSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnR5cGUgPSBrZXlyaW5nVHlwZTtcbiAgICB0aGlzLl9yZXNldERlZmF1bHRzKCk7XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBLZXlyaW5nIEFQSSAocGVyIGBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svZXRoLXNpbXBsZS1rZXlyaW5nYClcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGRlc2VyaWFsaXplIChvcHRzID0ge30pIHtcbiAgICBpZiAob3B0cy5oZFBhdGgpXG4gICAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoO1xuICAgIGlmIChvcHRzLmNyZWRzKVxuICAgICAgdGhpcy5jcmVkcyA9IG9wdHMuY3JlZHM7XG4gICAgaWYgKG9wdHMuYWNjb3VudHMpXG4gICAgICB0aGlzLmFjY291bnRzID0gb3B0cy5hY2NvdW50cztcbiAgICBpZiAob3B0cy5hY2NvdW50SW5kaWNlcylcbiAgICAgIHRoaXMuYWNjb3VudEluZGljZXMgPSBvcHRzLmFjY291bnRJbmRpY2VzO1xuICAgIGlmIChvcHRzLmFjY291bnRPcHRzKVxuICAgICAgdGhpcy5hY2NvdW50T3B0cyA9IG9wdHMuYWNjb3VudE9wdHM7XG4gICAgaWYgKG9wdHMud2FsbGV0VUlEKVxuICAgICAgdGhpcy53YWxsZXRVSUQgPSBvcHRzLndhbGxldFVJRDtcbiAgICBpZiAob3B0cy5uYW1lKSAgLy8gTGVnYWN5OyB1c2UgaXMgZGVwcmVjYXRlZCBhbmQgYXBwTmFtZSBpcyBtb3JlIGRlc2NyaXB0aXZlXG4gICAgICB0aGlzLmFwcE5hbWUgPSBvcHRzLm5hbWU7XG4gICAgaWYgKG9wdHMuYXBwTmFtZSlcbiAgICAgIHRoaXMuYXBwTmFtZSA9IG9wdHMuYXBwTmFtZTtcbiAgICBpZiAob3B0cy5uZXR3b3JrKVxuICAgICAgdGhpcy5uZXR3b3JrID0gb3B0cy5uZXR3b3JrO1xuICAgIGlmIChvcHRzLnBhZ2UpXG4gICAgICB0aGlzLnBhZ2UgPSBvcHRzLnBhZ2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0SGRQYXRoKGhkUGF0aCkge1xuICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoO1xuICB9XG5cbiAgYXN5bmMgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVkczogdGhpcy5jcmVkcyxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgYWNjb3VudEluZGljZXM6IHRoaXMuYWNjb3VudEluZGljZXMsXG4gICAgICBhY2NvdW50T3B0czogdGhpcy5hY2NvdW50T3B0cyxcbiAgICAgIHdhbGxldFVJRDogdGhpcy53YWxsZXRVSUQsXG4gICAgICBhcHBOYW1lOiB0aGlzLmFwcE5hbWUsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsICAvLyBMZWdhY3k7IHVzZSBpcyBkZXByZWNhdGVkXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmssXG4gICAgICBwYWdlOiB0aGlzLnBhZ2UsXG4gICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgIH07XG4gIH1cblxuICAvLyBEZXRlcmltaW5lIGlmIHdlIGhhdmUgYSBjb25uZWN0aW9uIHRvIHRoZSBMYXR0aWNlIGFuZCBhbiBleGlzdGluZyB3YWxsZXQgVUlEXG4gIC8vIGFnYWluc3Qgd2hpY2ggdG8gbWFrZSByZXF1ZXN0cy5cbiAgaXNVbmxvY2tlZCAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZ2V0Q3VycmVudFdhbGxldFVJRCgpICYmICEhdGhpcy5zZGtTZXNzaW9uO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBhIHNlc3Npb24gd2l0aCB0aGUgTGF0dGljZTEgZGV2aWNlIHVzaW5nIHRoZSBHcmlkUGx1cyBTREtcbiAgLy8gTk9URTogYGJ5cGFzc09uU3RhdGVEYXRhPXRydWVgIGFsbG93cyB1cyB0byByZWh5ZHJhdGUgYSBuZXcgU0RLIHNlc3Npb24gd2l0aG91dFxuICAvLyByZWNvbm5lY3RpbmcgdG8gdGhlIHRhcmdldCBMYXR0aWNlLiBUaGlzIGlzIG9ubHkgY3VycmVudGx5IHVzZWQgZm9yIHNpZ25pbmdcbiAgLy8gYmVjYXVzZSBpdCBlbGltaW5hdGVzIHRoZSBuZWVkIGZvciAyIGNvbm5lY3Rpb24gcmVxdWVzdHMgYW5kIHNoYXZlcyBvZmYgfjQtNnNlYy5cbiAgLy8gV2UgYXZvaWQgcGFzc2luZyBgYnlwYXNzT25TdGF0ZURhdGE9dHJ1ZWAgZm9yIG90aGVyIGNhbGxzIG9uIGB1bmxvY2tgIHRvIGF2b2lkXG4gIC8vIHBvc3NpYmxlIGVkZ2UgY2FzZXMgcmVsYXRlZCB0byB0aGlzIG5ldyBmdW5jdGlvbmFsaXR5IChpdCdzIHByb2JhYmx5IGZpbmUgLSBqdXN0XG4gIC8vIGJlaW5nIGNhdXRpb3VzKS4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgcmVtb3ZlIGBieXBhc3NPblN0YXRlRGF0YWAgZW50aXJlbHkuXG4gIGFzeW5jIHVubG9jayAoYnlwYXNzT25TdGF0ZURhdGEgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSkge1xuICAgICAgcmV0dXJuIFwiVW5sb2NrZWRcIjtcbiAgICB9XG4gICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLl9nZXRDcmVkcygpO1xuICAgIGlmIChjcmVkcykge1xuICAgICAgdGhpcy5jcmVkcy5kZXZpY2VJRCA9IGNyZWRzLmRldmljZUlEO1xuICAgICAgdGhpcy5jcmVkcy5wYXNzd29yZCA9IGNyZWRzLnBhc3N3b3JkO1xuICAgICAgdGhpcy5jcmVkcy5lbmRwb2ludCA9IGNyZWRzLmVuZHBvaW50IHx8IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGluY2x1ZGVkU3RhdGVEYXRhID0gYXdhaXQgdGhpcy5faW5pdFNlc3Npb24oKTtcbiAgICAvLyBJZiBzdGF0ZSBkYXRhIHdhcyBwcm92aWRlZCBhbmQgaWYgd2UgYXJlIGF1dGhvcml6ZWQgdG9cbiAgICAvLyBieXBhc3MgcmVjb25uZWN0aW5nLCB3ZSBjYW4gZXhpdCBoZXJlLlxuICAgIGlmIChpbmNsdWRlZFN0YXRlRGF0YSAmJiBieXBhc3NPblN0YXRlRGF0YSkge1xuICAgICAgcmV0dXJuIFwiVW5sb2NrZWRcIjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybiBcIlVubG9ja2VkXCI7XG4gIH1cblxuICAvLyBBZGQgYWRkcmVzc2VzIHRvIHRoZSBsb2NhbCBzdG9yZSBhbmQgcmV0dXJuIHRoZSBmdWxsIHJlc3VsdFxuICBhc3luYyBhZGRBY2NvdW50cyhuPTEpIHtcbiAgICBpZiAobiA8PSAwKSB7XG4gICAgICAvLyBBdm9pZCBub24tcG9zaXRpdmUgbnVtYmVycy5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ051bWJlciBvZiBhY2NvdW50cyB0byBhZGQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4nXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBOb3JtYWwgYmVoYXZpb3I6IGVzdGFibGlzaCB0aGUgY29ubmVjdGlvbiBhbmQgZmV0Y2ggYWRkcmVzc2VzLlxuICAgIGF3YWl0IHRoaXMudW5sb2NrKClcbiAgICBjb25zdCBhZGRycyA9IGF3YWl0IHRoaXMuX2ZldGNoQWRkcmVzc2VzKG4sIHRoaXMudW5sb2NrZWRBY2NvdW50KTtcbiAgICBjb25zdCB3YWxsZXRVSUQgPSB0aGlzLl9nZXRDdXJyZW50V2FsbGV0VUlEKCk7XG4gICAgaWYgKCF3YWxsZXRVSUQpIHtcbiAgICAgIC8vIFdlIHNob3VsZCBub3QgYWRkIGFjY291bnRzIHRoYXQgZG8gbm90IGhhdmUgd2FsbGV0IFVJRHMuXG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBhbmQgbmVlZHMgdG8gYmUgcmV0cmllZC5cbiAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3QoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHdhbGxldCBmb3VuZCBpbiBMYXR0aWNlLiBQbGVhc2UgcmV0cnkuJyk7XG4gICAgfVxuICAgIC8vIEFkZCB0aGVzZSBpbmRpY2VzXG4gICAgYWRkcnMuZm9yRWFjaCgoYWRkciwgaSkgPT4ge1xuICAgICAgbGV0IGFscmVhZHlTYXZlZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmFjY291bnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICgodGhpcy5hY2NvdW50c1tqXSA9PT0gYWRkcikgJiZcbiAgICAgICAgICAgICh0aGlzLmFjY291bnRPcHRzW2pdLndhbGxldFVJRCA9PT0gd2FsbGV0VUlEKSAmJlxuICAgICAgICAgICAgKHRoaXMuYWNjb3VudE9wdHNbal0uaGRQYXRoID09PSB0aGlzLmhkUGF0aCkpXG4gICAgICAgICAgYWxyZWFkeVNhdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYWxyZWFkeVNhdmVkKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudHMucHVzaChhZGRyKTtcbiAgICAgICAgdGhpcy5hY2NvdW50SW5kaWNlcy5wdXNoKHRoaXMudW5sb2NrZWRBY2NvdW50K2kpO1xuICAgICAgICB0aGlzLmFjY291bnRPcHRzLnB1c2goe1xuICAgICAgICAgIHdhbGxldFVJRCxcbiAgICAgICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHM7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGxvY2FsIHN0b3JlIG9mIGFkZHJlc3Nlcy4gVGhpcyBnZXRzIGNhbGxlZCB3aGVuIHRoZSBleHRlbnNpb24gdW5sb2Nrcy5cbiAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHMgPyBbLi4udGhpcy5hY2NvdW50c10gOiBbXTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbiAoYWRkcmVzcywgdHgpIHtcbiAgICBsZXQgc2lnbmVkVHgsIHY7XG4gICAgLy8gV2Ugd2lsbCBiZSBhZGRpbmcgYSBzaWduYXR1cmUgdG8gaHlkcmF0aW9uIGRhdGEgZm9yIGEgbmV3XG4gICAgLy8gdHJhbnNhY3Rpb24gb2JqZWN0IHNpbmNlIHRoZSBzaWcgZGF0YSBpcyBub3QgbXV0YWJsZS5cbiAgICAvLyBTZXR1cCBgdHhUb1JldHVybmAgZGF0YSBhbmQgc3RhcnQgYWRkaW5nIHRvIGl0LlxuICAgIGNvbnN0IHR4VG9SZXR1cm4gPSB0eC50b0pTT04oKTtcbiAgICB0eFRvUmV0dXJuLnR5cGUgPSB0eC5fdHlwZSB8fCBudWxsO1xuICAgIC8vIFNldHVwIGluZm8gcmVsYXRlZCB0byBzaWduZXIgYWNjb3VudFxuICAgIGNvbnN0IGFjY291bnRJZHggPSBhd2FpdCB0aGlzLl9maW5kU2lnbmVySWR4KGFkZHJlc3MpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBnZXRUeENoYWluSWQodHgpLnRvTnVtYmVyKCk7XG4gICAgY29uc3QgZndWZXJzaW9uID0gdGhpcy5zZGtTZXNzaW9uLmdldEZ3VmVyc2lvbigpO1xuICAgIGNvbnN0IGFkZHJlc3NJZHggPSB0aGlzLmFjY291bnRJbmRpY2VzW2FjY291bnRJZHhdO1xuICAgIGNvbnN0IHsgaGRQYXRoIH0gPSB0aGlzLmFjY291bnRPcHRzW2FjY291bnRJZHhdO1xuICAgIGNvbnN0IHNpZ25lclBhdGggPSB0aGlzLl9nZXRIRFBhdGhJbmRpY2VzKGhkUGF0aCwgYWRkcmVzc0lkeCk7XG4gICAgLy8gTGF0dGljZSBmaXJtd2FyZSB2MC4xMS4wIGltcGxlbWVudGVkIEVJUDE1NTkgYW5kIEVJUDI5MzBcbiAgICAvLyBXZSBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgY2Fubm90IHN1cHBvcnQgdGhpcy5cbiAgICBpZiAoZndWZXJzaW9uLm1ham9yID09PSAwICYmIGZ3VmVyc2lvbi5taW5vciA8PSAxMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXBkYXRlIExhdHRpY2UgZmlybXdhcmUuJyk7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHRoZSBzaWduaW5nIHJlcXVlc3RcbiAgICBpZiAoZndWZXJzaW9uLm1ham9yID4gMCB8fCBmd1ZlcnNpb24ubWlub3IgPj0gMTUpIHtcbiAgICAgIC8vIE5ld2VyIGZpcm13YXJlIHZlcnNpb25zIHN1cHBvcnQgYW4gZWFzaWVyIHBhdGh3YXlcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIC8vIExlZ2FjeSB0cmFuc2FjdGlvbnMgcmV0dXJuIHR4IHBhcmFtcy4gTmV3ZXIgdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF3LCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHBheWxvYWQ6ICB0eC5fdHlwZSA/XG4gICAgICAgICAgICAgICAgICB0eC5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKSA6XG4gICAgICAgICAgICAgICAgICBybHAuZW5jb2RlKHR4LmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpKSxcbiAgICAgICAgY3VydmVUeXBlOiBTREsuQ29uc3RhbnRzLlNJR05JTkcuQ1VSVkVTLlNFQ1AyNTZLMSxcbiAgICAgICAgaGFzaFR5cGU6IFNESy5Db25zdGFudHMuU0lHTklORy5IQVNIRVMuS0VDQ0FLMjU2LFxuICAgICAgICBlbmNvZGluZ1R5cGU6IFNESy5Db25zdGFudHMuU0lHTklORy5FTkNPRElOR1MuRVZNLFxuICAgICAgICBzaWduZXJQYXRoLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN1cHBvcnRzRGVjb2RlclJlY3Vyc2lvbiA9IGZ3VmVyc2lvbi5tYWpvciA+IDAgfHwgZndWZXJzaW9uLm1pbm9yID49MTY7XG4gICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gZGVjb2RlIHRoZSBjYWxsZGF0YVxuICAgICAgY29uc3QgeyBkZWYgfSA9IGF3YWl0IFNESy5VdGlscy5mZXRjaENhbGxkYXRhRGVjb2Rlcih0eC5kYXRhLCB0eC50bywgY2hhaW5JZCwgc3VwcG9ydHNEZWNvZGVyUmVjdXJzaW9uKTtcbiAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgZGF0YS5kZWNvZGVyID0gZGVmO1xuICAgICAgfVxuICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgICAgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNka1Nlc3Npb24uc2lnbih7IGRhdGEgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9sZGVyIGZpcm13YXJlIHZlcnNpb25zICg8MC4xNS4wKSB1c2UgdGhlIGxlZ2FjeSBzaWduaW5nIHBhdGh3YXkuXG4gICAgICBjb25zdCBkYXRhID0gZ2V0TGVnYWN5VHhSZXEodHgpO1xuICAgICAgZGF0YS5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgIGRhdGEuc2lnbmVyUGF0aCA9IHNpZ25lclBhdGg7XG4gICAgICBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc2RrU2Vzc2lvbi5zaWduKHsgY3VycmVuY3k6ICdFVEgnLCBkYXRhIH0pO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgd2UgZ290IGEgc2lnbmF0dXJlIGJhY2tcbiAgICBpZiAoIXNpZ25lZFR4LnNpZyB8fCAhc2lnbmVkVHguc2lnLnIgfHwgIXNpZ25lZFR4LnNpZy5zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSByZXR1cm5lZC4nKTtcbiAgICB9XG4gICAgLy8gQ29uc3RydWN0IHRoZSBgdmAgc2lnbmF0dXJlIHBhcmFtXG4gICAgaWYgKHNpZ25lZFR4LnNpZy52ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFYyIHNpZ25hdHVyZSBuZWVkcyBgdmAgY2FsY3VsYXRlZFxuICAgICAgdiA9IFNESy5VdGlscy5nZXRWKHR4LCBzaWduZWRUeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlZ2FjeSBzaWduYXR1cmVzIGhhdmUgYHZgIGluIHRoZSByZXNwb25zZVxuICAgICAgdiA9IHNpZ25lZFR4LnNpZy52Lmxlbmd0aCA9PT0gMCA/ICcwJyA6IHNpZ25lZFR4LnNpZy52LnRvU3RyaW5nKCdoZXgnKVxuICAgIH1cblxuICAgIC8vIFBhY2sgdGhlIHNpZ25hdHVyZSBpbnRvIHRoZSByZXR1cm4gb2JqZWN0XG4gICAgdHhUb1JldHVybi5yID0gYWRkSGV4UHJlZml4KHNpZ25lZFR4LnNpZy5yLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgdHhUb1JldHVybi5zID0gYWRkSGV4UHJlZml4KHNpZ25lZFR4LnNpZy5zLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgdHhUb1JldHVybi52ID0gYWRkSGV4UHJlZml4KHYpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhY3RpdmUgd2FsbGV0IGlzIGNvcnJlY3QgdG8gYXZvaWQgcmV0dXJuaW5nXG4gICAgLy8gYSBzaWduYXR1cmUgZnJvbSBhbiB1bmV4cGVjdGVkIHNpZ25lci5cbiAgICBjb25zdCBmb3VuZElkeCA9IGF3YWl0IHRoaXMuX2FjY291bnRJZHhJbkN1cnJlbnRXYWxsZXQoYWRkcmVzcyk7XG4gICAgaWYgKGZvdW5kSWR4ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdXcm9uZyBhY2NvdW50LiBQbGVhc2UgY2hhbmdlIHlvdXIgTGF0dGljZSB3YWxsZXQgb3IgJyArXG4gICAgICAgICdzd2l0Y2ggdG8gYW4gYWNjb3VudCBvbiB5b3VyIGN1cnJlbnQgYWN0aXZlIHdhbGxldC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gRXRoVHguVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhUb1JldHVybiwge1xuICAgICAgY29tbW9uOiB0eC5jb21tb24sIGZyZWV6ZTogT2JqZWN0LmlzRnJvemVuKHR4KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKGFkZHJlc3MsIG1zZykge1xuICAgIHJldHVybiB0aGlzLnNpZ25NZXNzYWdlKGFkZHJlc3MsIHsgcGF5bG9hZDogbXNnLCBwcm90b2NvbDogJ3NpZ25QZXJzb25hbCcgfSk7XG4gIH1cblxuICBhc3luYyBzaWduVHlwZWREYXRhKGFkZHJlc3MsIG1zZywgb3B0cykge1xuICAgIGlmIChvcHRzLnZlcnNpb24gJiYgKG9wdHMudmVyc2lvbiAhPT0gJ1Y0JyAmJiBvcHRzLnZlcnNpb24gIT09ICdWMycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBPbmx5IHNpZ25UeXBlZERhdGEgVjMgYW5kIFY0IG1lc3NhZ2VzIChFSVA3MTIpIGFyZSBzdXBwb3J0ZWQuIEdvdCB2ZXJzaW9uICR7b3B0cy52ZXJzaW9ufWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25NZXNzYWdlKGFkZHJlc3MsIHsgcGF5bG9hZDogbXNnLCBwcm90b2NvbDogJ2VpcDcxMicgfSlcbiAgfVxuXG4gIGFzeW5jIHNpZ25NZXNzYWdlIChhZGRyZXNzLCBtc2cpIHtcbiAgICBjb25zdCBhY2NvdW50SWR4ID0gYXdhaXQgdGhpcy5fZmluZFNpZ25lcklkeChhZGRyZXNzKTtcbiAgICBsZXQgeyBwYXlsb2FkLCBwcm90b2NvbCB9ID0gbXNnO1xuICAgIC8vIElmIHRoZSBtZXNzYWdlIGlzIG5vdCBhbiBvYmplY3Qgd2UgYXNzdW1lIGl0IGlzIGEgbGVnYWN5IHNpZ25QZXJzb25hbCByZXF1ZXN0XG4gICAgaWYgKCFwYXlsb2FkIHx8ICFwcm90b2NvbCkge1xuICAgICAgcGF5bG9hZCA9IG1zZztcbiAgICAgIHByb3RvY29sID0gXCJzaWduUGVyc29uYWxcIjtcbiAgICB9XG4gICAgY29uc3QgYWRkcmVzc0lkeCA9IHRoaXMuYWNjb3VudEluZGljZXNbYWNjb3VudElkeF07XG4gICAgY29uc3QgYWRkcmVzc1BhcmVudFBhdGggPSB0aGlzLmFjY291bnRPcHRzW2FjY291bnRJZHhdLmhkUGF0aDtcbiAgICBjb25zdCByZXEgPSB7XG4gICAgICBjdXJyZW5jeTogXCJFVEhfTVNHXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBzaWduZXJQYXRoOiB0aGlzLl9nZXRIRFBhdGhJbmRpY2VzKGFkZHJlc3NQYXJlbnRQYXRoLCBhZGRyZXNzSWR4KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNka1Nlc3Npb24uc2lnbihyZXEpO1xuICAgIGlmICghcmVzLnNpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmF0dXJlIHJldHVybmVkXCIpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBgdmAgdG8gYSBudW1iZXIuIEl0IHNob3VsZCBjb252ZXJ0IHRvIDAgb3IgMVxuICAgIGxldCB2O1xuICAgIHRyeSB7XG4gICAgICB2ID0gcmVzLnNpZy52LnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgaWYgKHYubGVuZ3RoIDwgMikge1xuICAgICAgICB2ID0gYDAke3Z9YDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlIGZvcm1hdCByZXR1cm5lZC5cIik7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYWN0aXZlIHdhbGxldCBpcyBjb3JyZWN0IHRvIGF2b2lkIHJldHVybmluZ1xuICAgIC8vIGEgc2lnbmF0dXJlIGZyb20gYW4gdW5leHBlY3RlZCBzaWduZXIuXG4gICAgY29uc3QgZm91bmRJZHggPSBhd2FpdCB0aGlzLl9hY2NvdW50SWR4SW5DdXJyZW50V2FsbGV0KGFkZHJlc3MpO1xuICAgIGlmIChmb3VuZElkeCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnV3JvbmcgYWNjb3VudC4gUGxlYXNlIGNoYW5nZSB5b3VyIExhdHRpY2Ugd2FsbGV0IG9yICcgK1xuICAgICAgICAnc3dpdGNoIHRvIGFuIGFjY291bnQgb24geW91ciBjdXJyZW50IGFjdGl2ZSB3YWxsZXQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBzaWcgc3RyaW5nXG4gICAgcmV0dXJuIGAweCR7cmVzLnNpZy5yfSR7cmVzLnNpZy5zfSR7dn1gO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0QWNjb3VudChhZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBvcnRBY2NvdW50IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBkZXZpY2UnKTtcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgIHRoaXMuYWNjb3VudHMuZm9yRWFjaCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgaWYgKGFjY291bnQudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmFjY291bnRJbmRpY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5hY2NvdW50T3B0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgZ2V0Rmlyc3RQYWdlKCkge1xuICAgIHRoaXMucGFnZSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhZ2UoMCk7XG4gIH1cblxuICBhc3luYyBnZXROZXh0UGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhZ2UoMSk7XG4gIH1cblxuICBhc3luYyBnZXRQcmV2aW91c1BhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYWdlKC0xKTtcbiAgfVxuXG4gIHNldEFjY291bnRUb1VubG9jayAoaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMClcbiAgfVxuXG4gIGZvcmdldERldmljZSAoKSB7XG4gICAgdGhpcy5fcmVzZXREZWZhdWx0cygpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEludGVybmFsIG1ldGhvZHMgYW5kIGludGVyZmFjZSB0byBTREtcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEZpbmQgdGhlIGFjY291bnQgaW5kZXggb2YgdGhlIHJlcXVlc3RlZCBhZGRyZXNzLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBpcyB0aGUgQklQMzkgcGF0aCBpbmRleCwgbm90IHRoZSBpbmRleCBpbiB0aGUgYWRkcmVzcyBjYWNoZS5cbiAgYXN5bmMgX2ZpbmRTaWduZXJJZHggKGFkZHJlc3MpIHtcbiAgICAvLyBUYWtlIG5vdGUgaWYgdGhpcyB3YXMgYWxyZWFkeSB1bmxvY2tlZFxuICAgIGNvbnN0IHdhc1VubG9ja2VkID0gdGhpcy5pc1VubG9ja2VkKCk7XG4gICAgLy8gVW5sb2NrIGFuZCBnZXQgdGhlIHdhbGxldCBVSUQuIFdlIHdpbGwgYnlwYXNzIHRoZSByZWNvbm5lY3Rpb25cbiAgICAvLyBzdGVwIGlmIHdlIGFyZSBhYmxlIHRvIHJlaHlkcmF0ZSBhbiBTREsgc2Vzc2lvbiB3aXRoIHN0YXRlIGRhdGEuXG4gICAgYXdhaXQgdGhpcy51bmxvY2sodHJ1ZSk7XG4gICAgbGV0IGFjY291bnRJZHggPSBhd2FpdCB0aGlzLl9hY2NvdW50SWR4SW5DdXJyZW50V2FsbGV0KGFkZHJlc3MpO1xuICAgIGlmIChhY2NvdW50SWR4ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWNjb3VudElkeDtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyB3YXMgdW5sb2NrZWQgYWxyZWFkeSwgdGhlIGB0aGlzLnVubG9ja2AgY2FsbCBkaWQgbm90IHN5bmNcbiAgICAvLyBkYXRhIHdpdGggdGhlIExhdHRpY2UuIFdlIHNob3VsZCBmb3JjZSBhIHN5bmMgYnkgcmVjb25uZWN0aW5nLlxuICAgIGlmICh3YXNVbmxvY2tlZCkge1xuICAgICAgYXdhaXQgdGhpcy5fY29ubmVjdCgpO1xuICAgICAgLy8gQ2hlY2sgdGhlIG5ldyB3YWxsZXQgYW5kIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoXG4gICAgICBhY2NvdW50SWR4ID0gYXdhaXQgdGhpcy5fYWNjb3VudElkeEluQ3VycmVudFdhbGxldChhZGRyZXNzKTtcbiAgICAgIGlmIChhY2NvdW50SWR4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhY2NvdW50SWR4O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIG1hdGNoLCBleGl0IGhlcmVcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkFjY291bnQgbm90IGZvdW5kIGluIGFjdGl2ZSBMYXR0aWNlIHdhbGxldC4gUGxlYXNlIHN3aXRjaC5cIlxuICAgICk7XG4gIH1cblxuICBhc3luYyBfYWNjb3VudElkeEluQ3VycmVudFdhbGxldChhZGRyZXNzKSB7XG4gICAgLy8gR2V0IHRoZSB3YWxsZXQgVUlEIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmVyIGFuZCBtYWtlIHN1cmVcbiAgICAvLyB0aGUgTGF0dGljZSBoYXMgdGhhdCBhcyBpdHMgYWN0aXZlIHdhbGxldCBiZWZvcmUgY29udGludWluZy5cbiAgICBjb25zdCBhY2NvdW50SWR4ID0gYXdhaXQgdGhpcy5fZmluZEFjY291bnRCeUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgY29uc3QgeyB3YWxsZXRVSUQgfSA9IHRoaXMuYWNjb3VudE9wdHNbYWNjb3VudElkeF07XG4gICAgLy8gR2V0IHRoZSBsYXN0IHVwZGF0ZWQgU0RLIHdhbGxldCBVSURcbiAgICBjb25zdCBhY3RpdmVXYWxsZXQgPSB0aGlzLnNka1Nlc3Npb24uZ2V0QWN0aXZlV2FsbGV0KCk7XG4gICAgaWYgKCFhY3RpdmVXYWxsZXQpIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFjdGl2ZSB3YWxsZXQgaW4gTGF0dGljZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVVJRCA9IGFjdGl2ZVdhbGxldC51aWQudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IHRoZSBhY3RpdmUgd2FsbGV0IHdlIGRvbid0IG5lZWQgdG8gbWFrZSBhIHJlcXVlc3RcbiAgICBpZiAod2FsbGV0VUlELnRvU3RyaW5nKFwiaGV4XCIpID09PSBhY3RpdmVVSUQpIHtcbiAgICAgIHJldHVybiBhY2NvdW50SWR4O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIF9maW5kQWNjb3VudEJ5QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgYWRkcnMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG4gICAgbGV0IGFjY291bnRJZHggPSAtMTtcbiAgICBhZGRycy5mb3JFYWNoKChhZGRyLCBpKSA9PiB7XG4gICAgICBpZiAoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIGFjY291bnRJZHggPSBpO1xuICAgIH0pXG4gICAgaWYgKGFjY291bnRJZHggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25lciBub3QgcHJlc2VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudElkeDtcbiAgfVxuXG4gIF9nZXRIRFBhdGhJbmRpY2VzKGhkUGF0aCwgaW5zZXJ0SWR4PTApIHtcbiAgICBjb25zdCBwYXRoID0gaGRQYXRoLnNwbGl0KCcvJykuc2xpY2UoMSk7XG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGxldCB1c2VkWCA9IGZhbHNlO1xuICAgIHBhdGguZm9yRWFjaCgoX2lkeCkgPT4ge1xuICAgICAgY29uc3QgaXNIYXJkZW5lZCA9IChfaWR4W19pZHgubGVuZ3RoIC0gMV0gPT09IFwiJ1wiKTtcbiAgICAgIGxldCBpZHggPSBpc0hhcmRlbmVkID8gSEFSREVORURfT0ZGU0VUIDogMDtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGB4YCBpbiB0aGUgcGF0aCBzdHJpbmcsIHdlIHdpbGwgdXNlIGl0IHRvIGluc2VydCBvdXJcbiAgICAgIC8vIGluZGV4LiBUaGlzIGlzIHVzZWZ1bCBmb3IgZS5nLiBMZWRnZXIgTGl2ZSBwYXRoLiBNb3N0IHBhdGhzIGhhdmUgdGhlXG4gICAgICAvLyBjaGFuZ2luZyBpbmRleCBhcyB0aGUgbGFzdCBvbmUsIHNvIGhhdmluZyBhbiBgeGAgaW4gdGhlIHBhdGggaXNuJ3RcbiAgICAgIC8vIHVzdWFsbHkgbmVjZXNzYXJ5LlxuICAgICAgaWYgKF9pZHguaW5kZXhPZigneCcpID4gLTEpIHtcbiAgICAgICAgaWR4ICs9IGluc2VydElkeDtcbiAgICAgICAgdXNlZFggPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0hhcmRlbmVkKSB7XG4gICAgICAgIGlkeCArPSBOdW1iZXIoX2lkeC5zbGljZSgwLCBfaWR4Lmxlbmd0aCAtIDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCArPSBOdW1iZXIoX2lkeCk7XG4gICAgICB9XG4gICAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgICB9KVxuICAgIC8vIElmIHRoaXMgcGF0aCBzdHJpbmcgZG9lcyBub3QgaW5jbHVkZSBhbiBgeGAsIHdlIGp1c3QgYXBwZW5kIHRoZSBpbmRleFxuICAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIGV4dHJhY3RlZCBzZXRcbiAgICBpZiAodXNlZFggPT09IGZhbHNlKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaW5zZXJ0SWR4KTtcbiAgICB9XG4gICAgLy8gU2FuaXR5IGNoZWNrIC0tIExhdHRpY2UgZmlybXdhcmUgd2lsbCB0aHJvdyBhbiBlcnJvciBmb3IgbGFyZ2UgcGF0aHNcbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggPiA1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IEhEIHBhdGhzIHdpdGggdXAgdG8gNSBpbmRpY2VzIGFyZSBhbGxvd2VkLicpXG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1cblxuICBfcmVzZXREZWZhdWx0cygpIHtcbiAgICB0aGlzLmFjY291bnRzID0gW107XG4gICAgdGhpcy5hY2NvdW50SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuYWNjb3VudE9wdHMgPSBbXTtcbiAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICB0aGlzLmNyZWRzID0ge1xuICAgICAgZGV2aWNlSUQ6IG51bGwsXG4gICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgIGVuZHBvaW50OiBudWxsLFxuICAgIH07XG4gICAgdGhpcy53YWxsZXRVSUQgPSBudWxsO1xuICAgIHRoaXMuc2RrU2Vzc2lvbiA9IG51bGw7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDA7XG4gICAgdGhpcy5uZXR3b3JrID0gbnVsbDtcbiAgICB0aGlzLmhkUGF0aCA9IFNUQU5EQVJEX0hEX1BBVEg7XG4gIH1cblxuICBhc3luYyBfb3BlbkNvbm5lY3RvclRhYih1cmwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnJvd3NlclRhYiA9IHdpbmRvdy5vcGVuKHVybCk7XG4gICAgICAvLyBQcmVmZXJyZWQgb3B0aW9uIGZvciBDaHJvbWl1bSBicm93c2Vycy4gVGhpcyBleHRlbnNpb24gcnVucyBpbiBhIHdpbmRvd1xuICAgICAgLy8gZm9yIENocm9taXVtIHNvIHdlIGNhbiBkbyB3aW5kb3ctYmFzZWQgY29tbXVuaWNhdGlvbiB2ZXJ5IGVhc2lseS5cbiAgICAgIGlmIChicm93c2VyVGFiKSB7XG4gICAgICAgIHJldHVybiB7IGNocm9taXVtOiBicm93c2VyVGFiIH07XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci50YWJzICYmIGJyb3dzZXIudGFicy5jcmVhdGUpIHtcbiAgICAgICAgLy8gRmlyZUZveCBleHRlbnNpb25zIGRvIG5vdCBydW4gaW4gd2luZG93cywgc28gaXQgd2lsbCByZXR1cm4gYG51bGxgIGZyb21cbiAgICAgICAgLy8gYHdpbmRvdy5vcGVuYC4gSW5zdGVhZCwgd2UgbmVlZCB0byB1c2UgdGhlIGBicm93c2VyYCBBUEkgdG8gb3BlbiBhIHRhYi5cbiAgICAgICAgLy8gV2Ugd2lsbCBzdXJ2ZWlsbGUgdGhpcyB0YWIgdG8gc2VlIGlmIGl0cyBVUkwgcGFyYW1ldGVycyBjaGFuZ2UsIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgaW5kaWNhdGUgdGhhdCB0aGUgdXNlciBoYXMgbG9nZ2VkIGluLlxuICAgICAgICBjb25zdCB0YWIgPSBhd2FpdCBicm93c2VyLnRhYnMuY3JlYXRlKHt1cmx9KVxuICAgICAgICByZXR1cm4geyBmaXJlZm94OiB0YWIgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBicm93c2VyIGNvbnRleHQuIENhbm5vdCBvcGVuIExhdHRpY2UgY29ubmVjdG9yLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gb3BlbiBMYXR0aWNlIGNvbm5lY3Rvci4nKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZmluZFRhYkJ5SWQoaWQpIHtcbiAgICBjb25zdCB0YWJzID0gYXdhaXQgYnJvd3Nlci50YWJzLnF1ZXJ5KHt9KTtcbiAgICByZXR1cm4gdGFicy5maW5kKCh0YWIpID0+IHRhYi5pZCA9PT0gaWQpO1xuICB9XG5cbiAgX2dldENyZWRzKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gc2V0dXAgaWYgd2UgZG9uJ3QgaGF2ZSBhIGRldmljZUlEXG4gICAgICBpZiAodGhpcy5faGFzQ3JlZHMoKSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIC8vIElmIHdlIGFyZSBub3QgYXdhcmUgb2Ygd2hhdCBMYXR0aWNlIHdlIHNob3VsZCBiZSB0YWxraW5nIHRvLFxuICAgICAgLy8gd2UgbmVlZCB0byBvcGVuIGEgd2luZG93IHRoYXQgbGV0cyB0aGUgdXNlciBnbyB0aHJvdWdoIHRoZVxuICAgICAgLy8gcGFpcmluZyBvciBjb25uZWN0aW9uIHByb2Nlc3MuXG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5hcHBOYW1lID8gdGhpcy5hcHBOYW1lIDogJ1Vua25vd24nXG4gICAgICBjb25zdCBiYXNlID0gJ2h0dHBzOi8vbGF0dGljZS5ncmlkcGx1cy5pbyc7XG4gICAgICBjb25zdCB1cmwgPSBgJHtiYXNlfT9rZXlyaW5nPSR7bmFtZX0mZm9yY2VMb2dpbj10cnVlYDtcbiAgICAgIGxldCBsaXN0ZW5JbnRlcnZhbDtcblxuICAgICAgLy8gUG9zdE1lc3NhZ2UgaGFuZGxlclxuICAgICAgZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgLy8gRW5zdXJlIG9yaWdpblxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBiYXNlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTdG9wIHRoZSBsaXN0ZW5lclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwobGlzdGVuSW50ZXJ2YWwpO1xuICAgICAgICAgIC8vIFBhcnNlIGFuZCByZXR1cm4gY3JlZHNcbiAgICAgICAgICBjb25zdCBjcmVkcyA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgaWYgKCFjcmVkcy5kZXZpY2VJRCB8fCAhY3JlZHMucGFzc3dvcmQpXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBjcmVkZW50aWFscyByZXR1cm5lZCBmcm9tIExhdHRpY2UuJykpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGNyZWRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9wZW4gdGhlIHRhYlxuICAgICAgdGhpcy5fb3BlbkNvbm5lY3RvclRhYih1cmwpXG4gICAgICAudGhlbigoY29ubikgPT4ge1xuICAgICAgICBpZiAoY29ubi5jaHJvbWl1bSkge1xuICAgICAgICAgIC8vIE9uIGEgQ2hyb21pdW0gYnJvd3NlciB3ZSBjYW4ganVzdCBsaXN0ZW4gZm9yIGEgd2luZG93IG1lc3NhZ2VcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVjZWl2ZU1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgICAvLyBXYXRjaCBmb3IgdGhlIG9wZW4gd2luZG93IGNsb3NpbmcgYmVmb3JlIGNyZWRzIGFyZSBzZW50IGJhY2tcbiAgICAgICAgICBsaXN0ZW5JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25uLmNocm9taXVtLmNsb3NlZCkge1xuICAgICAgICAgICAgICBjbGVhckludGVydmFsKGxpc3RlbkludGVydmFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0xhdHRpY2UgY29ubmVjdG9yIGNsb3NlZC4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25uLmZpcmVmb3gpIHtcbiAgICAgICAgICAvLyBGb3IgRmlyZWZveCB3ZSBjYW5ub3QgdXNlIGB3aW5kb3dgIGluIHRoZSBleHRlbnNpb24gYW5kIGNhbid0XG4gICAgICAgICAgLy8gZGlyZWN0bHkgY29tbXVuaWNhdGUgd2l0aCB0aGUgdGFicyB2ZXJ5IGVhc2lseSBzbyB3ZSB1c2UgYVxuICAgICAgICAgIC8vIHdvcmthcm91bmQ6IGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgVVJMLCB3aGljaCB3aWxsIGNvbnRhaW5cbiAgICAgICAgICAvLyB0aGUgbG9naW4gaW5mby5cbiAgICAgICAgICAvLyBOT1RFOiBUaGlzIHdpbGwgb25seSB3b3JrIGlmIGhhdmUgYGh0dHBzOi8vbGF0dGljZS5ncmlkcGx1cy5pby8qYFxuICAgICAgICAgIC8vIGhvc3QgcGVybWlzc2lvbnMgaW4geW91ciBtYW5pZmVzdCBmaWxlIChhbmQgYWxzbyBgYWN0aXZlVGFiYCBwZXJtaXNzaW9uKVxuICAgICAgICAgIGNvbnN0IGxvZ2luVXJsUGFyYW0gPSAnJmxvZ2luQ2FjaGU9JztcbiAgICAgICAgICBsaXN0ZW5JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmRUYWJCeUlkKGNvbm4uZmlyZWZveC5pZClcbiAgICAgICAgICAgIC50aGVuKCh0YWIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCF0YWIgfHwgIXRhYi51cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTGF0dGljZSBjb25uZWN0b3IgY2xvc2VkLicpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFiIHdlIG9wZW5lZCBjb250YWlucyBhIG5ldyBVUkwgcGFyYW1cbiAgICAgICAgICAgICAgY29uc3QgcGFyYW1Mb2MgPSB0YWIudXJsLmluZGV4T2YobG9naW5VcmxQYXJhbSk7XG4gICAgICAgICAgICAgIGlmIChwYXJhbUxvYyA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhTG9jID0gcGFyYW1Mb2MgKyBsb2dpblVybFBhcmFtLmxlbmd0aDtcbiAgICAgICAgICAgICAgLy8gU3RvcCB0aGlzIGludGVydmFsXG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobGlzdGVuSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBsb2dpbiBkYXRhLiBJdCBpcyBhIHN0cmluZ2lmaWVkIEpTT04gb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlZCBhcyBhIGJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgY29uc3QgX2NyZWRzID0gQnVmZmVyLmZyb20odGFiLnVybC5zbGljZShkYXRhTG9jKSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIHRhYiBhbmQgcmV0dXJuIHRoZSBjcmVkZW50aWFsc1xuICAgICAgICAgICAgICAgIGJyb3dzZXIudGFicy5yZW1vdmUodGFiLmlkKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNyZWRzID0gSlNPTi5wYXJzZShfY3JlZHMpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjcmVkcy5kZXZpY2VJRCB8fCAhY3JlZHMucGFzc3dvcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzIHJldHVybmVkIGZyb20gTGF0dGljZS4nKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjcmVkcyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnRmFpbGVkIHRvIGdldCBsb2dpbiBkYXRhIGZyb20gTGF0dGljZS4gUGxlYXNlIHRyeSBhZ2Fpbi4nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIFtyZV1jb25uZWN0IHRvIHRoZSBMYXR0aWNlLiBUaGlzIHNob3VsZCBiZSBkb25lIGZyZXF1ZW50bHkgdG8gZW5zdXJlXG4gIC8vIHRoZSBleHBlY3RlZCB3YWxsZXQgVUlEIGlzIHN0aWxsIHRoZSBvbmUgYWN0aXZlIGluIHRoZSBMYXR0aWNlLlxuICAvLyBUaGlzIHdpbGwgaGFuZGxlIFNhZmVDYXJkIGluc2VydGlvbi9yZW1vdmFsIGV2ZW50cy5cbiAgYXN5bmMgX2Nvbm5lY3QgKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGNvbm5lY3Qgd2l0aCBhIExhdHRpY2UgdXNpbmcgYSBzaG9ydGVyIHRpbWVvdXQuIElmXG4gICAgICAvLyB0aGUgZGV2aWNlIGlzIHVucGx1Z2dlZCBpdCB3aWxsIHRpbWUgb3V0IGFuZCB3ZSBkb24ndCBuZWVkIHRvIHdhaXRcbiAgICAgIC8vIDIgbWludXRlcyBmb3IgdGhhdCB0byBoYXBwZW4uXG4gICAgICB0aGlzLnNka1Nlc3Npb24udGltZW91dCA9IENPTk5FQ1RfVElNRU9VVDtcbiAgICAgIHJldHVybiB0aGlzLnNka1Nlc3Npb24uY29ubmVjdCh0aGlzLmNyZWRzLmRldmljZUlEKVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZXNldCB0byBub3JtYWwgdGltZW91dCBubyBtYXR0ZXIgd2hhdFxuICAgICAgdGhpcy5zZGtTZXNzaW9uLnRpbWVvdXQgPSBTREtfVElNRU9VVDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfaW5pdFNlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNVbmxvY2tlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB1cmwgPSAnaHR0cHM6Ly9zaWduaW5nLmdyaWRwbC51cyc7XG4gICAgaWYgKHRoaXMuY3JlZHMuZW5kcG9pbnQpXG4gICAgICB1cmwgPSB0aGlzLmNyZWRzLmVuZHBvaW50XG4gICAgbGV0IHNldHVwRGF0YSA9IHtcbiAgICAgIG5hbWU6IHRoaXMuYXBwTmFtZSxcbiAgICAgIGJhc2VVcmw6IHVybCxcbiAgICAgIHRpbWVvdXQ6IFNES19USU1FT1VULFxuICAgICAgcHJpdktleTogdGhpcy5fZ2VuU2Vzc2lvbktleSgpLFxuICAgICAgbmV0d29yazogdGhpcy5uZXR3b3JrLFxuICAgICAgc2tpcFJldHJ5T25Xcm9uZ1dhbGxldDogdHJ1ZSxcbiAgICB9O1xuICAgIC8qXG4gICAgTk9URTogV2UgbmVlZCBzdGF0ZSB0byBhY3R1YWxseSBiZSBzeW5jZWQgYnkgTWV0YU1hc2sgb3Igd2UgY2FuJ3RcbiAgICB1c2UgdGhpcy4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svS2V5cmluZ0NvbnRyb2xsZXIvaXNzdWVzLzEzMFxuXG4gICAgaWYgKHRoaXMuc2RrU3RhdGUpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgc3RhdGUgZGF0YSB3ZSBjYW4gZnVsbHkgcmVoeWRyYXRlIHRoZSBzZXNzaW9uLlxuICAgICAgc2V0dXBEYXRhID0ge1xuICAgICAgICBzdGF0ZURhdGE6IHRoaXMuc2RrU3RhdGUsXG4gICAgICAgIHNraXBSZXRyeU9uV3JvbmdXYWxsZXQ6IHRydWUsXG4gICAgICB9XG4gICAgfVxuICAgICovXG4gICAgdGhpcy5zZGtTZXNzaW9uID0gbmV3IFNESy5DbGllbnQoc2V0dXBEYXRhKTtcbiAgICAvLyBSZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB3ZSBwcm92aWRlZCBzdGF0ZSBkYXRhLlxuICAgIC8vIElmIHdlIGhhdmUsIHdlIGNhbiBza2lwIGBjb25uZWN0YC5cbiAgICByZXR1cm4gISFzZXR1cERhdGEuc3RhdGVEYXRhO1xuICB9XG5cbiAgYXN5bmMgX2ZldGNoQWRkcmVzc2VzKG49MSwgaT0wLCByZWN1cnNlZEFkZHJzPVtdKSB7XG4gICAgaWYgKCF0aGlzLmlzVW5sb2NrZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb25uZWN0aW9uIHRvIExhdHRpY2UuIENhbm5vdCBmZXRjaCBhZGRyZXNzZXMuJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19mZXRjaEFkZHJlc3NlcyhuLCBpKTtcbiAgfVxuXG4gIGFzeW5jIF9fZmV0Y2hBZGRyZXNzZXMobj0xLCBpPTAsIHJlY3Vyc2VkQWRkcnM9W10pIHtcbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBkbyBhIHJlY3Vyc2l2ZSBjYWxsIGhlcmUuIFdlIHByZWZlciBub3QgdG9cbiAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtdWNoIHNsb3dlciwgYnV0IExlZGdlciBwYXRocyByZXF1aXJlIGl0IHNpbmNlXG4gICAgLy8gdGhleSBhcmUgbm9uLXN0YW5kYXJkLlxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gcmVjdXJzZWRBZGRycztcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkUmVjdXJzZSA9IHRoaXMuX2hkUGF0aEhhc0ludGVybmFsVmFySWR4KCk7XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0IHRvIGdldCB0aGUgcmVxdWVzdGVkIGFkZHJlc3NcbiAgICBjb25zdCBhZGRyRGF0YSA9IHtcbiAgICAgIGN1cnJlbmN5OiAnRVRIJyxcbiAgICAgIHN0YXJ0UGF0aDogdGhpcy5fZ2V0SERQYXRoSW5kaWNlcyh0aGlzLmhkUGF0aCwgaSksXG4gICAgICBuOiBzaG91bGRSZWN1cnNlID8gMSA6IG4sXG4gICAgfTtcbiAgICBjb25zdCBhZGRycyA9IGF3YWl0IHRoaXMuc2RrU2Vzc2lvbi5nZXRBZGRyZXNzZXMoYWRkckRhdGEpO1xuICAgIC8vIFNhbml0eSBjaGVjayAtLSBpZiB0aGlzIHJldHVybmVkIDAgYWRkcmVzc2VzLCBoYW5kbGUgdGhlIGVycm9yXG4gICAgaWYgKGFkZHJzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWRkcmVzc2VzIHJldHVybmVkJyk7XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgYWRkcmVzc2VzIHdlIGZldGNoZWQgKndpdGhvdXQqIHVwZGF0aW5nIHN0YXRlXG4gICAgaWYgKHNob3VsZFJlY3Vyc2UpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9fZmV0Y2hBZGRyZXNzZXMobi0xLCBpKzEsIHJlY3Vyc2VkQWRkcnMuY29uY2F0KGFkZHJzKSk7XG4gICAgfVxuICAgIHJldHVybiBhZGRycztcbiAgfVxuXG4gIGFzeW5jIF9nZXRQYWdlKGluY3JlbWVudD0wKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnQ7XG4gICAgICBpZiAodGhpcy5wYWdlIDwgMClcbiAgICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gUEVSX1BBR0UgKiB0aGlzLnBhZ2U7XG4gICAgICAvLyBPdGhlcndpc2UgdW5sb2NrIHRoZSBkZXZpY2UgYW5kIGZldGNoIG1vcmUgYWRkcmVzc2VzXG4gICAgICBhd2FpdCB0aGlzLnVubG9jaygpXG4gICAgICBjb25zdCBhZGRycyA9IGF3YWl0IHRoaXMuX2ZldGNoQWRkcmVzc2VzKFBFUl9QQUdFLCBzdGFydClcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYWRkcnMubWFwKChhZGRyZXNzLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICAgIGluZGV4OiBzdGFydCArIGksXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBnZXQgaGl0IGZvciBhIGZldyByZWFzb25zLiBIZXJlIGFyZSB0d28gcG9zc2liaWxpdGllczpcbiAgICAgIC8vIDEuIFRoZSB1c2VyIGhhcyBhIFNhZmVDYXJkIGluc2VydGVkLCBidXQgbm90IHVubG9ja2VkXG4gICAgICAvLyAyLiBUaGUgdXNlciBmZXRjaGVkIGEgcGFnZSBmb3IgYSBkaWZmZXJlbnQgd2FsbGV0LCB0aGVuIHN3aXRjaGVkXG4gICAgICAvLyAgICBpbnRlcmZhY2Ugb24gdGhlIGRldmljZVxuICAgICAgLy8gSW4gZWl0aGVyIGV2ZW50IHdlIHNob3VsZCB0cnkgdG8gcmVzeW5jIHRoZSB3YWxsZXQgYW5kIGlmIHRoYXRcbiAgICAgIC8vIGZhaWxzIHRocm93IGFuIGVycm9yXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpc1BhaXJlZCA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKCFpc1BhaXJlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UX1BBSVJFRCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5fZ2V0UGFnZSgwKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmFjY291bnRzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgICAgdGhpcy5mb3JnZXREZXZpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgYWNjb3VudHMuIFBsZWFzZSBmb3JnZXQgdGhlIGRldmljZSBhbmQgdHJ5IGFnYWluLiAnICtcbiAgICAgICAgICAnTWFrZSBzdXJlIHlvdSBkbyBub3QgaGF2ZSBhIGxvY2tlZCBTYWZlQ2FyZCBpbnNlcnRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhc0NyZWRzKCkge1xuICAgIHJldHVybiB0aGlzLmNyZWRzLmRldmljZUlEICE9PSBudWxsICYmIHRoaXMuY3JlZHMucGFzc3dvcmQgIT09IG51bGwgJiYgdGhpcy5hcHBOYW1lO1xuICB9XG5cbiAgX2dlblNlc3Npb25LZXkoKSB7XG4gICAgaWYgKHRoaXMubmFtZSAmJiAhdGhpcy5hcHBOYW1lKSAvLyBNaWdyYXRlIGZyb20gbGVnYWN5IHBhcmFtIGlmIG5lZWRlZFxuICAgICAgdGhpcy5hcHBOYW1lID0gdGhpcy5uYW1lO1xuICAgIGlmICghdGhpcy5faGFzQ3JlZHMoKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY3JlZGVudGlhbHMgLS0gY2Fubm90IGNyZWF0ZSBzZXNzaW9uIGtleSEnKTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJ1ZmZlci5mcm9tKHRoaXMuY3JlZHMucGFzc3dvcmQpLFxuICAgICAgQnVmZmVyLmZyb20odGhpcy5jcmVkcy5kZXZpY2VJRCksXG4gICAgICBCdWZmZXIuZnJvbSh0aGlzLmFwcE5hbWUpXG4gICAgXSlcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGFuIEhEIHBhdGggaGFzIGEgdmFyaWFibGUgaW5kZXggaW50ZXJuYWwgdG8gaXQuXG4gIC8vIGUuZy4gbS80NCcvNjAnL3gnLzAvMCAtPiB0cnVlLCB3aGlsZSBtLzQ0Jy82MCcvMCcvMC94IC0+IGZhbHNlXG4gIC8vIFRoaXMgaXMganVzdCBhIGhhY2t5IGhlbHBlciB0byBhdm9pZCBoYXZpbmcgdG8gcmVjdXJzaXZlbHkgY2FsbCBmb3Igbm9uLWxlZGdlclxuICAvLyBkZXJpdmF0aW9uIHBhdGhzLiBMZWRnZXIgaXMgU08gQU5OT1lJTkcgVE8gU1VQUE9SVC5cbiAgX2hkUGF0aEhhc0ludGVybmFsVmFySWR4KCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmhkUGF0aC5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLTE7IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0uaW5kZXhPZigneCcpID4gLTEpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfZ2V0Q3VycmVudFdhbGxldFVJRCgpIHtcbiAgICBpZiAoIXRoaXMuc2RrU2Vzc2lvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVdhbGxldCA9IHRoaXMuc2RrU2Vzc2lvbi5nZXRBY3RpdmVXYWxsZXQoKTtcbiAgICBpZiAoIWFjdGl2ZVdhbGxldCB8fCAhYWN0aXZlV2FsbGV0LnVpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVXYWxsZXQudWlkLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxufVxuXG4vLyAtLS0tLVxuLy8gSEVMUEVSU1xuLy8gLS0tLS1cbmZ1bmN0aW9uIGdldFR4Q2hhaW5JZCAodHgpIHtcbiAgaWYgKHR4ICYmIHR4LmNvbW1vbiAmJiB0eXBlb2YgdHguY29tbW9uLmNoYWluSWRCTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eC5jb21tb24uY2hhaW5JZEJOKCk7XG4gIH0gZWxzZSBpZiAodHggJiYgdHguY2hhaW5JZCkge1xuICAgIHJldHVybiBuZXcgQk4odHguY2hhaW5JZCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCTigxKTtcbn1cblxuLy8gTGVnYWN5IHZlcnNpb25zIG9mIExhdHRpY2UgZmlybXdhcmUgc2lnbmVkIEVUSCB0cmFuc2FjdGlvbnMgb3V0IG9mXG4vLyBhIG5vdyBkZXByZWNhdGVkIHBhdGh3YXkuIFRoZSByZXF1ZXN0IGRhdGEgaXMgYnVpbHQgYnkgdGhpcyBoZWxwZXIuXG5mdW5jdGlvbiBnZXRMZWdhY3lUeFJlcSAodHgpIHtcbiAgbGV0IHR4RGF0YTtcbiAgdHJ5IHtcbiAgICB0eERhdGEgPSB7XG4gICAgICBub25jZTogYDB4JHt0eC5ub25jZS50b1N0cmluZygnaGV4Jyl9YCB8fCAwLFxuICAgICAgZ2FzTGltaXQ6IGAweCR7dHguZ2FzTGltaXQudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgICB0bzogISF0eC50byA/IHR4LnRvLnRvU3RyaW5nKCdoZXgnKSA6IG51bGwsIC8vIG51bGwgZm9yIGNvbnRyYWN0IGRlcGxveW1lbnRzXG4gICAgICB2YWx1ZTogYDB4JHt0eC52YWx1ZS50b1N0cmluZygnaGV4Jyl9YCxcbiAgICAgIGRhdGE6IHR4LmRhdGEubGVuZ3RoID09PSAwID8gbnVsbCA6IGAweCR7dHguZGF0YS50b1N0cmluZygnaGV4Jyl9YCxcbiAgICB9XG4gICAgc3dpdGNoICh0eC5fdHlwZSkge1xuICAgICAgY2FzZSAyOiAvLyBlaXAxNTU5XG4gICAgICAgIGlmICgodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09IG51bGwgfHwgdHgubWF4RmVlUGVyR2FzID09PSBudWxsKSB8fFxuICAgICAgICAgICAgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09PSB1bmRlZmluZWQgfHwgdHgubWF4RmVlUGVyR2FzID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG1heFByaW9yaXR5RmVlUGVyR2FzYCBhbmQgYG1heEZlZVBlckdhc2AgbXVzdCBiZSBpbmNsdWRlZCBmb3IgRUlQMTU1OSB0cmFuc2FjdGlvbnMuJyk7XG4gICAgICAgIHR4RGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGAweCR7dHgubWF4UHJpb3JpdHlGZWVQZXJHYXMudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgICAgIHR4RGF0YS5tYXhGZWVQZXJHYXMgPSBgMHgke3R4Lm1heEZlZVBlckdhcy50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgdHhEYXRhLmFjY2Vzc0xpc3QgPSB0eC5hY2Nlc3NMaXN0IHx8IFtdO1xuICAgICAgICB0eERhdGEudHlwZSA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOiAvLyBlaXAyOTMwXG4gICAgICAgIHR4RGF0YS5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdCB8fCBbXTtcbiAgICAgICAgdHhEYXRhLmdhc1ByaWNlID0gYDB4JHt0eC5nYXNQcmljZS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgdHhEYXRhLnR5cGUgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGxlZ2FjeVxuICAgICAgICB0eERhdGEuZ2FzUHJpY2UgPSBgMHgke3R4Lmdhc1ByaWNlLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgICB0eERhdGEudHlwZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYnVpbGQgdHJhbnNhY3Rpb24uYClcbiAgfVxuICByZXR1cm4gdHhEYXRhO1xufVxuXG5hc3luYyBmdW5jdGlvbiBodHRwUmVxdWVzdCAodXJsKSB7XG4gIGNvbnN0IHJlc3AgPSBhd2FpdCB3aW5kb3cuZmV0Y2godXJsKTtcbiAgaWYgKHJlc3Aub2spIHtcbiAgICByZXR1cm4gYXdhaXQgcmVzcC50ZXh0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbWFrZSByZXF1ZXN0OiAnLCByZXNwLnN0YXR1cyk7XG4gIH1cbn1cblxuTGF0dGljZUtleXJpbmcudHlwZSA9IGtleXJpbmdUeXBlXG5tb2R1bGUuZXhwb3J0cyA9IExhdHRpY2VLZXlyaW5nOyIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQnVmZmVyID0gd2luZG93LkJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbbnVtYmVyICYgMHgzZmZmZmZmXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIC8vICcwJyAtICc5J1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHtcbiAgICAgIHJldHVybiBjIC0gNDg7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgfSBlbHNlIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgIHJldHVybiBjIC0gNTU7XG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG4gICAgICByZXR1cm4gYyAtIDg3O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdJbnZhbGlkIGNoYXJhY3RlciBpbiAnICsgc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgYiA9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgYiA9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gYztcbiAgICAgIH1cbiAgICAgIGFzc2VydChjID49IDAgJiYgYiA8IG11bCwgJ0ludmFsaWQgY2hhcmFjdGVyJyk7XG4gICAgICByICs9IGI7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1vdmUgKGRlc3QsIHNyYykge1xuICAgIGRlc3Qud29yZHMgPSBzcmMud29yZHM7XG4gICAgZGVzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSBzcmMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSBzcmMucmVkO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gX21vdmUgKGRlc3QpIHtcbiAgICBtb3ZlKGRlc3QsIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIENoZWNrIFN5bWJvbC5mb3IgYmVjYXVzZSBub3QgZXZlcnl3aGVyZSB3aGVyZSBTeW1ib2wgZGVmaW5lZFxuICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgQk4ucHJvdG90eXBlW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gaW5zcGVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kcm4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYsIDIpO1xuICB9O1xuXG4gIGlmIChCdWZmZXIpIHtcbiAgICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZSAoQXJyYXlUeXBlLCBzaXplKSB7XG4gICAgaWYgKEFycmF5VHlwZS5hbGxvY1Vuc2FmZSkge1xuICAgICAgcmV0dXJuIEFycmF5VHlwZS5hbGxvY1Vuc2FmZShzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoc2l6ZSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdmFyIHJlcyA9IGFsbG9jYXRlKEFycmF5VHlwZSwgcmVxTGVuZ3RoKTtcbiAgICB2YXIgcG9zdGZpeCA9IGVuZGlhbiA9PT0gJ2xlJyA/ICdMRScgOiAnQkUnO1xuICAgIHRoaXNbJ190b0FycmF5TGlrZScgKyBwb3N0Zml4XShyZXMsIGJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlTEUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24rK10gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VCRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUJFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSByZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gPj4+IHdiaXQpICYgMHgwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICAvLyBUZW1wb3JhcnkgZGlzYWJsZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL2lzc3Vlcy8yMTFcbiAgICAvLyB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgLy8gcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gICAgcmV0dXJuIGJpZ011bFRvKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDw9IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5fc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuX3N0cmlwKCk7XG4gICAgfVxuICAgIGEuX3N0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IChyMiA9PT0gMSAmJiBjbXAgPT09IDApKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RybiA9IGZ1bmN0aW9uIG1vZHJuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IC1hY2MgOiBhY2M7XG4gIH07XG5cbiAgLy8gV0FSTklORzogREVQUkVDQVRFRFxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLm1vZHJuKG51bSk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIuc3RyaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjQgaW5zdGFuY2VcbiAgICAgICAgci5zdHJpcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICBtb3ZlKGEsIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbHMgPSBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuLyoqXG4gKiBSTFAgRW5jb2RpbmcgYmFzZWQgb24gaHR0cHM6Ly9ldGgud2lraS9lbi9mdW5kYW1lbnRhbHMvcmxwXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIGRhdGEsIGNvbnZlcnRzIGl0IHRvIFVpbnQ4QXJyYXkgaWYgbm90LFxuICogYW5kIGFkZHMgYSBsZW5ndGggZm9yIHJlY3Vyc2lvbi5cbiAqIEBwYXJhbSBpbnB1dCBXaWxsIGJlIGNvbnZlcnRlZCB0byBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBVaW50OEFycmF5IG9mIGVuY29kZWQgZGF0YVxuICoqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGUoaW5wdXRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBjb25jYXRCeXRlcyguLi5vdXRwdXQpO1xuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKGJ1Zi5sZW5ndGgsIDE5MiksIGJ1Zik7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0QnVmID0gdG9CeXRlcyhpbnB1dCk7XG4gICAgaWYgKGlucHV0QnVmLmxlbmd0aCA9PT0gMSAmJiBpbnB1dEJ1ZlswXSA8IDEyOCkge1xuICAgICAgICByZXR1cm4gaW5wdXRCdWY7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRCeXRlcyhlbmNvZGVMZW5ndGgoaW5wdXRCdWYubGVuZ3RoLCAxMjgpLCBpbnB1dEJ1Zik7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogU2xpY2VzIGEgVWludDhBcnJheSwgdGhyb3dzIGlmIHRoZSBzbGljZSBnb2VzIG91dC1vZi1ib3VuZHMgb2YgdGhlIFVpbnQ4QXJyYXkuXG4gKiBFLmcuIGBzYWZlU2xpY2UoaGV4VG9CeXRlcygnYWEnKSwgMSwgMilgIHdpbGwgdGhyb3cuXG4gKiBAcGFyYW0gaW5wdXRcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICovXG5mdW5jdGlvbiBzYWZlU2xpY2UoaW5wdXQsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZW5kID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFAgKHNhZmVTbGljZSk6IGVuZCBzbGljZSBvZiBVaW50OEFycmF5IG91dC1vZi1ib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuLyoqXG4gKiBQYXJzZSBpbnRlZ2Vycy4gQ2hlY2sgaWYgdGhlcmUgaXMgbm8gbGVhZGluZyB6ZXJvc1xuICogQHBhcmFtIHYgVGhlIHZhbHVlIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aCh2KSB7XG4gICAgaWYgKHZbMF0gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXh0cmEgemVyb3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSGV4Qnl0ZShieXRlc1RvSGV4KHYpKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChsZW4sIG9mZnNldCkge1xuICAgIGlmIChsZW4gPCA1Nikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtsZW4gKyBvZmZzZXRdKTtcbiAgICB9XG4gICAgY29uc3QgaGV4TGVuZ3RoID0gbnVtYmVyVG9IZXgobGVuKTtcbiAgICBjb25zdCBsTGVuZ3RoID0gaGV4TGVuZ3RoLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gbnVtYmVyVG9IZXgob2Zmc2V0ICsgNTUgKyBsTGVuZ3RoKTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGhleFRvQnl0ZXMoZmlyc3RCeXRlICsgaGV4TGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQsIHN0cmVhbSA9IGZhbHNlKSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0Qnl0ZXMgPSB0b0J5dGVzKGlucHV0KTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShpbnB1dEJ5dGVzKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5yZW1haW5kZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IHJlbWFpbmRlciBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuZGF0YTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqIERlY29kZSBhbiBpbnB1dCB3aXRoIFJMUCAqL1xuZnVuY3Rpb24gX2RlY29kZShpbnB1dCkge1xuICAgIGxldCBsZW5ndGgsIGxsZW5ndGgsIGRhdGEsIGlubmVyUmVtYWluZGVyLCBkO1xuICAgIGNvbnN0IGRlY29kZWQgPSBbXTtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBpbnB1dFswXTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyAwLTU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB2YWx1ZSAweDgwIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmO1xuICAgICAgICAvLyBzZXQgMHg4MCBudWxsIHRvIDBcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFAgZW5jb2Rpbmc6IGludmFsaWQgcHJlZml4LCBzaW5nbGUgYnl0ZSA8IDB4ODAgYXJlIG5vdCBwcmVmaXhlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgICAgICAvLyBzdHJpbmcgaXMgZ3JlYXRlciB0aGFuIDU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB0aGUgdmFsdWUgKDB4YjcgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBsZW5ndGgpLFxuICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoLCBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGI2O1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIC0gMSA8IGxsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IG5vdCBlbm91Z2ggYnl0ZXMgZm9yIHN0cmluZyBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4cGVjdGVkIHN0cmluZyBsZW5ndGggdG8gYmUgZ3JlYXRlciB0aGFuIDU1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgbGVuZ3RoICsgbGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAgICAgLy8gYSBsaXN0IGJldHdlZW4gMC01NSBieXRlcyBsb25nXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YmY7XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhIGxpc3Qgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPCA1Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZW5jb2RlZCBsaXN0IHRvbyBzaG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gbGxlbmd0aCArIGxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiB0b3RhbCBsZW5ndGggaXMgbGFyZ2VyIHRoYW4gdGhlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclJlbWFpbmRlciA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgdG90YWxMZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCBjYWNoZWRIZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBQcmUtY2FjaGluZyBjaGFycyB3aXRoIGBjYWNoZWRIZXhlc2Agc3BlZWRzIHRoaXMgdXAgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGNhY2hlZEhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBwYXJzZUhleEJ5dGUoaGV4Qnl0ZSkge1xuICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgcmV0dXJuIGJ5dGU7XG59XG4vLyBDYWNoaW5nIHNsb3dzIGl0IGRvd24gMi0zeFxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgYXJyYXlbaV0gPSBwYXJzZUhleEJ5dGUoaGV4LnNsaWNlKGosIGogKyAyKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKiBDb25jYXRlbmF0ZXMgdHdvIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHV0Zikge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodXRmKTtcbn1cbi8qKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGl0cyBoZXhhZGVjaW1hbCB2YWx1ZSAqL1xuZnVuY3Rpb24gbnVtYmVyVG9IZXgoaW50ZWdlcikge1xuICAgIGlmIChpbnRlZ2VyIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBhcyBhcmd1bWVudCwgbXVzdCBiZSB1bnNpZ25lZCEnKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gaW50ZWdlci50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJSAyID8gYDAke2hleH1gIDogaGV4O1xufVxuLyoqIFBhZCBhIHN0cmluZyB0byBiZSBldmVuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4oYSkge1xuICAgIHJldHVybiBhLmxlbmd0aCAlIDIgPyBgMCR7YX1gIDogYTtcbn1cbi8qKiBDaGVjayBpZiBhIHN0cmluZyBpcyBwcmVmaXhlZCBieSAweCAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSAyICYmIHN0clswXSA9PT0gJzAnICYmIHN0clsxXSA9PT0gJ3gnO1xufVxuLyoqIFJlbW92ZXMgMHggZnJvbSBhIGdpdmVuIFN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4vKiogVHJhbnNmb3JtIGFueXRoaW5nIGludG8gYSBVaW50OEFycmF5ICovXG5mdW5jdGlvbiB0b0J5dGVzKHYpIHtcbiAgICBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlzSGV4UHJlZml4ZWQodikpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleCh2KSk7XG4gICAgfVxuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b0J5dGVzOiByZWNlaXZlZCB1bnN1cHBvcnRlZCB0eXBlICcgKyB0eXBlb2Ygdik7XG59XG5leHBvcnRzLnV0aWxzID0ge1xuICAgIGJ5dGVzVG9IZXgsXG4gICAgY29uY2F0Qnl0ZXMsXG4gICAgaGV4VG9CeXRlcyxcbiAgICB1dGY4VG9CeXRlcyxcbn07XG5jb25zdCBSTFAgPSB7IGVuY29kZSwgZGVjb2RlIH07XG5leHBvcnRzLmRlZmF1bHQgPSBSTFA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwidmVyc2lvblwiOiAyLFxuICBcInRvbGVyYW5jZVwiOiAyLFxuICBcImZ1enp5bGlzdFwiOiBbXG4gICAgXCJhdWN0dXMub3JnXCIsXG4gICAgXCJjcnlwdG9raXR0aWVzLmNvXCIsXG4gICAgXCJkZmluaXR5Lm9yZ1wiLFxuICAgIFwibGF1bmNocGFkLmV0aGVyZXVtLm9yZ1wiLFxuICAgIFwiZXRoZXJzY2FuLmlvXCIsXG4gICAgXCJmdWxjcnVtLnRyYWRlXCIsXG4gICAgXCJoZWRlcmFoYXNoZ3JhcGguY29tXCIsXG4gICAgXCJsb2NhbGNyeXB0b3MuY29tXCIsXG4gICAgXCJsb2NhbGV0aGVyZXVtLmNvbVwiLFxuICAgIFwibWFrZXJmb3VuZGF0aW9uLmNvbVwiLFxuICAgIFwibWFza21ldGEub3JnXCIsXG4gICAgXCJtZXRhbWFzay5pb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm9wZW5zZWEuaW9cIixcbiAgICBcIm9yaWdpbnByb3RvY29sLmNvbVwiXG4gIF0sXG4gIFwid2hpdGVsaXN0XCI6IFtcbiAgICBcImF1Y3RpYy5uZXRcIixcbiAgICBcIm1ldGF2YXMuY29tXCIsXG4gICAgXCJvcGVud2Vhci5wbFwiLFxuICAgIFwiYWZ0dXMuaW9cIixcbiAgICBcIm9wZW5kZW0uaW5mb1wiLFxuICAgIFwicGVhbnNlYS5zdG9yZVwiLFxuICAgIFwiaWZpbnR5Lm5sXCIsXG4gICAgXCJhcnR1cy5jb21cIixcbiAgICBcImF1a3VzLmZyXCIsXG4gICAgXCJmdWxjcnVtd3AuY29tXCIsXG4gICAgXCJvcGVuc2kubmV0XCIsXG4gICAgXCJ4YWN0dXMuY29tXCIsXG4gICAgXCJzcGVuc2VyLnh5elwiLFxuICAgIFwib3BlbnNjYWQuY2xvdWRcIixcbiAgICBcIm9wZW5kZS5maVwiLFxuICAgIFwic3VzaGlndWFyZC5jb21cIixcbiAgICBcInN1c2hpcmVsYXkuY29tXCIsXG4gICAgXCJzdXNoaS5jb21cIixcbiAgICBcIm1ldGFyYW5rLmFpXCIsXG4gICAgXCJ2dWx0dXMub25lXCIsXG4gICAgXCJrbGltYWRhby5maW5hbmNlXCIsXG4gICAgXCI5ZmluaXRlLmNvbVwiLFxuICAgIFwib3BlbmdlbS5jb21cIixcbiAgICBcImluZmluaXR5LmV4Y2hhbmdlXCIsXG4gICAgXCJvdHRlcnNjYW4uaW9cIixcbiAgICBcIm9seW1wdXNkYW8uZmluYW5jZVwiLFxuICAgIFwiYmlmaW5pdHkuY29tXCIsXG4gICAgXCJlZmZpbml0eS5mclwiLFxuICAgIFwib3BlbnNlbmQuY29tXCIsXG4gICAgXCJhcHAuY3J5cHRvYmxhZGVzLmlvXCIsXG4gICAgXCJhdWN0dXNpcS5jb21cIixcbiAgICBcImFydGJsb2Nrcy5pb1wiLFxuICAgIFwiZmluaXRlLmlvXCIsXG4gICAgXCJsYXNtZXRhLmlvXCIsXG4gICAgXCJhY3R1bS5ka1wiLFxuICAgIFwiYWN0dW0uZ2FtZXNcIixcbiAgICBcImFjdHVtLmdyXCIsXG4gICAgXCJhY3R5dXMuY29tXCIsXG4gICAgXCJtZXRhcGFzcy5jbG91ZFwiLFxuICAgIFwibWV0YW1hcnouY29tXCIsXG4gICAgXCJtZXRhbWFyei5pb1wiLFxuICAgIFwib3BlbnNmeC5jb21cIixcbiAgICBcIm1zbWV0YS5mdW5cIixcbiAgICBcIm1ldGFtYXAuY29tXCIsXG4gICAgXCJtZXRhbWFycy5vcmdcIixcbiAgICBcIm1ldGFtYXJzLmFpXCIsXG4gICAgXCJtZXRhZGFzaC5haVwiLFxuICAgIFwic2FuY3R1cy5hdWRpb1wiLFxuICAgIFwiYWZmaW5pdHkuYWRcIixcbiAgICBcImFmZmluaXR5LnJvXCIsXG4gICAgXCJhZmZpbml0eS5zb2x1dGlvbnNcIixcbiAgICBcImFjdGlzLm5vXCIsXG4gICAgXCJhY3Rzcy5jYVwiLFxuICAgIFwiYWN0dXMuYXRcIixcbiAgICBcImFqYXR1cy5pblwiLFxuICAgIFwiYXB0dXMuYWlcIixcbiAgICBcIm5maW5pdC5jb21cIixcbiAgICBcImFyY3VzLm5vXCIsXG4gICAgXCJhcmN0ZXVzLmluXCIsXG4gICAgXCJmaW5jaXR5LnNrXCIsXG4gICAgXCJhc2ttZW50YS5jb21cIixcbiAgICBcImFzdHVzLmFwcFwiLFxuICAgIFwiYXVidHUuYml6XCIsXG4gICAgXCJhdWJ1cy54eXpcIixcbiAgICBcImF1Y3UuZXNcIixcbiAgICBcImF1ZGl1cy5pb1wiLFxuICAgIFwiYXVkaXVzLnBhcnR5XCIsXG4gICAgXCJhdWt0dXMuY29tXCIsXG4gICAgXCJhdWx1cy5vcmdcIixcbiAgICBcImF1bHVzLnh5elwiLFxuICAgIFwiYXV0b3MuaWRcIixcbiAgICBcImF1dG9zLm51XCIsXG4gICAgXCJhdXJldXMuZXVcIixcbiAgICBcImF1cmV1cy5sdGRcIixcbiAgICBcImF1cmV1cy5tb25leVwiLFxuICAgIFwiYXVyb3VzLmNsXCIsXG4gICAgXCJhdS50dHMucnVcIixcbiAgICBcImF2YXR1cy5jb21cIixcbiAgICBcImF2aW5pdHkuY29tXCIsXG4gICAgXCJhdXJvdXMuZmluYW5jZVwiLFxuICAgIFwiYmVmaW5pdHkubWVkaWFcIixcbiAgICBcImJldGEuYXNrLnJpcFwiLFxuICAgIFwiYmV0YXRhc2suY29tXCIsXG4gICAgXCJidWx1cnVtLmNvbVwiLFxuICAgIFwiY3J5cHRvcGF0dGllcy54eXpcIixcbiAgICBcImRlZmluZnR5LmlvXCIsXG4gICAgXCJkaWZpbml0ZS5jb21cIixcbiAgICBcImRpbmlmeS5pb1wiLFxuICAgIFwiZGl2aW5pdHkuY2FcIixcbiAgICBcImRpdmluaXR5LmVzXCIsXG4gICAgXCJkb2luaXRhLmFydFwiLFxuICAgIFwiZWFzeW1ldGEuZnVuXCIsXG4gICAgXCJyZXZpZ28uZmFuY2x1Yi5yb2Nrc1wiLFxuICAgIFwiZmluaXR5LmluXCIsXG4gICAgXCJmaW5pdHR5LmNvbVwiLFxuICAgIFwiZmluaXR5eC5jb21cIixcbiAgICBcImZ1bGNydW0uYWdcIixcbiAgICBcImZ1bGNydW0ub3JnXCIsXG4gICAgXCJmdWxjcnVtNy5jb21cIixcbiAgICBcImZ1bGNydW10eC5jb21cIixcbiAgICBcImZ1bHBydWYuY29tXCIsXG4gICAgXCJodWd0dXMuY29tXCIsXG4gICAgXCJmdmxjcnZtLmNvbVwiLFxuICAgIFwiZnV0dXJ1bS5jbFwiLFxuICAgIFwiZnV0dXJ1bS5zb2Z0d2FyZVwiLFxuICAgIFwiaWZpbml0eS5jaFwiLFxuICAgIFwiY3J5cHRvaG90dGllcy5zcGFjZVwiLFxuICAgIFwiY3J5cHRvcGl0aWVzLmNvbVwiLFxuICAgIFwiY3J5cHRvdGl0dGllcy54eXpcIixcbiAgICBcImN1dHVzLmluXCIsXG4gICAgXCJtZXRhcGFzcy5tbFwiLFxuICAgIFwib3BlbjVlLmNvbVwiLFxuICAgIFwib3BlbmJlZS5jb21cIixcbiAgICBcIm9wZW5iZXRhLndvcmtzXCIsXG4gICAgXCJvcGVuZW8uY2xvdWRcIixcbiAgICBcIm9wZW5lby5vcmdcIixcbiAgICBcIm9wZW5lcy5pb1wiLFxuICAgIFwib3BlbmhlYWQuaW5mb1wiLFxuICAgIFwib3Blbm1ldGEuY2l0eVwiLFxuICAgIFwib3Blbm1ldGEuZmluYW5jZVwiLFxuICAgIFwib3Blbm1ldGEua3JcIixcbiAgICBcIm9wZW5tZXRhLnRyYWRlXCIsXG4gICAgXCJvcGVucG9hLmNvbVwiLFxuICAgIFwib3BlbnNpZy5vcmdcIixcbiAgICBcIm9wZW5zaXQubmV0XCIsXG4gICAgXCJvcGVuc2Vhcy5jb21cIixcbiAgICBcIm9wZW5zZWVzLnByb1wiLFxuICAgIFwibG9va3NyYXJlLm9yZ1wiLFxuICAgIFwib3Blbm1oYS5vcmdcIixcbiAgICBcIm9wZW5yZXMuaW9cIixcbiAgICBcIm9wZW5yZXNhLmNvbVwiLFxuICAgIFwib3BlbnNhdC5jY1wiLFxuICAgIFwib3BlbnNvYy5wbFwiLFxuICAgIFwib3BlbnNwYS5pbmZvXCIsXG4gICAgXCJvcGVud2ViLnNjaWVuY2VcIixcbiAgICBcIm9wZW56ZWthLmNvbVwiLFxuICAgIFwib3BlbnViYS5vcmdcIixcbiAgICBcIm9wZW4ud2EubGlua1wiLFxuICAgIFwicHVsc2VjaGFpbi5jb21cIixcbiAgICBcInB1bHNlcmFtcC5jb21cIixcbiAgICBcInB1bHNleC5jb21cIixcbiAgICBcImNhY3R1cy5ieVwiLFxuICAgIFwiY2FjdHVzLmNhcmRzXCIsXG4gICAgXCJjYWN0dXMuZ3JcIixcbiAgICBcImNhY3R1cy5zdG9yZVwiLFxuICAgIFwiY2FjdHVzLmxhXCIsXG4gICAgXCJjYWN0dXMuc2hcIixcbiAgICBcImViaW5pdHkuY29tXCIsXG4gICAgXCJmbGFydW0uaXRcIixcbiAgICBcImhvY3R1cy53aW5cIixcbiAgICBcImluZmluaXR5LmNvXCIsXG4gICAgXCJpbmZpbml0eS5maXNoXCIsXG4gICAgXCJpbmZpbml0eS5ncm91cFwiLFxuICAgIFwiaW5maW5pdHkuaGVhbHRoXCIsXG4gICAgXCJpbmZpbml0eS5pcmlzaFwiLFxuICAgIFwiaW5maW5pdHkubmxcIixcbiAgICBcImluZmluaXR5LnJlXCIsXG4gICAgXCJpbmZpbml0eS53YXRjaFwiLFxuICAgIFwiaXBlbnNhLmNvbVwiLFxuICAgIFwianVzdHVzLmZ1blwiLFxuICAgIFwianVzdHVzLmxpbmtcIixcbiAgICBcImtyeXB0a2l0dGllcy5jb21cIixcbiAgICBcIm9wZW5zY2FkLmluZm9cIixcbiAgICBcImZsYXJ1bS5pclwiLFxuICAgIFwibm9jdHVzLmNjXCIsXG4gICAgXCJxdWF0dXMuZGVcIixcbiAgICBcInJ1Y2t1cy5jbG91ZFwiLFxuICAgIFwicnVja3VzLm5sXCIsXG4gICAgXCJydWNrdXMub25lXCIsXG4gICAgXCJydWNrdXMuc3R1ZGlvXCIsXG4gICAgXCJmdmxjcnVtLmNvbVwiLFxuICAgIFwib3BlbnNlYXMuZ3JcIixcbiAgICBcImxhdXR1cy5uZXRcIixcbiAgICBcIm1ldGFjYXMuaW9cIixcbiAgICBcIm1hZ2VuZGFvLmNvbVwiLFxuICAgIFwibWFya21ldGEuZmluYW5jZVwiLFxuICAgIFwibWFza25ldC5uZXRcIixcbiAgICBcImxlY3R1cy5rclwiLFxuICAgIFwibHVjcnVtLmRpZ2l0YWxcIixcbiAgICBcImx1Y3J1bS5mdW5kXCIsXG4gICAgXCJsdWNydW0ucHJvXCIsXG4gICAgXCJsdWNydW0udWtcIixcbiAgICBcImx1Y3J1bS52Y1wiLFxuICAgIFwibHVjcnVzLmlvXCIsXG4gICAgXCJtZXRhZWFzZS5jb21cIixcbiAgICBcIm1ldGFlYXNlLmlvXCIsXG4gICAgXCJtZXRhaGFjay5nYW1lc1wiLFxuICAgIFwibWV0YWphY2sub3JnXCIsXG4gICAgXCJtYWRkbWV0YS5jb21cIixcbiAgICBcIm1ldGFtYWMubGl2ZVwiLFxuICAgIFwibWV0YW1haWwuaW5rXCIsXG4gICAgXCJtZXRhbWFyay5sdFwiLFxuICAgIFwibWV0YW1hcnMuY2FwaXRhbFwiLFxuICAgIFwibWV0YW1hcnMuY29tXCIsXG4gICAgXCJtZXRhbWFycy5mclwiLFxuICAgIFwibWV0YW1hcnMubXhcIixcbiAgICBcIm1ldGFtYXJzLnRvXCIsXG4gICAgXCJtZXRhbWFydC5zcGFjZVwiLFxuICAgIFwibWV0YW1hc3UuY29tXCIsXG4gICAgXCJtZXRhbWF0ZS5jcnlwdG9cIixcbiAgICBcIm1ldGFtYXRlLmdhbWVcIixcbiAgICBcIm1ldGFtYXh4LmlvXCIsXG4gICAgXCJtZXRhbWVzZS5jb21cIixcbiAgICBcIm1ldGFtZXNzLmlvXCIsXG4gICAgXCJtZXRhbWlsay54eXpcIixcbiAgICBcIm1ldGFtdXNlLnh5elwiLFxuICAgIFwibWV0YW1rLmNvbVwiLFxuICAgIFwibWV0YW11c2suZXVcIixcbiAgICBcIm1ldGFtdXNrLmlvXCIsXG4gICAgXCJtZXRhLW11c2suY29tXCIsXG4gICAgXCJtZXRhbW9zYS5pb1wiLFxuICAgIFwibWV0YW9hay5jb21cIixcbiAgICBcIm1ldGFvYWsueHl6XCIsXG4gICAgXCJtZXRhcGFrLmNvXCIsXG4gICAgXCJtZXRhcGFrLmlvXCIsXG4gICAgXCJtZXRhcGFyay5rclwiLFxuICAgIFwibWV0YXBhcmsubGFuZFwiLFxuICAgIFwibWV0YXBhc3Mud29ybGRcIixcbiAgICBcIm1ldGFsbWFyay54eXpcIixcbiAgICBcIm1ldGFzbWFzLmNvbVwiLFxuICAgIFwibWV0YXRhbGsuaWRcIixcbiAgICBcIm1pc3NtZXRhLndvcmxkXCIsXG4gICAgXCJtdWx0dXMubWVkaWFcIixcbiAgICBcIm5maW5pdGkuaW9cIixcbiAgICBcIm52aW5pdHkubmxcIixcbiAgICBcIm9mZmljaWFsbmZ0Lnh5elwiLFxuICAgIFwid3BvcGVuc2VhLmNvbVwiLFxuICAgIFwib3Blbi1lZC5meWlcIixcbiAgICBcIm9wZW5leC5pb1wiLFxuICAgIFwib3BlbmdlYXIudHZcIixcbiAgICBcIm9wZW5pZGVhLmx2XCIsXG4gICAgXCJvcGVubmVyLnZjXCIsXG4gICAgXCJvcGVuc3B2LmNvbVwiLFxuICAgIFwib3BlbnNyYy5mYW5zXCIsXG4gICAgXCJvcGVuc3JjLmZpbmFuY2VcIixcbiAgICBcIm9wZW5hLnR2XCIsXG4gICAgXCJvcGVuZXIucGxcIixcbiAgICBcIm9wZW4tZS5jb21cIixcbiAgICBcIm9wZW4tZXMuY29tXCIsXG4gICAgXCJvcGVuZ2VlLm9yZ1wiLFxuICAgIFwib3BlbmdlbS5uZXRcIixcbiAgICBcIm9wZW5zZWEuaW5zdGl0dXRlXCIsXG4gICAgXCJvcGVuc2VhLnJ1XCIsXG4gICAgXCJvcGVuc2VuZi5kZVwiLFxuICAgIFwib3BlbnNlcmEuY29tXCIsXG4gICAgXCJvcGVuc2V0LmNvXCIsXG4gICAgXCJvcGVuc2lzLmNvbVwiLFxuICAgIFwib3BlbnNreS5ibHVlXCIsXG4gICAgXCJvcGVuc2t5LmNvbVwiLFxuICAgIFwib3BlbnNreS5lc1wiLFxuICAgIFwib3BlbnNreS5rclwiLFxuICAgIFwib3BlbnNreS5sYVwiLFxuICAgIFwib3BlbnNsby5jb21cIixcbiAgICBcIm9wZW5zb2MuaW9cIixcbiAgICBcIm9wZW5zcGVjLmlvXCIsXG4gICAgXCJvcGVucmVhbC5vbmVcIixcbiAgICBcIm9wZW50ZWUuaW9cIixcbiAgICBcImVhcC5nclwiLFxuICAgIFwib3Blbi5lYXAuZ3JcIixcbiAgICBcInVhLmVkdVwiLFxuICAgIFwib3Blbi51YS5lZHVcIixcbiAgICBcImRpbml0ei5jelwiLFxuICAgIFwib3BlbmdlYXIuY29tXCIsXG4gICAgXCJvcGVudGVhbS5jb21tdW5pdHlcIixcbiAgICBcIm9wZW5pcGEub3JnXCIsXG4gICAgXCJvcGluc3RhLmNvbVwiLFxuICAgIFwib3BlbnNjLm9yZ1wiLFxuICAgIFwib3BlbnNpcGEuaXRcIixcbiAgICBcIm9wZW5zeXIuY29tXCIsXG4gICAgXCJvcGVuc2V0LmNvbVwiLFxuICAgIFwib3BlbnN0ZWFrLmNvbVwiLFxuICAgIFwib3BlbnNjYW4uZXVcIixcbiAgICBcIm9wZW5zd2FuLm9yZ1wiLFxuICAgIFwiYWZmaW5pdHkubG9jdXNcIixcbiAgICBcIm9wZW5kZXYuYXRcIixcbiAgICBcIm9wZW5kZXYub3JnXCIsXG4gICAgXCJvcGVuZWkub3JnXCIsXG4gICAgXCJvcGVuc2VlLmlvXCIsXG4gICAgXCJvcGVubGNhLm9yZ1wiLFxuICAgIFwib3BlbnJhLm5ldFwiLFxuICAgIFwib3BlbnRjYS5jb1wiLFxuICAgIFwib3Blbi1zZWMuY29tXCIsXG4gICAgXCJvZGVuc2UuZGtcIixcbiAgICBcIm9wZW56ZXRhLmlvXCIsXG4gICAgXCJzcGVuc2UubmxcIixcbiAgICBcInNwZW5zZS5ub1wiLFxuICAgIFwibWV0YW1zcC5jb21cIixcbiAgICBcImZhY3R1cy5pb1wiLFxuICAgIFwib3Blbm1lLmNvbVwiLFxuICAgIFwib3BlbmRlaS5ldVwiLFxuICAgIFwibWV0YWNhc2UucHRcIixcbiAgICBcIm9wZW5pYS5hZVwiLFxuICAgIFwib3BlbmVyLmFlcm9cIixcbiAgICBcIm9wZW5kZXgubmV0d29ya1wiLFxuICAgIFwib3BlbnBhLm5ldFwiLFxuICAgIFwicHVuY3R1cy5vcmdcIixcbiAgICBcIm9wZW5nZXMuZXNcIixcbiAgICBcIm1ldGFtYWRlLmlvXCIsXG4gICAgXCJtZXRhbWFkZS54eXpcIixcbiAgICBcIm1ldGFiYXNlLmJ1aWxkXCIsXG4gICAgXCJvcGVuc3RmLmlvXCIsXG4gICAgXCJvcGVudGVrLmV1XCIsXG4gICAgXCJvcGVuLmdhLmdvdlwiLFxuICAgIFwib3BlbnNmbS5vcmdcIixcbiAgICBcImFsdHVzLmZpbmFuY2VcIixcbiAgICBcImluZmluaXR5Lnh5elwiLFxuICAgIFwidXBmaW5pdHkueHl6XCIsXG4gICAgXCJ3d3cub3BlbnJlYy50dlwiLFxuICAgIFwib3BlbnNreS5maW5hbmNlXCIsXG4gICAgXCJvcGVuc2JyLm9yZ1wiLFxuICAgIFwib3BlbmthLm5ldFwiLFxuICAgIFwib3BlbmJldC5jb21cIixcbiAgICBcIm9wZW5zY2FkLm9yZ1wiLFxuICAgIFwib3BlbnNzbC5vcmdcIixcbiAgICBcIm9wZW5tZS5nbFwiLFxuICAgIFwib3Blbm1ldGEuZm91bmRhdGlvblwiLFxuICAgIFwib3BlbnNzaC5jb21cIixcbiAgICBcIm9wZW5ncmEuY29tXCIsXG4gICAgXCJvcGVuZ3JhLml0XCIsXG4gICAgXCJvcGVuYmlzZWEuaW9cIixcbiAgICBcIm9wZW5iaXNlYS5jb21cIixcbiAgICBcIm9wZW5zc2Yub3JnXCIsXG4gICAgXCJvcGVubmV0LnJ1XCIsXG4gICAgXCJvcGVuc2xyLm9yZ1wiLFxuICAgIFwib3BlbnN0YXgub3JnXCIsXG4gICAgXCJvcGVud2ViLnN5c3RlbXNcIixcbiAgICBcIm9wZW5zcnMuY29tXCIsXG4gICAgXCJvcGVud2ViLmNvbVwiLFxuICAgIFwib3BlbndlYi5vbmxcIixcbiAgICBcIm91bHJ1bS5jb21cIixcbiAgICBcInR1Y3R1Yy5jb21cIixcbiAgICBcInluZmluaXR5LmVzXCIsXG4gICAgXCJmaW50eS5jb21cIixcbiAgICBcIm9wZW5zZWEuaW9cIixcbiAgICBcInBlbnNlYy5ub1wiLFxuICAgIFwiYWx0dXMuY3JcIixcbiAgICBcImFsdHVzLmVkdWNhdGlvblwiLFxuICAgIFwiYWx0dXMuZGlnaXRhbFwiLFxuICAgIFwiYWx0dXMub25lXCIsXG4gICAgXCJhbHR1cy5nbG9iYWxcIixcbiAgICBcImF0dXMuY2hcIixcbiAgICBcInB4aW5pdHkuY29tXCIsXG4gICAgXCJ2Y2luaXR5LmlvXCIsXG4gICAgXCJ2Y2luaXR5Lm9yZ1wiLFxuICAgIFwidmNpbml0eS5jb21cIixcbiAgICBcIm5maW5pdGEuY29tXCIsXG4gICAgXCJuZmluaXRhLmlvXCIsXG4gICAgXCJuZmluaXRhLm9yZ1wiLFxuICAgIFwic3BpLmNsdWJcIixcbiAgICBcInN0YWtlc3BpLmNvbVwiLFxuICAgIFwiYXVjdG8uY29tXCIsXG4gICAgXCJkZWZpY2l0eS50ZWNoXCIsXG4gICAgXCJkZWZpY2l0eS5hcHBcIixcbiAgICBcImFyZmluaXR5LmlvXCIsXG4gICAgXCJjYWN0dXMudG9vbHNcIixcbiAgICBcImNhY3R1cy5ibVwiLFxuICAgIFwiYXNjZXR1cy5jb21cIixcbiAgICBcIm15bmV0aGVyd2FsbGV0LmlvXCIsXG4gICAgXCJtZXRhbWFza3MuY29tXCIsXG4gICAgXCJtZXRhY2Fzay5jb21cIixcbiAgICBcIm1ldGFjYXNrLmlvXCIsXG4gICAgXCJlZmluaXR5LmlvXCIsXG4gICAgXCJmaW5pdGUubHRkXCIsXG4gICAgXCJhdXVzLmNsb3VkXCIsXG4gICAgXCJtYXN0ZXJub2Rlcy5vbmxpbmVcIixcbiAgICBcIm15ZXRwd2FsbGV0LmNvbVwiLFxuICAgIFwiZnVsY3J1bS5yb2Nrc1wiLFxuICAgIFwibXljcnByby5jb21cIixcbiAgICBcIm9wZW5tZXYub3JnXCIsXG4gICAgXCJvcGVubWV2Lm5ldFwiLFxuICAgIFwib3Blbm1ldi5jb21cIixcbiAgICBcIm9wZW5tZXYueHl6XCIsXG4gICAgXCJvcGVuc3dhcC5pb1wiLFxuICAgIFwib3BlbnN3YXAub25lXCIsXG4gICAgXCJvcGVuc3dhcC50ZWNoXCIsXG4gICAgXCJvcGVuc3dhcC54eXpcIixcbiAgICBcInljcnlwdG9zLmNvbVwiLFxuICAgIFwibXJjcnlwdG8uc3BhY2VcIixcbiAgICBcIm1yY3J5cHRvLm1lXCIsXG4gICAgXCJldGhzY2FuLm9yZ1wiLFxuICAgIFwiY3J5cHRvLm11c2V1bVwiLFxuICAgIFwicXRjcnlwdG8uY29tXCIsXG4gICAgXCJkY3J5cHRvLmlvXCIsXG4gICAgXCJkcmNyeXB0by5pb1wiLFxuICAgIFwiZGVjcnlwdG8uaW5cIixcbiAgICBcIm15Y3J5cHRvbnguY29tXCIsXG4gICAgXCJtM2NyeXB0by5vbmxpbmVcIixcbiAgICBcImRjcnlwdG8ubmV0XCIsXG4gICAgXCJtc25jcnlwdG8uY29tXCIsXG4gICAgXCJpbmNyeXB0by5wbFwiLFxuICAgIFwiY3J5cHRvLm1hcmtldFwiLFxuICAgIFwiai1jcnlwdG8uY29tXCIsXG4gICAgXCJzY3J5cHRvLmRpZ2l0YWxcIixcbiAgICBcInBtaWNyeXB0by5tbFwiLFxuICAgIFwibWVjcnlwdG8uY2x1YlwiLFxuICAgIFwibWR4Y3J5cHRvLmNvbVwiLFxuICAgIFwibGF1bmNocGFkLmV0aGVyZXVtLm9yZ1wiLFxuICAgIFwiZW5sZWRnZXIuaW9cIixcbiAgICBcImNyeXB0by50dFwiLFxuICAgIFwiYmFkZ2VyLmZpbmFuY2VcIixcbiAgICBcImVubGVkZ2VyLmNvbVwiLFxuICAgIFwibGVkZ2VyeC5jb21cIixcbiAgICBcImxlZGdlcnFsLmNvbVwiLFxuICAgIFwiZnVsY3J1bS53aWtpXCIsXG4gICAgXCJhcHR1cy5oclwiLFxuICAgIFwiYXB0dXMubGlmZVwiLFxuICAgIFwiZWRnZS5uZXR3b3JrXCIsXG4gICAgXCJhY3RpdXMubXhcIixcbiAgICBcImlwbGVkZ2VyLmNvXCIsXG4gICAgXCJhdWN0aW0uY29tXCIsXG4gICAgXCJmdWxjcnVtZXAuY29tXCIsXG4gICAgXCJkZWZpbml0eS5uZXR3b3JrXCIsXG4gICAgXCJsZWRnZXIuY29tXCIsXG4gICAgXCJ3YXguY29tbXVuaXR5XCIsXG4gICAgXCJmbGFydW0ub3JnXCIsXG4gICAgXCJxaXN3YXAuY29tXCIsXG4gICAgXCJkZWNyeXB0by5maW5hbmNlXCIsXG4gICAgXCJ1bmlzd2FwLmV0aFwiLFxuICAgIFwiY3J5cHRvLmNvXCIsXG4gICAgXCJhbnlzd2FwLmV4Y2hhbmdlXCIsXG4gICAgXCJhbnlzd2FwLm5ldHdvcmtcIixcbiAgICBcIm1pbmlzd2FwLm9yZ1wiLFxuICAgIFwiYW55c3dhcC5vcmdcIixcbiAgICBcImFueXN3YXAuaW5mb1wiLFxuICAgIFwiYW55c3dhcC5tYXJrZXRcIixcbiAgICBcImFueXN3YXAubmV0XCIsXG4gICAgXCJ1bmlzd2FwLmNoXCIsXG4gICAgXCJ1bmlzd2FwLmlvXCIsXG4gICAgXCJ1bmlzd2FwLm5pbmphXCIsXG4gICAgXCJ1bmlzb2Nrcy5leGNoYW5nZVwiLFxuICAgIFwidW5pcGlnLmV4Y2hhbmdlXCIsXG4gICAgXCJ1bmlzd2FwLnZpc2lvblwiLFxuICAgIFwidW5pc3dhcC5pbmZvXCIsXG4gICAgXCJ1bmlzd2FwLm9yZ1wiLFxuICAgIFwidW5pc3dhcC5leGNoYW5nZVwiLFxuICAgIFwidW5pc3dhcGV4LmlvXCIsXG4gICAgXCJ1bXRzd2FwLmZpbmFuY2VcIixcbiAgICBcImF1Y3RpYS5pb1wiLFxuICAgIFwic2djcnlwdG8uaW5mb1wiLFxuICAgIFwibXItY3J5cHRvLm5ldFwiLFxuICAgIFwibW9yY3J5cHRvLm5ldFwiLFxuICAgIFwiZGZpbml0ZS5vcmdcIixcbiAgICBcImRlY3J5cHRvLm9yZ1wiLFxuICAgIFwibXJhY3J5cHRvLmNvbVwiLFxuICAgIFwiZXRpbml0eS5uZXRcIixcbiAgICBcImNyeXB0by5nYW1lc1wiLFxuICAgIFwiY3J5cHRvLWdhbWVzLm5ldFwiLFxuICAgIFwiY3J5cHRvLnJvXCIsXG4gICAgXCJidXljcnlwdG8uaW5mb1wiLFxuICAgIFwiYmFzaWMuaW50ZXJuYXRpb25hbFwiLFxuICAgIFwiYWN0dWEuY2FcIixcbiAgICBcImJ1bHR1cy5ubFwiLFxuICAgIFwib2FpLmlvXCIsXG4gICAgXCJwYXNzLm9yZ1wiLFxuICAgIFwieWFzaXYuY29tXCIsXG4gICAgXCJ0YXNrcy5vcmdcIixcbiAgICBcImF1ZHVzLm5ldFwiLFxuICAgIFwib3NyaXMub3JnXCIsXG4gICAgXCJvdGlzLmlzXCIsXG4gICAgXCJvcmlzLmNoXCIsXG4gICAgXCJvYWtzLnJlbnRcIixcbiAgICBcIm94aXMub3JnXCIsXG4gICAgXCJuYXZpcy5pb1wiLFxuICAgIFwic2ZvYXNpcy5jb21cIixcbiAgICBcInNheGlzLmRrXCIsXG4gICAgXCJtYXJzaXMudHZcIixcbiAgICBcIm9zcy5rclwiLFxuICAgIFwiY2FzaW8uY29tXCIsXG4gICAgXCJwYWlzLmNlbnRlclwiLFxuICAgIFwidWNodXMub25saW5lXCIsXG4gICAgXCJwYXRpcy5jb21cIixcbiAgICBcIm9zaS5lc1wiLFxuICAgIFwidGFzb3MuY29cIixcbiAgICBcInBhc3MuY2FtcFwiLFxuICAgIFwiYXNpY3MuY29tXCIsXG4gICAgXCJvbXNpLmVkdVwiLFxuICAgIFwidnVsdHVzLmlvXCIsXG4gICAgXCJrb3Npcy5rclwiLFxuICAgIFwicGFyaXMuY2xcIixcbiAgICBcInBhcnNpcy5hZ2VuY3lcIixcbiAgICBcImFwaXMuZ3VydVwiLFxuICAgIFwiYXNpLmx2XCIsXG4gICAgXCJwYXN0cy5sdlwiLFxuICAgIFwib2VzaXIuY29tXCIsXG4gICAgXCJhdmlzLmNhXCIsXG4gICAgXCJvZXNzLmRlXCIsXG4gICAgXCJob3Jhc2lzLm9yZ1wiLFxuICAgIFwib2F6aXMuaHVcIixcbiAgICBcInphcGlzLmt6XCIsXG4gICAgXCJuYWRpcy5qcFwiLFxuICAgIFwib3NpZi5vcmdcIixcbiAgICBcIm9tbmlzLmNvbVwiLFxuICAgIFwiZmFzcy5zZVwiLFxuICAgIFwidGFzcy5ydVwiLFxuICAgIFwic2lzLnB0XCIsXG4gICAgXCIzYXNpLmVzXCIsXG4gICAgXCJpYXNpYS5jb1wiLFxuICAgIFwib2thc2kubWVcIixcbiAgICBcIndhc2kuZGV2XCIsXG4gICAgXCJub3Npcy5jb21cIixcbiAgICBcIm9kYXNpZS5mclwiLFxuICAgIFwib3J2aXMuY29tXCIsXG4gICAgXCJvdmlzLm5ld3NcIixcbiAgICBcIm9yYXNpby5vcmdcIixcbiAgICBcImFzb3MuZnJcIixcbiAgICBcImJhc2ljLmZpbmFuY2VcIixcbiAgICBcInZhbmlzLmlvXCIsXG4gICAgXCJhdmlzLmNvbVwiLFxuICAgIFwiYXhpcy5saVwiLFxuICAgIFwibmFmaXMuY29cIixcbiAgICBcInRyaW5pdHkuYXJ0XCIsXG4gICAgXCJ0cmluaXR5LmRlc2lnblwiLFxuICAgIFwidHJpbml0eS5lZHVcIixcbiAgICBcInRyaW5pdHkuZ2xvYmFsXCIsXG4gICAgXCJ0cmluaXR5LmpwXCIsXG4gICAgXCJ0cmluaXR5Lm1vZVwiLFxuICAgIFwidHJpbml0eS5vbmVcIixcbiAgICBcInRyaW5pdHkub3JnXCIsXG4gICAgXCJ0cmluaXR5LnB3XCIsXG4gICAgXCJ0cmluaXR5LnRlY2hcIixcbiAgICBcImF4aXMuY29tXCIsXG4gICAgXCJvYXNhLmNvXCIsXG4gICAgXCJhcGlzLnpvbmVcIixcbiAgICBcIm90cmlzLmRlXCIsXG4gICAgXCJzdGFzaXMubmV0d29ya1wiLFxuICAgIFwibmFpcy5pb1wiLFxuICAgIFwiYXJjdGlzLmF0XCIsXG4gICAgXCJhdGMudXMuZXNcIixcbiAgICBcInRhc2l0LmlvXCIsXG4gICAgXCJmYXNpby5iaXpcIixcbiAgICBcImZhc2lvLm9yZ1wiLFxuICAgIFwiZmFzaW8ubmV0XCIsXG4gICAgXCJmYXNpby55b2tvaGFtYVwiLFxuICAgIFwiY2FuaXMueHl6XCIsXG4gICAgXCJvZWlzLm9yZ1wiLFxuICAgIFwicGFyaXMuZnJcIixcbiAgICBcImJhc2ljLm5ldFwiLFxuICAgIFwiYXN1cy5jb21cIixcbiAgICBcImdzaXMuZ3JcIixcbiAgICBcImFzb3MuY29tXCIsXG4gICAgXCJvcmJpcy5wbFwiLFxuICAgIFwic3Rhc2lzLm5ldFwiLFxuICAgIFwic3Rhc2lzLmZvdW5kYXRpb25cIixcbiAgICBcIm9mc3lzLmNvbVwiLFxuICAgIFwiYWNyeXB0by5ubFwiLFxuICAgIFwiZ2VzaXMub3JnXCIsXG4gICAgXCJvcmFzaXMudGVjaFwiLFxuICAgIFwiYmFzaWMuZmFpbFwiLFxuICAgIFwiYXBpcy5tblwiLFxuICAgIFwiYXNpYy50b1wiLFxuICAgIFwia2FsaXMubWVcIixcbiAgICBcIm1hc3MuZ292XCIsXG4gICAgXCJzdGFrZXJkYW8uY29tXCIsXG4gICAgXCJvYXNpcy5maXNoXCIsXG4gICAgXCJtYWtlcnBhZC5jb1wiLFxuICAgIFwidmsuY29tXCIsXG4gICAgXCJhbGlzLnRvXCIsXG4gICAgXCJncm9hc2lzLmludmVzdG1lbnRzXCIsXG4gICAgXCJtc24uY29tXCIsXG4gICAgXCJvay5ydVwiLFxuICAgIFwibWFrZXJmb3VuZGF0aW9uLmNvbVwiLFxuICAgIFwib2FzaXMuYXBwXCIsXG4gICAgXCJta3IudG9vbHNcIixcbiAgICBcIm1sY3J5cHQuZGVcIixcbiAgICBcImJ1eWNyeXB0by53b3JrXCIsXG4gICAgXCJtZXRhbWFpbC5hcHBcIixcbiAgICBcImZpbml0ZS5nYW1lc1wiLFxuICAgIFwiZGVjcnlwdG8uZnJcIixcbiAgICBcImRmaW5pLmNvbVwiLFxuICAgIFwiZGFkZHlzLWRpZ2VzdC5zYWRlay51c2VybWQubmV0XCIsXG4gICAgXCJkYW1paS51c2VybWQubmV0XCIsXG4gICAgXCJpbWFnaW5lLnVzZXJtZC5uZXRcIixcbiAgICBcImtyci51c2VybWQubmV0XCIsXG4gICAgXCJwcmV6ZW50eS50b211LnVzZXJtZC5uZXRcIixcbiAgICBcImV0aGVyc2NhbXMuaW9cIixcbiAgICBcInN0cnplbGN1LnVzZXJtZC5uZXRcIixcbiAgICBcImljcnlwdG8ubWVkaWFcIixcbiAgICBcInJ5ZWNyeXB0by5jb21cIixcbiAgICBcImNyeXB0by5neVwiLFxuICAgIFwicG1wY3J5cHRvLmNvbVwiLFxuICAgIFwiZWpjcnlwdG8uY29tXCIsXG4gICAgXCJiY2NyeXB0by5jbHViXCIsXG4gICAgXCJjcnlwdG8ubGF3XCIsXG4gICAgXCJzb2NyeXB0by5pb1wiLFxuICAgIFwiY3J5cHRvLnRheFwiLFxuICAgIFwib2tjcnlwdG8uY29tXCIsXG4gICAgXCJhY3RzLmNhXCIsXG4gICAgXCJlZGZpbml0eS5jb21cIixcbiAgICBcInRoZXJhc2Nhbi5pbmZvXCIsXG4gICAgXCJ3aWZpbml0eS5lc1wiLFxuICAgIFwibmZpbml0eS5jb21cIixcbiAgICBcIndheXMuMTZtYi5jb21cIixcbiAgICBcImF1Y3RhLmlvXCIsXG4gICAgXCJmaW5kaXR5LnNlXCIsXG4gICAgXCJkZXhpbml0eS5jb21cIixcbiAgICBcImV0aGVyc2Nhbi5jb21cIixcbiAgICBcImFydHR1cy5uZXRcIixcbiAgICBcImFydHR1cy5hcnRcIixcbiAgICBcImNyeXB0by5nYXJkZW5cIixcbiAgICBcImthY3R1cy5jb21cIixcbiAgICBcImRlY3J5cHRvLmNvbS5hclwiLFxuICAgIFwiZGVjcnlwdG8ubGFcIixcbiAgICBcImV0aGVyc2Nhbi5rclwiLFxuICAgIFwidXBkb2cuY29cIixcbiAgICBcImNyeXB0b3RpdHRpZXouY29tXCIsXG4gICAgXCJwYXljcnlwdG8uY29tXCIsXG4gICAgXCJ0cmNyeXB0by5saXZlXCIsXG4gICAgXCJhY3Q0cy5jb21cIixcbiAgICBcImVjcnlwdG8uc2hvcFwiLFxuICAgIFwiYXV0aHMuZXVcIixcbiAgICBcImZpbml0cy5vcmdcIixcbiAgICBcIm1pZmluaXR5LmNvbVwiLFxuICAgIFwiY3J5cHRvbml0aWVzLmNvbVwiLFxuICAgIFwiY3J5cHRvLmNlbnRlclwiLFxuICAgIFwiYXV0b3MuZGVhbHNcIixcbiAgICBcImFiY3J5cHRvLmNvXCIsXG4gICAgXCJnY3J5cHRvLm1lZGlhXCIsXG4gICAgXCJwYXljcnlwdG8udGVjaFwiLFxuICAgIFwibWV0YW1lc2guY29tXCIsXG4gICAgXCJjYWN0dXMuYXBwXCIsXG4gICAgXCJsdWNpdXMuZnJcIixcbiAgICBcImx1Y2l1cy5ubFwiLFxuICAgIFwiY3J5cHRvLmNhc2FcIixcbiAgICBcInNvY3J5cHRvLmFwcFwiLFxuICAgIFwiZ29jcnlwdG8uY29tXCIsXG4gICAgXCJiZWNyeXB0by5jb1wiLFxuICAgIFwiZXRoZXJzdGF0LmlvXCIsXG4gICAgXCJhcmN1cy5vcmdcIixcbiAgICBcImFyY3VzLmZpbmFuY2VcIixcbiAgICBcInVidHVzLmNvbVwiLFxuICAgIFwibWV0YWhhc2gudG9vbHNcIixcbiAgICBcIm1ldGF0YWxrLmlvXCIsXG4gICAgXCJtZXRhdGFsay5vcmdcIixcbiAgICBcIm1yY3J5cHRvLnh5elwiLFxuICAgIFwiZml4aXR5LmlvXCIsXG4gICAgXCJteWNyeXB0by5ndWlkZVwiLFxuICAgIFwiYWZmaW5pdHkuaWRcIixcbiAgICBcIm1yY3J5cHRvLmNjXCIsXG4gICAgXCJiaW5hbmNlLm5ldFwiLFxuICAgIFwiYmluYW5jZS5jbG91ZFwiLFxuICAgIFwiYmluYW5jZS52aXNpb25cIixcbiAgICBcImluZmluaXR5LmNtXCIsXG4gICAgXCJzY2NyeXB0by5uZXRcIixcbiAgICBcImNyeXB0by5pZVwiLFxuICAgIFwidGtjcnlwdG8uY29tXCIsXG4gICAgXCJldWZpbml0eS5jb21cIixcbiAgICBcImlkY3J5cHRvLmZyXCIsXG4gICAgXCJkaXZpbml0eS5jbG90aGluZ1wiLFxuICAgIFwiY3J5cHRvLmNhcmRzXCIsXG4gICAgXCJlbmNyeXB0by5hcnRcIixcbiAgICBcImNyeXB0by5leHByZXNzXCIsXG4gICAgXCJjcnlwdG8uYWlyZm9yY2VcIixcbiAgICBcImFjY3J5cHRvLmlvXCIsXG4gICAgXCJvaG15Y3J5cHRvLm5ld3NcIixcbiAgICBcImF1cmV1cy5jbFwiLFxuICAgIFwiYXVkaXVzLmRlXCIsXG4gICAgXCJldGhwbG9kZS5vcmdcIixcbiAgICBcInNmY3J5cHRvLmNvXCIsXG4gICAgXCJhbHl0dXMubHRcIixcbiAgICBcIm5iY3J5cHRvLmV1XCIsXG4gICAgXCJhcmN0b3MuY2FwaXRhbFwiLFxuICAgIFwiaW5jcnlwdG8udHJhZGVcIixcbiAgICBcInNreWNyeXB0by5pb1wiLFxuICAgIFwiY3J5cHRvLm1lblwiLFxuICAgIFwiZXRoZXJlYW4uaW9cIixcbiAgICBcImFmZmluaXR5LnB0XCIsXG4gICAgXCJpbmZpbml0eS5mYW1pbHlcIixcbiAgICBcIm1ldGFtZXNoLmxpZmVcIixcbiAgICBcIm1ldGFtZXNoLm9ubGluZVwiLFxuICAgIFwibWV0YW1lc2guY29cIixcbiAgICBcImNyeXB0by5idXNpbmVzc1wiLFxuICAgIFwiYWV0aGVyd2FsbGV0LmlvXCIsXG4gICAgXCJpY29uLmNvbW11bml0eVwiLFxuICAgIFwiZXRoZXJjYXAuY29tXCIsXG4gICAgXCJuY3J5cHRvLnNhbGVcIixcbiAgICBcInNjcnlwdG8uY2FwaXRhbFwiLFxuICAgIFwic2NyeXB0by5tdFwiLFxuICAgIFwibHpjcnlwdG8ubmV0XCIsXG4gICAgXCJlenljcnlwdG8ubmV0XCIsXG4gICAgXCJ2dWx0dXMuc2VcIixcbiAgICBcImFraXR1cy5jb21cIixcbiAgICBcImJ1eWNyeXB0by50b2RheVwiLFxuICAgIFwiY29pbmRlc2stZW1haWwuY29tXCIsXG4gICAgXCJidXljcnlwdG8uZ3JcIixcbiAgICBcImF0ZmluaXR5LmlvXCIsXG4gICAgXCJhdGZpbml0eS5jaFwiLFxuICAgIFwiYXRmaW5pdHkuZGVcIixcbiAgICBcImF0ZmluaXR5LmF0XCIsXG4gICAgXCJhdGZpbml0eS5zd2lzc1wiLFxuICAgIFwiYXRmaW5pdHkuc2dcIixcbiAgICBcImF0ZmluaXR5LmZyXCIsXG4gICAgXCJhdGZpbml0eS5saVwiLFxuICAgIFwiYXRmaW5pdHkuY28udWtcIixcbiAgICBcImF0ZmluaXR5LmluZm9cIixcbiAgICBcImF0ZmluaXR5LmFwcFwiLFxuICAgIFwiYXRmaW5pdHl0ZXN0Lm1lXCIsXG4gICAgXCJmaW5pdHkuY2hcIixcbiAgICBcImluZmluaXR5LnJldmlld3NcIixcbiAgICBcImJldGFuZXQucXVhbnRzdGFtcC5jb21cIixcbiAgICBcIm1vZGNyeXB0by5vbmxpbmVcIixcbiAgICBcImNyeXB0by5hZFwiLFxuICAgIFwiY3R1cy5pb1wiLFxuICAgIFwiZjVjcnlwdG8uY29tXCIsXG4gICAgXCJjcnlwdG8uZGlyZWN0XCIsXG4gICAgXCJydWNrdXMub3JnXCIsXG4gICAgXCJqdXN0dXMuY29cIixcbiAgICBcImRpZ25pdHkuY2ZcIixcbiAgICBcImFyY3R1ci5zaVwiLFxuICAgIFwiYmVjcnlwdG8uZnVuZFwiLFxuICAgIFwibHVjaXVzLmRpZ2l0YWxcIixcbiAgICBcImJpbmFuY2UuY29cIixcbiAgICBcInhjcnlwdG8uaW5cIixcbiAgICBcImx1Y3VzLmlvXCIsXG4gICAgXCJ4ZmluaXRlLmlvXCIsXG4gICAgXCJ4ZmluaXRlLnh5elwiLFxuICAgIFwiaW5maW5pdHkubW9uZXlcIixcbiAgICBcImNyeXB0by54eXpcIixcbiAgICBcImNyeXB0by5ob2xkaW5nc1wiLFxuICAgIFwiY3J5cHRvLmRpcmVjdG9yeVwiLFxuICAgIFwiYnVjcnlwdG8uY29cIixcbiAgICBcIm1pdGNyeXB0by50ZWNoXCIsXG4gICAgXCJzeWRjcnlwdG8uY29tXCIsXG4gICAgXCJnb2NyeXB0by5iZXRcIixcbiAgICBcInNjcnlwdG8uY2x1YlwiLFxuICAgIFwidmljdHVzLmdnXCIsXG4gICAgXCJ2aWN0dXMuZmluYW5jZVwiLFxuICAgIFwibXljcnlwdG9yby5jb21cIixcbiAgICBcImluZmluaXR5LmJsYWNrXCIsXG4gICAgXCJuYWN0dXMuY29tXCIsXG4gICAgXCJjcnlwdG8udG5cIixcbiAgICBcImF1dHVtLmNvbVwiLFxuICAgIFwiYWxpY3R1cy5jb21cIixcbiAgICBcImp1c3R1cy5wd1wiLFxuICAgIFwiZXRoZXJtYW4uYXBwXCIsXG4gICAgXCJkdWNhdHVzLm5ldFwiLFxuICAgIFwiZWl0aGVyc2Nhbi5jb21cIixcbiAgICBcImRtdW5pdHkuY29tXCIsXG4gICAgXCJjcnlwdG9raXR0aWVzLmNpdHlcIixcbiAgICBcImV0aGVya2FuLmNvbVwiLFxuICAgIFwiYWljcnlwdG8uaW9cIixcbiAgICBcImF1dG9zLmNhXCIsXG4gICAgXCJhY2F0dXMuY29tXCIsXG4gICAgXCJwY3J5cHRvLmlvXCIsXG4gICAgXCJtZXRhY2FzaC5nZ1wiLFxuICAgIFwibWV0YWNhc2gub25saW5lXCIsXG4gICAgXCJtZXRhY2FzaC5pdFwiLFxuICAgIFwiYXB0dXMuYWVyb1wiLFxuICAgIFwib2Rpbml0eS5jb21cIixcbiAgICBcImJ1eWNyeXB0by5ndWlkZVwiLFxuICAgIFwibWV0YWxtYXMuY29tXCIsXG4gICAgXCJ2YWZpbml0eS5jb21cIixcbiAgICBcIm15Y3J5cC50b1wiLFxuICAgIFwiY3J5cHRva2l0dGllc3ZyLmNvXCIsXG4gICAgXCJ0b2tlbi51c2VybWQubmV0XCIsXG4gICAgXCJkYmNyeXB0by5pb1wiLFxuICAgIFwiZXRoZXJjYXQub3JnXCIsXG4gICAgXCJiZXN0cmF0ZS5vcmdcIixcbiAgICBcIm1zZ2NyeXB0by5jb21cIixcbiAgICBcInZldGhvcnNjYW4uaW9cIixcbiAgICBcIm15a3J5cHRvLmlvXCIsXG4gICAgXCJ0cnljcnlwdG8ubmV0XCIsXG4gICAgXCJ0cnljcnlwdG8uY29tXCIsXG4gICAgXCJhdGF0dXMuY29tXCIsXG4gICAgXCJhY3VpdHVzLmNvbVwiLFxuICAgIFwidHJhZGluZ3ZpZXcuY29tXCIsXG4gICAgXCJjb2lubWFya2V0Y2FwLmNvbVwiLFxuICAgIFwiY3J5cHRvLmZtXCIsXG4gICAgXCJjcnlwdG8ucnVcIixcbiAgICBcIngtY3J5cHRvLmNvbVwiLFxuICAgIFwibXljcnlwdG8uc3RvcmVcIixcbiAgICBcImV0aGVyd2FuLmNvbVwiLFxuICAgIFwiZXRoZXJlYW4uY29tXCIsXG4gICAgXCJldGhlcmVhbi5vcmdcIixcbiAgICBcImNhY3R1cy50dlwiLFxuICAgIFwidmljdHVzLmJlXCIsXG4gICAgXCJjcnlwdG8uZ3JhdGlzXCIsXG4gICAgXCJjcnlwdG8ubWFya2V0c1wiLFxuICAgIFwibWV0YW1hdGgub3JnXCIsXG4gICAgXCJjcnlwdG8uc2NodWxlXCIsXG4gICAgXCJjYWN0dXMubHVcIixcbiAgICBcImFyY3R1cy5pb1wiLFxuICAgIFwibGVjcnlwdG8uY2x1YlwiLFxuICAgIFwiYWljcnlwdG8uYmxvZ1wiLFxuICAgIFwiam1jcnlwdG8ub3JnXCIsXG4gICAgXCJ0YWN0dXMuZGtcIixcbiAgICBcInRhY3R1cy5ubFwiLFxuICAgIFwiYXVjdHVzLmNvbVwiLFxuICAgIFwiYXZvdHVzLmNvbVwiLFxuICAgIFwibXljcnlwdG8uZ3VydVwiLFxuICAgIFwiY3VsdHVzLmNvbVwiLFxuICAgIFwiYWN0YXMuY2x1YlwiLFxuICAgIFwiY3J5cHRvLnR1YmVcIixcbiAgICBcImF1cmV1cy5ubFwiLFxuICAgIFwiY3J5cHRvLmNhXCIsXG4gICAgXCJmYWxsaW4ucmYuZ2RcIixcbiAgICBcImFkY3J5cHRvLmlvXCIsXG4gICAgXCJ3Ym9yZWQyLnVzZXJtZC5uZXRcIixcbiAgICBcImdvY3J5cHRvLmRrXCIsXG4gICAgXCJldGhlcnNjYXBlLmlvXCIsXG4gICAgXCJtbGJjcnlwdG8uaW9cIixcbiAgICBcInNlY3J5cHRvLmlvXCIsXG4gICAgXCJhY3VzLmdvdlwiLFxuICAgIFwiY3J5cHRvbmlhLWRhc2guYml0YmFsbG9vbi5jb21cIixcbiAgICBcImVjcnlwdG8ucm9cIixcbiAgICBcImNvZmluaXR5Lm5ldFwiLFxuICAgIFwiY3J5cHRvLmZhcm1cIixcbiAgICBcImNyeXB0by5yYWRpb1wiLFxuICAgIFwiYXJjcnlwdG8ueHl6XCIsXG4gICAgXCJsLWNyeXB0by5jb21cIixcbiAgICBcImFwdHVzLmRlXCIsXG4gICAgXCJjcnlwdG8uc3R1ZHlcIixcbiAgICBcImNyeXB0by53b3JrXCIsXG4gICAgXCJldGhlcmljYWwuaW9cIixcbiAgICBcImFyY3VzLmNpdHlcIixcbiAgICBcIncyY3J5cHRvLmNvbVwiLFxuICAgIFwiY3JpcHRva2l0dGllcy5pdFwiLFxuICAgIFwiY3J5cHRvLmtnXCIsXG4gICAgXCJidXljcnlwdG8uY2FcIixcbiAgICBcImNhY3R1cy5pc1wiLFxuICAgIFwiYXBjLXVzLmNvbVwiLFxuICAgIFwidXNvbmxpbmUuYXBjLmZyXCIsXG4gICAgXCJmcnVjdHVzLmlvXCIsXG4gICAgXCJjYWN0dXMudmlzaW9uXCIsXG4gICAgXCJpbmNyeXB0by5pb1wiLFxuICAgIFwiYWN0aXMubmxcIixcbiAgICBcIm5lbS1kbnMuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImV0aGVyc2F0LmlvXCIsXG4gICAgXCJzYW5jdHVzLmlvXCIsXG4gICAgXCJzbWJyLnJmLmdkXCIsXG4gICAgXCJtb2NyeXB0by5pb1wiLFxuICAgIFwibXljcnlwdG9zLmlvXCIsXG4gICAgXCJhZmZpbml0eS5oZWxwXCIsXG4gICAgXCJvcmlnaW5wcm90b2NvbC5jb21cIixcbiAgICBcImthY3R1cy5pb1wiLFxuICAgIFwiYXB0dHVzLmNvbVwiLFxuICAgIFwiYXB0dXMuYmVcIixcbiAgICBcImV0aGVuLm1hcmtldFwiLFxuICAgIFwiZW5jcnlwdG8uc2l0ZVwiLFxuICAgIFwiZW5jcnlwdG8ud2Vic2l0ZVwiLFxuICAgIFwiY3J5cHRvLm9uZVwiLFxuICAgIFwiY3J5cHRvLmZhc2hpb25cIixcbiAgICBcIm1lZ2FtYXJrLmZyXCIsXG4gICAgXCJhcHB0dXMuY2xvdWRcIixcbiAgICBcImFwcHR1cy5jb21cIixcbiAgICBcImF1Y3hpcy5nclwiLFxuICAgIFwiY3J5cHRvLmNoXCIsXG4gICAgXCJldGhlcnBsYW4uY29tXCIsXG4gICAgXCJvY3R1cy5uZXR3b3JrXCIsXG4gICAgXCJ1bmRlcndlYXItbGVhZGVyYm9hcmQuYml0YmFsbG9vbi5jb21cIixcbiAgICBcIm1pZGNyeXB0by5jb21cIixcbiAgICBcIm1lcmF0YXNrLmNvbVwiLFxuICAgIFwiYXJoYXNoLnh5elwiLFxuICAgIFwicXVhbnRzdGFtcC5jb21cIixcbiAgICBcImFwcC5xdWFudHN0YW1wLmNvbVwiLFxuICAgIFwidGFjcnlwdG8ubmV0XCIsXG4gICAgXCJob3BlZnVsLXBvaXRyYXMtNjU0ZTVhLmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJhY3R1bS5vbmxpbmVcIixcbiAgICBcIml1bmN0dXMuaW9cIixcbiAgICBcImVmaW5pdHkuY29tXCIsXG4gICAgXCJiY2NyeXB0by5vcmdcIixcbiAgICBcIm10a3J5cHRvLmRlXCIsXG4gICAgXCJhZG9yaW5nLWJvb3RoLTI3NmUxNS5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwiYWN0dXguY29tXCIsXG4gICAgXCJhYmNyeXB0by5ubFwiLFxuICAgIFwiYWJjaHVzLm5vXCIsXG4gICAgXCJnb2NyeXB0by50b29sc1wiLFxuICAgIFwiY3J5cHRvLmV1XCIsXG4gICAgXCJhdWRpdHVzLmNjXCIsXG4gICAgXCJkaXZpbml0eS5nYW1lXCIsXG4gICAgXCJhZGl0dXMubmV0XCIsXG4gICAgXCJhbWF0dXMuY29tXCIsXG4gICAgXCJhdXJldXMuYWVyb1wiLFxuICAgIFwiYWdpbml0eS5jb21cIixcbiAgICBcImF1cnVzLmlvXCIsXG4gICAgXCJhZmluaXRpLmNvbVwiLFxuICAgIFwiYWN0dS5mclwiLFxuICAgIFwibnVjbHVzLmNvXCIsXG4gICAgXCJudWNsdXMuaW9cIixcbiAgICBcImF1Y3R1cy5vcmdcIixcbiAgICBcIm5jcnlwdG8uaW9cIixcbiAgICBcImRmaW5lcnkuY29tXCIsXG4gICAgXCJoZWRlcmFoYXNoZ3JhcGguY29tXCIsXG4gICAgXCJteWNyeXB0by5lZHVjYXRpb25cIixcbiAgICBcIm1ldGFtZXNoLmlvXCIsXG4gICAgXCJjcnlwdG8uYnlcIixcbiAgICBcIm15Y3J5cHRvLnRveXNcIixcbiAgICBcImhrY3J5cHRvLmNvbVwiLFxuICAgIFwiY3J5cHRvLmRlYWxzXCIsXG4gICAgXCJjcnlwdG8ucXVlYmVjXCIsXG4gICAgXCJjcnlwdG8uZGFuY2VcIixcbiAgICBcInZuY3J5cHRvLmluZm9cIixcbiAgICBcImNyeXB0by5tc1wiLFxuICAgIFwibmNyeXB0by5jb21cIixcbiAgICBcIm1yY3J5cHRvLmRrXCIsXG4gICAgXCJuZWRmaW5pdHkuY29tXCIsXG4gICAgXCJhZmZpbml0eS5tZVwiLFxuICAgIFwiY3J5cHRvLmNhdFwiLFxuICAgIFwid2luaXR5LmlvXCIsXG4gICAgXCJnZmluaXR5Lm5ldFwiLFxuICAgIFwibXljcnlwdG9ucy5jb21cIixcbiAgICBcImFpY3J5cHRvLmFpXCIsXG4gICAgXCJhemNyeXB0by5uZXRcIixcbiAgICBcImNyeXB0by5jb21cIixcbiAgICBcImNyeXB0by5vcmdcIixcbiAgICBcImFmZmluaXR5LnBob3RvZ3JhcGh5XCIsXG4gICAgXCJhYmNyeXB0by5pbmZvXCIsXG4gICAgXCJ1Y3J5cHRvLm5ldFwiLFxuICAgIFwidnNjcnlwdG8uY29tXCIsXG4gICAgXCJhZmZpbml0eS5jb21cIixcbiAgICBcImFmZmluaXR5LmNvXCIsXG4gICAgXCJ1cGZpbml0eS5pb1wiLFxuICAgIFwiY3J5cHRvLm5ld3NcIixcbiAgICBcImRiY3J5cHRvLmNvbVwiLFxuICAgIFwiZXpjcnlwdG8uZ3VpZGVcIixcbiAgICBcImdvY3J5cHRvLm1lXCIsXG4gICAgXCJmaW5pdHkuYWlcIixcbiAgICBcIndlZmZrZW1pbmluZy5jb21cIixcbiAgICBcIm53Y3J5cHRvLmNvbVwiLFxuICAgIFwiY29iaW5ob29kLmNvbVwiLFxuICAgIFwiYWZmaW5pdHkudmNcIixcbiAgICBcIm1ldGFodXNrLmNvbVwiLFxuICAgIFwibXJjcnlwdG8uZnJcIixcbiAgICBcImFmZmluaXR5LnN0b3JlXCIsXG4gICAgXCJhZmZpbml0eS5zZXJpZi5jb21cIixcbiAgICBcInhmaW5pdHkuY29tXCIsXG4gICAgXCJkZmluaXR5Lm9yZ1wiLFxuICAgIFwibXljcnlwdG8ud2Vic2l0ZVwiLFxuICAgIFwicHFjcnlwdG8ub3JnXCIsXG4gICAgXCJ6LWNyeXB0by5jb21cIixcbiAgICBcIm1wY3J5cG8uY29tXCIsXG4gICAgXCJsb2NhbGV0aGVyZXVtLmNvbVwiLFxuICAgIFwibG9jYWxjcnlwdG9zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5jb21cIixcbiAgICBcImh1b2JpcHJvLmNvbVwiLFxuICAgIFwibmNyeXB0by50ZWNoXCIsXG4gICAgXCI5Y3J5cHRvLmNvXCIsXG4gICAgXCJuZXRtYXNrLmh1XCIsXG4gICAgXCJjcnlwdG9raXR0ZW5zLmNsdWJcIixcbiAgICBcInJ1Y3J5cHRvLmNvbVwiLFxuICAgIFwiY3J5cHRvY2l0aWVzLndvcmxkXCIsXG4gICAgXCJjcnlwdG8ucHJlc3NcIixcbiAgICBcImJlY3J5cHRvLnh5elwiLFxuICAgIFwiaGljcnlwdG8uaW9cIixcbiAgICBcImNyeXB0by5ubFwiLFxuICAgIFwienljcnlwdG8uY29tXCIsXG4gICAgXCJtbWNyeXB0by5pb1wiLFxuICAgIFwibXljcnlwdGVyLmNvbVwiLFxuICAgIFwiY3J5cHRvLnRpY2tldHNcIixcbiAgICBcImNyeXB0by5wcm9cIixcbiAgICBcIm9jcnlwdG8ub3JnXCIsXG4gICAgXCJ3ZWNyeXB0by5uZXRcIixcbiAgICBcImljY3J5cHRvLmlvXCIsXG4gICAgXCJjcnlwdG8ua3JlZFwiLFxuICAgIFwib2hteWNyeXB0by5pb1wiLFxuICAgIFwienpjcnlwdG8ub3JnXCIsXG4gICAgXCJjcnlwdG8uYmdcIixcbiAgICBcIm15Y3J5cHRvMjQub25saW5lXCIsXG4gICAgXCJhY3J5cHRvLmlvXCIsXG4gICAgXCJteWNyeXB0by5jYVwiLFxuICAgIFwic2NyeXB0by5pb1wiLFxuICAgIFwibXljcnlwdG8uZGtcIixcbiAgICBcIm12emNyeXB0by5jb21cIixcbiAgICBcImFtYmNyeXB0by5jb21cIixcbiAgICBcImNyeXB0by5iaVwiLFxuICAgIFwiY3J5cHRvLmpvYnNcIixcbiAgICBcImNyeXB0by5oZWxwXCIsXG4gICAgXCJteS5jcnlwdC5vYnNlcnZlclwiLFxuICAgIFwiY3J5cHQub2JzZXJ2ZXJcIixcbiAgICBcInVjcnlwdG8uY29tXCIsXG4gICAgXCJjcnlwdG9qb2JzbGlzdC5jb21cIixcbiAgICBcImNyeXB0by5yZXZpZXdcIixcbiAgICBcImNyeXB0by5tZVwiLFxuICAgIFwibXljcnlwdG8ubmluamFcIixcbiAgICBcImprY3J5cHRvLmNvbVwiLFxuICAgIFwiY3J5cHRvLmNyXCIsXG4gICAgXCJteWNyeXB0by5saXZlXCIsXG4gICAgXCJ5b2NyeXB0by5pb1wiLFxuICAgIFwiY3J5cHRvLmJhXCIsXG4gICAgXCJ6YWNyeXB0by5pbmZvXCIsXG4gICAgXCJteWNyeXB0by5jb21cIixcbiAgICBcInJlbWl4LmV0aGVyZXVtLm9yZ1wiLFxuICAgIFwibWV0YWhhc2guaW9cIixcbiAgICBcIm1ldGFoYXNoLm5ldFwiLFxuICAgIFwibWV0YWhhc2gub3JnXCIsXG4gICAgXCJjcnlwdG90aXR0aWVzLmNvbVwiLFxuICAgIFwiY3J5cHRvY2l0aWVzLm5ldFwiLFxuICAgIFwiY3J5cHRvc2hpdHRpZXMuY29cIixcbiAgICBcImNyeXB0b3RpdHRpZXMuZnVuXCIsXG4gICAgXCJjcnlwdG9raXR0aWVzLmZvcnNhbGVcIixcbiAgICBcImNyeXB0b2tpdHRpZXMuY2FyZVwiLFxuICAgIFwibWV0YW1hdGUuY2NcIixcbiAgICBcIm1ldGFtYXRlLmlvXCIsXG4gICAgXCJtZXRhbWF0ZS5jb21cIixcbiAgICBcIm1ldGFtYXRlLm9uZVwiLFxuICAgIFwibWV0YW1hdGUueHl6XCIsXG4gICAgXCJtZXRhbWVzaC50ZWNoXCIsXG4gICAgXCJpY28ubmV4dXMuc29jaWFsXCIsXG4gICAgXCJtZXRhbWVzaC5vcmdcIixcbiAgICBcIm1ldGF0YXNrLmlvXCIsXG4gICAgXCJtZXRtYXNrLmNvbVwiLFxuICAgIFwibWV0YXJhc2EuY29tXCIsXG4gICAgXCJtZXRhcGFjay5jb21cIixcbiAgICBcIm1ldGFjYXNlLmNvbVwiLFxuICAgIFwibWV0YWZhcy5ubFwiLFxuICAgIFwibWV0YW1ha28uY29tXCIsXG4gICAgXCJtZXRhbWFzdC5jb21cIixcbiAgICBcIm1ldGFtYXgucnVcIixcbiAgICBcIm1ldGFkZXNrLmNsdWJcIixcbiAgICBcIm1ldGFkZXNrLmlvXCIsXG4gICAgXCJtZXRhZGVzay5ydW5cIixcbiAgICBcIm1ldGFkaXNrLmNvbVwiLFxuICAgIFwibWV0YWxsc2sucnVcIixcbiAgICBcIm1ldGFtYWcuZnJcIixcbiAgICBcIm1ldGFtYWtzLnJ1XCIsXG4gICAgXCJtZXRhbWFwcy5jY1wiLFxuICAgIFwibWV0YW1hcHMuY29cIixcbiAgICBcIm1ldGFtYXBzLmRldlwiLFxuICAgIFwibWV0YW1hcHMubGFuZFwiLFxuICAgIFwibWV0YW1hdHMuY29tXCIsXG4gICAgXCJtZXRhbWF4LmJ5XCIsXG4gICAgXCJtZXRhbWF4LmNvbVwiLFxuICAgIFwibWV0YW1heC5pb1wiLFxuICAgIFwibWV0YW11c2UuaW9cIixcbiAgICBcIm1ldGFtdXNlLm5ldFwiLFxuICAgIFwibWV0YW1hemUuZXVcIixcbiAgICBcIm1ldGFtYXplLndvcmxkXCIsXG4gICAgXCJtZXRhcmFuay5jb21cIixcbiAgICBcIm1ldGF4YXMuY29tXCIsXG4gICAgXCJtZWdhbWFzMi5ydVwiLFxuICAgIFwibWV0YW1hc2suaW9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJldGhlcmV1bS5vcmdcIixcbiAgICBcIm15ZXRoZXJvbGwuY29tXCIsXG4gICAgXCJteWV0aGVyYXBpLmNvbVwiLFxuICAgIFwibGVkZ2Vyd2FsbGV0LmNvbVwiLFxuICAgIFwiZGF0YWJyb2tlcmRhby5jb21cIixcbiAgICBcImV0aGVyc2Nhbi5pb1wiLFxuICAgIFwiZXRoZXJpZC5vcmdcIixcbiAgICBcImV0aGVyLmNhcmRzXCIsXG4gICAgXCJldGhlcm9sbC5jb21cIixcbiAgICBcImV0aG5ld3MuY29tXCIsXG4gICAgXCJldGhleC5tYXJrZXRcIixcbiAgICBcImV0aGVyZXVtZGV2LmlvXCIsXG4gICAgXCJldGhlcmV1bWRldi5rclwiLFxuICAgIFwiZGV0aGVyLmlvXCIsXG4gICAgXCJldGhlcm1pbmUub3JnXCIsXG4gICAgXCJzbGFhc2suY29tXCIsXG4gICAgXCJldGhlcmJ0Yy5pb1wiLFxuICAgIFwiZXRoZXJlYWwuY2FwaXRhbFwiLFxuICAgIFwiZXRoZXJpc2MuY29tXCIsXG4gICAgXCJldGhlcmVjaG8uY29tXCIsXG4gICAgXCJldGhlcmV1bS5vcy50Y1wiLFxuICAgIFwidGhlZXRoZXJldW0ud2lraVwiLFxuICAgIFwibWV0YWphY2suaW1cIixcbiAgICBcImV0aGVyaHViLmlvXCIsXG4gICAgXCJldGhlcmV1bS5uZXR3b3JrXCIsXG4gICAgXCJldGhlcmV1bS5saW5rXCIsXG4gICAgXCJldGhlcmV1bS5jb21cIixcbiAgICBcInByZXRoZXJldW0ub3JnXCIsXG4gICAgXCJldGhlcmV1bWouaW9cIixcbiAgICBcImV0aGVyYXVzLmNvbVwiLFxuICAgIFwiZXRoZXJldW0uZGV2XCIsXG4gICAgXCIxZXRoZXJldW0ucnVcIixcbiAgICBcImV0aGVyZXVtLm56XCIsXG4gICAgXCJuZXRoZXJldW0uY29tXCIsXG4gICAgXCJtZXRhYmFuay5jb21cIixcbiAgICBcIm1ldGFtYXMuY29tXCIsXG4gICAgXCJhdmVudHVzLmlvXCIsXG4gICAgXCJldGhlcmRlbHRhLmNvbVwiLFxuICAgIFwiY3J5cHRva2l0dGllcy5jb1wiLFxuICAgIFwicmVtbWUuaW9cIixcbiAgICBcImppYnJlbC5uZXR3b3JrXCIsXG4gICAgXCJ0d2luaXR5LmNvbVwiLFxuICAgIFwibWV0YWJhc2UuYXJ0XCIsXG4gICAgXCJtZXRhYmFzZS5jb21cIixcbiAgICBcIm1ldGFiYXNlLmNjXCIsXG4gICAgXCJtZXRhYmFzZS5vbmVcIixcbiAgICBcIm1ldGFiYXNlLm5ldHdvcmtcIixcbiAgICBcIm1ldGFiYXNlLnN0dWRpb1wiLFxuICAgIFwibWV0YWJhc2UuZ2dcIixcbiAgICBcImRlY3J5cHRvLm5ldFwiLFxuICAgIFwiYXVkaXVzLmNvXCIsXG4gICAgXCJhdWRpdXMub3JnXCIsXG4gICAgXCJhdWRpdXMuYXBwXCIsXG4gICAgXCJ2ZXJhc2l0eS5pb1wiLFxuICAgIFwib3Jpb25wcm90b2NvbC5pb1wiLFxuICAgIFwiZXRoZXJzcGluLmNvXCIsXG4gICAgXCJhY3R1YS5hZFwiLFxuICAgIFwiYWRpdHVzLmlvXCIsXG4gICAgXCJjYXNzLmFkXCIsXG4gICAgXCJuYWJpcy5jb21cIixcbiAgICBcImZzY3J5cHRvLmNvXCIsXG4gICAgXCJkaXZpbml0eS5haVwiLFxuICAgIFwiZnVsY3J1bS50cmFkZVwiLFxuICAgIFwidG9ycXVlLmxvYW5zXCIsXG4gICAgXCJvbmVzd2FwLm5ldFwiLFxuICAgIFwiZHVjYXR1cy5jb21cIixcbiAgICBcImhlZGdldC5jb21cIixcbiAgICBcImxhZGRlci50b1wiLFxuICAgIFwiYXBwLnRvcm5hZG8uY2FzaFwiLFxuICAgIFwiY29pbmJhc2VkLnh5elwiLFxuICAgIFwiYXNremV0YS5jb21cIixcbiAgICBcImZ1bGNyYS5kZXNpZ25cIixcbiAgICBcImZ1bGNyYS5pb1wiLFxuICAgIFwiYXhsZS5kZXNpZ25cIixcbiAgICBcImNhY3R1cy5jaGF0XCIsXG4gICAgXCJuZmluaXR5LnNwYWNlXCIsXG4gICAgXCJjYXRjdHVzLmlvXCIsXG4gICAgXCJjYXVjdXMuc29cIixcbiAgICBcImV4aW5pdHkuY29tXCIsXG4gICAgXCJtYXJrZWV0YS5za1wiLFxuICAgIFwibWFya2VldGEuY3pcIixcbiAgICBcImNyeXB0b2tuaXR0aWVzLmlvXCIsXG4gICAgXCJmYWN0dXMucnVcIixcbiAgICBcImV0aGVyc2NlbmUuY29tXCIsXG4gICAgXCJtZXRhbWFzaC5jb1wiLFxuICAgIFwibWV0YW1hc2guaW9cIixcbiAgICBcImNhY3R1cy5ibGFja1wiLFxuICAgIFwiYW1hdHVzLmNhcGl0YWxcIixcbiAgICBcIm5maW5pdGUuYXBwXCIsXG4gICAgXCJuZmluaXRlLmluXCIsXG4gICAgXCJmcnVjdHVzLnh5elwiLFxuICAgIFwiZnJ1Y3R1cy5jb1wiLFxuICAgIFwibGlmaW5pdHkuaW9cIixcbiAgICBcIm1ldGFkYXNoLmFwcFwiLFxuICAgIFwib3BlbmtleS5kZXZcIixcbiAgICBcIm9wZW5zZWFsLmNoXCIsXG4gICAgXCJtZXRhZHVzay5pb1wiLFxuICAgIFwibWV0YWJhc2UuZmluYW5jZVwiLFxuICAgIFwibWV0YW1hcmMuaW9cIixcbiAgICBcIm1ldGFwYXNzLmZ5aVwiLFxuICAgIFwicm9jby5maW5hbmNlXCIsXG4gICAgXCJhcmNldXMuZ2dcIixcbiAgICBcIm9wZW5yZXAuZm91bmRhdGlvblwiLFxuICAgIFwiZXNhLmludFwiLFxuICAgIFwib3Blbi5lc2EuaW50XCIsXG4gICAgXCJkYXJrbWV0YS54eXpcIixcbiAgICBcImV2ZXJzY2FuLmlvXCJcbiAgXSxcbiAgXCJibGFja2xpc3RcIjogW1xuICAgIFwiYXp1a2lzaG9wLmxpdmVcIixcbiAgICBcImV0aGVyZWFsYXJ0Lm5mdHMtbWludHMuY29tXCIsXG4gICAgXCJuZnRzLW1pbnRzLmNvbVwiLFxuICAgIFwibW9vbmJpcmRzLnR2XCIsXG4gICAgXCJtb29uYmlyZHMuZ2lmdHNcIixcbiAgICBcImZyZWUtYXp1a2kuY29tXCIsXG4gICAgXCJuZnQtbW9vbmJpcmRzLm5ldFwiLFxuICAgIFwiY3J5cHRvbGF1bmNocy53ZWJmbG93LmlvXCIsXG4gICAgXCJic2NibmIudmlwXCIsXG4gICAgXCJkYXBwc25mdGNvbm5lY3QubmV0bGlmeS5hcHBcIixcbiAgICBcIm5mdHN3aGl0ZWxpc3RkYXBwcy53ZWVibHkuY29tXCIsXG4gICAgXCJldGh0b2tlbnMueHl6XCIsXG4gICAgXCJpbGx1dml1bWMuY29tXCIsXG4gICAgXCJzbWFydHdhbGxldHN5c3RlbS5jb21cIixcbiAgICBcIm11bHRpLWVudGl0eWNoYWlucHJvdG9jb2wubGlua1wiLFxuICAgIFwidmVlZnJlZW5kcy5jb21cIixcbiAgICBcImRlZml1bmkubmV0d29ya1wiLFxuICAgIFwidGdvdngtY29ubi5jb21cIixcbiAgICBcImRlZmlraW5nZG9tcy1wbGF5LmNvbVwiLFxuICAgIFwid2Vic2VydmVyc25ldHdvcmsuY29tXCIsXG4gICAgXCJkYXBwLWFpcmRyb3BzLmlvXCIsXG4gICAgXCJvZmZpY2lhbGFweW5vZGVzLm9ubGluZVwiLFxuICAgIFwiaWxsdWl1bXguY29tXCIsXG4gICAgXCJibG9jay1zeW5jLmxpdmVcIixcbiAgICBcImNyaWF0aXhpbmZvdGVjaC5jb21cIixcbiAgICBcImRlZmkta2ppbmdkb29tcy5jb21cIixcbiAgICBcInBvb2Njb2luLWFwcC50a1wiLFxuICAgIFwibWluaXRhYmUuY29tXCIsXG4gICAgXCJhdXRvcmVjb25uZWN0LmNvbVwiLFxuICAgIFwiYXV0aGVudGljZGFwcC5uZXRcIixcbiAgICBcImJha2VyeXN3YXBlcmVzLm9yZ1wiLFxuICAgIFwiY29sbGFibGFuZHZhbGlkYXRlLmNvbVwiLFxuICAgIFwibWV0bWFza3Nsb2dpLmF6dXJld2Vic2l0ZXMubmV0XCIsXG4gICAgXCJwaW5rc2FsZS56b25lXCIsXG4gICAgXCJkYXBwLmFjY2Vzc2FjdGl2YXRpb24uY29tXCIsXG4gICAgXCJwb2x5Z29uLXRlY2hvbG9nbGVzam9yZC5jb21cIixcbiAgICBcInRla3JvbGxpbmR1c3RyaWFsLmNvbS5iclwiLFxuICAgIFwiZXZlcmRvbWUuaW5cIixcbiAgICBcImF1dGhvcml6ZWRhcHBzLm5ldGxpZnkuYXBwXCIsXG4gICAgXCJtaW50LXNhbmRib3guYXBwXCIsXG4gICAgXCJhcHBzLm1vb25lYmVhbS5uZXR3b3JrXCIsXG4gICAgXCJtdWx0aS1jaGFpbi5pb1wiLFxuICAgIFwidHJ1c3RwYWQtYWlyZHJvcHMuY29tXCIsXG4gICAgXCJkZWNlbnJ0YWxlbmQuY29tXCIsXG4gICAgXCJub2RpZnlsb29wLm9ubGluZVwiLFxuICAgIFwiY29ubmVjdGluZ2F1dGgubWVcIixcbiAgICBcImNyeXB0b2Jhc2Vjb25uZWN0LmNvbVwiLFxuICAgIFwibWFpbmNvaW52YXVsdC5jb21cIixcbiAgICBcImRhcHBzLWNvbm5lY3RzLmxpdmVcIixcbiAgICBcInNlcnZlcnN5bmMubmV0bGlmeS5hcHBcIixcbiAgICBcIml0aGV1bS5uZXR3b3JrXCIsXG4gICAgXCJuYW5vcGFzc25mdC5jb1wiLFxuICAgIFwibWludGluZy1jaGVhcC5jb21cIixcbiAgICBcInN5bmNuZnRzbGluay5saXZlXCIsXG4gICAgXCJhenVraWFpcmRyb3AuY29tXCIsXG4gICAgXCJiaWF1dHdhY29taW4uY29tXCIsXG4gICAgXCJhdXRob3JpemVteXdhbGwubmV0XCIsXG4gICAgXCJldGhwb29sMzY1LmNvbVwiLFxuICAgIFwiYXBpLmNvbGxhYi1sYW5kLmFjXCIsXG4gICAgXCJhenVraS1iZWFuei5jb21cIixcbiAgICBcImFwcC5kYXBwdG9rZW52YWxpZGF0b3IuY29tXCIsXG4gICAgXCJ2ZXN1bnR1cmUuY29tXCIsXG4gICAgXCJ3YWxsZXRub2RlLndlYmZsb3cuaW9cIixcbiAgICBcImNoYWluc3luY3Blcm1pdC5vcmdcIixcbiAgICBcIm1ldGFtYXNrYXBwLmlvXCIsXG4gICAgXCJkZWZmbGtsbmdkb21zLmNvbVwiLFxuICAgIFwiY29sbGFibGFucS5jY1wiLFxuICAgIFwiY292aWQxOS1zeXMuaW9cIixcbiAgICBcImd5YXJpYXN5LmZyb21zbWFzaC5jb21cIixcbiAgICBcInMuZmFzdGlkaW91cy1tYWluZXQuY29tXCIsXG4gICAgXCJjYWxsYWJsYW5kLmNvbVwiLFxuICAgIFwiZXRoLWh1bW1pbmdib3QuY29tXCIsXG4gICAgXCJkZWNlbnRyYWxpemVkd2VwLmNvbVwiLFxuICAgIFwiYXBwbG92aW5zdHVkaW9zLmNvbVwiLFxuICAgIFwidG9rZW5kYXBwdmFsaWRhdG9yLmNvbVwiLFxuICAgIFwid2FsbGV0LXRlY2hub2xvZ3kuaW5cIixcbiAgICBcImRhcHB3YWxsZXRhdXRoZW50aWNhdGlvbi5jb21cIixcbiAgICBcInN1cHBvcnR3ZWJkZWZpLmNvbVwiLFxuICAgIFwiYmdnYi5vcmdcIixcbiAgICBcInNvbWV0aGluZ2lzYnJld2luZy5saXZlXCIsXG4gICAgXCJpbnZzYmxlZnJpZW5kcy1haXJkcm9wLmlvXCIsXG4gICAgXCJjb25uZWN0aWZ5ZGFwcHMubmV0XCIsXG4gICAgXCJjcnlwdG9jb25uZWN0YmFzZS5jb21cIixcbiAgICBcImFzc2V0YWNjZXNzLnNpdGVcIixcbiAgICBcImRhcHBpbnRlZ3JhdG9yLmNvbVwiLFxuICAgIFwibS5yZXN0b3Jld2ViLm9ubGluZVwiLFxuICAgIFwiYWF2ZS5saXZlXCIsXG4gICAgXCJiYXBldGF2ZXJzZS1uZnQuY29cIixcbiAgICBcIm1ldGEtaW5mb3JtYXRpb24uaW9cIixcbiAgICBcInRoZXN5bmNocm9uaXplci5saXZlXCIsXG4gICAgXCJ5YWFhci5pblwiLFxuICAgIFwibWludC1pbnZpc2libGVmcmllbmRzLmlvXCIsXG4gICAgXCJzaWxrLm1pbnQtbGF1bmNoLmNvbVwiLFxuICAgIFwic3luY2MtY29sbGFiLm5ldFwiLFxuICAgIFwieXVnYWxhYnMuYW5kXCIsXG4gICAgXCJ0aGVwcmltZWFwZXBsYW5ldG5mdC5jb21cIixcbiAgICBcIm9tbmlzb2NpZXR5bmZ0LW1pbnQuY29tXCIsXG4gICAgXCJ1bnJvbGxrLmNvbVwiLFxuICAgIFwiaW1hZ2luYXJ5LW9uZXMtbmZ0Lnh5elwiLFxuICAgIFwiZGV4bGF1bmNocGFkLmlvXCIsXG4gICAgXCJ0aGV3ZWlyZG9zLnlvdXJzLW1pbnRzLmNvbVwiLFxuICAgIFwidWVzd2FwLmNsb3VkXCIsXG4gICAgXCJhaXJkcm9wLXRydXN0LmNvbVwiLFxuICAgIFwic3RvcmUuYm9hcmRhcGV5YXJodGNsdWIuY29tXCIsXG4gICAgXCJ3b3JsZG9md29tZW4tbmZ0LmFydFwiLFxuICAgIFwibXVsdGljaGFpbnN5bmMubmV0bGlmeS5hcHBcIixcbiAgICBcIm9wZW5zZWEuY2NcIixcbiAgICBcImFpcmRyb3Atc3BoZXJlLmZpbmFuY2VcIixcbiAgICBcImJuYmZhbWUuaW9cIixcbiAgICBcImJuYmZ1ci5pb1wiLFxuICAgIFwic3Ryb25nYmxvY2tsLmNvbVwiLFxuICAgIFwiYXp1a2kuY2xhaW1cIixcbiAgICBcImFscGhha29uZ3MuY29cIixcbiAgICBcIndlYnNlcnZlcnNuZXR3b3Jrc3MuY29tXCIsXG4gICAgXCJjcnlwdG9yYXRlZnguY29tXCIsXG4gICAgXCJqb2lubW9vbi5uZXRcIixcbiAgICBcImludmlzaWJsZWZyaWVuZC1uZnQuY29tXCIsXG4gICAgXCJhenVraS1kcm9wLmNvbVwiLFxuICAgIFwiYmVhbnotYXp1a2kuY29tXCIsXG4gICAgXCJhenVraS1haXJkcm9wLmNvbVwiLFxuICAgIFwic3luY2hyb25pemF0aW9uLWNvbGxhYi5sYW5kXCIsXG4gICAgXCJjb2luZGFwcHMud2ViZmxvdy5pb1wiLFxuICAgIFwia3ljcy1mb3ItbWV0YWxvY2F0aW9uLmxpdmVcIixcbiAgICBcIm1pbnQtbXV0YW50c2hpYi5jbHViXCIsXG4gICAgXCJib3JlZGFwZXByb2plY3QuY29tXCIsXG4gICAgXCJhbW1taW5lLmNjXCIsXG4gICAgXCJhcGUtY29pbi5jbGFpbXNcIixcbiAgICBcImRhcHBzZGVmaWNoYWluLmNvbVwiLFxuICAgIFwiZGVmaS1hYXZldjMuYXJhYlwiLFxuICAgIFwiZGVmaS1hYXZldjMuYnV6elwiLFxuICAgIFwiZGVmaS1hYXZldjMuaW5mb1wiLFxuICAgIFwiZGVmaS1hYXZldjMubGlmZVwiLFxuICAgIFwiZGVmaS1hYXZldjMubGl2ZVwiLFxuICAgIFwiYXBlLWNvaW4uYXBwXCIsXG4gICAgXCJ3aWxsc21pdGhpbnUuaW9cIixcbiAgICBcImFra3N3YXAuaW9cIixcbiAgICBcInByaW1lYXBlc25mdG1pbnQuY29tXCIsXG4gICAgXCJyZWFsYXBlLWNsdWIuY29tXCIsXG4gICAgXCJzeW5jbnBheS5jb21cIixcbiAgICBcInNoaXJ0dW0uZmFzdG1pbnQub25saW5lXCIsXG4gICAgXCJhcHBsZS5pY29wcmltZWxpc3QuY29tXCIsXG4gICAgXCJjcm9zcy1jaGFpbmJvdC5vcmdcIixcbiAgICBcInBlZ2FzeHkubmV0XCIsXG4gICAgXCJ0cm9uaXhkYXBwLmNvbVwiLFxuICAgIFwieWdhbGF4eTE2OC5jb21cIixcbiAgICBcIm1pbmluZ3MuYmV0XCIsXG4gICAgXCJ0cnVzdHdhbGxldC54aWFtaWNvaW4udG9wXCIsXG4gICAgXCJ0cng1ODE2OC5jb21cIixcbiAgICBcInRydXN0d2FsbGV0ZGFwcC52aXBcIixcbiAgICBcImRhcHAtY29sbGFiLmxhbmRcIixcbiAgICBcImRlZmkuaW50ZXJuYXRpb25hbHRyYy5jb21cIixcbiAgICBcImRwZXRobWluLmNvbVwiLFxuICAgIFwidmFsaWRhdGlvbmZpeHN3YWxsZXRzLm9yZ1wiLFxuICAgIFwiZnJlZS1haXJkcm9wLmNvbVwiLFxuICAgIFwic29zdGluZXNrbC5sdFwiLFxuICAgIFwiZXJpY3dhdXN0aW4uY29tXCIsXG4gICAgXCJtYXljLnNwYWNlXCIsXG4gICAgXCJydGZrdC1naXZlYXdheS5jb21cIixcbiAgICBcImFwZWNvaW5jbGFpbWVyLmNvbVwiLFxuICAgIFwib3RoZXJzaWRld2wuY29tXCIsXG4gICAgXCIwYXJteS5pb1wiLFxuICAgIFwidHdmbmZ0LnNob3BcIixcbiAgICBcImxhenltdXRhbnRsaW9uLmNvbVwiLFxuICAgIFwiY29ycmVjdGlvbndlYnkubmV0bGlmeS5hcHBcIixcbiAgICBcImFwcC5pbXBvcnR3YWxsZXRzLmNvbVwiLFxuICAgIFwicHJlc2FsZS5zZWVzYXdwcm90b2NvbC5pb1wiLFxuICAgIFwibWFpbm5ldGRhcHB3YWxsZXRzLmNvbVwiLFxuICAgIFwibG91aXN2dWl0dG9ubmZ0cy50b3BcIixcbiAgICBcInRva2VuZml4Lm5ldFwiLFxuICAgIFwiYzBsYWJsYW5kLmNvbVwiLFxuICAgIFwiYzBsYWJsYW5kLmlvXCIsXG4gICAgXCJjYWxsYWJsYW5kLmNjXCIsXG4gICAgXCJvdHAtbWV0YW1hc2suaW9cIixcbiAgICBcIndhbGxldC12YWxpZGF0aW9uLm5ldGxpZnkuYXBwXCIsXG4gICAgXCJhdXRvbWF0aWNkZXhzeW5jaHIuY29tXCIsXG4gICAgXCJjcnlwdG93YWxsZXRjb25uZWN0b3IuY29tXCIsXG4gICAgXCJub3JkZGFwcHZlcmlmaWNhdGlvbi5uZXRsaWZ5LmFwcFwiLFxuICAgIFwic29sdXRpb24tZml4Lm9ubGluZVwiLFxuICAgIFwiYXBlY29pbi5ldmVudHNcIixcbiAgICBcImNlcmVhbGVudHJlcHJlbmV1cnMuYWNhZGVteVwiLFxuICAgIFwidmVyaWZpZWRtZXRhbm93Lm5ldFwiLFxuICAgIFwiZGFwcGludGVncmF0ZXMubWVcIixcbiAgICBcImRhcHBzcHJvdG9jb2xzLnRlY2hcIixcbiAgICBcImF1dGhlbnRpY2F0ZWRhcHBzLm9yZ1wiLFxuICAgIFwiYjBtYmVjcnlwdDAuY29tXCIsXG4gICAgXCJwdHQ5Ny5jb21cIixcbiAgICBcInNtYXJ0cGFpcmluZy5uZXRcIixcbiAgICBcIm1pbnQuYWxwaGFkb2dzLnJ1blwiLFxuICAgIFwiYXBlc2NvaW4ub25saW5lXCIsXG4gICAgXCJkZWZpLWFhdmV2My5saW5rXCIsXG4gICAgXCJldGgtYWF2ZS5vcmdcIixcbiAgICBcImRlZmktYWF2ZXYzLmNsdWJcIixcbiAgICBcImNvaW5iYXNlY2xvdWQuY2x1YlwiLFxuICAgIFwiZXRvcm8uem9uZVwiLFxuICAgIFwiZGVmaS1hYXZldjMuZnVuXCIsXG4gICAgXCJldGgtcGFuZGEuY29tXCIsXG4gICAgXCJkZWZpLWxwLmJpelwiLFxuICAgIFwiZGVmaS1jbG91ZC5jbG91ZFwiLFxuICAgIFwiZXRoLWFhdmUueHl6XCIsXG4gICAgXCJhbW11bmkuc2hvcFwiLFxuICAgIFwidXNkdC1ldGhlci5iZXRcIixcbiAgICBcImFwZS1jb2luLmFydFwiLFxuICAgIFwiY29sYWJjb25uZWN0LmxhbmRcIixcbiAgICBcImRhcHByZWF1dGhlbnRpY2F0ZS5vcmdcIixcbiAgICBcImRhcHBzLWFpcmRyb3BzLmlvXCIsXG4gICAgXCJtZXRhbWFza3RpY2tldC5jb21cIixcbiAgICBcImRlZmktZXRodS5tZVwiLFxuICAgIFwibmZ0d29yaWJzLmNvbVwiLFxuICAgIFwibWV0YXdpemFyZHNuZnQubWludC10b29sLmNvbVwiLFxuICAgIFwiZGVjZXRucmFsLmd1cnVcIixcbiAgICBcIm1haW5kYXBwc2Nvbm5lY3Qub3JnXCIsXG4gICAgXCJibG9rcGFkbGF1bmNoLmNvbVwiLFxuICAgIFwibGlxdWRkcml2ZXIuZmluYW5jZVwiLFxuICAgIFwidXAxLm9yZ1wiLFxuICAgIFwibWF5Y2Rhby5pb1wiLFxuICAgIFwiY29ubmVlY3QtbGFubmQub3JnXCIsXG4gICAgXCJhcHAuZGVmaXNlcnZlcnByb3RvY29scy5jb21cIixcbiAgICBcInBsYW5ldGFwZS5jb1wiLFxuICAgIFwidHJpbGxpb25haXJldGh1Z3MubWludGluLmluZm9cIixcbiAgICBcImFwcHBvbHlnb24ubmV0XCIsXG4gICAgXCJldGgtY29pbi5jbHViXCIsXG4gICAgXCJjb25uZWN0c3dhbGxldHMud2ViZmxvdy5pb1wiLFxuICAgIFwiZGVjZW50cmFsaXplZG5vbmNlLm9yZ1wiLFxuICAgIFwibGl2ZS1uZnQtbWludC5jb21cIixcbiAgICBcImFwZS1jb2luLm5ldFwiLFxuICAgIFwicGVnYXh5LnB3XCIsXG4gICAgXCJwZWdheC55dnRlLmNvbVwiLFxuICAgIFwicHJvdG9jb2xzcmVzb2x2ZXNpdGUuY29tXCIsXG4gICAgXCJtZXRhbWFzay5pby53ZWI3NjE1LndlYjA3LmJlcm8td2Vic3BhY2UuZGVcIixcbiAgICBcIm1ldGFtYWtyZWNvdmVyeTIwMjIuY29tXCIsXG4gICAgXCJjMGxsYWJsYW5kLmNvbVwiLFxuICAgIFwiYXBwLmRpbm9sbGFuZC5pb1wiLFxuICAgIFwiY29ubmVjdGxlZGdlbGl2ZS5jb21cIixcbiAgICBcImxvb2tzcmFyZS5uZXdzXCIsXG4gICAgXCJsb29rc3JhcmUuZnVuXCIsXG4gICAgXCJsb29rc3JhcmUub25nXCIsXG4gICAgXCJsb29rc3JhcmUubmdvXCIsXG4gICAgXCJsb29rc3JvcmUub3JnXCIsXG4gICAgXCJzb3VsbHouY29tXCIsXG4gICAgXCJ0b2tlbmluZm8ubmV0bGlmeS5hcHBcIixcbiAgICBcImxhbmRhdXRoLm1lXCIsXG4gICAgXCJjb2xsYXFsYW5kLmNjXCIsXG4gICAgXCJ3ZWIuY29ubmVjdGFzc2lzdC5saXZlXCIsXG4gICAgXCJvcGVuc2VhLWd3LmFydFwiLFxuICAgIFwiYXBlY29pbi5jbGFpbXNcIixcbiAgICBcInNwYWNlZG9vZGxlcy5vcmdcIixcbiAgICBcImdhbWVkZWZpa2luZG9tcy5jb21cIixcbiAgICBcIm1ldGEtYXBwbGljYXRpb24ueHl6XCIsXG4gICAgXCJkb29kbGVzbWludC5jb21cIixcbiAgICBcImRwcHRlc3QwMDEtYjZjYmEud2ViLmFwcFwiLFxuICAgIFwiaW52aXNpYmxlZnJpZW5kcy1uZnQuY29cIixcbiAgICBcInJlYWxhcGVjbHViLmNvXCIsXG4gICAgXCJlLWNyeXB0Y2hhaW5zLmNvbVwiLFxuICAgIFwicHJlc2FsZS1tZXRhdHJpYWRzLm9yZ1wiLFxuICAgIFwiZGFhcGtpdHMuY29tXCIsXG4gICAgXCJhbW1taW5lLmNsdWJcIixcbiAgICBcImFtbW1pbmUuY29tXCIsXG4gICAgXCJhbW1taW5lLnByb1wiLFxuICAgIFwiYW1tbWluZS5pbmZvXCIsXG4gICAgXCJhbW1taW5lLm9yZ1wiLFxuICAgIFwid29ybGRjaGFpbi5vbmxpbmVcIixcbiAgICBcIm9ubHl0cmFuc2ludGVyZmFjZS5uZXRsaWZ5LmFwcFwiLFxuICAgIFwiY29ubmVjdHdhbGxldGZpeC5jb21cIixcbiAgICBcIndhbGxldGNvbm5lY3RoZWxwZGVzay5uZXRsaWZ5LmFwcFwiLFxuICAgIFwic2VjdXJlZHByb3RvY29scy5uZXR3b3JrXCIsXG4gICAgXCJicmlkZ2Vwcm90b2NvbGZpeC5uZXRcIixcbiAgICBcInZhbGlkYXQwcmRlc2suY29tXCIsXG4gICAgXCJyYXJpdHl0b29scy5vbmxpbmVcIixcbiAgICBcIndlYjNub2Rlcy5saW5rXCIsXG4gICAgXCJ3YWxsZXQtZGFwcHMuc2l0ZVwiLFxuICAgIFwid29ybGRjaGFpbnMub25saW5lXCIsXG4gICAgXCIycmZsZS5jb21cIixcbiAgICBcImRlZmljb25uZWN0Lm5ldGxpZnkuYXBwXCIsXG4gICAgXCJhcHBzeW5jcGFnZS5saXZlXCIsXG4gICAgXCJ3YWxsZXR2YWxpZGF0b3Iub25yZW5kZXIuY29tXCIsXG4gICAgXCJkYXBwLXN5bmMuaGVyb2t1YXBwLmNvbVwiLFxuICAgIFwidHJ1c3RwYWQuY2xhaW1zXCIsXG4gICAgXCJ1bmktZGVmaXMuY29tXCIsXG4gICAgXCJ2ZXJpZnktbmZ0bm93LmNvbVwiLFxuICAgIFwidmF1bHRyZWNpdGZpY2F0aW9uLmNvbVwiLFxuICAgIFwidXNlLXRoZXNhbmRib3guY29tXCIsXG4gICAgXCJtaW50LWhvbHl2ZXJzZW5mdC5jb21cIixcbiAgICBcImNsb3VkLWV0aC5jY1wiLFxuICAgIFwibmZ0Y29sbGFicGFkcy5vcmdcIixcbiAgICBcIm11b24tdG9rZW4uc2FsZVwiLFxuICAgIFwiYXBwLmFjY2Vzc2FjdGl2YXRpb25ib3QuY29tXCIsXG4gICAgXCJpcHRzYi5jb20ubXlcIixcbiAgICBcInN1cHBvcnRtZXRhbWFzay5uZXRqaWxpZnkuYXBwXCIsXG4gICAgXCJkZXgtYWlyZHJvcHMuY29tXCIsXG4gICAgXCJjb2lucmVzb2x2ZS5jb21cIixcbiAgICBcImFudG9ueW0ubWludGluZ3MuY2x1YlwiLFxuICAgIFwiY2ItdHRpLmNvbVwiLFxuICAgIFwiYXp1a2kubWludHNlY3VyZS5pb1wiLFxuICAgIFwiYXp1a2ktbWludC5hcnRcIixcbiAgICBcImRub2RlY29ubmVjdC5jb21cIixcbiAgICBcImFwcC5lbmVyZ3licmlkZ2UuaW9cIixcbiAgICBcIm1haW5uZXRjb25uZWN0aW9ucy5jb21cIixcbiAgICBcInZveWFnZXJzdW5rbm93bm1pbnQuY29tXCIsXG4gICAgXCJzcGludGVyc2xhbmRzLmNvbVwiLFxuICAgIFwicGVnYXh5LTFwbGF5LmNvXCIsXG4gICAgXCJtYWlubmV0LXJlY3RpZnkuY29tXCIsXG4gICAgXCJkZWZpLWFhdmV2My50ZWNoXCIsXG4gICAgXCJzdGVwaGVyby1ldmVudC5jb21cIixcbiAgICBcInRoZXJ1ZGVraWR6LmFydFwiLFxuICAgIFwic3dpZnRkYXBwc2NvLm9ubGluZVwiLFxuICAgIFwibGEudHJyZWNvaW4uY2NcIixcbiAgICBcIndhbGxldHNlY3VyZXZhbC5jb21cIixcbiAgICBcIm11cmFrYW1pZmxvd2Vycy1rYWlrYWlpa2lraS5jb21cIixcbiAgICBcImRleHNvbHV0aW9uLm9ubGluZVwiLFxuICAgIFwiY29ubmVjdC5kYXBjb25uZWN0bGl2ZS5jb21cIixcbiAgICBcIndhbGxldGNvbm5lY3QtdmVyaWZpY2F0aW9uLm5ldGxpZnkuYXBwXCIsXG4gICAgXCJkZWZpZWFybi12aXAuY29cIixcbiAgICBcInNhbmJkb3hkZWZpZ2FtZS5zcGFjZVwiLFxuICAgIFwic21hcnRjb25uZWN0ZGFwcC5vbmxpbmVcIixcbiAgICBcIm5ldXRyYWxwcm90b2NvbC5zaXRlXCIsXG4gICAgXCJhcHBzLndhbGxldHZhbGlkYXRlbGl2ZS5jb21cIixcbiAgICBcImNvaW5zb2x1dGlvbi5wd1wiLFxuICAgIFwibWV0YW1hbnNpb25zbmZ0LW1pbnQuY29tXCIsXG4gICAgXCJzbmV3ZWFzeS5jb21cIixcbiAgICBcInVzZHQtZXRoZXIuY2NcIixcbiAgICBcIndhbGxldC1wb2x5Z29udGVjaG5vbGFneS5jb1wiLFxuICAgIFwibWludC1tYW1tZXRocy5jb21cIixcbiAgICBcIm1hdGljZm9ydW0ubGl2ZVwiLFxuICAgIFwicG9seWdvbi1ic2MtYnJpZGdlLmNvbVwiLFxuICAgIFwiY29tcGFueS1hdG9taWMuY29tXCIsXG4gICAgXCJkYW9tYWtlci5jb20ubXNcIixcbiAgICBcIndhbGxldC1jb25uZWN0LW1ldGEuY29tXCIsXG4gICAgXCJ3YWxsZXQtbWV0YS1jb25uZWMuY29tXCIsXG4gICAgXCJ2YWxpZGF0aW9ub3BlbnNlYS5jb21cIixcbiAgICBcIm15c2VjdXJlLWRuc3NlcnZlci5jb21cIixcbiAgICBcIjJvbWJzLmZpbmFuY2VcIixcbiAgICBcIm1ldGFtYXNrd2Vid2FsbGV0LmlvXCIsXG4gICAgXCJtZXRhbWFzay1tb2JpbGUuaW9cIixcbiAgICBcImN5Y2xpY3N3aXRjaC5vbmxpbmVcIixcbiAgICBcIm1ldGFzYWZlLmRkbnMubmV0XCIsXG4gICAgXCJhcG9jYWx5cHRpYy1hcGVzLmNvXCIsXG4gICAgXCJhaXJkcm9wLXRydXN0cGFkLmlvXCIsXG4gICAgXCJpbnZpc2liaWxmcmllbmRzLmNvbVwiLFxuICAgIFwiYmF5Y25mdGMuaW9cIixcbiAgICBcImVzeXN0ZW1wcm90b2NvbHMuY29tXCIsXG4gICAgXCJlcnJvcmNvcnJlY3Rpb25zLmNvbVwiLFxuICAgIFwiZGVjZXJ0cmFsYW5kLm9yZ1wiLFxuICAgIFwidmFsaWR3YWxsZXRjb25uZWN0LmxpdmVcIixcbiAgICBcIm1ldGFtYXNrLmlvLW55enduaHlhLnJ1XCIsXG4gICAgXCJ2b3lhZ2VyLXVua25vd24uY29tXCIsXG4gICAgXCJhcG9jYWx5cHRpY2FwZXMuY29cIixcbiAgICBcImRlZmkuaHktZXRoLm5ldFwiLFxuICAgIFwicG9seWduLXRlaG5vbGVneS5kaWdpdGFsXCIsXG4gICAgXCJzZW5kYmF4Z2FtZS5jb21cIixcbiAgICBcImNvbGxhYmxhbmQuYm1pZmN1LnNlcnZpY2VzXCIsXG4gICAgXCJkYXBwc2xpbmsub3JnXCIsXG4gICAgXCJ2ZXJpZnltZXRhbWFzay5pb1wiLFxuICAgIFwibW0tc3VwcG9ydC5pb1wiLFxuICAgIFwibW0tcmVuZXcuaW9cIixcbiAgICBcIm1tLXVwZGF0ZXMuaW9cIixcbiAgICBcIm1tLXVwZGF0ZS5pb1wiLFxuICAgIFwibW0tcmVjb3ZlcnkuaW9cIixcbiAgICBcIm1tLWF3YXJlLmlvXCIsXG4gICAgXCJtbS12ZXJpZnkuaW9cIixcbiAgICBcIm1tLXdlYi5pb1wiLFxuICAgIFwibW0tYWxlcnQuaW9cIixcbiAgICBcIm1ldGFtLWFzay5pb1wiLFxuICAgIFwibW0tc2VydmljZS5pb1wiLFxuICAgIFwiY29vbG1hbnN1bml2ZXJzZS54eXpcIixcbiAgICBcImNvc21pY2NhdHMuaW8uc3dhZGV4Zmkub25saW5lXCIsXG4gICAgXCJhY2Nlc3MtY29sbGFiLmxhbmRcIixcbiAgICBcImdpdmUtc2VhLmNvbVwiLFxuICAgIFwiaGVscG1ldGFtYXNrLm9ubGluZVwiLFxuICAgIFwiYW5lc3dhcC5jb21cIixcbiAgICBcInNvdWx6em5mdC5jb21cIixcbiAgICBcImZpeGVycm9yd2FsbGV0Lm9yZ1wiLFxuICAgIFwid2FsbGV0aW5zdGFudHNvbHV0aW9ucy53ZWVibHkuY29tXCIsXG4gICAgXCJsb29rc3JhcmVkYXBwLmxpdmVcIixcbiAgICBcImZpeHN1cHBvcnQub25saW5lXCIsXG4gICAgXCJuZXctY29sbGFiLmxhbmRcIixcbiAgICBcImRhcHBzc3VwcG9ydC5jb1wiLFxuICAgIFwibG9va3NycXJlLm9yZ1wiLFxuICAgIFwidGhlZGFwc2F1dGguY29tXCIsXG4gICAgXCJzeW5jcmVzdG9yZS5tZVwiLFxuICAgIFwiZGFwcGNvbm5lY3Qud2ViZmxvdy5pb1wiLFxuICAgIFwiZHdpbnRkYXBwcy5jb21cIixcbiAgICBcIndhbGxldGNvbm5lY3Qtc3luY2hyb25pemUuY29tXCIsXG4gICAgXCJhbGxldGJyaWRnZXMuY29tXCIsXG4gICAgXCJ3YWxsbGl2ZWVuY3J5cHQuY29tXCIsXG4gICAgXCJvbmx5aW50ZXJtZXJpdGFwcHMubmV0bGlmeS5hcHBcIixcbiAgICBcIm1pbnQtcmFpbmJveWNsdWIuY29tXCIsXG4gICAgXCJkYXBwc2ludC5jb21cIixcbiAgICBcInN1cHBvcnRwYWdlcy5vcmdcIixcbiAgICBcIndhbGxldGF1dGhlbnRpY2F0aW9ucy51c1wiLFxuICAgIFwiaWFuY29sZW1hbnZhbGlkYXRvci5jb21cIixcbiAgICBcInNvdWlsei5jb21cIixcbiAgICBcImRhcHBzbmV0d29yay5jb1wiLFxuICAgIFwiY3J5cHRvdmFsaWRhdG9yLm9yZ1wiLFxuICAgIFwiaW5zdGFudGNvbm5lY3RzZml4ZWQuY29tXCIsXG4gICAgXCJjb2xsYWJ2YWxpZGF0b3IuY29tXCIsXG4gICAgXCJ3YWxsZXRhcHBzLmNsb3VkXCIsXG4gICAgXCJyZWNvdmVyeXdhbGxldC5uZXRcIixcbiAgICBcImRhcHBzb2x2ZXRlY2gub3JnXCIsXG4gICAgXCJ3YWxsZXRmaXguZGV2XCIsXG4gICAgXCJzaG9ydC1wcm9jZXNzLmFwcFwiLFxuICAgIFwibWFpbm5ldHN1cHBvcnQub25saW5lXCIsXG4gICAgXCJub2Rlc2RhcHAub3JnXCIsXG4gICAgXCJzcGVlZGJpdHMub3JnXCIsXG4gICAgXCJkYXBwc3Rvb2xzY29ubmVjdHMuY29tXCIsXG4gICAgXCJkZWZpYXNzZXRzeW5jLmNvbVwiLFxuICAgIFwid2FsbGV0YXV0aC1kYXBwcy5vcmdcIixcbiAgICBcImRhcHBzZm9yYWxsLmNvbVwiLFxuICAgIFwiYnJpZ2Vwcm90b2NvbC5saW5rXCIsXG4gICAgXCJzb3Vsem1pbnRlci54eXpcIixcbiAgICBcImRldmljZS1hdXRoZW50aWNhdGlvbi1kYXBwc3Byb3RvY29sLW1lY2hhbmlzbS53ZWVibHkuY29tXCIsXG4gICAgXCJ3YWxsZXRjb25uZWN0cy1zeW5jLmNvbVwiLFxuICAgIFwibWludC1jb29sY2F0c25mdC5jb21cIixcbiAgICBcIm1ldGFtYXNrMS5pb1wiLFxuICAgIFwiYy0wMW5mdG1pbnQuY29tXCIsXG4gICAgXCJoYXBlYmVhc3QtbmZ0LmlvXCIsXG4gICAgXCJ3ZWJjb25uZWN0aW5nd2FsbGV0cy5uZXRcIixcbiAgICBcImRhcHAuYWN0aXZhdGlvbmFjY2Vzcy5jb21cIixcbiAgICBcImZpeGNvbm5lY3QuY2xpY2tcIixcbiAgICBcImRhcHBzLW5vZGUubGlua1wiLFxuICAgIFwiY2hhaW5wcm90b2NvbC50b29sc1wiLFxuICAgIFwibWV0YW1hc2std2FsbGV0LXN5bmMtMTAzNDQ0LnNxdWFyZS5zaXRlXCIsXG4gICAgXCJtb29keWFwZWNsdWIuYXBwXCIsXG4gICAgXCJtdWx0aWJyaWRnZWRhcHBzLmNvbVwiLFxuICAgIFwiZGFwcHNsYXVuY2hlci5vcmdcIixcbiAgICBcImNvbGxhYmxhbmRqb2luaG9sZGVyLnVrb2Zmc2hvcmVhY2NvdW50cy5jb21cIixcbiAgICBcInhwdWJjYWxjdWxhdG9ycy5jb21cIixcbiAgICBcIndhbGxldC1zeW5jLmhlcm9rdWFwcC5jb21cIixcbiAgICBcImRlZmllcnJvcnZhbGlkYXRvci5jb21cIixcbiAgICBcIndlYi1kYXBwc2Nvbm5lY3QubmV0XCIsXG4gICAgXCJsYW5kLnhuLS02ZnJ6ODJnXCIsXG4gICAgXCJhdXRoLWNvbm5lY3Rvci5jb21cIixcbiAgICBcImRhcHB3YWxsZXRleHRlbnNpb24uY29tXCIsXG4gICAgXCJhbmdyeXNwaXRidWxsY2x1Yi5jb21cIixcbiAgICBcIm1hcmtldHBsYWNlLnRoZXRhbnNhcmVuYS5jb21cIixcbiAgICBcIndhbGxldGVhdXRob3JpemF0aW9uLmNvbVwiLFxuICAgIFwiaW5iZXR3ZW5lcnMuY29tXCIsXG4gICAgXCJzaGliYXNvY2lhbHNjbHViLmNvbVwiLFxuICAgIFwicmVhdXRoZW50aWNhdG9yLm9ubGluZVwiLFxuICAgIFwicG9seWdvbmNoYWluLmlvXCIsXG4gICAgXCJkYXBwc3JhZGVyLmNvbVwiLFxuICAgIFwiZGVmaWVhc2UubmV0XCIsXG4gICAgXCJkYXBub2Rlc2Nhbi5jb21cIixcbiAgICBcIm1haW5uZXRub3cuY29tXCIsXG4gICAgXCJzb3Vsei1uZnQuY29tXCIsXG4gICAgXCJ3YWxsZXRjaGFpbnN5bmMuc3VyZ2Uuc2hcIixcbiAgICBcImRlZmktY29uZWN0cy5jb21cIixcbiAgICBcIndlYmF1dGhkYXBwcy5jb21cIixcbiAgICBcImZvcnVtc21hdGljLm5ldHdvcmtcIixcbiAgICBcInBpbmtzYWxlZmluYW5jZXMuY29tXCIsXG4gICAgXCJ4bi0tc2FtdXJhc2FnYS1jOWEuY29tXCIsXG4gICAgXCJ2bGF1bmNoLm9ubGluZVwiLFxuICAgIFwibm9uZnVuZ2libGVhbGxpZW5zLmNvbVwiLFxuICAgIFwiY2xvbmV4LnJsZmt0LmNvbVwiLFxuICAgIFwiZmxpcHBlZGJheWMuY2x1YlwiLFxuICAgIFwidXNkdC1iZWVzdGFrZS5zaXRlXCIsXG4gICAgXCJ0aGVib3JlZGJ1bm5pZXMuY29tXCIsXG4gICAgXCJldGgtY29pbi5jY1wiLFxuICAgIFwiYWRpZGFzLW1pbnQubmV0XCIsXG4gICAgXCJxcmN1bmlnZW4uY29tXCIsXG4gICAgXCJldGh1MmUuY29tXCIsXG4gICAgXCJ0aGVpbnZpc2libGVmcmllbmRzLmlvXCIsXG4gICAgXCJoeXBlYmVhcnNjbHViLmNvbVwiLFxuICAgIFwiY3J5cHRvcmVwYWlyLmlvXCIsXG4gICAgXCJ3ZWIzbm9kZXMubmV0d29ya1wiLFxuICAgIFwiZGFwcGNvbm5lY3R3YWxsZXQud2ViLmFwcFwiLFxuICAgIFwiZGFwcGNoYWluc2Nvbm5lY3QuY29tXCIsXG4gICAgXCJhbGxub2RlZGFwLmNvbVwiLFxuICAgIFwiYmFja2VuZHdlYi5vbmxpbmVcIixcbiAgICBcInN5bmMtdmFsaWRhdGlvbi5jb21cIixcbiAgICBcIm1haW5ldGludGVncmF0aW9uLmNvbVwiLFxuICAgIFwiZGVmaXByb3RvY29scy5vbmVcIixcbiAgICBcIndhbGxldHNhdXRoeS53ZWJmbG93LmlvXCIsXG4gICAgXCJ3YWxsZXRzeW5jLWRhcHBzLmNvbVwiLFxuICAgIFwibm9kZXZlcmlmeS5jb21cIixcbiAgICBcIm9ubmVjdGRhcHBzLmluZm9cIixcbiAgICBcImRub2RlLWxpbmsuY29cIixcbiAgICBcImdldGFjdGl2ZXdhbGxldC5uZXRsaWZ5LmFwcFwiLFxuICAgIFwid2FsbGV0dmFsaWQud2ViZmxvdy5pb1wiLFxuICAgIFwic3dpZnRzeW5jcy5pb1wiLFxuICAgIFwiZGVmaS1hcHBzb2x1dGlvbnMuY29tXCIsXG4gICAgXCJkYXBwc2xpdmV3YWxsZXRzY29ubmVjdHMubmV0XCIsXG4gICAgXCJkYXBwc2Nvbm4uY29tXCIsXG4gICAgXCJtYWlud2FsbGV0YXV0aG9yaXNhdGlvbi5uZXRcIixcbiAgICBcIm1ldGF3YWxsZXQuY29tLnRyYXZlbHBsdXMuZ3JcIixcbiAgICBcImxvb2tzcmFyZXN1cHBvcnQub3JnXCIsXG4gICAgXCJsb29pay1yYXJlcy5vcmdcIixcbiAgICBcImxvb2tzcmFscmUub3JnXCIsXG4gICAgXCJsb29rc3JhcmUub3JnLnVhXCIsXG4gICAgXCJsb29rc3JhcmVzLm9yZ1wiLFxuICAgIFwibG9va3NhcmUudG9wXCIsXG4gICAgXCJsaW9va3NyYXJlLmNvbVwiLFxuICAgIFwibG9va3NhcmFyZS5vcmdcIixcbiAgICBcImxvb2tzcmFyZW0ub3JnXCIsXG4gICAgXCJsb29rc2FyYXJlLnRlY2hcIixcbiAgICBcImZpeGVkdmFsaWRhdGVzd2FsbGV0ZXJyb3JzLm9yZ1wiLFxuICAgIFwic3luY3dhbGxldGNsb3VkLm9yZ1wiLFxuICAgIFwic21hcnRkYXBwd2FsbGV0c2Nvbm5lY3QuY29tXCIsXG4gICAgXCJkYXBwbW9iaWxlc3luYy5jb1wiLFxuICAgIFwiaW1wb3J0dmFsaWRhdG9yLmNvbVwiLFxuICAgIFwibWV0YW1hc2syeC5jb21cIixcbiAgICBcImRhcHBzeW5zY29ubmVjdC5vcmdcIixcbiAgICBcIm1ldGFibGFjay5zb2Z0d2FyZVwiLFxuICAgIFwiZ2FtZS1ib21iY3JpcHRvLWNvbS5qY2xvdWQua3pcIixcbiAgICBcInRoZWJpZ2NhdHMuYXJ0XCIsXG4gICAgXCJyZWFsYXBlc2NsdWIuY29cIixcbiAgICBcImNvbGxhYi1sYW5kLmN4XCIsXG4gICAgXCJib3JlZC1hcGUudXNcIixcbiAgICBcInJvd2R5c29jaWV0eS5hcnRcIixcbiAgICBcImx1Y2t5bGlvbmNsdWIuYXJ0XCIsXG4gICAgXCJkZWNuZXRhcmxhbmQub3JnXCIsXG4gICAgXCJkZWNudGVyYWxhbmQub3JnXCIsXG4gICAgXCJiYXljLW5mdC5jb21cIixcbiAgICBcInRoZXRyb253YXJzLmFydFwiLFxuICAgIFwiYWNjZXNzLXBvb2NvaW5uLmNvbVwiLFxuICAgIFwibWV0YWRhdGEuaW8udGFtYm9va3Mudm5cIixcbiAgICBcImtpbGxlcmdmLm1pbnRpbi5vcmdcIixcbiAgICBcIm9mZmljaWFsbW0uY29tXCIsXG4gICAgXCJtZXRhbWFzay14cHVicy53ZWIuYXBwXCIsXG4gICAgXCJtaW50LW1vbnN0ZXJhcGVjbHViLmFydFwiLFxuICAgIFwidmVyaWZ5bWV0YS5uZXRcIixcbiAgICBcIm1ldGFzZXJjb24uY29tXCIsXG4gICAgXCJvbGRhcGVjb3VudHJ5Y2x1Yi5zdG9yZVwiLFxuICAgIFwic2hpZnRlcnNuZnQuaW9cIixcbiAgICBcImRlY250ZXJhbGFuZC5jb21cIixcbiAgICBcInN1cHBvcnRtZXRhbWFza3MubmV0bGlmeS5hcHBcIixcbiAgICBcInBkb3QuaW9cIixcbiAgICBcInBkb3QuYXBwXCIsXG4gICAgXCJ5ZXRpc3dhcC5pb1wiLFxuICAgIFwibWludC1henVraS5pblwiLFxuICAgIFwibXV0YW50YXBlc3BsYW5ldC5jb21cIixcbiAgICBcInN5bmNocm9uYXBwcy5jb21cIixcbiAgICBcImRhcHAtYWlyZHJvcC5jb21cIixcbiAgICBcImtpdHR5Y3J5cHRvZ2FuZ29mZmljaWFsLmNvbVwiLFxuICAgIFwiem9uZS1zYWxlcy5uZXRsaWZ5LmFwcFwiLFxuICAgIFwiYXBwLm9wcmVzYWxlLmNvbVwiLFxuICAgIFwibWFrZXJvbWV0YS5vcmdcIixcbiAgICBcIm1pbnQtYWRpZGFzLmFwcFwiLFxuICAgIFwibWV0YW5uYXNrLXZlcmlmaWNhdGlvbi5jb21cIixcbiAgICBcImJhcGVzLm5ldFwiLFxuICAgIFwiZXRoLWludmVzdDIxLm9yZ1wiLFxuICAgIFwicGFsa2FzdGFydGVyLmNvbVwiLFxuICAgIFwiZHJhcHAud2ViM3NvbHV0aW9uc1wiLFxuICAgIFwicGFucXVla2VzYXdwLmNpZW5jZVwiLFxuICAgIFwiaW52aXNpYmxlZnJpZW5kcy1zYWxlLmlvXCIsXG4gICAgXCJjb2luYmFzZS1taW5pbmcubmV0XCIsXG4gICAgXCJiaXRsaXZlY29ubmVjdC5jb21cIixcbiAgICBcImZhc3R3YWxsZXRmaXguY29tXCIsXG4gICAgXCJtYXNrYmlsbGlvbmFpcmVuZnQubWludHBsYXRmb3JtLmRlc2lnblwiLFxuICAgIFwibWludHBsYXRmb3JtLmRlc2lnblwiLFxuICAgIFwic3Rhcmxpbmt0b2tlbi1wcmVzYWxlLmNvbVwiLFxuICAgIFwiYmluYW5jZS1naXZlYXdheS5oZWF2ZW5seXR1bmVzLmNvLnphXCIsXG4gICAgXCJ3YWxsZXRzdmFsaWlkYXRlLmNvXCIsXG4gICAgXCJtZXRhbWFza3ZlcmlmaWNhdGlvbi5pblwiLFxuICAgIFwiYmlsbGlvbmFpcmViaWdmb290Y2x1Yi5zYWxlXCIsXG4gICAgXCJ0b2tlbi1yZXN0b3JlLmlvXCIsXG4gICAgXCJkZWZpdmFsaWRhdG9ycy5vcmdcIixcbiAgICBcInJvYm90c2hlbHAub3JnXCIsXG4gICAgXCJkYXBwc21ldGFkYXRhLmNvbVwiLFxuICAgIFwibWV0YWNhcmQubWludHNpdGUucGFnZVwiLFxuICAgIFwidGhlaGFwZWJlYXN0cHJvamVjdC5jb21cIixcbiAgICBcImNyeXB0b2JhdHoueHl6XCIsXG4gICAgXCJ3YWxsZXRva2VudmFsaWRhdG9ycy5jb21cIixcbiAgICBcInNsb3RpZS1taW50LmFwcFwiLFxuICAgIFwiYXJrZ2lmdC5uZXRcIixcbiAgICBcIndhbGxzc2VjdXJldmFsLmNvbVwiLFxuICAgIFwibWludC1pbnZpc2libGVmcmllbmRzLmNsdWJcIixcbiAgICBcInRva2VuZXh0ZW5zaW9uLm1lXCIsXG4gICAgXCJuaWtlbWludGluZy5jb21cIixcbiAgICBcIm1ldGEtd29yZHMueHl6XCIsXG4gICAgXCJpbnZpc2libGUtZnJpZW5kcy5jb1wiLFxuICAgIFwibXlkZWNlbnRyYWxhbmQuc2hvcFwiLFxuICAgIFwiYmxvY2tjaGFpbnMtdG9vbC5jb21cIixcbiAgICBcImN1cnJ2ZS5pb1wiLFxuICAgIFwiZGF0YWJhc2VhY3RpdmF0aW9uLm9yZ1wiLFxuICAgIFwid2FsbGV0ZGFwcHNhcC5jb21cIixcbiAgICBcIm1pbnRzLWhhcGViZWFzdC5jb21cIixcbiAgICBcInJvY29maW5hbmNlLmNvbVwiLFxuICAgIFwiZGVmaW1vbmV5LmluZm9cIixcbiAgICBcIm1ldGFtYXNrbmZ0LmVtYWlsXCIsXG4gICAgXCJ3YWxsZXRjb25uZWN0LmVtYWlsXCIsXG4gICAgXCJsb29rc2hhcmUub3JnXCIsXG4gICAgXCJhcHBsZS5pY29tZXRhdmVyc2UuaW9cIixcbiAgICBcInBsYXlib3lyYWJiaXRhcnMtbWludC5hcnRcIixcbiAgICBcIm5pa2VuZnQuYXJ0XCIsXG4gICAgXCJwcmltZWFwZXBsYW5ldHMuYXBwXCIsXG4gICAgXCJwYW5jYWtlc3dhcGVzLmNvbXBhbnlcIixcbiAgICBcIjFnYXMucHJvXCIsXG4gICAgXCJtZXRhbWFzay12ZXJpZnkub3JnXCIsXG4gICAgXCJtZXRhbWFzay5ldGFtYXNrLnRvcFwiLFxuICAgIFwibWV0YW1hc2suc2VjdXJpdHktaW5mb3JtYXRpb24uY2NcIixcbiAgICBcInVuZGVhZHBhc3RlbGNsdWIub3JnXCIsXG4gICAgXCJ1bmlzd2FwLmZpbmFuY2lhbFwiLFxuICAgIFwieHl6LnRyYWRlXCIsXG4gICAgXCJzdWRvc3dhcC10cmFkZXIueHl6XCIsXG4gICAgXCJkYXBwd2FsbGV0LWNvbm5lY3Qub3JnXCIsXG4gICAgXCJub2RzLXN5bmN3YWxsZXQuY29tXCIsXG4gICAgXCJsaWxoZXJvZXNuZnRtaW50LmNvbVwiLFxuICAgIFwiYm9yZGJ1bm55LmlvXCIsXG4gICAgXCJ0aGV0YW5hcmVuYS5jYW1cIixcbiAgICBcImRleGludGVycGhhc2Uub25saW5lXCIsXG4gICAgXCJkZWZpLWVycm9yZml4LmNvbVwiLFxuICAgIFwiZGV4cHJvdG9jb2wub25saW5lXCIsXG4gICAgXCJtaW50LmZhbmN5YmVhcnNtZXRhdmVyc2UuY29tXCIsXG4gICAgXCJhcHAtYnNjcGFkLm9ubGluZVwiLFxuICAgIFwiYm9yZWJ1bm55LmlvXCIsXG4gICAgXCJ2YWxpZGF0ZXNmaXhlZHdhbGxldHMub3JnXCIsXG4gICAgXCJkYXBwc2Nvbm5lY3R3ZWIuY29tXCIsXG4gICAgXCJkb3dubG9hZC1tZXRhbWFzay5pbVwiLFxuICAgIFwiYWRpZGFzLWNvbGxhYi5sYW5kXCIsXG4gICAgXCJwcmltZWFwZW5mdC5jb21cIixcbiAgICBcIndpa2lyb2JvdHRva2VucmVjdGlmeS5vbmxpbmVcIixcbiAgICBcImRhcHBzeW5jLnh5elwiLFxuICAgIFwib25jaGFpbndhbGxldGRhcHMuY29tXCIsXG4gICAgXCJkZWNlbnRyYWxpemVkLWNvbm5lY3QuY29tXCIsXG4gICAgXCJyZW1vdGVjaGFpbmV4dGVuc2lvbi5jb21cIixcbiAgICBcImtub3dteXBhdGgubmV0XCIsXG4gICAgXCJzeW5jLWNvbGxhYi5jb21cIixcbiAgICBcIm5vZGUtdmFsaWRhdGlvbi5vbmxpbmVcIixcbiAgICBcImNyeXB0b2FwcHNhdXRoZW50aWNhdG9yLnN1cHBvcnRcIixcbiAgICBcInRva2VuYXV0aGVudGljYXRvci5vbmxpbmVcIixcbiAgICBcImRhcHBzbWFydHdhbGxldC5iaXpcIixcbiAgICBcIndlbC1uZXQub25saW5lXCIsXG4gICAgXCJidXNkc3dhcC5uZXRcIixcbiAgICBcImNlbGVyLWFpcmRyb3BzLmNvbVwiLFxuICAgIFwiY2hyb21lLWV4dGVuc2lvbi5tZXRhbXNhay5jb1wiLFxuICAgIFwid2FsbGV0Y29uLm1lXCIsXG4gICAgXCJtdWx0aWNvbm5lY3RkYXBwLmNvbVwiLFxuICAgIFwidGhlaW5kaWZmZXJlbnRkdWNrcy5jb21cIixcbiAgICBcInJlc3RvcmVtZXRhZGF0YS5jb21cIixcbiAgICBcIm15d2FsbGV0YXV0aGVudGljYXRvci53ZWVibHkuY29tXCIsXG4gICAgXCJzYW5kYm94Z2FtZS5hcHBcIixcbiAgICBcInNoaWJhc29jaWFpY2x1Yi5jb21cIixcbiAgICBcImJvbWJjcnlwdG8ubmV0XCIsXG4gICAgXCJmYWNlbGVzcy5tYWlzb25cIixcbiAgICBcIndoaXRlbGlzdC1pbnZpc2libGVmcmllbmRzLmNvbVwiLFxuICAgIFwiY2xvbmV4LnJmdGt0Lm5ldFwiLFxuICAgIFwiYW5ncnlwaXRidWxsY2x1Yi5pb1wiLFxuICAgIFwibWludC1hZGlkYXMuYXJ0XCIsXG4gICAgXCJjcnlwdG9ib21iLmNjXCIsXG4gICAgXCJhcHAuaW1wb3J0dmFsaWRhdG9yLmNvbVwiLFxuICAgIFwiem9tYmllYXBlY2x1Yi5hcnRcIixcbiAgICBcInNoaWJhc29jaWFsc2NsdWIubmV0XCIsXG4gICAgXCJwc3ljaGVkZWxpY3Nhbm9ueW1vdXMtbWludC5jb21cIixcbiAgICBcImJvcmVkYXBlLWdldC5jbHViXCIsXG4gICAgXCJodWItZ2FtZWZpLm5ldFwiLFxuICAgIFwibWFpbm5ldGFjdGl2YXRpb24uY29tXCIsXG4gICAgXCJkYXNoZmIyLm1ldGVtYXNrLnRvZGF5XCIsXG4gICAgXCJiaXRsaXZlcHJvdGVjdC5jb21cIixcbiAgICBcIm1pbnQtaGFwZWJlYXN0LmFydFwiLFxuICAgIFwicGlua3NhbGUuc2l0ZVwiLFxuICAgIFwicHJvamVjdC1ic2NwYWQuY29tXCIsXG4gICAgXCJmb3htYXNrLm5ldFwiLFxuICAgIFwid2FsbGV0aXNzdWVzZml4YWxsLm9yZ1wiLFxuICAgIFwibXVsdGlicmlkZ2UudG9vbHNcIixcbiAgICBcIndhbGxldHNyZXN0b3JlLnN0b3JlXCIsXG4gICAgXCJsb2dpbjEubWV0ZW1hc2sudG9kYXlcIixcbiAgICBcIm1ldGVtYXNrLnRvZGF5XCIsXG4gICAgXCJidXNpbmVzc2FwZXNjbHViLmNvbVwiLFxuICAgIFwibG9yZHNvY2lldHkuY29cIixcbiAgICBcImFkaWRhcy1taW50LmNvbVwiLFxuICAgIFwieHJlcy5vcmdcIixcbiAgICBcInhyZXMuYXBwXCIsXG4gICAgXCJwbGdwdW5rLmNvbVwiLFxuICAgIFwibGVseC5pb1wiLFxuICAgIFwibGVseC5vcmdcIixcbiAgICBcImtrOC5pb1wiLFxuICAgIFwia2s4LmluZm9cIixcbiAgICBcIm1ldGFtYXNrLm1ldG9tYXNrcy5jeW91XCIsXG4gICAgXCJnZXQtYmFwZS5jbHViXCIsXG4gICAgXCJhZGlkYXNtaW50aW5nLmNvbVwiLFxuICAgIFwid2FsbGV0LmFwaXNlcnZlcm5ldC5vcmdcIixcbiAgICBcIm94eWFvcmlnaW4uYXJ0XCIsXG4gICAgXCJjcnlwdG9iYXR6LmNvXCIsXG4gICAgXCJpbnZzaWJsZWZyaWVuZHMuaW9cIixcbiAgICBcInNhbXVyYWlzYWdhY2x1Yi5jb21cIixcbiAgICBcIm9wZW5zYWUtY29sbGVjdGlvbi5jY1wiLFxuICAgIFwib2duLWFpcmRyb3BzLmNvbVwiLFxuICAgIFwiYXhpZS1ib3gub25lXCIsXG4gICAgXCJjcmF6eWJhYmllc25mdC5jb21cIixcbiAgICBcInRoZW1hc2tkYW8ub3JnXCIsXG4gICAgXCJhcGVza2lkc2NsdWJzLmNvbVwiLFxuICAgIFwiY2h1bWJpdmFsbGxleS5jb21cIixcbiAgICBcImNvbm5lY3RhbGx3YWxsZXQubmV0XCIsXG4gICAgXCJ3YWxsZXRhdXRoZW50aWNpdHkub3JnXCIsXG4gICAgXCJoYXBlYmVhc3RnYW5nLm5ldFwiLFxuICAgIFwiYm9yZWRiaWdmb290cy5jb1wiLFxuICAgIFwiZGFvbWFrZXIuY29tLm14XCIsXG4gICAgXCJzdXBlcmxhdGl2ZXNhcGVzLmNvbVwiLFxuICAgIFwiZ2FseXZlcnNlcy5jb21cIixcbiAgICBcInhuLS1ydGJsb2Nrcy03eWEubmV0XCIsXG4gICAgXCJ4bi0tcnRibG9ja3MtN3lhLmlvXCIsXG4gICAgXCJ4bi0tcnRibG9ja3MtN3lhLmNvbVwiLFxuICAgIFwidmFsaWRhdGV3YWxsZXRkYXBwLmNvbVwiLFxuICAgIFwibWV0YXZwYWRzYWxlcy5vbmxpbmVcIixcbiAgICBcImFwaS1jb2xsYWJzLmxhbmRcIixcbiAgICBcInJhZGlvcmFjYWEuY29tXCIsXG4gICAgXCJtZXRhbWFzay13YWxsZXRzLXByb3RlY3Rpb24ud2ViLmFwcFwiLFxuICAgIFwibXlkYXBwc3dhbGxldGNvbm5lY3QuY29tXCIsXG4gICAgXCJtZXRhLm1hc2t3ZWIuYXBwXCIsXG4gICAgXCJjb3JyZWN0aW9uc2Vic2l0ZS5jb21cIixcbiAgICBcIm9seW1wdXNkYW8uaW9cIixcbiAgICBcInRyaWRlbnRtYXJrZXQuaW9cIixcbiAgICBcImFwZXNpbnNwYWNlLmFwcFwiLFxuICAgIFwiYmxvY2tudXguY29tXCIsXG4gICAgXCJwb3duZnQucHJvXCIsXG4gICAgXCJzb2xpY2UubGl2ZVwiLFxuICAgIFwibWV0YS1yZWNvdmVyeS1waHJhc2UuY29tXCIsXG4gICAgXCJibG9ja2NoYWluLXRvb2wub3JnXCIsXG4gICAgXCJjb25uZWN0dG9kYXBwcy5nYVwiLFxuICAgIFwic3VwcG9ydC1tZXRhbWFzay5uZXRsaWZ5LmFwcFwiLFxuICAgIFwiYmV0YS1hbHRjaGFpbnMub3JnXCIsXG4gICAgXCJkYXBwcy5yZXdhbGxldGF1dGhvcml6YXRpb24uY29tXCIsXG4gICAgXCJwaW5rZXNhbGUuY29tXCIsXG4gICAgXCJkZWZpcHJvdG9jb2wtb25saW5lLmRpZ2l0YWxcIixcbiAgICBcIm1ldGEtc2VydmVycy1vbmxpbmUuY29tXCIsXG4gICAgXCJsaXZlZml4cmVzdG9yZS5jb21cIixcbiAgICBcInNhbmRib3hlZ2Ftcy5jb21cIixcbiAgICBcInNhdG9zaGlxdWVzdC5pblwiLFxuICAgIFwicmljaGJ1bGxzY2x1YnMuY29tXCIsXG4gICAgXCJiaXN3YXAtZXhjYW5nLmNvbVwiLFxuICAgIFwib25saW5lbWV0YXRva2Vucy5jb21cIixcbiAgICBcInBvd25mdC5uZXRcIixcbiAgICBcInBvd25mdC5pbmZvXCIsXG4gICAgXCJwYW5jYWtlLWNyeXB0by5pY3VcIixcbiAgICBcInprc3luYy5zYWxlXCIsXG4gICAgXCJmcmVlLWV0aC5vcmdcIixcbiAgICBcImV0aHNwZWNpYWwyMS5jb21cIixcbiAgICBcImZpeHdhbGxldHRva2VuLmNvbVwiLFxuICAgIFwibWV0YS1naXZld2F5LmlvXCIsXG4gICAgXCJ3YWxsZXRhcGlzeW5jLmNvbVwiLFxuICAgIFwiZmYxOC5pb1wiLFxuICAgIFwiZmYxOC5pbmZvXCIsXG4gICAgXCJob3Bwcm90b2NvbC5zYWxlXCIsXG4gICAgXCJ4bi0tYmxjaGhjaS1ld2E5bzU1YS5jb21cIixcbiAgICBcImltLXRva2Vucy5zdG9yZVwiLFxuICAgIFwibW1hcC5tYXRlbWFza3MuZG93bmxvYWRcIixcbiAgICBcInhuLS1ibGNoY2hpbi1sZ2luLXVkYjkwYWphLmNvbVwiLFxuICAgIFwiYmlnZGF0YS1zdGFydGluZ29uLmNvbVwiLFxuICAgIFwiaGFpbGlhbnBhcnRzLmNuXCIsXG4gICAgXCJ4bi0tbXRhbWFzay1kOGEuY29tXCIsXG4gICAgXCJhcHAubmJhdG9rZW5zYWxlLmNvbVwiLFxuICAgIFwibWV0YW1hc2stdmVyaWZpY2F0aW9uLmluXCIsXG4gICAgXCJ5ZXN3YXAuaW5mb1wiLFxuICAgIFwidW5sb2NraW5nbG9jYXRpb24uYnV6elwiLFxuICAgIFwid2FsbGV0dGNvbm5lY3QuY29cIixcbiAgICBcImlvLWxlZGdlLmNvbVwiLFxuICAgIFwiYW1hem9uLnRva2VucHJlLnNhbGVcIixcbiAgICBcInRva2VucHJlLnNhbGVcIixcbiAgICBcInRoZS1ndWFyZGlhbi5uZXdzXCIsXG4gICAgXCJhbHBhY2FmbmluYW5jZS5jb21cIixcbiAgICBcImlkYXBwcy10b2tlbnMuY29tXCIsXG4gICAgXCJjcnlwdG8uZS1hY2Nlc3MuaG9zdFwiLFxuICAgIFwibWFpbm5ldC12YWxpZGF0b3Iub3JnXCIsXG4gICAgXCJ1bmlzd29wLXVuaS5jb21cIixcbiAgICBcInZhbGlkYXRlLWNvbGxhYi5sYW5kXCIsXG4gICAgXCJkYXBwc2F1dGhzbWFydGNvbm5lY3QuY29tXCIsXG4gICAgXCJyb2xsLmNvbGxhYi52b3RlXCIsXG4gICAgXCJjb2xsYWIudm90ZVwiLFxuICAgIFwiY29sbGFib3JhdGlpb24ubmV0XCIsXG4gICAgXCJmbG93ZGFvLmlvXCIsXG4gICAgXCJmbG93ZGFvLnByb1wiLFxuICAgIFwiYXBwd2FsbGV0c3luYy5uZXRcIixcbiAgICBcInRydXN0LWhlbHB3YWxsZXQubGl2ZVwiLFxuICAgIFwiY29sbGFib3JhdGlpb24uY29tXCIsXG4gICAgXCJjb2xsYWJvcmF0aWlvbi5hcHBcIixcbiAgICBcIm1pbnQtaGFwZWJlYXN0LmNjXCIsXG4gICAgXCJoM3guZXhjaGFuZ2VcIixcbiAgICBcImFsaGVtaXguY29tXCIsXG4gICAgXCJzcG9va3lzdnZhcC5maW5hbmNlXCIsXG4gICAgXCJlbnNkb21haW5zLmFwcFwiLFxuICAgIFwic3luYy13YWxsZXRzLm9yZ1wiLFxuICAgIFwia2xsbWFkYW8uZmluYW5jZVwiLFxuICAgIFwiYmxvY2tjaGFpbi1ub2Rlcy5uZXRcIixcbiAgICBcInN3YXA3Lm9yZ1wiLFxuICAgIFwibGl2ZS1kcm9wLm5ldFwiLFxuICAgIFwiYmVlZnktZmluYW5jZS5vcmdcIixcbiAgICBcImJlbmVmeS5maW5hbmNlXCIsXG4gICAgXCJhbGNoZW1peC5haVwiLFxuICAgIFwic3dhcDcuaW9cIixcbiAgICBcImRhcHBzYnJvd3Nlci5vbmxpbmVcIixcbiAgICBcInBhbmNha2Vzd2FwLWRhcHBzLmNvbVwiLFxuICAgIFwiY29sbGFiLmxhbmQuaW8taW52ZXN0Lm9yZ1wiLFxuICAgIFwiYXBwLWJlZWZ5LmNvbVwiLFxuICAgIFwiYmVlZnlqLmZpbmFuY2VcIixcbiAgICBcIndhbGxzdHJlZXRidWxscy50b1wiLFxuICAgIFwiZGl2aW5lYW5hcmNoeS5pbmtcIixcbiAgICBcImFwcC1iZWVmeXIuZmluYW5jZVwiLFxuICAgIFwiYWxjaGVtbHhzLmZpbmFuY2VcIixcbiAgICBcImFsY2hlcm5peC5maW5hbmNlXCIsXG4gICAgXCJ4bi0tbWV0bWFzay1zbjRjLmNvbVwiLFxuICAgIFwibWV0YS5laXAtMTU1OS5zaXRlXCIsXG4gICAgXCJrZXk3Lm9yZ1wiLFxuICAgIFwiZGFwcGNvbm5uZWN0Lm9ubGluZVwiLFxuICAgIFwiOXZ3d3YtbWV0YW1zLnRvcFwiLFxuICAgIFwibWV0c2FtYXNrLWhvbWUuY29tXCIsXG4gICAgXCJiZWVmeXQuZmluYW5jZVwiLFxuICAgIFwid3d3bWV0bWFza3ZlcmlmaWNhdGlvbi5tZVwiLFxuICAgIFwiYmVlZnlkLmZpbmFuY2VcIixcbiAgICBcImJlZWZ5cC5maW5hbmNlXCIsXG4gICAgXCJiZWVuZnkuZmluYW5jZVwiLFxuICAgIFwiZGF5c3VzaGlzd2FwLmNvbVwiLFxuICAgIFwiYmVlZnloLmZpbmFuY2VcIixcbiAgICBcInhuLS1iZWZ5LWxwYS5maW5hbmNlXCIsXG4gICAgXCJiZWVmeXIuZmluYW5jZVwiLFxuICAgIFwibWV0YW1hc2std2FsbGV0cy1yZXN0b3JlLm5ldGxpZnkuYXBwXCIsXG4gICAgXCJkeGRleC5jb1wiLFxuICAgIFwic3luYy1jb25ud2FsbGV0LmNvXCIsXG4gICAgXCJhbnlzd2FwLmlvXCIsXG4gICAgXCJmaXhteXdhbGxldHMuY29tXCIsXG4gICAgXCJ3d3dhcHBzLW1ldGFtLnRvcFwiLFxuICAgIFwic3Vkb3N3YXAuYXBwXCIsXG4gICAgXCJzYXlsb3ItdmlzaW9uLmNvbVwiLFxuICAgIFwiOHZ3dy1tZXRhbWFzLnRvcFwiLFxuICAgIFwiYmVlZnlhcHAuZmluYW5jZVwiLFxuICAgIFwiYmVlZnlmLmZpbmFuY2VcIixcbiAgICBcImV0aGVyZXVtLWFubm91bmNlLm5ldFwiLFxuICAgIFwiYmVlZnliLmZpbmFuY2VcIixcbiAgICBcInVuaXZzd2FwLm9yZ1wiLFxuICAgIFwicnN3YXAuY2x1YlwiLFxuICAgIFwib3B0aW11c20uaW9cIixcbiAgICBcImxpbmtwLmlvXCIsXG4gICAgXCJsaW5rbXAub3JnXCIsXG4gICAgXCJ0dTcub3JnXCIsXG4gICAgXCJybmlsb3JuYWNrLmNvbVwiLFxuICAgIFwidHU3LmlvXCIsXG4gICAgXCJib3JlZGFwZXlhY2h0Y2x1Yi5hcHBcIixcbiAgICBcIm1vb25wb3RyZXdhcmRzLmNvbVwiLFxuICAgIFwiYmVlZnktZmluYW5jZS5jb21cIixcbiAgICBcImFwcHMtYmVlZnkuZmluYW5jZVwiLFxuICAgIFwiYXBwLWJlZWZ5LmZpbmFuY2VcIixcbiAgICBcImFrc3dhcC5pbmZvXCIsXG4gICAgXCJjb2xsYWJzLmxhbmRcIixcbiAgICBcImRpc2NvcmQtY29sbGFiLmxhbmRcIixcbiAgICBcImV4c29kZHVzLm9ubGluZVwiLFxuICAgIFwib3BlbnNlYS5mb1wiLFxuICAgIFwiY3BlbnNlbGwuY29cIixcbiAgICBcInJzd2FwLmxpbmtcIixcbiAgICBcInJzd2FwLm5ldFwiLFxuICAgIFwibWVkaXVuLmNvXCIsXG4gICAgXCJtZXRhbWFza3JlY292ZXIuY29tXCIsXG4gICAgXCJwb2x5YmVzdC5pb1wiLFxuICAgIFwicG9seWJlc3Qub3JnXCIsXG4gICAgXCJhYXhleGNoYW5nZS5vcmdcIixcbiAgICBcImR4ZGV4LmlvXCIsXG4gICAgXCJkeGRleC5vcmdcIixcbiAgICBcInhjaDUubmV0XCIsXG4gICAgXCJ4Y2g1Lm9yZ1wiLFxuICAgIFwiZmluYW5jZS5wYXJ0c1wiLFxuICAgIFwibmVzdGZpbi5uZXRcIixcbiAgICBcImF1dGhlbnRpY2F0ZS1kYXBwcy5jb21cIixcbiAgICBcIm9wZW5pc2VhLmNvbVwiLFxuICAgIFwicGFsbXN5bmMuaW9cIixcbiAgICBcIm1ldGEtbWFzay13YWxsZXQub25saW5lXCIsXG4gICAgXCJ3YWxsZXRzc3luY2xpdmUuY29tXCIsXG4gICAgXCJtZXRhbWFzay50b3BcIixcbiAgICBcImFscGFjYWZpbi5jb21cIixcbiAgICBcInN1c2hpLXYzLmNvbVwiLFxuICAgIFwiYWF2ZS12My5jb21cIixcbiAgICBcImFiY2hhbmdlLm9yZ1wiLFxuICAgIFwid2FsbGV0c3hzeW5jcy5jb21cIixcbiAgICBcImV4b2R1cy11cGRhdGUub3JnXCIsXG4gICAgXCJ6ZXBlLnZpcFwiLFxuICAgIFwid2FsbGV0Y29ubmVjdHJlc3RvcmUuaW9cIixcbiAgICBcImZmOS5pbmZvXCIsXG4gICAgXCJzaGliYWRyb3AuaW9cIixcbiAgICBcImFhZXhjaGFuZ2UuaW9cIixcbiAgICBcImZsdXhjaGFpbi5uZXRcIixcbiAgICBcImFrc3dhcC5uZXRcIixcbiAgICBcInJlc3RvcmUtd2FsbGV0Lm9ubGluZVwiLFxuICAgIFwiZGFwcHMtcGx1Zy5jb21cIixcbiAgICBcImFrc3dhcC5pb1wiLFxuICAgIFwiYWtzd2FwLm9yZ1wiLFxuICAgIFwiYmVzdGFpci5pb1wiLFxuICAgIFwiemVwZS5pb1wiLFxuICAgIFwiYWFiZWsubmV0XCIsXG4gICAgXCJhYmZpbi5vcmdcIixcbiAgICBcImJuYncuaW9cIixcbiAgICBcIm1ldGFtYXNrLmlvLXIucnVcIixcbiAgICBcIm1hdXRvbXNrLnJ1LmNvbVwiLFxuICAgIFwiZGFwcHN2YWxpZGF0aW9uLm9yZ1wiLFxuICAgIFwicGFuY2FrZXN3YXAuZmluYW5jZS5kZWxpdmVyeVwiLFxuICAgIFwiaW1wb3J0LW1lc3RhbWFzay5jb21cIixcbiAgICBcInRyaWRva25pZ2VyaWEuY29tLm5nXCIsXG4gICAgXCJtZXRhc21hc2tzLmlvXCIsXG4gICAgXCJzeW5jd2FsbGV0bGl2ZXRva2VucmVzdG9yZS5vcmdcIixcbiAgICBcImRhcHBzY29ubmVjdHMubmV0XCIsXG4gICAgXCJheGllbGluZmluaXR5LmNvbVwiLFxuICAgIFwiYXhpZWluZmluaXR5cGFnZS5vbmVcIixcbiAgICBcInNreW1hdmlzd2FsbGV0dXBkYXRlLmNvbVwiLFxuICAgIFwid2FsbGV0LWFzc2V0dXBkYXRlLmNvbVwiLFxuICAgIFwiYXhpZW5mbGluaXR5LmNvbVwiLFxuICAgIFwiZGFwcC13YWxsZXRzY29ubmVjdC5jb21cIixcbiAgICBcIm1ldGFtYXNrLmlvLXVwZGF0ZWQuYXBwXCIsXG4gICAgXCJ0LW9wZW5zZWEuaW9cIixcbiAgICBcImRhcHBjb25uZWN0LmxpdmVcIixcbiAgICBcIm1lc3RhbWFzay1pby5jb21cIixcbiAgICBcIncxMXN0b3AuY29tXCIsXG4gICAgXCJwYW5jYWtldHJhZGUuaW5mb1wiLFxuICAgIFwid2FsbGV0c2NoYWluLm9yZ1wiLFxuICAgIFwid2FsbGV0ZXRoZXIubmV0XCIsXG4gICAgXCJ3YWxsZXRzZGFwcHMuaW9cIixcbiAgICBcImJpdG1lc29rLmNvbVwiLFxuICAgIFwibWV0YW1hc2stdmVyaWZ5LmNvbVwiLFxuICAgIFwibWV0YW1hc2stY29tcGxpYW5jZS5jb21cIixcbiAgICBcIm1ldGFtYXNrLWRlc2t0b3AuY29tXCIsXG4gICAgXCJ0cmFpbmluZy1tYXNrLmNvbVwiLFxuICAgIFwib3BlbnNlYWEuY29tXCIsXG4gICAgXCJvcGVuc2VlYS5jb21cIixcbiAgICBcImJhZGdlcmRhby5pb1wiLFxuICAgIFwiYmFkZ2VyZGFvLmFwcFwiLFxuICAgIFwidmVyYW5ldC5pbmZvXCIsXG4gICAgXCJ0aGV2ZXJhLmlvXCIsXG4gICAgXCJ2ZXJhLmlvXCIsXG4gICAgXCJ0aGVldmVyLmlvXCIsXG4gICAgXCJldmVyZmluYW5jZS5pb1wiLFxuICAgIFwidmVsYXBhZC5pb1wiLFxuICAgIFwiZmx1eGJsb2NrY2hhaW4uY29tXCIsXG4gICAgXCJnb2ZsdXguaW9cIixcbiAgICBcImZlZ3N3YXAubmV0XCIsXG4gICAgXCJzYWZlbW9vbi5pc1wiLFxuICAgIFwiYmFieWRvZ2VjbGFpbS5jb21cIixcbiAgICBcInZlc3BlcmJpdC5jb21cIixcbiAgICBcIndhbGxldGNvbm5lY3R2MS5vcmdcIixcbiAgICBcImVhc3l3ZWJ3YWxsZXQuY29tXCIsXG4gICAgXCJiaXRsYW1zLmNvbVwiLFxuICAgIFwiY3J5cHRvd290LmNvbVwiLFxuICAgIFwidHJ1c3QtY29tcGxpYW5jZS5jb21cIixcbiAgICBcImxhcnZhbGFiLnRvXCIsXG4gICAgXCJ3YWxsZXRob21lY29ubmVjdC5saXZlXCIsXG4gICAgXCJtYXRpYy5wbHVzXCIsXG4gICAgXCJzdXNoaS1zd2FwLm5ldFwiLFxuICAgIFwic3VzaGljb20uc2l0ZVwiLFxuICAgIFwiYXBwLnN1c2hpY29tLnNpdGVcIixcbiAgICBcIm15ZXdldGxoZXJ2d2FsbGV0LmNvbVwiLFxuICAgIFwic3RhYmxlNy5uZXRcIixcbiAgICBcInhuLS1icmF2LXl2YS5jb21cIixcbiAgICBcInBhbmNha2Vzd2FwLmJldGF2Mi5jb21cIixcbiAgICBcImJldGF2Mi5jb21cIixcbiAgICBcImR4c2FpZS5hcHBcIixcbiAgICBcImR4c2F0ZS5hcHBcIixcbiAgICBcImR4eHNhdGUuYXBwXCIsXG4gICAgXCJkeHhzYWxlLmFwcFwiLFxuICAgIFwiZHhzYWxlLmFwcC10b2tlbi5zaXRlXCIsXG4gICAgXCJkeHNhbGUubG9sXCIsXG4gICAgXCJkeHNhbHYuYXBwXCIsXG4gICAgXCJkeHNhbGVhLmFwcFwiLFxuICAgIFwiZHhzbGFsZS5hcHBcIixcbiAgICBcImR4c2xlYS5hcHBcIixcbiAgICBcImR4YWxsZS5hcHBcIixcbiAgICBcImR4c2FsZS5jby5pblwiLFxuICAgIFwiZHhzYWxlLnJ1blwiLFxuICAgIFwiZHhzYWxlLmlvXCIsXG4gICAgXCJkeHhhbGUuYXBwXCIsXG4gICAgXCJkeHNhbGUuY2FzaFwiLFxuICAgIFwiZHhzYWxleC5hcHBcIixcbiAgICBcImR4c2FsZS5iaWRcIixcbiAgICBcImR4c2FsZS5oZWxwXCIsXG4gICAgXCJkeHNhbGVhcHAubGl2ZVwiLFxuICAgIFwiZHhzYWxlaS5hcHBcIixcbiAgICBcImR4c2FsZS5kZXZcIixcbiAgICBcImR4c2FsbC5hcHBcIixcbiAgICBcImR4c2FsZWwuYXBwXCIsXG4gICAgXCJkeHNhbGUuZG8uYW1cIixcbiAgICBcImR4c2FsZS5hY1wiLFxuICAgIFwiZGV4c2FsZS5vbmxcIixcbiAgICBcImR4ZXNsYS5hcHBcIixcbiAgICBcImR4c2FsZS53c1wiLFxuICAgIFwiZHhyc2FsZS5hcHBcIixcbiAgICBcImR4c2FlbC5hcHBcIixcbiAgICBcImR4c2FsZS5kaXJlY3RcIixcbiAgICBcImR4c2FsZS5vbmxcIixcbiAgICBcImR4c2FsZS5mdW5cIixcbiAgICBcImR4c2FsZS5mdW5kXCIsXG4gICAgXCJkeHNhbGUubHRkXCIsXG4gICAgXCJkeHNhbGUuYXRcIixcbiAgICBcImR4c2lhbGUuYXBwXCIsXG4gICAgXCJkeHNhbGUuaWN1XCIsXG4gICAgXCJkeHNhbGUuem9uZVwiLFxuICAgIFwiZHhzYWxlLmJpelwiLFxuICAgIFwiZHhzYWxlLmlkXCIsXG4gICAgXCJkeHNhbGUubmV0XCIsXG4gICAgXCJkeHNhbGUuYWlcIixcbiAgICBcImR4c2FsZS5zdVwiLFxuICAgIFwiZHhzYWxlLmJhclwiLFxuICAgIFwiZHhzYWxlLmNvbS5hdVwiLFxuICAgIFwiZHhzYWxlLmxpdmVcIixcbiAgICBcImR4c2FsZS52aXBcIixcbiAgICBcImR4c2FsZS5jb21cIixcbiAgICBcImR4c2FsZS5jYW1cIixcbiAgICBcImR4c2FsZS5jY1wiLFxuICAgIFwiZHhzYWxlcy5jY1wiLFxuICAgIFwiZHhzYWxlLmRlXCIsXG4gICAgXCJkeHNhbGUuZG90XCIsXG4gICAgXCJkeHNhbGUub3JnXCIsXG4gICAgXCJkeHNhbGUuY2FcIixcbiAgICBcInJheWRpdW0udXNcIixcbiAgICBcIm1ldGFtYXNrbWFpbHMuY29tXCIsXG4gICAgXCJwb25jYWtlc3dhcC5jZW50ZXJcIixcbiAgICBcImNvbnRhY3RtZXRhbWFzay5jb21cIixcbiAgICBcIndhbGxldHZhbGlkYXRpb24uaW5mb1wiLFxuICAgIFwibXVsdGlhcHAtY29ubmVjdC5vcmdcIixcbiAgICBcIm11bHRpY29uY2VwdC5uZXRcIixcbiAgICBcInBhbmNha2Vzd29wLmZpbmFuY2VcIixcbiAgICBcInd3dy1vcGVhbnNlYS5pb1wiLFxuICAgIFwibWV0YW1hc2tzd2FwLmlvXCIsXG4gICAgXCJtZXRhLXRva2VuLnNpdGVcIixcbiAgICBcIm1ldGFtYXNrZHJvcC5jbHViXCIsXG4gICAgXCJtYW50ZW1hc2suY29tXCIsXG4gICAgXCJtZXRhdG9rZW4uc2l0ZVwiLFxuICAgIFwieG4tLW1ldGFtc2stdDRhLmNvbVwiLFxuICAgIFwibWV0YS1tYXNrLmNvXCIsXG4gICAgXCJmcmVlbWF0aWMuZ2lmdHNcIixcbiAgICBcIm15ZXdlcnRoZXZha2xldGguY29tXCIsXG4gICAgXCJld2FsbGV0c3VwcG9ydC5jb21cIixcbiAgICBcImN1cnZlLnd0ZlwiLFxuICAgIFwidHJ1c3R3YWxsZXRzLm1lXCIsXG4gICAgXCJsaXF1aWRpZnR5LmJzY3BhZC5jb20uZGVcIixcbiAgICBcImJzY3BhZC5jb20uZGVcIixcbiAgICBcImtlZXAtbmV0d29yay5jb21cIixcbiAgICBcIndhbGxldC1zeW5jLmlvXCIsXG4gICAgXCJtZXRhbWFzay1zeW5jLmNvbVwiLFxuICAgIFwibWV0YW1hc2t2Mi5pb1wiLFxuICAgIFwic2VjdXJld2FsbGV0bGluay5vcmdcIixcbiAgICBcIm1ldGFtYXNrLW9ubGluZS5vcmdcIixcbiAgICBcImRvd25sb2FkLW1ldGFtYXNrLmNvbVwiLFxuICAgIFwibWV0ZW1hc2stbm9kZS5jb21cIixcbiAgICBcIjJwYW5jYWtlc3dhcC5jb21cIixcbiAgICBcImRhcHBzYXR0ZXN0YXRpb24uYm9uZFwiLFxuICAgIFwiZGFwcHNyYXRpZmljYXRpb24uYm9uZFwiLFxuICAgIFwiZmFybS1yZXdhcmRzLmV4Y2hhbmdlLXBhbmNha2Vzd2FwLmV4Y2hhbmdlXCIsXG4gICAgXCJ3YWxsZXRsaXZlYXV0aG9yaXphdGlvbi5jb21cIixcbiAgICBcIm1ldGFjaG1vbmsuY29tXCIsXG4gICAgXCIxaW5jaGV0LmNvbVwiLFxuICAgIFwib25saW5lLW1ldGFtYXNrLmNvbVwiLFxuICAgIFwicmVjb25uZWN0d2FsbGV0LmlvXCIsXG4gICAgXCJwYW5jYWtlc3dhcC5jaGVhcFwiLFxuICAgIFwicG9sa2FzdGFydGVyLmV1XCIsXG4gICAgXCJtZXRhbWFzay1jb25uZWN0aW9uLmlvXCIsXG4gICAgXCJidXlzcHguY29tXCIsXG4gICAgXCJvZmZpY2lhbHNweC5jb21cIixcbiAgICBcImFsY2hlcm5peC5jb21cIixcbiAgICBcIndhbGxldGNvbm5lY3RzdXBwb3J0cy5jb21cIixcbiAgICBcImlvLXJlc3RvcmUubmV0XCIsXG4gICAgXCJtZXRhbWFzay5pby1yZXN0b3JlLm5ldFwiLFxuICAgIFwibWF0aWN3YWxsZXRzLm5ldFwiLFxuICAgIFwibGFydmFsYWIuaW9cIixcbiAgICBcImxhcnZhbGFicy50b1wiLFxuICAgIFwibGFydmFsYWJzLm1lXCIsXG4gICAgXCJsYXJ2YWxhYnMuYWlcIixcbiAgICBcImxhcnZhbGFicy5jbVwiLFxuICAgIFwibGFydmFsYWJzLmxpbWl0ZWRcIixcbiAgICBcImxhcnZhbGFic3dhbGxldC5jb21cIixcbiAgICBcImxhcnZhc2xhYnMuY29tXCIsXG4gICAgXCJtZXRhbWFzay1pby5vbmxpbmVcIixcbiAgICBcIm11bHRpY29pbi13YWxsZXQub3JnXCIsXG4gICAgXCJ2YWxpZGF0ZS5tdWx0aWNvaW4td2FsbGV0Lm9yZ1wiLFxuICAgIFwicG9sa2FzdGFydGVyLXNhbGUuY29tXCIsXG4gICAgXCJkYXBwd2FsbGV0Y29ubmVjdHMuY29tXCIsXG4gICAgXCJleHRlbnNpb24udGhlYmFsaWNoaWxpLmNvbVwiLFxuICAgIFwidGhlYmFsaWNoaWxpLmNvbVwiLFxuICAgIFwidHJlem9yLmlvLWNoZWNrcmVzdG9yZS5jb21cIixcbiAgICBcIm5mdC1vcGVuc2VhLmNvbVwiLFxuICAgIFwiY29ubmVjdHMtd2FsbGV0LmxpdmVcIixcbiAgICBcInhuLS1tdGFtc2stc3RhNGQuY29tXCIsXG4gICAgXCJ2Mi11bmlzd2FwLmlvXCIsXG4gICAgXCJ3YWxsZXRjbG91ZC5vcmdcIixcbiAgICBcImxpdmV3YWxsZXQub3JnXCIsXG4gICAgXCJtZXRhbWFza2NjLmxpdmVcIixcbiAgICBcIndhbGxldHN5bmMudGVjaFwiLFxuICAgIFwibGFydmFsYWIubmV0XCIsXG4gICAgXCJua2JpaGZiZW9nYWVhb2VobGVmbmtvZGJlZmdwZ2ttbi5jY1wiLFxuICAgIFwiZmlybXdhcmUtbWV0YW1hc2sucmVwYWlyXCIsXG4gICAgXCJ3YWxldGNvbm5lY3QudXNcIixcbiAgICBcIm1lZmFtYWhzLmlvXCIsXG4gICAgXCJhcHAuY3JlYW1maW5hbmNlLmNvXCIsXG4gICAgXCJjcmVhbWZpbmFuY2UuY29cIixcbiAgICBcImFwcC51bmlzd2FwLm9yZy1wcm90b2NvbC1haXJkcm9wLmNvbVwiLFxuICAgIFwib3JnLXByb3RvY29sLWFpcmRyb3AuY29tXCIsXG4gICAgXCJzcGkuY2x1YlwiLFxuICAgIFwid2F4dG9rZW5yZXdhcmRzLmNvbVwiLFxuICAgIFwiYXBwLXVuaXN3YXAtZXhjaGFuZ2Uub3JnXCIsXG4gICAgXCJhaXJkcm9wLXVuaXN3YXAtYXBwLm9yZ1wiLFxuICAgIFwicG9sa2FzdGFydGVyLmxpbmtcIixcbiAgICBcIm1ldGFtYXNrLXJlc3RvcmVzLm5ldFwiLFxuICAgIFwieG4tLW1ldGFtc2stZW40Yy5pb1wiLFxuICAgIFwibWV0YW1hc2t3YWxsZXQubGl2ZVwiLFxuICAgIFwibWV0YW1hc2tvbmxpbmUuY29tXCIsXG4gICAgXCJtZXRhbWFzay16ZW5kZXNrLmNvbVwiLFxuICAgIFwibWV0YW1hc2tjb25uZWN0cy5vbmxpbmVcIixcbiAgICBcIndhbGxldG1lcmdlci5uZXRcIixcbiAgICBcInhuLS1tdGFtYXNrLWJ5YS5jb21cIixcbiAgICBcImdpdmVhd2F5LWFwcC5pbmZvXCIsXG4gICAgXCJtZXRhbWFzay5naXZlYXdheS1hcHAuaW5mb1wiLFxuICAgIFwid2FsbGV0cy1jb25uZWN0cy5zdXBwb3J0XCIsXG4gICAgXCJ4bi0tbWV0YW1zay0zMGMuY29tXCIsXG4gICAgXCJleHRlbnNpb25zLW1ldGEuaW9cIixcbiAgICBcImxveWFsdHlzd2FwLmNvbVwiLFxuICAgIFwibG9hbHR5c3dhcC5jb21cIixcbiAgICBcIm1ldGFtYXNrd2FsbGV0cy5pb1wiLFxuICAgIFwibWV0YW1hc2t3YWxsZXRzLm9ubGluZVwiLFxuICAgIFwibnNsZ2l2ZXMuY29tXCIsXG4gICAgXCJzbmxkYXkudG9wXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuY2xpY2tcIixcbiAgICBcInRob3J0cmFkaW5nLmNvbVwiLFxuICAgIFwic25sbXVzay5jb21cIixcbiAgICBcInVuaWhvbGRlcnMuY29tXCIsXG4gICAgXCJ3YWxsZXRuZXR3b3Jrcy5vcmdcIixcbiAgICBcImNvbm5lY3Rpb253YWxsZXQubGl2ZVwiLFxuICAgIFwid2FsbGV0Y29ubmVjdC50b1wiLFxuICAgIFwib3BlbnNpYW8uaW9cIixcbiAgICBcImxlZGdlcmxpdmUuY29tLmRlXCIsXG4gICAgXCJiaXRnb29kZXkuY29tXCIsXG4gICAgXCJlbG9uZHJvcC5wcm9cIixcbiAgICBcInBhbmNha2Vzd2FwLWFpcmRyb3BjYW1wYWlnbi5maW5hbmNlXCIsXG4gICAgXCJwYW5jYWtlc3dhcC1maW5hbmNlLXRva2Vucy1mYXJtLnNpdGVcIixcbiAgICBcInBhbmNha2Vzd2FwLXYxLW1pcnJvci51bnJla3QubmV0XCIsXG4gICAgXCJwYW5jYWtlc3dhcGNvbm5lY3QuY29tXCIsXG4gICAgXCJwYW5jYWtlc3dhcC5ndXJ1XCIsXG4gICAgXCJwYW5jYWtlc3dhcC1maW5hbmNlLXN3YXAtdjIuc2l0ZVwiLFxuICAgIFwiYWN0aXZhdGV3YWxsZXQubGl2ZVwiLFxuICAgIFwicGFuY2FrZXN3YXBmaW5hbmNlLmNvXCIsXG4gICAgXCJ1bmlzd2FwLnJldmlld3NcIixcbiAgICBcInYzdW5pc3dhcC5jb21cIixcbiAgICBcInVuaXN3YXAtbm9kZS5vcmdcIixcbiAgICBcInVuaXN3YXAubXlcIixcbiAgICBcInVuaXN3YXAud3RmXCIsXG4gICAgXCJ1bmlzd2Fwd2FsbGV0Lm5ldFwiLFxuICAgIFwicGFuY2FrZXN3YXB3YWxsZXRzdmFsaWRhdGlvbi5maW5hbmNlXCIsXG4gICAgXCJ3YWxsZXRzY29ubmVjdGlvbi5hcHBcIixcbiAgICBcIndhbGxldHNjb25uZWN0c3VwcG9ydHMuaW9cIixcbiAgICBcInd3dy1sb2dpbnMta3Jha2VuLWxvLmNvbVwiLFxuICAgIFwid3d3LWxvZ2lucy1rcmFrZW4tbWEuY29tXCIsXG4gICAgXCJ3d3ctbG9naW5zLWtyYWtlbi1ydS5jb21cIixcbiAgICBcInd3dy1sb2dpbnMta3Jha2VuLXN1LmNvbVwiLFxuICAgIFwia3Jha2Vucy1sb2dpbnMtZnUuY29tXCIsXG4gICAgXCJrcmFrZW4tbG9naW4tcm8uY29tXCIsXG4gICAgXCJrcmFrZW5pLWxvZ2lucy5jb21cIixcbiAgICBcImtyYWtlbnMtYWNjb3VudHMtYnIuY29tXCIsXG4gICAgXCJrcmFrZW5zLWFjY291bnRzLXBvLmNvbVwiLFxuICAgIFwia3Jha2Vucy1hY2NvdW50cy1wdC5jb21cIixcbiAgICBcImtyYWtlbnMtbG9naW5zLWZpLmNvbVwiLFxuICAgIFwia3Jha2Vucy1sb2dpbnMtaGkuY29tXCIsXG4gICAgXCJrcmFrZW5zLWxvZ2lucy1wYS5jb21cIixcbiAgICBcInd3bC1rcmFrZW4tbG9naW5zLXVpLmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtYXBwcy5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLWFzLmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtYXUuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy1jYS5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLWNoLmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtY2kuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy1jdS5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLWRlLmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtZHYuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy1lci5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLWllLmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtanAuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy1sZS5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLWxpLmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtbHEuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy1sdS5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLXJ1LmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtc2UuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy10aC5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLXVpLm9ubGluZVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtdWkueHl6XCIsXG4gICAgXCJpbmNoc3dhcC5jb21cIixcbiAgICBcInBhbmNha2Vib251cy5jb21cIixcbiAgICBcInJpcHBsZS5nci5jb21cIixcbiAgICBcImF4aWVuaW5maW5pdHkuY29tXCIsXG4gICAgXCJ1bmktZXZlbnQuaW5mb1wiLFxuICAgIFwic29sc3RhcnRlci5hcHBcIixcbiAgICBcImNvaW54aGFzaC5jb21cIixcbiAgICBcIm5leHVzLXN3YXAuY29tXCIsXG4gICAgXCJ0cm9ubGluay13YWxsZXQuY29tXCIsXG4gICAgXCIxaW5jaC5uZXdcIixcbiAgICBcIm11c2stZm91bmRlci5jb21cIixcbiAgICBcInRlcm9sYml0LmNvbVwiLFxuICAgIFwiZml4ZWR3YWxsZXQub3JnXCIsXG4gICAgXCJwb2xrYWRvdC1haXJkcm9wY2FtcGFpZ24ubmV0d29ya1wiLFxuICAgIFwiemFwcGVyLndzXCIsXG4gICAgXCJmb3VuZGF0bG9uLmFwcFwiLFxuICAgIFwidHJ1c3R3YWxsZXRyZXN0b3JlLm9yZ1wiLFxuICAgIFwibWV0YW1hc2tzd2FsbGV0cy5pb1wiLFxuICAgIFwid2FsbGV0LW5ldHdvcmsubGl2ZVwiLFxuICAgIFwiaW5zdGFkYXBwLndvcmtcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbG9naW4tcGFnZS5jYW5hZGlhbjI0aG91cnBoYXJtYWN5LmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtdGUuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy1wZS5jb21cIixcbiAgICBcIndhbGxldGNvbm5lY3RzdXBwb3J0cy5uZXRcIixcbiAgICBcIndhbGxldC1jb25uZWN0aW9uLm5ldFwiLFxuICAgIFwiZ2xhdmVidGMuY29tXCIsXG4gICAgXCJlbG9ubXVzay5hcHBcIixcbiAgICBcInNtYXJ0d2FsbGV0cmVzdG9yZS5pb1wiLFxuICAgIFwiZG9kb2V4ZS5jb21cIixcbiAgICBcInBvbGthZG90c3dhbGxldC53ZWJzaXRlXCIsXG4gICAgXCJsZWRnZXJwcm9tby5saXZlXCIsXG4gICAgXCJ3YWxsZXRjb25uZWN0ZGFwcC5saW5rXCIsXG4gICAgXCJ3YWxsZXRzdmFsaWRhdGlvbi5uZXRcIixcbiAgICBcInBhaWRuZXR3b3JrLmxpdmVcIixcbiAgICBcImluc3RhZGFwcC5uZXRcIixcbiAgICBcInVuaWZyZWVib251cy5jb21cIixcbiAgICBcImFpcmRyb3AtbGlxdWlkaXR5LmluZm9cIixcbiAgICBcInNvbGlkaXR5LXdlYjMuY29tXCIsXG4gICAgXCJhcHAudW5pc3dhcC5vcmcuc29saWRpdHktd2ViMy5jb21cIixcbiAgICBcImVsb24tZ3JhbnQuY29tXCIsXG4gICAgXCJ1bmlzd2FwLWV0aGVybm9kZS5vcmdcIixcbiAgICBcInBvbGthZG90LWdpZnQuaW5mb1wiLFxuICAgIFwid2FsbGV0cmVzdG9yYXRpb24uY29tXCIsXG4gICAgXCJjZWxzaXVzd2FsbGV0Lm5ldHdvcmtcIixcbiAgICBcImJldHJhZGViaXQuY29tXCIsXG4gICAgXCJjb2lucmF1LmNvbVwiLFxuICAgIFwibWV0YW1hc2tzdXBwb3J0LmNvbVwiLFxuICAgIFwibXl3YWxsZXR2YWxpZGF0aW9uLm9yZ1wiLFxuICAgIFwidW5pdG9rZW5naXZlLmNvbVwiLFxuICAgIFwic3ludGhldGl4Y29pbi5jb21cIixcbiAgICBcIndhbGxldHJlY29ubmVjdC5pbmZvXCIsXG4gICAgXCJhcHAudW5pc3dhcC5saXF1aWRpdHktaG9sZGVyLmNvbVwiLFxuICAgIFwiYXBwLnVuaXN3YXAuaG9sZGVyLWxpcXVpZGl0eS5jb21cIixcbiAgICBcImFwcC51bmlzd2FwLmluZm8tbGlxdWlkaXR5LmNvbVwiLFxuICAgIFwiYXBwLnVuaXN3YXAub3JnLWluZm8tbGlxdWlkaXR5LmNvbVwiLFxuICAgIFwibGlxdWlkaXR5LWhvbGRlci5jb21cIixcbiAgICBcImhvbGRlci1saXF1aWRpdHkuY29tXCIsXG4gICAgXCJpbmZvLWxpcXVpZGl0eS5jb21cIixcbiAgICBcIm9yZy1pbmZvLWxpcXVpZGl0eS5jb21cIixcbiAgICBcInVuaXN3YXB2Mm5vZGVzLmNvbVwiLFxuICAgIFwid2FsbGV0Y29ubmVjdC5iaXpcIixcbiAgICBcImJpdGJveGFwcC54eXpcIixcbiAgICBcInVuaXN3c2FwLmNvbVwiLFxuICAgIFwiZXRoZXJldW1naWZ0Lm1lXCIsXG4gICAgXCJ3d3ctZXRoZXJzY2FuLmNvbVwiLFxuICAgIFwiemlsbGlxYW1lcml0cy5jb21cIixcbiAgICBcInRlc2xhZ2F0ZS50b3BcIixcbiAgICBcImFpcmRyb3Bob3N0Lm5ldFwiLFxuICAgIFwiZW1iaXRjb2lucy5vcmdcIixcbiAgICBcImVsb25haXJkcm9wLnRvcFwiLFxuICAgIFwiZ2VtaW5pMjEub3JnXCIsXG4gICAgXCJycGxkcm9wLm5ldFwiLFxuICAgIFwiNGdlbWluaS5jb21cIixcbiAgICBcInNwYWNleGdpdmUubmV0XCIsXG4gICAgXCJrcmFrZW4tY29tLmNvbVwiLFxuICAgIFwia3Jha2VuLXNpZ24tbG4uY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy1pbi5jb21cIixcbiAgICBcInd3dy1rcmFrZW4tbG9naW5zLXB0LmNvbVwiLFxuICAgIFwid3d3LWtyYWtlbi1sb2dpbnMtdHIuY29tXCIsXG4gICAgXCJ3d3cta3Jha2VuLWxvZ2lucy11cy5jb21cIixcbiAgICBcImJpbmFuY2U0ZC5jbHViXCIsXG4gICAgXCJ3YWxsZXR1bmxvY2tjb25uZWN0LmNvbVwiLFxuICAgIFwid2FsbGV0Y29ubmVjdC53ZWItdW5sb2NrZXIuY29tXCIsXG4gICAgXCJldGhlcm5pdHkubWVcIixcbiAgICBcImNyeXB0b3Jvei5jb21cIixcbiAgICBcInBvbGthc3RhdGVyLmxpbmtcIixcbiAgICBcInRoZXNtYXJ0d2FsbGV0cmVzdG9yZS5saXZlXCIsXG4gICAgXCJldGhlcmV1bWdpZnQubmV0XCIsXG4gICAgXCJleGNoYW5nZS1yYXRlcy50b3BcIixcbiAgICBcImNvcmVidXguY29tXCIsXG4gICAgXCJ0ZXNsYS1lbG9ubXVzay5jb21cIixcbiAgICBcIm11c2stZG9uYXRlLm9yZ1wiLFxuICAgIFwiYnRjZ2l2ZXMub3JnXCIsXG4gICAgXCJidGNnZW5lcmF0aW9uLnZpcFwiLFxuICAgIFwibmV4dGdlbmVyYXRpb24uYmxvZ1wiLFxuICAgIFwiemlsbGV0aW5mby5jb21cIixcbiAgICBcIm15ZXRoZXJzd2FsbGV0Lm9ubGluZVwiLFxuICAgIFwicmVzdG9yZXNleG9kdXN3YWxsZXRzLm9ubGluZVwiLFxuICAgIFwiYml0ZnVnLmNvbVwiLFxuICAgIFwid2FsbGVjdGNvbm5lY3Rpb24uaW5mb1wiLFxuICAgIFwidHJ1c3R3YWxsZXRzLmFwcFwiLFxuICAgIFwicmVzdG9yZS1sZWRnZXJsaXZld2FsbGV0Lm9yZ1wiLFxuICAgIFwiZWxvbm11c2s2LmNvbVwiLFxuICAgIFwid2FsbGV0c3Jlc3RvcmUuaW9cIixcbiAgICBcInZlcmlmeXdhbGxldHMuaW9cIixcbiAgICBcInVuaXN3YXAtZXZlbnQubmV0XCIsXG4gICAgXCJtdXNrLXgubmV0XCIsXG4gICAgXCJlbG9ubW9uZXkudG9wXCIsXG4gICAgXCJtZXRhbWFza3dhbGxldHMubGl2ZVwiLFxuICAgIFwicG9sa2Fkb3RsaXZlLm5ldHdvcmtcIixcbiAgICBcImJpbmFuY2UuY29tMTIxODk2NTQ3NTg1MTEueHl6XCIsXG4gICAgXCJjb20xMjE4OTY1NDc1ODUxMS54eXpcIixcbiAgICBcIm1ldGFtYXNrY29ubmVjdC5vbmxpbmVcIixcbiAgICBcImNsYWltcG9sa2Fkb3QubmV0d29ya1wiLFxuICAgIFwicGFuY2FrZXN3YXBwLmZpbmFuY2VcIixcbiAgICBcImF0b21pY3dhbGxldHNyZXN0b3JlLm9ubGluZVwiLFxuICAgIFwiYXBwLnVuaXN3YXAub3JnLWhvbGRlcnMtYWlyZHJvcC5jb21cIixcbiAgICBcInVuaXN3ZXAtYXBwLmNvbVwiLFxuICAgIFwid2FsbGV0d2ViY29ubmVjdC5vbmxpbmVcIixcbiAgICBcImFwcC51bmlzd3NhcC5jb21cIixcbiAgICBcImxpdmV3YWxsZXRjb25uZWN0LmxpbmtcIixcbiAgICBcInRlc2xhdHcub3JnXCIsXG4gICAgXCJiaW5vcm9peC5jb21cIixcbiAgICBcImFwcmlsLnRyYWRlXCIsXG4gICAgXCJ3YWxsZXRibG9rc2Nvbm5lY3QubGl2ZVwiLFxuICAgIFwid2FsbGV0Y29ubmVjdGJvdC5jb21cIixcbiAgICBcInRyZXphci5pb1wiLFxuICAgIFwibXVzazJ4LWV2ZW50LmxpdmVcIixcbiAgICBcInBhbmNha2Vzd2FwLXJlc3RvcmUuZmluYW5jZVwiLFxuICAgIFwibWV0YW1hc2tzd2FsbGV0c2lvLmNvbVwiLFxuICAgIFwibWV0YW1hc2t3YWxsZXRzLmxpbmtcIixcbiAgICBcInRydXN0c3dhcC1haXJkcm9wLmNvbVwiLFxuICAgIFwic21hcnR3YWxsZXRyZXN0b3JlLmNvbVwiLFxuICAgIFwicG9sa2FzdGFydGVyLndzXCIsXG4gICAgXCJwb2xrYW1vbi5jb1wiLFxuICAgIFwibWV0YW1hc2t3YWxsZXRyZXN0b3JlLmNvbVwiLFxuICAgIFwieG4tLWJpdHZ2by16YzhiLmNvbVwiLFxuICAgIFwicGFuY2FrZXN3YXAuZmluYW5jZS5haXJkcm9wLWluZm8tcHJvdG9jb2wuY29tXCIsXG4gICAgXCJhaXJkcm9wLWluZm8tcHJvdG9jb2wuY29tXCIsXG4gICAgXCJvcGVuY2VhLmlvXCIsXG4gICAgXCJvbnhzd2FwLmNvbVwiLFxuICAgIFwid2FsbGV0Y29ubmVjdGxpdi5vcmdcIixcbiAgICBcIm1ldGFtYXNrLXJlc3RvcmUuY29tXCIsXG4gICAgXCJtZXRhbWFza3dhbGxldC5vcmdcIixcbiAgICBcIndhbGxldGNvbm5lY3Rpb25saXZlLmxpdmVcIixcbiAgICBcInRlc2xhZHJvcDIxLmNvbVwiLFxuICAgIFwibWVyY2Fkby1iaXRjb2lucy1sb2dpbi5jb21cIixcbiAgICBcInBhbmNha2Uud2FsbGV0c2Nvbm5lY3Rpb25zLmNvbVwiLFxuICAgIFwid2FsbGV0c2Nvbm5lY3Rpb25zLmNvbVwiLFxuICAgIFwiY2FzcGVyLXRva2Vuc2FsZS5jb21cIixcbiAgICBcIndhbGxldC5leG9kdXMuY29tLmIzN2R4LnNlaHphZGVsZXJkYWdpdGltLmNvbVwiLFxuICAgIFwiMW5pY2guY29tXCIsXG4gICAgXCJtZXRhbWFzay1hcGkuaW9cIixcbiAgICBcInRva2VuLWFpcmRyb3AuY29tXCIsXG4gICAgXCJhcHAudW5pc3dhcC50b2tlbi1haXJkcm9wLmNvbVwiLFxuICAgIFwicGFuY2FrZXN3YXAtZmluYW5jZS1yZXdhcmRzLnNpdGVcIixcbiAgICBcInBvbGthZG90LWFpcmRyb3Aub3JnXCIsXG4gICAgXCJjb25uZWN0aW9ud2FsbGV0LWxpbmsubGl2ZVwiLFxuICAgIFwid2FsbGV0c3luYy5zaXRlXCIsXG4gICAgXCJ3ZWJ3YWxsZXRzY29ubmVjdC5zaXRlXCIsXG4gICAgXCJ1bmlzd2FwLWV0aC1kcm9wLm9yZ1wiLFxuICAgIFwiY29pbi1naXZlLmNvbVwiLFxuICAgIFwic3VzaGlzd2Fwcy5vcmdcIixcbiAgICBcInBhbmNha3N3YXAuY29tXCIsXG4gICAgXCJpZG8tcG9sa2FzdGFydGVyLmNvbVwiLFxuICAgIFwiY29ubmVjdGlvbmxpdmUtd2FsbGV0LmxpdmVcIixcbiAgICBcImV4Y2hhbmdlLXN1c2hpLm5ldC1saXF1aWRpdHktcmV3YXJkcy5zaXRlXCIsXG4gICAgXCJuZXQtbGlxdWlkaXR5LXJld2FyZHMuc2l0ZVwiLFxuICAgIFwiYWlyZHJvcHN0YXJ0Lm5ldFwiLFxuICAgIFwibmV0LWxpcXVpZGl0eS1yZXdhcmRzLnBvb2wtbGlxdWlkaXR5LnNpdGVcIixcbiAgICBcInBvb2wtbGlxdWlkaXR5LnNpdGVcIixcbiAgICBcIndhbGxldGNvbm5lY3RzdXBwb3J0LmxpdmVcIixcbiAgICBcIndhbGxldGNvbm5lY3RyZXN0b3JlLmxpbmtcIixcbiAgICBcIm15ZWxvbngub3JnXCIsXG4gICAgXCJ3YWxsZXRjb25uZWN0cy5jb1wiLFxuICAgIFwiY3J5cHRvZGVwLmNvbVwiLFxuICAgIFwiYml0dHJpbGxleC5jb21cIixcbiAgICBcInJlb2JpdC5jb21cIixcbiAgICBcIndlZXRiaXQuY29tXCIsXG4gICAgXCJjcnlwZXhjaGFuZ2VyLmNvbVwiLFxuICAgIFwiZGVmaXRyYWRlY29pbi5jb21cIixcbiAgICBcImNvaW5mYWluLmNvbVwiLFxuICAgIFwid2FsbGV0bGl2ZWNvbm5lY3Rpb24uY29tXCIsXG4gICAgXCJhcHAudW5pbXN3YXAuY29tXCIsXG4gICAgXCJ1bmltc3dhcC5jb21cIixcbiAgICBcInppbGxpcWEtd2ViLnNpdGVcIixcbiAgICBcImJ0Y2V0aGRvZ2UuY2FzaFwiLFxuICAgIFwibXVza2dpdmVuLmNvbVwiLFxuICAgIFwicHJvbW8tYnRjLnVzXCIsXG4gICAgXCJiaXQtY29pbmxhbmQudWtcIixcbiAgICBcInVuaXN3dXAuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0bS5jY1wiLFxuICAgIFwiaW1wb3J0LW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJ3YWxsZXR2YWxpZGF0aW9uLm5ldFwiLFxuICAgIFwic3RyZWFtZWFybmluZ3Mub25saW5lXCIsXG4gICAgXCJsZW1tZW9wdGlvbnMuY29tXCIsXG4gICAgXCJ2ZXJpZnl3YWxsZXQuaW9cIixcbiAgICBcIjIwMjFzdGVsbGFyLm9yZ1wiLFxuICAgIFwibG9naW4tYmxvY2tjaGFpbi5jb20uY29cIixcbiAgICBcIjFpZ2NoLmV4Y2hhbmdlXCIsXG4gICAgXCJ0cnVzdHNhZmVhc3NldHMuY29tXCIsXG4gICAgXCJtYXh4aXNjb2luLm5ldFwiLFxuICAgIFwicGVubnl0b2tlbi5vbmxpbmVcIixcbiAgICBcImNvcmV4Yml0LmNvbVwiLFxuICAgIFwiYmFuZXNjb25zdWx0cy5jb21cIixcbiAgICBcImJpdGNvaW5hc3RlLmNvbVwiLFxuICAgIFwiYmV0Y3J5cHRvcGxheS5jb21cIixcbiAgICBcInBlbmNha2Vzd2FwLmZpbmFuY2VcIixcbiAgICBcImJpdG1hcmtldGNvaW5zLmNvbVwiLFxuICAgIFwidHJpY29pbnguY29tXCIsXG4gICAgXCJsaXF1aWRpdHktbW9ycGhldXMubmV0d29ya1wiLFxuICAgIFwidGVzbGEyMDAueHl6XCIsXG4gICAgXCJnZW9jcnlwdG8ubmV0XCIsXG4gICAgXCJiaXR0eWV4LmNvbVwiLFxuICAgIFwidmFsaWRhdGVtZXRhbWFza3dhbGxldC5pb1wiLFxuICAgIFwibGl2ZS13YWxsZXQtY29ubmVjdC5jb21cIixcbiAgICBcInJveWFsY3J5cHRvMjQ3LmNvbVwiLFxuICAgIFwiYml0c3dhcGV4LmNvbVwiLFxuICAgIFwiZGVmaWJpdGV4LmNvbVwiLFxuICAgIFwiYml0ZXhjb3JlLmNvbVwiLFxuICAgIFwiYnV4Y29pbnMuY29tXCIsXG4gICAgXCJiaXR4YXJ5LmNvbVwiLFxuICAgIFwiYml0c3JhaXNlLmNvbVwiLFxuICAgIFwibW9ub2J0Yy5jb21cIixcbiAgICBcImNvaW5zcmF5LmNvbVwiLFxuICAgIFwiYml0c2NoYW5nZXIuY29tXCIsXG4gICAgXCJ4bi0tdWlzd2FwLWllYi5jb21cIixcbiAgICBcIndhbGxldC1zeW5jaW5nLmNvbVwiLFxuICAgIFwiYWlyZHJvcHN0YXJ0LmNvbVwiLFxuICAgIFwiYXV0aC1nbHRodWIuY29tXCIsXG4gICAgXCJ5ZWFtdXNrLm9yZ1wiLFxuICAgIFwiYm9zb25wcm90b2NvbC5tZVwiLFxuICAgIFwibWV3Y29ubmVjdC5teWV0bmVyd2FsbGV0LnJ1XCIsXG4gICAgXCJjcnlwdG9lYml0LmNvbVwiLFxuICAgIFwibXlldGhlaHdhbGxldC5jb21cIixcbiAgICBcIndhbGV0Y29ubmVjdC5jb21cIixcbiAgICBcInRyZXp6b3JyLmlvXCIsXG4gICAgXCJlbG9uc3BlY3NlYWdyZWVuc29sYXJpcy5mb2Nham82MzY1LnJlcGwuY29cIixcbiAgICBcImNvaW5kcm9wLmNsdWJcIixcbiAgICBcImJueGRyb3Aub3JnXCIsXG4gICAgXCJsaXZld2FsbGV0Y29ubmVjdC5vcmdcIixcbiAgICBcIndhbGxldHZhbGlkYXRpb24uY29cIixcbiAgICBcIndhbGxldHNjb25uZWN0aW9uLmNvbVwiLFxuICAgIFwibGl2ZXdhbGxldGxpbmtlci5vcmdcIixcbiAgICBcImNvbm5lY3Rpb25saXZld2FsbGV0Lm5ldFwiLFxuICAgIFwid2FsbGV0cmVzdG9yZS5vbmxpbmVcIixcbiAgICBcIndhbGxldHZhbGlkYXRpb24ub25saW5lXCIsXG4gICAgXCJhaXJtdXNrLm5ldFwiLFxuICAgIFwiY2FzcGVyLmxpbWl0ZWRcIixcbiAgICBcInRlc2xhZ2l2ZWNyeXB0by5jb21cIixcbiAgICBcImNyeXB0by1naWZ0LmRlYWxzXCIsXG4gICAgXCJidGNwcm9tby5uZXRcIixcbiAgICBcIm11c2tkZXAuY29tXCIsXG4gICAgXCJtdXNrLWhlbHAuY29tXCIsXG4gICAgXCJtdXNrMnguY29tXCIsXG4gICAgXCJlbXVza3RvcC5jb21cIixcbiAgICBcIm11c2tzaG93LmNvbVwiLFxuICAgIFwiZ2Vja2NvaW4uY29tXCIsXG4gICAgXCJjcnlwdG9yb3ppLmNvbVwiLFxuICAgIFwiYnVuY2ViaXQuY29tXCIsXG4gICAgXCJjcnlwdG9weWUuY29tXCIsXG4gICAgXCJlbG9uZXZlbnQub3JnXCIsXG4gICAgXCIxbmNpaC5leGNoYW5nZVwiLFxuICAgIFwidW5pc3dhcG5ld2dpdmVhd2F5LmNvbVwiLFxuICAgIFwiYWRhZ2lmdC5tZVwiLFxuICAgIFwidW5pc3dhcHYybm9kZS5vbmxpbmVcIixcbiAgICBcIndhbGxldC1zeW4uY29tXCIsXG4gICAgXCJmYW50b20tZm91bmRhdGlvbi51c1wiLFxuICAgIFwiYmFkZ2VyZmkudXNcIixcbiAgICBcImFwaS13YWxsZXRjb25uZWN0Lm9yZ1wiLFxuICAgIFwid2FsbC5wcm9ob3N0ZXIuYml6XCIsXG4gICAgXCJ0ZXNsYWIudXNcIixcbiAgICBcImVsb25tdXNrLWdpdmVzLnMzLmFtYXpvbmF3cy5jb21cIixcbiAgICBcIm5ld3VuaWdpdmVhd2F5LmNvbVwiLFxuICAgIFwidGVzbGFjcnlwdG8udG9wXCIsXG4gICAgXCJwYW5jYWtlc3N3YXAuY29tXCIsXG4gICAgXCJqdXN0c3dhcC51c1wiLFxuICAgIFwiaGl2ZXByb2plY3QudXNcIixcbiAgICBcInJhdmVucHJvamVjdC5uZXRcIixcbiAgICBcImJha2VyeXN3YXAudXNcIixcbiAgICBcImRhZWRhbHVzd2FsbGV0Lm5ldFwiLFxuICAgIFwib2Zlcm9ucmFpbi53ZWIuYXBwXCIsXG4gICAgXCJ0aGVncmFwaC51c1wiLFxuICAgIFwibnVjeXBoZXIuYml6XCIsXG4gICAgXCJtdXNrLmluZm9cIixcbiAgICBcImNsYWltLW5vdy5tZVwiLFxuICAgIFwic21hcnRpbnRlZ3JhdGlvbi5saXZlXCIsXG4gICAgXCJ4cnAyMS5uZXRcIixcbiAgICBcImRvZG9leC5saXZlXCIsXG4gICAgXCJhZGEtY2FyZGFuby51c1wiLFxuICAgIFwieG4tLXVuc3dhZXAtc2ZiLmNvbVwiLFxuICAgIFwid2Vid2FsbGV0c2Nvbm5lY3QubGlua1wiLFxuICAgIFwic3VzaGlmaW5hbmNlLnVzXCIsXG4gICAgXCJ3YXNhYmJpLmV1XCIsXG4gICAgXCJ3YWxsZXRzY29ubmVjdC5uZXRcIixcbiAgICBcInVuaXN3YWVwLmNvbVwiLFxuICAgIFwidW5pc3dhcG5vZGV2MS5jb21cIixcbiAgICBcImJ0Y2Zhc3QudmlwXCIsXG4gICAgXCJnZXRidGMudG9wXCIsXG4gICAgXCJlbG9ubXVzay1naXZlYXdheS5zMy5hbWF6b25hd3MuY29tXCIsXG4gICAgXCJnZXRidGMub25lXCIsXG4gICAgXCJrb25vbWkuaW9cIixcbiAgICBcImFwcC51bmlzd2FwLmhvbGRlcnMtYWlyZHJvcC5jb21cIixcbiAgICBcImhvbGRlcnMtYWlyZHJvcC5jb21cIixcbiAgICBcInBhbnN3YXBjYWtlLmNvbVwiLFxuICAgIFwia3Jha2VucmV3YXJkLmNvbVwiLFxuICAgIFwiZmJjLWxpbWl0ZWQuY29tXCIsXG4gICAgXCJtdXNrLWluLmNvbVwiLFxuICAgIFwiZHNkdG9rZW5kcm9wcy5jb21cIixcbiAgICBcImdyb3dteWJpdC5jb21cIixcbiAgICBcInRoZXNtYXJ0aW50ZWdyYXRpb24uY29tXCIsXG4gICAgXCJzdGJ6bWVyaXRzLmNvbVwiLFxuICAgIFwiY3VydmVmaS51c1wiLFxuICAgIFwiYWlyZHJvcC1ob2xkZXJzLXVuaXN3YXAub3JnXCIsXG4gICAgXCJ3YWxsZXRjb25uZWN0bGl2ZS5jb21cIixcbiAgICBcImFwcG1hbnRyYWRhby5jb21cIixcbiAgICBcImFscGhhZmluYW5jZS5iaXpcIixcbiAgICBcImNvbWJvLXJld2FyZHMubmV0bGlmeS5hcHBcIixcbiAgICBcImJpeGNhcC5jb21cIixcbiAgICBcImFweXN3YXAuY29cIixcbiAgICBcImhvbGRlcnMtYWlyZHJvcC11bmlzd2FwLm9yZ1wiLFxuICAgIFwiemlsbGlxYS5wcm9cIixcbiAgICBcImNvaW5iYXNlZG9uYXRlLm5ldFwiLFxuICAgIFwibXVzay1haXJkcm9wLm9yZ1wiLFxuICAgIFwidGVzbGEzLnNwYWNlXCIsXG4gICAgXCJ0ZXNsYTMudGVhbVwiLFxuICAgIFwibXVzay1lLWdpdmVhd2F5LmxpdmVcIixcbiAgICBcImVsb24tbS1naXZlYXdheS5saXZlXCIsXG4gICAgXCJtdXNrLWVsb24tZ2l2ZWF3YXkubWVcIixcbiAgICBcImdlbWluaS10cmFuc2FjdGlvbi5mdW5cIixcbiAgICBcImVtdXNrNC5jb21cIixcbiAgICBcImVsb24tY2x1YmhvdXNlLmxpdmVcIixcbiAgICBcImVsb24tYWlyZHJvcC5vcmdcIixcbiAgICBcImdpdmVhd2F5LWVsb24tbS50ZWNoXCIsXG4gICAgXCJnZXRidGMuZ2lmdFwiLFxuICAgIFwiZWxvbi1jcnlwdG9kcm9wLm9ubGluZVwiLFxuICAgIFwiZWxvbjJ4LmNvbVwiLFxuICAgIFwiY29pbjIucmVwbC5jb1wiLFxuICAgIFwieGxtc3dhcC5jb21cIixcbiAgICBcImVsb25yZXdhcmRzLm9ubGluZVwiLFxuICAgIFwibXVzay11cC5jb21cIixcbiAgICBcIm11c2syMS5uZXRcIixcbiAgICBcImNoYW1hdGguYml6XCIsXG4gICAgXCJjaGFtYXRocGF5bWVudC5ibG9nc3BvdC5jb21cIixcbiAgICBcImNoYW1hdGgtbGFuZGVyMS5ibG9nc3BvdC5jb21cIixcbiAgICBcImNoYW1hdGhwYXk0LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZWxvbi1jbGFpbS5pbmZvXCIsXG4gICAgXCJlbG9ubXVza2NoYXJpdHkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJidGNhaXJkcm9wZWxvbi5ibG9nc3BvdC5jb21cIixcbiAgICBcInJwbDQub3JnXCIsXG4gICAgXCJzdGVsbGFyLm9yZy5pbFwiLFxuICAgIFwiYml0c3RhbXByZXdhcmQuY29tXCIsXG4gICAgXCJlbG9ucy5zdXJnZS5zaFwiLFxuICAgIFwiZXRoZHJvcG5vdy5ibG9nc3BvdC5jb21cIixcbiAgICBcImJ0Y2Ryb3Bub3cuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJlbG9ucGF5bWVudDE2LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZWxvbmxhbmRlLXIxOC5ibG9nc3BvdC5jb21cIixcbiAgICBcImJjaG53YWxsZXQub3JnXCIsXG4gICAgXCJiY2hub2Rld2FsbGV0Lm9yZ1wiLFxuICAgIFwiZWxvbnhwLmdpdGh1Yi5pb1wiLFxuICAgIFwid2FsZXRjb25lY3QubGl2ZVwiLFxuICAgIFwiYm5kcm9wLm9yZ1wiLFxuICAgIFwic2NhcGl0YWwuYml6XCIsXG4gICAgXCJ1bmlzd2FwZ2l2ZWF3YXkuaW5mb1wiLFxuICAgIFwibmV3dW5pc3dhcC5jb21cIixcbiAgICBcIjRsaW5rLm9uZVwiLFxuICAgIFwiZXRobGVnaXQuY29tXCIsXG4gICAgXCJmeG9wZWwuY29tXCIsXG4gICAgXCJkb2dlMjEubmV0XCIsXG4gICAgXCJ1bmlzd2FwYWRkcmVzcy5jb21cIixcbiAgICBcInJvY2xkLmNvbVwiLFxuICAgIFwic3RlbGxhci1haXJkcm9wLmNvbVwiLFxuICAgIFwidW5pLXByb2plY3Qub3JnXCIsXG4gICAgXCJjb25uZWN0aW9ubGl2ZXdhbGxldHMub3JnXCIsXG4gICAgXCJodHRwc2FwcG15Y3J5cHRvY29tLnNsYWNrLmNvbVwiLFxuICAgIFwiY2xhaW0tYnRjLm5ldFwiLFxuICAgIFwic3RhcnQtZ2VtaW5pLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYml0emNoYW5nZXIuY29tXCIsXG4gICAgXCJkb3Q0LnRvcFwiLFxuICAgIFwieG4tLW1ldGFtc2stZW40Yy5jb21cIixcbiAgICBcIndhdmVidGMuY29tXCIsXG4gICAgXCJlbG9uaW52ZXN0aW5nLmNvbVwiLFxuICAgIFwiZHJvcHh0ZXNsYS5jb21cIixcbiAgICBcImVsb25mdW5keC5jb21cIixcbiAgICBcImNsYWltYml0Y29pbi5wcm9cIixcbiAgICBcIm11c2stZ2l2ZWJ0Yy5zMy5ldS13ZXN0LTMuYW1hem9uYXdzLmNvbVwiLFxuICAgIFwiY29pbmRyb3AudmlwXCIsXG4gICAgXCJibHVwcm9kdWN0cy5jb21cIixcbiAgICBcIm11c2tidGMuZnVuXCIsXG4gICAgXCJtdXNrLWNoLmNvbVwiLFxuICAgIFwiY29pbmV2ZW50Lm5ldFwiLFxuICAgIFwiY29pbmV2ZW50czIwMjFpbmZvLmRlcGVuYXg3NjkucmVwbC5jb1wiLFxuICAgIFwibXVza2JpdC5jbHViXCIsXG4gICAgXCJtdXNrZ2l2ZWF3YXkyMDIxLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiaWxvZ2l2ZW11cy0yMDIxLmluZm9cIixcbiAgICBcInNvbGFuYWJpdC5jb21cIixcbiAgICBcImJ0Y3NhbS5jb21cIixcbiAgICBcImJ0Y2xhbS5jb21cIixcbiAgICBcIndhbGxldHNjb25uZXRzLmNvbVwiLFxuICAgIFwiY29pbi1ldmVudC5jb21cIixcbiAgICBcImVsb24tcG9ydGFsLmNvbVwiLFxuICAgIFwiZXdhbGxldGNvbm5lY3QubGlua1wiLFxuICAgIFwid2F2ZXNsaXRld2FsbGV0Lm9yZ1wiLFxuICAgIFwibXVza3RlYW0ubWxcIixcbiAgICBcInRydXN0LXdhbGxldHMuaW5mb1wiLFxuICAgIFwiY29zbW9jaGFuZ2UuY29tXCIsXG4gICAgXCJlbG9uLW11c2stbWVkaXVtLmNvbVwiLFxuICAgIFwiZG9kb2V4LnVzXCIsXG4gICAgXCJlbG9uLnNvXCIsXG4gICAgXCJhcHAuYmV0YS12Mi11bmlzd2FwLm9yZ1wiLFxuICAgIFwiYXBwLXVuaXN3YXAuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJlbG9uZG9uYXRlLmNvbVwiLFxuICAgIFwibXVza2Ryb3AuY2NcIixcbiAgICBcImVsb25ub3cuZ2l0aHViLmlvXCIsXG4gICAgXCJhcHAudW5pc3dhcC5haXJkcm9wLWhvbGRlcnMtdW5pc3dhcC5vcmdcIixcbiAgICBcInJlc3RvcmV3YWxsZXRzaW8ubGlua1wiLFxuICAgIFwicHJpbWUtYml0Z28uY29tXCIsXG4gICAgXCJiaXRtZXgtd2l0aGRyYXdhbC1kaXNhYmxlZC5jb21cIixcbiAgICBcInBheGZ1bC1iaW5hcnkuY29tXCIsXG4gICAgXCJlbG9udGVzbGEubWVcIixcbiAgICBcIndhbGxldC12YWxpZGF0aW9uLmNvbVwiLFxuICAgIFwicHJvdG9jb2wtYWlyZHJvcC5jb21cIixcbiAgICBcIjEtaWNuaC5maW5hbmNlXCIsXG4gICAgXCJhY2NvdW50dmlld2VyLnN0ZWxsYXIub3JnLmh0XCIsXG4gICAgXCJzdGVsbGFyLm9yZy5odFwiLFxuICAgIFwicG9sb25pZXgtbGlnaW4tdXMuY29tXCIsXG4gICAgXCJhbXRpbnZlc3RtZW50c3B0eWx0ZC5jb21cIixcbiAgICBcImJ0Yy1kcm9wLnh5elwiLFxuICAgIFwiYXBwLnVuaXN3YXAub3JnLmlvLWVyYzIwLndvcmtcIixcbiAgICBcImlvLWVyYzIwLndvcmtcIixcbiAgICBcInN3YXAtcG9vbC5zaXRlXCIsXG4gICAgXCJibmJnZXQub3JnXCIsXG4gICAgXCJldmVudGJpbmFuY2Uub3JnXCIsXG4gICAgXCJhcHAtdW5pc3dhcC5leGNoYW5nZVwiLFxuICAgIFwibG90dG8uZmFzaGlvblwiLFxuICAgIFwiZWxvbm11c2suaGVscFwiLFxuICAgIFwidW5pc3dhcHYyLm9ubGluZVwiLFxuICAgIFwiYWRhLWxpdGUudXNcIixcbiAgICBcImJpdGZpbmV4Z2l2ZWF3YXkuY29tXCIsXG4gICAgXCIxaW5jaC1haXJkcm9wLmxpdmVcIixcbiAgICBcInN0ZWxsYXIub3JnLnBsXCIsXG4gICAgXCJhY2NvdW50dmlld2VyLnN0ZWxsYXIub3JnLnBsXCIsXG4gICAgXCJjYXJkYW5vLWZvdW5kYXRpb24udXNcIixcbiAgICBcImFkYWxpdGUuY29tLmNtXCIsXG4gICAgXCJ6aWxtZXJpdHMuY29tXCIsXG4gICAgXCJ6aWxkcm9wcy5jb21cIixcbiAgICBcInRha2V5b3VyY3J5cHRvLmluZm9cIixcbiAgICBcInRlc2xhLW11c2suY29tXCIsXG4gICAgXCJwcm9tby1tdXNrLm5ldFwiLFxuICAgIFwiZWxvbmhlbHAubWVcIixcbiAgICBcImVsb25mdW5kYXRpb24uY29tXCIsXG4gICAgXCJjaGFtYXRoLWdpdmVzLnNpdGVcIixcbiAgICBcIm11c2stb24uY29tXCIsXG4gICAgXCJjaGFtYXRoc29jaWFsLmNvbVwiLFxuICAgIFwiZmVycnVtLmF3YXJkLXByb2dyYW1zLmNvbVwiLFxuICAgIFwiYXBwLnVuaXN3YXAucHJvdG9jb2wtYWlyZHJvcC5jb21cIixcbiAgICBcImVsb250cnVzdC5jb21cIixcbiAgICBcImdldGJpdGNhcC5jb21cIixcbiAgICBcImV0aDIwc3Rha2luZy5vcmdcIixcbiAgICBcInphcHBlcmkuZmluYW5jZVwiLFxuICAgIFwid2FsbGV0Y29uZWN0LmluZm9cIixcbiAgICBcIm11c2suaGVscFwiLFxuICAgIFwiZWxtdXNrLm9yZ1wiLFxuICAgIFwiZWxvbnguY2x1YlwiLFxuICAgIFwiZWxvbi1tdXNrLmxpZmVcIixcbiAgICBcImVsb24yLmNsdWJcIixcbiAgICBcImVsb24tbGFuZGVyNC5ibG9nc3BvdC5jb21cIixcbiAgICBcImVsb25idGNwYXltZW50OS5ibG9nc3BvdC5jb21cIixcbiAgICBcIm9uZWlzaC54eXpcIixcbiAgICBcImVsb24tc3RhcnQuY29tXCIsXG4gICAgXCJlbG9uYm9udXMuY2x1YlwiLFxuICAgIFwibXVzay1haXJkcm9wLm5ldFwiLFxuICAgIFwibXVzay1mdW5kLm5ldFwiLFxuICAgIFwibXVzay1jbHViLmNvbVwiLFxuICAgIFwiZWxvbm11c2tnaXZlYXdheS5vcmdcIixcbiAgICBcInRoZWJpdGNvaW5lcmFhcHAuY29tXCIsXG4gICAgXCJidGNvaW4tYmFuay5jb21cIixcbiAgICBcImJ0Y29pbmZ1dHVyZS5jb21cIixcbiAgICBcImZpcnN0ZnhvcHRpb24uY29tXCIsXG4gICAgXCJidGNvaW5yZXZvbHV0aW9uLmNvbVwiLFxuICAgIFwiYnRjb2luZXJhLmNvbVwiLFxuICAgIFwiZ3JlYXR0b3VjaHRyYWRlLmNvbVwiLFxuICAgIFwiY3J5cHRvbGl2ZXRyYWRpbmcubHRkXCIsXG4gICAgXCJidGNvaW5ldm9sdXRpb24uY29tXCIsXG4gICAgXCJiaXRwcm9meC5jb21cIixcbiAgICBcImJpdHJldm9sdXRpb24uaW5mb1wiLFxuICAgIFwiYml0Y29pbi1ldm9sdXRpb25wcm8uY29tXCIsXG4gICAgXCJiaXRjb2luc2NvZGVwcm8uY29tXCIsXG4gICAgXCJiaXRjb2luZXJhbmV3LmNvbVwiLFxuICAgIFwiZXhvZHVzc3VwcG9ydC5jb21cIixcbiAgICBcImJ0Y2dlbi5jY1wiLFxuICAgIFwic3RlbGxhci1wbGF0Zm9ybS5jb21cIixcbiAgICBcImV0aGVyYWlyZHJvcC5uZXRcIixcbiAgICBcImFkYS1saXRlLm9yZ1wiLFxuICAgIFwiZHJvcG11c2t4LmlyXCIsXG4gICAgXCJtdXNrNC50b3BcIixcbiAgICBcIm11c2stYWlyZHJvcC5jb21cIixcbiAgICBcImhhcnZlc3RmaW5hbmNlLmNvXCIsXG4gICAgXCJ3YWxsZXQtdmFsaWRhdGlvbi5vbmxpbmVcIixcbiAgICBcImFkYS1ldmVudC5saWZlXCIsXG4gICAgXCJjcnlwdG9yZXZvbHRwcm8uY29tXCIsXG4gICAgXCJ0aGUtYml0Y29pbi1iZW5lZml0LXByby5jb21cIixcbiAgICBcImJ0Y2Z1dHVyZS5iaXRjb2luYnV5ZXJzLm9ubGluZVwiLFxuICAgIFwidGhlYml0cXRhcHAuY29tXCIsXG4gICAgXCJ0aGUtY3J5cHRvY29kZS1wcm8uY29tXCIsXG4gICAgXCJ0aGUtZHViYWlsaWZlc3R5bGUtcHJvLmNvbVwiLFxuICAgIFwidGhlLWJpdGNvaW4tcmVqb2luLXByby5jb21cIixcbiAgICBcImJpdGNvaW4tcmV2aXZhbHByby5jb21cIixcbiAgICBcImJpdGNvaW5jaXJjdWl0bm93LmNvbVwiLFxuICAgIFwibmV4dC5idGMtdHJhZGUtYXBwLmNsdWJcIixcbiAgICBcImNyeXB0by1nZW5pc3VzLmNvbVwiLFxuICAgIFwiYml0Y29pbmNhc2gtZ3JhYi5jb21cIixcbiAgICBcInRoZS1iaXRjb2luLW1pbGxpb25haXJlLmNvbVwiLFxuICAgIFwidGhlLWNyeXB0b3NvZnQtcHJvLmNvbVwiLFxuICAgIFwidGhlLWFpLXN0b2NrLXByb2ZpdC1wcm8uY29tXCIsXG4gICAgXCJiaXRjb2luLWJpbGxpb25haXJlLXByby5jb21cIixcbiAgICBcInRoZS1iaXRjb2luLW9wdGltaXplci1wcm8uY29tXCIsXG4gICAgXCJ0aGUtY3J5cHRvLW5hdGlvbmFwcC5jb21cIixcbiAgICBcInRoZS1jcnlwdC1leC1wcm8uY29tXCIsXG4gICAgXCJ0aGUtYml0Y29pbi1mdXR1cmVhcHAuY29tXCIsXG4gICAgXCJ0aGUtYml0Y29pbi1zdXByZW1lLmNvbVwiLFxuICAgIFwiYml0Y29pbnRyYWRlci5haVwiLFxuICAgIFwidGhlLWNyeXB0b2dlbml1cy1wcm8uY29tXCIsXG4gICAgXCJmeHN0b2NrdHJhZGVzb3B0aW9uLmNvbVwiLFxuICAgIFwiZnh0cmFkaW5nYXNzZXRzLmNvbVwiLFxuICAgIFwiY3J5cHRvdHJhZGVhc3NldHMuY29tXCIsXG4gICAgXCJmeHRyYWRlYXNzZXRzLmNvbVwiLFxuICAgIFwiY3J5cHN0cmFkZS5jb1wiLFxuICAgIFwiZm54Y3J5cHRvLmNvbVwiLFxuICAgIFwiaW5kZXhjcnlwdG9meC5jb21cIixcbiAgICBcImJsdWV3YXZlZnhjLm9ubGluZVwiLFxuICAgIFwiYml0Y29pbi1ldm9sdXRpb24uY29cIixcbiAgICBcImJpdGNvaW4tcnVzaC5jb1wiLFxuICAgIFwib3B0aW11bXRyYWRlcnMubGl2ZVwiLFxuICAgIFwiZHBpdG9rZW5kcm9wcy5jb21cIixcbiAgICBcInVuaXN3YXAtZnJlZS5jb21cIixcbiAgICBcIjFpbmNoeC5leGNoYW5nZVwiLFxuICAgIFwiYWNjb3VudHMtYmluYW5jZS1sb2ctaW4uY29tXCIsXG4gICAgXCJ1bmlzd2Fwbm9kZXYyLmNvbVwiLFxuICAgIFwiYWF2ZS5wd1wiLFxuICAgIFwiYXBwLnVuaXNzd2FwLmNvbVwiLFxuICAgIFwibXlldHB3YWxsZXQuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcIndzYmNhcC5jb21cIixcbiAgICBcIm9wZXhjaGFuZ2UyNC5jb21cIixcbiAgICBcInNlbmR1bmlzd2FwLmNvbVwiLFxuICAgIFwiY3J5cHRvZ2lmdHNnaXZlLm5lb2NpdGllcy5vcmdcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tYXQuY2NcIixcbiAgICBcInN0ZWxsYXIub3JnLmFnXCIsXG4gICAgXCJhY2NvdW50dmlld2VyLnN0ZWxsYXIub3JnLmFnXCIsXG4gICAgXCJtYWlsNC1zdGVsbGFyLm9yZ1wiLFxuICAgIFwibWV0YW1hc2suaW4ubmV0XCIsXG4gICAgXCJhZGFsaWZlLmlvXCIsXG4gICAgXCJhZGFsbHRlLmlvXCIsXG4gICAgXCJhZGFpbHRlLmlvXCIsXG4gICAgXCJhZGFsaXRlLnByb1wiLFxuICAgIFwiYWRhbGlmZS5zb1wiLFxuICAgIFwiYWRhaWl0ZS5pb1wiLFxuICAgIFwiYWRhLWxpdGUuaW9cIixcbiAgICBcImFkYWxpdGUuc29cIixcbiAgICBcImFkYWxpdGUub3JnXCIsXG4gICAgXCJ5ZWFybnNvbi5maW5hbmNlXCIsXG4gICAgXCJjdXZyZS5maW5hbmNpYWxcIixcbiAgICBcInN3ZXJ2ZS5mb1wiLFxuICAgIFwic3dlcnZlLmZtXCIsXG4gICAgXCJzd2VydmUuZmluYW5jaWFsXCIsXG4gICAgXCJhYXZlZS5jb1wiLFxuICAgIFwidW5pc3dhcGJhY2suY29tXCIsXG4gICAgXCJhcHAudW5pc3dhcC5vcmcuYWRoZWYuY29tXCIsXG4gICAgXCJ1bmkyMDIxLm9yZ1wiLFxuICAgIFwieG4tLWJsY29rY2hhbi1kNWE1NWcuY29tXCIsXG4gICAgXCIyMDIxdW5pLm9yZ1wiLFxuICAgIFwiMWljbmNoLmV4Y2hhbmdlXCIsXG4gICAgXCJnaXZlYXdheXVuaXN3YXAuY29tXCIsXG4gICAgXCJleG9kdXMtdXBkYXRlLmNvbVwiLFxuICAgIFwiY29ubmVjdGlvbmxpdmV3YWxsZXQub3JnXCIsXG4gICAgXCJ1bmlzd2FwZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJzdXNoaWFpcmRyb3AubmV0XCIsXG4gICAgXCJjb2luYmFzZS5jb20uYXV0aC12YWx1ZS10b2tlbi05OTI5OTI5LnJ1XCIsXG4gICAgXCJjb2luYmFzZS5jb20uc2VjdXJlLWFjY291bnQxODgucnVcIixcbiAgICBcInNlY3VyZS1hY2NvdW50MTg4LnJ1XCIsXG4gICAgXCJhdXRoLXRva2VuLWF1dGhlbnRpY2F0aW9uLXZhbHVlLTQ3ODIzNjUyMzQucnVcIixcbiAgICBcImF1dGhlbnRpY2F0ZS1jb2luYmFzZS5jb21cIixcbiAgICBcImludGVncmF0ZXdhbGxldC5saXZlXCIsXG4gICAgXCJzeW50aGV0aXgudXNcIixcbiAgICBcIndhbGxldHNjb25uZWN0Lm9yZ1wiLFxuICAgIFwiemFwcGVyaS5maVwiLFxuICAgIFwid2FsbGV0c2Nvbm5lY3QudG9wXCIsXG4gICAgXCJ3YWxsZXRzY29ubmVjdC5vbmxpbmVcIixcbiAgICBcImFwcHVuaXN3YXBzLm9yZ1wiLFxuICAgIFwibWV0YW1hc2NrLmNvbVwiLFxuICAgIFwidW5pdndhcHMuY29tXCIsXG4gICAgXCJnZW1pbmktZ2l2ZXMuY29tXCIsXG4gICAgXCJjaGFtYXRoLXNvY2lhbC5jb21cIixcbiAgICBcImNvaW5yYXl6LmNvbVwiLFxuICAgIFwieG4tLWF2ZS1zZ3ouY29tXCIsXG4gICAgXCJyZWNlaXZldW5pc3dhcC5jb21cIixcbiAgICBcImV4b2R1cy1zdXBwb3J0cy5jb21cIixcbiAgICBcImNsYWltLWNyeXB0by5zaXRlXCIsXG4gICAgXCJ4bi0tYWNjb3VudHMtYm5hbmNlLWVwYi5jb21cIixcbiAgICBcIm11c2syLnRvcFwiLFxuICAgIFwidG9rZW4tZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJzb2NpYWxjYXBpdGFsLnBhZ2VcIixcbiAgICBcImJpdG15Y2FwLmNvbVwiLFxuICAgIFwiYmluZXhvci5jb21cIixcbiAgICBcIm11c2stcHJpemUuY29tXCIsXG4gICAgXCJlbG9uLWJvbnVzLm9yZ1wiLFxuICAgIFwicHJlc2VhcmNoLnRva2VuLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwidml0YWxpa2J1dGVyaW4uaW9cIixcbiAgICBcInVuaXN3YXAtY29pbi5jb21cIixcbiAgICBcImdlbWluaS1ldmVudC5ibG9nc3BvdC5jb21cIixcbiAgICBcImdlbWluaS1yZWNlaXZlLmJsb2dzcG90LmNvbVwiLFxuICAgIFwidW5kd2FwbGUuY29tXCIsXG4gICAgXCJzYWZldHktcGF4ZnVsLmNvbVwiLFxuICAgIFwicGxlZ2FsLXBheGZ1bC5jb21cIixcbiAgICBcImVsZWN0cnVtc29mdC5saXZlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbXNrLm9yZ1wiLFxuICAgIFwiZ2VtaW5pLWJvbnVzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwid2lua2xldm9zcy1icm90aGVycy1ib251cy5ibG9nc3BvdC5jb21cIixcbiAgICBcIndpbmtsZXZvc3MtYnJvdGhlcnMtYml0LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiY3J5cHRvLWVsb24ubmV0XCIsXG4gICAgXCJtZXRhbWFzay5pby1pbnN0YWxsLmNvbVwiLFxuICAgIFwid2FsbGV0Y29ubmV0LmxpZmVcIixcbiAgICBcInhtci1xci1jb2RlLWdlbmVyYXRvci5jb21cIixcbiAgICBcInNoYWRlYml0LmNvbVwiLFxuICAgIFwiYXBwLnVuaXN3YXAuaW5mby1ob2xkZXJzLWFpcmRyb3AuY29tXCIsXG4gICAgXCJpbmZvLWhvbGRlcnMtYWlyZHJvcC5jb21cIixcbiAgICBcInhuLS1teGVyLXFwYS5tb25leVwiLFxuICAgIFwiaGFydmVzdGZpbmFuY2UuYXBwXCIsXG4gICAgXCJldmVudHZiLmNvbVwiLFxuICAgIFwiZXRoZXJnaWZ0LnVzXCIsXG4gICAgXCJteWVudG5oZXJiYWxsZXQuY29tXCIsXG4gICAgXCJnZW1pbmlib251cy51c1wiLFxuICAgIFwibXVzazIwMjEudXNcIixcbiAgICBcImV0aGdpZnQudXNcIixcbiAgICBcImNhcmRhbm9naWZ0LnVzXCIsXG4gICAgXCJldGgtYWlyZHJvcC11bmlzd2FwLm9yZ1wiLFxuICAgIFwiYnRjaGF6ZS5jb21cIixcbiAgICBcIm11c2stZ2l2ZS51c1wiLFxuICAgIFwiZ2VtaW5pLWxhbmRlcjIuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJnZW1pbi1wYXltZW50cy5ibG9nc3BvdC5jb21cIixcbiAgICBcIm1ldGFtYXNrY29ubmVjdC5uZXRcIixcbiAgICBcImFpcmRyb3AtZ2VtaW5pLmJsb2dzcG90LmNvbVwiLFxuICAgIFwicGF5Z2VtaW5pLmJsb2dzcG90LmNvbVwiLFxuICAgIFwibG9yZWJ0Yy5jb21cIixcbiAgICBcIm11c2stcHJvbW8ubmV0XCIsXG4gICAgXCJtdXNrLWRvbmF0ZXMuY29tXCIsXG4gICAgXCJlbG9uLWxhbmRpbmctcHJpemUuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJlbG9uLWJ0Yy1wcml6ZS5ibG9nc3BvdC5jb21cIixcbiAgICBcImVsb24tcHJpemUtZXRoLmJsb2dzcG90LmNvbVwiLFxuICAgIFwieG4tLXdhbGx0Y29ubmVjdC1lZWIub3JnXCIsXG4gICAgXCJnZW1pbmktZ2l2ZS5jb21cIixcbiAgICBcIjJmYS12ZXJpZnkuY29tXCIsXG4gICAgXCJ0cm9uLWdhc3NpLmNvbVwiLFxuICAgIFwidHJ1c3QtZWJvb2suY29tXCIsXG4gICAgXCJwcm9zLWNvaW5vbWkuY29tXCIsXG4gICAgXCJ3aW5rbGV2b3NzLWFpcmRyb3AuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJnZW1pbmktZ2l2ZWF3YXktYnRjLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiaW5mby10b2tlbnMtYWlyZHJvcC5jb21cIixcbiAgICBcImFwcC51bmlzd2FwLmluZm8tdG9rZW5zLWFpcmRyb3AuY29tXCIsXG4gICAgXCJnZW1pbWl4eC5jb21cIixcbiAgICBcImFpcmRyb3BzLXVuaXN3YXAub3JnXCIsXG4gICAgXCJldGhidGNyZWxlYXNlLmNvbVwiLFxuICAgIFwib25saW5lLm1ldGFtYXNsay5jb21cIixcbiAgICBcInNvbGl0YWlyZW5ldHdvcmsuY29tXCIsXG4gICAgXCJ3aW5rbGV2b3NzLWV2ZW50cy5ibG9nc3BvdC5jb21cIixcbiAgICBcImp1c3RpbnN1bi5jZW9cIixcbiAgICBcInVuaXN3YXAtYWlkcm9wLmluZm9cIixcbiAgICBcIm1hc2twbWV0YS5jb21cIixcbiAgICBcImFpcmRyb3Atb2ZmaWNpYWwtdW5pc3dhcC5vcmdcIixcbiAgICBcImV4c2hlbmdlZS5jb21cIixcbiAgICBcInRyZXpvci1pby5jb21cIixcbiAgICBcImFpcmRyb3AtdW5pc3dhcC5pbmZvXCIsXG4gICAgXCJ1bmlzd2FwdXNlci5jb21cIixcbiAgICBcInNlY3VyZWNyeXB0b3dhbGxldC5hcHBcIixcbiAgICBcImdlbWluaS1haXJkcm9wLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZ2VtaW5pLXBheS5ibG9nc3BvdC5jb21cIixcbiAgICBcInVuaXN3YXAtaWNvLmNvbVwiLFxuICAgIFwiYWlyZHJvcC1sb29wcmluZy5pb1wiLFxuICAgIFwieG4tLXRyZW9yLTdoYi5pb1wiLFxuICAgIFwic3RlbGxhci5vcmcucm9cIixcbiAgICBcInN0ZWxsYXItdGVybS5jb21cIixcbiAgICBcInRvLXN0ZWxsYXIub3JnXCIsXG4gICAgXCJ5ZWFuci5maW5hbmNlXCIsXG4gICAgXCJldGgtYWlyZHJvcC5pb1wiLFxuICAgIFwidHJlem9yLnhuLS13bGxldC10Y2MuY29tXCIsXG4gICAgXCJ0cmV6b3ItaGFyZHdhcmUtd2FsbGV0LnJla2xhbWEtYWRzLmNvbVwiLFxuICAgIFwidHJlem9yLWhhcmR3YXJlLnJla2xhbWEtYWRzLmNvbVwiLFxuICAgIFwiY2xhaW0tYWlyZHJvcC11bmlzd2FwLm9yZ1wiLFxuICAgIFwid3d3LmFwcC51bmlzd2FwLm9yZy1jbGFpbS1haXJkcm9wLmNvbVwiLFxuICAgIFwiYXBwLXVuaXN3YXAub3JnLXYzLnNpdGVcIixcbiAgICBcImNycnlwdG9kMzQyMy5ibG9nc3BvdC5jb21cIixcbiAgICBcInVuaXN3YXBiYWxhbmNlLmNvbVwiLFxuICAgIFwiZXRoZXJldW1naWZ0LnVzXCIsXG4gICAgXCJ1bmlzd2Fwc2hhcmUuY29tXCIsXG4gICAgXCJnZW1pbmktZ2lmdHMtMjAyMS5ibG9nc3BvdC5jb21cIixcbiAgICBcImdlbWluaXBheW1lbnRzMi5ibG9nc3BvdC5jb21cIixcbiAgICBcImVsb24tZnJlZS5mdW5kXCIsXG4gICAgXCJzdGVsbGFyLm9yZy5tdVwiLFxuICAgIFwiYWNjb3VudHZpZXdlci5zdGVsbGFyLm9yZy5tdVwiLFxuICAgIFwibG9naW4tbWV0YW1hc2suaW9cIixcbiAgICBcImJpdGNvaW5vbmxpbmVwb29sLmNvbVwiLFxuICAgIFwiZXRoZXJhaXJkcm9wLmlvXCIsXG4gICAgXCJpbnRlZ3JhdGlvbndhbGxldC5jb21cIixcbiAgICBcInhycGhlcmUuY29tXCIsXG4gICAgXCJvbnhzd2FwLm9ubGluZVwiLFxuICAgIFwiemlsbGlxYS5jZlwiLFxuICAgIFwicGxhdGZvcm0yMDIxLjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJhcHAudjItdW5pc3dhcC5vcmdcIixcbiAgICBcInYyLXVuaXN3YXAub3JnXCIsXG4gICAgXCJpbmZvLXVuaXN3YXAub3JnXCIsXG4gICAgXCJteWFwcC5meWlcIixcbiAgICBcImJhbGFuY2VyYy5leGNoYW5nZVwiLFxuICAgIFwiY29tcG91bmQuZnlpXCIsXG4gICAgXCJjdXJ2ZS5vbmxcIixcbiAgICBcImN1cnJ2ZS5vcmdcIixcbiAgICBcImFwcC1hYXZlLm9yZ1wiLFxuICAgIFwiYnRjZmF6ZS5jb21cIixcbiAgICBcImdlbWluaS1naXZlYXdheXMyLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZzM0Z2VyZmdlMzMuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJtZXRhMXllYXJuMi5ibG9nc3BvdC5jb21cIixcbiAgICBcImdlbWluaXBheW1lbnRzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwibXVzazIwMjEub3JnXCIsXG4gICAgXCJtdXNrLWZyZWUuY29tXCIsXG4gICAgXCJ0ZXNsYS1wcm9tby5vcmdcIixcbiAgICBcIm11c2stY3J5cHRvLmZ1bmRcIixcbiAgICBcImJvbGFuY2VyLmV4Y2hhbmdlXCIsXG4gICAgXCJib2xhbmNlci5pbmZvXCIsXG4gICAgXCJ3YXZlLWFpcmRyb3AubGl2ZVwiLFxuICAgIFwiY29ubmVjdGlvbmxpdmV3YWxsZXQuaW9cIixcbiAgICBcImNvaW5nY2Nrby5jb21cIixcbiAgICBcImp4eGxsLmZ1blwiLFxuICAgIFwibGliZXJ0eWpheHgubGl2ZVwiLFxuICAgIFwiYnJhbmNoLXRydXN0LXdhbGxldC4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwib3JnLWFwcGNvbm5lY3QuY29tXCIsXG4gICAgXCJpby11cGRhdGUuY29tXCIsXG4gICAgXCJsaXF1aWRpdHktcG9vbC11bmlzd2FwLm9yZ1wiLFxuICAgIFwiYXBwLmxpcXVpZGl0eS1wb29sLXVuaXN3YXAub3JnXCIsXG4gICAgXCJnZW1pbmktZ2l2ZWF3YXlzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZ2VtaW5pcGF5bWV3bnQuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJsZWRnZXItdXBkYXRlcy5jb21cIixcbiAgICBcInBvbGthZG90LWFpcmRyb3AubGl2ZVwiLFxuICAgIFwid2FsbGV0LWNvbm5lY3QubmV0XCIsXG4gICAgXCJ3YWxsZXQtY29ubmVjdC5vcmdcIixcbiAgICBcInhuLS1zdGVsbHItbXRhLmNvbVwiLFxuICAgIFwidG9rZW5zLWFpcmRyb3AtaG9sZGVycy5jb21cIixcbiAgICBcImFwcC51bmlzd2FwLnRva2Vucy1haXJkcm9wLWhvbGRlcnMuY29tXCIsXG4gICAgXCJjcnlwdGZ1bmR6LmNvbVwiLFxuICAgIFwidGV0aGVyLXVzZHQtbWl4ZXIuY29tXCIsXG4gICAgXCJhbm9ueW1vdXMtdGV0aGVyLW1peGVyLmNvbVwiLFxuICAgIFwiZXRoZXJldW1zLW1peGVyLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tbWl4ZXIuY29tXCIsXG4gICAgXCJ0aGV0YW1haW50b2tlbi5vbmxpbmVcIixcbiAgICBcInN3YXAtdW5pc3dhcC5vcmdcIixcbiAgICBcImlvbG9naW4ub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbWltLm9yZ1wiLFxuICAgIFwibXVzay1ldmVudC5vcmdcIixcbiAgICBcImVsb24tY3J5cHRvLmZ1bmRcIixcbiAgICBcImJpdGN1cGNvaW5zLmNvbVwiLFxuICAgIFwieG4tLXN0bGxhci00dWEuY29tXCIsXG4gICAgXCJtYWlsc3J2LXN0ZWxsYXIuY29tXCIsXG4gICAgXCJ4bi0tc3RsbGFyLWN2YS5jb21cIixcbiAgICBcInJpcHBsZS5jb20ubHZcIixcbiAgICBcImluLXJpcHBsZS5jb21cIixcbiAgICBcInMzLXN0ZWxsYXIub3JnXCIsXG4gICAgXCJteWJjLWZ1bmRzLnR1bWJsci5jb21cIixcbiAgICBcIm15YnQuZ2FcIixcbiAgICBcIm15YmkuZ2FcIixcbiAgICBcInVuaXN3YXBob2xkLmNvbVwiLFxuICAgIFwiZWxvbi1mb3VuZC50dW1ibHIuY29tXCIsXG4gICAgXCJjb2l4LmdhXCIsXG4gICAgXCJwYXl0b3BheWV0aHgudHVtYmxyLmNvbVwiLFxuICAgIFwicGF5dG9wYXlidGN4LnR1bWJsci5jb21cIixcbiAgICBcImJhbmNvcmEubmV0d29ya1wiLFxuICAgIFwidW5pc3dhcC1jcnlwdG8uY29tXCIsXG4gICAgXCJ1bmlzd2FwLWRlZmkuY29tXCIsXG4gICAgXCJ1bmlzd2FwYWlyZHJvcC5vcmdcIixcbiAgICBcInVwZGF0ZXVuaXN3YXAuY29tXCIsXG4gICAgXCJtdXNrZHJvcC5saWZlXCIsXG4gICAgXCJiaXRjb2luZm9jdXMueHl6XCIsXG4gICAgXCJlcGF5bWVudGJ0Yy50dW1ibHIuY29tXCIsXG4gICAgXCJlcGF5bWVudGV0aC50dW1ibHIuY29tXCIsXG4gICAgXCJjaHJpc3RtYXNiaXQudHVtYmxyLmNvbVwiLFxuICAgIFwiYml0bi5nYVwiLFxuICAgIFwiZWxvbnJld2FyZC5pbmZvXCIsXG4gICAgXCJsb2dpbi1hY2NvdW50LmFwcFwiLFxuICAgIFwibmV4dXNtdXR1YWwub3JnXCIsXG4gICAgXCJ5ZWFybmFwcC5maW5hbmNlXCIsXG4gICAgXCJjcnlwdG8tY29tLmFwcFwiLFxuICAgIFwiZXRoZ2l2ZXMuY29tXCIsXG4gICAgXCJhYXZlYXBwLm5ldFwiLFxuICAgIFwia3liZXJhcHAubmV0d29ya1wiLFxuICAgIFwic3VzaGlzd2FwY2xhc3NpYy5hcHBcIixcbiAgICBcIm1hc2ttZXhhLmNvbVwiLFxuICAgIFwibWV0ZW1hc2suaW9cIixcbiAgICBcIm1hc2ttZWlhLnh5elwiLFxuICAgIFwibWV0bWFzay5jb21cIixcbiAgICBcInVuaXN3YXBwcy5jb21cIixcbiAgICBcImV0aGdpdmUub3JnXCIsXG4gICAgXCJlbG9uZ2l2ZS51c1wiLFxuICAgIFwidW5paXN3YWFwLm9yZ1wiLFxuICAgIFwiY2FyZGFubzIwMjEudXNcIixcbiAgICBcIm5ld2xlZGdlcndlYi5jb21cIixcbiAgICBcInVuaXN3YXB1cGRhdGUuY29tXCIsXG4gICAgXCJsaXZlLXRlc2xhLmNvbVwiLFxuICAgIFwiZWxvbi5mdW5kXCIsXG4gICAgXCJsZWRnZXItY2hhaW4uY28udWtcIixcbiAgICBcIjFpbmNoLmRldlwiLFxuICAgIFwidW5pc3dhcHNpdGUuY29tXCIsXG4gICAgXCJtZXRhbWFzay1vbmxpbmUtaW8uY29tXCIsXG4gICAgXCJtYXNrbWV0YWEuaW9cIixcbiAgICBcIm1vb25pc3dhcC5hcHBcIixcbiAgICBcIjFpbmNoLWV4Y2hhbmdlLmNvbVwiLFxuICAgIFwiZnVuZG11c2suY29tXCIsXG4gICAgXCJiaW5hbi5pblwiLFxuICAgIFwiYmluYW5jZXR3aXR0ZXIuY29tXCIsXG4gICAgXCJleHRlbnNpb25zbWV0YS5jb21cIixcbiAgICBcImxpdmUtc3BhY2V4LmNvbVwiLFxuICAgIFwibWV0YW1hc2t3ZWIuY29tXCIsXG4gICAgXCIxaW5jaC5hcHBcIixcbiAgICBcIm1hc2ttZXRhLm1lXCIsXG4gICAgXCJtYXNrbWV0YS5vcmdcIixcbiAgICBcIm1ldGFtYXNrd2FsbGV0Lm5ldFwiLFxuICAgIFwibWFza21lcmEuaW9cIixcbiAgICBcImluc3RhbGxtZXRhbWFzay5vcmdcIixcbiAgICBcIm1hc2ttZXRhLm5ldFwiLFxuICAgIFwibWFza21ldGEuYml6XCIsXG4gICAgXCJzbG9semZyLmNvbVwiLFxuICAgIFwieHJwLmxpbWl0ZWRcIixcbiAgICBcInJpcHBsZS5wcm9tb1wiLFxuICAgIFwiYml0dHF1ZS5jb21cIixcbiAgICBcImxldG1lY3J5cHRvLmNvbVwiLFxuICAgIFwieG4tLWxlY3RydW0tczhhLm9yZ1wiLFxuICAgIFwiY29pbmdlY2tvLnByb1wiLFxuICAgIFwib3JjLWdldC1hY2Nlc3MuY29tXCIsXG4gICAgXCJ1bmlzd2FwLm9yYy1nZXQtYWNjZXNzLmNvbVwiLFxuICAgIFwibWV0YW1zay5pb1wiLFxuICAgIFwiY2hyb21lLWV4dGVuc2lvbi5pY3VcIixcbiAgICBcImJpbmFuY2UyMDIxLmNvbVwiLFxuICAgIFwiczEtcmlwcGxlLmNvbVwiLFxuICAgIFwicmlwcGxlLmNvbS5zb1wiLFxuICAgIFwibXVza3gub25saW5lXCIsXG4gICAgXCJtZXRhbWFzay5vbmxpbmVcIixcbiAgICBcIm1hcmstZGlyZWN0LmNvbVwiLFxuICAgIFwidHJ1c3QtbXlmb29kLmNvbVwiLFxuICAgIFwiZW5qaW4tYm9va3MuY29tXCIsXG4gICAgXCJicmlnYWR0ZWNobmljLmNvbVwiLFxuICAgIFwic2VjdXJlLWJldGEuY29tXCIsXG4gICAgXCJibG9ja2NoYWluc3VwcG9ydC5uZXR3b3JrXCIsXG4gICAgXCJnaXZlLWNyeXB0by5zMy11cy13ZXN0LTIuYW1hem9uYXdzLmNvbVwiLFxuICAgIFwibXlldGVyaHdhbGxldC5jb21cIixcbiAgICBcImV0aGVydW5pc3dhcC5jb21cIixcbiAgICBcInVuaXN3YXAtYm9udXMuY29tXCIsXG4gICAgXCIyNDdjcnlwdG90cmFkZS5vbmxpbmVcIixcbiAgICBcIm1ldGFtYXNrYXBwLmNvbVwiLFxuICAgIFwid2FsbGV0Y29ubmVjdC5pbmZvXCIsXG4gICAgXCJpbnN0YWxsLW1ldGFtYXNrLWlvLmNvbVwiLFxuICAgIFwibWV0YW1hc2tzdGFydC1pby5jb21cIixcbiAgICBcImFzdGFsbG1ldGFtYXNrLmNvbVwiLFxuICAgIFwibWFza21ldGEueHl6XCIsXG4gICAgXCJyaXBwbGUtbGFicy5kZXZcIixcbiAgICBcIndpbmtsZXZvc3MtZ2VtaW5pLmNvbVwiLFxuICAgIFwieHJwMjAyMS5uZXRcIixcbiAgICBcImV0aHVuaXN3YXAuY29tXCIsXG4gICAgXCJzdXNoaXN3YXBjb2luLmNvbVwiLFxuICAgIFwibGVkZ2VybGl2ZS5pb1wiLFxuICAgIFwicmlwcGxlMjAyMS5jb21cIixcbiAgICBcInJlZ2lzdGVyLXJpcHBsZS5jb21cIixcbiAgICBcInN0ZWxsYXJ3YWxsZXQub3JnXCIsXG4gICAgXCJzdGVsbGFyd2FsbGV0Lm5ldFwiLFxuICAgIFwic3RlbGxhcndhbGxldC5pblwiLFxuICAgIFwieG4tLXN0ZWxhci16Y2Iub3JnXCIsXG4gICAgXCJjbGFpbXhsbS5jb21cIixcbiAgICBcInhuLS1zdGVsYXIteWNiLm9yZ1wiLFxuICAgIFwiYnRjcHJvbWluZXIubGlmZVwiLFxuICAgIFwibWFya2V0cGxhY2UtYXhpZWluZmluaXR5LmNvbVwiLFxuICAgIFwiYmxvZy1yaXBwbGUuY29tXCIsXG4gICAgXCJ4bi0tc3RlbGxyLTd6YS5vcmdcIixcbiAgICBcInN0ZWxsYXJjbGFpbS5vcmdcIixcbiAgICBcInVuaWRyb3AucHJvXCIsXG4gICAgXCJmdW5kLWdlbWluaS5uZXRcIixcbiAgICBcInhuLS1ycHBsZS1jdGEuY29tXCIsXG4gICAgXCJ1bmlwcm9tby5hcHBcIixcbiAgICBcImluc3RhbGxtZXRhbWFzay5jb21cIixcbiAgICBcImtheWFydWdzLmNvbVwiLFxuICAgIFwibWV0YW1hc2suaXNcIixcbiAgICBcImNoYXJsZXMtaG9za2luc29uLmxpdmVcIixcbiAgICBcInVuaXN3YXBkcm9wLmZpbmFuY2VcIixcbiAgICBcInVuaXN3YXAtYWlyZHJvcC5pb1wiLFxuICAgIFwiODhtcGguYXBwLmRlZmktdW5pdmVyc2UudmlwXCIsXG4gICAgXCJheGllaW5maW5pdHkuY29tLmFhdmUuZGVmaS11bml2ZXJzZS52aXBcIixcbiAgICBcImFhdmVhcHAuY29tXCIsXG4gICAgXCJyaXBwbGUteHJwLmxpdmVcIixcbiAgICBcImRyb3BiaW5hbmNlLmV4Y2hhbmdlXCIsXG4gICAgXCJiaXRob21wLndvcmtcIixcbiAgICBcInJpcHBsZWJvbnVzLnVzXCIsXG4gICAgXCJsaXRlY29pbi1ldmVudC5uZXRcIixcbiAgICBcImJ0Y21pbmVyYXBwLmNvbVwiLFxuICAgIFwidGhlYmlnZGVhbC5jbGlja2Z1bm5lbHMuY29tXCIsXG4gICAgXCJlYXN5cmlwcGxlLmNsYWltc1wiLFxuICAgIFwieHJwLWZ1bmQubGl2ZVwiLFxuICAgIFwiY29pbmJhc2VldGgub3JnXCIsXG4gICAgXCJnZW1pbmlzc3BheW1lbnRzZC5ibG9nc3BvdC5jb21cIixcbiAgICBcImVvc2F1dGhvcml0eS5saW5rXCIsXG4gICAgXCJ6aWxsZXQubmV0XCIsXG4gICAgXCJjb3Ntb3N0YXRpb24ubmV0d29ya1wiLFxuICAgIFwid2FsbGV0LmNvc21vc3RhdGlvbi5uZXR3b3JrXCIsXG4gICAgXCJyaXBwbGUtc3BhcmsuaW5mb1wiLFxuICAgIFwiaW5zdGFsbG1ldGEuY29tXCIsXG4gICAgXCJtYXNrbWVoYS5pb1wiLFxuICAgIFwiY2hhaW5saW5rLmNsaWNrXCIsXG4gICAgXCJ1bmktcmVkaXJlY3RzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYWZpbi1hcHAuY29tXCIsXG4gICAgXCJteW1vbmVyby5jb1wiLFxuICAgIFwid2FsbGV0Lm15bW9uZXJvLmNvXCIsXG4gICAgXCJjb2luYXJiaXRyYWRlLmNvbVwiLFxuICAgIFwiYml0Y29pbnRyYWRlci50cmNrb2ZmZXJzLnh5elwiLFxuICAgIFwicmlwcGxlLXhycC5tZVwiLFxuICAgIFwiYWNjb3VudHRzLWJpbmFuY2UuY29tXCIsXG4gICAgXCJ4bi0tbGdkZXItNnphLmNvbVwiLFxuICAgIFwibGVkZ2VyLWxpdmUuaW9cIixcbiAgICBcImNocm9tZS1leHRlbnNpb24uaW5mb1wiLFxuICAgIFwidGFrZWJ0Yy5uZXRcIixcbiAgICBcImJpdGNvaW4tcmV2b2x1dGlvbjIuY2FzaHZvbHVtZS5tb25zdGVyXCIsXG4gICAgXCJidGMtZ2VtaW5pLmxpdmVcIixcbiAgICBcInZlcmlmeWFjY291bnRzLmlvXCIsXG4gICAgXCJwYXlwYWwtYnRjLmNvbVwiLFxuICAgIFwiY2xhaW0tYWlyZHJvcC11bmlzd2FwLXYyLmluZm9cIixcbiAgICBcImFwcC51bmlzd2FwLmNsYWltLWFpcmRyb3AtdW5pc3dhcC12Mi5pbmZvXCIsXG4gICAgXCJsb2dpbi1ibG9ja2xuYWluLnRvcFwiLFxuICAgIFwidW5pc3dhcHMuYXBwXCIsXG4gICAgXCJtZXRhbWFza3dhbGxldC5vbmxpbmVcIixcbiAgICBcIm1ha2VyZGFvLWluZm8uY29tXCIsXG4gICAgXCJ5ZmlnZXQub3JnXCIsXG4gICAgXCJwYXlwYWxidGMub3JnXCIsXG4gICAgXCJ1ZmliaXQuY29tXCIsXG4gICAgXCJ1ZHJvcC5maW5hbmNlXCIsXG4gICAgXCJ4cnAtcmV3YXJkLm9yZ1wiLFxuICAgIFwiZ2VtaW5pLnNvY2lhbFwiLFxuICAgIFwidW5pZ2l2ZS5uZXRcIixcbiAgICBcImV0aGVyLWdpdmUuY2VvXCIsXG4gICAgXCJ1bmlwcm9tb3Rpb24ubmV0XCIsXG4gICAgXCJ3b29kZnVuZC5pbmZvXCIsXG4gICAgXCJjZWxpc3dhcC5jb21cIixcbiAgICBcImxlZGdlcndlYi5kaWdpdGFsXCIsXG4gICAgXCJsaXRlY29pbmdpdmVhd2F5LWxpdmUuY29tXCIsXG4gICAgXCJ5ZmlhaXJkcm9wLmNvbVwiLFxuICAgIFwiZXRoNjYuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJiaXRmdXJ5bHRkLmNvbVwiLFxuICAgIFwiYml0ZnVyeWdyb3VwbHRkLmNvbVwiLFxuICAgIFwiZXRocG9zLm9yZ1wiLFxuICAgIFwiZ2VtaW5pZ2lmdC5vcmdcIixcbiAgICBcImJpdGNvaW4tcmV2b2x1dGlvbi4yMDIwLW9yZGVyLm1vbnN0ZXJcIixcbiAgICBcImJpdGNvaW4tcmV2b2x1dGlvbi5pbmVzdG92bzIwMjAueHl6XCIsXG4gICAgXCJiaXRjb2luLXJldm9sdXRpb24ub255eHRyYWRlLm1vbnN0ZXJcIixcbiAgICBcImV4b2R1cy5jYXNhXCIsXG4gICAgXCJ0ZXNsYS1idGMuaW5mb1wiLFxuICAgIFwibXVzay1naXZpbmcuY29tXCIsXG4gICAgXCJjb2luYmFzZTJ4Lm9ubGluZVwiLFxuICAgIFwidW5pLXRva2VuLmNvbVwiLFxuICAgIFwieGV0aDIuZ2l0aHViLmlvXCIsXG4gICAgXCJzdGVsbGFyLm9yZy5tYVwiLFxuICAgIFwiYWNjb3VudHZpZXdlci5zdGVsbGFyLm9yZy5tYVwiLFxuICAgIFwic3BlY2lhbGdpZnQxMjIuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJicm93c2VybWFzay5vcmdcIixcbiAgICBcInByb2ZpdC1ib29zdGVyLnh5elwiLFxuICAgIFwiY3J5cHRvLWdpdmVzLnMzLnVzLWVhc3QtMi5hbWF6b25hd3MuY29tXCIsXG4gICAgXCJvbmtiaXQuY29tXCIsXG4gICAgXCJyaXBwbGUuY29tLnB0XCIsXG4gICAgXCJjb2luYmFzZS1wYXltZW50cy5ibG9nc3BvdC5jb21cIixcbiAgICBcInBsY2tsZS5maW5hbmNlXCIsXG4gICAgXCJwaWNrbGVlLmZpbmFuY2VcIixcbiAgICBcInRva2VucG9ja2V0LXByby53ZWIuYXBwXCIsXG4gICAgXCJtZXRhYnJvd3Nlci5vcmdcIixcbiAgICBcImNvaW56b3IuY29tXCIsXG4gICAgXCJ3YWxsZXRleG9kdXMuY29tXCIsXG4gICAgXCJjb2ludm96LmNvbVwiLFxuICAgIFwiY29pbnJvei5jb21cIixcbiAgICBcIndvemJpdC5jb21cIixcbiAgICBcInllYXJuLWZpbmFuY2UtZ2lmdC5tZWRpdW0uY29tXCIsXG4gICAgXCJ5ZWFybnlmaS5ibG9nc3BvdC5jb21cIixcbiAgICBcImNsYWltb2NlYW4uY29tXCIsXG4gICAgXCJtYXRpY3dhbGxldC5uZXR3b3JrXCIsXG4gICAgXCIyZXRoLnNpdGVcIixcbiAgICBcInlmbGlua3Jld2FyZC5jb21cIixcbiAgICBcInBvbGthZG90LWFpcmRyb3AuaW5mb1wiLFxuICAgIFwiZXRoLWJ1dC50b3BcIixcbiAgICBcImV0aGJ1dGVyaW4udG9wXCIsXG4gICAgXCJldGhlci1iZXN0LnRvcFwiLFxuICAgIFwiZXRoZXItbG92ZS50b3BcIixcbiAgICBcImV0aHgtYnV0ZXJpbngudG9wXCIsXG4gICAgXCJlbG9ubXVza3hwcm8uY29tXCIsXG4gICAgXCJjbGFpbXVuaS5jb21cIixcbiAgICBcIngyY3J5cHRzLmNvbVwiLFxuICAgIFwibHRjbWluZXIuY29tXCIsXG4gICAgXCJtZXRhc3dhcC5kZXZcIixcbiAgICBcImV0aC1mb3VuZC5saXZlXCIsXG4gICAgXCJ1bmlzd2FwLmJpZFwiLFxuICAgIFwiYXBwLnVuaXN3YXAuYmlkXCIsXG4gICAgXCJjdXJ2ZS5ydW5cIixcbiAgICBcIm1vei1leHRlbnNpb24ubGlua1wiLFxuICAgIFwiYXBwLnVuaXN3YXAud3NcIixcbiAgICBcInVuaXN3YXAud3NcIixcbiAgICBcImRyb3BtdXNrLmluXCIsXG4gICAgXCJjaHJvbWUtZXh0ZW5zaW9uLmxpbmtcIixcbiAgICBcIm1vbmV5LXRlc2xhLmNvbVwiLFxuICAgIFwiYWlyZHJvcC11bmlzd2FwLmNvbVwiLFxuICAgIFwibWV0YW1hcy5pb1wiLFxuICAgIFwib2NlYW5haXJkcm9wLmluZm9cIixcbiAgICBcImV0aC1nZW5lcmF0b3IuY29tXCIsXG4gICAgXCJ0ZXRoZXItdHVtYmxlci5jb21cIixcbiAgICBcInVuaS1wcm9tby5uZXRcIixcbiAgICBcInN0ZWxsYXItaW5mby5vcmdcIixcbiAgICBcInN0YWtlLWV0aGVyZXVtLm9yZ1wiLFxuICAgIFwiZXRoNjcuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJhaXJkcm9wLW9jZWFuLmNvbVwiLFxuICAgIFwibXVzay1jb2lucy5jb21cIixcbiAgICBcIm11c2twcml6ZS5mdW5cIixcbiAgICBcImdldG11c2suZnVuXCIsXG4gICAgXCJzcGFjZXhsaXZlLnRvcFwiLFxuICAgIFwiZWxvbmJ0Y3guY29tXCIsXG4gICAgXCJjaGFpbi1sZWRnZXIuaW5mb1wiLFxuICAgIFwibGVkZ2VyLWNoYWluLmxpdmVcIixcbiAgICBcInhuLS1sZWRnci0yNTFiLmNvbVwiLFxuICAgIFwieG4tLXJwcGxlLW40YS5uZXRcIixcbiAgICBcImNsYWltLXJpcHBsZS5jb21cIixcbiAgICBcIm1ldGFtYXNrLm9yZy1zd2FwLmFwcFwiLFxuICAgIFwib3JnLXN3YXAuYXBwXCIsXG4gICAgXCJhaXJkcm9wb2NlYW4uY29tXCIsXG4gICAgXCJvY2Vhbi1haXJkcm9wLmNvbVwiLFxuICAgIFwiYmVzdGNoZWluZ2UuY29tXCIsXG4gICAgXCJsYmVzdGNoZW5nZS5jb21cIixcbiAgICBcInVuaS1haXJkcm9wLmluZm9cIixcbiAgICBcInppbGxldC5pbmZvXCIsXG4gICAgXCJ1bmlzd2FwYWlyZHJvcC5pbmZvXCIsXG4gICAgXCJ1bmlzd2Fwb2ZmaWNpYWwuY29tXCIsXG4gICAgXCJiaXRjb2lucy1naWZ0LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRoLWdpZnQuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJtZXRhbWFzay5ib251cy1lcmMyMC10b2tlbi5pbmZvXCIsXG4gICAgXCJkaWNlMndpbi5jb1wiLFxuICAgIFwiYm9udXMtZXJjMjAtdG9rZW4uaW5mb1wiLFxuICAgIFwieXJlYW4uZmluYW5jZVwiLFxuICAgIFwibGl2ZS5sZWRnZXJvcmlnaW4uY29tXCIsXG4gICAgXCJsZWRnZXJvcmlnaW4uY29tXCIsXG4gICAgXCJsZWRnZXIuY29tLWNsaWVudC5lbWFpbFwiLFxuICAgIFwieG4tLWxlZGdyLXE1MWIuY29tXCIsXG4gICAgXCJrZWVwa2V5LmFwcFwiLFxuICAgIFwiZXRoZ2l2ZWF3YXlzLm1lXCIsXG4gICAgXCJldGh4Mi5pb1wiLFxuICAgIFwibGVkZ2VyLnJlcG9ydFwiLFxuICAgIFwibGVkZ2VyLmJ1enpcIixcbiAgICBcInVzLWxlZGdlci5jb21cIixcbiAgICBcInVzYS1sZWRnZXIuY29tXCIsXG4gICAgXCJsZWRnZXIudXMub3JnXCIsXG4gICAgXCJsZWRnZXIudWsuY29tXCIsXG4gICAgXCJsZWRnZXIuZGVhbHNcIixcbiAgICBcImRlLWxlZGdlci5jb21cIixcbiAgICBcImZyLWxlZGdlci5jb21cIixcbiAgICBcIml0LWxlZGdlci5jb21cIixcbiAgICBcImF1LWxlZGdlci5jb21cIixcbiAgICBcIm5sLWxlZGdlci5jb21cIixcbiAgICBcImxlZGdlci5vcmcucGxcIixcbiAgICBcImxlZGdlcnN1cHBvcnQucHJvXCIsXG4gICAgXCJsZWRnZXJzdXBwb3J0Lm9ubGluZVwiLFxuICAgIFwibGVkZ2VyY29ubmVjdC5zdHJlYW1cIixcbiAgICBcImxlZGdlci1jaGFpbi5pbmZvXCIsXG4gICAgXCJjb25uZWN0bGVkZ2VyLmxpdmVcIixcbiAgICBcImxlZGdpci54eXpcIixcbiAgICBcImxlYnFlci54eXpcIixcbiAgICBcImxlZGdlci5jYW1cIixcbiAgICBcInhuLS1lZGdlci01NWEuY29tXCIsXG4gICAgXCJ4bi0tbGRnci12dmFjLmNvbVwiLFxuICAgIFwieG4tLWxkZ3ItbHU1YWMuY29tXCIsXG4gICAgXCJ4bi0tbGRnZXItNnphLmNvbVwiLFxuICAgIFwieG4tLWxlZGdlLTliYi5jb21cIixcbiAgICBcInhuLS1sZWRnZS14YmIuY29tXCIsXG4gICAgXCJ1bmlhaXJkcm9wLm9yZ1wiLFxuICAgIFwibGVkZ2VyLm1lZGlhXCIsXG4gICAgXCJ4bi0tbGRnZXItbjUxYi5jb21cIixcbiAgICBcImV0aDIwMjAudG9wXCIsXG4gICAgXCJ4cmlwcGxleC50dW1ibHIuY29tXCIsXG4gICAgXCJidGMtZ2lmdC5ibG9nc3BvdC5jb21cIixcbiAgICBcImNyeXB0b3ZpdGFsaWsuczMtdXMtd2VzdC0xLmFtYXpvbmF3cy5jb21cIixcbiAgICBcInJld2FyZHMtdG9rZW5zLWFpcmRyb3AuaW5mb1wiLFxuICAgIFwic2VsbGNyeXB0by50b3BcIixcbiAgICBcImV0aC51Z1wiLFxuICAgIFwib2xkbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcImdpZnQtZXRoLmluZm9cIixcbiAgICBcInJpcHBsZS51Z1wiLFxuICAgIFwibGVnZGVyLmNvbVwiLFxuICAgIFwiYnV0ZXJpbi5zMy5ldS13ZXN0LTIuYW1hem9uYXdzLmNvbVwiLFxuICAgIFwiZ2l2ZWF3YXlzdXNoaS5jb21cIixcbiAgICBcImxvZ2luLmJsb2NraGFsbi5jb21cIixcbiAgICBcImJsb2NraGFsbi5jb21cIixcbiAgICBcIndhbGxldHMtdGx4LWJsb2NrY2hhaW4uY29tXCIsXG4gICAgXCJwYXJhZGVmaS5uZXR3b3JrXCIsXG4gICAgXCJnZXQzMGJuYi5saXZlXCIsXG4gICAgXCJwZGZlc2NhcGUuc3VcIixcbiAgICBcInVuaXN3YXAub3JnLmNsYWltLXRva2Vucy1haXJkcm9wLmluZm9cIixcbiAgICBcImNsYWltLXRva2Vucy1haXJkcm9wLmluZm9cIixcbiAgICBcImFhdmVsZW5kLmNvbVwiLFxuICAgIFwiYWF2ZS1kZWZpLmNvbVwiLFxuICAgIFwiYXBwLnRyaWVhaGFyZGVyZXdhLmNvbVwiLFxuICAgIFwiYml0Y29pbm5vdy5iaWRcIixcbiAgICBcInN1c2hpc3dhcGNsYXNzbGMub3JnXCIsXG4gICAgXCJ4bi0tYnN0Y2hhbmdlLTAzYS5uZXRcIixcbiAgICBcImJpdGhhdS5jb21cIixcbiAgICBcImVsb25naWZ0LnMzLmV1LXdlc3QtMi5hbWF6b25hd3MuY29tXCIsXG4gICAgXCJiaXRuYXUuY29tXCIsXG4gICAgXCJ1bmlnaXYuY29tXCIsXG4gICAgXCJ0cnVzdHdhbGxldHRva2VuLmlvXCIsXG4gICAgXCJtZXRhbWFza3dhbGxldC5pb1wiLFxuICAgIFwieHJwLWdpdmVhd2F5LmJsb2dzcG90LmNvbVwiLFxuICAgIFwidW5pc3dhcC51Z1wiLFxuICAgIFwiYWNjb3VudHZpZXdlci5zdGVsbGFyLm9yZy5iaVwiLFxuICAgIFwic3RlbGxhci5vcmcuYmlcIixcbiAgICBcImRleHVuaXN3YXAub3JnXCIsXG4gICAgXCJldGhlcmV1bS51Z1wiLFxuICAgIFwidW5pc3dhcC1wYXBlci5zMy5ldS13ZXN0LTMuYW1hem9uYXdzLmNvbVwiLFxuICAgIFwiZXRoZXJldW1kb3dubG9hZHMuY29tXCIsXG4gICAgXCJnZXQtZ2V0aC5vcmdcIixcbiAgICBcImdldC1nZXRoLmNvbVwiLFxuICAgIFwid2lubmVyc2NyeXB0by5saXZlXCIsXG4gICAgXCJ1bmktZnVuZC5pbmZvXCIsXG4gICAgXCJyaXBwbGVib251cy5uZXRcIixcbiAgICBcImRleGFpcmRyb3AtYmluYW5jZS5jb21cIixcbiAgICBcImJ0Y2NoYW0uaW5mb1wiLFxuICAgIFwiZ2VtaW5peGZ1bmQuaW5mb1wiLFxuICAgIFwiZ2VtaW5pZHJvcC5mdW5kXCIsXG4gICAgXCJyaXBwbGVnaWZ0LmNlb1wiLFxuICAgIFwiYWRhLWdpdmUuaW5mb1wiLFxuICAgIFwieWVhcm0uZmluYW5jZVwiLFxuICAgIFwic3RlbGxhci5vcmcubmdcIixcbiAgICBcInN1c2hpYmFjay5jb21cIixcbiAgICBcInJpcHBsZS5zdXBwbHlcIixcbiAgICBcInppbGxldC5vcmdcIixcbiAgICBcImNoaWNvLWV0aGVycy5jb21cIixcbiAgICBcImxvZ2luLW1ldGFtYXNrLmNvbVwiLFxuICAgIFwiZXZlbnR1bmlzd2FwLmNvbVwiLFxuICAgIFwieHJwY2VvLmNvbVwiLFxuICAgIFwidmVjaGFpbmV2ZW50LmNvbVwiLFxuICAgIFwiZnJlZXVuaXN3YXAuY29tXCIsXG4gICAgXCIxMDAwMGV0aGdpdmVhd2F5LmNvbVwiLFxuICAgIFwiYmlwY2FsY3VsYXRvci5pb1wiLFxuICAgIFwidW5pc3dhcC1jbGFpbS5jb21cIixcbiAgICBcImdldC1zdGVsbGFyLmNvbVwiLFxuICAgIFwiemlsbGlxYS1saXZlLm9yZ1wiLFxuICAgIFwicnllYml0LmNvbVwiLFxuICAgIFwidW5pZ2l2ZWF3YXkubmV0XCIsXG4gICAgXCJzdGVsbGFyLm9yZy5pblwiLFxuICAgIFwiYWNjb3VudHZpZXdlci5zdGVsbGFyLm9yZy5pblwiLFxuICAgIFwiaW5mby1iaW5hbmNlLnVzXCIsXG4gICAgXCJteXVzLWFwcC5jb21cIixcbiAgICBcInVuaWdpdmVhd2F5Lm9yZ1wiLFxuICAgIFwibWV0YW1hc2suc2l0ZVwiLFxuICAgIFwidHJ1c3R3YWxsZXQuaW5cIixcbiAgICBcImV0aGVyc2Nhbi5tZW1iZXIuZXZlbnQubW9uZXNyZy5jb21cIixcbiAgICBcIm1vbmVzcmcuY29tXCIsXG4gICAgXCJtdXNrLWVsb24uY29cIixcbiAgICBcImFpci1kcm9wLnVzXCIsXG4gICAgXCJweWViaXQuY29tXCIsXG4gICAgXCJldGgtZm9uZC5pbmZvXCIsXG4gICAgXCJldGhnZXQudXNcIixcbiAgICBcInN5ZWJpdC5jb21cIixcbiAgICBcInVuaWdpdmVhd2F5LmNvbVwiLFxuICAgIFwiYWNjb3VudHZpZXdlci5zdGVsbGFyLm9yZy56YVwiLFxuICAgIFwic3RlbGxhci5vcmcuemFcIixcbiAgICBcInVuaS1kcm9wLm9yZ1wiLFxuICAgIFwidW4yYXBwLmNvbVwiLFxuICAgIFwiZnVuZC12ZWNoYWluLmNvbVwiLFxuICAgIFwiY2hpY28tZXRoLmNvbVwiLFxuICAgIFwiY3J5cHRvZ2Vuc2NyaXB0LmNvbVwiLFxuICAgIFwib2ZmaWNpYWx2YnV0ZXJpbi5jb21cIixcbiAgICBcInNwYWNleGZvdW5kYXRpb24uY29tXCIsXG4gICAgXCJhaXJkcm9wc3VzaGkuY29tXCIsXG4gICAgXCJ2aWZiaXQuY29tXCIsXG4gICAgXCJ6aWZiaXQuY29tXCIsXG4gICAgXCJyaWZiaXQuY29tXCIsXG4gICAgXCJzdXNoaWdpdmVhd2F5LmNvbVwiLFxuICAgIFwib21nLWFpcmRyb3AuaW9cIixcbiAgICBcIm11c2tidGN4LnRvcFwiLFxuICAgIFwiYmluYW5jZS1kZWZpLm5ldFwiLFxuICAgIFwiYmluYW5jZS1zbWFydC5jb21cIixcbiAgICBcInVuaWRyb3Aub3JnXCIsXG4gICAgXCJwb2xrYXdhbGxldHMuc2l0ZVwiLFxuICAgIFwidHJhZGVpbnRlbC5iaXpcIixcbiAgICBcInN1c2hpLWdpZnRzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwidmJldGguY29tXCIsXG4gICAgXCJ1bmlhaXJkcm9wLmNvbVwiLFxuICAgIFwiZnV0dXJlcy1iaW5hbmNlLmNvXCIsXG4gICAgXCJ1bmktZ2l2ZWF3YXkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJnZW5zY3JpcHRldGguZ28ueW8uZnJcIixcbiAgICBcImRpdWJpdC5jb21cIixcbiAgICBcInRlc2xhbWluaW5nLmx0ZFwiLFxuICAgIFwicml1Yml0LmNvbVwiLFxuICAgIFwiYnV0LXNlbmQudG9wXCIsXG4gICAgXCJldGgtbmV3cy5jb21cIixcbiAgICBcInN3ZXJ2ZS1maW5hbmNlLmNvbVwiLFxuICAgIFwiY3piaW5hbmNlLmNvXCIsXG4gICAgXCJjcnlwdG8yeHBvb2wuY29tXCIsXG4gICAgXCJzdXNoaXN3YXAuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJiaW5hbmNlLW1lZGl1bS5jb21cIixcbiAgICBcInJpcHBsZWJvbnVzLmV2ZW50c1wiLFxuICAgIFwieHJwLmNlb1wiLFxuICAgIFwiZ2FybGluZ2hvdXNlLmNlb1wiLFxuICAgIFwic3VzaGktZ2l2ZWF3YXkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJ5ZmktYWlyZHJvcHMuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJldGh2di5jb21cIixcbiAgICBcImV0aGVmLmNvbVwiLFxuICAgIFwiZXRoZXouY29tXCIsXG4gICAgXCJldGh0ZC5jb21cIixcbiAgICBcImV0aGRmLmNvbVwiLFxuICAgIFwidml0YWxpay5pb1wiLFxuICAgIFwiZXRoa2QuY29tXCIsXG4gICAgXCJldGhveS5jb21cIixcbiAgICBcImV0aGl5LmNvbVwiLFxuICAgIFwiZXRoZmMuY29tXCIsXG4gICAgXCJldGhmZi5jb21cIixcbiAgICBcImNyeXB0b25pbC5sdGRcIixcbiAgICBcImxlZGdlci5jb20uZGVcIixcbiAgICBcInJld2FyZHMtY29pbi4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwicmVuYWlyZHJvcC5jb21cIixcbiAgICBcInVuaXN3YXBub2RlLmNvbVwiLFxuICAgIFwiYXBwLnVuaXN3YXBub2RlLmNvbVwiLFxuICAgIFwiZHJvcC1ldGgub3JnXCIsXG4gICAgXCJqZGF4Lm1hcmtldFwiLFxuICAgIFwic3VwcG9ydGJuYi5jb21cIixcbiAgICBcImJpbi1jcnlwdG8uY29tXCIsXG4gICAgXCJleGlvZHVzLmNvbVwiLFxuICAgIFwiYmluYW5jZWZvdW5kLmNvbVwiLFxuICAgIFwibDFuY2guZXhjaGFuZ2VcIixcbiAgICBcImV4b2R1ei5pb1wiLFxuICAgIFwiZXhvZHVzLnNnXCIsXG4gICAgXCJleG9kdXMuY21cIixcbiAgICBcImF0b21pY3dsbGV0LmlvXCIsXG4gICAgXCJvbWlzZWdvYWlyZHJvcC5pbmZvXCIsXG4gICAgXCJzaXViaXQuY29tXCIsXG4gICAgXCJsaW5rY29pbmJvbnVzLmNvbVwiLFxuICAgIFwibGluay10b2tlbi5jb21cIixcbiAgICBcImdvYWlyZHJvcC5mdW5cIixcbiAgICBcImdvYWlyZHJvcC5wcm9cIixcbiAgICBcImV0aC1saW5rLnNpdGVcIixcbiAgICBcImFpcmRyb3AtbGlua2NoYWluLnNpdGVcIixcbiAgICBcImFpcmRyb3B3YWxsZXQucHJvXCIsXG4gICAgXCJhaXJkcm9wd2FsbGV0LnNpdGVcIixcbiAgICBcImFpcmRyb3AtbGlua2NoYWluLnByb1wiLFxuICAgIFwidG9rZW5saW5rLmluZm9cIixcbiAgICBcInRyZXpvci5jb20uc2VcIixcbiAgICBcInJlc3RvcmUtbGVkZ2VyLm9yZ1wiLFxuICAgIFwicmVzdG9yZS1sZWRnZXJ3YWxsZXQub3JnXCIsXG4gICAgXCJ3YWxsZXQucmVzdG9yZS1sZWRnZXIub3JnXCIsXG4gICAgXCJiaW5hbmNlLm9rdGFwbGF0Zm9ybS5jb21cIixcbiAgICBcInRydXN0c3dhcC1yZXdhcmRzLXByb2dyYW1zLWNsYWltcy10b2tlbnMuY29tXCIsXG4gICAgXCJmcmVlYml0Y29pbm1pbmluZy53ZWJzaXRlXCIsXG4gICAgXCJvbWduZXR3b3JrLmluZm9cIixcbiAgICBcImF0b21pY3dlYi5uZXR3b3JrXCIsXG4gICAgXCJ3YWxsZXQuYXRvbWljd2ViLm5ldHdvcmtcIixcbiAgICBcImV0aGZvLmNvbVwiLFxuICAgIFwidGV0aGVyLW1peGVyLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZWF3YXkubmV0d29ya1wiLFxuICAgIFwiY2hhaW5saW5rc2dpdmVhd2F5cy5ibG9nc3BvdC5jb21cIixcbiAgICBcInN0ZWxsYXJwYXkub3JnXCIsXG4gICAgXCJldGhidi5jb21cIixcbiAgICBcIm9mZmljaWFsdml0YWxpay5jb21cIixcbiAgICBcImNoYWlubGluay1naXZlYXdheS5ibG9nc3BvdC5jb21cIixcbiAgICBcInZpdGFsaWtiLnRvcFwiLFxuICAgIFwidml0YWxpa2JiLnRvcFwiLFxuICAgIFwiYXBwLnhuLS11bnN3cC02cWE1Zi5jb21cIixcbiAgICBcInhuLS11bnN3cC02cWE1Zi5jb21cIixcbiAgICBcImFwcC54bi0tdW5pc3dwLTB0YS5jb21cIixcbiAgICBcInhuLS11bmlzd3AtMHRhLmNvbVwiLFxuICAgIFwiYXBwLnhuLS1uc3dhcC0wdWE3MGIuY29tXCIsXG4gICAgXCJ4bi0tbnN3YXAtMHVhNzBiLmNvbVwiLFxuICAgIFwibW9ycGh0b2tlbi5jb1wiLFxuICAgIFwibGlicmFnbG9iYWxjb2luLmlvXCIsXG4gICAgXCJlbG9uMi50b3BcIixcbiAgICBcImxpdGVjb2lubWluZXIuc3BhY2VcIixcbiAgICBcImRvZ2Vjb2lubWluZXIuc3BhY2VcIixcbiAgICBcImV0aGVyZXVtbWluZXIuc3BhY2VcIixcbiAgICBcImJjaG1pbmVyLnNwYWNlXCIsXG4gICAgXCJkYXNoY29pbm1pbmVyLnNwYWNlXCIsXG4gICAgXCJidGNtaW5lci53ZWJzaXRlXCIsXG4gICAgXCJ0b3piaXQuY29tXCIsXG4gICAgXCJzdGVsbGFyLm9yZy5sdlwiLFxuICAgIFwidGVzbGEzLWJvbnVzLmNvbVwiLFxuICAgIFwiZGVmaS11bml2ZXJzZS52aXBcIixcbiAgICBcIm1hcmtldHBsYWNlLmF4aWVpbmZpbml0eS5jb20uaW52ZW50b3J5Y2xhaW0uZGVmaS11bml2ZXJzZS52aXBcIixcbiAgICBcImJyYWQtZ2lmdC5jb21cIixcbiAgICBcImNvaW5heGVsLmNvbVwiLFxuICAgIFwiZXRoLWRyb3AuY2x1YlwiLFxuICAgIFwidW5pc3dhcC1leGNoYW5nZS5jb21cIixcbiAgICBcImFwcC51bmlzd2FwLWV4Y2hhbmdlLmNvbVwiLFxuICAgIFwidW5pc3dhcC1leGNoYW5nZS5ldVwiLFxuICAgIFwiYXBwLnVuaXN3YXAtZXhjaGFuZ2UuZXVcIixcbiAgICBcImFwcHVuanN3YXAub3JnXCIsXG4gICAgXCJhcHB1bmlzd29wLmxpbmtcIixcbiAgICBcImV0aG9mZi5vcmdcIixcbiAgICBcImZ1bGNydW0ubnVcIixcbiAgICBcImV0aC5mdWxjcnVtLm51XCIsXG4gICAgXCJldGgtZ2l2ZWF3YXkudG9wXCIsXG4gICAgXCJ2aXQtZXRoeC50b3BcIixcbiAgICBcImV0aC12aXR5YS50b3BcIixcbiAgICBcImFpcmRyb3AtYml0LnRvcFwiLFxuICAgIFwiY3J5cHRvZ2lmdHMuczMuYW1hem9uYXdzLmNvbVwiLFxuICAgIFwieHJwLWV2ZW50LmNvbVwiLFxuICAgIFwiY3J5cHRvZ2lmdHMuczMudXMtZWFzdC0yLmFtYXpvbmF3cy5jb21cIixcbiAgICBcInhycC1mdW5kcy5jb21cIixcbiAgICBcIm9taXNlZ28tZ2l2ZWF3YXkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJvbWctZ2l2ZWF3YXkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJ1bmlzd2FwLXguY29tXCIsXG4gICAgXCJhcHAudW5pc3dhcC14LmNvbVwiLFxuICAgIFwic3RlbGxhci5vcmcuaW1cIixcbiAgICBcImFjY291bnR2aWV3ZXIuc3RlbGxhci5vcmcuaW1cIixcbiAgICBcImNkbi1zdGVsbGFyLm9yZ1wiLFxuICAgIFwiZ28tc3RlbGxhci5vcmdcIixcbiAgICBcInN0ZWxpYXIub3JnXCIsXG4gICAgXCJzdGVsbGFyLm9yZy5zYlwiLFxuICAgIFwiZXhjb2R1cy5jZlwiLFxuICAgIFwiZXhvZHVzLmNmXCIsXG4gICAgXCJlbGVjdHJ1bXkub3JnXCIsXG4gICAgXCJhcHAudW5qc3dhcC5vcmdcIixcbiAgICBcInVuanN3YXAub3JnXCIsXG4gICAgXCJ1bmlzd2FwLW9yZy5jb21cIixcbiAgICBcImFwcC51bmlzd2FwLW9yZy5jb21cIixcbiAgICBcInhuLS1uaXN3YXAtaHE4Yi5jb21cIixcbiAgICBcImFwcC54bi0tbmlzd2FwLWhxOGIuY29tXCIsXG4gICAgXCJldGhldmVudC50b3BcIixcbiAgICBcImNyeXB0by1zYWZlLmx0ZFwiLFxuICAgIFwiZWxvbmhlbHAuaW5cIixcbiAgICBcInhycC5sdGRhXCIsXG4gICAgXCJib3ZiaXQuY29tXCIsXG4gICAgXCJ6ZWxiaXQuZXhjaGFuZ2VcIixcbiAgICBcInRldmJpdC5jb21cIixcbiAgICBcInRvY2JpdC5jb21cIixcbiAgICBcImNoaXBtaXhlci5hcHBcIixcbiAgICBcImFwcC51bmxzd2FwLm9yZ1wiLFxuICAgIFwidW5sc3dhcC5vcmdcIixcbiAgICBcImNvaW5iaXRtZXguY29tXCIsXG4gICAgXCJidXRlcmluLWdvbGQueHl6XCIsXG4gICAgXCJldGhlcmgtdml0YWxpay50b3BcIixcbiAgICBcImNoZWNrLWxlZGdlci5jb21cIixcbiAgICBcIm1vb25zd2FwLmV4Y2hhbmdlXCIsXG4gICAgXCJ4bi0tdW5pc3dwLW10YS5jb21cIixcbiAgICBcImFwcC54bi0tdW5pc3dwLW10YS5jb21cIixcbiAgICBcIm9yZy1jb25uZWN0LXdhbGxldC5jb21cIixcbiAgICBcImJpenN0YXIuaWN1XCIsXG4gICAgXCJhdG9taWN3YWxsZXQud2Vic2l0ZVwiLFxuICAgIFwiY3J5cHRvaXFvcHRpb25zLmNvbVwiLFxuICAgIFwiZnhwZWN0Y3J5cHQuY29tXCIsXG4gICAgXCJ0cmFkZXJncm92ZS5zcGFjZVwiLFxuICAgIFwiaG91c2UtYXJ0aWNsZS5zcGFjZVwiLFxuICAgIFwiZ3JlZWNlLXBsYXRmb3JtLnNwYWNlXCIsXG4gICAgXCJtdXNrLXNlbmQudG9wXCIsXG4gICAgXCJidGN0ZXNsYS5vcmdcIixcbiAgICBcIm11c2tnaXZlLnRvcFwiLFxuICAgIFwic3BhY2UtZWxvbi5zaXRlXCIsXG4gICAgXCJjdXR2ZS5maW5hbmNlXCIsXG4gICAgXCJhcHB1bmlzd29wLm9yZ1wiLFxuICAgIFwiYXBwdW5pc3dvcC5zaXRlXCIsXG4gICAgXCJ1bnN3YXAuc2l0ZVwiLFxuICAgIFwiYnRjc3lzdGVtLXdlYi1hcHAuY29tXCIsXG4gICAgXCJoZWRlcmFiaXQuY29tXCIsXG4gICAgXCJuaXZiaXQuY29tXCIsXG4gICAgXCJrYXZiaXQuY29tXCIsXG4gICAgXCJqb2NiaXQuY29tXCIsXG4gICAgXCJtaXZiaXQuY29tXCIsXG4gICAgXCJ4bi0tcHhmdWxsLXB0YS5jb21cIixcbiAgICBcInRydXN0d2FsbGV0YXBwLWVyYy0yMC10b2tlbnMuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcInN0YXJsaW5rYnRjLmNvbVwiLFxuICAgIFwic3RhcmxpbmtldGguY29tXCIsXG4gICAgXCJ4bi0tYml0bWFpLW50N2IuY29tXCIsXG4gICAgXCJnaXZlYXdheS5pc1wiLFxuICAgIFwiMmV0aGVyZXVtLm9yZ1wiLFxuICAgIFwic3BhY2V4LWV0aC5iaXpcIixcbiAgICBcInNwYWNleGV0aGVyZXVtLm5ldFwiLFxuICAgIFwieG4tLW5pc3dhcC1veWEuY29tXCIsXG4gICAgXCJtZXRhc2sud2Vic2l0ZVwiLFxuICAgIFwid2FsbGV0Lm1ldGFzay53ZWJzaXRlXCIsXG4gICAgXCJzcGFjZXguY2xpY2tcIixcbiAgICBcInRlc2xhLW11c2submV0XCIsXG4gICAgXCJ1bmlzd2FwcC5zaXRlXCIsXG4gICAgXCJhbHRleGNoZW5nZS5jb21cIixcbiAgICBcIm15Y29zbW9zcGF5LmNvbVwiLFxuICAgIFwiZXhvZGR1cy5uZXRcIixcbiAgICBcInVuaXN3YXAubmV0XCIsXG4gICAgXCJ1bmlzd2FwLmV1XCIsXG4gICAgXCJtdXNrdG8uZnVuXCIsXG4gICAgXCJtdXNrdG9wLnB3XCIsXG4gICAgXCJtdXNrZXZlbnQub3JnXCIsXG4gICAgXCJodW9ibC5ydVwiLFxuICAgIFwidW5pc3dhcC5zaXRlXCIsXG4gICAgXCJtZXRhbWFzay5ldVwiLFxuICAgIFwiYXBwLnhuLS11bnN3YXAtNHZhLmNvbVwiLFxuICAgIFwieG4tLXVuc3dhcC00dmEuY29tXCIsXG4gICAgXCJhcHB1bmlzd2FwLmxpdmVcIixcbiAgICBcInhuLS11bnN3YXAteGs4Yi5jb21cIixcbiAgICBcImFwcC54bi0tdW5zd2FwLXhrOGIuY29tXCIsXG4gICAgXCJlbG9ubXVza2V2ZW50LmNvbVwiLFxuICAgIFwiZWxvbm11c2submV0d29ya1wiLFxuICAgIFwiYml0Y29pbmNvbXB1dG9zLmNvbVwiLFxuICAgIFwiZHNob3Aub3JpZ2lucHJvdG9jb2wuY29yZHBpZGdlb24uY29tXCIsXG4gICAgXCJiaXRmdXJ5dHJhZGUuY29tXCIsXG4gICAgXCJiaXRmdXJ5d2ViLmNvbVwiLFxuICAgIFwiYml0ZnVyeWludmVzdC5jb1wiLFxuICAgIFwieG4tLXVuc3dhcC1xOWEuY29tXCIsXG4gICAgXCJiZXN0Y2hhbWdlLnJ1XCIsXG4gICAgXCJjaGFtYXRoY2FwaXRhbC5jb21cIixcbiAgICBcImNhcmRhbm8tcGFnZS5vcmdcIixcbiAgICBcIm5lby1saXZlLm9yZ1wiLFxuICAgIFwiZWxvbm11c2suY2FwaXRhbFwiLFxuICAgIFwiY2hhbWF0aC5mdW5kXCIsXG4gICAgXCJ2ZXQuY2FwaXRhbFwiLFxuICAgIFwiZ2l2ZWV0aC5jb21cIixcbiAgICBcImFwcHVuaXN3YXAuY29tXCIsXG4gICAgXCJ1bmlzd2FwZGV4Lm9yZ1wiLFxuICAgIFwiZXRoZXJldW11cGRhdGUuaW5mb1wiLFxuICAgIFwiZXRoZXJldW1vZmZpY2lhbC5vcmdcIixcbiAgICBcInNvY2lhbC1jYXBpdGFsLnVzXCIsXG4gICAgXCJldGhlcmV1bS5sdGRhXCIsXG4gICAgXCJhY2NvdW50dmlld2VyLnN0ZWxsYXIub3JnLnNvXCIsXG4gICAgXCJzdGVsbGFyLm9yZy5zb1wiLFxuICAgIFwiZ2l2ZWF3YXktZXRoLXRydXN0d2FsbGV0cy4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwiYXBwLXRydXN0d2FsbGV0LmVyYzIwLWFpcmRyb3AuaWN1XCIsXG4gICAgXCJlcmMyMC1haXJkcm9wLmljdVwiLFxuICAgIFwiYXNzZXRzLWluZGV4LWZpbGVzLnh5elwiLFxuICAgIFwiYXBwLXRydXN0d2FsbGV0LnJld2FyZHMtZXJjMjAtYWlyZHJvcC5zaXRlXCIsXG4gICAgXCJyZXdhcmRzLWVyYzIwLWFpcmRyb3Auc2l0ZVwiLFxuICAgIFwidHJ1c3R3YWxsZXQuZXJjMjAtYWlyZHJvcC5pY3VcIixcbiAgICBcImxrLm1pbGxpb24ubW9uZXkuZXJjMjAtYWlyZHJvcC5pY3VcIixcbiAgICBcIm1hZXphd2EtYm9udXMuY29tXCIsXG4gICAgXCJnb211c2suZnVuXCIsXG4gICAgXCJzcGFjZXgubWFya2V0XCIsXG4gICAgXCJlbG9uZHJvcHMuY29tXCIsXG4gICAgXCJlbG9ucHJvbW8ub3JnXCIsXG4gICAgXCJqb2hucHJvbW8uY29tXCIsXG4gICAgXCJ0ZXNsYS1iaXRjb2luLmluZm9cIixcbiAgICBcImJpbmFuY2UucmV3YXJkcy1wcm9ncmFtcy5vcmdcIixcbiAgICBcInJld2FyZHMtcHJvZ3JhbXMub3JnXCIsXG4gICAgXCJsY29pbmJhc2UuY29tXCIsXG4gICAgXCJldGhlcnNjYW4uaW8ucmV3YXJkcy11c2VyLWluZm8uY29tXCIsXG4gICAgXCJ6ZWR4ZS5jb20ucmV3YXJkcy11c2VyLWluZm8uY29tXCIsXG4gICAgXCJyZXdhcmRzLXVzZXItaW5mby5jb21cIixcbiAgICBcIm11bHRpbWluZXIud2Vic2l0ZVwiLFxuICAgIFwibGFuZGNvaW5sbmMuY29tXCIsXG4gICAgXCJhcHB1bmlzd29wLmNvbVwiLFxuICAgIFwidW5pc3Z2YXAub3JnXCIsXG4gICAgXCJhcHAudW5pc3Z2YXAub3JnXCIsXG4gICAgXCJ1bmlzd2FwdjF2Mi5vcmdcIixcbiAgICBcImdpdmVhd2F5YWlyZHJvcC1ldGguZ2FcIixcbiAgICBcInNlY3JldG1ldGhvZHNub3cuY29tXCIsXG4gICAgXCJhaXJkcm9wYmF0LmNvbVwiLFxuICAgIFwibXVza3guY29cIixcbiAgICBcImRheHhjb2lucy5jb21cIixcbiAgICBcImV0aC1ldmVudC5iaXpcIixcbiAgICBcImJsb2NrZHJvcHMuaW5mb1wiLFxuICAgIFwiZWxvbi1ibG9nLmNvbVwiLFxuICAgIFwiYm9udXMtdGVzbGEuY29tXCIsXG4gICAgXCJiaXRtaW5lcnMuc3RvcmVcIixcbiAgICBcInVuaW9uZmluYW5jZS5vcmdcIixcbiAgICBcImV4b2R1c3Mub3JnXCIsXG4gICAgXCJleGNvZHVzLmlvXCIsXG4gICAgXCJleHNvZHVzLmlvXCIsXG4gICAgXCJlbGNhc3RydW0uY29tXCIsXG4gICAgXCJiYXNiaXQuY29tXCIsXG4gICAgXCJkaWdpbWluZXIuaW9cIixcbiAgICBcImJhdGFpcmRyb3AubmV0XCIsXG4gICAgXCJtYWtlcmRhb3dlYi5vcmdcIixcbiAgICBcInZpdGFsaWsudG9wXCIsXG4gICAgXCJldGhlci1wcm9tby1wYXJ0aWNpcGF0ZS1ub3cuY29tXCIsXG4gICAgXCJldGhlci1wcm9tby5jb21cIixcbiAgICBcImJhZmJpdC5jb21cIixcbiAgICBcImZyZXpvci51c1wiLFxuICAgIFwiZ2VtaW5pLWJ0Yy5uZXdzXCIsXG4gICAgXCJhdmF4c2FsZXMubmV0XCIsXG4gICAgXCJjcnlwdG9taW5lci50ZWxcIixcbiAgICBcImJpdGNyeXB0b21hbmlhLmNvbVwiLFxuICAgIFwiZnVuZHVzZHQuY29tXCIsXG4gICAgXCJ2NC1hbnRwb29sLmNvbVwiLFxuICAgIFwiYWlyZHJvcDIwMjAuY29tXCIsXG4gICAgXCJ3b3pidGNmdW5kcy1qb2lucHJvbW90aW9uLmNvbVwiLFxuICAgIFwiYnRjeGV2ZW50LmNvbVwiLFxuICAgIFwiY3J5cHRvZm9yaGVhbHRoLmNvbVwiLFxuICAgIFwieG4tLWJpbm5jZS1rdGEuY29tXCIsXG4gICAgXCJ4bi0tYmxubmNlLWRkOGIuY29tXCIsXG4gICAgXCJub2RlLnVuaXN3YXB2MXYyLmFwcFwiLFxuICAgIFwidW5pc3dhcHYxdjIuYXBwXCIsXG4gICAgXCJ1bmlzd2FwZXhjaGFuZ2Uub25saW5lXCIsXG4gICAgXCJ4bXItd2FsbGV0LmNvbVwiLFxuICAgIFwidW5pc3dvcC5zaG9wXCIsXG4gICAgXCJ0cm9uYWlyZHJvcC5jb21cIixcbiAgICBcInN0ZWxsYXItbGltaXRlZC5jb21cIixcbiAgICBcInZlcmlmeS5wYXhmdWxzdXBwb3J0Lm9ubGluZVwiLFxuICAgIFwicGF4ZnVsc3VwcG9ydC5vbmxpbmVcIixcbiAgICBcImltLWNyZWF0b3IuY29tXCIsXG4gICAgXCJiaXRjb2lubW9udGgtdG9wLmluZm9cIixcbiAgICBcInNtYXJ0Y29udHJhY3RiaXouY29tXCIsXG4gICAgXCJsaW5rLWRyb3AubmV0XCIsXG4gICAgXCJsb2dpbi54bi0tYmxvY2tjaGluLWgyYS5jb21cIixcbiAgICBcInhuLS1ibG9ja2NoaW4taDJhLmNvbVwiLFxuICAgIFwibG9naW4ueG4tLWJsb2NrY2hhLTkxYTQxZy5jb21cIixcbiAgICBcInhuLS1ibG9ja2NoYS05MWE0MWcuY29tXCIsXG4gICAgXCJiaWxsZ2F0ZXNidGMuY29tXCIsXG4gICAgXCJjbGFpbWJzdi50b1wiLFxuICAgIFwieG4tLWJvY2tjaGFpbi0wZTVoLmNvbVwiLFxuICAgIFwibG9naW4ueG4tLWJvY2tjaGFpbi0wZTVoLmNvbVwiLFxuICAgIFwidGVzbGEzLmdpZnRzXCIsXG4gICAgXCJtdXNrLWdpZnRzLmNvbVwiLFxuICAgIFwibXVza3Byb21vdGlvbi5jb21cIixcbiAgICBcIm11c2stY29pbi5jb21cIixcbiAgICBcImNhcmRhbm9ldmVudC5vcmdcIixcbiAgICBcImV2ZW50LWV0aC5jb21cIixcbiAgICBcImFkYWZ1bmQucHJvXCIsXG4gICAgXCJldmVudC1hZGEuaW5mb1wiLFxuICAgIFwiY2FyZGFuby1pbmZvLnVzXCIsXG4gICAgXCJldGhmdW5keC5pbmZvXCIsXG4gICAgXCJldGgtZnJlZS5jb21cIixcbiAgICBcImJyYWlucHJvbW8uaW5mb1wiLFxuICAgIFwiam9lcm9nYW4uZnVuZFwiLFxuICAgIFwiYmluYW5jZWZ1bmQub3JnXCIsXG4gICAgXCJicm9jay1idGMuY29tXCIsXG4gICAgXCJjYXJkYW5vLWFkYS5pbmZvXCIsXG4gICAgXCJldGh4ZXZlbnQtcGFydGljaXBhdGUuY29tXCIsXG4gICAgXCJldGh1bWFuLmNvbVwiLFxuICAgIFwia2FueWVidGMub3JnXCIsXG4gICAgXCJldGhlcm1vbmV5bWFjaGluZS5jb21cIixcbiAgICBcImFpci1ldGhlci50b3BcIixcbiAgICBcInRyZXpvci5saVwiLFxuICAgIFwieG4tLXJlem9yLTZkYi5jb21cIixcbiAgICBcImRyb3AtZXRoLmluZm9cIixcbiAgICBcImNvaW4tZnJlZS1leGNoYW5nZS5jZlwiLFxuICAgIFwicmlwcGxlLmNvbS52Y1wiLFxuICAgIFwiZXRoZnJlZS5pbmZvXCIsXG4gICAgXCJzdGVsbGFyLm9yZy52Y1wiLFxuICAgIFwiYWNjb3VudHZpZXdlci5zdGVsbGFyLm9yZy52Y1wiLFxuICAgIFwiZXRoLWluZm8ub3JnXCIsXG4gICAgXCJhZGEtZXZlbnQuaW5mb1wiLFxuICAgIFwiY2FyZGFub2V2ZW50LmNvbVwiLFxuICAgIFwiY2FyZGFub2Z1bmQuaW5mb1wiLFxuICAgIFwiYWRhZnVuZC5uZXRcIixcbiAgICBcInNwYWNleC01MDAwYnRjLmNvbVwiLFxuICAgIFwiZnVuZGdlbWluaS5jb21cIixcbiAgICBcImV0aGZvdW5kYXRpb24uaW5mb1wiLFxuICAgIFwidW5pc3dhcHYzLm9yZ1wiLFxuICAgIFwidW5pc3dvcC5leGNoYW5nZVwiLFxuICAgIFwiZXZlbnQtZXRoLmluZm9cIixcbiAgICBcImZ1bmRzcmV0cmlldmUuY29tXCIsXG4gICAgXCJiYXQtYWlyZHJvcC5jb21cIixcbiAgICBcImNyeXB0b3RhYmhhY2suY29tXCIsXG4gICAgXCJmcmVlYml0Z2VuZXJhdG9yLmNvbVwiLFxuICAgIFwidHJvbi1wcm9qZWN0LmNvbVwiLFxuICAgIFwid3d3Z3VhcmRhLmNvXCIsXG4gICAgXCJ3d3d0aGV0YXRva2VuLm9yZ1wiLFxuICAgIFwiaGV0YXRva2VuLm9yZ1wiLFxuICAgIFwidGhldGF0b2tlbi5jblwiLFxuICAgIFwidGV0YXRva2VuLm9yZ1wiLFxuICAgIFwibHVtaXdhbGxlLmNvbVwiLFxuICAgIFwibHVpd2FsbGV0LmNvbVwiLFxuICAgIFwibHVtaXdhbGV0LmNvbVwiLFxuICAgIFwidW1pd2FsbGV0LmNvbVwiLFxuICAgIFwibHVtaXdhbGx0LmNvbVwiLFxuICAgIFwibHVtaXdhbGxldC5uZXRcIixcbiAgICBcImx1bXdhbGxldC5jb21cIixcbiAgICBcInd3d2NvaW5meS5jb21cIixcbiAgICBcInd3d2x1bWl3YWxsZXQuY29tXCIsXG4gICAgXCJsdW1pd2xsZXQuY29tXCIsXG4gICAgXCJ0aGV0YW9rZW4ub3JnXCIsXG4gICAgXCJ0aGV0YXRrZW4ub3JnXCIsXG4gICAgXCJ0aGV0YXRvZW4ub3JnXCIsXG4gICAgXCJ0aGV0YXRva24ub3JnXCIsXG4gICAgXCJ3d3d3aGl0ZWNvaW4uaW5mb1wiLFxuICAgIFwibG1pd2FsbGV0LmNvbVwiLFxuICAgIFwidGhlYXRva2VuLm9yZ1wiLFxuICAgIFwidGhldGF0b2tlLm9yZ1wiLFxuICAgIFwidGh0YXRva2VuLm9yZ1wiLFxuICAgIFwic3RvY2staW5kZXguc3BhY2VcIixcbiAgICBcImZpbm1heGJvLmNvbVwiLFxuICAgIFwidGVzbGEtZ2l2ZS5jb21cIixcbiAgICBcInRlc2xhLWNyeXB0b3MuY29tXCIsXG4gICAgXCJjcnlwdG9zLW1hc2suY29tXCIsXG4gICAgXCJjcnlwdG8tZXZlbnQuY29tXCIsXG4gICAgXCJnZW1pbmlsaXZlLm9yZ1wiLFxuICAgIFwicHJvZXRoZXItZnVuZHNyZWxlYXNlLXBhcnRpY2lwYXRlLmNvbVwiLFxuICAgIFwiZXRobWFya2V0LmluZm9cIixcbiAgICBcImdlbWluaWJ0Yy5uZXRcIixcbiAgICBcImdlbWluaS1idGMuaW9cIixcbiAgICBcImV0aC1pbmZvLmNvbVwiLFxuICAgIFwiZXRoZHJvcHguaW5mb1wiLFxuICAgIFwiYmV6b3MtYW1hem9uLnRvcFwiLFxuICAgIFwibXJiZWFzdGJ0Yy5pbmZvXCIsXG4gICAgXCJldGhlcmV1bW5ld3MucHdcIixcbiAgICBcImphY2stYnRjLm5ldFwiLFxuICAgIFwibXVza3NwYWNleC5vcmdcIixcbiAgICBcInBvb2wuYmFsYW5jZXIuZGV2XCIsXG4gICAgXCJiYWxhbmNlci5kZXZcIixcbiAgICBcImJpdGNvaW5zZWFyY2hlbmdpbmVzLnN0b3JlXCIsXG4gICAgXCJhdmF4d2ViLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwiZWxvbnguY29cIixcbiAgICBcIm5vdGFsbC5lc2hvc3QuY29tLmFyXCIsXG4gICAgXCJub3RhbGx3YWxsZXQubWxcIixcbiAgICBcImJhdmJpdC5jb21cIixcbiAgICBcInRlc2xhLWJvbnVzLmNvbVwiLFxuICAgIFwidHJlejByLmNvbVwiLFxuICAgIFwiYWN0aXZkYXJ0by5jb21cIixcbiAgICBcImJpdC1haXJkcm9wLmNsdWJcIixcbiAgICBcImNvbXBvdW5kbm9kZS5kZXZcIixcbiAgICBcImx1bWl3YWxsZXRhcHAuY29tXCIsXG4gICAgXCJkYXNod2FsbGV0YXBwLmNvbVwiLFxuICAgIFwibWV0YW1hc2subHRkXCIsXG4gICAgXCJldmVyY29pbmFwcC5jb21cIixcbiAgICBcInNhbW9yYWl3YWxsZXRhcHAuY29tXCIsXG4gICAgXCJiaXRwaWVhcHAuY29tXCIsXG4gICAgXCJibHVld2FsbGV0YXBwLmNvbVwiLFxuICAgIFwidG9rZW5wb2NrZXRhcHAuY29tXCIsXG4gICAgXCJwYXl0b21hdHdhbGxldC5jb21cIixcbiAgICBcInB1bWFwYXlhcHAuY29tXCIsXG4gICAgXCJibG9ja2NoYWluYXBwLmx0ZFwiLFxuICAgIFwiamF4eC5sdGRcIixcbiAgICBcImdyZWVuYXBwLmx0ZFwiLFxuICAgIFwiZXhvZHVzYXBwLmx0ZFwiLFxuICAgIFwiY29ib2FwcC5sdGRcIixcbiAgICBcImF0b21pY2FwcC5sdGRcIixcbiAgICBcImV0b3Jvd2FsbGV0YXBwLmNvbVwiLFxuICAgIFwicmlwcGxld2FsbGV0YXBwcy5jb21cIixcbiAgICBcImNyeXB0ZXJpdW13YWxsZXRhcHAuY29tXCIsXG4gICAgXCJ0cmV6b3JhcHAuY29tXCIsXG4gICAgXCJtZXdhcHAubHRkXCIsXG4gICAgXCJ2bGFkbGFkLmNvbVwiLFxuICAgIFwiZGV4YXBpcy54eXpcIixcbiAgICBcImFyYml0cmFnZWNyeXB0by5vcmdcIixcbiAgICBcInRoZWFwaS5wcm9cIixcbiAgICBcImVsb25ldmVudC5zaXRlXCIsXG4gICAgXCJ0cnVzdGFwcC5sdGRcIixcbiAgICBcIm15cnRoZXJ2dmVsbGFudGkuY29tXCIsXG4gICAgXCJndWFkcmEuY29tXCIsXG4gICAgXCJnaXZlYXdheS1iaXQueHl6XCIsXG4gICAgXCJjcnlwdG8tdHJ1c3QuY29cIixcbiAgICBcImRhby1taWdyYXRlLmNvbVwiLFxuICAgIFwid2ludGVzbGEubmV0XCIsXG4gICAgXCIwMTAxLnN5c3RlbXNcIixcbiAgICBcImJpdGNvaW5ibGFjay5jYXNoXCIsXG4gICAgXCJ4bi0tcmlwcGwtOHJhLmNvbVwiLFxuICAgIFwiYmxvZ3N0ZWxsYXIub3JnXCIsXG4gICAgXCJjbGFpbXN0ZWxsYXIuY29tXCIsXG4gICAgXCJ4bi0tYWNjb3VudHZld2VyLXN0ZWxsYXItcGJkLmNvbVwiLFxuICAgIFwieG4tLXRyb3NjYW4tbWtiLm9yZ1wiLFxuICAgIFwieG4tLXRlbGxhci0yaWIub3JnXCIsXG4gICAgXCJ4bi0tc3RlbGFyLTVkYi5jb21cIixcbiAgICBcImdldHhsbS5vcmdcIixcbiAgICBcInhuLS1zdGVsYXItNmRiLm9yZ1wiLFxuICAgIFwiYWNjb3VudHZpZXdlci54bi0tc3RlbGFyLTZkYi5vcmdcIixcbiAgICBcImdldHJpcHBsZS5vcmdcIixcbiAgICBcInhuLS1zdGxsYXItY3BjLmNvbVwiLFxuICAgIFwieG4tLXN0bGxhci1xM2EuY29tXCIsXG4gICAgXCJ4cnAtY29tbXVuaXR5LmNvbVwiLFxuICAgIFwiYml0aG9tYi5jb21cIixcbiAgICBcInhuLS1iaXRobXAtNndiLmNvbVwiLFxuICAgIFwiZ3Jvd2JpdGNvaW4uY28udWtcIixcbiAgICBcImdldDJ4Y29pbi5jb21cIixcbiAgICBcImJrZXhjYXBpdGFsLmNvbVwiLFxuICAgIFwib2xkZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWRhc2h3YWxsZXRzLmNvbVwiLFxuICAgIFwibXlha2F3YWxsZXQuY29tXCIsXG4gICAgXCJtdXNpY29pbndhbGxldC5jb21cIixcbiAgICBcImV4cHdhbGxldC5uZXRcIixcbiAgICBcImRiaXgubGlua1wiLFxuICAgIFwibXl1Ymlxd2FsbGV0LmNvbVwiLFxuICAgIFwiY2xvd2FsbGV0Lm5ldHdvcmtcIixcbiAgICBcIm15cnRoZXNydnZlbGx0bmkuY29tXCIsXG4gICAgXCJsaW5rY29pbmFpcmRyb3AuY29tXCIsXG4gICAgXCJiYXRhaXJkcm9wLmNvbVwiLFxuICAgIFwidGVhbS1ibG9ja2NoYWluLmluZm9cIixcbiAgICBcImF2dWJpdC5jb21cIixcbiAgICBcImZ1bGNydW0ucGx1c1wiLFxuICAgIFwiZXRoLmZ1bGNydW0ucGx1c1wiLFxuICAgIFwidXNkYy5mdWxjcnVtLnBsdXNcIixcbiAgICBcImRhaS51c2RjLmZ1bGNydW0ucGx1c1wiLFxuICAgIFwieG4tLXJpcHAteXZhMXguY29tXCIsXG4gICAgXCJyaXBwbGUuY29tLmJ6XCIsXG4gICAgXCJjaGFpbmxpbmt0b2tlbi5pbmZvXCIsXG4gICAgXCJub2RlLWJpbmFuY2VkZXgub25saW5lXCIsXG4gICAgXCJoZXhub2RlLm9ubGluZVwiLFxuICAgIFwidW5pc3dhcHYydjEub3JnXCIsXG4gICAgXCJwYXhmdWxjLmNvbVwiLFxuICAgIFwicGF4ZnVsLXZlcmlmaWVkLmNvbVwiLFxuICAgIFwicGF4ZnVsb2ZmZXJzLmNvbVwiLFxuICAgIFwidHJvbnNjYW4ubWVcIixcbiAgICBcInRyb25zY2FuLmluXCIsXG4gICAgXCJ4bi0tdHJvbnNhbi02NWEuY29tXCIsXG4gICAgXCJvYXV0aC1kZXJpdi1iaW5hcnkud2Vic2l0ZVwiLFxuICAgIFwicGF4ZnVsLWNvbS1sb2dpbi5vYXV0aC1kZXJpdi1iaW5hcnkud2Vic2l0ZVwiLFxuICAgIFwiZWxlY3RydW1lLm9yZ1wiLFxuICAgIFwiZnVsY3J1bS5jb2Rlc1wiLFxuICAgIFwieG4tLWJsb2NjaGFuLWNpYjdoLmNvbVwiLFxuICAgIFwiY29pbmJpei5tZVwiLFxuICAgIFwiZnVsY3J1bS5yZXBhaXJcIixcbiAgICBcInVuaXN3YXAuc2VydmljZXNcIixcbiAgICBcIm1heC1tYWljb2luLWJvbnVzYnRjLjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJmeG9wdGlvbjI3LmNvbVwiLFxuICAgIFwibGNvbi5mb3VuZGF0aW9uXCIsXG4gICAgXCJ3YWxsZXQuZmFudG9tLmxpbmtcIixcbiAgICBcImZhbnRvbS5saW5rXCIsXG4gICAgXCJjb2lucGhhbnQuY29tXCIsXG4gICAgXCJ0aGV0YXRva2VuLmxpbmtcIixcbiAgICBcImljb25mb3VuZGF0aW9uLm9ubGluZVwiLFxuICAgIFwiZHJvcGVsb24uY29cIixcbiAgICBcImJ0Yy1ldmVudC5vcmdcIixcbiAgICBcImJ0Y21peGVyLnRlY2hcIixcbiAgICBcIm11c2tldmVudC5uZXRcIixcbiAgICBcIm11c2t4ZHJvcC5pbmZvXCIsXG4gICAgXCJtdXNrLWdpdmUub25saW5lXCIsXG4gICAgXCJ6aWxsaXFhd2FsbGV0Lm9ubGluZVwiLFxuICAgIFwiYmxvY2tjaGFpbi1hdXRvLWJ0Yy5ydVwiLFxuICAgIFwid2FsbGV0LnRyeGxpdmUubmV0d29ya1wiLFxuICAgIFwidHJ4bGl2ZS5uZXR3b3JrXCIsXG4gICAgXCJmb3VuZGF0bG9uLmNvbVwiLFxuICAgIFwiZXhvZGx1cy5pb1wiLFxuICAgIFwibGl0ZWNvbG4ub3JnXCIsXG4gICAgXCJiaXRjb2xuY29yZS5vcmdcIixcbiAgICBcImV4b2R1c3VwZGF0ZS5jb21cIixcbiAgICBcInNocmVtYnRjLmNvbVwiLFxuICAgIFwiYWxhbmJ0Yy5jb21cIixcbiAgICBcImpvc2VwaGJ0Yy5jb21cIixcbiAgICBcImZvcmRidGMub3JnXCIsXG4gICAgXCJicmFuc29uYnRjLmNvbVwiLFxuICAgIFwiYmxvb21iZXJnYnRjLm5ldFwiLFxuICAgIFwiZXhvZHVzLmNvbS5zd3Rlc3QucnVcIixcbiAgICBcImVsb25tdXNrZHJvcC5jb21cIixcbiAgICBcIm11c2tidGMudXNcIixcbiAgICBcIm1ldG1hYXNrLmlvXCIsXG4gICAgXCJzb255eGJ0Yy5uZXRcIixcbiAgICBcIm5pY2VsaGFzaC5jb21cIixcbiAgICBcIm1vbm5lcm8ub3JnXCIsXG4gICAgXCJndWltbG5lci5vcmdcIixcbiAgICBcImJpbGluYW5jZS5vcmdcIixcbiAgICBcIm5pY2VyaGFzaC5jb21cIixcbiAgICBcIm5sY2VoYXNoLnJ1XCIsXG4gICAgXCJ3b3puaWFrZHJvcC5jb21cIixcbiAgICBcInRpbmtvZmZidGMuaW5mb1wiLFxuICAgIFwiZHVyb3ZhaXJkcm9wLmNvbVwiLFxuICAgIFwiY29va2J0Yy5jb21cIixcbiAgICBcInBld2RpZXBpZWJ0Yy5jb21cIixcbiAgICBcImV0aGVyYWlyZHJvcC5jb21cIixcbiAgICBcInBhbnRlcmFkcm9wLmNvbVwiLFxuICAgIFwic3BhY2V4ZHJvcHguY29tXCIsXG4gICAgXCJzcGFjZXhidGNkcm9wLmNvbVwiLFxuICAgIFwiYmlsbGdhdGVzZnVuZC5jb21cIixcbiAgICBcImxpdGVjb2luLXR1bWJsZXIuY29tXCIsXG4gICAgXCJodXJ0cmFkZS5jb21cIixcbiAgICBcImh1YmNvaS5jb21cIixcbiAgICBcImZpeHhjb2luLmNvbVwiLFxuICAgIFwibXVza2ZyZWVidGMuY29tXCIsXG4gICAgXCJldGhlcmV1bS10dW1ibGVyLmNvbVwiLFxuICAgIFwibXVza3Jld2FyZC5jb21cIixcbiAgICBcImVsb25naXZlcy5mdW5cIixcbiAgICBcImdhaW50ZXNsYS5jb21cIixcbiAgICBcInRydXN0d2FsbGV0LmNsYWltLWdpdmVhd2F5LWFpcmRyb3Auc2l0ZVwiLFxuICAgIFwiY2xhaW0tZ2l2ZWF3YXktYWlyZHJvcC5zaXRlXCIsXG4gICAgXCJhaXJkcm9wLWdpdmVhd2F5Lnh5elwiLFxuICAgIFwicHMtYnRjLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NoaW4tYzJkLmNvbVwiLFxuICAgIFwieG4tLWJsb2NrY2huLTFvZDQ5OTNlLmNvbVwiLFxuICAgIFwieG4tLWJsb2NjaGFuLWc0OWN2MWQuY29tXCIsXG4gICAgXCJpbnZlc3RiaW5hbmNlLmNvbVwiLFxuICAgIFwibXlmdXNpb253YWxsZXQubmV0XCIsXG4gICAgXCJidGNkb3VibGUyeC5zaXRlXCIsXG4gICAgXCJjb2luYW55dGltZS5jb21cIixcbiAgICBcInBvcnRhbC5ub2RlLWJpbmFuY2UuZGV2XCIsXG4gICAgXCJub2RlLWJpbmFuY2UuZGV2XCIsXG4gICAgXCJwb3J0YWwuc3ludGhldGl4LmRldlwiLFxuICAgIFwic3ludGhldGl4LmRldlwiLFxuICAgIFwicG9ydGFsLmhleC1ub2RlLm5ldHdvcmtcIixcbiAgICBcImhleC1ub2RlLm5ldHdvcmtcIixcbiAgICBcInBvcnRhbC51bmlzd2FwLmRldlwiLFxuICAgIFwidW5pc3dhcC5kZXZcIixcbiAgICBcInBvcnRhbC5jdXJ2ZWZpbmFuY2UubmV0d29ya1wiLFxuICAgIFwiY3VydmVmaW5hbmNlLm5ldHdvcmtcIixcbiAgICBcInBvcnRhbC5mdWxjcnVtLm5ldHdvcmtcIixcbiAgICBcImZ1bGNydW0ubmV0d29ya1wiLFxuICAgIFwidW5pc3dhcC1leGNoYW5nZS5yZXBhaXJcIixcbiAgICBcInRlc2xhZ2Fpbi5jb21cIixcbiAgICBcInpyeGFpcmRyb3AuY29tXCIsXG4gICAgXCJsZWRkZ2VyLmlvXCIsXG4gICAgXCJxdWlja2J0Y21pbmVyLmNvbVwiLFxuICAgIFwidGVzbGF4LmluXCIsXG4gICAgXCJhcHAuZnVsY3J1bS5yZXBhaXJcIixcbiAgICBcImpheHh4LmlvXCIsXG4gICAgXCJ6aWxsbGV0LmlvXCIsXG4gICAgXCJtb29ubGxldC5pb1wiLFxuICAgIFwiYXBwLm1vb25sbGV0LmlvXCIsXG4gICAgXCJwcm9maXR0ZXNsYS5jb21cIixcbiAgICBcInRlc2xhcGF5b3V0LmNvbVwiLFxuICAgIFwiZ2l2ZXRlc2xhLmNvbVwiLFxuICAgIFwidGVzbGF4LmxpdmVcIixcbiAgICBcImFpbmJpdC5jb21cIixcbiAgICBcInNwYWNleGJ0Yy5uZXRcIixcbiAgICBcIm1ha2VyZGFvLnJlZGVlbS5ielwiLFxuICAgIFwicmVkZWVtLmJ6XCIsXG4gICAgXCJzYWkucmVkZWVtLmJ6XCIsXG4gICAgXCJidGNvbmxpbmUuaW9cIixcbiAgICBcInhycGNvbnRlc3QudHVtYmxyLmNvbVwiLFxuICAgIFwiZm92Yml0LmNvbVwiLFxuICAgIFwiYXRvbWljLmltXCIsXG4gICAgXCJleG9kdXMudmNcIixcbiAgICBcInBheGZ1bC1ucy5jb21cIixcbiAgICBcInBheGZ1bC1zbC5jb21cIixcbiAgICBcIm15LXBheGZ1bC5jb21cIixcbiAgICBcInBheGZ1bC12ZXJpZmllci5jb21cIixcbiAgICBcInBheGZ1bC1mcmEuY29tXCIsXG4gICAgXCJiaXRvcHJvd2FsbGV0LjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJmdHgtY29tLWV4Y2hhbmdlLWNyeXB0b2N1cnJlbmN5LjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJwaW9uZXgtY29tLWV4Y2hhbmdlLWdpdmVhd2F5LjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJwYXhmdWxzZWN1cmVkLmNvbVwiLFxuICAgIFwiY3J5cHRveGx1Y2suY29tXCIsXG4gICAgXCJrdWNvaW4taW5mby5saXZlXCIsXG4gICAgXCJlbG9uLmdpZnRzXCIsXG4gICAgXCJzaW1wbGVzd2FwLm9yZ1wiLFxuICAgIFwiZ2V0YnRjeC5jb21cIixcbiAgICBcIm1ha2VyZGFvLnJlZGVlbS5mdW5kXCIsXG4gICAgXCJzYWkucmVkZWVtLmZ1bmRcIixcbiAgICBcInJlZGVlbS5mdW5kXCIsXG4gICAgXCJsaWJyYXNhbGUuaW9cIixcbiAgICBcImhvdmJpdC5jb21cIixcbiAgICBcIm9mZmljaWFsbGlicmFjb2luLmNvbVwiLFxuICAgIFwibXVzay1ldmVudC5vbmxpbmVcIixcbiAgICBcIm11c2stZXZlbnQudGVjaFwiLFxuICAgIFwibXVzay1ldmVudC5zcGFjZVwiLFxuICAgIFwidGVzbGFlYXJuLmNvbVwiLFxuICAgIFwiemFsYml0LmNvbVwiLFxuICAgIFwiZWxvbngub3JnXCIsXG4gICAgXCJmb2xiaXQuY29tXCIsXG4gICAgXCJvbWlzZWdvLmluZm9cIixcbiAgICBcIm11ZXRoZXJ3YWxsZXQuY29cIixcbiAgICBcImJ0Y3Nob3dlci5jb21cIixcbiAgICBcImxrLmZvcnNhZ2UuaW8uZ2l2ZWF3YXktdG9rZW4tbWVtYmVyLmNvbVwiLFxuICAgIFwiZ2l2ZWF3YXktdG9rZW4tbWVtYmVyLmNvbVwiLFxuICAgIFwiYWNjb3VudHZpZXdlci54bi1zdGVsbGEtZ2liLm9yZ1wiLFxuICAgIFwieG4tc3RlbGxhLWdpYi5vcmdcIixcbiAgICBcImJlc3RjaGFucWUucnVcIixcbiAgICBcIm1pbmluZ2Jhc2UuY2xvdWRcIixcbiAgICBcImFjY291bnR2aWV3ZXItc3RlbGxhci5jb21cIixcbiAgICBcImxlZGdlcnNsaXZlLndlYi5hcHBcIixcbiAgICBcImxlZGdlcmxpdmV3YWxsZXQuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcInRlYW1zcGFjZXguaW5mb1wiLFxuICAgIFwidHNsYW11c2subWVcIixcbiAgICBcInJvYmVydGV0aC5jb21cIixcbiAgICBcImNoYW1idGMub3JnXCIsXG4gICAgXCJ0c2xhYnRjLm1lXCIsXG4gICAgXCJicmluYnRjLm5ldFwiLFxuICAgIFwid2lua2J0Yy5jb21cIixcbiAgICBcImJyaW5idGMub3JnXCIsXG4gICAgXCJ4cnAuY2xhaW1zXCIsXG4gICAgXCJnZXQteHJwLW5vdy5vbmxpbmVcIixcbiAgICBcInhycDIwLm9yZ1wiLFxuICAgIFwiYmFycnlidGMub3JnXCIsXG4gICAgXCJzaHJlbWJ0Yy5vcmdcIixcbiAgICBcInRha2V4cnAubGl2ZVwiLFxuICAgIFwieHJwZHJvcC5tZVwiLFxuICAgIFwieHJwLndvcmtcIixcbiAgICBcInhycC5iaW9cIixcbiAgICBcInhycDIwLmNvbVwiLFxuICAgIFwiamFja21hYnRjLmNvbVwiLFxuICAgIFwid296bmlhay5ncm91cFwiLFxuICAgIFwicm9iZXJ0a2kub3JnXCIsXG4gICAgXCJnYXRlcy5wcm9tb1wiLFxuICAgIFwidG9weHJwLmNvbVwiLFxuICAgIFwieHJwY2xhaW0ub3JnXCIsXG4gICAgXCJhd2F5eHJwLm9yZ1wiLFxuICAgIFwieHJwdG9wLmNvbVwiLFxuICAgIFwieHJwdGFrZS5saXZlXCIsXG4gICAgXCIyMDIweHJwLm9yZ1wiLFxuICAgIFwiY2xhaW14cnAub3JnXCIsXG4gICAgXCIyMHhycC50ZWNoXCIsXG4gICAgXCJnaXZlYXdheXNlcHRlbWJlci5jb21cIixcbiAgICBcInJlY2VpdmV4cnAuY29tXCIsXG4gICAgXCJ4cnB4MTAub3JnXCIsXG4gICAgXCJ4cnBhd2F5Lm9yZ1wiLFxuICAgIFwiZ2V0ZXRoLmxpdmVcIixcbiAgICBcIjIwMjB4cnAubmV0XCIsXG4gICAgXCJjbGFpbXhycC5uZXRcIixcbiAgICBcImF3YXl4cnAubmV0XCIsXG4gICAgXCJteXhycC5vcmdcIixcbiAgICBcInJpcHBsZS5yZVwiLFxuICAgIFwiZGF2ZS1idGMuaW5mb1wiLFxuICAgIFwic3RldmVidGMub3JnXCIsXG4gICAgXCJjaGFtLWJ0Yy5pbmZvXCIsXG4gICAgXCJwYW50ZXJhLmx0ZFwiLFxuICAgIFwieGlhb21pYnRjLmNvbVwiLFxuICAgIFwiZm91bmQtYmluLmNvbVwiLFxuICAgIFwid2FsbGV0Z2VuZXJhdG9yLm5ldFwiLFxuICAgIFwibWF4LW1haWNvaW4tY2xhaW1ib251c2J0Yy4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwibG9rYml0LmNvbVwiLFxuICAgIFwidmF1Yml0LmNvbVwiLFxuICAgIFwiYml0Y29pbnBhcGVyd2FsbGV0LmNvbVwiLFxuICAgIFwicHJvZml0bXVzay5jb21cIixcbiAgICBcImVsb25zYXZlLmNvbVwiLFxuICAgIFwidG9ueS1idGMuaW5mb1wiLFxuICAgIFwiZGVudGFjb2lucy5jb21cIixcbiAgICBcImxhdWJpdC5jb21cIixcbiAgICBcImJpbmFuY2VjaGFuZ2UuY29tXCIsXG4gICAgXCJyb3lhbC1jcnlwdG8uY2NcIixcbiAgICBcIm11c2twcm9maXQuY29tXCIsXG4gICAgXCJldGhlcnNjYW5uZXIubWxcIixcbiAgICBcIndvemRyb3AubWVcIixcbiAgICBcInlhdWJpdC5jb21cIixcbiAgICBcImhhbGZiaXQuY2NcIixcbiAgICBcImJpdGNvaW5ib251c3dhbGxldC5jb21cIixcbiAgICBcImJ5dG9tYml0LmNvbVwiLFxuICAgIFwidGVzbGEuYnpcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaW5jLmNvbVwiLFxuICAgIFwiZXRjd2FsbGV0Lm5ldFwiLFxuICAgIFwibWFzdGVyY29pbi50b3BcIixcbiAgICBcImxlZGdlcndhbGxldC54eXpcIixcbiAgICBcImNsYWltLXRva2VuLWVyYzIwLXJld2FyZHMtcHJvZ3JhbS5jb21cIixcbiAgICBcIm1ldGFtYWtzLmlvXCIsXG4gICAgXCJtZXRhZGIub25saW5lXCIsXG4gICAgXCJteWNyeXB0by5tbFwiLFxuICAgIFwibXlldGhlcndhbGxldC5rZXluYXN0eS5jb21cIixcbiAgICBcIndhbGxldHMuY29tcGFueVwiLFxuICAgIFwibXlldGhlcndhbGxldC1lcmMyMHRva2VuLndlZWJseS5jb21cIixcbiAgICBcImJpdGdlbi5wcm9cIixcbiAgICBcIm1ldGFybmFzay5pb1wiLFxuICAgIFwiZ2l2ZWF3YXkucmV2cHJvamVjdC5zaXRlXCIsXG4gICAgXCJlbG9ubXVzay5maW5hbmNpYWxcIixcbiAgICBcImV0aGVyZXVtLXByb21vLnNpdGVcIixcbiAgICBcInNwYWNleGNhc2guY29tXCIsXG4gICAgXCJiZXN0Y2hhbmdlLnJ1blwiLFxuICAgIFwiYXBwbGVnaXZlLmNsdWJcIixcbiAgICBcIm15Y3J5cHRvLmdhXCIsXG4gICAgXCJyZWNvdmVybXljb2lucy5jb21cIixcbiAgICBcIm1ldGEtbWFzay5pb1wiLFxuICAgIFwiZmFvYml0LmNvbVwiLFxuICAgIFwidGVzbGFwcm9tby5vcmdcIixcbiAgICBcInhsbWdldC5vcmdcIixcbiAgICBcIm1ldG1hbWFzay5jb21cIixcbiAgICBcIm1ldGFtYXNrLmluZm9cIixcbiAgICBcIm1ldGFtb3NrLmluZm9cIixcbiAgICBcIm1ldGFtb3NrLmNvbVwiLFxuICAgIFwicGF1Yml0LmNvbVwiLFxuICAgIFwic3BhY2V4Z2l2ZXMuY29tXCIsXG4gICAgXCJldGhlcmV1bWZvbmQuY29tXCIsXG4gICAgXCJhcHAuZnVsY3J1bS5saW5rXCIsXG4gICAgXCJmdWxjcnVtLmxpbmtcIixcbiAgICBcImV0aGRyb3AubmV3c1wiLFxuICAgIFwibWFrZXIuZGFvLm1pZ3JhdGUuY2xhaW1zXCIsXG4gICAgXCJtaWdyYXRlLmNsYWltc1wiLFxuICAgIFwicHJvbW9tdXNrLm1lXCIsXG4gICAgXCJteWVodGVyd2FsdGV0LmNvbVwiLFxuICAgIFwic3BhY2V4LnNhbGVcIixcbiAgICBcInBpdXRyYWRlLmNvbVwiLFxuICAgIFwibXl0aWV0aGVydnZlYWxsZXQuY29tXCIsXG4gICAgXCJnbXNzdGF0aXN0aWNzLmNvbVwiLFxuICAgIFwieW9sYml0LmNvbVwiLFxuICAgIFwicmV3YXJkcy1ob2xkZXJzLWVyYzIwLXRva2Vucy5jb21cIixcbiAgICBcInRhYXMuZnVuZC5yZXdhcmRzLWhvbGRlcnMtZXJjMjAtdG9rZW5zLmNvbVwiLFxuICAgIFwic3BhY2V4Z2l2ZWF3YXkuY29tXCIsXG4gICAgXCJldGhkcm9wLm9yZ1wiLFxuICAgIFwicHJldGhib251cy5jb21cIixcbiAgICBcImV0aHByb21vLm5ld3NcIixcbiAgICBcInByb2V0aGV2ZW50LmNvbVwiLFxuICAgIFwiYmV6b3N4YnQuY29tXCIsXG4gICAgXCJlcmMtMjAub25saW5lXCIsXG4gICAgXCJldGhldmVudC51c1wiLFxuICAgIFwiZXRoZ2lmdC5jb21cIixcbiAgICBcInRlc2xhZ2l2ZXMuY29tXCIsXG4gICAgXCJzcGFjZXguYnpcIixcbiAgICBcInJld2FyZHMtcHJvZ3JhbS1lcmMtMjAtdG9rZW4uY29tXCIsXG4gICAgXCJnbHliaXQuY29tXCIsXG4gICAgXCJhcHJpbGNvbnRlc3QudHVtYmxyLmNvbVwiLFxuICAgIFwiYmV6b3MueHl6XCIsXG4gICAgXCJ4bi0tdHJzdHdhbGxldC1vZGIuY29tXCIsXG4gICAgXCIxMHhiaXRjb2luLm5ldC5kZWVwcHJvZml0c3RyZWFtcy5jb21cIixcbiAgICBcImVsb25saXZlLm9yZ1wiLFxuICAgIFwicHJvbW9jb2luYmFzZS54eXpcIixcbiAgICBcIm15ZWx0aGVybXdhbGxldC5jb21cIixcbiAgICBcImFzc2V0LWVyYy0yMC10b2tlbi5jb21cIixcbiAgICBcImRhb3N0YWNrLmFzc2V0LWVyYy0yMC10b2tlbi5jb21cIixcbiAgICBcImxlYWtlZGJpdGNvaW4uZXhjZWxlcmF0ZS5jby5uelwiLFxuICAgIFwibml4ZXRyYWRlLmNvbVwiLFxuICAgIFwiYml0Y29pbi5jcnlwdG9nZW5lcmF0b3IubGl2ZVwiLFxuICAgIFwiY3J5cHRvZ2VuZXJhdG9yLmxpdmVcIixcbiAgICBcImV0aGVyZXVtLmNyeXB0b2dlbmVyYXRvci5saXZlXCIsXG4gICAgXCJtdXNrdGVzbGEucHJlc3NcIixcbiAgICBcInRlc2xhZHJvcHMuaW5mb1wiLFxuICAgIFwic3BhY2V4Z2lmdHMuaW5mb1wiLFxuICAgIFwieHJwY2xhaW0ubmV0XCIsXG4gICAgXCJtdXNrZnVuZHMuaW5mb1wiLFxuICAgIFwicHJvZXRoLWFwcmlsLWNhbXBhaWduLmNvbVwiLFxuICAgIFwiZXRobm93LnNpdGVcIixcbiAgICBcImJlc3RjcmhhbmdlLnJ1XCIsXG4gICAgXCJob2ZiaXQuY29tXCIsXG4gICAgXCJlbG9uZnVuZC5pbmZvXCIsXG4gICAgXCJkb3VibGV5b3VyYml0Y29pbi5jb21cIixcbiAgICBcImJpdGNvaW5haXJkcm9wLmluZm9cIixcbiAgICBcImVhc3liaXRjb2luLmZ1blwiLFxuICAgIFwic3NvLWdpdGh1Yi5jb21cIixcbiAgICBcImdsdGh1YnMuaW5mb1wiLFxuICAgIFwiZ2l0aGIuY29cIixcbiAgICBcImdpdC1zZWN1cmUtc2VydmljZS5pblwiLFxuICAgIFwid2FsbGV0LnRlcnpjci5jb21cIixcbiAgICBcInRlcnpjci5jb21cIixcbiAgICBcIm11c2tmdW5kLmluZm9cIixcbiAgICBcImV0aGRyb3AubWVcIixcbiAgICBcImxpZmJpdC5jb21cIixcbiAgICBcInRlc2xhZ2l2aW5nLmNvbVwiLFxuICAgIFwidml0YWxpay1ldGguY29tXCIsXG4gICAgXCJwcm9ldGgtZXZlbnQtYXByaWwuY29tXCIsXG4gICAgXCJldGh2ZW50dXJlLmNvbVwiLFxuICAgIFwicmFuZG9taXgub3JnXCIsXG4gICAgXCJnbHQtaHViLmNvbVwiLFxuICAgIFwidHJ1c3Qtd2FsbGV0Lm1lXCIsXG4gICAgXCJ0cnVzdHdvbGxldC5jb21cIixcbiAgICBcInhuLS1ibG5uY2UteWM4Yi5jb21cIixcbiAgICBcImNvaW5iYXNlLmZ1bmRcIixcbiAgICBcImxvZ2luLmJsY29oY2hhbG4uY29tXCIsXG4gICAgXCJibGNvaGNoYWxuLmNvbVwiLFxuICAgIFwid2FsbGV0LmJsb2NrY2hhbG4uY29tcGFueVwiLFxuICAgIFwidGlmYml0LmNvbVwiLFxuICAgIFwidW5nbGVkZXIubm9cIixcbiAgICBcImxvZ2luLXRyZXpvci5pb1wiLFxuICAgIFwidHJlem9yeS5zaXRlXCIsXG4gICAgXCJldGhhaXJkcm9wcy5jb21cIixcbiAgICBcInJlZXRoZXIuc3RvcmVcIixcbiAgICBcImV0aGxpdmUub3JnXCIsXG4gICAgXCJ0ZXNsYW11c2sub25saW5lXCIsXG4gICAgXCJ0ZXNsYXgudGVjaFwiLFxuICAgIFwidGVzbGF4LnN0b3JlXCIsXG4gICAgXCJldGhjaGFpbi5naWZ0XCIsXG4gICAgXCJjb2luYmFzZXRvZGF5LmluZm9cIixcbiAgICBcImJpbmFuY2UuY29tMTg5NTQ3NjEuaW5mb1wiLFxuICAgIFwiY29tMTg5NTQ3NjEuaW5mb1wiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZS5jb21cIixcbiAgICBcImNvaW5iYXNlMngucHJvXCIsXG4gICAgXCJjb2luYmFzZWdpdmUuaW5mb1wiLFxuICAgIFwiY29pbmJhc2Vkcm9wLmluZm9cIixcbiAgICBcInRyYWRpbmctYmluYW5jZS5jb21cIixcbiAgICBcImNvaW5iYXNlLmRlcG9zaXQtYWxsb3cuY29tXCIsXG4gICAgXCJkZXBvc2l0LWFsbG93LmNvbVwiLFxuICAgIFwiY29pbmJhc2V2ZXJpZnkueHl6XCIsXG4gICAgXCJjb2luYmFzZS5wcm8tZGVwb3NpdC5jb21cIixcbiAgICBcInByby1kZXBvc2l0LmNvbVwiLFxuICAgIFwiY29pbmJhc2UyeC51c1wiLFxuICAgIFwiY29pbmJhc2UtYml0Y29pbi50ZWNoXCIsXG4gICAgXCJiaXRjb2luY29kZS50ZWNoXCIsXG4gICAgXCJjb2luYmFzZWpvaW4uaW5mb1wiLFxuICAgIFwiY29pbmJhc2UtYXNzaXN0LmNvbVwiLFxuICAgIFwid2FsbGV0LnRyY3pvci5jb21cIixcbiAgICBcInRyY3pvci5jb21cIixcbiAgICBcInRlbGVncmFtY3J5cHRvLm5ldFwiLFxuICAgIFwiYmxva2NoYWxuZS5pbmZvXCIsXG4gICAgXCJldGhlcnVtLmdpdmVhd2F5LWNvaW5iYXNlLmNvbVwiLFxuICAgIFwiYml0Y29pbi5naXZlYXdheS1jb2luYmFzZS5jb21cIixcbiAgICBcImdpdmVhd2F5LWNvaW5iYXNlLmNvbVwiLFxuICAgIFwiamF4eHVwZGF0ZXN1cHBvcnQuY29tXCIsXG4gICAgXCJ0cnVzdGNvaW4uZXhjaGFuZ2VcIixcbiAgICBcImRvdWJsZXdheS5yZi5nZFwiLFxuICAgIFwieHRpYml0LmNvbVwiLFxuICAgIFwiY3J5cHRvLWNyb3duLmx0ZFwiLFxuICAgIFwiZmVleC5leGNoYW5nZVwiLFxuICAgIFwibXVza3Rlc2xhLnByb1wiLFxuICAgIFwiYmVzdGNoYW5nZS5ydS5iaXRjb2luLXNiZXJiYW5rLm9ubGluZVwiLFxuICAgIFwic3BhY2V4bXVzay5pbmZvXCIsXG4gICAgXCJtdXNrbm93LmluZm9cIixcbiAgICBcInplcmlvbnRyYWRlLmlvXCIsXG4gICAgXCJyb3piaXQuY29tXCIsXG4gICAgXCJteWxlZGdlcm5hbm8uY29tXCIsXG4gICAgXCJjb21wbGV0c3NsLmNvbVwiLFxuICAgIFwiYml0Y29pbnN5c3RlbS1hcHAuY29tXCIsXG4gICAgXCJ4bi0teXRoZXJhbGxldC10bzJlOTRheXIuY29tXCIsXG4gICAgXCJ0ZXNsYW11c2sucHJvXCIsXG4gICAgXCJtdXNrZ2V0LmluZm9cIixcbiAgICBcImJpdC1jb2ludmVzdG9yLmNvbVwiLFxuICAgIFwiYmVzdGNocm5nZS5ydVwiLFxuICAgIFwid2FsbGV0LWNvaW5vbWktZ2l2ZWF3YXkuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcInRydXN0d2FsbGV0LmJpelwiLFxuICAgIFwibGVkZ2Vyd2ViLmFpXCIsXG4gICAgXCJzcGFjZXguYmV0XCIsXG4gICAgXCJlbG9ubXVzay5tYXJrZXRcIixcbiAgICBcInRlc2xhZXZlbnQucHJvXCIsXG4gICAgXCJnYXRlc2ZyZWUuY29tXCIsXG4gICAgXCJtdXNrZ2l2ZS5pbmZvXCIsXG4gICAgXCJzcGFjZXgud29ybGRcIixcbiAgICBcImJlc3Rjb2lucy5pbmZvXCIsXG4gICAgXCJ0ZXNsYW11c2suZ3JvdXBcIixcbiAgICBcImdhdGVzbGl2ZS50ZWNoXCIsXG4gICAgXCJiaWxsZ2F0ZXMuY2FwaXRhbFwiLFxuICAgIFwidHJ1bXBidGMudGVjaFwiLFxuICAgIFwiYmV6b3Ntb25leS5uZXRcIixcbiAgICBcInNsbXBsZXN3YXAuc2l0ZVwiLFxuICAgIFwiYmVzdGNoYW5nZS5zcGFjZVwiLFxuICAgIFwiamF4eC5saXZlXCIsXG4gICAgXCJhdG9taWN3YWxsZXQubHRkXCIsXG4gICAgXCJjcnlwdG9uZnguY29tXCIsXG4gICAgXCJxcmNvZGVidGMuY29tXCIsXG4gICAgXCJ2aWFidGMtdHJhbnNhY3Rpb24tYWNjZWxlcmF0b3IuY29tXCIsXG4gICAgXCJiaXRjb2lucy1xci1jb2RlLmNvbVwiLFxuICAgIFwiY3JlYXRlLWJpdGNvaW4tcXItY29kZS5jb21cIixcbiAgICBcImxvZ2luLmJsY29rY2hhbG4udG9wXCIsXG4gICAgXCJibGNva2NoYWxuLnRvcFwiLFxuICAgIFwiYml0Y29pbmdlbmVyYXRvcnNvbmxpbmUuY29tXCIsXG4gICAgXCJiaXRtdXNrLm5ldFwiLFxuICAgIFwic3VwcG9ydHZlLWNvaW5iYXNlLmljdS5kcmVhbWNlbnRlcmludGVybmF0aW9uYWwub3JnXCIsXG4gICAgXCJiaW5hbmNlLmNvbTE4Mjc2Mzc0OC5pbmZvXCIsXG4gICAgXCJjb20xODI3NjM3NDguaW5mb1wiLFxuICAgIFwiYml0Y29pbmRvdWJsZXIyeC5jb21cIixcbiAgICBcImJlem9zYml0LmNvbVwiLFxuICAgIFwidGVzbGFiZXN0LmluZm9cIixcbiAgICBcImJtZ2ZldmVudC5jb21cIixcbiAgICBcIm1pZ3JhdGUuZnVuZFwiLFxuICAgIFwibWFrZXIuZGFvLm1pZ3JhdGUuZnVuZFwiLFxuICAgIFwiZ2V0bmV3YnRjLmNvbVwiLFxuICAgIFwibWRsMy50b3BcIixcbiAgICBcImJpdGNvaW5nZW5lcmF0Lm9ubGluZVwiLFxuICAgIFwiYmluYW5jZS1kZXguYXBwXCIsXG4gICAgXCJmcmVlLWJpdGNvaW4tcXItY29kZXMuY29tXCIsXG4gICAgXCJiaXRjb2luYWRkcmVzc3RvcXJjb2RlLmNvbVwiLFxuICAgIFwiYmluYW5jZXByb2ZpdC5jb21cIixcbiAgICBcIngyYml0Y29pbi5pbmZvXCIsXG4gICAgXCJxci1jb2RlLWJpdGNvaW4uY29tXCIsXG4gICAgXCJmcmVlYml0Y29pbnFyY29kZXMuY29tXCIsXG4gICAgXCJmcmVld2FsbGV0Z2l2ZWF3YXkuY29tXCIsXG4gICAgXCJldGgtdG8tYnRjLWNvbnZlcnRlci5jb21cIixcbiAgICBcImJpdGNvaW4tdHJhbnNhY3Rpb24tYWNjZWxlcmF0b3IuY29tXCIsXG4gICAgXCJ0cmFuc2FjdGlvbi1hY2NlbGVyYXRvci5jb21cIixcbiAgICBcImJ0Yy10by1xci5jb21cIixcbiAgICBcImJpdGNvaW4tdHgtdHJhbnNhY3Rpb24tYWNjZWxlcmF0b3IuY29tXCIsXG4gICAgXCJiaXRjb2luLWJhcmNvZGUtZ2VuZXJhdG9yLmNvbVwiLFxuICAgIFwibXVza2dpdmluZy5jb21cIixcbiAgICBcImNvaW5iYXNlLmNvbS5uZXJ2by5jby56YVwiLFxuICAgIFwiYml0Y29pbi1lbGVjdHJ1bS5tZVwiLFxuICAgIFwiYml0Y29pbmVsb24uY29tXCIsXG4gICAgXCJiaXRjb2lucGF5b3V0Lm5ldFwiLFxuICAgIFwiYml0Y29pbmZvcm1lLm5ldFwiLFxuICAgIFwiY29tLWJpdGNvaW5zLmNvbVwiLFxuICAgIFwiZWxvbi1tdXNrLm9ubGluZVwiLFxuICAgIFwiYmluYW5jZS1naXZlZXRoLm9ubGluZVwiLFxuICAgIFwiYml0Y29pbmVsZWN0cnVtLmNvXCIsXG4gICAgXCJtb3JlZnJlZWJpdGNvaW4uY29tXCIsXG4gICAgXCJlbG9ueGNvaW4uaW5mb1wiLFxuICAgIFwiYmluYW5jZS5jb20xNTg3Njg0NzEuaW5mb1wiLFxuICAgIFwiNHhycC5vcmdcIixcbiAgICBcImNuaXBtaXhlci5jb21cIixcbiAgICBcImJsaW9ja2xjaGFpbi5jb21cIixcbiAgICBcImxvZ2luLWJsb2NrY2hhbmluLmNvbVwiLFxuICAgIFwiZXZlbnRjcnlwdG8ubWVcIixcbiAgICBcImV2ZW50Y3J5cHRvLm5ldFwiLFxuICAgIFwibXVza2dpdmluZy5pbmZvXCIsXG4gICAgXCJiZXN0Y2hhZ25lLnJ1XCIsXG4gICAgXCJzcGFjZXguZXhwZXJ0XCIsXG4gICAgXCJldmVudGNyeXB0by5vcmdcIixcbiAgICBcImJpdGNvaW5taW5lcnByby55ai5mclwiLFxuICAgIFwibWVyY2Fkb2JpdGNvaW4udGVjaFwiLFxuICAgIFwiZWxvbm5ld3Mub25saW5lXCIsXG4gICAgXCJ0aGViaXRjb2luLWNvZGUubmV0XCIsXG4gICAgXCJiaXRjb2luZWxlY3RydW0ud3NcIixcbiAgICBcImJpdGNvaW4tZWxlY3RydW0ub3JnXCIsXG4gICAgXCJiaXRjb2lucmlzaW5nLm5ldFwiLFxuICAgIFwid3d3LmxvZ2luLmNvaW5iYXNlLmNvbS1zcmMuY2dpLWJpbi5jb2xuYmFzZS5zaXRlXCIsXG4gICAgXCJjb2xuYmFzZS5zaXRlXCIsXG4gICAgXCJiaXRjb2luZ2l2ZXMuaW5mb1wiLFxuICAgIFwieG4tLXRyZW9yLTdoYi5jb21cIixcbiAgICBcIndhbGxldHMtdHJlem9yLmlvXCIsXG4gICAgXCJtdXNrYml0Y29pbi5pbmZvXCIsXG4gICAgXCJiaXRjb2lubXVzay5pbmZvXCIsXG4gICAgXCJtYXRpY2JpdC5jb21cIixcbiAgICBcIm11c2stcHJvbW8ucHJvXCIsXG4gICAgXCJ0bWRsMy5zcGFjZVwiLFxuICAgIFwic3BhY2V4LnByZXNzXCIsXG4gICAgXCJzcGFjZWdhaW5zLmluZm9cIixcbiAgICBcImxpYnJhc2VjdXJlLm5ldFwiLFxuICAgIFwiYmxjb2tjbG5hbG4uY29tXCIsXG4gICAgXCJ4bi0tbG9jYWxiaWNvaW5zLWpjYy5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxlLW8xMmVqOGFjYS5jb21cIixcbiAgICBcImxlZGdlci1saXZlLmNvbVwiLFxuICAgIFwidGVzbGFiaXRjb2luLmluZm9cIixcbiAgICBcImJpbmFuY2UtZXRocHJvbW8udGVjaFwiLFxuICAgIFwibXVzazQuZnVuXCIsXG4gICAgXCJlbG9udGVhbS5zcGFjZVwiLFxuICAgIFwibXVza2dpdmUub3JnXCIsXG4gICAgXCJzcGFjZWJpdGNvaW4uaW5mb1wiLFxuICAgIFwibXVza2ZyZWUubmV0XCIsXG4gICAgXCJ0ZXNsYWRyb3Auc3BhY2VcIixcbiAgICBcImJ0Y2ZtaW5lci5vbmxpbmVcIixcbiAgICBcImxlZGdlcmhhbHZpbmcuY29tXCIsXG4gICAgXCJidGNldGh0ZXNsYS5pbmZvXCIsXG4gICAgXCJtdXNrZXZlbnQucHJvXCIsXG4gICAgXCJtdXNrYnRjLm5ldFwiLFxuICAgIFwiZ3JhbS1tYXJjaC5jb21cIixcbiAgICBcInJpdmJpdC5jb21cIixcbiAgICBcImJ0Y3plYWwuY29tXCIsXG4gICAgXCJyYWZiaXQuY29tXCIsXG4gICAgXCJsb3JlY2hhbmdlLmNvbVwiLFxuICAgIFwicm9jc2JpdC5jb21cIixcbiAgICBcImJsZXJiaXQuY29tXCIsXG4gICAgXCJidGNldGhwcm9tby5pbmZvXCIsXG4gICAgXCJlbG9uZXRoLm9yZ1wiLFxuICAgIFwiYnRjd2VibWluZXIuc2l0ZVwiLFxuICAgIFwiMzAwZG9sbGFyc2RhaWx5LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZXRoLmluZm9cIixcbiAgICBcIjRtdXNrLnRvcFwiLFxuICAgIFwiZWxvbm11c2tnaXZlLm5ldFwiLFxuICAgIFwibXVza3Byb21vLmNsb3VkXCIsXG4gICAgXCJsb2dpbi1ibDBja2NoYWluLmNvbVwiLFxuICAgIFwibWluZWJpdGNvaW4uY2x1YlwiLFxuICAgIFwieG4tLWxvY2FiaXRjb2lucy1nY2MuY29tXCIsXG4gICAgXCJidGNtdXNrLm5ldFwiLFxuICAgIFwidGVzbGFldmVudC5vbmxpbmVcIixcbiAgICBcImVsb25saXZlLmNvbVwiLFxuICAgIFwiYnRjZWxvbi5jb21cIixcbiAgICBcInRlc2xhbGl2ZS5vbmxpbmVcIixcbiAgICBcInRlc2xhZ29vZHMuaW5mb1wiLFxuICAgIFwibXVzazIwLmNvbVwiLFxuICAgIFwiZ3JhbXB1YmxpYy5jb21cIixcbiAgICBcInFvbG9uaWV4LmNvbVwiLFxuICAgIFwieG4tLWNocG1peGVyLTMxYS5jb21cIixcbiAgICBcInRlc2xhdGVhbS5uZXRcIixcbiAgICBcInRlc2xhd2FsbGV0LmluZm9cIixcbiAgICBcIm1vZGVsMy5wd1wiLFxuICAgIFwiZXRoZXJldW0tZ2lmdC5uZW9jaXRpZXMub3JnXCIsXG4gICAgXCJiZXN0Y29pbi5sdGRcIixcbiAgICBcImNoYW5nZXF1aWNrLnNlcnZpY2VzXCIsXG4gICAgXCJ4bi0tYmVzdGNobmctNXphNjJjLm5ldFwiLFxuICAgIFwibmV0MjRleC5jbHViXCIsXG4gICAgXCJpZGV4LW1hcmtldC5uZXRcIixcbiAgICBcImZ1bGNydW0uY2xhaW1zXCIsXG4gICAgXCJlbG9ubXVzay5iZXRcIixcbiAgICBcImVsb25tdXNrLnByb21vXCIsXG4gICAgXCJ0ZXNsYWdpdmVzLmluZm9cIixcbiAgICBcIm11c2twcm9tby5wcmVzc1wiLFxuICAgIFwic3BhY2V0ZXNsYS5pbmZvXCIsXG4gICAgXCJiaXRjb2luYS51c1wiLFxuICAgIFwibmV4dXMtY3J5cHRvLmNvbVwiLFxuICAgIFwieG4tLWJlc3RjaGFnLWNlYjIwYy5uZXRcIixcbiAgICBcInhuLS1ic3RjaGFnLXQ4YWcyMGMubmV0XCIsXG4gICAgXCJ4bi0tYnN0Y2hhZ2UtNGRiOTBjLm5ldFwiLFxuICAgIFwieG4tLWJzdGNoYW4tdDhhZzNoLm5ldFwiLFxuICAgIFwieG4tLWJ0Y2hhbmdlLTRkYjQ5ZC5uZXRcIixcbiAgICBcInhuLS1ic3RjaGFnLXQ4YWcyNmIubmV0XCIsXG4gICAgXCJ4bi0tYmVzdGNoYWctY2ViMjZiLm5ldFwiLFxuICAgIFwieG4tLWJldGNoYW5nLWNlYjc4dy5uZXRcIixcbiAgICBcImV2ZW50bXVzay5jb21cIixcbiAgICBcInNwYWNlZHJvcHMuaW5mb1wiLFxuICAgIFwibW9vbnRyYWRlLm9yZ1wiLFxuICAgIFwibW9vbnRyYWRlLmhlcm9rdWFwcC5jb21cIixcbiAgICBcImJ0Y3ZpcC5uZXRcIixcbiAgICBcIjR0ZXNsYS50b3BcIixcbiAgICBcIm15ZWhldGVycndhbGxldC5jb21cIixcbiAgICBcImV4b2R1cy5jb20ucnVcIixcbiAgICBcImxvZ2xuLWJsY29rY2hpYW4uY29tXCIsXG4gICAgXCJnZXRsaWJyYS5jY1wiLFxuICAgIFwibXVza2V2ZW50LmluZm9cIixcbiAgICBcIm11c2twcmVzZW50LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZXRoLmx0ZFwiLFxuICAgIFwiYi1wcm9tby5vbmxpbmVcIixcbiAgICBcImVsb24yMDIwLm9ubGluZVwiLFxuICAgIFwibXVzay1haXJkcm9wLm9ubGluZVwiLFxuICAgIFwieG4tLWJzdGNoYW5nLWIxYTE0Yi5jb21cIixcbiAgICBcImJlc3RjaGFucmdlLm5ldFwiLFxuICAgIFwiYml0LWV4aGNhbmdlci54bi0tci05Z2EubmV0XCIsXG4gICAgXCJ4bi0tYmVzdGhhZ2UtNDlhLmNvbVwiLFxuICAgIFwiYmVzcmNoYW5nZS5ydVwiLFxuICAgIFwiZWxvbi1naXZlLm9ubGluZVwiLFxuICAgIFwic3BhY2V4Ym9udXMuaW5mb1wiLFxuICAgIFwiZWxvbm11c2sud29ybGRcIixcbiAgICBcInNwYWNleGRyb3AuaW5mb1wiLFxuICAgIFwiYm9udXN0ZXNsYS5jb21cIixcbiAgICBcIm11c2tkcm9wLmNvbVwiLFxuICAgIFwidGVzbGFwcmVzZW50LmNvbVwiLFxuICAgIFwibGNnaW4ueG4tLWJjb2tjaGFuLTZvYjkwNzZlLmNvbVwiLFxuICAgIFwieG4tLWJjb2tjaGFuLTZvYjkwNzZlLmNvbVwiLFxuICAgIFwieG4tLWJzdGNoYS0zdWE1OWFyZDhwLm5ldFwiLFxuICAgIFwiY2hhbmdlcXVpY2submV0d29ya1wiLFxuICAgIFwiMjRuZXRleC5saWZlXCIsXG4gICAgXCJzaWduaW4uYmxvY2tjaGFsbi5jb20uMThzZWN1cmUuaG9zdFwiLFxuICAgIFwiYmxvY2tjaGFsbi5jb20uMThzZWN1cmUuaG9zdFwiLFxuICAgIFwieG4tLWJlc3RjaGFnZS1oeGIuY29tXCIsXG4gICAgXCJ4bi0tYnN0Y2hhbmUtM2NiMGkuY29tXCIsXG4gICAgXCJiZXN0Y2hhbmdlLnJ1NGJlc3RjaGFuZ2UucnVcIixcbiAgICBcImJlc3RjaGFuZ2UucnU1YmVzdGNoYW5nZS5ydVwiLFxuICAgIFwiYmVzdGNoYW5yZ2UuY29tXCIsXG4gICAgXCJ4bi0tYmVzdGNhbmdlLTRtYi5jb21cIixcbiAgICBcImFpci1kcm9wLWNvaW5iYXNlLmNvbVwiLFxuICAgIFwiZHJvcHRlc2xhLmNvbVwiLFxuICAgIFwiZWxvbngtc3BhY2UuY29tXCIsXG4gICAgXCJleG9kdXMub25sXCIsXG4gICAgXCJsZWRnZXIuaWN1XCIsXG4gICAgXCJhcmFnb25naWZ0LmxpdmVcIixcbiAgICBcInZlcnRvY29pbnMuY29tXCIsXG4gICAgXCJsZWRnZXIuZ21iaFwiLFxuICAgIFwiY29pbmJhc2UtYWlyLWRyb3AuY29tXCIsXG4gICAgXCJidGN3ZWJtaW5lci50cmFkZVwiLFxuICAgIFwibWluZWJpdGNvaW4ub25saW5lXCIsXG4gICAgXCJmcmVzaC1taW5pbmcuY29tXCIsXG4gICAgXCJ4YXNobWluaW5nLmNvbVwiLFxuICAgIFwic3BhY2Vwcml6ZS5pbmZvXCIsXG4gICAgXCJlbG9ueHNwYWNlLmNvbVwiLFxuICAgIFwibWV0YWxmYWJwcm8uY29tXCIsXG4gICAgXCJkb25hbGRjcnlwdG8uY29tXCIsXG4gICAgXCJkb3VibGVyLnRvXCIsXG4gICAgXCJ4bi0tYnN0Y2hhbmctM2NiaC5jb21cIixcbiAgICBcInhuLS1iZXRoYWUtazJhMnAybDVnLm5ldFwiLFxuICAgIFwiZWxvbnhwcm9tby5jb21cIixcbiAgICBcInJ1Z2dnYmVzdGNoYW5nZS5ydVwiLFxuICAgIFwiYmluYW5jZWV0aC5zcGFjZVwiLFxuICAgIFwic3BhY2Vib251cy5pbmZvXCIsXG4gICAgXCJjaGFuZ2VxdWljay5kaWdpdGFsXCIsXG4gICAgXCJjb2luLWJlc3QuaW5mb1wiLFxuICAgIFwiMzY1Y2FzaC50b2RheVwiLFxuICAgIFwieG4tLWV0eDI0LTd6YTA0YS5uZXRcIixcbiAgICBcInRyZXJvei5pb1wiLFxuICAgIFwibXlic3Z3YWxsZXQub3JnXCIsXG4gICAgXCJnZXR4cnAub3JnXCIsXG4gICAgXCJ4cnAtYWlyZHJvcC5uZXRcIixcbiAgICBcImpheHgud3NcIixcbiAgICBcImV4b2R1cy13YWxsZXQub3JnXCIsXG4gICAgXCJsZWRnZXIuaW5rXCIsXG4gICAgXCJqYXh4LXdhbGxldC5jb21cIixcbiAgICBcIndlYmxlZGdlci5kZXZcIixcbiAgICBcImxlZGdlcndhbGxldC5saWZlXCIsXG4gICAgXCJib251c3BhY2V4LmNvbVwiLFxuICAgIFwibXVza3NlY3JldC5pbmZvXCIsXG4gICAgXCJlbG9uY3J5cHRvLmlvXCIsXG4gICAgXCJ4bi0tYnRoYS1icGFkMXNraTBraTdlLm5ldFwiLFxuICAgIFwiZXRoZXItYmluYW5jZS5vbmxpbmVcIixcbiAgICBcImJlc3RjaHNhbmdlcy5jb21cIixcbiAgICBcImxlZGdlci13ZWJ3YWxsZXQuY29tXCIsXG4gICAgXCJ4cnAyMDIwLm5ldFwiLFxuICAgIFwiZ3JpbWViaXQuY29tXCIsXG4gICAgXCJjcmFpZ3NlY3JldC5jb21cIixcbiAgICBcImV0aGVyZXVtcHJvLmV1XCIsXG4gICAgXCJlYXJuMnhldGhub3cuY29tXCIsXG4gICAgXCJ0ZXNsYW5ld3MubGlmZVwiLFxuICAgIFwid2VibGVkZ2VyLnByb1wiLFxuICAgIFwiZWxvbmdpZnRwcm9tby5jb21cIixcbiAgICBcImVsb25wcm9tby5uZXRcIixcbiAgICBcImVsb25naXZpbmcubmV0XCIsXG4gICAgXCJ5dXNha3UyMDIwLm9yZ1wiLFxuICAgIFwiZWxvbnByb21vLm9ubGluZVwiLFxuICAgIFwidmF6ZWJpdC5jb21cIixcbiAgICBcImJlbGRleGN1cnJlbmN5LmNvbVwiLFxuICAgIFwiZWxvbnByb21vLnRlY2hcIixcbiAgICBcInhuLS1uZXR4MjQtcjNhLm5ldFwiLFxuICAgIFwibXVzazIwMjAuZnVuXCIsXG4gICAgXCJ4bi0tYmVzY2hhbmdlLWQ1Yi5jb21cIixcbiAgICBcInhuLS1iZXRoYWUtZDFhMHVybDdpLm5ldFwiLFxuICAgIFwiYmVzdGNoYW5nZS5jb21iZXN0Y2hhbmdlLnJ1XCIsXG4gICAgXCJ0ZXNsYWRyb3AuaW5mb1wiLFxuICAgIFwic2VjcmV0bXVzay5jb21cIixcbiAgICBcImN5YmVydHJ1Y2sud29ya1wiLFxuICAgIFwiYm9udXNtdXNrLmNvbVwiLFxuICAgIFwibWFrZXIuZGFvLm1pZ3JhdGUubHRkXCIsXG4gICAgXCJtYWtlci5taWdyYXRlLnRvb2xzXCIsXG4gICAgXCJjb25uZWN0Lm1ha2VyLm1pZ3JhdGUudG9vbHNcIixcbiAgICBcInN3YXAubWFrZXJkYW8uZ3VpZGVcIixcbiAgICBcImNvbm5lY3QubWFrZXIuZGFvLm1pZ3JhdGUubHRkXCIsXG4gICAgXCJtaWdyYXRlLm1ha2VyZGFvLmd1aWRlXCIsXG4gICAgXCJtYWtlcmRhby5ndWlkZVwiLFxuICAgIFwibWFrZXJkYW8uY2FyZVwiLFxuICAgIFwibWlncmF0ZS50b29sc1wiLFxuICAgIFwibWlncmF0ZS5sdGRcIixcbiAgICBcInJpcHBsZS5naWZ0XCIsXG4gICAgXCJsb2dpbi5ibGNvbGtjaGFsbi5jb21cIixcbiAgICBcImJsY29sa2NoYWxuLmNvbVwiLFxuICAgIFwiYmxjY2tjaGxlbi5jb21cIixcbiAgICBcInRyZXpvci5pby13YWxsZXQuY29tXCIsXG4gICAgXCJpby13YWxsZXQuY29tXCIsXG4gICAgXCJ4bi0tbG9jYWxiaXRjaW5zLXZjZC5uZXRcIixcbiAgICBcInJhemViaXQuY29tXCIsXG4gICAgXCJpbmZpbml2aS5pb1wiLFxuICAgIFwiYnl0ZXRyYWRlLmNvbVwiLFxuICAgIFwiYnl0ZXRyYWRlLmlvXCIsXG4gICAgXCJjZ2VuLmZyLmZvXCIsXG4gICAgXCJjcnlwdG90YWJzY3JpcHQub25saW5lXCIsXG4gICAgXCJjcnlwdG90YWJzY3JpcHRzLmNvbVwiLFxuICAgIFwid2FsbGV0LmJsb2NrY25haW4udGVjaFwiLFxuICAgIFwiYmxvY2tjbmFpbi50ZWNoXCIsXG4gICAgXCJleG9kdXNhcHAubGlmZVwiLFxuICAgIFwibGVkZ2Vyd2ViLmxpZmVcIixcbiAgICBcImFpcmRyb3AtZXRoZXJldW0uY29tXCIsXG4gICAgXCJ3YWxsZXQuYmxvY2tjbmFpbi5iaXpcIixcbiAgICBcImxvZ2luLmJsb2NrY2hhbG4uY29tLmF0dHAuaG9zdFwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5uYW1lXCIsXG4gICAgXCJzdHJhaW5iaXQuY29tXCIsXG4gICAgXCJiZW5yaWJpdC5jb21cIixcbiAgICBcInBsZWluYml0LmNvbVwiLFxuICAgIFwiZWxvbi52aXBcIixcbiAgICBcImVsb25wcm9tb2dpZnQuY29tXCIsXG4gICAgXCJsYXplYml0LmNvbVwiLFxuICAgIFwiZWxvbi5wcmVzc1wiLFxuICAgIFwidGVzbGFwcm9tby5uZXRcIixcbiAgICBcInRlc2xhZ2l2ZS5uZXRcIixcbiAgICBcInRlc2xhZ2l2ZS52aXBcIixcbiAgICBcImVsb24ubGl2ZVwiLFxuICAgIFwibXVzay5iZXRcIixcbiAgICBcImJlbGRleHRyYWRlLmNvbVwiLFxuICAgIFwibXVzazIwMjAuc2l0ZVwiLFxuICAgIFwic2hhcGVzaGlmdGUueHl6XCIsXG4gICAgXCJsb2dpbi5ibG9ja2NoYWxuLmNvbXBhbnlcIixcbiAgICBcImJsb2NrY2hhbG4uY29tcGFueVwiLFxuICAgIFwibG9naW4uYmxvY2tjaGFsbi5jb20uMTRzZWN1cmUuaG9zdFwiLFxuICAgIFwiYmxvY2tjaGFsbi5jb20uMTRzZWN1cmUuaG9zdFwiLFxuICAgIFwiYmxvY2tjaGFsbi5jb20uMTNzZWN1cmUuaG9zdFwiLFxuICAgIFwiYnRjZXRoZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJtdXNrcHJvbW8uY29tXCIsXG4gICAgXCJlbG9ueGdpdmUub25saW5lXCIsXG4gICAgXCJ0ZXNsYWNvaW5zLmNsdWJcIixcbiAgICBcIm11c2tnaWZ0LmNvbVwiLFxuICAgIFwiYnRjLWdlbi5zaXRlXCIsXG4gICAgXCJtYWtlcmRhby5sdGRcIixcbiAgICBcInhuLS1iZXRjaG5nZS1kemEwNWoubmV0XCIsXG4gICAgXCJ4bi0tZXRleDI0LXZmYi5uZXRcIixcbiAgICBcInNlcmlvc2JpdC5jb21cIixcbiAgICBcImVsb25idGMuaW5mb1wiLFxuICAgIFwibWFrZXJkYW8ubGxjXCIsXG4gICAgXCJtYWtlcmRhby5vbmVcIixcbiAgICBcIm1pZ3JhdGUubWFrZXJkYW8ub25lXCIsXG4gICAgXCJtYWtlcmRhby5jYXNoXCIsXG4gICAgXCJtaWdyYXRlLm1ha2VyZGFvLmNhc2hcIixcbiAgICBcIm1hZXphd2FvdG9zaGlkYW1hLmluZm9cIixcbiAgICBcImxyZXpvci5pb1wiLFxuICAgIFwiaW5zdGFudDJ4cmV3YXJkLmNvbVwiLFxuICAgIFwibWFrZXJkYW8uY2xpY2tcIixcbiAgICBcImVsb25haXJkcm9wLmNvbVwiLFxuICAgIFwid2FsbGV0LmJsb2NrY2hhbG4ubGxjXCIsXG4gICAgXCJibG9ja2NoYWxuLmxsY1wiLFxuICAgIFwibG9naW4uYmxvY2tjaGFsbi5jb20uMTZzZWN1cmUuaG9zdFwiLFxuICAgIFwiYmxvY2tjaGFsbi5jb20uMTZzZWN1cmUuaG9zdFwiLFxuICAgIFwibG9naW4tYmxvY2tjaGFpbi1jb20ubmxcIixcbiAgICBcImJlbGRleGNoYW5nZS5jb21cIixcbiAgICBcImJlc3RjaGFuZ3JlLnJ1XCIsXG4gICAgXCJiaXQtY2hhbmdlci5ydVwiLFxuICAgIFwidml0YWxpa2V0aC5saXZlXCIsXG4gICAgXCI0bXVzay5ob3N0XCIsXG4gICAgXCJlbG9ueGdpdmUuY29tXCIsXG4gICAgXCJlbG9uZ2l2ZS5saXZlXCIsXG4gICAgXCJtdXNrZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJ0aGV0YXRva2VuLmdxXCIsXG4gICAgXCJlbG9ueGNyeXB0by5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2V0LWJoYjY0ZWEuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbHUuY29tXCIsXG4gICAgXCJibG9rY2hpYWluLmNvbVwiLFxuICAgIFwidml0YWxpa2V0aC5jb21cIixcbiAgICBcImhveGJpdC5jb21cIixcbiAgICBcImZyZWUtZXRoZXJldW0uaW9cIixcbiAgICBcImVsb24ubWFya2V0XCIsXG4gICAgXCJ0bWRsMy5vbmxpbmVcIixcbiAgICBcIm11bHRpc3VwcG9ydC5saXZlXCIsXG4gICAgXCJodW9iaWdsb2JhbC5saXZlXCIsXG4gICAgXCJpbmZpbmFuY2VzLmNvbVwiLFxuICAgIFwicXVha2ViaXQuY29tXCIsXG4gICAgXCJldGNhZ2hhcnRhLm9yZ1wiLFxuICAgIFwid2FsbGV0LmV0Y2FnaGFydGEub3JnXCIsXG4gICAgXCJtYWtlcmRhby50b29sc1wiLFxuICAgIFwidG1kbDMuY29tcGFueVwiLFxuICAgIFwibG9naW4tYmxvY2tjaGFpbi5jb20uYnJcIixcbiAgICBcImJ0Y2dlbnBsdXMuZnIuZm9cIixcbiAgICBcIm11c2suYmxvZ1wiLFxuICAgIFwiZWxvbnhkcm9wLmNvbVwiLFxuICAgIFwidGVzbGEuZ2lmdFwiLFxuICAgIFwiZ2VuZXJhdG9yYXBwLmNmXCIsXG4gICAgXCJ4bi0tYmVzY2huZS1wY2IyNHRtMzVqLm5ldFwiLFxuICAgIFwiYnRjLXByby5ydVwiLFxuICAgIFwieG4tLWJzdGhuZ2Uta3dhM2R5cy5uZXRcIixcbiAgICBcImNhc2gzNjUubWVcIixcbiAgICBcInhuLS1ldGV4MjQtaGViLm5ldFwiLFxuICAgIFwieG4tLWJzdGhuZ2Uta3dhNDVhbWYubmV0XCIsXG4gICAgXCJ4bi0tYmV0aGdlLWsyYTc4YjlnbTc4eS5uZXRcIixcbiAgICBcImNhc2gzNjUuY2NcIixcbiAgICBcInhuLS1iZWNobmdlLXJxYjg4bm0yMW0ubmV0XCIsXG4gICAgXCJ4bi0tbmV0eDI0LXJ2YS5uZXRcIixcbiAgICBcIjM2NWNhc2guY2FzaFwiLFxuICAgIFwieG4tLWJldGNoZ2UtNGtiMTlwNzUxbC5uZXRcIixcbiAgICBcImJlc3QtY29pbi52aXBcIixcbiAgICBcImNoYW5nZS1xdWljay51c1wiLFxuICAgIFwieG4tLW50ZXgyNC1wdmEubmV0XCIsXG4gICAgXCJldGhkcm9wY2hhcml0eS50ZWNoXCIsXG4gICAgXCJjaGFuZ2UtcXVpY2sudmlwXCIsXG4gICAgXCJjYXNoLWkueHl6XCIsXG4gICAgXCJjb2luYmVzdC51c1wiLFxuICAgIFwieG4tLXRyZXpyLXl1YS5jb21cIixcbiAgICBcImJlc3J0Y2hhbmdlLnJ1XCIsXG4gICAgXCJ4bi0tYmVzdGhuZy1sd2E0NWF0Zi5uZXRcIixcbiAgICBcImNvaW5iZXN0LmNjXCIsXG4gICAgXCJxdWlja2NoYW5nZS52aXBcIixcbiAgICBcIjM2NWNhc2gudXNcIixcbiAgICBcInhuLS1iZXRobmdlLWt3YTQ1YTI0YS5uZXRcIixcbiAgICBcInhuLS1uZWV4MjQtam1jLm5ldFwiLFxuICAgIFwibXVza2Z1bi5pbmZvXCIsXG4gICAgXCJlbG9ucHJlc2VudC5jb21cIixcbiAgICBcIm1ha2VyZGFvLmxpdmVcIixcbiAgICBcIm1pZ3JhdGUubWFrZXJkYW8ubGl2ZVwiLFxuICAgIFwiYmVsZGV4d2FsbGV0LmNvbVwiLFxuICAgIFwieG4tLWJzdGhhbmdlLW1iYjFoLm5ldFwiLFxuICAgIFwieG4tLWJlc2NobmctbHdhMjBjdjdmLm5ldFwiLFxuICAgIFwieG4tLWJzdGhuZy1zdGE2MWF6ZWgubmV0XCIsXG4gICAgXCJjb2luLWJlc3QubWVcIixcbiAgICBcInF1aWNrLWNoYW5nZS5jb1wiLFxuICAgIFwiMzY1Y2FzaC5tb2JpXCIsXG4gICAgXCJpLWNhc2gubGlua1wiLFxuICAgIFwieG4tLWV0ZXgyNC05ZWIubmV0XCIsXG4gICAgXCJiaXRjb2lubWluZXIyeC5jb21cIixcbiAgICBcImJsb2NrY2hhaW4tc2NyaXB0Lm5ldFwiLFxuICAgIFwiYnRjLWdlbi5jb21cIixcbiAgICBcImJpdGNvaW5taW5pbmctcHJvLnNvZnR3YXJlXCIsXG4gICAgXCJsaXNhbmUuZ3FcIixcbiAgICBcInNoaXRjb2lud2FsbGV0LmNvXCIsXG4gICAgXCJlcmMyMHdhbGxldC50a1wiLFxuICAgIFwiY2FwaXRhbGJpdHNpbnZlc3RtZW50cy5jb21cIixcbiAgICBcImJlc3QtY29pbi53b3JsZFwiLFxuICAgIFwiZWxvbmNocmlzLmNvbVwiLFxuICAgIFwieG4tLWJldGhhbmUtNzRhOXcwdi5uZXRcIixcbiAgICBcInhuLS1iZXN0aGFnLWh5YTQzYW11Lm5ldFwiLFxuICAgIFwieG4tLWJldGNoYWUtcGNiODJhN2kubmV0XCIsXG4gICAgXCJ4bi0tYmV0Y2hhZ2UtZHFiOXIubmV0XCIsXG4gICAgXCJldGgtZ2l2ZW91dC5jb21cIixcbiAgICBcInhuLS1iZXRoYWdlLTc0YTM4Y2ppLm5ldFwiLFxuICAgIFwieG4tLWJldGhhZ2UtNzRhMzhjbmcubmV0XCIsXG4gICAgXCJ4bi0tYmV0aGFnZS03NGE1NmMzaS5uZXRcIixcbiAgICBcInhuLS1iZXN0aGFuZS0zOGE3ei5uZXRcIixcbiAgICBcInhuLS1iZXN0aG5nZS1kemEyOWEubmV0XCIsXG4gICAgXCJ4bi0tYnN0aGFuZ2UtMjhhMW4ubmV0XCIsXG4gICAgXCJ4bi0tYnN0aGFuZ2UtYjFhNjFhLm5ldFwiLFxuICAgIFwieG4tLWJlc3RjaG5nLWV6YTZlLm5ldFwiLFxuICAgIFwieG4tLWJlc3RobmctbHdhODBieWUubmV0XCIsXG4gICAgXCJ4bi0tYmVzdGhuZy1sd2E5ZHp1Lm5ldFwiLFxuICAgIFwieG4tLWJldGNobmctbHdhOWQ0M2UubmV0XCIsXG4gICAgXCJ4bi0tYnN0aGFuZy1sNmExZ2gubmV0XCIsXG4gICAgXCJ4bi0tYmVzdGNoYWctODBhMmcubmV0XCIsXG4gICAgXCJ4bi0tYmVzdGhhbmctbmJiOGgubmV0XCIsXG4gICAgXCJ4bi0tYmVzdGhhbmctdjBhODNjLm5ldFwiLFxuICAgIFwieG4tLWJzdGNoYWctMnhhMGd1dC5uZXRcIixcbiAgICBcInhuLS1ic3RjaGFnLTJ4YWcyZy5uZXRcIixcbiAgICBcInhuLS1ic3RjaGFnLTl6YTA1YWhhLm5ldFwiLFxuICAgIFwiY2FzaDM2NS52aXBcIixcbiAgICBcInhuLS1ic3RjaGFnZS0xMGE5Zy5uZXRcIixcbiAgICBcImktY2hhbmdlLmNvXCIsXG4gICAgXCJpLWNhc2guY2NcIixcbiAgICBcImJsb2NrY2hhaW5zY3JpcHQubmV0XCIsXG4gICAgXCJjcnlwdG90YWJzY3JpcHQuY29tXCIsXG4gICAgXCJtdWx0aWNvaW5taW5lci5mdW5kXCIsXG4gICAgXCJ4bi0tbXlldGVyd2FldC1oMGJhdS5jb21cIixcbiAgICBcImxvZ2luLmJsY29ya2NoZWluLmNvbVwiLFxuICAgIFwiYmxjb3JrY2hlaW4uY29tXCIsXG4gICAgXCJjb2luYmFzZS14bWFzLmNvbVwiLFxuICAgIFwieG1hc2dpdmUuaW5mb1wiLFxuICAgIFwidHJlem9yLndvcmxkXCIsXG4gICAgXCJ4bi0tdHJ6ci1jcGE3ZS5jb21cIixcbiAgICBcInJpcHBsZWxhYnMuc3BhY2VcIixcbiAgICBcImVsb25jaHJpc3RtYXMuY29tXCIsXG4gICAgXCJjb2luYmFzZXhtYXMuY29tXCIsXG4gICAgXCJ4bWFzYnRjLmNvbVwiLFxuICAgIFwieG4tLWJlc3RoYWdlLTM4YTYyZC5uZXRcIixcbiAgICBcInhuLS1iZXRoYW5nZS0yOGEyNWYubmV0XCIsXG4gICAgXCJpLWNoYW5nZS5vbmxpbmVcIixcbiAgICBcImNoYW5nZS1xdWljay54eXpcIixcbiAgICBcImVsb25jaHJpc3RtYXMubmV0XCIsXG4gICAgXCJlbG9ueG1hcy5uZXRcIixcbiAgICBcImxsZWRnZXIuaW9cIixcbiAgICBcImxlZWRnZXIuaW9cIixcbiAgICBcIm1jYWZlZWNocmlzdG1hcy5uZXRcIixcbiAgICBcIm1jYWZlZTIwMjAueHl6XCIsXG4gICAgXCJlbXVzay5ob3N0XCIsXG4gICAgXCJtdXNrLm9uZVwiLFxuICAgIFwiYWlyZHJvcHhycC5jb21cIixcbiAgICBcImJpdGNvaW54MTAuY2xvdWRhY2Nlc3MuaG9zdFwiLFxuICAgIFwieHJwZG91Ymxlci51c1wiLFxuICAgIFwic2hvcHpvcm8uY28udWtcIixcbiAgICBcInhycGNocmlzdG1hcy5jb21cIixcbiAgICBcInRyZXpvcnMuaW9cIixcbiAgICBcImJsb2NrY2hhaW5zZXZlbnQuY2xhaW0tZnJlZS1idGMuY29tXCIsXG4gICAgXCJhaXJkcm9wLXN0eC1ibG9ja2NoYWluLmluZm9cIixcbiAgICBcImNvaW5iYXNlLXByb21vLmluZm9cIixcbiAgICBcImxvZ2luLmxibG9ja2hjb2luLmNvbVwiLFxuICAgIFwibGJsb2NraGNvaW4uY29tXCIsXG4gICAgXCJsb2dpbi1ibGxvY2tjaGFpbi5jb21cIixcbiAgICBcImJyZXN0Y2hhbmdlLnJ1XCIsXG4gICAgXCJzaXRlLWJsb2NrY2hhaW4uamRldmNsb3VkLmNvbVwiLFxuICAgIFwibXllaHRlcndhbGx0ZXQuaW5mb1wiLFxuICAgIFwibGFzdGNoYW5jZS50ZWNoXCIsXG4gICAgXCJldGhlcmZseWVyLmNvbS5jbGFpbS10b2tlbnMtZXJjLTIwLmNvbVwiLFxuICAgIFwiY2xhaW0tdG9rZW5zLWVyYy0yMC5jb21cIixcbiAgICBcInRyZXpvcnMtd2FsbGV0cy5jb21cIixcbiAgICBcImVsb25naWZ0Y3J5cHRvLmNvbVwiLFxuICAgIFwiaW5zdGFuYnRjLnNpdGVcIixcbiAgICBcImZyZWViaXRjb2lubWluZXIub3JnXCIsXG4gICAgXCJiaXRjb2lubWluZXItcG9vbC5jb21cIixcbiAgICBcImJpdGNvaW5mYXN0Lnh5elwiLFxuICAgIFwiYml0Y29pbnBvb2xtaW5pbmcueHl6XCIsXG4gICAgXCJsb2dpbi5sYmxvY2xrY2hvaW4uY29tXCIsXG4gICAgXCJsYmxvY2xrY2hvaW4uY29tXCIsXG4gICAgXCJkb3VibGVidGMzaG91cnMuY29tXCIsXG4gICAgXCJtdWx0aWJpdC5hcHBcIixcbiAgICBcImZyZWVidGNtaW5lci5vcmdcIixcbiAgICBcImJ0Y2dlbmVyYXRvci5wcm9cIixcbiAgICBcImdpdmVhd2F5NTAwMC5jb21cIixcbiAgICBcImJpb2NrY2hvaW4uaW5mb1wiLFxuICAgIFwiYmxvY2stY2hhaW4taWQuam9vbWxhLmNvbVwiLFxuICAgIFwiYml0dHJleC15ZHMuY29tXCIsXG4gICAgXCJybmplbGhlcndhbGxldC5jb21cIixcbiAgICBcImJ0Y2ZyZWUucHJvXCIsXG4gICAgXCJjb2luYmFzZWdpdmUubmV0XCIsXG4gICAgXCJzdGVsbGFyZHJvcC5jb21cIixcbiAgICBcIm1lcmNhdG94Mnhib251cy5jb21cIixcbiAgICBcImJpdGNvaW5kb3VibGVyLnRlY2hcIixcbiAgICBcInVwZ3JhZGVzYWkyZGFpLmNvbVwiLFxuICAgIFwieG4tLWJzdGNobmdlLW5lYjgxNzZlLm5ldFwiLFxuICAgIFwieG4tLWJlc3RjaGdlLWRxYjM2MjZlLm5ldFwiLFxuICAgIFwieG4tLWJzdGNoYW5lLTEwYTAxZC5uZXRcIixcbiAgICBcInN0ZWxsYXIudXMuY29tXCIsXG4gICAgXCJjb2luYmFzZTEyLmluZm9cIixcbiAgICBcImNhc2gtY29pbmJhc2UuY29tXCIsXG4gICAgXCJjb2luYmFzZS1jYXNoLmNvbVwiLFxuICAgIFwiZWxvbmJpei5ob3N0XCIsXG4gICAgXCJidGNmYXN0bWluaW5nLnh5elwiLFxuICAgIFwibXVzay1idGMuY29tXCIsXG4gICAgXCJlbG9uYm9udXMuaW5mb1wiLFxuICAgIFwidHJlemdyLmlvXCIsXG4gICAgXCJ3YWxsZXQudHJyZXpvci5jb21cIixcbiAgICBcInRycmV6b3IuY29tXCIsXG4gICAgXCJ4bi0tYmVzdGNhbmdlLXU4NWQuY29tXCIsXG4gICAgXCJ4bi0tYnN0Y2hhbmdlLTAzYS5jb21cIixcbiAgICBcInhuLS1iZXN0Y2hhbmctODNhLmNvbVwiLFxuICAgIFwieG4tLWJlc3RobmdlLTQ5YTU1ODZlLm5ldFwiLFxuICAgIFwiYmVsZGV4Y29pbnMuY29tXCIsXG4gICAgXCJtY2FmZWVnaXZlYXdheS5jb21cIixcbiAgICBcImJ0Yy1vbi5jb21cIixcbiAgICBcInJpcHBsZS1naWZ0cy5vbmxpbmVcIixcbiAgICBcImNvaW5iYXNlZ3JhbnQuY29tXCIsXG4gICAgXCJidGMtcHJpemUuY29tXCIsXG4gICAgXCJ0cmV6Y29yLmNvbVwiLFxuICAgIFwidHJlem9yLWlvLmNvXCIsXG4gICAgXCJ3YWxsZXQudHJlem9yLWlvLmNvXCIsXG4gICAgXCJ4cnAyMDIwLmNvbVwiLFxuICAgIFwibWNhZmVlMjAyMC5vbmxpbmVcIixcbiAgICBcImJ0Yy1jb2luLm9ubGluZVwiLFxuICAgIFwiY29pbmJhc2VjLmNvbVwiLFxuICAgIFwiY29pbmJhc2U1MG0uY29tXCIsXG4gICAgXCJyaXBwbGUtYWlyZHJvcC5vcmdcIixcbiAgICBcImJ0Y211c3QuY29tXCIsXG4gICAgXCJlbG9ubXVza2dvLmNvbVwiLFxuICAgIFwiYm5iZ2lmdC5pbmZvXCIsXG4gICAgXCJiaW5hbmNlZ2l2ZWF3YXkuc2l0ZVwiLFxuICAgIFwiZXJjLTIwLXRva2VuLmNvbVwiLFxuICAgIFwic2FpMmRhaS5wcm9cIixcbiAgICBcIm11c2tuZXdzLmluZm9cIixcbiAgICBcIndhbGxldC50cmV6b3JlLmlvXCIsXG4gICAgXCJ0cmV6b3JlLmlvXCIsXG4gICAgXCJjb2luYmFzZWdvLmNvbVwiLFxuICAgIFwidHJvbm5ldC5uZXR3b3JrXCIsXG4gICAgXCJ4cnBsaWtlLmNvbVwiLFxuICAgIFwiem4tLXRyZXpyLW11YS5jb21cIixcbiAgICBcImxlZHFlci5uZXRcIixcbiAgICBcImxlZGdlcnMuY29tXCIsXG4gICAgXCJ4bi0tYmVzdGNoYW5lLXhrYi5jb21cIixcbiAgICBcImdpdmV4cnAubmV0XCIsXG4gICAgXCIyMDIwbWNhZmVlLmluZm9cIixcbiAgICBcInVwYml0Y29pbi5pbmZvXCIsXG4gICAgXCJ4bi0tYmVzdGNoYW5lLTJsYi5jb21cIixcbiAgICBcInhuLS1iZXRjaGFuZ2UtdzFiLmNvbVwiLFxuICAgIFwic2FpMmRhaS5saW5rXCIsXG4gICAgXCJ4bXJxcmNvZGUuY29tXCIsXG4gICAgXCJib251c2J0Yy5uZXRcIixcbiAgICBcImhpdGJyYy5ydVwiLFxuICAgIFwiZ2VtaW5pZXRoLmNvbVwiLFxuICAgIFwiZS1kZWFscy5vbmxpbmVcIixcbiAgICBcImJ0YzUweC5pbmZvXCIsXG4gICAgXCJ0ZXNsYS0zLm9ubGluZVwiLFxuICAgIFwiZWxvbmJpei5zaXRlXCIsXG4gICAgXCJjb2luYmFzZXVwLmNvbVwiLFxuICAgIFwibG9naW4uYmlsb2NrY2hvaW4uY29tXCIsXG4gICAgXCJiaWxvY2tjaG9pbi5jb21cIixcbiAgICBcImJpdHRyZXh0aGFua2dpdmluZy5jb21cIixcbiAgICBcImFpcmRyb3BleC5zaXRlXCIsXG4gICAgXCJteWNoYWlubGluay5vcmdcIixcbiAgICBcInhuLS1iZXRjaGFuZS1kZ2I4NGQuY29tXCIsXG4gICAgXCJiaWdnZXN0LWFpcmRyb3AudG9wXCIsXG4gICAgXCJkYWkyc2FpLmV4Y2hhbmdlXCIsXG4gICAgXCJzYWkyZGFpLmV4Y2hhbmdlXCIsXG4gICAgXCJhaXJkcm9wZGV4LnNpdGVcIixcbiAgICBcInhuLS10cmVvci13aWIuY29tXCIsXG4gICAgXCJ0cmVyem9yLmlvXCIsXG4gICAgXCJidGNnaWZ0LnByb1wiLFxuICAgIFwiY2xhaW0tc3RlbGxhci5pbmZvXCIsXG4gICAgXCJjb2luYmFzZTVrLmNvbVwiLFxuICAgIFwicmVjZWlwdC5pbnZvaWNlLnJld2FyZC1ldGhlcmV1bS5jZlwiLFxuICAgIFwicmV3YXJkLWV0aGVyZXVtLmNmXCIsXG4gICAgXCJyZWNlaXB0Lmludm9pY2UuZXRoLXJlZmVycmFsLWFpcmRyb3AubWxcIixcbiAgICBcImV0aC1yZWZlcnJhbC1haXJkcm9wLm1sXCIsXG4gICAgXCJlbGVja2N0cnVtLm9yZ1wiLFxuICAgIFwiZGFpMnNhaS5hcHBcIixcbiAgICBcInNhaS10by1kYWkuY29tXCIsXG4gICAgXCIzbWRsLnNwYWNlXCIsXG4gICAgXCJ6aWxsaXFhLW5ldHdvcmsuY29tXCIsXG4gICAgXCJnZW1pbmlldGgubGl2ZVwiLFxuICAgIFwiZnJlZWJ0Yy1kcm9wLmxpdmVcIixcbiAgICBcInhuLS1iZXN0Y2hhZ2UtMXZiLm5ldFwiLFxuICAgIFwieG4tLWJzdGNoYW5nZS0waWIubmV0XCIsXG4gICAgXCJ4bi0tYmV0Y2hhbmdlLTEyYi5jb21cIixcbiAgICBcInhuLS1iZXRjaGFuZS1kZ2I4NGQubmV0XCIsXG4gICAgXCJ4bi0tYmVzdGhhbmdlLWplYi5jb21cIixcbiAgICBcImxlZGdyZS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtZ2V0ZXh0cmF0b2tlbi4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwidHJpZXpvci5pb1wiLFxuICAgIFwibGRleG1hcmtldC5ydS5jb21cIixcbiAgICBcIm1hcmdpbmV0aC5vbmxpbmVcIixcbiAgICBcImJsb29tLnJld2FyZC1wcm9ncmFtcy5lcmMyMC10b2tlbnMuY29tXCIsXG4gICAgXCJlcmMyMC10b2tlbnMuY29tXCIsXG4gICAgXCJleGNoYW5nZS5ibmJkZXgudG9wXCIsXG4gICAgXCJibmJkZXgudG9wXCIsXG4gICAgXCJ3YWxsZXQtdGhldGF0b2tlbi1leHRyYWJvbnVzZXMuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcIndhbGxldC10aGV0YXRva2VuLWNsYWltLWV4dHJhLWJvbnVzZXMuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcIndhbGxldC10aGV0YXRva2VuLWJvbnVzZXMuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcIndhbGxldC10aGV0YXRva2VuLWV4dHJhYm9udXNlcy1lcmMyMC4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwiZ2V0LWV4dHJhLnRrXCIsXG4gICAgXCJuZXh0LmdldC1leHRyYS50a1wiLFxuICAgIFwibXlldGhlcndhbGxldC1nZXRmcmVldG9rZW4uMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcImdldC1leHRyYS5tbFwiLFxuICAgIFwibXlldGhlcndhbGxldC5yZWtsbGFtYS5jb21cIixcbiAgICBcInZpbnRhZ2UtbXlldGhlcndhbGxldC50ZWxlZ3JhbS1haXJkcm9wLmNvbVwiLFxuICAgIFwidGVsZWdyYW0tYWlyZHJvcC5jb21cIixcbiAgICBcImNvaW54YmFjay5jb21cIixcbiAgICBcImNyeXB0b2Nsb3VkeC5jb21cIixcbiAgICBcInNhaXRvZGFpLmFwcFwiLFxuICAgIFwiY3J5cHRvYmFjay5vcmdcIixcbiAgICBcInRyZXpvci5ielwiLFxuICAgIFwid2FsbGV0LnRyZXpvci5ielwiLFxuICAgIFwiYmVkc3RjaGFuZ2UucHAucnVcIixcbiAgICBcInhuLS1iZXN0Y2huZ2UtNTFhLm5ldFwiLFxuICAgIFwieG4tLWJldGNoYW5nZS02bGQubmV0XCIsXG4gICAgXCIzbWRsLnB3XCIsXG4gICAgXCJ0cmV6b3ItaW5mby13YWxsZXQubXVzaWNmZXN0ZXMuY29tXCIsXG4gICAgXCJtdXNrYm9udXMuaW5mb1wiLFxuICAgIFwiY3liZXItdGVzbGEuY29tXCIsXG4gICAgXCIzbWRsLnByb1wiLFxuICAgIFwibGRleG1hcmtldC54eXpcIixcbiAgICBcImJ0YzVrLmNvbVwiLFxuICAgIFwiY3J5cHRvLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwibGRleG1hcmtldC5pbmZvXCIsXG4gICAgXCJtdXNrZ2l2ZXMuaW5mb1wiLFxuICAgIFwiYml0bXVzay5pbmZvXCIsXG4gICAgXCIyMDIwYnRjLnNpdGVcIixcbiAgICBcIm1ldy1vZmZsY2xhbC5pbmZvXCIsXG4gICAgXCJ4bi0tYmVzdGNoYWdlLW13Yi5uZXRcIixcbiAgICBcImJlc3RjaGFuZ2UucGFnZVwiLFxuICAgIFwicmV3YXJkLWNyeXB0by5jb21cIixcbiAgICBcInNwYWNleGJpdC5uZXRcIixcbiAgICBcInNwYWNleGJpdC5pbmZvXCIsXG4gICAgXCJ0ZXJlem9yLmlvXCIsXG4gICAgXCJ3YWxsZXQudGVyZXpvci5pb1wiLFxuICAgIFwidHJlZXpvci5pb1wiLFxuICAgIFwiZWxvbm11c2tnaWZ0LmNvbVwiLFxuICAgIFwidHJlem9yLXdhbGxldHMuY2NcIixcbiAgICBcInRycmV6b3IuaW9cIixcbiAgICBcInRyZXpvci5wcm9tb1wiLFxuICAgIFwiZWlsZWN0dW0ub3JnXCIsXG4gICAgXCJsZXJnZXIuY2ZcIixcbiAgICBcImxvY2FsYml0Y29pbnMuY29tLjBmZmljaWFsLWxvY2FsYml0Y29pbnMud2Vic2l0ZVwiLFxuICAgIFwiMGZmaWNpYWwtbG9jYWxiaXRjb2lucy53ZWJzaXRlXCIsXG4gICAgXCJvZmZpY2lhbC1sb2NhbGJqdGNvaW5zLndlYnNpdGVcIixcbiAgICBcIm1ld215ZXRoZXJ3YWxsZXRzLmNvbVwiLFxuICAgIFwib2ZmaWNpYWwtbWNhZmVlLm1lXCIsXG4gICAgXCJlbG9uYm9udXMuY29tXCIsXG4gICAgXCJpZGV4LW1hcmtldC5zcGFjZVwiLFxuICAgIFwic2FpMmRhaS5jb21cIixcbiAgICBcIndhbGxldC50cmV6Y3IuY29tXCIsXG4gICAgXCJ0cmV6Y3IuY29tXCIsXG4gICAgXCJuZW9zbWFydGVjb25vbXkubmV0bGlmeS5jb21cIixcbiAgICBcImxlZWRnZXIuaW5mb1wiLFxuICAgIFwib3ZkYW4uY29tXCIsXG4gICAgXCJsZWdkZXIuY29cIixcbiAgICBcInhuLS10cmV6ci1ndWEuY29tXCIsXG4gICAgXCJibG9ja2NoYWluLmluZm8ucmVrbGxhbWEuY29tXCIsXG4gICAgXCJsb2dpbi5ibG9ja2hpZWFuLmNvbVwiLFxuICAgIFwiYmxvY2toaWVhbi5jb21cIixcbiAgICBcImVodGVyZGVsdGEucnUuY29tXCIsXG4gICAgXCJiaW5hbmNlLWN6LXByb21vLm5ldGxpZnkuY29tXCIsXG4gICAgXCJyaXBwbGUub29vXCIsXG4gICAgXCJjaGFpbmxpbmt0b2tlbi5uZXRcIixcbiAgICBcImNoYWlubGluay1pbmZvLnByb1wiLFxuICAgIFwiY2xhaW0tZXJjMjAtdG9rZW4tYm9udXMuZ2FcIixcbiAgICBcImJhbmNvci1uZXR3b3JrLmdhXCIsXG4gICAgXCJjcnlwdG8tcmV3YXJkLmNvbVwiLFxuICAgIFwiaW50cmVuYXRpb25hbC5ianRmdHJleC5jb21cIixcbiAgICBcImJqdGZ0cmV4LmNvbVwiLFxuICAgIFwiMnhib251cy5saXZlXCIsXG4gICAgXCJjb2luYmFzZXRlYW0uY29tXCIsXG4gICAgXCJpZGV4LW1hcmtldC5pbmZvXCIsXG4gICAgXCJnZXRldGguc2l0ZVwiLFxuICAgIFwiYmluYW5jZWZ1dHVyZXMub25saW5lXCIsXG4gICAgXCJjcnlwdG8tZ2VuZXJhdC5tbFwiLFxuICAgIFwibXlldGhlcndhbGxldC1naXZlYXdheS4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwiZXh0cmEtYm9udXNlcy5nYVwiLFxuICAgIFwib2ZmaWNpYWwtZXRoZXJzLmNvbVwiLFxuICAgIFwibG9naW4uYmxsb2NraGFpaW4uY29tXCIsXG4gICAgXCJibGxvY2toYWlpbi5jb21cIixcbiAgICBcImlkZXhtYXJrZXQuYXJ0XCIsXG4gICAgXCJoZWxsb2dvbGQuaW5cIixcbiAgICBcInN0ZWVtZXRoLmNvbVwiLFxuICAgIFwiYmVlbnRyYWRlLm9yZ1wiLFxuICAgIFwiY29pbnNwaW4ubmV0XCIsXG4gICAgXCJiaXRsYXJlLmNvbVwiLFxuICAgIFwidW5pLXBvdWNoLmNvbVwiLFxuICAgIFwiZWxvbi1nZXQuY29tXCIsXG4gICAgXCJsaXRlLmZvdW5kYXRpb25cIixcbiAgICBcInJpcHBsZS5leHBlcnRcIixcbiAgICBcIjN0ZXNsYS5pbmZvXCIsXG4gICAgXCJjb2luc21heC5saXZlXCIsXG4gICAgXCI0bHRjLnN1XCIsXG4gICAgXCJnZXQteHJwLm9ubGluZVwiLFxuICAgIFwiZnJlZWJ0Y2V0aC5jb21cIixcbiAgICBcIndwLmxvY2FsbGJpdHRjb2lucy5uZXRcIixcbiAgICBcImxvY2FsbGJpdHRjb2lucy5uZXRcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtZXh0cmEtYm9udXNlcy4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwiZXh0cmEtYm9udXNlcy5ncVwiLFxuICAgIFwibmV4dC5leHRyYS1ib251c2VzLmdxXCIsXG4gICAgXCJkZXgtc3RhcnQubmV0XCIsXG4gICAgXCJ0ZXNsYW11c2suaW5mb1wiLFxuICAgIFwiM3Rlc2xhLmNsdWJcIixcbiAgICBcImVsb25tdXNrLnRrXCIsXG4gICAgXCJldGhlcnNhd2F5Lm5ldFwiLFxuICAgIFwidHJ5LWV0aGVycy5jb21cIixcbiAgICBcInRlc2xhMy5saW5rXCIsXG4gICAgXCJlbG9uLWNyeXB0by5tZVwiLFxuICAgIFwiZXRoLWdldC5vcmdcIixcbiAgICBcImV0aHBsb2RlLmxpdmVcIixcbiAgICBcIm15Z3JhbS5wcm9cIixcbiAgICBcImdyYW1zYWxlLm9yZ1wiLFxuICAgIFwibWMyMDIwZ2V0LmNvbVwiLFxuICAgIFwibWNmLWNyeXB0Lm5ldFwiLFxuICAgIFwiNHRlc2xhLmJpelwiLFxuICAgIFwiZWxvbi1jcnlwdG8ub25saW5lXCIsXG4gICAgXCJ0ZXNsYTMtbm93LmNvbVwiLFxuICAgIFwibW9kZWwzLnNwYWNlXCIsXG4gICAgXCJtY2FmZWUtY3J5cHRvLmNvbVwiLFxuICAgIFwiZWxvbi1jcnlwdG8ubmV0XCIsXG4gICAgXCI0dGVzbGEucHJvXCIsXG4gICAgXCJlbG9udGVzbGEuaW5mb1wiLFxuICAgIFwidGVzbGEzLnByb21vXCIsXG4gICAgXCJjaGlhbmxpbmsuaW9cIixcbiAgICBcIndhbGxldC5jaGlhbmxpbmsuaW9cIixcbiAgICBcImNsYWltbGluay5vcmdcIixcbiAgICBcIndhbGxldC5jaGlhbmxpbmsub3JnXCIsXG4gICAgXCJjaGlhbmxpbmsub3JnXCIsXG4gICAgXCJ3YWxsZXQueG4tLWNoYWlubGlrLW85OWMuY29tXCIsXG4gICAgXCJ4bi0tY2hhaW5saWstbzk5Yy5jb21cIixcbiAgICBcImVhcm54cnAubGl2ZVwiLFxuICAgIFwidHJvbi1uZXR3b3JrLmxpdmVcIixcbiAgICBcImJ0Yy10aXRhbi5jb21cIixcbiAgICBcInVtaW5lci5uZXRcIixcbiAgICBcIjJ4Y29pbi5saXZlXCIsXG4gICAgXCJtdWx0aWNvaW5zbWluZXIuZnVuZFwiLFxuICAgIFwiY2xhaW1idGMub3JnXCIsXG4gICAgXCJlbG9uc3BhY2Uub25saW5lXCIsXG4gICAgXCJ4cnBpbnNpZ2h0cy5saXZlXCIsXG4gICAgXCJldGhhZ2V0LmNvbVwiLFxuICAgIFwiY29pbnhrZWVwLmNvbVwiLFxuICAgIFwiY3JhdmV0cmFkZS5jb21cIixcbiAgICBcImludmVzdG1lbnR3b3JsZC5zaXRlXCIsXG4gICAgXCJib25kaW52ZXN0LnNpdGVcIixcbiAgICBcImxpZGV4Lm1hcmtldFwiLFxuICAgIFwiYmluYW5jZWJuYmdpdmUuY29tXCIsXG4gICAgXCJldGgtY2hhcml0eS50ZWNoXCIsXG4gICAgXCJ0b25wcmVzYWxlLmNvbVwiLFxuICAgIFwiZXRoZ2V0Lm9yZ1wiLFxuICAgIFwiaWxkZXguaG9zdFwiLFxuICAgIFwiYmxpdHRyZXguaW50cmVuYXRpb25hbC5jb21cIixcbiAgICBcImxjZ2luLWJsb2NrY2hpYW4uY29tXCIsXG4gICAgXCJibGNvbGNoaWFuLmxjZ2lsbi5jb21cIixcbiAgICBcImxjZ2lsbi5jb21cIixcbiAgICBcImJsb2Nja2NoYWlubi5jb21cIixcbiAgICBcImJpbmFuY2UuYm5ibmV0d29yay5pY3VcIixcbiAgICBcImJuYm5ldHdvcmsuaWN1XCIsXG4gICAgXCJldGhlcmV1bWZyZWVtaW5pbmcuY29tXCIsXG4gICAgXCJleGNoYW5nZS5qZXJzZXlyZWxlYXNlLnNlcnZpY2VzXCIsXG4gICAgXCJqZXJzZXlyZWxlYXNlLnNlcnZpY2VzXCIsXG4gICAgXCJiaW5hbmNlLmplcnNleXRyYWRlLmljdVwiLFxuICAgIFwiamVyc2V5dHJhZGUuaWN1XCIsXG4gICAgXCJjaGlhbmxpbmsuY29tXCIsXG4gICAgXCJ3YWxsZXQuY2hpYW5saW5rLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2xucy5uZXRcIixcbiAgICBcImJpbmFuY2UubWFya2V0amVyc2V5LmljdVwiLFxuICAgIFwicmlwcGxlaW5zaWdodHMubGl2ZVwiLFxuICAgIFwiY3J5cHRvZ3Jvd3RoLmxpdmVcIixcbiAgICBcImxvZ2luLmJsb2xvY2toYWluLmljdVwiLFxuICAgIFwiYmxvbG9ja2hhaW4uaWN1XCIsXG4gICAgXCJlaHRlcmRlbHRhLmhvc3RcIixcbiAgICBcInRoZWxpYnJhc2FsZS5jb21cIixcbiAgICBcInhuLS1sb2dpbi1ibG9ja2NoYW4td2o1aC5jb21cIixcbiAgICBcInhuLS1sb2dpbi1ibG9ja2Nobi1kbWI3OWEuY29tXCIsXG4gICAgXCJidGNnZW4uaW9cIixcbiAgICBcInRyeC1ldGhnaXZlYXdheS5jb21cIixcbiAgICBcImthcmxrZW4uY29tXCIsXG4gICAgXCJiaWx0dHJleC5pbnRyZW5hdGlvbmFsLmNvbVwiLFxuICAgIFwiaW50cmVuYXRpb25hbC5jb21cIixcbiAgICBcInVwYml0Z2lmdC5jb21cIixcbiAgICBcInhycGRyb3AuZnVuXCIsXG4gICAgXCJyaXBwbGVpbnNpZ2h0cy50ZWNoXCIsXG4gICAgXCJsb2dpbi5ibG9sY2tjaGFsbi5jb21cIixcbiAgICBcImJsb2xja2NoYWxuLmNvbVwiLFxuICAgIFwiYmxjb2xjaGlhbi5sY2dqcm4uY29tXCIsXG4gICAgXCJsY2dqcm4uY29tXCIsXG4gICAgXCJ4bi0tbGVkZXIteTFhLmNvbVwiLFxuICAgIFwibG9naW4tYmxvY2tjaGFpbi5jb20ubXhcIixcbiAgICBcInF1aWNraW52LmNvbVwiLFxuICAgIFwibWNhZmVlLXByaXplLm9ubGluZVwiLFxuICAgIFwiYmFra3QtZXZlbnQtc3RhcnQubmV0bGlmeS5jb21cIixcbiAgICBcInNwYWNleGJpdC5jb21cIixcbiAgICBcInVucnVmZmxlZC1zaG9ja2xleS0xZGI0OTEubmV0bGlmeS5jb21cIixcbiAgICBcInQzbWQubmV0XCIsXG4gICAgXCJlYXJuYnJvcy5jb21cIixcbiAgICBcIm0yMDIwLm1lXCIsXG4gICAgXCJyaXBwbGVpbnNpZ2h0cy5wcm9cIixcbiAgICBcInRvbi1pY28uY29tXCIsXG4gICAgXCJjbGFpbS1idGMuY29tXCIsXG4gICAgXCJtZWRpdW0tY3J5cHRvLnRlY2hcIixcbiAgICBcImJha2t0Z2lmdC5pbmZvXCIsXG4gICAgXCJjaGFpbmxpbmsud2ViY2luZGFyaW8uY29tXCIsXG4gICAgXCJjb2luYmFzZWNyeXB0by50ZWNoXCIsXG4gICAgXCJ4cnAtcHJvbW8udGVjaFwiLFxuICAgIFwiYmFra3QtY2VsZWJyYXRpb24ubmV0bGlmeS5jb21cIixcbiAgICBcImJvbnVzY29pbmJhc2UuY29tXCIsXG4gICAgXCJiYWtrdC1naXZlLm9yZ1wiLFxuICAgIFwiYmFra3RnZXQuY29tXCIsXG4gICAgXCJiYWtrdC53ei5jelwiLFxuICAgIFwiYnRjZHJvcHMubmV0XCIsXG4gICAgXCJwcm9tb2Jha2t0LmNvbVwiLFxuICAgIFwiYmFra3RsYXVuY2guY29tXCIsXG4gICAgXCJib2xvbGNraGFpbi5jb21cIixcbiAgICBcImxvZ2luLWJsb2Nsa25haW5uLmNvbVwiLFxuICAgIFwibmV3Y3J5cHRvZ2lmdC5jb21cIixcbiAgICBcImRleC1nZXQubmV0XCIsXG4gICAgXCJleHRyYS1yZXdhcmRzLWJvbnVzLmNvbVwiLFxuICAgIFwibXVza2JpdC5jb21cIixcbiAgICBcImJsb2NrY2hhaW41dGguY29tXCIsXG4gICAgXCJsdGRleC5tYXJrZXRcIixcbiAgICBcImRvZ2VjaGFpbi5vcmdcIixcbiAgICBcImV4b2R1cy5pY3VcIixcbiAgICBcInRvbi10ZWxlZ3JhbS5uZXRcIixcbiAgICBcImZyZWViYWtrdC5jb21cIixcbiAgICBcImxpYnJhdG9rZW5zYWxlLmNvbVwiLFxuICAgIFwiZ2V0YmFiYi1jbGFpbXMuZXhjbHVzaXZlLWV4dHJhLWJvbnVzZXMuY29tXCIsXG4gICAgXCJleGNsdXNpdmUtZXh0cmEtYm9udXNlcy5jb21cIixcbiAgICBcImNsYWltcy10b2tlbi1lcmMyMC5leGNsdXNpdmUtZXh0cmEtYm9udXNlcy5jb21cIixcbiAgICBcInhycGNvbXBldGl0aW9uLmxpdmVcIixcbiAgICBcImJpdGh1bWIubGl2ZVwiLFxuICAgIFwic3BhY2V4ZnJlZS5jb21cIixcbiAgICBcImNyeXB0b2dvb2QuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcImRlbGx0cmFkZS5jb21cIixcbiAgICBcInlvYml0LndlYnNpdGVcIixcbiAgICBcIm5ldGV4Y29pbnMuY29tXCIsXG4gICAgXCJoaWdoY29pbi5uZXRcIixcbiAgICBcImNvaW5iYXNjZXQuY29tXCIsXG4gICAgXCJjaGFydHJhZGUuY29tXCIsXG4gICAgXCJ0cmFkZWJlcnJ5Lm9yZ1wiLFxuICAgIFwiYmlsbGF4eS5jb21cIixcbiAgICBcImNyeXB0b25leC51a1wiLFxuICAgIFwiaHlwdHJhZGUuY29tXCIsXG4gICAgXCJ3aW50cmFkZXJzLm5ldFwiLFxuICAgIFwiY29pbnJleG8uY29tXCIsXG4gICAgXCJleG1vZml0LmNvbVwiLFxuICAgIFwieG4tLXN0bGxhci1jdmEub3JnXCIsXG4gICAgXCJ4bi0tbWRpdW0tbjUxYi5jb21cIixcbiAgICBcImNsYWltbHVtZW5zLm9yZ1wiLFxuICAgIFwieG4tLXN0bGxyLTZ3YTdqLm9yZ1wiLFxuICAgIFwibGVkZ2VyLWxpdmUuY29cIixcbiAgICBcImxlZGdlci1hZC5jb21cIixcbiAgICBcIndhbGxldC5teS10cmV6b3IuY29tXCIsXG4gICAgXCJteS10cmV6b3IuY29tXCIsXG4gICAgXCJzbmVnaXItc2hvcC5ydVwiLFxuICAgIFwidG9rZW5haXJkcm9wcy5uZXRcIixcbiAgICBcImlkZXhtYXJrZXQuaW5mb1wiLFxuICAgIFwieG4tLWxvY2FsaXRjb2lucy1iaDRmLm5ldFwiLFxuICAgIFwiZGRleGJpdC5jb21cIixcbiAgICBcInNlY3VyZS1sZWRnZXIuY29tXCIsXG4gICAgXCJldGhlcmV1bWF0bGFudGlzLm5ldHdvcmtcIixcbiAgICBcImJ0Y2V0aGdpZnQuY29tXCIsXG4gICAgXCJibG9ja2tjaGFpbi5ydVwiLFxuICAgIFwibG9naW4uYmxsb2NrbG5haW4uY29tXCIsXG4gICAgXCJibGxvY2tsbmFpbi5jb21cIixcbiAgICBcIm1jZjIwMjAubmV0XCIsXG4gICAgXCJ0bWRsLmluZm9cIixcbiAgICBcInhuLS1zdGVsbHItdHRhLm9yZ1wiLFxuICAgIFwieHJwZ2lmdC5saXZlXCIsXG4gICAgXCJsb2dpbi5ibG9nY2hhaW4uaWN1XCIsXG4gICAgXCJibG9nY2hhaW4uaWN1XCIsXG4gICAgXCJsb2dpbi5ibGxjb2tsbmFpbi5jb21cIixcbiAgICBcImJsbGNva2xuYWluLmNvbVwiLFxuICAgIFwieW91cmxpYnJhLm5ldFwiLFxuICAgIFwiYXRsYW50aXMtd2FsbGV0LmNvbVwiLFxuICAgIFwiZ28tdGVzdG5ldC5jb21cIixcbiAgICBcImluZm8tZGV4LmNvbVwiLFxuICAgIFwiYmlib3hnaXZlLmNvbVwiLFxuICAgIFwidG9yZW92b25saW5lLnVrXCIsXG4gICAgXCJibG9ja2NjaGFpbi5ydVwiLFxuICAgIFwiZXRoZXJldW1jbGFzc2ljLmJvbnVzLXByb2dyYW1zLmNvbVwiLFxuICAgIFwiYm9udXMtcHJvZ3JhbXMuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS13YWxsZXQtdHJhbnNhY3Rpb25zLmhvc3RcIixcbiAgICBcImNvbS13YWxsZXQtdHJhbnNhY3Rpb25zLmhvc3RcIixcbiAgICBcInRyZXpvci5ibG9nXCIsXG4gICAgXCJkb3VibGVpbnYuY29tXCIsXG4gICAgXCJtZWRpdW0tY3J5cHRvLnh5elwiLFxuICAgIFwiaWR0ZXgubWFya2V0XCIsXG4gICAgXCJoaXRidGMuc3VcIixcbiAgICBcImJsY2NrY2hpYW4uY29tXCIsXG4gICAgXCJldGhlcmV1bWJvc3Rvbi5jb21cIixcbiAgICBcIjUwMDAtYnRjLmNvbVwiLFxuICAgIFwibG9xaW4uYmxjYWtjaGlhbi5jb21cIixcbiAgICBcImJsY2FrY2hpYW4uY29tXCIsXG4gICAgXCJibG9ja2NoYWlsbi5iaXpcIixcbiAgICBcImV4Y2hhbmdlLmJuYm14LnNlcnZpY2VzXCIsXG4gICAgXCJldmVudC5leGNoYW5nZW1hcmtldC5zZXJ2aWNlc1wiLFxuICAgIFwiY29pbmJhc2UtcHJvbW8ubmV0XCIsXG4gICAgXCJkcm9wLWNyeXB0by5vcmdcIixcbiAgICBcImxpYnJhLWNvaW4uY2NcIixcbiAgICBcInRoZXZpZGJpdC5jb21cIixcbiAgICBcImJpbmFuY2UubGF1bmNoLXVzYS5uZXRcIixcbiAgICBcImxhdW5jaC11c2EubmV0XCIsXG4gICAgXCJjb2luYmFzZS1ib251cy5uZXRcIixcbiAgICBcImJpdGNvaW5nZW5lcmF0b3IuY29tLnJ1XCIsXG4gICAgXCJiLWxvY2tjaGlhbi5jb21cIixcbiAgICBcImVodGVyZGV0bGEuY29tXCIsXG4gICAgXCJidGMxMC5vcmdcIixcbiAgICBcInRvcm5hZG8uYmVzdFwiLFxuICAgIFwiYmluYW5jZS10ZXN0Lm9yZ1wiLFxuICAgIFwidmludGFnZS5teWV0aGV3YWxsZXQub25saW5lXCIsXG4gICAgXCJteWV0aGV3YWxsZXQub25saW5lXCIsXG4gICAgXCJsb2dpbi5ibGFja2NoYWlyLmluZm9cIixcbiAgICBcImJsYWNrY2hhaXIuaW5mb1wiLFxuICAgIFwibGlua2FpcmRyb3AuY29tXCIsXG4gICAgXCJ2aXBtYWdpamEuY29tXCIsXG4gICAgXCJrdW5nbWVkaWEuY29tXCIsXG4gICAgXCJidGNhbmRldGguY29tXCIsXG4gICAgXCJkcm9wa3Jha2VuLmNvbVwiLFxuICAgIFwiYmluYW5jZS1nZXQub3JnXCIsXG4gICAgXCJwcm9qZWN0MjAxOS5zZXJ2aWNlc1wiLFxuICAgIFwiYmxvY2xrY2hhaW4ubmV0XCIsXG4gICAgXCJjb2luYmFzZS1wcml6ZS5jb21cIixcbiAgICBcImlkZXgubmV0LnJ1XCIsXG4gICAgXCJncmFtLWNoYWluLmNvbVwiLFxuICAgIFwiZXRoZXJkZWx0YS5uZXQucnVcIixcbiAgICBcIndpbi1jb2luYmFzZS5jb21cIixcbiAgICBcInRva2VuZ2l2ZWF3YXkuaW5cIixcbiAgICBcImZpbmFsZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJjb2luYmFzZXdpbi5jb21cIixcbiAgICBcImNvaW5iYXNlLXJld2FyZC5jb21cIixcbiAgICBcImJ0dGZpbmV4LnJ1XCIsXG4gICAgXCJiaXRkZWdyZWUtY2xhaW1zLmJvbnVzLWNsaWVudC5jb21cIixcbiAgICBcImJvbnVzLWNsaWVudC5jb21cIixcbiAgICBcImNyeXB0b3VzZC5ob3N0XCIsXG4gICAgXCJlYXJuY3J5cHRvLnh5elwiLFxuICAgIFwiY3J5cHR4Yml0LnByb1wiLFxuICAgIFwiYnRjam9iLnB3XCIsXG4gICAgXCJjcnlwdG9leC5pY3VcIixcbiAgICBcImNyeXB0b2NvaW4yNC5zaXRlXCIsXG4gICAgXCJtdXNrLm1sXCIsXG4gICAgXCJjcnlwdG8tYWlyZHJvcC5vcmdcIixcbiAgICBcImNvaW5iYXNlZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJsdWNreS1iaW5hbmNlLmNvbVwiLFxuICAgIFwiZXhjaGFuZ2UuYm5iZGV4ZXZlbnQuc2VydmljZXNcIixcbiAgICBcImJuYmRleGV2ZW50LnNlcnZpY2VzXCIsXG4gICAgXCJiaW4tdXMuY29tXCIsXG4gICAgXCJiaXRzaHVtYi5jb21cIixcbiAgICBcImJuYm1hcmtldC5zZXJ2aWNlc1wiLFxuICAgIFwiZXhjaGFuZ2UuYm5ibWFya2V0LnNlcnZpY2VzXCIsXG4gICAgXCJldmVudC5leGNoYW5nZWplcnNleS50b3BcIixcbiAgICBcImV4Y2hhbmdlamVyc2V5LnRvcFwiLFxuICAgIFwiZXhjaGFuZ2Uud2ViamVyc2V5LnRvcFwiLFxuICAgIFwid2ViamVyc2V5LnRvcFwiLFxuICAgIFwiYmluYW5jZS5tYXJrZXRsYXVuY2guc2l0ZVwiLFxuICAgIFwibWFya2V0bGF1bmNoLnNpdGVcIixcbiAgICBcImV4Y2hhbmdlLnByb2plY3RkZXgudG9wXCIsXG4gICAgXCJwcm9qZWN0ZGV4LnRvcFwiLFxuICAgIFwid3d3ZWxlY3RydW0ub3JnXCIsXG4gICAgXCJibGNva2NoaWFuLmxpY2dpbi5jb21cIixcbiAgICBcImxpY2dpbi5jb21cIixcbiAgICBcImlkZXgucnUubmV0XCIsXG4gICAgXCJiaXRtYXJ0Z2l2ZS5jb21cIixcbiAgICBcImZyZWVjcnlwdG9ldmVudC5jb21cIixcbiAgICBcIm11c2tnaXZlLmNvbVwiLFxuICAgIFwieG4tLXN0bGxhci14NGEub3JnXCIsXG4gICAgXCJsYXVjaGVzZXZlbnQuc2VydmljZXNcIixcbiAgICBcInRyb25ldHdvcmsubGl2ZVwiLFxuICAgIFwiY3J5cHRvYnJpZGdlcy5jb21cIixcbiAgICBcImV0aC1kcm9wLm9yZ1wiLFxuICAgIFwiZ2V0LWJhY2suc2l0ZVwiLFxuICAgIFwiYmNhc2gtcHJvbW8ub3JnXCIsXG4gICAgXCJjb2luYmFzZXByb21vdGlvbi5jb21cIixcbiAgICBcIm15dGV0aHdlbGxldC5jb21cIixcbiAgICBcImt1dGl4dG9rZW4uY29tXCIsXG4gICAgXCJteWFldGhlcndlbGxhdC5jb21cIixcbiAgICBcImt0eC50eXBlZm9ybS5jb21cIixcbiAgICBcImlkZWV4LnB3XCIsXG4gICAgXCJidGMtY29pbmJhc2UuY29tXCIsXG4gICAgXCJnd2F5YXVndXN0LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiaW50ZW5yYXRpb25hbC5iZnR0cmV4LmNvbVwiLFxuICAgIFwibGl0ZWNvaW5naXZlYXdheS5pbmZvXCIsXG4gICAgXCJiZnR0cmV4LmNvbVwiLFxuICAgIFwiZXRoYmVybGluLm9yZ1wiLFxuICAgIFwiY29pbmJhc2VnaXZlLmNvbVwiLFxuICAgIFwibXVza2Vsb24uZ2FcIixcbiAgICBcInJpcHBsZWFpcmRyb3AuY2x1YlwiLFxuICAgIFwibXlldGhlcndhbGxldC5zaWdudHJhbnNhY3Rpb24uY29cIixcbiAgICBcInNpZ250cmFuc2FjdGlvbi5jb1wiLFxuICAgIFwiemVuZGVzay1uZXdzLmNvbVwiLFxuICAgIFwibGl0ZWNvaW5haXJkcm9wLmNsdWJcIixcbiAgICBcImJsbG9ja2NoYWluLmdhXCIsXG4gICAgXCI1MDAwLWNvaW5iYXNlLmNvbVwiLFxuICAgIFwiYmluYW5jZS1haXJkcm8ub25saW5lXCIsXG4gICAgXCJsdGNjb250ZXN0LmNvbVwiLFxuICAgIFwibGl0ZWNvaW4tZ2l2ZWF3YXkub3JnXCIsXG4gICAgXCJzYXRvc2hpLWxpdGVjb2luLm5ldGxpZnkuY29tXCIsXG4gICAgXCJ0b3AtY29pbmJhc2UuY29tXCIsXG4gICAgXCJwdWx0ZWdpdmUuY29tXCIsXG4gICAgXCJldGhlcmV1bS1ib3VudHkubGl2ZVwiLFxuICAgIFwicmlwcGxlYm91bnR5LmxpdmVcIixcbiAgICBcInJpcHBsZS1naXZlLm5ldFwiLFxuICAgIFwibWVkaXVtLnhycGFpcmRyb3Aud2Vic2l0ZVwiLFxuICAgIFwieHJwYWlyZHJvcC53ZWJzaXRlXCIsXG4gICAgXCJiZXN0LWV2ZW50Lmhvc3RcIixcbiAgICBcIm1jYWZlZTIwMjAtYWlyZHJvcC5uZXRsaWZ5LmNvbVwiLFxuICAgIFwiY2hhcmxpZWxlZWRyb3AubmV0XCIsXG4gICAgXCJsdGMtZ2l2ZS5vcmdcIixcbiAgICBcIjIwMTlnaXZlYXdheS5uZXRcIixcbiAgICBcImN0b2tlbi5pbmZvXCIsXG4gICAgXCJiaW5hbmNlLm5ld3Byb2plY3Quc2l0ZVwiLFxuICAgIFwibmV3cHJvamVjdC5zaXRlXCIsXG4gICAgXCJ6ZW5kZXNrLWJpbmFuYy5jb21cIixcbiAgICBcImJpbmFuY2VreWMuY29tXCIsXG4gICAgXCJjb2lua2Fub24uY29tXCIsXG4gICAgXCJiaXQ3ODgwLmNvbVwiLFxuICAgIFwiYml0Y29pbi1hZGRyZXNzLWNyYWNrZXIuYml0Nzg4MC5jb21cIixcbiAgICBcInd3dy1pZGVleC5tYXJrZXRcIixcbiAgICBcImlkbGVheC5tYXJrZXRcIixcbiAgICBcImJpdG1leC1ibG9nLmluZm9cIixcbiAgICBcImV0aC1zZW5kLnRlY2hcIixcbiAgICBcImJsY29rY2hpYW4ubGNnbGpuLmNvbVwiLFxuICAgIFwibGNnbGpuLmNvbVwiLFxuICAgIFwiZHJvcGNvaW5iYXNlLmNvbVwiLFxuICAgIFwiYXVndXN0Y29udGVzdC5ibG9nc3BvdC5jb21cIixcbiAgICBcInhuLS1sb2NhbGJpdGNvbnMtamZiZi5uZXRcIixcbiAgICBcImFpcmRyb3AtbWNhZmVlLnRlY2hcIixcbiAgICBcImNyeXB0by1wcm9tby5zdG9yZVwiLFxuICAgIFwiZXRoZXJldW1wcml6ZS5wcm9cIixcbiAgICBcInBsdXMtZXRoZXJzLmNvbVwiLFxuICAgIFwia3Vjb2luLmxpdmVcIixcbiAgICBcImItbmFuY2UuY29tXCIsXG4gICAgXCJjb2luYmFzZS5naWZ0c1wiLFxuICAgIFwid3d3LWlkYWV4Lm1hcmtldFwiLFxuICAgIFwiYnRjLWRyb3AuY29tXCIsXG4gICAgXCJwcm9tby1jb2luYmFzZS5jb21cIixcbiAgICBcImdldC1tY2FmZWUubWVcIixcbiAgICBcIm1jYWZlZWdpdmVhd2F5Lm5ldFwiLFxuICAgIFwibWNhZmVldG9kYXkuY29tXCIsXG4gICAgXCJqb2huLW1jYWZlZS1ldmVudHMuY29tXCIsXG4gICAgXCJnZXQtbWNhZmVlLnByZXNzXCIsXG4gICAgXCJjcnlwdG9mYW5zMjAxOS5jb21cIixcbiAgICBcImNvaW5iYXNlLXByb21vdGlvbi5jb21cIixcbiAgICBcImNvaW5iYXNlLW5ld3MuY29tXCIsXG4gICAgXCJidGMtYm9udXMuY29tXCIsXG4gICAgXCJteWV0aGVydmVyaWZ5LmNvbVwiLFxuICAgIFwiZm9ya2RlbHRhLmlkXCIsXG4gICAgXCJmb3JrZGVsdGEuY28udWtcIixcbiAgICBcImZvcmtkZWx0YS5jbHViXCIsXG4gICAgXCJldGhlcmV1bS1taXhlci5vcmdcIixcbiAgICBcImZlYXRoZXJjb2luLnRvcFwiLFxuICAgIFwibXlldGhkZXguY29tXCIsXG4gICAgXCJldGhjb21iby5jb21cIixcbiAgICBcImxvY2FpYml0Y29pbnMubmV0XCIsXG4gICAgXCJnaXZlYXdheS10cmFuc2Zlci5jb21cIixcbiAgICBcImRlY2VudHJhbGl6ZWQtZXhjaGFuZ2UuaW5mb1wiLFxuICAgIFwibWNhZmVlbm93Lm5ldFwiLFxuICAgIFwid3d3LWxkYXgubWFya2V0XCIsXG4gICAgXCJkdmVyeWlyYXpkdnl6aG5pZXN5c3RlbXkuY29tXCIsXG4gICAgXCJiaW5hbmNlLmRleG14LnNpdGVcIixcbiAgICBcInd3dy1pZGxleC5tYXJrZXRcIixcbiAgICBcImlkZXhtYXJrZXQubGl2ZVwiLFxuICAgIFwibWNhZmVlZHJvcC5jb21cIixcbiAgICBcImFpcmRyb3AtbWNhZmVlLm9ubGluZVwiLFxuICAgIFwiZ2V0LW1jYWZlZS5zcGFjZVwiLFxuICAgIFwibWNhZmVlZ3JvdXAub3JnXCIsXG4gICAgXCJ4bi0tbG9jYWxidGNvaW5zLWpmYmIubmV0XCIsXG4gICAgXCJibG9uY2toaWFuLmNvbVwiLFxuICAgIFwicGVybGluLmluXCIsXG4gICAgXCJ0cmV6b3IudGVhbVwiLFxuICAgIFwiYnJhdmUtYm91bnR5LmNvbVwiLFxuICAgIFwiNTAwMGNyeXB0by5jb21cIixcbiAgICBcImV4Y2hhbmdlLmV2ZW50c29sdXRpb25zLnRvcFwiLFxuICAgIFwiY29pbmJhc2VnaXZlcy5jb21cIixcbiAgICBcImNvaW5iYXNlZ29sZC5jb21cIixcbiAgICBcImNvaW5iYXNlLTUwMDAuY29tXCIsXG4gICAgXCJjb2luYmFzZS1kcm9wLmNvbVwiLFxuICAgIFwidGVhbW9mYmluYW5jZS5jb21cIixcbiAgICBcIm5lb2F1Z3VzdC5ibG9nc3BvdC5jb21cIixcbiAgICBcImJpbmFuY2UuamVyc2V5ZXhjaGFuZ2Uuc2l0ZVwiLFxuICAgIFwiamVyc2V5ZXhjaGFuZ2Uuc2l0ZVwiLFxuICAgIFwibGl0ZWNvaW5wcm9tby5uZXRsaWZ5LmNvbVwiLFxuICAgIFwiZXhjaGFuZ2Uud2ViZGV4bGF1bmNoLnRvcFwiLFxuICAgIFwid2ViZGV4bGF1bmNoLnRvcFwiLFxuICAgIFwiZXRoZXJldW0tYWlyZHJvcC5uZXRsaWZ5LmNvbVwiLFxuICAgIFwiZ2V0LWJpbmFuY2Uub3JnXCIsXG4gICAgXCJnZXQzdGVzbGEuc3BhY2VcIixcbiAgICBcImNhbGlicmEtaWNvLmluZm9cIixcbiAgICBcImJpbmFuY2VmcmVlMjAxOC5kcm9wcGFnZXMuY29tXCIsXG4gICAgXCJiaW5hbmNlLm5ld3JlbGVhc2Uuc2l0ZVwiLFxuICAgIFwiNTAwMGNvaW5iYXNlLmNvbVwiLFxuICAgIFwiY29pbmJhc2VidGMuYXRzcGFjZS5jY1wiLFxuICAgIFwiY29pbmJhc2Vib251cy5uZXRcIixcbiAgICBcImNvaW5iYXNlZ2lmdC5lcGl6eS5jb21cIixcbiAgICBcInRyYW5zYWN0aW9uLXZlcmlmaWNhdGlvbi50ZWNoXCIsXG4gICAgXCJjb2luYmFzZS10ZWFtLmNvbVwiLFxuICAgIFwiYnRjLWdlbmVyYXRvci5jbHViXCIsXG4gICAgXCJpZGVreC5tYXJrZXRcIixcbiAgICBcInZpcC5rZWxpcmVxYS54eXpcIixcbiAgICBcIm11c2tlbG9uNTQ3Nzc2LndlYmNpbmRhcmlvLmNvbVwiLFxuICAgIFwibXVza2Vsb24ubmV0XCIsXG4gICAgXCJhaXJkcm9wLWNyeXB0by5jb21cIixcbiAgICBcInByb21vdGlvbi1jcnlwdG8uY29tXCIsXG4gICAgXCJjb2luYmFzZWdpZnQubmV0XCIsXG4gICAgXCJldGhlcmV1bTR0aC5vcmdcIixcbiAgICBcImRyb3AtY3J5cHRvLmNvbVwiLFxuICAgIFwiY29pbmJhc2V0b3AuY29tXCIsXG4gICAgXCJjb2luYmFzZS5wcm9tb1wiLFxuICAgIFwiMTAwa2J0Yy5jb21cIixcbiAgICBcImJpbmFuY2UxMHguZXBpenkuY29tXCIsXG4gICAgXCJldGhlcmV1bXByb21vLmVwaXp5LmNvbVwiLFxuICAgIFwiMjAxOWdpdmVhd2F5LmNvbVwiLFxuICAgIFwiZ3JhbS1uZXQub3JnXCIsXG4gICAgXCI1MDAwYnRjLmdpZnRcIixcbiAgICBcInByb21vLWJpbmFuY2UubmV0bGlmeS5jb21cIixcbiAgICBcImJ0Yy53ei5za1wiLFxuICAgIFwibXllbGx0aGV2d2FhbGxldC5jb21cIixcbiAgICBcIm1jYWZlZWJ0Yy5uZXRcIixcbiAgICBcImJ1dGVyaW5ldGgubmV0XCIsXG4gICAgXCJmYXN0cHJvZml0YWJsZW9wdGlvbnRyYWRlLmNvbVwiLFxuICAgIFwiZXRoZXJldW00dGguY29tXCIsXG4gICAgXCJjb25uLXZpZXctd2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29ubi12aWV3LXdhbGxldC5pbmZvXCIsXG4gICAgXCJ0b3AtYmluYW5jZS5jb21cIixcbiAgICBcIm5ld3MtYm5iLm9yZ1wiLFxuICAgIFwibmVvZm91bmRhdGlvbi5ibG9nc3BvdC5jb21cIixcbiAgICBcImV2ZW50YmluYW5jZS5jb21cIixcbiAgICBcInhuLS1ibG9ja2NhaW4tbG1iLmNvbVwiLFxuICAgIFwiaGl2ZXJ6b25lLmNvbVwiLFxuICAgIFwiZWxvbm11c2tjcnlwdG8ud2ViY2luZGFyaW8uY29tXCIsXG4gICAgXCJiaW5hbmNlLW1hcmdpbi1sYXVuY2guY29tXCIsXG4gICAgXCJhbnljb2lucy5jbHViXCIsXG4gICAgXCJtY2FmZWVzLXJlZGVtcHRpb24ubmV0bGlmeS5jb21cIixcbiAgICBcImNhbGlicmEtdG9rZW4uaW5mb1wiLFxuICAgIFwibm93NTAwMC5jb21cIixcbiAgICBcImNyeXB0by1kcm9wLm9yZ1wiLFxuICAgIFwiY3J5cHRvLXByb21vLm5ldFwiLFxuICAgIFwiY3J5cHRvZXh0cmF2YWdhbnphLm9ubGluZVwiLFxuICAgIFwiZG9uYWx0LmxpdmV0cmFkZXMudmlwXCIsXG4gICAgXCJiaWl0bXJ0LmNvbVwiLFxuICAgIFwiY29pbmJhc2Vwcm9tby5lcGl6eS5jb21cIixcbiAgICBcIndpbi1iaW5hbmNlLmNvbVwiLFxuICAgIFwiY3J5cHRvLWV4dHJhdmFnYW56YS5zdG9yZVwiLFxuICAgIFwiZHJvcC1iaW5hbmNlLmNvbVwiLFxuICAgIFwiZ2lmdC1iaW5hbmNlLmNvbVwiLFxuICAgIFwiaHVvYmlwYXJ0bmVycy5jb21cIixcbiAgICBcIm1uLXIuc3RvcmVcIixcbiAgICBcInRva2VuLTEuY29tXCIsXG4gICAgXCJjb2luYmFzZS50b2tlbi0xLmNvbVwiLFxuICAgIFwiaHVvYmlnbG9iYWwubHRkXCIsXG4gICAgXCJ6ZW5kZXNrLmh1b2JpZ2xvYmFsLmx0ZFwiLFxuICAgIFwiYmluYW5jZWJ0Yy5lcGl6eS5jb21cIixcbiAgICBcInVwYml0LnNhbGVcIixcbiAgICBcImJpbmFuY2UtdXBkYXRlcy5jb21cIixcbiAgICBcImJ0YzUwMDAuZXBpenkuY29tXCIsXG4gICAgXCJwcm9tb2JpbmFuY2UubmV0XCIsXG4gICAgXCIzMGYzMDAwZi01ZjFmLTRkZWUtYWYyZC0wYjdhNjE1OWY0YzAuaHRtbHBhc3RhLmNvbVwiLFxuICAgIFwiMzM2NWNhZDUtNDU1Yi00ZWQwLWE5NDQtMmI5YmQwMTkxNTAxLmh0bWxwYXN0YS5jb21cIixcbiAgICBcIjA5NzhmNjU1LTQ2NWItNDQzNC05OWZiLWY4MzU3YzdiY2E0Yi5odG1scGFzdGEuY29tXCIsXG4gICAgXCJhaXJkcm9wMi5jb21cIixcbiAgICBcImdldC1jcnlwdG8udGVjaFwiLFxuICAgIFwiZGlldG9sb2dpY2hlc2tvZXBpdC5zcGFjZVwiLFxuICAgIFwiYmluYW5jZTUwMDAuZXBpenkuY29tXCIsXG4gICAgXCJidGNmYXN0Lm5ldFwiLFxuICAgIFwidHJhbnNhY3Rpb24tc2VuZHMudGVjaFwiLFxuICAgIFwiYnRjLWRyb3AubmV0XCIsXG4gICAgXCJjb2luYmFzZXByb21vLm5ldFwiLFxuICAgIFwibWdjdG9rZW4uYml6XCIsXG4gICAgXCJtZ2N0b2tlbi5vcmdcIixcbiAgICBcImJpbmFuY2U1MDAwLmluZm9cIixcbiAgICBcImJpZ3Byb21vLm5ldFwiLFxuICAgIFwiNTAwMGJ0Yy5vcmdcIixcbiAgICBcImNhbGlicmEtdG9rZW4uY29tXCIsXG4gICAgXCJjYWxpYnJhaWNvLmNvbVwiLFxuICAgIFwiY2FsaWJyYS1pY28uY29tXCIsXG4gICAgXCJiYWtrdC1idGMtZXZlbnQubmV0bGlmeS5jb21cIixcbiAgICBcImJ1eWxpYnJhY29pbnMuY29tXCIsXG4gICAgXCJtY2FmZWUtb2ZmaWNpYWwubmV0XCIsXG4gICAgXCJtY2FmZWUtZXRoLm5ldGxpZnkuY29tXCIsXG4gICAgXCJtY2FmZWUtYnRjLm5ldGxpZnkuY29tXCIsXG4gICAgXCJjYWxpYnJhLWljby5uZXRcIixcbiAgICBcInRyb24tb2ZmaWNpYWwtYnRjLXByb21vLm5ldGxpZnkuY29tXCIsXG4gICAgXCJjcnlwdG8tcHJvbW8tZ2V0LnRlY2hcIixcbiAgICBcInRyb24tZm91bmRhdGlvbi1yZWRlZW0ubmV0bGlmeS5jb21cIixcbiAgICBcIjUwMDBnaXZlYXdheS5jb21cIixcbiAgICBcImNvaW5iYXNlZ2lmdC5jb21cIixcbiAgICBcImJpbmFuY2UtbWFyZ2luLW5ldy5jb21cIixcbiAgICBcIjUwMDBnZXQuY29tXCIsXG4gICAgXCJnZXQzdGVzbGEub3JnXCIsXG4gICAgXCJsaXRlbmV0Lmx0ZFwiLFxuICAgIFwiNTAwMHByb21vLm5ldFwiLFxuICAgIFwiY3J5cHRvY2x1YjI0Ny5jb21cIixcbiAgICBcImJ0Y3ByZXNlbnQubmV0XCIsXG4gICAgXCJiaW5hbmNldmlzaXQubmV0XCIsXG4gICAgXCJ0aGVjcnlwdG9ib251cy5jb21cIixcbiAgICBcIm1kbDMub3JnXCIsXG4gICAgXCJlYXN5YmluYW5jZS5jb21cIixcbiAgICBcImNyeXB0by1wcm9tb3Rpb24tZ2V0Lm9ubGluZVwiLFxuICAgIFwidGVzbGEtcHJvbW8ubmV0bGlmeS5jb21cIixcbiAgICBcImJpbmFuY2VnaXZlYXdheS50b3BcIixcbiAgICBcImJpbmFuY2ViZWdpbi5jb21cIixcbiAgICBcImJpbmFuY2VmZWFzdC5vcmdcIixcbiAgICBcImRyb3A1MDAwLmNvbVwiLFxuICAgIFwiY3J5cHRvLXByb21vdGlvbi1nZXQudGVjaFwiLFxuICAgIFwiNTAwMGJ0Yy5uZXRcIixcbiAgICBcImJsb2NrY2hhaW4tZXhwbG9pdC5zaXRlXCIsXG4gICAgXCJidGMxMHgub3JnXCIsXG4gICAgXCJiaW5hbmNlMjAxOS5jb21cIixcbiAgICBcImJpbmFuY2VmZWFzdC5uZXRcIixcbiAgICBcIjJiaW5hbmNlLmNvbVwiLFxuICAgIFwiYmluYW5jZTJ5by5jb21cIixcbiAgICBcIm15YmluYW5jZS5uZXRcIixcbiAgICBcImxvY2FsYml0Y29pbnMuY29tLmRpZ2ljZXJ0cy5saXZlXCIsXG4gICAgXCIyMGV0aC5vcmdcIixcbiAgICBcImJpbmNsaWMuY29tXCIsXG4gICAgXCJiaW5hbmNlcHJvLmVwaXp5LmNvbVwiLFxuICAgIFwibWNhZmVlLW9mZmljaWFsLWNvbWViYWNrLm5ldGxpZnkuY29tXCIsXG4gICAgXCJvZmZpY2lhbC1zZXJ2aWNlLm9ubGluZVwiLFxuICAgIFwiYmluYW5jZWZ1bmRzLmNvbVwiLFxuICAgIFwiYmluYW5jZXRvZGF5Lm5ldFwiLFxuICAgIFwianVseW5lby5ibG9nc3BvdC5jb21cIixcbiAgICBcImlubm92YW1pbmUubHRkXCIsXG4gICAgXCJjcnlwdG9wbGF5LndvcmxkXCIsXG4gICAgXCJiaW5hbmNlZ2l2ZWF3YXkubmV0XCIsXG4gICAgXCIyMGJ0Yy5uZXRcIixcbiAgICBcImJpbmFuY2UtZ2lmdC5wcm9cIixcbiAgICBcImJpbmFuY2V3aW4uY29tXCIsXG4gICAgXCIyMGV0aC5jb21cIixcbiAgICBcImNyeXB0by1ldmVudC5ob3N0XCIsXG4gICAgXCJkcm9wYmluYW5jZS5jb21cIixcbiAgICBcInhycHgyanVseS5ibG9nc3BvdC5jby5rZVwiLFxuICAgIFwiZ2lmdGJpbmFuY2UuY29tXCIsXG4gICAgXCJhbm5pdmVyc2FyeS1ldGguY29tXCIsXG4gICAgXCJkcm9wZmVzdGV4dHJhdmFnYW56YS50ZWNoXCIsXG4gICAgXCJmbHktcHJvbW8ub25saW5lXCIsXG4gICAgXCJiaW5wcm9tby5uZXRcIixcbiAgICBcImNibi1wcm9qZWN0LmNvbVwiLFxuICAgIFwiYmlsdG1haW4uY29tXCIsXG4gICAgXCJiaW5hbmNlLXRlYW0uY29tXCIsXG4gICAgXCJiaW5hbmNldGVhbXMubmV0XCIsXG4gICAgXCJiaW5hbmNlMi5lcGl6eS5jb21cIixcbiAgICBcInhycHgyanVseS5ibG9nc3BvdC5jb21cIixcbiAgICBcImJpbmFuY2UtZ2l2ZXMuY29tXCIsXG4gICAgXCJiaW5hbmNlMi52aXBcIixcbiAgICBcIjUwMDBkcm9wLmNvbVwiLFxuICAgIFwiZ2V0cHJvbW8ubWVcIixcbiAgICBcImFubml2ZXJzYXJ5LWJpbmFuY2UuY29tXCIsXG4gICAgXCJkb3RoZXJldW13YWxsZXQubmV0XCIsXG4gICAgXCJncmFtdG9uLnB3XCIsXG4gICAgXCJnZXRidXRlcmluLm9yZ1wiLFxuICAgIFwiYmluYW5jZTIwLm9yZ1wiLFxuICAgIFwiYmluYW4tbWFyZ2luYWwuY29tXCIsXG4gICAgXCJpZG5leC5tYXJrZXRcIixcbiAgICBcInByb21vLWV4dHJhdmFnYW56emEudGVjaFwiLFxuICAgIFwiYmluYW5jZWdpZnQub3JnXCIsXG4gICAgXCJ3aW4tZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJjcnlwdG8tZXh0cmF2YWdhbnphLnRlY2hcIixcbiAgICBcImxpdmViaW5hbmNlLmNvbVwiLFxuICAgIFwiYnRjZmFzdC5vcmdcIixcbiAgICBcImJpbmFuY2VzdXBlci5uZXRcIixcbiAgICBcImJpdGNvaW5kcm9wLm9yZ1wiLFxuICAgIFwiZXRoMTAudG9wXCIsXG4gICAgXCJiaW5hbmNlZnJlZS5uZXRcIixcbiAgICBcIm9mZmljaWFsLWRyb3AuY2x1YlwiLFxuICAgIFwiYmluYW5jZXByb21vLmVwaXp5LmNvbVwiLFxuICAgIFwiYWlyZHJvcGJ0Yy5lcGl6eS5jb21cIixcbiAgICBcImJpbmFuY2VjbHViLnJmLmdkXCIsXG4gICAgXCJjcnlwdG8tcHJvbW8uY29tXCIsXG4gICAgXCJnaXZlYXdheS1idGMubmV0XCIsXG4gICAgXCJwcm9tb2NyeXB0by5uZXRcIixcbiAgICBcImJpbmFuY2V2Mi5saXZlXCIsXG4gICAgXCJiaW5hbmNlLWJ0Yy5uZW9jaXRpZXMub3JnXCIsXG4gICAgXCJldGgzMC5vcmdcIixcbiAgICBcImJpbmFuY2UtcHJvbW8ubmV0bGlmeS5jb21cIixcbiAgICBcIngybmVvanVseS5ibG9nc3BvdC5jb21cIixcbiAgICBcImNlbGVicmF0aW9uLWJpbmFuY2UubmV0bGlmeS5jb21cIixcbiAgICBcImJpdGNvaW5naWZ0Lm5ldFwiLFxuICAgIFwiZWxvbi1tdXNrLnh5elwiLFxuICAgIFwiYmxsb2NrY2hhaW4udGtcIixcbiAgICBcImhpbHRidGMuY29tXCIsXG4gICAgXCJsb2dpbi5iaWxvY2tjbmFpbi5jb21cIixcbiAgICBcImJpbG9ja2NuYWluLmNvbVwiLFxuICAgIFwic3RhcmtkZXgubmV0XCIsXG4gICAgXCJtZXcuc3RhcmthcHAubmV0XCIsXG4gICAgXCJzdGFya2FwcC5uZXRcIixcbiAgICBcImRleHRlc3RuZXQuaW5mb1wiLFxuICAgIFwiZXRoMjAub3JnXCIsXG4gICAgXCJiaW5hbmNlLWJpdC5uZXRcIixcbiAgICBcImV4dHJhdmFnYW56YS1ldmVudC53ZWJzaXRlXCIsXG4gICAgXCJ0ZXNsYXByb21vLmluZm9cIixcbiAgICBcInhuLS1naXRodS1rOTBiLmNvbVwiLFxuICAgIFwiZXRoYnV0ZXJpbi5jb21cIixcbiAgICBcImJlc3QtZXZlbnQuc2l0ZVwiLFxuICAgIFwiYWlyZHJvcC5iZXN0LWV2ZW50LnNpdGVcIixcbiAgICBcInhuLS1tZWR1bS0xc2EuY29tXCIsXG4gICAgXCJiaW5hbm5jZS5uZXRcIixcbiAgICBcIm5ld3MuYmluYW5uY2UubmV0XCIsXG4gICAgXCJteWV0aGVyZXdhbGxldC5pb1wiLFxuICAgIFwiZ2l2ZWF3YXktY3J5cHRvLnRlY2hcIixcbiAgICBcImJpbmFuY2Vwcm9tby1ub3cub25saW5lXCIsXG4gICAgXCJiaXRjb2luZHJvcC5uZXRcIixcbiAgICBcImJpbmFuY2UtY2xhaW1zLm5ldGxpZnkuY29tXCIsXG4gICAgXCJldGgtYnRjcHJvbW90aW9uLm9ubGluZVwiLFxuICAgIFwiZXRoY2hhcml0eS5uZXRcIixcbiAgICBcImV0aHByaXplLm5ldFwiLFxuICAgIFwibWNhZmVlLmFpcmRyb3AtZXZlbnQuZnVuXCIsXG4gICAgXCJhaXJkcm9wLWV2ZW50LmZ1blwiLFxuICAgIFwiZG91YmxlZXRoZXJldW0uY2NcIixcbiAgICBcImhpdGJ0Yy5jby51YVwiLFxuICAgIFwiY29pbmJhc2Vwcm8xMDAwMC53ZWJjaW5kYXJpby5jb21cIixcbiAgICBcIm5lb2p1bHl4Mi5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGRyb3AubmV0XCIsXG4gICAgXCJldGguZ2lmdFwiLFxuICAgIFwiZXRoLWxpbmsuaW5mb1wiLFxuICAgIFwiY2hhaW5saW5rLnByb1wiLFxuICAgIFwiY2xhaW13YWxsZXQub3JnXCIsXG4gICAgXCJncmFtLXRvbi5jb21cIixcbiAgICBcInJpcHBsZXN1cHBvcnQub3JnXCIsXG4gICAgXCI2NjAyYzQxMi02N2YzLTQ3MjUtOTJlYi01YzJlYmIyYzYxNjYuaHRtbHBhc3RhLmNvbVwiLFxuICAgIFwiZDY1MTNkNzEtZWUwZS00MWMzLThiZGEtODM1ODdhYzRlODYzLmh0bWxwYXN0YS5jb21cIixcbiAgICBcImpvaG5zMjAxOTBnaWZ0LnR1bWJsci5jb21cIixcbiAgICBcInplbmRlc2stYm5iLm9yZ1wiLFxuICAgIFwibG9naW4uYmxvZGNoYWluLmNvbVwiLFxuICAgIFwiYmxvZGNoYWluLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tdmVyaWZ5LndlYnNpdGVcIixcbiAgICBcImxvZ2luLmJsb2NpY2tjaGFpcm4uY29tXCIsXG4gICAgXCJibG9jaWNrY2hhaXJuLmNvbVwiLFxuICAgIFwibWV3LnN0YXJrd2FsbGV0Lm9yZ1wiLFxuICAgIFwic3Rhcmt3YWxsZXQub3JnXCIsXG4gICAgXCJiaXAzOS5pbmZvXCIsXG4gICAgXCJiaXAzOXRvb2xzLmNvbVwiLFxuICAgIFwiZWxlY3RydW0ub3JnLXNlY3VyZS5hcHBcIixcbiAgICBcImNsYWltbGluay5vbmxpbmVcIixcbiAgICBcIm9yZy1zZWN1cmUuYXBwXCIsXG4gICAgXCJyZWZlcmV1bS5jb20uZXJjLTIwLmNsYWltc1wiLFxuICAgIFwiZXJjLTIwLmNsYWltc1wiLFxuICAgIFwiYmlnZHJvcC5wcm9cIixcbiAgICBcIm1lZGl1bS5leGNoYW5nZS1wcm9tby5mdW5cIixcbiAgICBcImV4Y2hhbmdlLXByb21vLmZ1blwiLFxuICAgIFwicG9tcGxpYW5vLXByb21vLm5ldGxpZnkuY29tXCIsXG4gICAgXCJjb2luYmFzZS5nZXRmb3JnZS5pb1wiLFxuICAgIFwibW9yZS1nZXRiYWNrLnNpdGVcIixcbiAgICBcImRvdGhlcmV1bS1wb2xrYWRvdC5uZXRcIixcbiAgICBcInJpcHBsZWNvbXBldGl0aW9uLmNvbVwiLFxuICAgIFwianVuZWNvaW5zeDIuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJjcnlwdGV4cGxhdGZvcm0uY29tXCIsXG4gICAgXCJjb2luZXBsdXMuY29tXCIsXG4gICAgXCJlY3B0b2tlbi5jb21cIixcbiAgICBcInplbmRlc2stYm5iLmNvbVwiLFxuICAgIFwidml0YWxpay1naXZlcy53ZWJzaXRlXCIsXG4gICAgXCJzdG9wcC5jb20uYXVcIixcbiAgICBcInByb21vLWZyb20tYnV0ZXJpbi5zaXRlXCIsXG4gICAgXCJibmItemVuZGVzay5jb21cIixcbiAgICBcIm5lb2p1bmV4Mi5ibG9nc3BvdC5jb21cIixcbiAgICBcImUzYzAxZDQ3LTMyZDUtNDE3ZC04NmE1LTY0ODQ0MTJmZDQ3Ny5odG1scGFzdGEuY29tXCIsXG4gICAgXCJ4bi0tY2FsYnJhLXl2YS5jb21cIixcbiAgICBcInppbGxpcWEudGVjaFwiLFxuICAgIFwiY3J5cHRvc3VwcG9ydC5saXZlXCIsXG4gICAgXCJpZGF4LW1hcmtldC5ydVwiLFxuICAgIFwibXllbHRoZXJld2FsbGV0LmNvbVwiLFxuICAgIFwiYmxvY2tjaGFpcm5ldy5pbmZvXCIsXG4gICAgXCJzdGFyY29pbmUuY29tXCIsXG4gICAgXCJjcnlwdG9oeXBlLndvcmxkXCIsXG4gICAgXCJldGhzLmdpZnRcIixcbiAgICBcIm1jYWZlZS5haXJkcm9wLXByb21vdGlvbi5ob3N0XCIsXG4gICAgXCJhaXJkcm9wLXByb21vdGlvbi5ob3N0XCIsXG4gICAgXCJhcG9tcGxpYW5vLm5ldGxpZnkuY29tXCIsXG4gICAgXCJub3ctZXRoZXJzLmNvbVwiLFxuICAgIFwib2ZmaWNpYWwtcHJvbW8ucHdcIixcbiAgICBcIm9mZmljaWFsLXByb21vLnByb1wiLFxuICAgIFwidGVzbGEtcHJvbW8uZXBpenkuY29tXCIsXG4gICAgXCJhaXJkcm9wLXNhbGUub25saW5lXCIsXG4gICAgXCJhaXJkcm9wLW1haW4uaW5mb1wiLFxuICAgIFwiYml0ZmluZXguY2xpY2tcIixcbiAgICBcIm9mZmljaWFsLWV2ZW50cy5zaXRlXCIsXG4gICAgXCJteWVsdGh3YWx0dGVyLmNvbVwiLFxuICAgIFwiYmlnY2xhaW0ucHJvXCIsXG4gICAgXCJlbGVjdHJ1bXVzLmNvbVwiLFxuICAgIFwiYmxvZy5kZWNlbnRyYWxpemVkLWV4Y2hhbmdlLm9yZ1wiLFxuICAgIFwiZGVjZW50cmFsaXplZC1leGNoYW5nZS5vcmdcIixcbiAgICBcIm5lb2p1bmUuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJtZWRpdW0uYml0Y29pbi1nYWluLm9yZ1wiLFxuICAgIFwiYml0Y29pbi1nYWluLm9yZ1wiLFxuICAgIFwic2Y1MjBway5jb21cIixcbiAgICBcImxpYW5qaWVkdS5jb21cIixcbiAgICBcImNvaW5leG1pbmVyLnNpdGVcIixcbiAgICBcImJpdC1kb25vci5jb21cIixcbiAgICBcImJuYi1sYXVuY2guY29tXCIsXG4gICAgXCJtZWRpdW1jZG4udG9kYXlcIixcbiAgICBcIm1jYWZlZS5jcnlwdG8tYWlyZHJvcC5zcGFjZVwiLFxuICAgIFwiY3J5cHRvLWFpcmRyb3Auc3BhY2VcIixcbiAgICBcInRlc2xhbXVzay50ZWNoXCIsXG4gICAgXCI1OGI0OGQwNy0xMTBjLTQ4N2UtOGE3Ny05MzhjZmFhOGFmMTguaHRtbHBhc3RhLmNvbVwiLFxuICAgIFwibWNhZmVlLXByb21vLmNvbVwiLFxuICAgIFwibWNhZmVlLWNyeXB0by50ZWNoXCIsXG4gICAgXCJjb2luMmNvaW4uY29cIixcbiAgICBcInJlY2VpdmUtZXRoZXJldW0ud2Vic2l0ZVwiLFxuICAgIFwiY29tLWV0aC50b3BcIixcbiAgICBcImJpbmFuY2UuY29tLWV0aC50b3BcIixcbiAgICBcImJpbmFuY2UtdHJhZGUuY29tXCIsXG4gICAgXCJtdXNrLWV2ZW50LmluZm9cIixcbiAgICBcImJpbmFuY2UtcHJlc2VudHMuZnVuZFwiLFxuICAgIFwiYWlyZHJvcC5jZW50ZXJcIixcbiAgICBcImdldC1ldGgtZnJlZS5jb21cIixcbiAgICBcImJyYXZlLWJyb3dzZXIuaW5mb1wiLFxuICAgIFwibWNhZmVlLnNpdGVcIixcbiAgICBcImpvaG4ubWNhZmVlLmdldGZvcmdlLmlvXCIsXG4gICAgXCJiaW5hbmNlLWFwcC5vcmdcIixcbiAgICBcIm5ld3MuYmluYW5jZS1hcHAub3JnXCIsXG4gICAgXCJteXRod2FsdGVyLmNvbVwiLFxuICAgIFwibG9nbi5saWZlXCIsXG4gICAgXCJwb2xvbmlleC5jb20tYWNjb3VudC1sb2dpbi5sb2duLmxpZmVcIixcbiAgICBcImNvbS1hY2NvdW50LWxvZ2luLmxvZ24ubGlmZVwiLFxuICAgIFwibWFyZ2luLWJpbnRlc3RuZXQuY29tXCIsXG4gICAgXCJtY2FmZWUuZ2V0Zm9yZ2UuaW9cIixcbiAgICBcIm5ld2V0aGVyZXdhbGxldHMuY29tXCIsXG4gICAgXCJldGhlci1yZXR1cm4uY29tXCIsXG4gICAgXCJlbG9uLW11c2suZ2V0Zm9yZ2UuaW9cIixcbiAgICBcImNvaW5leHBsb3Jlci50ZWNoXCIsXG4gICAgXCJ3d3ctbXlldGhlbnJ3YWxsZXQuY29tXCIsXG4gICAgXCJybmV3ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJycnJ5ZWhsZXJld3ZhbGxldC5jb21cIixcbiAgICBcImlsZGV4bWFya2V0LnB3XCIsXG4gICAgXCJuZXdzLWJuYi5jb21cIixcbiAgICBcIm9yaWdpbi5mb3VuZGF0aW9uXCIsXG4gICAgXCJjbG91ZHRva2VuZXhjaGFuZ2UuY29tXCIsXG4gICAgXCJibG9ja2NoYWluY29tZXhwbG9yZXIuejEzLndlYi5jb3JlLndpbmRvd3MubmV0XCIsXG4gICAgXCJjcnlwdG90cm9ueC5jb21cIixcbiAgICBcInhuLS1jb2luYnNlLWR3YS5jb21cIixcbiAgICBcIm5vLXJlcGx5Y29pbmJhc2UuY29tXCIsXG4gICAgXCJobXJjbWVjbGFpbS5jb21cIixcbiAgICBcIm15Y3J5cHRvLXdhbGxldC5pbmZvXCIsXG4gICAgXCJkb2dlcGF5LmluZm9cIixcbiAgICBcImlkZGV4LnB3XCIsXG4gICAgXCJsb2NhbGJpbGNvbG5zLm5ldFwiLFxuICAgIFwiYm5iLXRlc3RuZXQub3JnXCIsXG4gICAgXCJqZXJzZXlsYXVuY2hlcy5pY3VcIixcbiAgICBcImRleGNvbXBldGl0aW9uLnNpdGVcIixcbiAgICBcImNyeXB0b3hnbG9iYWwuY29tXCIsXG4gICAgXCJidXlldGg3MC5qZGV2Y2xvdWQuY29tXCIsXG4gICAgXCJ4Y29pbmJhY2suY29tXCIsXG4gICAgXCJldGguZWxvbi1tdXNrLXRlc2xhLnNwYWNlXCIsXG4gICAgXCJlbG9uLW11c2stdGVzbGEuc3BhY2VcIixcbiAgICBcImJ0Yy5lbG9uLW11c2stdGVzbGEuc3BhY2VcIixcbiAgICBcInRvcnRva2VuLmlvXCIsXG4gICAgXCJzZWN1cmUuZ2xvYmFsc2VjLmljdVwiLFxuICAgIFwiZG91YmxlYml0Y29pbi5nYVwiLFxuICAgIFwiZ2xvYmFsc2VjLmljdVwiLFxuICAgIFwibGxkZXgucHdcIixcbiAgICBcImlkLWV4LnB3XCIsXG4gICAgXCJiaW5hbmNlLWNsaWVudC5jb21cIixcbiAgICBcInJlZGRpdC1zZWN1cmVwYWdlLWhkc2poZzNqaDVnamFzZ2VkMzJoNGkyMzQ5ODAzNDM0NTUzLnNlY2dsb2JhbC5pY3VcIixcbiAgICBcInNlY2dsb2JhbC5pY3VcIixcbiAgICBcInJlZGRpdC1zZWN1cmVwYWdlLWhkc2poZzNqaDVnamFzZ2VkMzJoNGkyMzQ5NmpoZ2g2Nzd1LnNlY2dsb2JhbC5pY3VcIixcbiAgICBcImJsYWNrY2hvaW4uaW5mb1wiLFxuICAgIFwibXlybGhlcndhbGxldC5jb21cIixcbiAgICBcImlpZGV4LnB3XCIsXG4gICAgXCJteWV0aGlyd2FpbGV0cy5jb1wiLFxuICAgIFwiYmluYW5jZS1tYXJnaW4uY29tXCIsXG4gICAgXCJjcnlwdG9naXZlYXdheXMudG9wXCIsXG4gICAgXCJsaWRleC5wd1wiLFxuICAgIFwidG9rZW5zbWFya2V0Lm9ubGluZVwiLFxuICAgIFwidGVsb3MtZnVuZGF0aW9uLmlvXCIsXG4gICAgXCJteWNvZnRlcndhbGxldC5jb21cIixcbiAgICBcInhuLS1ibG9rY2hhbi11MGE4ZC5jb21cIixcbiAgICBcIm15ZXRoaGVyZXdhbGxldC5jb21cIixcbiAgICBcInByb21vLXRlc2xhLnN0b3JlXCIsXG4gICAgXCJsZGV4bWFya2V0LnB3XCIsXG4gICAgXCJldGguZWxvbm11c2stdGVzbGEuc3BhY2VcIixcbiAgICBcImVsb25tdXNrLXRlc2xhLnNwYWNlXCIsXG4gICAgXCJ0ZXNsYXN0b3JlLWdpdmVhd2F5Lm9ubGluZVwiLFxuICAgIFwiYnV5N2J0Yy5vbmxpbmVcIixcbiAgICBcImJ1eTdidGMucHJvXCIsXG4gICAgXCJ0ZW5vY3J5cHQuY29tXCIsXG4gICAgXCJlbG9uLXNwYWNleC5wcm9tb1wiLFxuICAgIFwiZWxvbi1zcGFjZXguY29tXCIsXG4gICAgXCJlbG9uLXNwYWNleC5vbmxpbmVcIixcbiAgICBcImVsb24tc3BhY2V4LnN0b3JlXCIsXG4gICAgXCJnaXZlYXdheXRlc2xhLm1lXCIsXG4gICAgXCJ2d3YtYmluYW5jZS5jb21cIixcbiAgICBcInRlYmVzdGluYS5pbmZvXCIsXG4gICAgXCJlbG9uLXRlc2xhLmluZm9cIixcbiAgICBcIndhbGxldGdlbmVyYXRvci5vcmdcIixcbiAgICBcImJuYi1iaW5hbmNlLmNvbVwiLFxuICAgIFwid3d3LXZudGFnZS1teWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwid3d3LXZpbnRhZ2UtbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcInd3dy12aW50YXFlLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJ3d3ctdm5pdGFnZS1teWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwid3d3MS12aW50YWdlLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJsZGV4LnB3XCIsXG4gICAgXCJibGNja2NoaWFuLmxjZ2puLmNvbVwiLFxuICAgIFwibGNnam4uY29tXCIsXG4gICAgXCJibG9ka2NoaWFuLmNvbVwiLFxuICAgIFwiZ2l2ZWF3YXktdGVzbGEuY2x1YlwiLFxuICAgIFwiY29pbnRvLnVzXCIsXG4gICAgXCJsYXVuY2hwYWRiaW5hbmNlLmNvbVwiLFxuICAgIFwibGF1bmNocGFkLWJpbmFuY2UuY29tXCIsXG4gICAgXCJjcnlwdG8tbXVsdC5pb1wiLFxuICAgIFwiYnRjLmNyeXB0by1tdWx0LmlvXCIsXG4gICAgXCJsdGMuY3J5cHRvLW11bHQuaW9cIixcbiAgICBcImRvZ2UuY3J5cHRvLW11bHQuaW9cIixcbiAgICBcInhlcHB3YWxsZXQuaW9cIixcbiAgICBcImRleHRlc3RuZXQtYmluYW5jZS5jb21cIixcbiAgICBcImRleGJpbmFuY2UuaW5cIixcbiAgICBcIm15ZWh0ZXJ2YWxsZXQuY29tXCIsXG4gICAgXCJyZWNlaXZlLWV0aGVyZXVtLmNvbVwiLFxuICAgIFwiZ294dHJhZGUuY29tXCIsXG4gICAgXCJldGJjd2FsbGV0LmNvbVwiLFxuICAgIFwiaWxkZXgucHdcIixcbiAgICBcImJsb2NrY2hhaW54eXouMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcImJsb2NrY2hhaW5oYWNrZXIubmV0XCIsXG4gICAgXCJiaW5hbmNlLXplbmRlc2submV0XCIsXG4gICAgXCJjYXNoYml0LndvcmxkXCIsXG4gICAgXCJtaW5pbmdiYW5raW5nLmNvbVwiLFxuICAgIFwiY29uc3RhbnRpbm9wbGUuc2l0ZVwiLFxuICAgIFwidHJhbnNmZXItYnRjLndlYnNpdGVcIixcbiAgICBcInRlc2xhLWdpZnQuY2x1YlwiLFxuICAgIFwibWVkaXVtLnJldHVybi1idGMuY29tXCIsXG4gICAgXCJyZXR1cm4tYnRjLmNvbVwiLFxuICAgIFwidHJlem9yLW9mZmljaWFsLmxpbmtcIixcbiAgICBcImdpdmVhd2F5LXhycC5jb21cIixcbiAgICBcImlkZXgtbWFya2V0LnB3XCIsXG4gICAgXCJ4bi0tcG9sb25leC1jemEuY29tXCIsXG4gICAgXCJ4Y3J5cHRvZnVuZHMuY29tXCIsXG4gICAgXCJidXk3MDAwYnRjLm9ubGluZVwiLFxuICAgIFwiaWRleG1hcmtldC5wd1wiLFxuICAgIFwiZXhvZHVzLXdhbGxldC5uZXRcIixcbiAgICBcInRyZXpvci13YWxsZXQubGFcIixcbiAgICBcImNvbWV0Y3J5cHQuY29tXCIsXG4gICAgXCJldGhtYXJrZXQuc3RvcmVcIixcbiAgICBcImJ0Yy1wcm8uY29cIixcbiAgICBcInBsYXRmb3JtLWJpdG1leC5jb21cIixcbiAgICBcImNvbnN0YW50aW5vcGxlaGFyZGZvcmsuY2ZcIixcbiAgICBcImVsb24tZ2lmdGluZy53ZWJzaXRlXCIsXG4gICAgXCJ0ZXNsYTMub3JnXCIsXG4gICAgXCJldGhub2NyeXB0LmNvbVwiLFxuICAgIFwiY2FzaGFkZC5vcmdcIixcbiAgICBcImV4bW8uaW4udWFcIixcbiAgICBcInRlc2xhLWdpZnQuc3BhY2VcIixcbiAgICBcImlkZXh4LnB3XCIsXG4gICAgXCJvZmZpY2lhbC1lbG9uLnNwYWNlXCIsXG4gICAgXCJpZGV4bWFydGsubmV0XCIsXG4gICAgXCJhaXJkcm9wLXJ1bm5pbmcuaW5mb1wiLFxuICAgIFwibXliaXRjb2lucXJjb2RlLmNvbVwiLFxuICAgIFwiY2xpZW50LXRlemJveC5jb21cIixcbiAgICBcImJpbmFuY2UuYmludGVzdG5ldC5jb21cIixcbiAgICBcImJpbnRlc3RuZXQuY29tXCIsXG4gICAgXCJpY28tc2Ftc3VuZy5vcmdcIixcbiAgICBcImJ0Y2RhaWx5LmluZm9cIixcbiAgICBcImNoYW5jZS5zZXJ2aWNlc1wiLFxuICAgIFwiYmlvY2tjaGFpbm4uY29tXCIsXG4gICAgXCJzdXBlcm1pbmluZy53ZWJzaXRlXCIsXG4gICAgXCJiaW5hbmNlLWRleC5jZlwiLFxuICAgIFwiZWxlY3RydW0ubXhcIixcbiAgICBcImwtamF4eC5pb1wiLFxuICAgIFwieG4tLS0taXRiamFiN2Fka2Fjb2NlZ2I5ZXRkMmMueG4tLXAxYWlcIixcbiAgICBcInJpcHBsZWdpdmVhd2F5Lm5ldFwiLFxuICAgIFwiaS1kZXgucHdcIixcbiAgICBcImJpdGhvbXAuaW5mb1wiLFxuICAgIFwiY29pbnByb21vLmZ1bmRcIixcbiAgICBcImJpdGNvaW4tYnRjLXFyLWNvZGUtZ2VuZXJhdG9yLmNvbVwiLFxuICAgIFwidGh1bmRlcmNvcmUuc3BhY2VcIixcbiAgICBcInhuLS1tcmNhdG94LWJ5YS5jb21cIixcbiAgICBcInRydXN0c3dhbGxldC54eXpcIixcbiAgICBcImVsZWN0cnVtLmxhXCIsXG4gICAgXCJpZGV4LnB3XCIsXG4gICAgXCJidGMtZ2lmdC5jb21cIixcbiAgICBcImJpbi10ZXN0bmV0LmNvbVwiLFxuICAgIFwiNC14cnAuY29tXCIsXG4gICAgXCJsaXZlLWV0aGVycy5jb21cIixcbiAgICBcImNvaW5taW5pbmcud2Vic2l0ZVwiLFxuICAgIFwiY29pbnByb21vLmljdVwiLFxuICAgIFwiYml0aHVtYi5jZlwiLFxuICAgIFwieHJwYnVsbGlzaC5ibG9nc3BvdC5jb21cIixcbiAgICBcImJpdGxob21wLmNvbVwiLFxuICAgIFwicmlwcGxlLWluZm9naXZlYXdheS5jb21cIixcbiAgICBcImJvbnVzbW9udGhseS5ibG9nc3BvdC5jb21cIixcbiAgICBcImRleC1sYXVuY2gubmV0XCIsXG4gICAgXCJ4cnAuZWFydGhcIixcbiAgICBcIm1pY3JvdGVzdGRpZ2l0YWxhZ2VuY3kuaG9zdFwiLFxuICAgIFwiYml0Y29pbi1kb3VibGVyLnVzXCIsXG4gICAgXCJhdG9taWN3YWxsZXQudGVjaFwiLFxuICAgIFwiaWRleC5jYXNoXCIsXG4gICAgXCJyaXBwbGVib3VudHkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJzYXRvc2hpbGl0ZS5wcm9tb1wiLFxuICAgIFwiYml0bWV4LWFpcmRyb3AuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLXZlcmlmeS5jb21cIixcbiAgICBcImNvaW5kZWNrZXIuY29tXCIsXG4gICAgXCJldmVyZXguY2FzaC5ldmVudHMtZXJjLTIwLmNvbVwiLFxuICAgIFwiZXZlbnRzLWVyYy0yMC5jb21cIixcbiAgICBcInRva2Vuc3RvcmUuc3RvcmVcIixcbiAgICBcImJvdW50eXhycC5ibG9nc3BvdC5hbVwiLFxuICAgIFwiYm91bnR5eHJwLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiaWNvLW1hdGljLm5ldHdvcmtcIixcbiAgICBcIndhbGxldC10cmV6b3IuaW8tYmFja3VwLW9ubGluZS5pbmZvXCIsXG4gICAgXCJpby1iYWNrdXAtb25saW5lLmluZm9cIixcbiAgICBcImV4b2R1c3dhbGxldC5pb1wiLFxuICAgIFwibWF0aWMubGl2ZVwiLFxuICAgIFwiYnV0ZXJpbi1wcm9tby5pbmZvXCIsXG4gICAgXCJldGhnaWZ0LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYmluYW5jZS5iaWx0dGx5LmNvbVwiLFxuICAgIFwiYml0bHZ5LmNvbVwiLFxuICAgIFwiYmluYW5jZS5iaXRsdnkuY29tXCIsXG4gICAgXCJiaW5hbmNlLmJuYmNyeXB0b2ZpYXQuY29tXCIsXG4gICAgXCJibmJjcnlwdG9maWF0LmNvbVwiLFxuICAgIFwieHJwLXJpcHBsZS5vcmdcIixcbiAgICBcImlkZXguZGV2XCIsXG4gICAgXCJnZXQtbHRjLW5vdy5vbmxpbmVcIixcbiAgICBcImhlbGxvZ29sZGNvbnRyYWN0LmNvbVwiLFxuICAgIFwidGhlLXNwZWN0cnVtbmV0d29yay5jb21cIixcbiAgICBcInBheGZ1aXZlcmlmeS5pbmZvXCIsXG4gICAgXCJiZXNldGNoYW5nZS5vcmcucnVcIixcbiAgICBcImJsb2NrY2hhaS13LmluZm9cIixcbiAgICBcImJlc3RtaXhlci5pbmZvXCIsXG4gICAgXCJiaW4tZGV4LmNsdWJcIixcbiAgICBcImNsYWltLXRva2VuLWRndHguY29tXCIsXG4gICAgXCJkaWdpdGV4ZnV0dXJlcy5jb20uY2xhaW0tdG9rZW4tZGd0eC5jb21cIixcbiAgICBcImRleC1sYXVuY2guY29tXCIsXG4gICAgXCJkZXhiZXRhbGF1bmNoY2FtcGFpZ24uY29tXCIsXG4gICAgXCJiaXRjb2luLWJ0Yy1hZGRlci5jb21cIixcbiAgICBcImNvbnN0YW50aW5vcGxlcGx1cy50ZWNoXCIsXG4gICAgXCJ0b2tlbnNpY28ub25saW5lXCIsXG4gICAgXCJvZmZpY2lhbC1iaW5hbmNlLnNwYWNlXCIsXG4gICAgXCJybnVldGhlcmV3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0ZXJld2FsbGlldC5jb21cIixcbiAgICBcImdydXpvdnllc3BlY2F2dG92ZXN5Lm9ubGluZVwiLFxuICAgIFwiZ2RheC51c1wiLFxuICAgIFwiaGlsbHN0cmFkZS5uZXRcIixcbiAgICBcImRlY2VudHJhbGl6ZWQtbGF1bmNoLmNvbVwiLFxuICAgIFwiYmluYW5jZWJuYi1kZXgubmV0XCIsXG4gICAgXCJ4bi0tbGdpbi1ibG9ja2NoYWluLWRsNWguY29tXCIsXG4gICAgXCJ4bi0tbG9nbi1ibG9ja2NoYW4tMmxiay5jb21cIixcbiAgICBcImJsb2NrY2hhaW4tMDE1ODI3NS5pbmZvXCIsXG4gICAgXCJibG9ja2NoYWluLTAxNzQ2MjguaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbi0wMTgyNzE5LmluZm9cIixcbiAgICBcImJsb2NrY2hhaW4tMDE5Mzc2NS5pbmZvXCIsXG4gICAgXCJibG9ja2NoYWluLTAyODk0ODguaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbi0xMDM1OC5pbmZvXCIsXG4gICAgXCJibG9ja2NoYWluLTE1NjEuaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbi0xOTkzNzIuaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbi00MDE5ODguaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbi05MDE3NDIuaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbi05MTg0MjUuaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbi05NTAxLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLWV0aC5uZXR3b3JrXCIsXG4gICAgXCJjb20tZXRoLm5ldHdvcmtcIixcbiAgICBcImJuYi1sYXVuY2guZXVcIixcbiAgICBcImVsZWN0cnVtLmJ6XCIsXG4gICAgXCJibmItdGVzdG5ldC5jb21cIixcbiAgICBcIm1hdGljLW5ldHdvcmsuY29tXCIsXG4gICAgXCJmb3J0dW5lamFjay5jY1wiLFxuICAgIFwiZGV4LmJpbmFuY2Uub3JnLm56XCIsXG4gICAgXCJiaW5hbmNlLm9yZy5uelwiLFxuICAgIFwicm55YXRoYXJ3ZWxsYXQuY29tXCIsXG4gICAgXCJnZXQteGxtLXN0ZWxsYXIub3JnXCIsXG4gICAgXCJrYXJ0aXkuY29tXCIsXG4gICAgXCJkZXh0ZXN0bmV0LmNvbVwiLFxuICAgIFwiZHJlcC13YWxsZXQuY29tXCIsXG4gICAgXCJ1cGRhdGViaW5hbmNlLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1hZG1pbi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbGUtNGs1Zi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xldC0za2I4MGYuY29tXCIsXG4gICAgXCJibG9ja2NobmFpbi5pbmZvXCIsXG4gICAgXCJibG9jaGNoYWkuaW5mb1wiLFxuICAgIFwiYmxvY2hjaGFpbS5pbmZvXCIsXG4gICAgXCJibG9jaWNoYWluLmNvbVwiLFxuICAgIFwiYmxvY2lja2NoYWluLmNvbVwiLFxuICAgIFwiYml0dHJleGkub25saW5lXCIsXG4gICAgXCJ4bi0taW50ZW5hdGlvbmFsLWJpdHRyZXgtNjVnLmNvbVwiLFxuICAgIFwieG4tLWludHJuYXRpb25hbC1iaXR0cmV4LXl5Zy5jb21cIixcbiAgICBcImJsb2NraG9sbi5jb21cIixcbiAgICBcImJsb2NraW5jaGFpbi5wbFwiLFxuICAgIFwiYmxvY2xrY2hhaW4uY29tXCIsXG4gICAgXCJwYXhmdWx1cGRhdGUuY29tXCIsXG4gICAgXCJ4bi0tYml0dHJ4LXR2YS5jb21cIixcbiAgICBcInhuLS1idHRyZXgtYjlhLmNvbVwiLFxuICAgIFwiaHR0cHMtYmxvY2NrY2hhaW4uY29tXCIsXG4gICAgXCJ5b2JpdC13YWxsZXQuY29tXCIsXG4gICAgXCJoaXR0YnRjLm5ldFwiLFxuICAgIFwicm55ZWF0bGVyd2FpdGV0LmNvbVwiLFxuICAgIFwiYmFja3hjb2luLmNvbVwiLFxuICAgIFwiYWRtYWV0by5jb21cIixcbiAgICBcInZlcmlmeS1ibG9jaC1jaGFpbi5jb21cIixcbiAgICBcImJsb2NraGNoYWluLmluZm9cIixcbiAgICBcImJsb2tjaWhhaW4uY29tXCIsXG4gICAgXCJ4bi0tYmxja2NoYWluLTY2YS5jb21cIixcbiAgICBcInZlcmlmeS1jb2luYmFzZS5jb21cIixcbiAgICBcImJsb2NrY2hhaWlpbi5jb21cIixcbiAgICBcImNvaW5iYXNlLnByby14YS5jb21cIixcbiAgICBcInByby14YS5jb21cIixcbiAgICBcImJsb2NrY2loYWluLmNvbVwiLFxuICAgIFwibWVkaXVtLndpa2lcIixcbiAgICBcImV0aGVycy50b2RheVwiLFxuICAgIFwiYml0Y29pbnJ1LXdhbGxldC5zaXRlXCIsXG4gICAgXCJiaXRjb2luMjQtd2FsbGV0LnNpdGVcIixcbiAgICBcImJpdGNvaW4td2FsbGV0cnUuc2l0ZVwiLFxuICAgIFwiYmxva2hjaGlhbi13YWxsZXQueHl6XCIsXG4gICAgXCJibG9jbGtjaGFsbi5vbmxpbmVcIixcbiAgICBcImJsb2NrY2hhaW53YWxsZXRvZmZpY2FsLmNvbVwiLFxuICAgIFwid3d3LS0tYmluYW5jZS5jb21cIixcbiAgICBcInhuLS1pbnRybmF0aW9uYWwtYml0dHJleC15dWMuY29tXCIsXG4gICAgXCJiaW5hbmNlLXRlc3RuZXQubmV0XCIsXG4gICAgXCJteWV0aGVydnZhbGxldC5jby51a1wiLFxuICAgIFwicGF4ZnVsLWVzLmNvbVwiLFxuICAgIFwieG4tLWJpdHRyeC03aDhiLmNvbVwiLFxuICAgIFwieG4tLWJ0dHJ4LXE1MWJtZS5jb21cIixcbiAgICBcImJsb2NrY2hhaW4tMjUxLnJ1XCIsXG4gICAgXCJibG9ja2NoYWluLTI1Mi5ydVwiLFxuICAgIFwiYmxvY2tjaGFpbi0yNTMucnVcIixcbiAgICBcImJsb2NrY2hhaW4tMjU0LnJ1XCIsXG4gICAgXCJibG9ja2NoYWluLTI1NS5ydVwiLFxuICAgIFwiYmxvY2tjaGFpbi0yNTYucnVcIixcbiAgICBcImJsb2NrY2hhaW4tMjU3LnJ1XCIsXG4gICAgXCJibG9ja2NoYWluLTI1OC5ydVwiLFxuICAgIFwiYmxvY2tjaGFpbi0yNTkucnVcIixcbiAgICBcImJsb2NrY2hhaW4tMjYwLnJ1XCIsXG4gICAgXCJ4bi0tZWVjdHJ1bS05aGIub3JnXCIsXG4gICAgXCJ4bi0tZWxldHJ1bS00NWEuY29tXCIsXG4gICAgXCJ4bi0taW50ZXJuYXRpbmFsLWJpdHRyZXgtNG5oLmNvbVwiLFxuICAgIFwieG4tLWludGVybmF0aW5hbC1iaXR0cmV4LXE4NmsuY29tXCIsXG4gICAgXCJ4bi0taW50ZXJuYXRvbmFsYml0dHJleC03MWMuY29tXCIsXG4gICAgXCJncmFtLm9uZVwiLFxuICAgIFwiYml0dHJleHZlcmlmeW1lcGxlYXNlLmNvbVwiLFxuICAgIFwiaW50ZXJuZWF0aW9uYWwtYml0dHJleC5jb21cIixcbiAgICBcImxvZ2luYml0dHJleC5jb21cIixcbiAgICBcIm15ZXRoZXJ2dmFsbGV0LnZpcFwiLFxuICAgIFwieG4tLWJpdHRleC1sa2MuY29tXCIsXG4gICAgXCJ4bi0tYnRzdGFtcC1lZWIubmV0XCIsXG4gICAgXCJ6b2xsby5pb1wiLFxuICAgIFwidGRlLnpvbGxvLmlvXCIsXG4gICAgXCJ6aWxsaXFhYmxvZy5jb21cIixcbiAgICBcInJlZ2lzdGVyLnpvbGxvLmlvXCIsXG4gICAgXCJ4bi0tbnRlcm5hdGlvbmFsLWJpdHRyZXgtOTY2ay5jb21cIixcbiAgICBcImhpdGJ0Yy5jb20ucGxcIixcbiAgICBcImJsY29rY2hhaW4ubGxvcWluLmNvbVwiLFxuICAgIFwibGxvcWluLmNvbVwiLFxuICAgIFwibGRheC5tYXJrZXRcIixcbiAgICBcImlkZXhjb3JwLmNvbVwiLFxuICAgIFwiaWRleGNvcnAuY29tZ2cuZ2dcIixcbiAgICBcImludmVzdG1lbnQyeC5vbmxpbmVcIixcbiAgICBcImVsZWN0cnVtc2VjdXJlZG93bmxvYWQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNsYWltLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1jbGFpbS5uZXRcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtY2xhaW0ub3JnXCIsXG4gICAgXCJteWV0aG92ZXJ3YWxsdWV0LnNpdGVcIixcbiAgICBcIm15ZXRoc29uZW1hbGx2ZXQuc2l0ZVwiLFxuICAgIFwibXlldGhzb25ld2FsbHJldC5pY3VcIixcbiAgICBcIm15ZXRoc2Nob29sY2xhc3MucHdcIixcbiAgICBcImt1Y29pbi1hY3Rpdml0eS5jb21cIixcbiAgICBcIm10Yy1pY28ub25saW5lXCIsXG4gICAgXCJldGhlcmV1bTIub25saW5lXCIsXG4gICAgXCJjcnlwdG9lbXBpcmVpbmMuY29cIixcbiAgICBcInJpcHBsZWJvbnVzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiaWRleHguc2l0ZVwiLFxuICAgIFwibXlldGhhbnRpd2FsbGNhZmUuY2x1YlwiLFxuICAgIFwiY29pbmJhc2UtZ2V0Y3J5cHRvLjg5MG0uY29tXCIsXG4gICAgXCJiaXRoZXh0cmFkZS5jb21cIixcbiAgICBcIm1hdGljLndvcmtcIixcbiAgICBcInhuLS1idHRyeC15M2E1NjA0Yy5jb21cIixcbiAgICBcImJsb2NrY2hhaW4tMTMwLnJ1XCIsXG4gICAgXCJiaW5hbmNlLXRlc3RuZXQuaG9zdFwiLFxuICAgIFwiYmluYW5jZS10ZXN0bmV0LmZ1blwiLFxuICAgIFwiYmluYW5jZS1kZXh0ZXN0bmV0LnNpdGVcIixcbiAgICBcInJudWF0aGVydmF0bGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1ib251cy5pbmZvXCIsXG4gICAgXCJleG9kdXMtc3VwcG9ydC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtYm9udXMubmV0XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWJvbnVzLm9yZ1wiLFxuICAgIFwiYml0Y29pbnJ1LW9yZy5zaXRlXCIsXG4gICAgXCJjb2luYXB1bHQtbG9naW4uY29tXCIsXG4gICAgXCJibG9nYmlib3guY29tXCIsXG4gICAgXCJiaW5hbmNlLXRlc3RuZXQuY29tXCIsXG4gICAgXCJlYXJuZnJlZWJpdGNvaW5zLm9yZ1wiLFxuICAgIFwibXlldGh5b2dhd2FsbGNsYXNzLmljdVwiLFxuICAgIFwid293eC5pb1wiLFxuICAgIFwiY29pbmJ0Y2JvdC5jb21cIixcbiAgICBcImNhdGJvdC5ydVwiLFxuICAgIFwicGFyYWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwiYmluYW5jZWN6LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYnR0b3JlbnQuY29tXCIsXG4gICAgXCJ4bi0tY29pbmJzZS1lbjRjLmNvbVwiLFxuICAgIFwieW91ci1idGMuY28udWtcIixcbiAgICBcImNyeXB0b3Rpcy5jb21cIixcbiAgICBcImJ0Y2xkbi5jb21cIixcbiAgICBcImlsZGV4bWFya2V0LmluZm9cIixcbiAgICBcImJpdGNvaW4tZ29sZC1ibG9ja2NoYWluLmluZm9cIixcbiAgICBcImludGVybmF0aW9uYWwtYml0dHJleC1sb2dpbi5jb21cIixcbiAgICBcImludGVybmF0aW9uLWJpdHRyZXguY29tXCIsXG4gICAgXCJpbnRlcm5hdGxvbmFsLWJpdHRyZXguY29tXCIsXG4gICAgXCJpbnRlcm5hdGlvbmFsLWJpdHRyZXgtYS5jb21cIixcbiAgICBcIjEwMHgtbWx0LWJ0Yy5jb21cIixcbiAgICBcImNvbnN0YW50aW5vcGxlcGx1cy5pb1wiLFxuICAgIFwib2ZmaWNpYWwtdHJlem9yLmNjXCIsXG4gICAgXCJ1c2RkZXguaW9cIixcbiAgICBcIm1pdGhyaWwucHJvXCIsXG4gICAgXCJjcnlwdG94ZmFuLndlYnNpdGVcIixcbiAgICBcIndic2NvaW5zLmNvbVwiLFxuICAgIFwibmVvdHJhY2tlci5tZVwiLFxuICAgIFwiZ2lmdC13YWxsZXQtc3RlbGxhci5vcmdcIixcbiAgICBcImV0aC5lbG9uLW11c2suc3BhY2VcIixcbiAgICBcImJ0Yy5lbG9uLW11c2suc3BhY2VcIixcbiAgICBcImVsb24tbXVzay5zcGFjZVwiLFxuICAgIFwicm51YXRoZXJ2YWx0ZXQuY29tXCIsXG4gICAgXCJybnlldGhlcndhbGlldC5jb21cIixcbiAgICBcImNlbGVyLndvcmtcIixcbiAgICBcImVsZWN0cnVtcHJvamVjdC5vcmdcIixcbiAgICBcImlkZXgubW9uZXlcIixcbiAgICBcImNlbGVyYy5uZXR3b3JrXCIsXG4gICAgXCJrcmFrZW4tY29tLmdhXCIsXG4gICAgXCJleG9kdXN3YWxsZXQub25saW5lXCIsXG4gICAgXCJiaXRjb2luYXJtb3J5LnRlY2hcIixcbiAgICBcImNlbGVyLnRvZGF5XCIsXG4gICAgXCJjZWxlci5zaXRlXCIsXG4gICAgXCJjb2luYmFzZS1hcHAuZ2FcIixcbiAgICBcInJpcHBsZW5ldC5saW1pdGVkXCIsXG4gICAgXCJncmFtLW5ldHdvcmsub3JnXCIsXG4gICAgXCJ4eW9naWZ0Lm5ldHdvcmtcIixcbiAgICBcImJsb2NrY2hlaW4ubHBnaXJuLmNvbVwiLFxuICAgIFwibHBnaXJuLmNvbVwiLFxuICAgIFwidGhld2F5aGVyZS5hY2Nlc3NoZWFsdGhhdXRpc20uY29tLmF1XCIsXG4gICAgXCJobXFmb3VuZGF0aW9uLmNvbVwiLFxuICAgIFwib25peGNyeXB0LmNvbVwiLFxuICAgIFwibGRleG1hcmtldC5wcm9cIixcbiAgICBcInZpbnRhZ2UtbWV0aGVyd2FsbGV0LmNvXCIsXG4gICAgXCJiaXRjb2ludmVzdC50ZWNoXCIsXG4gICAgXCJiZXN0Y2RhbmplLm9yZy5ydVwiLFxuICAgIFwia3Jha2VuLWxvZ2luLm1sXCIsXG4gICAgXCJrcmFrZW4tbG9naW4uZ2FcIixcbiAgICBcImdyYW0tbmV0d29yay5uZXRcIixcbiAgICBcImV0aGVyc2FsZS5vbmxpbmVcIixcbiAgICBcImh1b2JpYWlyZHJvcC5jb21cIixcbiAgICBcImdldC1naWZ0LXN0ZWxsYXIub3JnXCIsXG4gICAgXCJldGhlcnMtbGl2ZS5jb21cIixcbiAgICBcImZvcmV4ZXRvcm8uY29tXCIsXG4gICAgXCJodW9iaS1haXJkcm9wLm9yZ1wiLFxuICAgIFwiaHVvYmlhaXJkcm9wLmNvXCIsXG4gICAgXCJlbGVjdHJ1bWNpcmNsZS5jb21cIixcbiAgICBcImwtZWxlY3RydW0ub3JnXCIsXG4gICAgXCJwYXhmdWwtZGFzaGJvYXJkLmNvbVwiLFxuICAgIFwicGF4ZnVsdXNlci5jb21cIixcbiAgICBcInZsbnRhZ2UtbXlldGhlcmVzd2FsbGV0LmNvbVwiLFxuICAgIFwicm15ZXRoZXJld2FsbGV0LmNvbVwiLFxuICAgIFwiaWRleHhvbmxpbmUuY29tXCIsXG4gICAgXCJteWNyeXB0by5rclwiLFxuICAgIFwicC1lb3MuaW9cIixcbiAgICBcImJ0YzI0ZXgucHJvXCIsXG4gICAgXCJnZXQtMTAwMDAteGxtLm9yZ1wiLFxuICAgIFwiYmxvY2tja2NoYWluLmluZm9cIixcbiAgICBcImdpZnQtbHVtZW5zLXN0ZWxsYXIub3JnXCIsXG4gICAgXCJteWVsZXZlbndhbGxzZW4uc2l0ZVwiLFxuICAgIFwiZGV4bGF1bmNoLXRlc3RuZXQuc3BhY2VcIixcbiAgICBcIm1veWJsb2dzcG9yLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYm91bnR5LXBsYXRmb3JtLndlYnNpdGVcIixcbiAgICBcImNlbGVyLnNwYWNlXCIsXG4gICAgXCJsYXVuY2hwYWQuY2VsZXIuc3BhY2VcIixcbiAgICBcIndhbGxldC5lbGl0ZXRyZXVtLmNvbVwiLFxuICAgIFwiZWxpdGV0cmV1bS5jb21cIixcbiAgICBcImRvZ3guZG9nXCIsXG4gICAgXCJjcnlwdG94aW52ZXN0LmNvbVwiLFxuICAgIFwicGF4ZnVsY29uZmlybWF0aW9uLmNvbVwiLFxuICAgIFwicC1lb3Mub25lXCIsXG4gICAgXCJpZGV4LndlYnNpdGVcIixcbiAgICBcIngtY3J5cHRvLmluZm9cIixcbiAgICBcIm5weHMucHJvXCIsXG4gICAgXCJldGhlcmV1bS1jb25zdGFudGlub3BsZS5jb21cIixcbiAgICBcImdpZnQ3NTAweGxtLm9yZ1wiLFxuICAgIFwiYXpiaXQub3JnXCIsXG4gICAgXCJiaXR0b3JlbnQuc2l0ZVwiLFxuICAgIFwiZGV4LWJpbmFuY2VzLmluZm9cIixcbiAgICBcImV4b2R1cy13YWxsZXQuaW5mb1wiLFxuICAgIFwiaWRleHhtYXJrZXQud2Vic2l0ZVwiLFxuICAgIFwibG9jYWlibHRjb2lucy5ydVwiLFxuICAgIFwibXlldGhjd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC12aW50YWdlLmNvXCIsXG4gICAgXCJvZmZpY2lhbC10cmV6b3Iub3JnXCIsXG4gICAgXCJwYXhmdWwtbG9naW4uaWRcIixcbiAgICBcInBheGZ1bGhlbHAuY29tXCIsXG4gICAgXCJwYXhmdWx0cmFkZS5tbFwiLFxuICAgIFwicGF4bGxmdWwuY29tXCIsXG4gICAgXCJ2bG50YWdlLW15ZXRoZXJld2FsbGV0LmNvbVwiLFxuICAgIFwieG4tLW15ZXRlcndhbGx0LW5sOGV5M2UuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbHQtamZlODkxNmcuY29tXCIsXG4gICAgXCJ4bi0tbXl0ZXJ3YWxsZXQtbWw4ZXEzZS5jb21cIixcbiAgICBcImx0Y2dpdmVhd2F5Lm9ubGluZVwiLFxuICAgIFwiZWxlY3RyZXguaW5mb1wiLFxuICAgIFwiYmluYW5jZS1ib251cy5vbmxpbmVcIixcbiAgICBcImJpbmFuY2Utc3VwcG9ydC5ob21lLmJsb2dcIixcbiAgICBcImJpbmFuY2UuY29tMTYxNTg3MzI2MS5nYVwiLFxuICAgIFwiYmluYW5jZS5jb20xOTgzNzYyMTYxLm1sXCIsXG4gICAgXCJiaW5hbmNlLm11c2ljLmJsb2dcIixcbiAgICBcImJpbmFuY2VjdXN0b21lcnN1cHBvcnQxODg4MzAyMzQ0NC5ob21lLmJsb2dcIixcbiAgICBcImJpbmFuY2VzLnNpdGVcIixcbiAgICBcImJpbmFuY2VzdXBwb3J0LmhvbWUuYmxvZ1wiLFxuICAgIFwiY20tY29pbm1hc3Rlci5ob21lLmJsb2dcIixcbiAgICBcImNvaW5iYXNleHJwLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiY29pbmJhemUub25saW5lXCIsXG4gICAgXCJjb2luaW5kZXgudGVjaFwiLFxuICAgIFwiY3BhbmVsLm15aWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwiaW1hZ2VvbmxpbmUuZ2FcIixcbiAgICBcImxkZXhtYXJrZXQuc2l0ZVwiLFxuICAgIFwibGljYWxiaXRjb2lucy5vcmdcIixcbiAgICBcImxvY2FsYml0Y29paHMucnVcIixcbiAgICBcImxvY2FsYml0Y29pbmQuaWN1XCIsXG4gICAgXCJsb2NhbGJpdGNvaW5kLm1vYmlcIixcbiAgICBcImxvY2FsYml0Y29pbnMtcnVzLnJ1XCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zcy5pbmZvXCIsXG4gICAgXCJsb2NhbGJpdGNvbmlzLmluZm9cIixcbiAgICBcImxvY2FsYml0Y291aW5zLm1vYmlcIixcbiAgICBcImxvY2FsYml0Y291aW5zLnByb1wiLFxuICAgIFwibG9jYWxuaXRjb2lucy5pbmZvXCIsXG4gICAgXCJsb2NhbHZpdGNvaW5zLmluZm9cIixcbiAgICBcImxvY3NsYml0Y29pbnMuaWN1XCIsXG4gICAgXCJsb2thbGJpdGNvbnMuY29tXCIsXG4gICAgXCJtYWlsLmJpdHRyZXgxLmNvbVwiLFxuICAgIFwibXllbGhlcmVzd2FsbGV0LmNvbVwiLFxuICAgIFwibXllbGhlcndhbGljZXQuY29tXCIsXG4gICAgXCJteWV0ZXJ3b2xsZXQuY29tXCIsXG4gICAgXCJteWV0aGVsd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcm13YWxsZXQuY29tXCIsXG4gICAgXCJteWlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15cGF4ZnVsLmNvbVwiLFxuICAgIFwicGF4ZnVsLmdxXCIsXG4gICAgXCJwYXhmdWwudmlwXCIsXG4gICAgXCJwYXhmdWxzdXBwb3J0cy5jb21cIixcbiAgICBcInBheGZ1bHZlcmlmeS53ZWJzaXRlXCIsXG4gICAgXCJzaWduaW4tY29pbmJhc2UuY29tXCIsXG4gICAgXCJ0ZWxvc2Z1bmRhdGlvbi5pb1wiLFxuICAgIFwidHJlem9yLXNhbGUuY29tXCIsXG4gICAgXCJ0cmV6b3Itc2hvcC53ZWJzaXRlXCIsXG4gICAgXCJ2aW50YWdlLW15ZXRoZXJld2FsbGV0LmNvbVwiLFxuICAgIFwidmludGFnZS5teWV0aGVyZXdhbGxldC5jb21cIixcbiAgICBcInZpbnRhcWUtbXlldGhlcmV3YWxsZXQuY29tXCIsXG4gICAgXCJ4bi0tYmFuY2UtM2wxYjAzYi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsdC1jcmI0OWIuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGUtamI5ZXk5YS5jb21cIixcbiAgICBcImJpbmFuY2UtdGVzdG5ldC5zaXRlXCIsXG4gICAgXCJtb25lcm8tcmluZ3Mub3JnXCIsXG4gICAgXCJteXhybXdhbGxldC5jb21cIixcbiAgICBcInJueXV0aGV3YWxsZXQueHl6XCIsXG4gICAgXCJoZXV2ZWxsYW5kY2F0ZXJpbmcuY29tXCIsXG4gICAgXCJ2bG50YWdlLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJpZGV4LW1hcmtldC1jb20uaW5mb1wiLFxuICAgIFwiYmluYXJpcHBsZS5ibG9nc3BvdC5jb21cIixcbiAgICBcImJpbmFmZWIuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJmZXRjaGFpLm5ldFwiLFxuICAgIFwiYmluYW5jZS1zdXBwb3J0LW51bWJlci5jb21cIixcbiAgICBcImh0dHBzbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcImRlbHRhZm9yay5hcHBcIixcbiAgICBcInlvYml0ZXgtcnUubmV0XCIsXG4gICAgXCJwYXhmdWx0cmFkZS54eXpcIixcbiAgICBcImZldGNoYWkuZXVcIixcbiAgICBcImJpdGNvaW4tdXBkYXRlLmluZm9cIixcbiAgICBcImJyYWQtcHJvbW8uaW5mb1wiLFxuICAgIFwicm55dXRoZXZ2YWxsZXQuY29tXCIsXG4gICAgXCJidHRhaXJkcm9wLmNvbVwiLFxuICAgIFwiZWxlY3RydW0ub3JnLnVrXCIsXG4gICAgXCJybnl1dGhldmFsbGV0Lnh5elwiLFxuICAgIFwiZmV0Y2gtYWkubmV0XCIsXG4gICAgXCJwYXhmdWxsLmdhXCIsXG4gICAgXCJtdXNrLmNlbnRlclwiLFxuICAgIFwidGVsZWdyYW0uc3lzdGVtc1wiLFxuICAgIFwiZmV0Y2hhaS5jb1wiLFxuICAgIFwiZmV0Y2hhaS5vcmdcIixcbiAgICBcImVsZWN0cnVtaG9tZS5vcmdcIixcbiAgICBcInhuLS1teWV0aGV3YWx0LXptYjc1YmdsLmNvbVwiLFxuICAgIFwidmludGFxZS1teWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibG9naW4tYmxvY2tjaGFhaW4uY29tXCIsXG4gICAgXCJsb3Fpbi1ibG9ja2NoYWluLmNvbVwiLFxuICAgIFwibG9xaW4tYmxvY2tjaGFsbi5jb21cIixcbiAgICBcInZpbnRhZ2VteWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwieG4tLW1lZHVtLTg1YS5jb21cIixcbiAgICBcInJudGhlcndhbGxldC5pY3VcIixcbiAgICBcIm15ZXRocmV3YWxsZXQueHl6XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Y29tLnh5elwiLFxuICAgIFwibXlldGhlcndhbGxldGNvbS53ZWJzaXRlXCIsXG4gICAgXCJ3d3dteWV0aGVyd2FsbGV0LnNob3BcIixcbiAgICBcInd3d215ZXRoZXJ3YWxsZXQuaWN1XCIsXG4gICAgXCJldGhlcndhbGxldHMuaW5mb1wiLFxuICAgIFwibXlkb2dlY2hhaW5zLmluZm9cIixcbiAgICBcInJudGhlcndhbGxldC54eXpcIixcbiAgICBcInhycGJpbmFuLmJsb2dzcG90LmNvbVwiLFxuICAgIFwibXVzay5jcmVkaXRcIixcbiAgICBcIm11c2suZnlpXCIsXG4gICAgXCJiaW5hbmNlZWUuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJiaW5hbmNlZWUuYmxvZ3Nwb3QubHRcIixcbiAgICBcImJpbmFuY2VlZS5ibG9nc3BvdC5jb20ubXRcIixcbiAgICBcInBheGZ1bC5sb2ctaWluLmNvbVwiLFxuICAgIFwibG9nLWlpbi5jb21cIixcbiAgICBcIm15ZWhsZXJ3YWwuY29tXCIsXG4gICAgXCJhdG9tY3dhbGxldC5jb21cIixcbiAgICBcImF0b21jd2FsbGV0LmNsdWJcIixcbiAgICBcImF0b21zd2FsbGV0LmNvXCIsXG4gICAgXCJhdG9tc3dhbGxldC5tZVwiLFxuICAgIFwiYXRvbXN3YWxsZXQub3JnXCIsXG4gICAgXCJhdG9tY3dhbGxldC5iaXpcIixcbiAgICBcImJpdHRyZXgtbG9naW4uaW50ZXItY2xpZW50ZS5vbmxpbmVcIixcbiAgICBcImludGVyLWNsaWVudGUub25saW5lXCIsXG4gICAgXCJzdG9yZS10cmV6b3IuY29tXCIsXG4gICAgXCJzdG9yZS10cmV6b3Iub3JnXCIsXG4gICAgXCJzdG9yZXRyZXpvci5jb21cIixcbiAgICBcInRyZXpvci13YWxsZXQuaW5mb1wiLFxuICAgIFwid2FsbGV0LXRyZXpvci5pbmZvXCIsXG4gICAgXCJ0cmV6b3Itc2hvcHMuY29tXCIsXG4gICAgXCJ3YWxsZXRzLXRyZXpvci5sdGRcIixcbiAgICBcInN0b3JlLXRyZXpvci5ldVwiLFxuICAgIFwibXllbGhpdG9yd2FpbGN0LmNvbVwiLFxuICAgIFwidmludGFnZS1teWV0aGVyZXN3YWxsZXQuY29tXCIsXG4gICAgXCJiaXRjb2luLW1peGVyLnRrXCIsXG4gICAgXCI0Ni4yMjYuMTA4LjE3MVwiLFxuICAgIFwiYmFuY29yLm5ldHdvcmsuc2lnbi1pbi1ieS13YWxsZXQuZXZlbnQtZGlzdHJpYnV0b3JzLmNvbVwiLFxuICAgIFwiYmFuY29yLm5ldHdvcmsuc2lnbi1pbi1ieS13YWxsZXQubWVtYmVycy1naWZ0LmNvbVwiLFxuICAgIFwiYmxvZ2JpbmFuYy5ibG9nc3BvdC5jb21cIixcbiAgICBcImNvaW5iYXNlLmNvbS05ZGE3YTIwNC01NDRlLTUzZDEtOWExMi02MTE3NmM0ZDRjZDguc2l0ZVwiLFxuICAgIFwiY29pbmJhc2UuY29tLTlkYTdhMjA0LTU0NGUtNWZkMS05YTEyLTYxMTc2YzVkNGNkOC5jb21cIixcbiAgICBcImNvaW5iYXNlLmNvbS05ZGE3YTIwNC01NDRlLTYzZDEtNGExMi02MTE3NmM0ZDRjZDguc2l0ZVwiLFxuICAgIFwiY29pbmJhc2UuY29tLTlkYTdhMjA0LTU0NGUtNjNkMS00YTEyLTYxMTc2YzRkNGNkOC5zdVwiLFxuICAgIFwiY29pbmJhc2ViaXRiYW5rLmNvbVwiLFxuICAgIFwiY29pbmJhc2VoZWxwZGVzay5jb21cIixcbiAgICBcImNvaW5kZXNrLmxpbmsuMTY2NDAuYXFxLnJ1XCIsXG4gICAgXCJjb2luZGVzay5uYW1lLjE2NjQwLmFxcS5ydVwiLFxuICAgIFwiY29pbmRlc2tqYXBhbi5uZXRcIixcbiAgICBcImNvaW5sYmFzZS5jb20tN2RhN2EyMDQtNzQ0ZS02M2QxLTY0YjEyLTYxMTc2YzRkNGNkNy5zaXRlXCIsXG4gICAgXCJjb2lubGJhc2Uuc3BhY2VcIixcbiAgICBcImNvam5iYXNlLmNvbVwiLFxuICAgIFwiZGV4bGF1bmNoLWJpbmFuY2UuY29tXCIsXG4gICAgXCJ0cmV6b3Itd2FsbGV0LnNob3BcIixcbiAgICBcImlkZXgtbWFya2V0LWNvbS5jb21cIixcbiAgICBcImlkZXhtYXJrZXQucHJvXCIsXG4gICAgXCJpZGV4bWFya2V0LnN0b3JlXCIsXG4gICAgXCJpbmRhZGF4LmNvbVwiLFxuICAgIFwiaXBheGZ1bC51c1wiLFxuICAgIFwia3liZXIubmV0d29yay5zaWduLWluLnVzZXItYm9udXMtdG9rZW5zLmNvbVwiLFxuICAgIFwibGFjYWxiaXRjb2lucy5ydVwiLFxuICAgIFwibGNhbGJpdGNvaW5zLnJ1XCIsXG4gICAgXCJsaWNhbGJpdGNvaW5zLnJ1XCIsXG4gICAgXCJsb2FsYml0Y29pbnMucnVcIixcbiAgICBcImxvY2FsYmljb2lucy5jb21cIixcbiAgICBcImxvY2FsYmlyY29pbnMucnVcIixcbiAgICBcImxvY2FsYml0Y29pbS5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbXMucHJvXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4uY29tLnBheGZ1bHJlcG9ydC5vbmxpbmVcIixcbiAgICBcImxvY2FsYml0Y29pbmEucnVcIixcbiAgICBcImxvY2FsYml0Y29pbmQucnVcIixcbiAgICBcImxvY2FsYml0Y29pbnMudGVjaG5vbG9neS4xNjY0MC5hcXEucnVcIixcbiAgICBcImxvY2FsYml0Y291aW5zLnJ1XCIsXG4gICAgXCJsb2NhbGJpdGNvdW5zLnJ1XCIsXG4gICAgXCJsb2NhbGJpdGljb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0b2Npbi5jb21cIixcbiAgICBcImxvY2FsZXRoZXJldW0uYml6LjE2NjQwLmFxcS5ydVwiLFxuICAgIFwibG9jYWxldGhlcmV1bS5jYy4xNjY0MC5hcXEucnVcIixcbiAgICBcImxvY2FsZXRoZXJldW0uY2x1Yi4xNjY0MC5hcXEucnVcIixcbiAgICBcImxvY2FsZXRoZXJldW0uY28uMTY2NDAuYXFxLnJ1XCIsXG4gICAgXCJsb2NhbGV0aGVyZXVtLmNvbXBhbnkuMTY2NDAuYXFxLnJ1XCIsXG4gICAgXCJsb2NhbGV0aGVyZXVtLm1lLjE2NjQwLmFxcS5ydVwiLFxuICAgIFwibG9jYWxldGhlcmV1bS5uYW1lLjE2NjQwLmFxcS5ydVwiLFxuICAgIFwibG9jYWxldGhlcmV1bS50ZWNobm9sb2d5LjE2NjQwLmFxcS5ydVwiLFxuICAgIFwibG9jYWxldGhlcmV1bS50b2RheS4xNjY0MC5hcXEucnVcIixcbiAgICBcImxvY2FsaWJpdGNvbnMuY29tXCIsXG4gICAgXCJsb2NhbG5pdGNvaW5zLnJ1XCIsXG4gICAgXCJsb2NhbHZpdGNvaW5zLnJ1XCIsXG4gICAgXCJsb2NpYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvY29pYml0Y29pbi5jb21cIixcbiAgICBcImxvY3NsYml0Y29pbnMucHJvXCIsXG4gICAgXCJsb2N1bGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9rYWxiaXRjb2luLm5ldFwiLFxuICAgIFwibG9rYWxiaXRjb2luLnRvcFwiLFxuICAgIFwibG9rYWxiaXRrb2lucy5jb21cIixcbiAgICBcImxvdmFsYml0Y29pbnMucnVcIixcbiAgICBcImxveGFsYml0Y29pbi5jb21cIixcbiAgICBcIm15LnBheGZ1bGNoZWNrLnh5elwiLFxuICAgIFwibXlhdGhlcmVzd2FsbGV0LmNvbVwiLFxuICAgIFwibXlhdGhlcmV3YWxsZXQuY29tXCIsXG4gICAgXCJteWVodGVyd29haWxldC5jb21cIixcbiAgICBcIm15ZWxoZXJldmFsbGV0LmNvbVwiLFxuICAgIFwibXllbGhlcmV3YWxsZXQuY29tXCIsXG4gICAgXCJteWVsaGVyc3dhbHRldC5jb21cIixcbiAgICBcIm15ZWxoZXJ3YWZsZXQuY29tXCIsXG4gICAgXCJteWVsaGVyd2FsZmV0LmNvbVwiLFxuICAgIFwibXllbGhlcndhbHRldC5jb21cIixcbiAgICBcIm15ZWxoZXJ3b2xsZXQuY29tXCIsXG4gICAgXCJteWVzZXJlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJlY3ZhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJlY3dhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJld2FpaWV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV3YWxsZWYuY29tXCIsXG4gICAgXCJteWV0aGVyZXdhbHR5dC5jb21cIixcbiAgICBcIm15ZXRoZXJ1b213YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsZXQucnVcIixcbiAgICBcIm15ZXRoZXJ3YWxldHMucnVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtcGF5bWVudC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLTdkYTNhNzkwLTIxNGEtNTFjNy0xNGcxOS04NzUzMWcwZjRjbzkuc2l0ZVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20tN2RhM2E3OTAtMjE0dS0yM2MxLTE0YTE5LTg3NTM2ZzBmNGNhMS5zaXRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS03ZGEzYTg5MC0yMTR1LTIzYzEtMTRhMTktODc1MzZnMGY0Y2MzLnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLTdkYTNhODkwLTIxNHUtMjNjMS0xNGExOS04NzUzNmcwZjRjZTUuc2l0ZVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20tN2RhM2E4OTAtMjE0dS0yM2MxLTE0YTE5LTg3NTM2ZzBmNGNmNi5zaXRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS03ZGEzYTg5MC0yMTR1LTIzYzEtMTRhMTktODc1MzZnMGY0Y2c3LnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmV0aGVyLXNlbmQuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uZXRoZXItdHJhbnNhY3Rpb25zLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmV0aGVycy10cmFuc2FjdGlvbi5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5ub2RlLWV0aGVyZXVtLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNlbi10cmFuc2FjdGlvbi5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0cy5ydVwiLFxuICAgIFwibXlldGhlcndlbHRldC5jb21cIixcbiAgICBcIm15ZXRoZXdhbGlldC1sb2dpbi5zaXRlXCIsXG4gICAgXCJteWV0aHJlcm53YWxsZXQuY29tXCIsXG4gICAgXCJteWV0bGxlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRuZXJ3YWxldC5ydVwiLFxuICAgIFwibXlldG5lcndhbGxldC5jb20ubG9hZC10cmFuc2FjdGlvbi5pbmZvXCIsXG4gICAgXCJteWV0bmVyd2FsbGV0LmNvbS5zZXRoLXRyYW5zYWN0aW9uLmluZm9cIixcbiAgICBcIm15ZXRuZXJ3YWxsZXRzLnJ1XCIsXG4gICAgXCJteWV0c2Vyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlpZXRoZXJlc3dhbGxldC5jb21cIixcbiAgICBcIm15dGhldGF3YWxsZXQuY29tXCIsXG4gICAgXCJvY2FsYml0Y29pbnMucnVcIixcbiAgICBcInBheGZ1bC5jb20ubG9vbGljLmdhXCIsXG4gICAgXCJwYXhmdWxjaGVjay54eXpcIixcbiAgICBcInBheGZ1bHJlcG9ydC5vbmxpbmVcIixcbiAgICBcInBheGZ1bHJldmVyaWZ5LmNvbVwiLFxuICAgIFwicGF4ZnVsdmVyaWZ5Lm9ubGluZVwiLFxuICAgIFwicmVtaXRhbm8udHJhZGVcIixcbiAgICBcInJudWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwicm55ZXRoZXJldXJud2FsbGV0LmNvbVwiLFxuICAgIFwicm55ZXRocmV3YWxsZXQuY29tXCIsXG4gICAgXCJzaG9wLXRyZXpvci5pbmZvXCIsXG4gICAgXCJ0cmV6b3Itc2hpcC5iaXpcIixcbiAgICBcInRyZXpvci1zaG9wLmJpelwiLFxuICAgIFwidHJlem9yLXdhbGxldC5ldVwiLFxuICAgIFwidHJlem9yLXdhbGxldC5saXZlXCIsXG4gICAgXCJ0cnVzdHdhbGxldC5jb20uZXJjLTIwLWdpZnQuY29tXCIsXG4gICAgXCJ2dnd3LWNvaW5iYXNlLmNvbVwiLFxuICAgIFwidnd3LWNvaW5iYXNlLmNvbVwiLFxuICAgIFwidnd3Lm15ZXRuZXJ3YWxsZXQuY29tLm5vZGUtc2VuZC5pbmZvXCIsXG4gICAgXCJ3YWxsZXRzLXRyZXpvci5ldVwiLFxuICAgIFwid2FsbGV0cy10cmV6b3Iub3JnXCIsXG4gICAgXCJ3dnctY29pbmJhc2UuY29tXCIsXG4gICAgXCJ3d3ctbGRleC5tYXJrZXRcIixcbiAgICBcInhuLS1jb25iYXNlLWh6YS5jb21cIixcbiAgICBcInhuLS1tZWR1bS1nODFiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGxldC1uY2IuY29tLnN0YXR1cy1zZW5kLmluZm9cIixcbiAgICBcInhuLS1teWV0aGVyd2xsdC0za2Iwdi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsdC0za2I4Njk5Zy5jb21cIixcbiAgICBcInhuLS1weGZ1bC05M2IuY29tXCIsXG4gICAgXCJ4bi0tdHJlem9yLXdsbGV0LTU5YS5jb21cIixcbiAgICBcInJudWV0aGVydnZhbGxldC5jb21cIixcbiAgICBcImVsZWN0cnVtdXBkYXRlLmNvbVwiLFxuICAgIFwiZWxlY3RydW13ZWIubmV0XCIsXG4gICAgXCJ2aW50YWdlLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJ3ZWRkZXJiZXJnZW4uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hY2Nlc3Mtd2FsbGV0LmluZm9cIixcbiAgICBcImFjY2Vzcy13YWxsZXQuaW5mb1wiLFxuICAgIFwiZWxlY3RydW1maXguY29tXCIsXG4gICAgXCJlbGVjdHJ1bXNvdXJjZS5vcmdcIixcbiAgICBcImJsdGFkZHJlc3Mub3JnXCIsXG4gICAgXCJjcnlwdG94Y2FzaC5jb21cIixcbiAgICBcImNyeXB0b25iYWNrLmNvbVwiLFxuICAgIFwiYmluYW5ubi5ibG9nc3BvdC5jb21cIixcbiAgICBcImJpbmFueHJwLmJsb2dzcG90LmNvbVwiLFxuICAgIFwidW5mcmVlemUtcGF4ZnVsLmNvbVwiLFxuICAgIFwicm51ZXRoYXJ3YWxsZXQuY29tXCIsXG4gICAgXCJiaW50cnguYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJiaW4tYW5jZS5ibG9nc3BvdC5jb20udHJcIixcbiAgICBcImJpbmF4cnAuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJpdHViZW9ubGluZS5jb21cIixcbiAgICBcImVuamluLnByb1wiLFxuICAgIFwidHJvbnh3YWxsZXQuY29tXCIsXG4gICAgXCJ0cm9ueGNhc2guY29tXCIsXG4gICAgXCJlbGVjdHJ1bXVwZ3JhZGUub3JnXCIsXG4gICAgXCJ3d3dteWNyeXB0by5jb21cIixcbiAgICBcImNvaW5kZXNrLm1lLjE2NjQwLmFxcS5ydVwiLFxuICAgIFwiZWxlY3RydW1kb3dubG9hZC5jb21cIixcbiAgICBcImxkZXhtYXJrZXQuY29tXCIsXG4gICAgXCJiaXR0cmV4LW0uY29tXCIsXG4gICAgXCJybnVhdGhlcnZ2YWxmZXQuY29tXCIsXG4gICAgXCJzcGFjZXgucHJvbW9cIixcbiAgICBcInBheGZ1bC5jb20ucnVcIixcbiAgICBcImVsZWN0cnVtYmFzZS5jb21cIixcbiAgICBcImVsZWN0cnVtY29yZS5uZXRcIixcbiAgICBcImVsZWN0cnVtYXBwcy5jb21cIixcbiAgICBcInhuLS1ibGNrY2hpbi1lemE5by5jb21cIixcbiAgICBcImlkZXh4bWFya2V0LnNpdGVcIixcbiAgICBcImlkZXhtYXJrdC5zdG9yZVwiLFxuICAgIFwiZ2V0MjgwMmx1bWVucy5vbmxpbmVcIixcbiAgICBcImVsZWN0cnVtb2ZmaWNpYWwuY29tXCIsXG4gICAgXCJwcml2YXRzdHVmZi5zdG9yZVwiLFxuICAgIFwidHRyeHRyeC5ibG9nc3BvdC5jb21cIixcbiAgICBcInhycHhycC5ibG9nc3BvdC5jb21cIixcbiAgICBcImxkZXgtbWFya2V0LnByb1wiLFxuICAgIFwiYml0dG9ycmVudC5wcm9cIixcbiAgICBcImRvdWJsZWJpdGNvaW4uaW9cIixcbiAgICBcImx1Y2FsYmx0Y29pbnMuY29tXCIsXG4gICAgXCJ4bi0taGl0YnQtOHhhLmNvbVwiLFxuICAgIFwiaWRleG1hcmtldC5zcGFjZVwiLFxuICAgIFwiYmFra3RwbGF0Zm9ybS5pb1wiLFxuICAgIFwiYnRjZGV2LnVzXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS03ZGEzYTg5MC0yMTR1LTIzYzEtMTRhMTktODc1MzZnMGY0Y2Q0LnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLTdkYTNhODkwLTIxNHUtMjNjMS0xNGExOS04NzUzNmcwZjRjYjIuc2l0ZVwiLFxuICAgIFwiYml0dG9ycmVudC5mb3VuZGF0aW9uXCIsXG4gICAgXCJnZXRmcmVlLW5lby5ibG9nc3BvdC5teVwiLFxuICAgIFwiZ2V0ZnJlZS1uZW8uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJiaW5qZXJzZXlnYnBldXIuY29tXCIsXG4gICAgXCJnZXQtZnJlZWNyeXB0by5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aDRmcmVlLmNvbVwiLFxuICAgIFwiZ2l2ZWF3YXkteC5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGVyY2hhbmdlLnRlY2hcIixcbiAgICBcImNsYWltLXh5b3Rva2Vucy5jb21cIixcbiAgICBcImJpdGNvaW40ZnV0dXJlLmNsdWJcIixcbiAgICBcImRleGJldGFsYXVuY2guY29tXCIsXG4gICAgXCJhaXJkcm9weG5lby5ibG9nc3BvdC5jb21cIixcbiAgICBcIm15ZXRoZXJlc3N3YWxsZXQuY29tXCIsXG4gICAgXCJiaXRhZW9uLnRvcFwiLFxuICAgIFwiYnRybWFydGd2ZS5jb21cIixcbiAgICBcInN0ZWxsYXItbGlnaHRuaW5nLm9yZ1wiLFxuICAgIFwieGxsd2FsbGV0LmNvbVwiLFxuICAgIFwiaWRleG1hcmtldC53ZWJzaXRlXCIsXG4gICAgXCJjcnlwdG9leGNvaW5zLmNvbVwiLFxuICAgIFwiYml0Y29pbi1nZW5lcmF0b3IubmV0d29ya1wiLFxuICAgIFwiZXRodG9rZW5zLnN0b3JlXCIsXG4gICAgXCJ4bi0tYnR0b3JyZW50LTU0YS5jb21cIixcbiAgICBcImJ0Y2FpbS5jb21cIixcbiAgICBcImJpenppbGlvbi5jb21cIixcbiAgICBcInNldGgtdHJhbnNhY3Rpb24uaW5mb1wiLFxuICAgIFwiY3J5cHRvY3JlZGl0Zm91bmRhdGlvbi5jb21cIixcbiAgICBcImNpcmNsZW1peC5pb1wiLFxuICAgIFwiamFuY3J5cHRvLmJsb2dzcG90LmNvbVwiLFxuICAgIFwid2FsbGV0LXN1cHBvcnQuY29tXCIsXG4gICAgXCJhaXJkcm9weHJwLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiY3J5cHRvYmFjay50b3BcIixcbiAgICBcImNyeXB0b2dlbmUubmV0XCIsXG4gICAgXCJidXRlcmluZ2lmdC5jb21cIixcbiAgICBcInF1aWNrMnhidGMuY29tXCIsXG4gICAgXCJkb3VibGVjcnlwdG8ubWxcIixcbiAgICBcImRvdWJsZWludmVzdG1lbnQuY2ZcIixcbiAgICBcImRvdWJsZWJpdGNvLmluXCIsXG4gICAgXCJiaXRjb2luLXByby5jbHViXCIsXG4gICAgXCJpZGV4Z3JvdXAub25saW5lXCIsXG4gICAgXCJidHRwcm9tb3Rpb24uZ2l0aHViLmlvXCIsXG4gICAgXCJ0ZWxvcy1mb3VuZGF0aW9uLmlvXCIsXG4gICAgXCJiaW5hbmNlZ2l2ZS5jb21cIixcbiAgICBcImV0aGVyZXVtLWFkdmFuY2VkLmNvbVwiLFxuICAgIFwiaW52ZXN0bWVudGRvdWJsZXIub25saW5lXCIsXG4gICAgXCJidHRwcm9tby5naXRodWIuaW9cIixcbiAgICBcImJpdHRvcnJlbnRwcm9tby5naXRodWIuaW9cIixcbiAgICBcImJpbmFuY2VkZXhnLmNvbVwiLFxuICAgIFwiaXNlY3VyZWNvaW5iYXNlLmxpdmVcIixcbiAgICBcIm1leWh0ZXJ3YWlsZXQuY29tXCIsXG4gICAgXCJteWNmaGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXljdGhlcndhaWxldC5jb21cIixcbiAgICBcIm15Y3RoZXJ3YWxldC5jb21cIixcbiAgICBcIm15ZWZoZXJ2dmFpbGV0LmNvbVwiLFxuICAgIFwibXllZmhlcnZ2YWxpZXQuY29tXCIsXG4gICAgXCJteWVmaGVydnZlbGxldC5jb21cIixcbiAgICBcIm15ZWZoZXJ3YWxldC5jb21cIixcbiAgICBcIm15ZWZoZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJteWVmdGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXllaHRlcnZ2YWxsZXQuY29tXCIsXG4gICAgXCJteWV0ZmVydnZhbGxldC5jb21cIixcbiAgICBcIm15ZXRmZXJ2dmVsbGV0LmNvbVwiLFxuICAgIFwibXlldGZlcndhaWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVydmVsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnZ2YWxsY3QuY29tXCIsXG4gICAgXCJteWV0aGVydnZlaWxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ2dmVsaWV0LmNvbVwiLFxuICAgIFwibXlldGhlcnZ2ZWxsZXQub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsZmV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uZXRoZXItdHJhbnNhY3Rpb24uaW5mb1wiLFxuICAgIFwibXlldGhlcndlaWxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3ZWxpZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2VsbGN0LmNvbVwiLFxuICAgIFwibXlldGhyd2FsbGV0LnJ1XCIsXG4gICAgXCJteWV0bmVyd2FsbGV0LnJ1XCIsXG4gICAgXCJteXRoZXJ2dmFsbGV0LmNvbVwiLFxuICAgIFwicGF4ZnVsLm1sXCIsXG4gICAgXCJ3d3ctcGF4ZnVsLmNvbVwiLFxuICAgIFwieG4tLWR4LXFiYjQyNDBhLm1hcmtldFwiLFxuICAgIFwieG4tLW15ZXRocndsbGV0LXE3YTEzNDBoLmNvbVwiLFxuICAgIFwieG4tLXRyem9yLTd6YS5uZXRcIixcbiAgICBcInhuLS10cnpvci1jc2EuY29tXCIsXG4gICAgXCJ4bi0tdHJ6b3ItY3NhLmNvXCIsXG4gICAgXCJ0b2tlLm9ubGluZVwiLFxuICAgIFwiYmluYW5jZXhycGphbi5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGVyY29udGVzdC5jb21cIixcbiAgICBcImVzY29iYXJzYnIuY29tXCIsXG4gICAgXCJteWVzZXJlc3dhbGxldC5jb21cIixcbiAgICBcIm15ZXJvbWFob3VzaXQuY29tXCIsXG4gICAgXCJiaW5hbmNlZ2l2ZWF3YXlzLmNvbVwiLFxuICAgIFwiZWxvbmNpdHkuc2FsZVwiLFxuICAgIFwibWFuYS1naWZ0LmNvbVwiLFxuICAgIFwiZGlnaXRleGZ1dHVyZXMuc2l0ZVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5jb20uc3VwcG9ydC10aWNrZXQtcmVwb3J0LmNvbVwiLFxuICAgIFwicGF4ZnVsLmNvLmluXCIsXG4gICAgXCJwYXhmdWx3YWxsZXRzLmNvbVwiLFxuICAgIFwidHJlem9yLW9mZmljaWFsLm9yZ1wiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWx0LTE1YjQ3MTlnLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWx0LW80YjYyMjlnLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YXQtbXlieDYyMjlnLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2xsZXQtamozZW5rYy5jb21cIixcbiAgICBcImxvY2FsYmx0Y29pbnMuY29tXCIsXG4gICAgXCJtZXl0aGVyd2FsZXQuY29tXCIsXG4gICAgXCJteWN0aGVyd2FsbGV0LmljdVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uZXQtdHJhbnNhY3Rpb24uaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2VuZC1ldHJhbnNhY3Rpb24uaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20udmlldy1jaGFpbi5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2F0dGV0LmNvbVwiLFxuICAgIFwicGF4ZnVsLnRvXCIsXG4gICAgXCJwYXhmdWxsLmNsdWJcIixcbiAgICBcInN1cHBvcnQtdGlja2V0LXJlcG9ydC5jb21cIixcbiAgICBcImxvY2FsZXRoZXJldW0uY29tLnN1cHBvcnQtdGlja2V0LXJlcG9ydC5jb21cIixcbiAgICBcImRvdWJsZWJpdGNvaW4uY2NcIixcbiAgICBcImRvdWJsZTJidGMudG9wXCIsXG4gICAgXCJ0cm9uZGlzY291bnQuY29tXCIsXG4gICAgXCJoeWRyb3dhbGxldC5pb1wiLFxuICAgIFwibHRjcHJvLmxpdmVcIixcbiAgICBcImx0Y2dpdmVhd2F5LmNvbVwiLFxuICAgIFwibHRjcHJvLnh5elwiLFxuICAgIFwiZGV4Y2hhaW5sYXVuY2hwYWQuY29tXCIsXG4gICAgXCJldGhnd3MuY29tXCIsXG4gICAgXCJ4cHJvLmljdVwiLFxuICAgIFwiYWlyZHJvcGNhbXBhaWduLmNvbVwiLFxuICAgIFwiYnR0bGF1bmNocGFkLmNvbVwiLFxuICAgIFwiY2xpZW50LXdhdmVzeC5jb21cIixcbiAgICBcImJ0Yy1wcm9tby5uZXRcIixcbiAgICBcIndhdmVzLXguY29tXCIsXG4gICAgXCJldGN2LXdhbGxldC5jb1wiLFxuICAgIFwiZmFjZXVzZC5jb21cIixcbiAgICBcInRva2Vuc2hvcHMub25saW5lXCIsXG4gICAgXCJqYW5iaW5hbmNleHJwLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiamFuYmluYW5jZS5ibG9nc3BvdC5jb21cIixcbiAgICBcImNvaW5iaXQyNC5zaXRlXCIsXG4gICAgXCJpZGV4LW1hcmtldC5saXZlXCIsXG4gICAgXCJ4MTBldGguY29tXCIsXG4gICAgXCJiZXRhYmluZGV4LmNvbVwiLFxuICAgIFwiYml0bXJ0cHJvLmNvbVwiLFxuICAgIFwiYm9udXMtc3RlbGxhcnRlcm0uY29tXCIsXG4gICAgXCJjb2luYnZzZS5jb21cIixcbiAgICBcImRleC1oYmlnbG9iYWwuaW5mb1wiLFxuICAgIFwieG4tLXd2d3cta3Jha24tNXEzZS5jb21cIixcbiAgICBcImJhbmNvci5uZXR3b3JrLnhiYW5jb3Iub25saW5lXCIsXG4gICAgXCJiaW5hbmNlZ2lmdC5vbmxpbmVcIixcbiAgICBcImJpdGNvaW5jb2luYmFzZS50b3BcIixcbiAgICBcImNvaW1iYXNlLnRvcFwiLFxuICAgIFwiY29pbmJhc2UtYWlyZHJvcC54eXpcIixcbiAgICBcImNvaW5iYXNlLWJ0Yy50b3BcIixcbiAgICBcImNvaW5iYXNlLWJ0Y2FpcmRyb3AudG9wXCIsXG4gICAgXCJjb2luYmFzZS1jb21wZXRpdGlvbi50b3BcIixcbiAgICBcImNvaW5iYXNlLWNyeXB0by50b3BcIixcbiAgICBcImNvaW5iYXNlLWdpdmUudG9wXCIsXG4gICAgXCJjb2luYmFzZS1naXZlcy50b3BcIixcbiAgICBcImNvaW5iYXNlLXByaXplLnRvcFwiLFxuICAgIFwiY29pbmJhc2UuYXJteVwiLFxuICAgIFwiY29pbmJhc2VhaXIuY29pbmJhc2VhaXJkcm9wcy5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWFpci5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWJpdGNvaW4uY29pbmJhc2VhaXJkcm9wcy5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWJ0Y2FpcmRyb3AuY29pbmJhc2VhaXJkcm9wcy5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWJ0Y2FpcmRyb3AuaW5mb1wiLFxuICAgIFwiY29pbmJhc2VidGNkcm9wLmNvaW5iYXNlYWlyZHJvcHMuaW5mb1wiLFxuICAgIFwiY29pbmJhc2VkLnRvcFwiLFxuICAgIFwiY29pbmJhc2VkLnh5elwiLFxuICAgIFwiY29pbmJhc2VkZXgudG9wXCIsXG4gICAgXCJjb2luYmFzZWRleGRyb3AuY29pbmJhc2VhaXJkcm9wcy5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWRleHguY29pbmJhc2VhaXJkcm9wcy5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWR4LmNvaW5iYXNlYWlyZHJvcHMuaW5mb1wiLFxuICAgIFwiY29pbmJhc2VlLmNvaW5iYXNlYWlyZHJvcHMuaW5mb1wiLFxuICAgIFwiY29pbmJhc2VlLmluZm9cIixcbiAgICBcImNvaW5iYXNlaW8udG9wXCIsXG4gICAgXCJjb2luYmFzZXJ4LmNvaW5iYXNlYWlyZHJvcHMuaW5mb1wiLFxuICAgIFwiY29pbmJhc2VyeC50b3BcIixcbiAgICBcImNvaW5iYXNldmVydC5uZXR3b3JrXCIsXG4gICAgXCJjb2luYmFzZXZlcnRuZXR3b3JrLmNvaW5iYXNlYWlyZHJvcHMuaW5mb1wiLFxuICAgIFwiY29pbmJhc2V4LnRvcFwiLFxuICAgIFwiY29pbmJhc2V4eC5jb2luYmFzZWFpcmRyb3BzLmluZm9cIixcbiAgICBcImNvbG5iYXNlLnRvcFwiLFxuICAgIFwiY3BhbmVsLmJpdGNvaW5jb2luYmFzZS50b3BcIixcbiAgICBcImNwYW5lbC5jb2luYmFzZS1haXJkcm9wLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlLWFpcmRyb3AueHl6XCIsXG4gICAgXCJjcGFuZWwuY29pbmJhc2UtYnRjLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlLWJ0Yy54eXpcIixcbiAgICBcImNwYW5lbC5jb2luYmFzZS1idGNhaXJkcm9wLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlLWNvbXBldGl0aW9uLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlLWNyeXB0by50b3BcIixcbiAgICBcImNwYW5lbC5jb2luYmFzZS1naXZlLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlLWdpdmVzLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlLXByaXplLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlYWlyLmluZm9cIixcbiAgICBcImNwYW5lbC5jb2luYmFzZWFpcmRyb3BzLmluZm9cIixcbiAgICBcImNwYW5lbC5jb2luYmFzZWJ0Y2FpcmRyb3AuaW5mb1wiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlYnRjZHJvcC5pbmZvXCIsXG4gICAgXCJjcGFuZWwuY29pbmJhc2VjYW1wYWlnbi5vbmxpbmVcIixcbiAgICBcImNwYW5lbC5jb2luYmFzZWQudG9wXCIsXG4gICAgXCJjcGFuZWwuY29pbmJhc2VkLnh5elwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlZGV4LnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlZGV4ZHJvcC5pbmZvXCIsXG4gICAgXCJjcGFuZWwuY29pbmJhc2VkZXhpby5vbmxpbmVcIixcbiAgICBcImNwYW5lbC5jb2luYmFzZWUuaW5mb1wiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlZ2l2ZWF3YXkub25saW5lXCIsXG4gICAgXCJjcGFuZWwuY29pbmJhc2VnaXZlcy50b3BcIixcbiAgICBcImNwYW5lbC5jb2luYmFzZWlvLnRvcFwiLFxuICAgIFwiY3BhbmVsLmNvaW5iYXNlcngudG9wXCIsXG4gICAgXCJjcGFuZWwuY29pbmJhc2V4LnRvcFwiLFxuICAgIFwiY3BhbmVsLm15ZXRoZXJ3YWxsZXQtZGVjLnNwYWNlXCIsXG4gICAgXCJsY2NhbGJ0bGNvaW5zLmNvbVwiLFxuICAgIFwibWFpbC5jb2luYmFzZS5hcm15XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXllLnNwYWNlXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsdC16eGI2MjcxZy5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3bGx0LWtqM2Vta2lhLmNvbVwiLFxuICAgIFwiaWRleC1tYXJrZXQud2Vic2l0ZVwiLFxuICAgIFwiZm9ya2RlbHRhLnNwYWNlXCIsXG4gICAgXCJiaWctZ2lmdC5nYVwiLFxuICAgIFwiZG91YmxlaW52ZXN0Lm9ubGluZVwiLFxuICAgIFwiZWJpdHNlcnZpY2VzLmNvbVwiLFxuICAgIFwiYnRjZXhjZWxpbnZlc3QuY29tXCIsXG4gICAgXCJlbGVjdHJ1bS5vbmVcIixcbiAgICBcImUteG9kdXMuY29tXCIsXG4gICAgXCJteWV0Y3Z3YWxsZXQuY29tXCIsXG4gICAgXCJ3YWxsZXQuaHlkcm9wcm9qZWN0LmlvXCIsXG4gICAgXCJoeWRyb3Byb3RvY29sLnRlY2hcIixcbiAgICBcImV0Y3Ytd2FsbGV0LmNvbVwiLFxuICAgIFwidGVzbGEtcHJvbW8udGVjaFwiLFxuICAgIFwiYmluYW5jZWphbi5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGVyZXVtY3YuaW9cIixcbiAgICBcImV0aGVyZXVtY3YuaW5mb1wiLFxuICAgIFwiZXRobm93YXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtZGZ6LnNwYWNlXCIsXG4gICAgXCJzZGYzNG15ZXRoZXJ3YWxsZXQuc2l0ZVwiLFxuICAgIFwid2FsbGV0LmJhbmNvci5uZXR3b3JrLnhiYW5jb3Iub25saW5lXCIsXG4gICAgXCJ4YmFuY29yLm9ubGluZVwiLFxuICAgIFwiMjM0MjNteWV0aGVyd2FsbGV0LnNpdGVcIixcbiAgICBcIjMzMzMzbXlldGhlcndhbGxldC5zaXRlXCIsXG4gICAgXCI0NDMzMm15ZXRoZXJ3YWxsZXQuc2l0ZVwiLFxuICAgIFwiYmluYW5jZXByb21vLmNvbVwiLFxuICAgIFwiY29pbmJhc2UtYWlyZHJvcC5jb21cIixcbiAgICBcImpoZmpteWV0aGVyd2FsbGV0LnNpdGVcIixcbiAgICBcImJpdG1hcnRwcm8ubGl2ZVwiLFxuICAgIFwiZXRjdndhbGxldC5jb21cIixcbiAgICBcImNvaW5pYmFzZS5wcm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbmUuc3BhY2VcIixcbiAgICBcInRyZXpvci1zYWxlcy5vbmxpbmVcIixcbiAgICBcImthcmF0YmFycy1hZmZpbGlhdGUtYm9udXMuY29tXCIsXG4gICAgXCJpZGV4LnJ1LmNvbVwiLFxuICAgIFwiMmZhLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJibG9ja3Rvd2VyLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtZWIuc3BhY2VcIixcbiAgICBcInRyZXpvci1zaG9wLm9yZ1wiLFxuICAgIFwiaHlkcm9wcm9qZWN0LmlvXCIsXG4gICAgXCJybnlldGhlcndhbGxldC5zaXRlXCIsXG4gICAgXCJ4bi0tbXl0aHJ3bGx0LTU3NmRxamNmLmNvbVwiLFxuICAgIFwiZW4uY29pbmJhc2UtY291cG9uLmNvbVwiLFxuICAgIFwibG9jYWxiaWl0Y29pbnouY2x1YlwiLFxuICAgIFwibXlldGhlcmVzd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhyZWl3YWxsZXQuY29tXCIsXG4gICAgXCJvbmxpbmUtbG9jYWxiaXRjb2lucy10aC5jb1wiLFxuICAgIFwidGVzdC50ZHN0cmFmLnJ1XCIsXG4gICAgXCJ2d3d3LWNvaW5iYXNlLmNvbVwiLFxuICAgIFwieG4tLWJpbm5jZS1kaDhiLmNvbVwiLFxuICAgIFwieG4tLWJubmNlLWM1MWJzZi5jb21cIixcbiAgICBcInhuLS12d3cta3Jha24tMmY3ZC5jb21cIixcbiAgICBcInhuLS13dncta3Jha24tMmY3ZC5jb21cIixcbiAgICBcImdvd2luY29pbi5jb21cIixcbiAgICBcImRlbHRhLm1vbmV5XCIsXG4gICAgXCJjb2luc3VwZXJnaXZlLmxpdmVcIixcbiAgICBcImV0aGVycy1jbGFpbS5jb21cIixcbiAgICBcImJpbmFuY2VldmVudC5uZXRcIixcbiAgICBcImh1b2JpbGl2ZS5pY3VcIixcbiAgICBcImNyeXB0b2Nhc2hiYWNrLm9yZ1wiLFxuICAgIFwiY3J5cHRvY2FzaGJhY2suaW5mb1wiLFxuICAgIFwiY3J5cHRvYmFjay5vbmVcIixcbiAgICBcIm5ld3llYXJjcnlwdG8uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJuZXd5ZWFybmVvLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiY3J5cHRvYnJpZGdlLnN1XCIsXG4gICAgXCJ4cnAtZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJiaWJveHByLmljdVwiLFxuICAgIFwibXlldGhlcmVzdmFsbGV0LmNvbVwiLFxuICAgIFwicGF4ZnUxLmNvbS5teFwiLFxuICAgIFwicGF4ZnVpLmNvbVwiLFxuICAgIFwicGF4ZnVsLXBwLmNvbVwiLFxuICAgIFwieG4tLWNvaW5iYXMteHM0Yy5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3bGx0LWtqM2Vwa2YuY29tXCIsXG4gICAgXCJjb20tMWE3ZDFrZjNpNTc4NmRnaGJhODguc2l0ZVwiLFxuICAgIFwiY29pbmJhc2VnaXZlYXdheS5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWdpdmVhd2F5Lm9ubGluZVwiLFxuICAgIFwiZXRobm93YS13YWxsZXQuY29tXCIsXG4gICAgXCJjcnlzdGFsLXByb2ZpdC5jb21cIixcbiAgICBcImJhbmNvci5zdG9yZVwiLFxuICAgIFwiYmluYW5jZS1jb21wZXRpdGlvbi5pbmZvXCIsXG4gICAgXCJiaW5hbmNlbC5ydVwiLFxuICAgIFwiYml0aHVtYnMuY29tXCIsXG4gICAgXCJjb2lubGJhc2UuY29pbmJhc2UuY2xvdWRcIixcbiAgICBcImxjY2FsYmx0Y29pbnMuY29tXCIsXG4gICAgXCJteWV0aGVyZXZ2YWxsZXQuY29tXCIsXG4gICAgXCJteWV0bG5lcndhbGxldC5jb21cIixcbiAgICBcInBvc215ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJybnl0aGVydnZhbGxldC5jb21cIixcbiAgICBcInhuLS1jb2luYnNlLWl4YS5jb21cIixcbiAgICBcInhuLS13dncta3JrZW4tNTc2ZC5jb21cIixcbiAgICBcInhuLS13d3Yta3JrZW4tNTc2ZC5jb21cIixcbiAgICBcImNhc2gtYml0Y29pbi5vbmxpbmVcIixcbiAgICBcInlvYml0ZXguaW5mb1wiLFxuICAgIFwieW9iaXQtYWRtaW4ubmV0XCIsXG4gICAgXCJ5b2JpdC0tbmV0LmNvbVwiLFxuICAgIFwic3VwcG9ydHlvYml0Lm5ldFwiLFxuICAgIFwieG4tLXliaXQtZ3JhLm5ldFwiLFxuICAgIFwieG4tLXlvYnQtc3lhLm5ldFwiLFxuICAgIFwiYmFua2Nvci5uZXR3b3JrXCIsXG4gICAgXCJiYW5rb3IubmV0d29ya1wiLFxuICAgIFwiYmluYW5jZS10ci5jb21cIixcbiAgICBcImJpbmFuY2ViY2guY29tXCIsXG4gICAgXCJjb2luYmFzZWNhbmFkYS5jb21cIixcbiAgICBcImNvaW5iYXNlZ2l2ZXMudG9wXCIsXG4gICAgXCJjb2luYmFzZW9mZmljaWFscy5jb21cIixcbiAgICBcImh0dHBzLXRyZXpvci5jb21cIixcbiAgICBcImxvY2FsYnRsY29pbnMuY29tXCIsXG4gICAgXCJ0cmV6b3Iuc2l0ZVwiLFxuICAgIFwieG4tLWJpdGZpbngtdjlhLmNvbVwiLFxuICAgIFwieG4tLWJpdHJleC1ya2IuY29tXCIsXG4gICAgXCJ4bi0tdnd3LWtya2VuLTU3NmQuY29tXCIsXG4gICAgXCJ4bi0td3d3LWtha2VuLXUwYi5jb21cIixcbiAgICBcInhuLS13d3cta3Jha2UtM3ZiLmNvbVwiLFxuICAgIFwieG4tLXd3dy1rcmFrbi0yZjdkLmNvbVwiLFxuICAgIFwieG4tLXd3dy1rcmtlbi01NzZkLmNvbVwiLFxuICAgIFwiYmluYW5jZS1jb21wZXRpdGlvbi5uZXRcIixcbiAgICBcImV4Y2R1cy5vcmdcIixcbiAgICBcInhuLS1teWV0aHJ3YWx0LXl4YjIyNzFnZmEuY29tXCIsXG4gICAgXCJnaXZlYXdheXhuZW8uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJldGh0b2tlbnMub25saW5lXCIsXG4gICAgXCJva2V4cHJvLmljdVwiLFxuICAgIFwicG9ldGFpcmRyb3AuY29tXCIsXG4gICAgXCJjb2luYmFua2F0bS5jb21cIixcbiAgICBcImNvaW5iYXNlZGV4Lm9ubGluZVwiLFxuICAgIFwiY29pbnNiYW5rY29tLmNvbVwiLFxuICAgIFwiZm9ybS1jb2luYmFzZS5jb21cIixcbiAgICBcImtyYWtlbi5mclwiLFxuICAgIFwibWVyY29hdG94LmNvbVwiLFxuICAgIFwibXd3dy1rcmFrZW4uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGVsLnByb1wiLFxuICAgIFwicG9sb25pZXhiY2guY29tXCIsXG4gICAgXCJzd3d3LWtyYWtlbi5jb21cIixcbiAgICBcImNvaW5iYXNlLWFpcmRyb3AudG9wXCIsXG4gICAgXCJjb2luYmFzZS1idGMueHl6XCIsXG4gICAgXCJrdWNvaW5kZWN0cnguYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJqYXh4LmltXCIsXG4gICAgXCJqYXh4LnJ1LmNvbVwiLFxuICAgIFwiY29pbmJhc2VkZXhpby5vbmxpbmVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaWNvLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXhvLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2VsbGV0LmNjXCIsXG4gICAgXCJ0cmV6b3IubHRkXCIsXG4gICAgXCJ1c2VyLnBheGZ1bHJlcG9ydHMuY29tXCIsXG4gICAgXCJjcnlwdG8tcG9zaXRpdmUuY2x1YlwiLFxuICAgIFwiZXJjLTIwLXRva2Vucy1naWZ0LmNvbVwiLFxuICAgIFwidHJ1c3R3YWxsZXQuY29tLmVyYy0yMC10b2tlbnMtZ2lmdC5jb21cIixcbiAgICBcImJpbmFuY2UtZGV4LnByb1wiLFxuICAgIFwiYmluYW5jZS5iaWRcIixcbiAgICBcImJpbmFuY2VidGMuY29tXCIsXG4gICAgXCJiaW5hbmNlY2FzaGJhY2suY29tXCIsXG4gICAgXCJiaW5hbmNlbW9iaWxlLmFwcFwiLFxuICAgIFwibWVkbHVtLm9yZ1wiLFxuICAgIFwidHJlem9yLnZvenAuY3pcIixcbiAgICBcInhuLS1teWV0aHJ3YWxldC05MmIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsdC15eGI3MjcxZy5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3bGV0LXh4YjczNDFnLmNvbVwiLFxuICAgIFwiYmluYW5jZS5maXRcIixcbiAgICBcImNvaW5iYXNlYm9udXMub3JnXCIsXG4gICAgXCJjb2luYmFzZWRpc2NvdW50LmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy52aXBcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuaWxvZ2lybi5jb21cIixcbiAgICBcInRyZXpvci13YWxsZXQub25saW5lXCIsXG4gICAgXCJ4bi0tbXllZXJ3YWxsZXQtdmljODY3NmcuY29tXCIsXG4gICAgXCJiaXR0bHJleC5jb21cIixcbiAgICBcInhuLS1iaW5uY2UtcmhjLmNvbVwiLFxuICAgIFwiYmluYW5jZS5leGNoYW5nZTIwMTguc3VwcG9ydFwiLFxuICAgIFwiZXhjaGFuZ2UyMDE4LnN1cHBvcnRcIixcbiAgICBcImJpbmFuY2VoZWxwZGVzay5jb21cIixcbiAgICBcImJpbmFuY2V0d29mYWN0b3JhdXRoZW50aWNhdGlvbi5jb21cIixcbiAgICBcInB1bWFwYXkuaW8uZ2l2ZWF3YXktdXNlci5jb21cIixcbiAgICBcImV0aGVyLWNvbnRlc3QuY29tXCIsXG4gICAgXCJkZXgtaHVvYmlnbG8uaW5mb1wiLFxuICAgIFwieG4tLW15ZXRoZXJsbGV0LWhvYzQ3ei5jb21cIixcbiAgICBcInhuLS1teWV0aGV3bGxldC1oZGMxOTNhLmNvbVwiLFxuICAgIFwiYWlyZ2l2ZWF3YXkudHlwZWZvcm0uY29tXCIsXG4gICAgXCJiaXRjYXNoc3Yub3JnXCIsXG4gICAgXCJiaXRscnkuaW5mb1wiLFxuICAgIFwiY29pbmJhc3NlLmNvbTE5ODYzNzgyOTc2MS5tbFwiLFxuICAgIFwibXlldGhldnZhbGxlbC5jb21cIixcbiAgICBcIm15ZXRuZXJ3YWxlbC5jb21cIixcbiAgICBcInhuLS1teWV0ZXJ3YWxsZS13YzlleHIuY29tXCIsXG4gICAgXCJ4bi0tcHhmdWwtajExYi5jb21cIixcbiAgICBcImV0aGVyZGVsdGEucHJvXCIsXG4gICAgXCJxdWFya2FpcmRyb3AuY29tXCIsXG4gICAgXCJjcnlwdGVyaXVtLnNpdGVcIixcbiAgICBcImJpdHRmaW5leC5jb21cIixcbiAgICBcImJpdHRyZXgubW9iaVwiLFxuICAgIFwiYml0dHJleGJ0Yy5jb21cIixcbiAgICBcImJvbnVzLWNvaW5iYXNlLmNvbVwiLFxuICAgIFwiY29pbmJhc2UtZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJjb2luYmFzZWVhcm4uY29tXCIsXG4gICAgXCJrcmFrZW5vbmxpbmUuY29tXCIsXG4gICAgXCJjb2luYmFzZWRleGRyb3AuaW5mb1wiLFxuICAgIFwiY29pbmJlYmFzZS5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbnMtaW5mby5ydVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy1ydS5ydVwiLFxuICAgIFwibXV5ZXRoZXJ3YWxpZXQuY29tXCIsXG4gICAgXCJteWVsaGVyd2FsaWV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV2YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmxjZ2lybi5jb21cIixcbiAgICBcIm15ZXRoZXZhbGV0LmNvbVwiLFxuICAgIFwidHJlem9yLXdhbGxldC5uZXRcIixcbiAgICBcInhuLS1ob2JpLTA4YS5jb21cIixcbiAgICBcInhuLS1odW9iLXRwYS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2F0LXp4YmE3NzI5Zy5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxldC05MmIzNzI5Zy5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxldC0zcWIyMGMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxldC14eGIwMjcxZy5jb21cIixcbiAgICBcInhuLS15ZXRlcndhbGxlLXVlMmUzbnJzLmNvbVwiLFxuICAgIFwic3VwcG9ydC1jb2luYmFzZS5pbmZvXCIsXG4gICAgXCJtZWR1aW0ub25saW5lXCIsXG4gICAgXCJteWVsdGhlcndhbGlldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtdGd0LnNwYWNlXCIsXG4gICAgXCJiaW5hbmNlLmNvbS5hdVwiLFxuICAgIFwiYml0YmFua21vbmV5LmNvbVwiLFxuICAgIFwiYml0aHVtYmphcGFuLmNvbVwiLFxuICAgIFwiYml0aHVtYnVzLmNvbVwiLFxuICAgIFwiY2tyYWtlbi5jb21cIixcbiAgICBcImNvaW5iYXNlYnRjZHJvcC5pbmZvXCIsXG4gICAgXCJjb2luZGVzay52aXBcIixcbiAgICBcImh1b2JpcHJvLnRrXCIsXG4gICAgXCJpbmRvZGN4LmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbHQtenhiMTI3MWdmYS5jb21cIixcbiAgICBcInhuLS1lb3Njb3JlYXJiaXRyYXRpby1sNmMuaW9cIixcbiAgICBcImJhc2ljYXR0ZW50aW9udG9rZW4ud2Vic2l0ZVwiLFxuICAgIFwibXlldGhlcndhbGxldC45Ni5sdFwiLFxuICAgIFwiZGVjLWt1Y29pbi5ibG9nc3BvdC5jb21cIixcbiAgICBcInRyeC1rdWNvaW4uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJuZW8ta3Vjb2luLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiY3J5cHRvYm91bnR5bWNvLmNvbVwiLFxuICAgIFwidG9rZW5zaWMub25saW5lXCIsXG4gICAgXCJlbmNyeXBleC5vbmxpbmVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuODkwbS5jb21cIixcbiAgICBcImZyZWViaXRjb2JvdC50b3BcIixcbiAgICBcImJpZnRpbmV4LmNvbVwiLFxuICAgIFwiYmluYW5jZS1iZXRhLmluZm9cIixcbiAgICBcImJpbmFuY2UuYm5ibGF1bmNoLmNvbVwiLFxuICAgIFwiYml0aHVtYmxvYW4uY29tXCIsXG4gICAgXCJiaXR0cmV4LmNvbTE1ODk4NzY3OS5nYVwiLFxuICAgIFwiY29pbmJhc2VhaXJkcm9wcy5pbmZvXCIsXG4gICAgXCJpd3d3LWtyYWtlbi5jb21cIixcbiAgICBcImtyYWtlbi53b3JsZFwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5jYXNoXCIsXG4gICAgXCJsb2NhbGJpdGxjb2lucy5jb21cIixcbiAgICBcIm1zZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWNyeXB0by5mYWl0aFwiLFxuICAgIFwibXlldGhlc3dhaWlldC5pbmZvXCIsXG4gICAgXCJteWV0aGV2dmFsbGV0LmJpelwiLFxuICAgIFwibXlldGhldnZhbGxldC5vcmdcIixcbiAgICBcIm15ZXRoZXZ3YWxsZXQub3JnXCIsXG4gICAgXCJteWlldGhlcndhbGxldC5wcm9cIixcbiAgICBcInBheGZ1bHVzZXJzLmNvbVwiLFxuICAgIFwicHItaGl0YnRjLmNvbVwiLFxuICAgIFwidHJlem9yLXdhbGxldHMubmV0XCIsXG4gICAgXCJ3dnZ3LWtyYWtlbi5jb21cIixcbiAgICBcInd3dnYta3Jha2VuLmNvbVwiLFxuICAgIFwid3d3Yml0dHJleC5jb21cIixcbiAgICBcInhuLS1odWJpLWh4NWEuY29tXCIsXG4gICAgXCJ4bi0taHViaS13MGIuY29tXCIsXG4gICAgXCJ4bi0taWR4LWxyYS5tYXJrZXRcIixcbiAgICBcInhuLS1teWV0aGVyd2FsdC1jM2I3NzI5Zy5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxldC1iM2IyNzI5Zy5jb21cIixcbiAgICBcImJpbmFuY2VkZXhhaXJkcm9wLm5ldFwiLFxuICAgIFwiZ2l2ZWF3YXkyMDE4Lm9yZ1wiLFxuICAgIFwiYnVsbHJ1bjIwMTguY29tXCIsXG4gICAgXCJkb3VibGVjb2luaW8uamRldmNsb3VkLmNvbVwiLFxuICAgIFwibWVkaWl1bS5vcmdcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtYmUuc3BhY2VcIixcbiAgICBcImJpbmFuY2UtZGV4YmV0YS5uZXRcIixcbiAgICBcImJpdHRyZXgtcmYuY29tXCIsXG4gICAgXCJiaXR0cmV4LXJ4LmNvbVwiLFxuICAgIFwiY29pbmJhc2UtemVuZGVzay5jb21cIixcbiAgICBcImNvaW5iYXNlZGV4bmV3cy5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWh1Yi5jb21cIixcbiAgICBcImNvaW5iYXNldGguaW5mb1wiLFxuICAgIFwibXljcnlwdG9hLmdxXCIsXG4gICAgXCJteWV0ZXJ2YWxsaWVudC5pbmZvXCIsXG4gICAgXCJteWV0aGlyd2FsZGUuaW5mb1wiLFxuICAgIFwidHJlem9yLXdhbGxldHMub3JnXCIsXG4gICAgXCJ2d3Yta3Jha2VuLmNvbVwiLFxuICAgIFwidnd2dy1rcmFrZW4uY29tXCIsXG4gICAgXCJ3dnd3LWtyYWtlbi5jb21cIixcbiAgICBcInhuLS1rYWtlbi0xN2IuY29tXCIsXG4gICAgXCJ4bi0ta2FrZW4tZThiLmNvbVwiLFxuICAgIFwieG4tLWtyYWtuLTI1Yi5jb21cIixcbiAgICBcInhuLS1rcmFrbi04Y2MuY29tXCIsXG4gICAgXCJ4bi0ta3Jha24tZjZiLmNvbVwiLFxuICAgIFwiY29pbmJhc2UucHJvLXhjYS5jb21cIixcbiAgICBcInByby14Y2EuY29tXCIsXG4gICAgXCJhd3gtbHkuc3RvcmVcIixcbiAgICBcImJpbmFuY2UtZGV4LmxpZmVcIixcbiAgICBcImJpbmFuY2UtZGV4LmxpdmVcIixcbiAgICBcImJpbmFuY2UtZGV4b25saW5lLmluZm9cIixcbiAgICBcImJpbmFuY2UuZmFuXCIsXG4gICAgXCJiaW5hbmNlZGV4YmV0YS5jb21cIixcbiAgICBcImJpdC10aHVtYi5jb21cIixcbiAgICBcImNvaW5iYXNlZGV4eC5pbmZvXCIsXG4gICAgXCJrcmFrZW4udmlwXCIsXG4gICAgXCJsb2NhbGJhdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiY29pbnMucnVcIixcbiAgICBcImxvY2FsYmlrY29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpbWNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjYWlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbXMuaW5mb1wiLFxuICAgIFwibG9jYWxiaXRjb2luLmNhc2hcIixcbiAgICBcImxvY2FsYml0Y29pbmVzLmluZm9cIixcbiAgICBcImxvY2FsYml0Y29saW5zLmluZm9cIixcbiAgICBcImxvY2FsYml0bG9pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdHNjb2lucy5pbmZvXCIsXG4gICAgXCJsb2NhbHNpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jc2xiaXRjb2lucy5pbmZvXCIsXG4gICAgXCJsb2phbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9rYWxiaXRjb2luLmluZm9cIixcbiAgICBcIm1ldGFtYXNraGVscC5jb21cIixcbiAgICBcIm15ZXRoZHdhbGxpZXQuaW5mb1wiLFxuICAgIFwibXlldGhlcndlbGxldC5pbmZvXCIsXG4gICAgXCJteWV0aGllc3dhbGxlcC5pbmZvXCIsXG4gICAgXCJteWV0aGxlcndhbGxpZXQuaW5mb1wiLFxuICAgIFwibXlldGhyd2FpbGxldC5pbmZvXCIsXG4gICAgXCJwb2xvbmlleC5jbG91ZFwiLFxuICAgIFwicG9sb25pZXhzLmNvbVwiLFxuICAgIFwic2hvcC10cmV6b3IuaW9cIixcbiAgICBcInN0Y29pbmJhc2UuY29tXCIsXG4gICAgXCJ0cmV6b3Itd2FsbGV0cy5zdG9yZVwiLFxuICAgIFwidHVwYml0LmNvbVwiLFxuICAgIFwid3d2dy1rcmFrZW4uY29tXCIsXG4gICAgXCJ4bi0tY29uYmFzLXh2YTg3YS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsdC1iM2I0MDM5Zy5jb21cIixcbiAgICBcImNvaW5iYXNlLnByb3dzLWF4LmNvbVwiLFxuICAgIFwicHJvd3MtYXguY29tXCIsXG4gICAgXCJvdHgtY2EuY29tXCIsXG4gICAgXCJhdi16YS5jb21cIixcbiAgICBcImNsYS1wcm8uY29tXCIsXG4gICAgXCJiaXRjb2ludG9vbG1pbmluZy5jb21cIixcbiAgICBcImlkZXhldGhlcmV1bS5vbmxpbmVcIixcbiAgICBcImJieG90Yy50ZWNoXCIsXG4gICAgXCJidGMtZ2lmdHMubmV0XCIsXG4gICAgXCJiaWl0ZmlpbmV4LmNvbVwiLFxuICAgIFwiYmluYW5jZS1kZXhib3VudHkuaW5mb1wiLFxuICAgIFwiYmluYW5jZS1kb3dubG9hZC5jb21cIixcbiAgICBcImJpbmFuY2VidGNhaXJkcm9wLm5ldFwiLFxuICAgIFwiYml0YmFuay5mdW5kXCIsXG4gICAgXCJiaXR0cmV4eC53aW5cIixcbiAgICBcImNhcmVlcmJpdHRyZXguY29tXCIsXG4gICAgXCJjb2luYmFzZS1yaXBwbGUub3JnXCIsXG4gICAgXCJjb2luYmFzZS12aXAuY29tXCIsXG4gICAgXCJjb2luYmFzZWFpcmRyb3AuY29tXCIsXG4gICAgXCJjb2luYmFzZWFpcmRyb3AuaW5mb1wiLFxuICAgIFwiY29pbmJhc2VjYXNoLmNvbVwiLFxuICAgIFwiY29pbmJhc2VkZXguaW5mb1wiLFxuICAgIFwiY29pbm1hcmtldGNhcC5vdmhcIixcbiAgICBcImhpdGJ0Yy5zZVwiLFxuICAgIFwiaW50ZXJuYXRpb25hbC1iaW5hbmNlLmNvbVwiLFxuICAgIFwiaW50ZXJuYXRpb25hbC5iaXR0cmV4LmNvbTc4MTIzNjc4MS5ncVwiLFxuICAgIFwia3Jha2V6bi5jb21cIixcbiAgICBcImxvY2FtYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2hhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9sYWxiaXRjb2lucy5jb21cIixcbiAgICBcIm1leXRoZXJtYWxsZXQuY29tXCIsXG4gICAgXCJteWN0aGNyd2FsbGN0LmNvbVwiLFxuICAgIFwibXllaHRjcndhbGxjdC5jb21cIixcbiAgICBcIm15ZWh0ZXJ2dmFpbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJud2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRoZXJzd2FqbGxldC5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWVzLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWdldC5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldGwuaW5mb1wiLFxuICAgIFwibXlldGhlcndvbGV0LmNvbVwiLFxuICAgIFwibXlldGhyZW53YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHdhbGxldC5pbmZvXCIsXG4gICAgXCJteWV0bGhlcndhbGxldC5vbmxpbmVcIixcbiAgICBcIm15ZXRyaGV3YWxsZXQuY29tXCIsXG4gICAgXCJwYXhmdWwuY29cIixcbiAgICBcInBvbG9ubGV4LmNvbVwiLFxuICAgIFwidnd3LWtyYWtlbi5jb21cIixcbiAgICBcIndlYmltYWdlLm1sXCIsXG4gICAgXCJ3d3Yta3Jha2VuLmNvbVwiLFxuICAgIFwid3d3LWNvaW5zYmFuay5jb21cIixcbiAgICBcInd3d2h1b2JpLnByb1wiLFxuICAgIFwieG4tLWh1b2IteXc1YS5jb21cIixcbiAgICBcInhuLS1rcmtlLW1vYTQwZC5jb21cIixcbiAgICBcInhuLS1rcmtlbi00cWEuY29tXCIsXG4gICAgXCJ4bi0ta3JrZW4tYzUxYi5jb21cIixcbiAgICBcInhuLS1rcmtlbi1uNDFiLmNvbVwiLFxuICAgIFwieG4tLWtya24tNm5hOWMuY29tXCIsXG4gICAgXCJ4bi0tbWV0aHJ3bGxldC11bWIwNjgxZzk0YS5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsZXQtOWQ1Zi5jb21cIixcbiAgICBcInhuLS1yZXpvci1xOWIuY29tXCIsXG4gICAgXCJ4bi0tdHJ6b3ItN3phLmNvbVwiLFxuICAgIFwieG4tLXRyem9yLXZ6YS5jb21cIixcbiAgICBcInhuLS11cGhsZC13b2IuY29tXCIsXG4gICAgXCJ4bi0tYmliby1lbzVhLmNvbVwiLFxuICAgIFwicGF4ZnVsbGRhc2hib2FyZC5jb21cIixcbiAgICBcImluZm8ucGF4ZnVsdmVyaWZ5LmNvbVwiLFxuICAgIFwicGF4ZnVsdmVyaWZ5LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC14eW8uc3BhY2VcIixcbiAgICBcInZpZXctc3RhdHlzLmluZm9cIixcbiAgICBcInhuLS1teWV0aGVyd2xsZXQtNTlhLmNvbS52aWV3LXN0YXR5cy5pbmZvXCIsXG4gICAgXCJteWV0aHdhbGNoZWxsZXQuc2l0ZVwiLFxuICAgIFwiYXBwbHllci5pbmZvXCIsXG4gICAgXCJ4bi0tcHhmdWwtM3FhLmNvbVwiLFxuICAgIFwidHJvbmt1Y29pbi5ibG9nc3BvdC5jb21cIixcbiAgICBcImh1b2JpZ2xvLmNvbVwiLFxuICAgIFwiY3J5cHRva3Vjb2luLmJsb2dzcG90LmNvbVwiLFxuICAgIFwibmVva3Vjb2luLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYmxvY2tjaGFpbi11cGRhdGUuYm91bmNlbWUubmV0XCIsXG4gICAgXCJjb2luYmVuZS5uZXRcIixcbiAgICBcImhpdGJ0Y3dhbGV0LmNvbVwiLFxuICAgIFwibXVzay5jbGFpbXNcIixcbiAgICBcInNwYWNleC5naXZlc1wiLFxuICAgIFwibXVzay5jbGlja1wiLFxuICAgIFwiZXRobmV3LnN0b3JlXCIsXG4gICAgXCJjb2luYmFzZS5wcm8tY2F4LmNvbVwiLFxuICAgIFwicHJvLWNheC5jb21cIixcbiAgICBcImNicy1wcm8uY29tXCIsXG4gICAgXCJ0eGEtYXNvLmNvbVwiLFxuICAgIFwiemFzLXByby5jb21cIixcbiAgICBcImJsb2NrY2hpYXJuLm5ldFwiLFxuICAgIFwicG9sb25pZXhuZW8uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJiaW5hbmNlLmV0aC13aW4uY29tXCIsXG4gICAgXCJldGgtd2luLmNvbVwiLFxuICAgIFwiaHVvYmlnbG9iLmxpdmVcIixcbiAgICBcIm1lZGl1bXBvc3QudG9wXCIsXG4gICAgXCJwdW5kaXguc2l0ZVwiLFxuICAgIFwiZGV4aHVvYmkuY29tXCIsXG4gICAgXCJiaW5hbmNlLWRldi5vbmxpbmVcIixcbiAgICBcImFhYml0aHViLmNvbVwiLFxuICAgIFwiYmluYW5jZS1haXJkcm9wLmhvbC5lc1wiLFxuICAgIFwiYmluYW5jZS1naWZ0LmNvbVwiLFxuICAgIFwiYmluYW5jZS5hY2NvdW50YW50XCIsXG4gICAgXCJiaW5hbmNlLmRhdGVcIixcbiAgICBcImJpbmFuY2UubWVuXCIsXG4gICAgXCJiaW5hbmNlLnNjaWVuY2VcIixcbiAgICBcImJpbmFuY2Uud2ViY2FtXCIsXG4gICAgXCJiaW5hbmNlYm5iLm9ubGluZVwiLFxuICAgIFwiYmluYW5jZXMuY2x1YlwiLFxuICAgIFwiYml0ZmlsZXMubWxcIixcbiAgICBcImNvaWluYmFzZS5jb21cIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW5zeC5jb21cIixcbiAgICBcImkxLmxvY2FsYml0Y29pbnN4LmNvbVwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2lzLm9yZ1wiLFxuICAgIFwia3Jha2VuLmNvbS5zZVwiLFxuICAgIFwibGNhbGJpdGNvaW5zLmJpelwiLFxuICAgIFwibGljYWxiaXRjb2lucy5jbHViXCIsXG4gICAgXCJsb2NhbGJpcGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXJjb2lucy5jbHViXCIsXG4gICAgXCJsb2NhbGJpcmNvaW5zLnRvcFwiLFxuICAgIFwibG9jYWxiaXRjb2luLmFzaWFcIixcbiAgICBcImxvY2FsYml0Y29pbmEuY2x1YlwiLFxuICAgIFwibG9jYWxiaXRjb2luYS50b3BcIixcbiAgICBcImxvY2FsYml0Y29pbmQuY2x1YlwiLFxuICAgIFwibG9jYWxiaXRjb2luZC5uZXQucnVcIixcbiAgICBcImxvY2FsYml0Y29pbmVzLnRvcFwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5vb29cIixcbiAgICBcImxvY2FsYml0Y29pbnMucnUubmV0XCIsXG4gICAgXCJsb2NhbGJpdGNvbGlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y291bnMuY2x1YlwiLFxuICAgIFwibG9jYWxiaXRrb2lucy5jb20ucnVcIixcbiAgICBcImxvY2FsYml0a29pbnMubmV0LnJ1XCIsXG4gICAgXCJsb2NhbGJpdG9jaW5zLmNsdWJcIixcbiAgICBcImxvY2FsYml0c2NvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRzY29pbnMubmV0LnJ1XCIsXG4gICAgXCJsb2NhbGJ1dGNvaW5zLmFzaWFcIixcbiAgICBcImxvY2FsYnV0Y29pbnMubmV0XCIsXG4gICAgXCJsb2NhbGJ1dGNvaW5zLm5ldC5ydVwiLFxuICAgIFwibG9jYWxuaXRjb2lucy5jbHViXCIsXG4gICAgXCJsb2NhbG5pdGNvaW5zLnRvcFwiLFxuICAgIFwibG9jYWxzYml0Y29pbnMubmV0XCIsXG4gICAgXCJsb2NhbHZpdGNvaW5zLmNsdWJcIixcbiAgICBcImxvY2xiaXRjb2lucy5jb20ucnVcIixcbiAgICBcImxvY2xiaXRjb2lucy5uZXQucnVcIixcbiAgICBcImxvY3NsYml0Y29pbnMuY2x1YlwiLFxuICAgIFwibG9rYWxiaXRjaW5zLmNvbVwiLFxuICAgIFwibG9rYWxiaXRjb2lucy5jb20ucnVcIixcbiAgICBcImxva2FsYml0Y29pbnMuZ2RuXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLm5ldC5ydVwiLFxuICAgIFwibG9rYWxiaXRjb2lucy5vcmcucnVcIixcbiAgICBcImxva2FsYml0Y29pbnMucGxcIixcbiAgICBcImxva2FsYml0Y29pbnQuY29tXCIsXG4gICAgXCJsb3ZhbGJpdGNvaW5zLmNsdWJcIixcbiAgICBcImxvdmFsYml0Y29pbnMudG9wXCIsXG4gICAgXCJtYW5hZ2UtYXBwbGVzdXBwb3J0LXZlcmlmaWNhdGlvbi5jb21cIixcbiAgICBcIm1leXRoZXJ2dmFsbGV0Lm5ldFwiLFxuICAgIFwibWV5dGhlcnZ2YWxsZXQub3JnXCIsXG4gICAgXCJtZXl0aGVyd2VsbGV0LmluZm9cIixcbiAgICBcIm1leXRoZXJ3ZWxsZXQubmV0XCIsXG4gICAgXCJtbnlldGxoZXJ3YmxsZXQuY29tXCIsXG4gICAgXCJtbnlldG5oZXJ3YWlsZXQuY29tXCIsXG4gICAgXCJteWN0aGVydnZlbGxldC5jb21cIixcbiAgICBcIm15Y3RoZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJteWVmaGVyd2FpbGV0LmNvbVwiLFxuICAgIFwibXllaHRlcnZ2YWxsY3QuY29tXCIsXG4gICAgXCJteWVodGVyd2VsbGV0ZS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtZGUuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsbmV0LmNvbVwiLFxuICAgIFwibXlzY3JlZW4ubWxcIixcbiAgICBcInBvbG9uaWV4Lm9ubGluZVwiLFxuICAgIFwicm55ZXRoZXJ2YWxsZWwuY29tXCIsXG4gICAgXCJ0ZXJtcy1wYXhmdWwuY29tXCIsXG4gICAgXCJ4bi0tYml0Zm5leC0yeWEuY29tXCIsXG4gICAgXCJ4bi0taHVvYi04dzVhLmNvbVwiLFxuICAgIFwiY3J5cHRvcGhvbmVzdXBwb3J0LmNvbVwiLFxuICAgIFwia2VlcHN0YWtlLmdpdGh1Yi5pb1wiLFxuICAgIFwibXNnLnhuLS1tZXRoZXJ3bGx0LXptYjU1ODFnOTRhLmNvbVwiLFxuICAgIFwieG4tLW1ldGhlcndsbHQtem1iNTU4MWc5NGEuY29tXCIsXG4gICAgXCJpbnRlcm5hdGlvbmFsLmJpdHRyZXguY29tODkxNzMyMS5nYVwiLFxuICAgIFwiY29tODkxNzMyMS5nYVwiLFxuICAgIFwic3BhY2V4LmRlbGl2ZXJ5XCIsXG4gICAgXCJiaWJvbHguY29tXCIsXG4gICAgXCJ4bi0tbWV0aGVyd2xsdC1mMmQ0ODg4Zjl2YS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtdWUuc3BhY2VcIixcbiAgICBcImdldC1ldGgtbm93Lm9ubGluZVwiLFxuICAgIFwieG4tLXRyby1yd2EubmV0XCIsXG4gICAgXCJlcmMtMjAubXlldGhlcndhbGxldC5ib251cy50b2tlbnMtbWV3LmNvbVwiLFxuICAgIFwidG9rZW5zLW1ldy5jb21cIixcbiAgICBcImJpbmFuY2UtaG9tZS1hcHAuY29tXCIsXG4gICAgXCJiaW5hbmNlLWlsLmNvbVwiLFxuICAgIFwiYmluYW5jZS5jcmlja2V0XCIsXG4gICAgXCJiaW5hbmNlLmxvYW5cIixcbiAgICBcImJpbmFuY2VkZXguY2VudGVyXCIsXG4gICAgXCJiaW5hbmNlbC5jb21cIixcbiAgICBcImJpbmFuY2VzLndpblwiLFxuICAgIFwiYmluYW5jZXN0by5vcmdcIixcbiAgICBcImNvaW5iYXNlLXVzZGMuaW5mb1wiLFxuICAgIFwiY29pbmRlc2suaHVcIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW4uZG93bmxvYWRcIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW4ub25saW5lXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2luLnJldmlld1wiLFxuICAgIFwiZGVzaWduLmxvY2FsYml0Y29pbi51c1wiLFxuICAgIFwiZGVzaWduLmxvY2FsYml0Y29pbi53ZWJzaXRlXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2luLndpblwiLFxuICAgIFwiZGVzaWduLmxvY2FsYml0Y29pbnMuZGF0ZVwiLFxuICAgIFwiZGVzaWduLmxvY2FsYml0Y29pbnMuZ2RuXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2lucy5yYWNpbmdcIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW5zLnJldmlld1wiLFxuICAgIFwiZGVzaWduLmxvY2FsYml0Y29pbnMuc2NpZW5jZVwiLFxuICAgIFwiZGVzaWduLmxvY2FsYml0Y29pbnMud2ViY2FtXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2luc2EuY29tXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2luc2QuY29tXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2luc3QuY29tXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2lueHMuY29tXCIsXG4gICAgXCJkZXNpZ24ubWFya2V0aG90MjQucnVcIixcbiAgICBcImRleGJpbmFuY2UuY2VudGVyXCIsXG4gICAgXCJkZXhiaW5hbmNlLmluZm9cIixcbiAgICBcImhpdGJ0Yy5pbmZvXCIsXG4gICAgXCJoaXRidGMub3JnXCIsXG4gICAgXCJoaXRidGMucnVcIixcbiAgICBcImhpdGJ0Yy5zaXRlXCIsXG4gICAgXCJoaXRidGMuc3BhY2VcIixcbiAgICBcImhpdGJ0Yy50ZWNoXCIsXG4gICAgXCJoaXRidGMudXNcIixcbiAgICBcImhpdGJ0eC5jb21cIixcbiAgICBcImhpdHRidGMuY29tXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW4uYmlkXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW4ub25saW5lXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW4ucmV2aWV3XCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW4uc3RyZWFtXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW4udG9wXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW4ud2luXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW5zLnJldmlld1wiLFxuICAgIFwiaTEubG9jYWxiaXRjb2lucy5zY2llbmNlXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW5zLndlYmNhbVwiLFxuICAgIFwiaTEubG9jYWxiaXRjb2luc2QuY29tXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW5zdC5jb21cIixcbiAgICBcImkxLmxvY2FsYml0Y29pcy5iaXpcIixcbiAgICBcImkxLmxvY2FsYml0Y29pcy5vcmdcIixcbiAgICBcImkyLmtsb2NhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2luLmRvd25sb2FkXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW4ub25saW5lXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW4ucmV2aWV3XCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW4udG9wXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW4udXNcIixcbiAgICBcImkyLmxvY2FsYml0Y29pbi53ZWJzaXRlXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW5kLmNvbVwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2lucy5kYXRlXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW5zLmdkblwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2lucy5yZXZpZXdcIixcbiAgICBcImkyLmxvY2FsYml0Y29pbnMuc2NpZW5jZVwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2lucy5zdVwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2lucy53ZWJjYW1cIixcbiAgICBcImkyLmxvY2FsYml0Y29pbnNkLmNvbVwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2luc3guY29tXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaXMuYml6XCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaXMuaW5mb1wiLFxuICAgIFwiaTMubG9jYWxiaXRjb2luLmJpZFwiLFxuICAgIFwiaTMubG9jYWxiaXRjb2luLnJldmlld1wiLFxuICAgIFwiaTMubG9jYWxiaXRjb2luLnRvcFwiLFxuICAgIFwiaTMubG9jYWxiaXRjb2luLnVzXCIsXG4gICAgXCJpMy5sb2NhbGJpdGNvaW4ud2Vic2l0ZVwiLFxuICAgIFwiaTMubG9jYWxiaXRjb2lzLm9yZ1wiLFxuICAgIFwiaTQubG9jYWxiaXRjb2luLnJldmlld1wiLFxuICAgIFwiaW5kb2RheDEuY29tXCIsXG4gICAgXCJpbmRvZGF4Yy5jb21cIixcbiAgICBcImluZm8tbWVyY2F0b3guY29tXCIsXG4gICAgXCJsOWNhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibGNhbGJpdGNvaW5zLmNsdWJcIixcbiAgICBcImxjYWxiaXRjb2lucy5vcmdcIixcbiAgICBcImxkZXguc3BhY2VcIixcbiAgICBcImxlY2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsaW9jYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvYWNsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2FjbGJpdGNvaW5zLm5ldFwiLFxuICAgIFwibG9hY2xiaXRjb2lucy5vcmdcIixcbiAgICBcImxvYWNsYml0Y29pbnMudXNcIixcbiAgICBcImxvYWxiaXRjb2lucy5iaXpcIixcbiAgICBcImxvYWxiaXRjb2lucy5jbHViXCIsXG4gICAgXCJsb2FsYml0Y29pbnMubG9hblwiLFxuICAgIFwibG9hbGJpdGNvaW5zLm1vYmlcIixcbiAgICBcImxvYWxiaXRjb2lucy5uZXRcIixcbiAgICBcImxvYWxiaXRjb2lucy5vcmdcIixcbiAgICBcImxvYWxiaXRjb2lucy51c1wiLFxuICAgIFwibG9hbGJpdGNvaW5zLndpblwiLFxuICAgIFwibG9jYWJpdGNvaW5zLnRvcFwiLFxuICAgIFwibG9jYWJpdGNvaW5zLnRyYWRlXCIsXG4gICAgXCJsb2NhYml0Y29pbnMud2luXCIsXG4gICAgXCJsb2NhbGI5dGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiYml0Y29pbnMubmV0XCIsXG4gICAgXCJsb2NhbGJlZXRjb2lucy5jb21cIixcbiAgICBcImxvY2FsYmk2Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpY29pbnMuYmlkXCIsXG4gICAgXCJsb2NhbGJpY29pbnMuYml6XCIsXG4gICAgXCJsb2NhbGJpY29pbnMuY2x1YlwiLFxuICAgIFwibG9jYWxiaWNvaW5zLmxvYW5cIixcbiAgICBcImxvY2FsYmljb2lucy5vcmdcIixcbiAgICBcImxvY2FsYmljb2lucy50b3BcIixcbiAgICBcImxvY2FsYmljb2lucy50cmFkZVwiLFxuICAgIFwibG9jYWxiaWNvaW5zLnVzXCIsXG4gICAgXCJsb2NhbGJpY29pbnMud2luXCIsXG4gICAgXCJsb2NhbGJpY3RvaW5zLm5ldFwiLFxuICAgIFwibG9jYWxiaWtvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaWt0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpbGxjb2lucy5ydVwiLFxuICAgIFwibG9jYWxiaW5jb2lucy5jb21cIixcbiAgICBcImxvY2FsYmlyY29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpcmNvaW5zLnVzXCIsXG4gICAgXCJsb2NhbGJpc2NvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjMGlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y2RvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjZm9pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNpbnMuY2x1YlwiLFxuICAgIFwibG9jYWxiaXRjaW5zLmxvYW5cIixcbiAgICBcImxvY2FsYml0Y2lucy5tZW5cIixcbiAgICBcImxvY2FsYml0Y2lucy50cmFkZVwiLFxuICAgIFwibG9jYWxiaXRjaW5zLndpblwiLFxuICAgIFwibG9jYWxiaXRja29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNsaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjbG9pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvOG5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjbzlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y29lbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaWJucy5jb21cIixcbiAgICBcImxvY2FsYml0Y29paHMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW1ucy5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbi5jcmlja2V0XCIsXG4gICAgXCJsb2NhbGJpdGNvaW4uZ2RuXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4uaG9zdFwiLFxuICAgIFwibG9jYWxiaXRjb2luLmhvdXNlXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4ubGlua1wiLFxuICAgIFwibG9jYWxiaXRjb2luLmxvYW5cIixcbiAgICBcImxvY2FsYml0Y29pbi5ubFwiLFxuICAgIFwibG9jYWxiaXRjb2luLm9yZy5ydVwiLFxuICAgIFwibG9jYWxiaXRjb2luLnBhcnR5XCIsXG4gICAgXCJsb2NhbGJpdGNvaW4ucHJvXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4ucmFjaW5nXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4ucmV2aWV3XCIsXG4gICAgXCJsb2NhbGJpdGNvaW4uc2NpZW5jZVwiLFxuICAgIFwibG9jYWxiaXRjb2luLnNpdGVcIixcbiAgICBcImxvY2FsYml0Y29pbi5zcGFjZVwiLFxuICAgIFwibG9jYWxiaXRjb2luLnRvcFwiLFxuICAgIFwibG9jYWxiaXRjb2luLndlYmNhbVwiLFxuICAgIFwibG9jYWxiaXRjb2luLndlYnNpdGVcIixcbiAgICBcImxvY2FsYml0Y29pbi53aW5cIixcbiAgICBcImxvY2FsYml0Y29pbmEub3JnXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5hLnVzXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5kLnRvcFwiLFxuICAgIFwibG9jYWxiaXRjb2luZC53aW5cIixcbiAgICBcImxvY2FsYml0Y29pbmVzLmJpZFwiLFxuICAgIFwibG9jYWxiaXRjb2luZXMudHJhZGVcIixcbiAgICBcImxvY2FsYml0Y29pbmVzLndpblwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5hY2NvdW50YW50XCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLmNvbS5ydVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5jelwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5kZXNpZ25cIixcbiAgICBcImxvY2FsYml0Y29pbnMuZ2RuXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLmtpbVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5saWZlXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLm5ldC5ydVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5zaXRlXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLnNwYWNlXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLnRvcFwiLFxuICAgIFwibG9jYWxiaXRjb2lucy53ZWJjYW1cIixcbiAgICBcImxvY2FsYml0Y29pbnMud29ybGRcIixcbiAgICBcImxvY2FsYml0Y29pbnMydi5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbnNhLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2luc2QuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zZS5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbnNmb3JvLm5ldFwiLFxuICAgIFwibG9jYWxiaXRjb2luc3MuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zcy5uZXRcIixcbiAgICBcImxvY2FsYml0Y29pbnN3LmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2ludC5iaWRcIixcbiAgICBcImxvY2FsYml0Y29pbnQubG9hblwiLFxuICAgIFwibG9jYWxiaXRjb2ludC50b3BcIixcbiAgICBcImxvY2FsYml0Y29pbncuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW54LmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2lzLmJpelwiLFxuICAgIFwibG9jYWxiaXRjb2lzLmluZm9cIixcbiAgICBcImxvY2FsYml0Y29pcy5sb2FuXCIsXG4gICAgXCJsb2NhbGJpdGNvaXMubWVuXCIsXG4gICAgXCJsb2NhbGJpdGNvaXMub3JnXCIsXG4gICAgXCJsb2NhbGJpdGNvaXMucnVcIixcbiAgICBcImxvY2FsYml0Y29pcy50cmFkZVwiLFxuICAgIFwibG9jYWxiaXRjb2lzLnVzXCIsXG4gICAgXCJsb2NhbGJpdGNvaXMud2luXCIsXG4gICAgXCJsb2NhbGJpdGNvaXNuLm5ldFwiLFxuICAgIFwibG9jYWxiaXRjb2l1bnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaXlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y29qaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2xucy5pbmZvXCIsXG4gICAgXCJsb2NhbGJpdGNvbmlzLmJpelwiLFxuICAgIFwibG9jYWxiaXRjb25pcy5jb21cIixcbiAgICBcImxvY2FsYml0Y29uaXMubmV0XCIsXG4gICAgXCJsb2NhbGJpdGNvbmlzLm9yZ1wiLFxuICAgIFwibG9jYWxiaXRjb25pcy50b3BcIixcbiAgICBcImxvY2FsYml0Y29ucy5iaWRcIixcbiAgICBcImxvY2FsYml0Y29ucy5iaXpcIixcbiAgICBcImxvY2FsYml0Y29ucy5pbmZvXCIsXG4gICAgXCJsb2NhbGJpdGNvbnMubmV0XCIsXG4gICAgXCJsb2NhbGJpdGNvbnMucnVcIixcbiAgICBcImxvY2FsYml0Y29ucy5zcGFjZVwiLFxuICAgIFwibG9jYWxiaXRjb25zLnVzXCIsXG4gICAgXCJsb2NhbGJpdGNvbnMud2luXCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy5jbHViXCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y291aW5zLm5ldFwiLFxuICAgIFwibG9jYWxiaXRjb3VpbnMubmV0LnJ1XCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy5zaXRlXCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy53ZWJzaXRlXCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy54eXpcIixcbiAgICBcImxvY2FsYml0Y291bnMuYml6XCIsXG4gICAgXCJsb2NhbGJpdGNvdW5zLnVzXCIsXG4gICAgXCJsb2NhbGJpdGNwaW5zLnVzXCIsXG4gICAgXCJsb2NhbGJpdGNwb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0Y3hvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRkY29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGZjb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0a29pbi5jb21cIixcbiAgICBcImxvY2FsYml0a29pbnMuYmlkXCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLmNsdWJcIixcbiAgICBcImxvY2FsYml0a29pbnMuY29cIixcbiAgICBcImxvY2FsYml0a29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLmRvd25sb2FkXCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLmZhaXRoXCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLmxvYW5cIixcbiAgICBcImxvY2FsYml0a29pbnMubWVuXCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLnByb1wiLFxuICAgIFwibG9jYWxiaXRrb2lucy5ydVwiLFxuICAgIFwibG9jYWxiaXRrb2lucy5zaXRlXCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLnRvcFwiLFxuICAgIFwibG9jYWxiaXRrb2lucy50cmFkZVwiLFxuICAgIFwibG9jYWxiaXRrb2lucy51c1wiLFxuICAgIFwibG9jYWxiaXRrb2lucy53aW5cIixcbiAgICBcImxvY2FsYml0b2NpbnMub3JnXCIsXG4gICAgXCJsb2NhbGJpdG9pbnMuYmlkXCIsXG4gICAgXCJsb2NhbGJpdG9pbnMuYml6XCIsXG4gICAgXCJsb2NhbGJpdG9pbnMuY2x1YlwiLFxuICAgIFwibG9jYWxiaXRvaW5zLmluZm9cIixcbiAgICBcImxvY2FsYml0b2lucy5sb2FuXCIsXG4gICAgXCJsb2NhbGJpdG9pbnMub3JnXCIsXG4gICAgXCJsb2NhbGJpdG9pbnMucnVcIixcbiAgICBcImxvY2FsYml0b2lucy50cmFkZVwiLFxuICAgIFwibG9jYWxiaXRvaW5zLnVzXCIsXG4gICAgXCJsb2NhbGJpdG9pbnMud2luXCIsXG4gICAgXCJsb2NhbGJpdHFvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRzY29pbnMuYmlkXCIsXG4gICAgXCJsb2NhbGJpdHNjb2lucy5jbHViXCIsXG4gICAgXCJsb2NhbGJpdHNjb2lucy5mYWl0aFwiLFxuICAgIFwibG9jYWxiaXRzY29pbnMubWVuXCIsXG4gICAgXCJsb2NhbGJpdHNjb2lucy5vcmdcIixcbiAgICBcImxvY2FsYml0c2NvaW5zLnRvcFwiLFxuICAgIFwibG9jYWxiaXRzY29pbnMudXNcIixcbiAgICBcImxvY2FsYml0c2NvaW5zLndpblwiLFxuICAgIFwibG9jYWxiaXRzb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0dm9pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdXRjb2lucy5jb21cIixcbiAgICBcImxvY2FsYml5Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJqdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxib3Rjb2lucy50b3BcIixcbiAgICBcImxvY2FsYm90Y29pbnMudHJhZGVcIixcbiAgICBcImxvY2FsYnRjb2lucy5iaXpcIixcbiAgICBcImxvY2FsYnRjb2lucy5tZW5cIixcbiAgICBcImxvY2FsYnRjb2lucy5vcmdcIixcbiAgICBcImxvY2FsYnRjb2lucy53aW5cIixcbiAgICBcImxvY2FsYnR0Y29pbnMucnVcIixcbiAgICBcImxvY2FsYnVpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxidXRjb2lucy5iaWRcIixcbiAgICBcImxvY2FsYnV0Y29pbnMuZmFpdGhcIixcbiAgICBcImxvY2FsYnV0Y29pbnMuaW5mb1wiLFxuICAgIFwibG9jYWxidXRjb2lucy5tZW5cIixcbiAgICBcImxvY2FsYnV0Y29pbnMud2luXCIsXG4gICAgXCJsb2NhbGJ1dHNjb2lucy5jb21cIixcbiAgICBcImxvY2FsYnZpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxnYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGdpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxoaXRjb2lucy5jb21cIixcbiAgICBcImxvY2FsaWJ0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGl0Y29pbnMuYmlkXCIsXG4gICAgXCJsb2NhbGl0Y29pbnMuYml6XCIsXG4gICAgXCJsb2NhbGl0Y29pbnMuY2x1YlwiLFxuICAgIFwibG9jYWxpdGNvaW5zLmluZm9cIixcbiAgICBcImxvY2FsaXRjb2lucy5tZW5cIixcbiAgICBcImxvY2FsaXRjb2lucy5vcmdcIixcbiAgICBcImxvY2FsaXRjb2lucy50b3BcIixcbiAgICBcImxvY2FsaXRjb2lucy51c1wiLFxuICAgIFwibG9jYWxrYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbG5pdGNvaW5zLmJpelwiLFxuICAgIFwibG9jYWxuaXRjb2lucy5jb21cIixcbiAgICBcImxvY2Fsbml0Y29pbnMudXNcIixcbiAgICBcImxvY2FscGl0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbHNiaXRjb2lucy5pbmZvXCIsXG4gICAgXCJsb2NhbHNiaXRjb2lucy5ydVwiLFxuICAgIFwibG9jYWxzYml0Y29pbnMudG9wXCIsXG4gICAgXCJsb2NhbHNiaXRjb2lucy51c1wiLFxuICAgIFwibG9jYWxzYml0Y29pbnMud2luXCIsXG4gICAgXCJsb2NhbHNiaXRzY29pbnMuY29tXCIsXG4gICAgXCJsb2NhbHZpdGNvaW5zLnh5elwiLFxuICAgIFwibG9jYWx2aXRzY29pbnMuY29tXCIsXG4gICAgXCJsb2NhbHliaXRjb2lucy5jb21cIixcbiAgICBcImxvY2FzbGJpdGNvaW5zLm9yZ1wiLFxuICAgIFwibG9jYXpsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NmYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvY2xhYml0Y29pbnMubmV0XCIsXG4gICAgXCJsb2NsYWJpdGNvaW5zLnVzXCIsXG4gICAgXCJsb2NsYml0Y29pbnMuYWNjb3VudGFudFwiLFxuICAgIFwibG9jbGJpdGNvaW5zLmFzaWFcIixcbiAgICBcImxvY2xiaXRjb2lucy5jbHViXCIsXG4gICAgXCJsb2NsYml0Y29pbnMuY3JpY2tldFwiLFxuICAgIFwibG9jbGJpdGNvaW5zLmRhdGVcIixcbiAgICBcImxvY2xiaXRjb2lucy5kb3dubG9hZFwiLFxuICAgIFwibG9jbGJpdGNvaW5zLmZhaXRoXCIsXG4gICAgXCJsb2NsYml0Y29pbnMubG9hblwiLFxuICAgIFwibG9jbGJpdGNvaW5zLm9yZ1wiLFxuICAgIFwibG9jbGJpdGNvaW5zLnBhcnR5XCIsXG4gICAgXCJsb2NsYml0Y29pbnMucHJvXCIsXG4gICAgXCJsb2NsYml0Y29pbnMucmFjaW5nXCIsXG4gICAgXCJsb2NsYml0Y29pbnMucmV2aWV3XCIsXG4gICAgXCJsb2NsYml0Y29pbnMuc2NpZW5jZVwiLFxuICAgIFwibG9jbGJpdGNvaW5zLnNpdGVcIixcbiAgICBcImxvY2xiaXRjb2lucy5zcGFjZVwiLFxuICAgIFwibG9jbGJpdGNvaW5zLnRvcFwiLFxuICAgIFwibG9jbGJpdGNvaW5zLnRyYWRlXCIsXG4gICAgXCJsb2NsYml0Y29pbnMud2Vic2l0ZVwiLFxuICAgIFwibG9jbGJpdGNvaW5zLndpblwiLFxuICAgIFwibG9jcWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvY3psYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2RjYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvZ2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2ljYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxva2FsYmljb2lucy5jb21cIixcbiAgICBcImxva2FsYml0Y29pbi5jb21cIixcbiAgICBcImxva2FsYml0Y29pbnMuYmlkXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLmNsdWJcIixcbiAgICBcImxva2FsYml0Y29pbnMuZGF0ZVwiLFxuICAgIFwibG9rYWxiaXRjb2lucy5ob3N0XCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLm1lXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLm1lblwiLFxuICAgIFwibG9rYWxiaXRjb2lucy5tb2JpXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLm9ubGluZVwiLFxuICAgIFwibG9rYWxiaXRjb2lucy5yYWNpbmdcIixcbiAgICBcImxva2FsYml0Y29pbnMucmV2aWV3XCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLnNjaWVuY2VcIixcbiAgICBcImxva2FsYml0Y29pbnMuc2l0ZVwiLFxuICAgIFwibG9rYWxiaXRjb2lucy5zcGFjZVwiLFxuICAgIFwibG9rYWxiaXRjb2lucy5zdHJlYW1cIixcbiAgICBcImxva2FsYml0Y29pbnMudG9wXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLnVzXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLndpblwiLFxuICAgIFwibG9rYWxiaXRzY29pbnMuY29tXCIsXG4gICAgXCJsb2thbGJ1dGNvaW5zLmNvbVwiLFxuICAgIFwibG9rYWxzYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2tjYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvcWFsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb3ZhbGJpdGNvaW5zLmJpelwiLFxuICAgIFwibHBjYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxwb2NhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibHVvY2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJtZXJjYW90eC5jb21cIixcbiAgICBcIm1lcmNhdG9veC5jb21cIixcbiAgICBcIm1lcmNhdG94Lm1hcmtldFwiLFxuICAgIFwibWVyY2F0dG94LmNvbVwiLFxuICAgIFwibWVydmF0b3guY29tXCIsXG4gICAgXCJteWV0ZXJ3YWxsZXQuc3VcIixcbiAgICBcIm15ZXRoZXJldW0td2FsbGV0LWNvbS5jb21cIixcbiAgICBcIm15ZXRoZXJldW0td2FsbGV0LWNvbS5pbmZvXCIsXG4gICAgXCJteWV0aGVyZXVtLXdhbGxldC1jb20uc2l0ZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1kcm9wLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWVtLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWV1LnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LW1zZ3NpZ24uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY2xhaW0uZXJjLTIwLmJvbnVzLnRva2Vucy1tZXcuY29tXCIsXG4gICAgXCJteWV0aGl3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHdhY2hsdGV0LmNvbVwiLFxuICAgIFwibXlldGh3YXRjaGxldC5jb21cIixcbiAgICBcIm15ZXRod2F0Y2hsbGV0LmNvbVwiLFxuICAgIFwibXlzZWxoZXJ3YWxsZWwuY29tXCIsXG4gICAgXCJvY2FsYml0Y29pbnMubmV0XCIsXG4gICAgXCJvbGNhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwidi1rcmFrZW4uY29tXCIsXG4gICAgXCJ3d3ctYmluYW5jZS5vbmxpbmVcIixcbiAgICBcInhuLS1iaW5uYy01d2E2bC5jb21cIixcbiAgICBcInhuLS1odW9iLW96YS5jb21cIixcbiAgICBcInhuLS1rcmFrZS13bTFiLmNvbVwiLFxuICAgIFwieG4tLWtyYWtuLWY2MWIuY29tXCIsXG4gICAgXCJ4bi0ta3JrZW4teXFhLmNvbVwiLFxuICAgIFwieG4tLWtya24tY3RhOTk3NmIuY29tXCIsXG4gICAgXCJtZWRpdW0tZXRoZXIuY29tXCIsXG4gICAgXCJnaWZ0LWJ0Yy5uZXRcIixcbiAgICBcIm15ZXRuZXJ3YWxsZXQuY29tLmFwcGxpY2F0aW9uLXNlbmQuaW5mb1wiLFxuICAgIFwiYXBwbGljYXRpb24tc2VuZC5pbmZvXCIsXG4gICAgXCJtZWRpdW16LnRvcFwiLFxuICAgIFwiZ2l2ZWF3YXlldGhlci5uZXRcIixcbiAgICBcImRyZ25haXJkcm9wLmNvbVwiLFxuICAgIFwiaHVvYmlnbG8ubGl2ZVwiLFxuICAgIFwiZ2V0bXVzay5zcGFjZVwiLFxuICAgIFwicG9sb25pZXh0cm9uLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYnRjLXByb21vLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuMTZtYi5jb21cIixcbiAgICBcImJsb2cuMHhwcm9qZWN0LmNvXCIsXG4gICAgXCIweHByb2plY3QuY29cIixcbiAgICBcIndhbGxldC5wb2xsdXgubmV0d29ya1wiLFxuICAgIFwicG9sbHV4Lm5ldHdvcmtcIixcbiAgICBcIm12ZWxuZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJtdWx0cGxhdGZvcmxleC5hc2lhXCIsXG4gICAgXCJjcnlwdG9ibGFja2ZyaWRheS5ibG9nc3BvdC5jb21cIixcbiAgICBcImZyZWVjcnlwdG9naWZ0Lm9yZ1wiLFxuICAgIFwidHJvbmJsYWNrZnJpZGF5LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYnRjLWdpZnQudGVjaFwiLFxuICAgIFwibmVvYmxhY2tmcmlkYXkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJheWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwiYmluYW5jZS5mYWl0aFwiLFxuICAgIFwiYmluYW5jZS5yYWNpbmdcIixcbiAgICBcImJpbmFuY2VzLnRvcFwiLFxuICAgIFwiZGVzaWduLmtsb2NhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwiZGVzaWduLmxvY2FsYml0Y29pbi5zdHJlYW1cIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW4udG9wXCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2luZC5jb21cIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW5qcy5jb21cIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW5zLnN1XCIsXG4gICAgXCJkZXNpZ24ubG9jYWxiaXRjb2ludy5jb21cIixcbiAgICBcImRlc2lnbi5sb2NhbGJpdGNvaW56cy5jb21cIixcbiAgICBcImhpdGJ0Yy5iaWRcIixcbiAgICBcImhpdGJ0Yy5iaXpcIixcbiAgICBcImhpdGJ0Yy5jbHViXCIsXG4gICAgXCJoaXRidGMubGlua1wiLFxuICAgIFwiaGl0YnRjLmxvYW5cIixcbiAgICBcImhpdGJ0Yy5vbmxpbmVcIixcbiAgICBcImhpdGJ0Yy5wcmVzc1wiLFxuICAgIFwiaGl0YnRjLnRvcFwiLFxuICAgIFwiaGl0YnRjLnRyYWRlXCIsXG4gICAgXCJoaXRidGMud2luXCIsXG4gICAgXCJoaXRidHRjLmNvbVwiLFxuICAgIFwiaHVvYmkucHJlc3NcIixcbiAgICBcImkxLmtsb2NhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwiaTEubG9jYWxiaXRjb2luLmRvd25sb2FkXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW4udXNcIixcbiAgICBcImkxLmxvY2FsYml0Y29pbi53ZWJzaXRlXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW5kLmNvbVwiLFxuICAgIFwiaTEubG9jYWxiaXRjb2luanMuY29tXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW5zLmRhdGVcIixcbiAgICBcImkxLmxvY2FsYml0Y29pbnMuZ2RuXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW5zLnN1XCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW5zYS5jb21cIixcbiAgICBcImkxLmxvY2FsYml0Y29pbncuY29tXCIsXG4gICAgXCJpMS5sb2NhbGJpdGNvaW56cy5jb21cIixcbiAgICBcImkxLmxvY2FsYml0Y29pcy5pbmZvXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW4uYmlkXCIsXG4gICAgXCJpMi5sb2NhbGJpdGNvaW5qcy5jb21cIixcbiAgICBcImkyLmxvY2FsYml0Y29pbnNhLmNvbVwiLFxuICAgIFwiaTIubG9jYWxiaXRjb2ludy5jb21cIixcbiAgICBcImkyLmxvY2FsYml0Y29pbnpzLmNvbVwiLFxuICAgIFwia2xvY2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsYWNhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibGNhbGJpdGNvaW5zLmluZm9cIixcbiAgICBcImxjYWxiaXRjb2lucy5uZXRcIixcbiAgICBcImxpY2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsa2NhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibGtvY2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsbGNhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9hbGJpdGNvaW5zLmJpZFwiLFxuICAgIFwibG9hbGJpdGNvaW5zLmluZm9cIixcbiAgICBcImxvYWxiaXRjb2lucy5wcm9cIixcbiAgICBcImxvY2FiaXRjb2lucy5iaWRcIixcbiAgICBcImxvY2FiaXRjb2lucy5iaXpcIixcbiAgICBcImxvY2FiaXRjb2lucy5jbHViXCIsXG4gICAgXCJsb2NhYml0Y29pbnMuaW5mb1wiLFxuICAgIFwibG9jYWJpdGNvaW5zLmxvYW5cIixcbiAgICBcImxvY2FiaXRjb2lucy5vcmdcIixcbiAgICBcImxvY2FiaXRjb2lucy5ydVwiLFxuICAgIFwibG9jYWJpdGNvaW5zLnVzXCIsXG4gICAgXCJsb2NhYmxpdGNvaW5zLm5ldFwiLFxuICAgIFwibG9jYWtiaXRjb2lucy5jb21cIixcbiAgICBcImxvY2FrbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiOHRjb2lucy5jb21cIixcbiAgICBcImxvY2FsYmF5dGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiZ2l0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJoaXRjb2lucy5jb21cIixcbiAgICBcImxvY2FsYmk1Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpY29pbnMubWVuXCIsXG4gICAgXCJsb2NhbGJpZGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaWZjb2lucy5jb21cIixcbiAgICBcImxvY2FsYmlmdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaWdjb2lucy5jb21cIixcbiAgICBcImxvY2FsYmlndGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaWl0Y29pbnMubmV0XCIsXG4gICAgXCJsb2NhbGJpanRjb2lucy5jb21cIixcbiAgICBcImxvY2FsYmlyY29pbnMuaW5mb1wiLFxuICAgIFwibG9jYWxiaXJ0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGM5aW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjaWlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y2lucy5iaWRcIixcbiAgICBcImxvY2FsYml0Y2lucy5ydVwiLFxuICAgIFwibG9jYWxiaXRjbzlpbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaWJzLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2lobnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaWlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y29pam5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2lqcy5jb21cIixcbiAgICBcImxvY2FsYml0Y29pa25zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2luLmFjY291bnRhbnRcIixcbiAgICBcImxvY2FsYml0Y29pbi5jbGlja1wiLFxuICAgIFwibG9jYWxiaXRjb2luLmNsdWJcIixcbiAgICBcImxvY2FsYml0Y29pbi5jb20ucnVcIixcbiAgICBcImxvY2FsYml0Y29pbi5kYXRlXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4uZG93bmxvYWRcIixcbiAgICBcImxvY2FsYml0Y29pbi5mYWl0aFwiLFxuICAgIFwibG9jYWxiaXRjb2luLmljdVwiLFxuICAgIFwibG9jYWxiaXRjb2luLm1lXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4ubWVuXCIsXG4gICAgXCJsb2NhbGJpdGNvaW4ubW9iaVwiLFxuICAgIFwibG9jYWxiaXRjb2luLm5ldC5ydVwiLFxuICAgIFwibG9jYWxiaXRjb2luLm9ubGluZVwiLFxuICAgIFwibG9jYWxiaXRjb2luLnN0cmVhbVwiLFxuICAgIFwibG9jYWxiaXRjb2luLnVzXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5hLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2luYS5pbmZvXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5hLnh5elwiLFxuICAgIFwibG9jYWxiaXRjb2luYXMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5kLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2luZC5pbmZvXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5kLm5ldFwiLFxuICAgIFwibG9jYWxiaXRjb2luZC51c1wiLFxuICAgIFwibG9jYWxiaXRjb2luZHMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5lcy5sb2FuXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5lcy5zcGFjZVwiLFxuICAgIFwibG9jYWxiaXRjb2luZXMudXNcIixcbiAgICBcImxvY2FsYml0Y29pbmhzLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2luanMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5tcy5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbm5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5hZ2VuY3lcIixcbiAgICBcImxvY2FsYml0Y29pbnMuYXNpYVwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5iaWRcIixcbiAgICBcImxvY2FsYml0Y29pbnMuY3JpY2tldFwiLFxuICAgIFwibG9jYWxiaXRjb2lucy5kYXRlXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLmZhaXRoXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLmhvc3RcIixcbiAgICBcImxvY2FsYml0Y29pbnMuaG91c2VcIixcbiAgICBcImxvY2FsYml0Y29pbnMubWVuXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLm1vYmlcIixcbiAgICBcImxvY2FsYml0Y29pbnMucGFydHlcIixcbiAgICBcImxvY2FsYml0Y29pbnMucHJlc3NcIixcbiAgICBcImxvY2FsYml0Y29pbnMucHJvXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLnJhY2luZ1wiLFxuICAgIFwibG9jYWxiaXRjb2lucy5yZWRcIixcbiAgICBcImxvY2FsYml0Y29pbnMucmV2aWV3XCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLnJvY2tzXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLnNjaWVuY2VcIixcbiAgICBcImxvY2FsYml0Y29pbnMuc3RvcmVcIixcbiAgICBcImxvY2FsYml0Y29pbnMuc3VcIixcbiAgICBcImxvY2FsYml0Y29pbnMudHJhZGVcIixcbiAgICBcImxvY2FsYml0Y29pbnMud2luXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLndvcmtcIixcbiAgICBcImxvY2FsYml0Y29pbnMueHl6XCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zbC5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbnN0LmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2luc3guY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zei5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbnQudHJhZGVcIixcbiAgICBcImxvY2FsYml0Y29pbnQud2luXCIsXG4gICAgXCJsb2NhbGJpdGNvaW53cy5jb21cIixcbiAgICBcImxvY2FsYml0Y29pbnhzLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2luenMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaXMuYmlkXCIsXG4gICAgXCJsb2NhbGJpdGNvaXMuc3BhY2VcIixcbiAgICBcImxvY2FsYml0Y29pc24uY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvam5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb2tpbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNva25zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb25zLmxvYW5cIixcbiAgICBcImxvY2FsYml0Y29ucy5tZW5cIixcbiAgICBcImxvY2FsYml0Y29ucy50cmFkZVwiLFxuICAgIFwibG9jYWxiaXRjb29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvb25zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjb3BpbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy5pbmZvXCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy5zcGFjZVwiLFxuICAgIFwibG9jYWxiaXRjb3Vucy5jb21cIixcbiAgICBcImxvY2FsYml0Y295bnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNwaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRjdWlucy5jb21cIixcbiAgICBcImxvY2FsYml0Y3ZvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRkb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0Zm9pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdGdjb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0a29pbnMuZGF0ZVwiLFxuICAgIFwibG9jYWxiaXRrb2lucy5pbmZvXCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLm1vYmlcIixcbiAgICBcImxvY2FsYml0a29pbnMubmV0XCIsXG4gICAgXCJsb2NhbGJpdGtvaW5zLm9yZ1wiLFxuICAgIFwibG9jYWxiaXRrb2lucy5zcGFjZVwiLFxuICAgIFwibG9jYWxiaXRvY2lucy5jb21cIixcbiAgICBcImxvY2FsYml0b2NpbnMuaW5mb1wiLFxuICAgIFwibG9jYWxiaXRvY2lucy54eXpcIixcbiAgICBcImxvY2FsYml0b2lucy5uZXRcIixcbiAgICBcImxvY2FsYml0cmNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXRzY29pbi5jb21cIixcbiAgICBcImxvY2FsYml0c2NvaW5zLmRvd25sb2FkXCIsXG4gICAgXCJsb2NhbGJpdHNjb2lucy5uZXRcIixcbiAgICBcImxvY2FsYml0c2NvaW5zLnJ1XCIsXG4gICAgXCJsb2NhbGJpdHNrb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0dGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaXR2Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdHhjb2lucy5jb21cIixcbiAgICBcImxvY2FsYml0eG9pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJpdHljb2lucy5jb21cIixcbiAgICBcImxvY2FsYml5dGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxiaml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJraXRjb2lucy5jb21cIixcbiAgICBcImxvY2FsYmt0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJuaXRjb2lucy5jb21cIixcbiAgICBcImxvY2FsYm9pdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxib3Rjb2lucy5pbmZvXCIsXG4gICAgXCJsb2NhbGJ0Y29pbnMuaW5mb1wiLFxuICAgIFwibG9jYWxidGNvaW5zLmxvYW5cIixcbiAgICBcImxvY2FsYnRjb2lucy50cmFkZVwiLFxuICAgIFwibG9jYWxidGljb2lucy5uZXRcIixcbiAgICBcImxvY2FsYnV0Y29pbnMuYml6XCIsXG4gICAgXCJsb2NhbGJ1dGNvaW5zLmNsdWJcIixcbiAgICBcImxvY2FsYnV0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJ1dGNvaW5zLnJ1XCIsXG4gICAgXCJsb2NhbGJ1dGNvaW5zLnNwYWNlXCIsXG4gICAgXCJsb2NhbGJ1dGNvaW5zLnRvcFwiLFxuICAgIFwibG9jYWxidXRjb2lucy50cmFkZVwiLFxuICAgIFwibG9jYWxidXRjb2lucy51c1wiLFxuICAgIFwibG9jYWxidXRjb2lucy54eXpcIixcbiAgICBcImxvY2FsYnV0a29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGJ5dGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYWxieXRlY29pbnMuY29tXCIsXG4gICAgXCJsb2NhbGhiaXRjb2lucy5jb21cIixcbiAgICBcImxvY2FsaXRjb2lucy5sb2FuXCIsXG4gICAgXCJsb2NhbGl0Y29pbnMucnVcIixcbiAgICBcImxvY2FsaXRjb2lucy50cmFkZVwiLFxuICAgIFwibG9jYWxpdGNvaW5zLndpblwiLFxuICAgIFwibG9jYWxuYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbG5pdGNvaW5zLm9yZ1wiLFxuICAgIFwibG9jYWxuaXRzY29pbnMuY29tXCIsXG4gICAgXCJsb2NhbHBiaXRjb2lucy5jb21cIixcbiAgICBcImxvY2Fsc2JpdGNvaW5zLmxvYW5cIixcbiAgICBcImxvY2Fsc2JpdGtvaW5zLmNvbVwiLFxuICAgIFwibG9jYWx2Yml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhbHZpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYW5iaXRjb2lucy5jb21cIixcbiAgICBcImxvY2FvYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NhcGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jYXFsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2Nhd2xiaXRjb2lucy5jb21cIixcbiAgICBcImxvY2NhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jZGFsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2NlbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jbGFiaXRjb2lucy5jb21cIixcbiAgICBcImxvY2xiaXRjb2lucy5iaWRcIixcbiAgICBcImxvY2xiaXRjb2lucy5ob3N0XCIsXG4gICAgXCJsb2NsYml0Y29pbnMuaW5mb1wiLFxuICAgIFwibG9jbGJpdGNvaW5zLm1lblwiLFxuICAgIFwibG9jbGJpdGNvaW5zLnByZXNzXCIsXG4gICAgXCJsb2NsYml0Y29pbnMucnVcIixcbiAgICBcImxvY2xiaXRjb2lucy5zdHJlYW1cIixcbiAgICBcImxvY2xiaXRjb2lucy53ZWJjYW1cIixcbiAgICBcImxvY2xiaXRzY29pbnMuY29tXCIsXG4gICAgXCJsb2NxYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvY3NsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2N2YWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvY3dhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jd2xiaXRjb2lucy5jb21cIixcbiAgICBcImxvY3hhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9jemFsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2RhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9mY2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2dpbi5sb2NhbGJpdGNvaW5zLmNvbS5sb2NhbGJpdGNvaW5ucy5jb21cIixcbiAgICBcImxva2FsYml0Y29pbnMuYml6XCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLmNvXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLmRvd25sb2FkXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLmxvYW5cIixcbiAgICBcImxva2FsYml0Y29pbnMub3JnXCIsXG4gICAgXCJsb2thbGJpdGNvaW5zLnByb1wiLFxuICAgIFwibG9rYWxiaXRjb2lucy5ydVwiLFxuICAgIFwibG9rYWxiaXRjb2lucy53ZWJzaXRlXCIsXG4gICAgXCJsb2thbGJpdGNvaW50cy5jb21cIixcbiAgICBcImxva2FsYml0c2NvaW4uY29tXCIsXG4gICAgXCJsb2tsYml0Y29pbnMuY29tXCIsXG4gICAgXCJsb2xjYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvb2NhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG9zYWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvdWNhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG92YWxiaXRjb2lucy5jb21cIixcbiAgICBcImxvdmNhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibG94YWxiaXRjb2lucy5jb21cIixcbiAgICBcImxveGNhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibWVyY2Fyb3guY29tXCIsXG4gICAgXCJtZXJyY2F0b3guY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWVuZy5zcGFjZVwiLFxuICAgIFwibXlldGhleXdhbGxldC5jb21cIixcbiAgICBcInBheGZ1bC1yZWNydXRlbWVudC5jb21cIixcbiAgICBcInN0LmxvY2FsYml0Y29pbi5yZXZpZXdcIixcbiAgICBcIndteWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwiYmluYW5jZS1kZXgudG9wXCIsXG4gICAgXCJiaW5hbmNlLmNvbTEyNzg2MjMuY2ZcIixcbiAgICBcImJpbmFuY2UuY29tMTM2MzQ3MTM1Lm1sXCIsXG4gICAgXCJiaW5hbmNlLmNvbTEzNzg2MjMuZ2FcIixcbiAgICBcImJpbmFuY2UuY29tMTYzMjQubWxcIixcbiAgICBcImJpbmFuY2UuY29tOTg3NTc0Lm1sXCIsXG4gICAgXCJjb2luYmFzZW9mZmVyLmNvbVwiLFxuICAgIFwiY29pbmRlc2sub25saW5lXCIsXG4gICAgXCJsZGV4Lmhvc3RcIixcbiAgICBcImxvY2FsYml0Y29pbnMubG9hblwiLFxuICAgIFwibG9wY2FsYml0Y29pbnMuY29tXCIsXG4gICAgXCJtYWlsLndhbGxldC10cmV6b3IuaW9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtZW4uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQubG9naWxuLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5ybG9naW4uY29cIixcbiAgICBcIm15ZXRoZXJ3ZWxldC5jb21cIixcbiAgICBcInBheGZ1bC5jb20udHVidWxrLmdhXCIsXG4gICAgXCJodW9iaWFpcmRyb3AuaW5mb1wiLFxuICAgIFwiaHVvYmlhaXJkcm9wLm9yZ1wiLFxuICAgIFwiaHVvYmlhaXJkcm9wLnRvcFwiLFxuICAgIFwibGNnaW4uY29tXCIsXG4gICAgXCJybG9naW4uY29cIixcbiAgICBcImJsb2NrY2hhaW4ubGNnaWluLmNvbVwiLFxuICAgIFwiYmxvY2tjaGFpbi5sbG9naW4uY29cIixcbiAgICBcImJsY29rY2hhaW4ubGxvZ2luLmNvXCIsXG4gICAgXCJibG9ja2NoYWluLmxvZ2lybi5jb21cIixcbiAgICBcImJsb2NrY2hlaW4ubG9naXJuLmNvbVwiLFxuICAgIFwiYmxvY2tjaGFpbi5sY2dpbi5jb21cIixcbiAgICBcImVtcG93ci5jb21cIixcbiAgICBcImJuYmV0aC5uZXRcIixcbiAgICBcImRleC1ibmIubmV0XCIsXG4gICAgXCJwYXhvcy1ib3VudHkuY29tXCIsXG4gICAgXCJibGFja2ZyaWRheW5lby5ibG9nc3BvdC5jb21cIixcbiAgICBcImJsYWNrZnJpZGF5ZXRjLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYmxhY2tmcmlkYXljcnlwdG8uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJidGMtZ2lmdC5saXZlXCIsXG4gICAgXCJidGMtZ2lmdC51c1wiLFxuICAgIFwiaHVvYmlhaXJkcm9wLm5ldFwiLFxuICAgIFwidGVzbGEtY3J5cHRvLmluZm9cIixcbiAgICBcImJuYi1ldGhjb21wZXRpdGlvbi5jb21cIixcbiAgICBcImV0aC5iaW5hbmNlZ2lmdC5wcm9cIixcbiAgICBcImJpbmFuY2VnaWZ0LnByb1wiLFxuICAgIFwiaWRleC5jb20ucnVcIixcbiAgICBcImliZXguY2NcIixcbiAgICBcInQtYnRjLm5ldFwiLFxuICAgIFwiZXRoZXJkZWx0YS5jb20ucnVcIixcbiAgICBcImJpbmFuY2UtbW14LmNvbVwiLFxuICAgIFwiYmluYW5jZS10eC5jb21cIixcbiAgICBcImJpbmFuY2UteG0uY29tXCIsXG4gICAgXCJiaW5hbmNlLmNvbTc2MjM2NzMyMS5tbFwiLFxuICAgIFwiYmluYW5jZTAuY29tXCIsXG4gICAgXCJiaW5hbmNlODguY29tXCIsXG4gICAgXCJiaXRmZmlubmV4LmNvbVwiLFxuICAgIFwiYml0ZmluZXhsb2dpbi5jb21cIixcbiAgICBcImJpdHRyZXhsLnVrLmwtbHdzLmNvbVwiLFxuICAgIFwiY29pbmJhc2UtY29tLmNsb3VkXCIsXG4gICAgXCJjb2luYmFzZS1jb20uaW5mb1wiLFxuICAgIFwiY29pbmJhc2UtY29tLm9yZ1wiLFxuICAgIFwiY29pbmJhc2UtY29tLnNpdGVcIixcbiAgICBcImNvaW5iYXNlLmZhbnNcIixcbiAgICBcImdpZnRhdXJvcmFkYW8uY29tXCIsXG4gICAgXCJsb2NhbGJpY29pbnMucnVcIixcbiAgICBcImxvY2FsYmlsY29pbnMucnVcIixcbiAgICBcImxvY2FsYml0Y29pbnMubHRkXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLm9yZy5ydVwiLFxuICAgIFwibG9jYWxiaXRjb2luc3YuY29tXCIsXG4gICAgXCJsb2ZhbGJpdGNvaW5zLmNvbVwiLFxuICAgIFwibHVjYWxiaXRjb2lucy5jb21cIixcbiAgICBcIndhbGxldC10cmV6b3IuaW9cIixcbiAgICBcIm1peWV0aGVyd2FsbGV0LnB3XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LW1zZy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC5sbG9naW4uY29cIixcbiAgICBcInBheGZ1bDA2Ny4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwicGF4ZnVsY29pbnMuY29tXCIsXG4gICAgXCJwYXhpaWZ1bC5jb21cIixcbiAgICBcInBvbG9uaWVueC5jb21cIixcbiAgICBcInRva2Vucy10cm9uc2Nhbi5vcmdcIixcbiAgICBcInhuLS1idHRyeC1lc2FyLmNvbVwiLFxuICAgIFwieG4tLWhpdHRjLTNqYi5jb21cIixcbiAgICBcInhuLS1vaW5iYXNlLXR4YS5jb21cIixcbiAgICBcInN0ZWxsYXItdGVybS5zdG9yZVwiLFxuICAgIFwiYmluYW5jZS1naXZlYXdheXMuY29tXCIsXG4gICAgXCJidGMtdmVyaWZpZWQuY29tXCIsXG4gICAgXCJjcnlwdG8tZ2l2ZWF3YXlzLmNvbVwiLFxuICAgIFwiZWxvbi1vZmZpY2lhbC1naXZlYXdheS5jb21cIixcbiAgICBcImVsb24tb2ZmaWNpYWwtcHJvbW8uY29tXCIsXG4gICAgXCJlbG9uLXBhcnR5LmNvbVwiLFxuICAgIFwiZWxvbi1wcmVzZW50cy5jb21cIixcbiAgICBcImVsb24tcHJvbW90aW9uLmNvbVwiLFxuICAgIFwiZWxvbi1zdXJwcmlzZS5jb21cIixcbiAgICBcImV0aGVyZXVtcy1naXZlYXdheS5jb21cIixcbiAgICBcImdhaW5idGMub3JnXCIsXG4gICAgXCJnZXQtYnRjcy1ub3cuY29tXCIsXG4gICAgXCJnZXQtZXRocy1ub3cuY29tXCIsXG4gICAgXCJnaWZ0YnRjLm9yZ1wiLFxuICAgIFwiZ2l2ZWF3YXktb2ZmaWNpYWwub3JnXCIsXG4gICAgXCJncmFiLWJ0Yy5jb21cIixcbiAgICBcImxpbWl0ZWQtcHJvbW8ub3JnXCIsXG4gICAgXCJsaW1pdGVkLXByb21vdGlvbi5jb21cIixcbiAgICBcImxpbWl0ZWQtcHJvbW90aW9uLm9yZ1wiLFxuICAgIFwibXVzay1naXZlcy5jb21cIixcbiAgICBcIm11c2stcHJlc2VudHMuY29tXCIsXG4gICAgXCJtdXNrLXByb21vdGlvbi5jb21cIixcbiAgICBcIm11c2stc3VycHJpc2UuY29tXCIsXG4gICAgXCJ0cmVhdHMtZnJvbS1lbG9uLmJsb2dzcG90LmNvbVwiLFxuICAgIFwib2ZmaWNpYWwtZ2l2ZWF3YXkub3JnXCIsXG4gICAgXCJwcm9tby1vZmZpY2lhbC5jb21cIixcbiAgICBcInByb21vLW9mZmljaWFsLm9yZ1wiLFxuICAgIFwicHJvbW90aW9uLW9mZmljaWFsLmNvbVwiLFxuICAgIFwicHJvbW90aW9uLW9mZmljaWFsLm9yZ1wiLFxuICAgIFwiYmluYW5jZXMucHJvXCIsXG4gICAgXCJiaXR0cmV4Lm1hbmFnZW1lbnRcIixcbiAgICBcImJpdHRyZXgucHJvbW9cIixcbiAgICBcImlkZXhtYXJrZXQuaG9zdFwiLFxuICAgIFwia3Jha2VuLS1sb2dpbi5jb21cIixcbiAgICBcIm1lZXJjYXRveC5jb21cIixcbiAgICBcIm1lcmNhYXRveC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtcGR0dC5ob3N0XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ25jb2luLnRvcC5tZC01Ni53ZWJob3N0Ym94Lm5ldFwiLFxuICAgIFwibXlldGhlcndhbGxldC10b2guaG9zdFwiLFxuICAgIFwib25saW5lLWltYWdlLm1sXCIsXG4gICAgXCJzcGF4ZnVsLmNvbVwiLFxuICAgIFwieG4tLWJpdGZuZXhzLXdrYi5jb21cIixcbiAgICBcInhuLS1waG9kLXhwYTA4aS5jb21cIixcbiAgICBcImRleGFpcmRyb3BldmVudC5jb21cIixcbiAgICBcImV0aC50cm9ubmV0d29yay5wd1wiLFxuICAgIFwiYnRjLnRyb25uZXR3b3JrLnB3XCIsXG4gICAgXCJ0cm9ubmV0d29yay5wd1wiLFxuICAgIFwicG9vbC1uZW8uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJsYmV4bS5jb21cIixcbiAgICBcImxiZXhtYXJuZXQuY29tXCIsXG4gICAgXCJsYmV4bWV0LmNvbVwiLFxuICAgIFwibGRjeG1hbmtldC5jb21cIixcbiAgICBcImJpbmFuY2UtYmV0YS5uZXRcIixcbiAgICBcImJpbmFuY2UuYmVzdC1vcmcubXhcIixcbiAgICBcImJpbmFuY2UuY29tMTY5ODIzNjIzLmdxXCIsXG4gICAgXCJiaW5hbmNlLnNwYWNlXCIsXG4gICAgXCJiaW5hbmNleC5jbHViXCIsXG4gICAgXCJiaW5hbmNleC5vcmdcIixcbiAgICBcImNvaW5iYXNlLXByby5uZXRcIixcbiAgICBcImNvaW5iYXNlLXByby5vcmdcIixcbiAgICBcImNvaW5iYXNlLmdyb3VwXCIsXG4gICAgXCJjb2luYmFzZXN0by5jb21cIixcbiAgICBcImxvY2FiaXRjb2lucy5tb2JpXCIsXG4gICAgXCJsb2NhYml0Y29pbnMucHJvXCIsXG4gICAgXCJsb2NhbGJpY29pbnMubW9iaVwiLFxuICAgIFwibG9jYWxiaWNvaW5zLnByb1wiLFxuICAgIFwibG9jYWxiaXRjb2lzLnByb1wiLFxuICAgIFwibG9jYWxiaXRjb25zLm1vYmlcIixcbiAgICBcImxvY2FsYml0Y29ucy5wcm9cIixcbiAgICBcImxvY2FsYml0Y29vaW5zLnJ1XCIsXG4gICAgXCJsb2NhbGJpdG9pbnMubW9iaVwiLFxuICAgIFwibG9jYWxiaXRvaW5zLnByb1wiLFxuICAgIFwibG9jYWxidGNvaW5zLm1vYmlcIixcbiAgICBcImxvY2FsYnRjb2lucy5wcm9cIixcbiAgICBcImxvY2FsaXRjb2lucy5tb2JpXCIsXG4gICAgXCJsb2NhbGl0Y29pbnMucHJvXCIsXG4gICAgXCJteS1ldGhlcndhbGxldC5vbmxpbmVcIixcbiAgICBcIm15ZXRoZXItd2FsbGV0Lm9ubGluZVwiLFxuICAgIFwibXlldGhlcm1hbGxldC5vbmxpbmVcIixcbiAgICBcIm15ZXRoZXJ3YWlsZXQuY2x1YlwiLFxuICAgIFwibXlldGhlcndhbGxldC1wZHQuaG9zdFwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20ubm9yZXBseS5ncm91cFwiLFxuICAgIFwicm55ZXRoYXJ3YWxsZXQuY29tXCIsXG4gICAgXCJybnlldGhlcndlbGxldC5jb21cIixcbiAgICBcInRyZXpvci1zaG9wLmNvbVwiLFxuICAgIFwidHJlem9yLXN0b3JlLmNvbVwiLFxuICAgIFwieG4tLWFrZW4tZjBhNnEuY29tXCIsXG4gICAgXCJ4bi0tYml0Zm5leC11ZmIuY29tXCIsXG4gICAgXCJ4bi0tY29pbmJhYy14czRjLmNvbVwiLFxuICAgIFwieG4tLWhpYnRjLXM5Yi5jb21cIixcbiAgICBcInhuLS1rYWVuLWgwYTRxLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWx0LWIzYjg3MjlnLmNvbVwiLFxuICAgIFwieG4tLW15dGhlcndsbGV0LWlmZTA5MTZnLmNvbVwiLFxuICAgIFwieG4tLXBob2xkLWVyYi5jb21cIixcbiAgICBcImRleGJuYi5uZXRcIixcbiAgICBcInhuLS1ib2NrY2hhbi04MWE3OGUuY29tXCIsXG4gICAgXCJpY28ua2FyYXRnb2xkLmlvLmJvbnVzLndhbGxldC1jcnlwdG8tbWVtYmVyLmNvbVwiLFxuICAgIFwid2FsbGV0LWNyeXB0by1tZW1iZXIuY29tXCIsXG4gICAgXCJidGMtZ2lmdC5uZXRcIixcbiAgICBcInhmcmVlY3J5cHRvLmJsb2dzcG90LmNvLm56XCIsXG4gICAgXCJ4ZnJlZW5lby5ibG9nc3BvdC5jb21cIixcbiAgICBcImUxY29udGVzdC5ibG9nc3BvdC5jb21cIixcbiAgICBcImRleGJpbmFuY2ViZXRhLm9yZ1wiLFxuICAgIFwiZGNvbnRlc3RkLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZmFzdGNyeXB0b2dpdmVhd2F5LndlYnNpdGVcIixcbiAgICBcImJjcnlwdG9iLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYWNvbnRlc3RhLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZWxvbi5naWZ0XCIsXG4gICAgXCJ4bi0tZGV4LWtsei5tYXJrZXRcIixcbiAgICBcImNvbnRlc3RjLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZ2VuZXJhdG9yLmNmXCIsXG4gICAgXCIweHByb2plY3Qub3JnXCIsXG4gICAgXCJwb2xsdXguYWlcIixcbiAgICBcIndhbGxldC5wb2xsdXguYWlcIixcbiAgICBcImdldC0xMDAwMC1ldGhlcmV1bS5vcmdcIixcbiAgICBcImNyeXB0by1naXZlYXdheS5vcmdcIixcbiAgICBcImJ0Yy1jcnlwdG8ubWVcIixcbiAgICBcImNyeXB0by1yZXR1cm4ub25saW5lXCIsXG4gICAgXCJjcnlwdG8tc2hhcmUub25saW5lXCIsXG4gICAgXCJ0ZXNsYS1naWZ0LmNvbVwiLFxuICAgIFwidGVzbGEtcHJvbW8udG9wXCIsXG4gICAgXCJsZGV4LW1hcmtldC5ob3N0XCIsXG4gICAgXCJ4bi0tYmxvY2Nobi00eWE4dGxzLmNvbVwiLFxuICAgIFwieG4tLW15ZXRlcndhbGlldC1mczRmLmNvbVwiLFxuICAgIFwieG4tLWJsb2NraGFuLXcwYTZkLmNvbVwiLFxuICAgIFwieG4tLWJvY2toYWluLXYwYTA2Zi5jb21cIixcbiAgICBcInhuLS1ib2NrY2hhLWV6YTgxZWxkLmNvbVwiLFxuICAgIFwibG9naW4ueG4tLWJvY2tjaGEtZXphODFlbGQuY29tXCIsXG4gICAgXCJzaGFwZXNoaXRmLmlvXCIsXG4gICAgXCJzaGFwZWhpZnQuaW9cIixcbiAgICBcImNvaW5iYXNlLnhtLWxvZ2luMi5jb21cIixcbiAgICBcImFtLW92LnN0b3JlXCIsXG4gICAgXCJ4bS1sb2dpbjIuY29tXCIsXG4gICAgXCJldGhlcmRlc2suY29cIixcbiAgICBcImltbWlncmF0aW9ucG9pbnQuY28udWtcIixcbiAgICBcImxkY3htYXJrZXQuY29tXCIsXG4gICAgXCJsZGN4bWFya2V0LmluZm9cIixcbiAgICBcImxkZXhtYXJrLmNvbVwiLFxuICAgIFwibGRleG1hcmsuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC1zaW5nLnRvcC5tZC02Ni53ZWJob3N0Ym94Lm5ldFwiLFxuICAgIFwieG4tLWxvY2FsYml0Y29pLWl4OGUuY29tXCIsXG4gICAgXCJ4bi0tcGhvZC0yMWEwN2QuY29tXCIsXG4gICAgXCJiaW5hbmNlLWluYy5jb21cIixcbiAgICBcImJpbmFuY2UuY29tMTg1NjY1LmNmXCIsXG4gICAgXCJiaXRodW1iLmJpelwiLFxuICAgIFwiY29pbmJhc2UudGVhbVwiLFxuICAgIFwiY29pbmdhc2UuY29tXCIsXG4gICAgXCJpZGV4LW1hcmtldC5mdW5cIixcbiAgICBcImlkZXgtbWFya2V0Lmhvc3RcIixcbiAgICBcImxvY2FsYml0Y29pbnMtc2lnbnVwLmNvbVwiLFxuICAgIFwibG9jYWxib3Rjb2lucy5jb21cIixcbiAgICBcIm0zMC1jb2luYmFzZS5jb21cIixcbiAgICBcIm15ZXRoZXJyd2FsbGV0cy5jbHViXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGV0LW04Yi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsdC1rYmIxOWguY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbC1iMjJlcDdhZmEuY29tXCIsXG4gICAgXCJ4bi0tcGhvZC1rcmE1NWIuY29tXCIsXG4gICAgXCJ6enVjLmNvaW5iYXNlei5jb21cIixcbiAgICBcImJpdHRyZXgubGl2ZVwiLFxuICAgIFwiY29pbmJhc2UtZ2l2ZWF3YXkuc2l0ZVwiLFxuICAgIFwibG9jYWxiaWNvaW5zLmluZm9cIixcbiAgICBcImxvY2FsYml0Y29pbnRzLm5ldFwiLFxuICAgIFwibG9jYWxiaXRjb2ludHMucnVcIixcbiAgICBcImxvY2FsZWJpdGNvaW5zLnJ1XCIsXG4gICAgXCJsb2NjYWxiaXRjb2lucy5ydVwiLFxuICAgIFwibXlldGhlcndhbGxldC1tc2dzaWduLnRvcC5tZC04Ni53ZWJob3N0Ym94Lm5ldFwiLFxuICAgIFwibXlldGhpcndhbGV0LmNvbVwiLFxuICAgIFwidXBob2xsZC5jb21cIixcbiAgICBcInhuLS1keC1oN3M2Yy5tYXJrZXRcIixcbiAgICBcInhuLS1pZHgta2p6Lm1hcmtldFwiLFxuICAgIFwieG4tLW15dGhyd2FsZXQteXEzZWMxdi5jb21cIixcbiAgICBcInhuLS1waG9kLTIxYTZ2LmNvbVwiLFxuICAgIFwieG4tLXBob2QtenJhNzNiLmNvbVwiLFxuICAgIFwiY29pbmJhc2Vkb21haW4uY2x1YlwiLFxuICAgIFwiY29pbmJhc2VoZWxwLmNvbVwiLFxuICAgIFwiY29pbmJhc2VzbS5jb21cIixcbiAgICBcIm15ZXRoZXJyd2FsbGV0cy5pY3VcIixcbiAgICBcInhuLS1jb25iYXNlLTh5YS5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsdC1jcmI2Mjc5Zy5jb21cIixcbiAgICBcImJhbmNvci1uZXR3b3JrLmNvbVwiLFxuICAgIFwiYmFuY29yLmx0ZFwiLFxuICAgIFwibGJpdHRyZXguY29tXCIsXG4gICAgXCJteWV0aGVycndhbGxldHMucHdcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtYWRtaW4ueHl6XCIsXG4gICAgXCJwYXhmdWxqLmNvbVwiLFxuICAgIFwieG4tLWRleC0xdGEuZXRoZXJkZXR0YS5jb21cIixcbiAgICBcInhuLS1kZXgtMXRhLm1hcmtldFwiLFxuICAgIFwieG4tLWRleC0xdWIubWFya2V0XCIsXG4gICAgXCJ4bi0tZGV4LTZqYi5tYXJrZXRcIixcbiAgICBcInhuLS1kZXgtaXVhLm1hcmtldFwiLFxuICAgIFwieG4tLWRleC1sdGEubWFya2V0XCIsXG4gICAgXCJ4bi0tZGV4LW9kYi5tYXJrZXRcIixcbiAgICBcImN1dGR1Y3QuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0dC50ZWNoXCIsXG4gICAgXCJteW1vbmVyby5tZVwiLFxuICAgIFwieG4tLWRleC1ma2IubWFya2V0XCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGUtejNiMzJjLmNvbVwiLFxuICAgIFwiYmluYW5jZS1keC5vcmdcIixcbiAgICBcImNvaW5iYXNlLm1hcmtldHNcIixcbiAgICBcImxvY2FsYml0Y29pbnMtNGYuY29tXCIsXG4gICAgXCJsb2NhbGJpdGNvaW5zLmNsb3VkXCIsXG4gICAgXCJteWV0aGVyZXVtLWxvZ2luLmNvbVwiLFxuICAgIFwicm55ZXRoZXJ2d2FsbGV0LmNvbVwiLFxuICAgIFwic3RlYW1iYWxhbmNlLmluZm9cIixcbiAgICBcInhuLS1kZXgtY2x6Lm1hcmtldFwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldC1uOGIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbHQtMHJiNzZiLmNvbVwiLFxuICAgIFwieG4tLW15dGhlcndhbGV0LTE1YjU2MTlnLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsZXQtOGsyZXAxZGNhLmNvbVwiLFxuICAgIFwieG4tLXVwb2xkLXkyYS5jb21cIixcbiAgICBcImFtYXpvbmJhbGFuY2UuY29tXCIsXG4gICAgXCJlbWV5ZXRoZXJ3ZWFsbGV0LmNvbVwiLFxuICAgIFwibGQtaGl0YnRjLmNvbVwiLFxuICAgIFwibG9jYWxiaXJjb2lucy5iaXpcIixcbiAgICBcImxvY2FsYml0Y2lucy5iaXpcIixcbiAgICBcImxvY2FsYml0Y29pbmQuYml6XCIsXG4gICAgXCJsb2NhbGJpdGNvbmlzLnJ1XCIsXG4gICAgXCJsb2NhbGJpdGNvdWlucy5iaXpcIixcbiAgICBcImxvY2FsYml0c2NvaW5zLmJpelwiLFxuICAgIFwibWVldGhlcndhbGxldC53ZWJzaXRlXCIsXG4gICAgXCJtZXRhbWFza2Nvbm5lY3Qub3JnXCIsXG4gICAgXCJtZXlldGhlcndhbGxjdC5jb21cIixcbiAgICBcIm1leXRmZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJtZXl0aGVyd2FsbGV0LmNvXCIsXG4gICAgXCJtZXl0aGVyd2FsbGV0Lm9yZ1wiLFxuICAgIFwibXktZXRoZXJ3YWxsZXRjb3JwLmNvbVwiLFxuICAgIFwibXljcnlwdG9ldGh3YWxsZXQuY29tXCIsXG4gICAgXCJteWN0aGNyd2FsbGV0LmNvbVwiLFxuICAgIFwibXllZXRoZXJ3YWxsZXQuc3BhY2VcIixcbiAgICBcIm15ZWh0ZXJ3YWxsZXQudXNcIixcbiAgICBcIm15ZXJ0aGVyZXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRlcndhbGxldC5pbmZvXCIsXG4gICAgXCJteWV0aGVhd2xsZXQuY29tXCIsXG4gICAgXCJteWV0aGVkd2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRoZWVyd2FsbGV0LnNwYWNlXCIsXG4gICAgXCJteWV0aGVlcndhbGxldC50b3BcIixcbiAgICBcIm15ZXRoZWVyd2FsbGV0LndlYnNpdGVcIixcbiAgICBcIm15ZXRoZWZ3YWxsZXQuaW5mb1wiLFxuICAgIFwibXlldGhlci13YWxsZXRjb3JwLmNvbVwiLFxuICAgIFwibXlldGhlcmF3YWxsZXQuaW5mb1wiLFxuICAgIFwibXlldGhlcmV3YWxsZXQuYml6XCIsXG4gICAgXCJteWV0aGVydHdhbGxldC5vbmxpbmVcIixcbiAgICBcIm15ZXRoZXJ3YWZsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbDExZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsZWwuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGVsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWJsbmFuY2Uuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtYm5iLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNoZWNrcy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1jb2luLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNvaW5oeWRyby50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtY29pbnNzLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1jcHMuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtY3JpcHRvLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWRlYy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1lY3RhLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWh5ZHJvY29pbi50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaHlkcm9nZW4uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaHlkcm9zbWcuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaHlkcm90b2tlbnMuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaWduLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWtlcC5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1rbmQuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQta25wLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWxvZy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1sb2dpbi5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1sb2dpbmNvaW4uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbHZ0LnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LW1wY3guc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbm9icy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1yaXguc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2duLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaGx0LnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdnbi5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdpbi5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdsLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ24uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2lnbmNvaW5zLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ25jb2lucy50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2lnbmh5ZHJvLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ25pbi5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdubC5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdubG9nLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ25tc2cuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2lnbm4uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2lnbnQuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2l0LnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXRpeC5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC10b2tlbi5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC10b2tlbnMuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtd2Fic2lnbi5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC14Y21kLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmJwbGFjZWQubmV0XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5sb2dpbi1zdGF0dXMuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5uZXQucnVcIixcbiAgICBcIm15ZXRoZXJ3ZGxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2VhbGxldHIuY29tXCIsXG4gICAgXCJteWV0aGV3YWxsZXRzLmNvbVwiLFxuICAgIFwibXlldGhpZXJ3YWxpZXQubmV0XCIsXG4gICAgXCJteWV0aGlyZXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRocnN3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHJ3YWxsZXQuaW5mb1wiLFxuICAgIFwibXlldHRoZXJ3YWVsbGV0LmNvbVwiLFxuICAgIFwibXlldHRoZXJ3YWxsZXQud2Vic2l0ZVwiLFxuICAgIFwibXl0aGVyd2FsbGV0Lm5ld3NcIixcbiAgICBcIm15dGhlcndhbGxldC5zaXRlXCIsXG4gICAgXCJteXRoZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJteXlldGhlcndhbGxldC5zcGFjZVwiLFxuICAgIFwicGF4ZnVsLmNvbS5qb2JvcmEubWxcIixcbiAgICBcInByaXZhdGUtbXlldGhlcndhbGxldC5xdWFudGEuaW1cIixcbiAgICBcInJueWV0aGVydndhbGxldC5pbmZvXCIsXG4gICAgXCJ4bi0tYmlubmNlLXlvYy5jb21cIixcbiAgICBcInhuLS1idHJ4LWRwYXAxNmYuY29tXCIsXG4gICAgXCJ4bi0tYnR0ZXgtY3RhODVlLmNvbVwiLFxuICAgIFwieG4tLWh0YnQtM29hMmIuY29tXCIsXG4gICAgXCJ4bi0tbWV0aGVyd2FsZXQtbXM4ZXE0Yi5jb21cIixcbiAgICBcInhuLS1teWV0ZXJ3YWxsZS0zaWM2ODc2Zy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyYWxsZXQtd3Q1Zi5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsdC03MzhldThiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndsbGV0LXE3YTMxZS5jb20uY29tXCIsXG4gICAgXCJ4bi0tbXlldHJ3YWxsZXQtNXFiNzA4N2cuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbHQtMDE5ZWlhLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsZXQtYzdhYzU3aS5jb21cIixcbiAgICBcInhuLS1waG9kLTIxYTQwYS5jb21cIixcbiAgICBcInhuLS1wbG9uaWV4LTkwYS5jb21cIixcbiAgICBcInhuLS1wb2xvZXgtNnZhNTJlLmNvbVwiLFxuICAgIFwieG4tLXBvbG9pZXgtbmtiLmNvbVwiLFxuICAgIFwiYmVubnljaG9waG91c2UuY29tXCIsXG4gICAgXCJ3d3ctaWRleC5tYXJrZXRcIixcbiAgICBcInhuLS1teXRoZXJ3YWxsdC0zcWJpLmNvbVwiLFxuICAgIFwieG4tLXVwaG9kLW43YS5jb21cIixcbiAgICBcImJpbmFuY2UtZGV4LmNsdWJcIixcbiAgICBcImJpbmFuY2UuZWZpbHVtLmRlXCIsXG4gICAgXCJiaW5hbmNlcy5jb21cIixcbiAgICBcImJpdGZpbmV4Lmx0ZFwiLFxuICAgIFwiYml0dHJleC5jb20ucWRnY3guY29tXCIsXG4gICAgXCJiaXR0cmV4aS5iaWRcIixcbiAgICBcImJuYmJpbmFuY2UuY29tXCIsXG4gICAgXCJjb2luYmFzZWFwcC5jb21cIixcbiAgICBcImRleGJpbmFuY2UuY2x1YlwiLFxuICAgIFwiaWRleGkubWFya2V0XCIsXG4gICAgXCJtLXBheGZ1bC5jb21cIixcbiAgICBcIm1haWwubXlldGhlcnJ3YWxpZXQuY29tLmNwLTE5LndlYmhvc3Rib3gubmV0XCIsXG4gICAgXCJteWV0aGVycndhbGlldC5jb20uY3AtMTkud2ViaG9zdGJveC5uZXRcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtYy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1kaXN0cmlidXRpb24uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRzb2x1dGlvbnMuY29tXCIsXG4gICAgXCJwYXhmdWxyZXBvcnQuY29tXCIsXG4gICAgXCJzdG9iaXRodW1iLmNvbVwiLFxuICAgIFwidXBob2xkLmNmXCIsXG4gICAgXCJ4bi0tY29pbnNibmstbnphLmNvbVwiLFxuICAgIFwieG4tLXBheGZsLTR1YS5jb21cIixcbiAgICBcInhuLS1weGZ1bC1ncmEuY29tXCIsXG4gICAgXCJzcGFjZXgudG9cIixcbiAgICBcInhsbS13YWxsZXQuY29tXCIsXG4gICAgXCJnZXRwZXRyb2NvaW4uY29tXCIsXG4gICAgXCJwYXhvc2JvdW50eS5jb21cIixcbiAgICBcImV0b3JvLWV4Y2hhbmdlLmNvbVwiLFxuICAgIFwibXVzay5wbHVzXCIsXG4gICAgXCJzcGFjZXgucGx1c1wiLFxuICAgIFwiZWxvbmdpZnQuc3BhY2VcIixcbiAgICBcIm11c2suZnVuZFwiLFxuICAgIFwiYy1jcnlwdG8ubWVcIixcbiAgICBcInAtY3J5cHRvLnB3XCIsXG4gICAgXCJjLWNyeXB0by5wd1wiLFxuICAgIFwiZWxvbmJ0Yy5tZVwiLFxuICAgIFwicC1jcnlwdG8ubWVcIixcbiAgICBcImVsb25tdXNrLmdpZnRcIixcbiAgICBcImJjcnlwdG8ucHJvXCIsXG4gICAgXCJiY3J5cHRvLnB3XCIsXG4gICAgXCJjb2luYmFzZS5wbHVzXCIsXG4gICAgXCJiY3J5cHRvLmxpdmVcIixcbiAgICBcImVoaXRidGMuY29tLnZpcHRlbXBvYmV0Z2lyaXNpLmNvbVwiLFxuICAgIFwiaGl0LWJsZW50Zi1jb20uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJwYXhmdWwuY29tLmF1dGFyby50a1wiLFxuICAgIFwiYXV0YXJvLnRrXCIsXG4gICAgXCJldGhlcmV1bS1naXZlYXdheS5uZXRcIixcbiAgICBcImJvbnVzLmV0aGVyZXVtLWdpdmVhd2F5Lm5ldFwiLFxuICAgIFwiZ28uZXRoZXJldW0tZ2l2ZWF3YXkubmV0XCIsXG4gICAgXCJlbnRlci5ldGhlcmV1bS1naXZlYXdheS5uZXRcIixcbiAgICBcImpvaW4tZXRoLXByb21vdGlvbi5ldGhlcmV1bS1naXZlYXdheS5uZXRcIixcbiAgICBcInBhcnRpY2lwYXRlLmV0aGVyZXVtLWdpdmVhd2F5Lm5ldFwiLFxuICAgIFwiZXRoZXJkZWx0YS5ydVwiLFxuICAgIFwiZXRoZXJldW1naWZ0aW5nLmNvbVwiLFxuICAgIFwiYml0aHVtYi50b2RheVwiLFxuICAgIFwiY29pbmJhc2Vob3RlbGNhcmQuY29tXCIsXG4gICAgXCJjb2luYmFzZXByb21vLnVzXCIsXG4gICAgXCJjb3guY29tLTYxNTkzNjhkZTM5MjUxZDdhLWxvZ2luLmlkLTEwN3NidGQ5Y2Joc2J0ZDVkODBhMTNjMGRiMWY1NDY3NTdqbnE5ajU3NTQ2NzU3ODI1MDA0MTYua3lsZWxpZXJtYW4uY29tXCIsXG4gICAgXCJldGhlcndhbGxldC5pdFwiLFxuICAgIFwiZXRoZXJ3YWxsZXQuc2hvcFwiLFxuICAgIFwiZXRoZXJ3YWxsZXQud29ybGRcIixcbiAgICBcImV5ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJpeWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwianlldGhlcndhbGxldC5jb21cIixcbiAgICBcImxoaXRsYnRjLmNvbVwiLFxuICAgIFwibHlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm0ueWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldDUuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0YS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRiLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGMuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0ZC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRlLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGYuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Zy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRoLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGkuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0aWUuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0aXAuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0aXkuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0ai5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRrLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldG0uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0bi5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRudHcuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0by5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRwLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHEuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0ci5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRzLmNjXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0cy5jb1wiLFxuICAgIFwibXlldGhlcndhbGxldHMudXNcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR0by5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR1LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHYuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0dy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR3cy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR4LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHkuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0ei5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXUuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV2LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxld3QuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV5LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxleXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV6LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxlenQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGd0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxpdC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsa2V0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxtZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbG10LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxvZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbG90LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxwZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbHJ0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxzZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbHN0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGx1dC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsemV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbG5ldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxvZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2Fsb2xldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxwZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FscGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YW1sZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FtbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YW5sZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FvbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhb2xsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FwbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhcGxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FxbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YXNsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhd2xsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2F6bGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3Y2xsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2VhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3aWFsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndpbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3bGFsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2xhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3cWFsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndxbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3c2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndzbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3dWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd3dhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3d2xsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd3hhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3eWFsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnd5bGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3emFsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnd6bGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ4d2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlc3J3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGV0cndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXdhbGxldC5uZXRcIixcbiAgICBcIm15ZXRoZXdyYWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGV3cndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXpyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlendhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZ2Vyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhncndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoamVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhtcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRobmVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhvcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRocnJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHNlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoc3J3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHVlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRod2FsbGN0LmNvbVwiLFxuICAgIFwibXlldGh3YWxsZXQubmV0XCIsXG4gICAgXCJteWV0aHdhbGxldC51a1wiLFxuICAgIFwibXlldGh3ZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHdyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGh5ZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHplcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoenJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aWVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGpoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0bmVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldG5oZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0dGVycndhbGxldC5jb21cIixcbiAgICBcIm15ZXR0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldHVlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXR1aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldHhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXR5ZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0eWhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXR6aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldWhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXZoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV3dGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXloZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV5dGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXpoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV6dGhlcndhbGxldC5jb21cIixcbiAgICBcIm15Z3RoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWhldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15aXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteW10aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlvdGhlcndhbGxldC5jb21cIixcbiAgICBcIm15cmV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlydGhlcndhbGxldC5jb21cIixcbiAgICBcIm15c2V0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlzdGhlcndhbGxldC5jb21cIixcbiAgICBcIm15dGV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXl1ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteXV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXl3ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteXd0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXl4ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteXlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15emV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXl6dGhlcndhbGxldC5jb21cIixcbiAgICBcIm5ueWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibnlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm95ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJwb2xvbmlleC1sb2dpbi5hY2NvdW50MmZhLWxvZ2luLmNvbVwiLFxuICAgIFwicHJvLWNvaW5iYXNlLm9ubGluZVwiLFxuICAgIFwicHJvbW9iaXR0cmV4LnNpdGVcIixcbiAgICBcInJueWV0aGVyd2FsbGV0LnB3XCIsXG4gICAgXCJycnlldGhlcndhbGxldC5jb21cIixcbiAgICBcInNoYXBlc2hpZnRlci5nclwiLFxuICAgIFwic2lnbi54bi0tbXl0aGVyd2FsZXQtM3FiMTBjLmNvbVwiLFxuICAgIFwidHJlemlyZS5jb21cIixcbiAgICBcInVwaG9sZC5ncVwiLFxuICAgIFwid3dteWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldC1sY2MubmV0XCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbGUtM2JiNjBuLmNvbVwiLFxuICAgIFwieG4tLW15dGhlcndhbGx0LXFwYmkuY29tXCIsXG4gICAgXCJ5ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJ5bWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwiYmluYW5jZS1leGNoYW5nZS5zcGFjZVwiLFxuICAgIFwiYmluYW5jZWtwLmNvbVwiLFxuICAgIFwiY29pbmJlc2VidGMuY29tXCIsXG4gICAgXCJnZXRuYWlqLmFsdGVydmlzdGEub3JnXCIsXG4gICAgXCJtb2JpbGUzNDkwLWNvaW5iYXNlLmNvbVwiLFxuICAgIFwibW9iaWxlMzQ5MC1jb2luYmFzZS5zaXRlXCIsXG4gICAgXCJteWV0aGVybG9naW4uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXRyYWRlLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0bXNnLmNvbVwiLFxuICAgIFwibXlldGh3YXRjaGxldHQuY29tXCIsXG4gICAgXCJwYWZ4dWxjb20uMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcInBhcnhmdWwuY29tXCIsXG4gICAgXCJwcm80LWNvaW5iYXNlLnNwYWNlXCIsXG4gICAgXCJ4bi0ta2FrZW4tNWJiLmNvbVwiLFxuICAgIFwieG4tLWtha2VuLWljYi5jb21cIixcbiAgICBcInhuLS1ibG9rY2hhaW4tbG9naW4tMjBiLmNvbVwiLFxuICAgIFwieG4tLWxvZ2luLWJsb2NrY2hhaS03dWMuY29tXCIsXG4gICAgXCJ4bi0td3d3LWJsb2NrY2hhbi1tOWIuY29tXCIsXG4gICAgXCJ3YWxsZXQucGF4ZnVsYXNzaXN0LmNvbVwiLFxuICAgIFwicGF4ZnVsYXNzaXN0LmNvbVwiLFxuICAgIFwicGF4ZnVsLnczc2Nob29sc29ubGluZS5jb21cIixcbiAgICBcInBheGZ1bC5jb20ubGV2ZXJrLmNmXCIsXG4gICAgXCJsZXZlcmsuY2ZcIixcbiAgICBcImFwcGJpdHRyZXguY29tXCIsXG4gICAgXCJhY2NvdW50LWJpdHRyZXguY29tXCIsXG4gICAgXCJiaXR0cmV4LWVzLmNvbVwiLFxuICAgIFwic2VjdXJpdHktYml0dHJleC5jb21cIixcbiAgICBcImVuLWNvaW5iYXNlLmNvbVwiLFxuICAgIFwiYmQtYml0ZmluZXguY29tXCIsXG4gICAgXCJiaXRmbmlleC5jb21cIixcbiAgICBcImJpdHRyZXgub25saW5lXCIsXG4gICAgXCJjb2luYmFzZXN1cHBvcnRudW1iZXJzLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1iaW5hbmNlLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNoZWNrLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWV0aGVyLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LW1pLnNwYWNlXCIsXG4gICAgXCJwYXgtZnVsLmNvbVwiLFxuICAgIFwicGF4ZnVsMS5jb21cIixcbiAgICBcInNoYXBlc2hpZml0Lm1lXCIsXG4gICAgXCJzaGFwZXNoaWZ0ZWQubmV0XCIsXG4gICAgXCJzdG9iaW5hbmNlLmNvbVwiLFxuICAgIFwieG4tLWlkeC10cmEubWFya2V0XCIsXG4gICAgXCJ4bi0tcmFlbi1rMGFjLmNvbVwiLFxuICAgIFwiYml0dHJleC5uZXQuc2VjdXJpdHktbG9naW4yZmEuY29tXCIsXG4gICAgXCJiaXR0cmV4aS5tZW5cIixcbiAgICBcInBheGZ1bC5jb20uam9pZXJ5LmNmXCIsXG4gICAgXCJoaXRidGMucHJhdGlrdGx5dWtsZW1lLmNvbVwiLFxuICAgIFwieG4tLW1lcmNhb3gtcnJiLmNvbVwiLFxuICAgIFwieG4tLXBobGQtcnFhN2EuY29tXCIsXG4gICAgXCJ4bi0tdXBob2QtZTRhLmNvbVwiLFxuICAgIFwieG4tLXVob2wtYnNhOWguY29tXCIsXG4gICAgXCJ4bi0tdXBob2QtOTVhLmNvbVwiLFxuICAgIFwieG4tLWhvbGQtcHJheS5jb21cIixcbiAgICBcInhuLS1waG9sZC1rZmIuY29tXCIsXG4gICAgXCJ4bi0tcGhvbGQtMHVhLmNvbVwiLFxuICAgIFwiZWxoZXJzY2FuLmhvc3RcIixcbiAgICBcImNsYWltLWV0aGVycy5jb21cIixcbiAgICBcImdpdmV0cnguYmxvZ3Nwb3QuY29tLmF1XCIsXG4gICAgXCJldGhlcmdpZmZjcnlwdG8ud2ViY2luZGFyaW8uY29tXCIsXG4gICAgXCJ6ZW4tc21hcnRnaXZlcy5zcGFjZVwiLFxuICAgIFwid2luLWdpdmUtYXdheS5jbHViXCIsXG4gICAgXCJjb2luYmFzZXByb21vLndlYmNpbmRhcmlvLmNvbVwiLFxuICAgIFwibWVkaXVuLWJsb2ctY29pbmJhc2Vwcm8xLnR1bWJsci5jb21cIixcbiAgICBcImV0aHdhbGxldGJvbnVzLmNvbVwiLFxuICAgIFwiY3J5cHRvbi1leGNoYW5nZS5jb21cIixcbiAgICBcIm9taXNlZ28tbmV0d29yay5pb1wiLFxuICAgIFwiZWFzeS1ldGhlcnMuY29tXCIsXG4gICAgXCJkZXh4bGF1bmNoLmNvbVwiLFxuICAgIFwiYWlyZHJvcC5zeXN0ZW1zXCIsXG4gICAgXCJzaW1iYXRvb2xzLmNvbVwiLFxuICAgIFwibmV4dGJpdGNvaW53YWxsZXQuY29tXCIsXG4gICAgXCJkZW50YWlyZHJvcC5jb21cIixcbiAgICBcImdldC1zbWFydHNlbmQud2Vic2l0ZVwiLFxuICAgIFwiYmlnY29pbmdpZnQuY2x1YlwiLFxuICAgIFwiY3J5cHRvZ2l2ZS5yZi5nZFwiLFxuICAgIFwidmVyaWZ5LnhuLS1teWV0aHJ3bGxldC14dDllM2suY29tXCIsXG4gICAgXCJtdXNrLWNyeXB0b2N1cnJlbmN5LmluZm9cIixcbiAgICBcImRleGNoYWluZXZlbnQuaW5mb1wiLFxuICAgIFwia2FyYXRnb2xkLmlvLmJvbnVzLmF3YXJkLndhbGxldC10b2tlbi1tZW1iZXIuY29tXCIsXG4gICAgXCJ3YWxsZXQtdG9rZW4tbWVtYmVyLmNvbVwiLFxuICAgIFwiY3J5cG9uaXVtLmluZm9cIixcbiAgICBcIm5lb2dpdmUuYmxvZ3Nwb3QuaWVcIixcbiAgICBcInByb21vY3J5cHQuY29tXCIsXG4gICAgXCJnZXQtc21hcnRjb250cmFjdC53ZWJzaXRlXCIsXG4gICAgXCJ0cmFuc2Zlci5nZXRtb3JlLmhvc3RcIixcbiAgICBcImdpdmUtbmVvLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZ2l2ZS1uZW8uYmxvZ3Nwb3Qucm9cIixcbiAgICBcImVsb25naXZlcy50ZWNoXCIsXG4gICAgXCJpb3N0LWFpcmRyb3AuY29tXCIsXG4gICAgXCJiaW4tbGF1bmNoLmNvbVwiLFxuICAgIFwiZ2l2ZWNyeXB0by53ZWJzaXRlXCIsXG4gICAgXCJmcmVlY3J5cHRvLXguYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJiaW5hbmNlLXNoYi5jb21cIixcbiAgICBcImJpbmFuY2UuY2FzaFwiLFxuICAgIFwiYml0YmFuay5ncm91cFwiLFxuICAgIFwiYml0aHVtYnN0by5jb21cIixcbiAgICBcImJpdHRyZXgtbG9naW4ub2ZpY2lhbC1ob21lcGFnZS5jb21cIixcbiAgICBcImJpdHRyZXguY29tLm9maWNpYWwtaG9tZXBhZ2UuY29tXCIsXG4gICAgXCJjb2luYmFzZW1pbmluZy5iaXpcIixcbiAgICBcImNvaW5zYmFuazM2NS5jb21cIixcbiAgICBcImh1b2JpLmxvYW5zXCIsXG4gICAgXCJrcmFrZW4uZ3FcIixcbiAgICBcImtyYWtlbm5pLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1ldGguc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaHlkci5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1pZGFwLnNwYWNlXCIsXG4gICAgXCJwYXhmdWwudHJhZGVcIixcbiAgICBcInBheGZ1bGoudHJhZGVcIixcbiAgICBcInBheGZ1bHJlY3RpZnkuY29tXCIsXG4gICAgXCJwYXhmdWxzZWN1cmV0ZWFtLmNvbVwiLFxuICAgIFwicGF4ZnVsc2VjdXJpdHkuY29tXCIsXG4gICAgXCJwYXhmdWx2YWxpZGF0ZS5jb21cIixcbiAgICBcInBheGZ1bHZlcmlmaWVkLmNvbVwiLFxuICAgIFwicG9sb25pZXgtZnIuY29tXCIsXG4gICAgXCJ4bi0taWV4LXZ5eS5tYXJrZXRcIixcbiAgICBcInhuLS1teWV0aGV3bGxldC0ya2I4N2guY29tXCIsXG4gICAgXCJiaW5hbmNlLmNvbTEyMzU3MjM3ODYuY2ZcIixcbiAgICBcImJpbmFuY2UuY29tMTc2MjM3ODIzNS5jZlwiLFxuICAgIFwiYmluYW5jZS50YXhcIixcbiAgICBcImJpbmFuY2VhbHRjb2luLmNvbVwiLFxuICAgIFwiYml0aHVtYi5jZW50ZXJcIixcbiAgICBcImJpdHRyZXgtcm0uY29tXCIsXG4gICAgXCJid2lkdGhoZXJvcC5oZXJva3VhcHAuY29tXCIsXG4gICAgXCJjb2luYmFzZS5jb21wYW55XCIsXG4gICAgXCJjb2luYmFzZS5nb2xkXCIsXG4gICAgXCJjb2luYmFzZS5pbnN0aXR1dGVcIixcbiAgICBcImNvaW5iYXNlLm1hcmtldFwiLFxuICAgIFwiY29pbmJhc2UubmV0d29ya1wiLFxuICAgIFwiY29pbmJhc2UucGFnZVwiLFxuICAgIFwiY29pbmJhc2UucGl6emFcIixcbiAgICBcImNvaW5iYXNlLnByb3BlcnRpZXNcIixcbiAgICBcImNvaW5iYXNlLnJpcFwiLFxuICAgIFwiY29pbmJhc2Uuc29mdHdhcmVcIixcbiAgICBcImNvaW5iYXNlcHJvbW8uY29tXCIsXG4gICAgXCJjb2luYmFzZXMuZnJcIixcbiAgICBcImZyZWVjb2luYmFzZS5jb21cIixcbiAgICBcImlkZXguc2VydmljZXNcIixcbiAgICBcImtyYWtlbi50b29sc1wiLFxuICAgIFwibWVyY2F0b3gubmV0XCIsXG4gICAgXCJteWV0aGVyZXVybndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJyd2FsbGV0LmljdVwiLFxuICAgIFwibXlldGhlcnVlbXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc3RhcnMuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQudGVhbVwiLFxuICAgIFwibXlldGhpZXJ3YWxsZXQudGVjaFwiLFxuICAgIFwibXlldGhpcndhbGxldC5vbmxpbmVcIixcbiAgICBcInBvbG9uaWV4LXJtLmNvbVwiLFxuICAgIFwicG9sb25pZXhzaWduLmNvbVwiLFxuICAgIFwicG9sb25pZXhzaWdudXAuY29tXCIsXG4gICAgXCJybnlldGhlcnZhbGxldC5jb21cIixcbiAgICBcIndpZGdldHMud3d3LmliZXhvZm1hcmsuY29tXCIsXG4gICAgXCJ4bi0tYmluYW5lLWYxYS5jb21cIixcbiAgICBcInhuLS1idHRyZXh4LWd6YS5jb21cIixcbiAgICBcInhuLS1jb2lueGNoYW5nZS0yYmIuY29tXCIsXG4gICAgXCJ4bi0taHRidC12cGEzbi5jb21cIixcbiAgICBcInhuLS1odGJ0LXZwYTVvLmNvbVwiLFxuICAgIFwieG4tLWxvZ2luLWJsb2NrY2hhbi1va2MuY29tXCIsXG4gICAgXCJ4bi0tbWVyY2FveC1icmIuY29tXCIsXG4gICAgXCJiaW5hbmNlaG9sZGluZy5jb21cIixcbiAgICBcImJpbmFuY2Vob2xkaW5ncy5jb21cIixcbiAgICBcImJpbmFuY2VzZ3AuY29tXCIsXG4gICAgXCJjb2luYmFoaXM4LmNvbVwiLFxuICAgIFwiZXRoZmluZXgubmV0XCIsXG4gICAgXCJpbmRvZGF4LXNkci5jb21cIixcbiAgICBcImlzaWRvcmlhbi1rbm9icy4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwibXlldGhlcnVpbS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbG90LnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbHQubmV0XCIsXG4gICAgXCJteWV0aHJ3bGxldC5jb21cIixcbiAgICBcInBheGZ1bC1jb20uY29tXCIsXG4gICAgXCJwYXhmdWwuaW5rXCIsXG4gICAgXCJ0cnVzdHdhbGxldC5jby51a1wiLFxuICAgIFwiYmluYW5jZS1ldmVudC5jb21cIixcbiAgICBcImJpbmFuY2UtbGFicy5jb21cIixcbiAgICBcImJpbmFuY2UuY29tOTg2MjEzLmdhXCIsXG4gICAgXCJiaW5uYW5jZTI0LmNvbVwiLFxuICAgIFwiYml0dHJleC1sb2dpbi5hY2NvdW50dC1hcHBzLmNvbVwiLFxuICAgIFwiYml0dHJleC5jb20udHJhZGluZ2xlbmRpbmcuY29tXCIsXG4gICAgXCJjb2luYmFzZS5hYS1nZy5jb21cIixcbiAgICBcImV4Y2hhbmdlLWNvaW5kZXNrLmNvbVwiLFxuICAgIFwibW55ZWxoZXJ3YWxsZWwuY29tXCIsXG4gICAgXCJteWV0aGVydWltd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnZ2YWxsZXQudXNcIixcbiAgICBcIm15ZXRoZXJ3YWxpZXQuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtYmluZy5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC1rZW4uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbWUuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbXIuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbXkuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2FtLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNlLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmFpcmRyb3BtZXcuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5zaWduaW4ubWVzc2FnZS5kb2xwaGluZXhwbG9yZXIuc2dcIixcbiAgICBcInNpZ24ueG4tLW15ZXRocndsbGV0LWlmZTM5MTZnLmNvbVwiLFxuICAgIFwid2tyYWtlbi5jb21cIixcbiAgICBcInhuLS1teWV0ZXJ3YWxsdC1jbThlMDJlLmNvbVwiLFxuICAgIFwiYmlpbmFuY2VsYWIuY29tXCIsXG4gICAgXCJiaW5hbmNlLXplbmRlc2suY29tXCIsXG4gICAgXCJiaW5hbmNlLmNvbTE5ODM2NzIzNi5tbFwiLFxuICAgIFwiYmluYW5jbG9naW4uY29tXCIsXG4gICAgXCJiaXRodW1iZXguY29tXCIsXG4gICAgXCJjb2luYmFzZXByb21vY29kZS5jb21cIixcbiAgICBcImNvbTEyMzM0NTY3NzM2Nzg5ODU0Lm1sXCIsXG4gICAgXCJjb20xMjQ0ODc4OTc2NTMyNzQuZ2FcIixcbiAgICBcImNvbTE2NDc5NTYyMzU2NDQ1NjY1NC5tbFwiLFxuICAgIFwiY29tMTg4NTY1MjM1NjU0ODQ2Lm1sXCIsXG4gICAgXCJldGhmaW5peC5jb21cIixcbiAgICBcImh1b29iaS5wcm9cIixcbiAgICBcImliaW5hbmNlLmNvbVwiLFxuICAgIFwiaWRleC5hZ2VuY3lcIixcbiAgICBcImlkZXguY29tcGFueVwiLFxuICAgIFwibG9jYWxldGhlcmV1bS5hcHBcIixcbiAgICBcIm15LWV0aGVyLXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoYXJ3ZWxsYXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvLnVrXCIsXG4gICAgXCJwYXhmdWxsb2dpbi51c1wiLFxuICAgIFwicG9sb25pZXhjaGluYS5jb21cIixcbiAgICBcInJuZWxoZXJ3YWxsZWwuY29tXCIsXG4gICAgXCJybnllbGhlcndhbGxlbC5jb21cIixcbiAgICBcInNpZ24taW4uY29pbmJhc2UuY29tLnB1cmFjb3NtZXRpY2EucHRcIixcbiAgICBcInRyYWRlLWluZG9kYXguY29tXCIsXG4gICAgXCJ3ZWItYmluYW5jZS5jb20ucnVcIixcbiAgICBcInhuLS1iaW5uZS1od2E1ZS5uZXRcIixcbiAgICBcInhuLS1ib2NrY2hhaW4tZ3NiLmNvbVwiLFxuICAgIFwieG4tLWNvaW5leGNoYW5nLXhiYi5jb21cIixcbiAgICBcInhuLS1jb2lueGNoYW5nZS1xYmIuY29tXCIsXG4gICAgXCJ4bi0tZGV4LXVtYS5jb21cIixcbiAgICBcInhuLS1keC1iamFvLm1hcmtldFwiLFxuICAgIFwieG4tLW15ZXRocndsbGV0LXh0OWUzay5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxsaWV0LTRvMmcuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbHQtNzlhZS5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3bGx0LXNtYjM4M2F5cTlrLmNvbVwiLFxuICAgIFwiYmluYW5jZS5jb20xMzg5NzIzNC5ncVwiLFxuICAgIFwiYmluYW5jZXVzYS5jb21cIixcbiAgICBcImNvaW5iYXNlLWV0aC5vcmdcIixcbiAgICBcImhpdGJ0Y3ZpcC5jb21cIixcbiAgICBcImlkZXhqLm1hcmtldFwiLFxuICAgIFwiaW9zLWljbG91ZC51c1wiLFxuICAgIFwicGxvb25pZXguY29tXCIsXG4gICAgXCJ4bi0tYmlpbmFuYy16OGEubmV0XCIsXG4gICAgXCJ4bi0tYmluYWNlLXplYi5uZXRcIixcbiAgICBcInhuLS1iaW5hbmMtbjRhLm5ldFwiLFxuICAgIFwieG4tLWJpbmFuZS0wdWEubmV0XCIsXG4gICAgXCJ4bi0tYm5hbmNlLWJ3YS5uZXRcIixcbiAgICBcInhuLS1teWVoZXJ3YWxsdC1jcmI2Mzc4Zy5jb21cIixcbiAgICBcImlsZGV4LnNwYWNlXCIsXG4gICAgXCIxY29pbmJhc2UuY29tXCIsXG4gICAgXCI4aWRleC5tYXJrZXRcIixcbiAgICBcIjlpZGV4Lm1hcmtldFwiLFxuICAgIFwiYmluYW5jZS1nZXQuZnVuZFwiLFxuICAgIFwiYmluYW5jZS1vZmZpY2lhbC5mdW5kXCIsXG4gICAgXCJiaW5hbmNlLmNvbTE3MjY4OTIzLm1sXCIsXG4gICAgXCJiaW5hbmNlLmNvbTE4OTc2MjMxLmdxXCIsXG4gICAgXCJiaW5hbmNlc3QuY29tXCIsXG4gICAgXCJiaW5hbmVjaXNlY3VyaXR5LWNvbS5jb21cIixcbiAgICBcImJpdGNvaW5zcG9sb25pZXhjaGFuZ2UuY29tXCIsXG4gICAgXCJiaXRmaW5leHZpcC5jb21cIixcbiAgICBcImJpdGh1bWJ2aXAuY29tXCIsXG4gICAgXCJiaXR0cmV4LmNsdWJcIixcbiAgICBcImNvaW5iYXNlLXByby5jb21cIixcbiAgICBcImNvaW5iYXNldmlwLmNvbVwiLFxuICAgIFwiaGl0ZHRjLm9ubGluZVwiLFxuICAgIFwiaGx0YnRjLm9ubGluZVwiLFxuICAgIFwiaWRheC5tYXJrZXRcIixcbiAgICBcImlkZXhhLm1hcmtldFwiLFxuICAgIFwiaWRleGMubWFya2V0XCIsXG4gICAgXCJpZGV4eC5zcGFjZVwiLFxuICAgIFwiaWRleHoubWFya2V0XCIsXG4gICAgXCJraWRleC5tYXJrZXRcIixcbiAgICBcIm1nZXRoZXJ3YWxsYXQuY29tXCIsXG4gICAgXCJteWNyeXB0MC5jb21cIixcbiAgICBcIm15ZXRoYXJ3b2xldC5jb21cIixcbiAgICBcIm15ZXRoZXJtd2FsZXQuY29tXCIsXG4gICAgXCJteWV0aGVydW1hbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1bWF3bGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1bXFhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1bXdhbGtldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1bXdhbGxldHQuY29tXCIsXG4gICAgXCJteWV0aGVydW13YWxsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FsbHQuY29tXCIsXG4gICAgXCJteWV0aGVydW13YWxsdGUuY29tXCIsXG4gICAgXCJteWV0aGVydW13bGxldC5jb21cIixcbiAgICBcIm15ZXRob3J3YWxsbGV0LmNvbVwiLFxuICAgIFwib2lkZXgubWFya2V0XCIsXG4gICAgXCJwb2xvbmlleC5iaWRcIixcbiAgICBcInBvc3QtYmluYW5jZS5jb21cIixcbiAgICBcInVpZGV4Lm1hcmtldFwiLFxuICAgIFwid3d3bGlkZXgubWFya2V0XCIsXG4gICAgXCJ4bi0tYmlubmUtaHdhNWUuY29tXCIsXG4gICAgXCJ4bi0tZGV4LTl0YS5tYXJrZXRcIixcbiAgICBcInhuLS1oaXRidC1seWEuY29tXCIsXG4gICAgXCJ4bi0tbXllaHJ3YWxsZXQtYmI5ZTk5YS5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3bGxldC1pZmUzOTE2Zy5jb21cIixcbiAgICBcImFjY291bnQtbXlldGhlcndhbGxldC5jbHViXCIsXG4gICAgXCJhY2NvdW50LW15ZXRoZXJ3YWxsZXQuaW5mb1wiLFxuICAgIFwiYWNjb3VudC1teWV0aGVyd2FsbGV0Lm9ubGluZVwiLFxuICAgIFwiYWNjdHhjb2luYmFzZS5jb21cIixcbiAgICBcImJpbmFuY2UtYWlyZHJvcHMuY29tXCIsXG4gICAgXCJiaW5hbmNlLmNvbTExMjU0NTkzNDUuY2ZcIixcbiAgICBcImJpbmFuY2VzdG8uY29tXCIsXG4gICAgXCJiaW5hbmNld2Vic2l0ZS5hY2NvdW50YW50XCIsXG4gICAgXCJiaXRmaW5leHN0by5jb21cIixcbiAgICBcImNvaW1iYXNlLm9ubGluZVwiLFxuICAgIFwiY29pbmJhc2UyNDcuY29tXCIsXG4gICAgXCJpZGV4LW1ha2V0LmluZm9cIixcbiAgICBcImlkZXhpLWxvZ2luLmNvbVwiLFxuICAgIFwiaWRleG1hcmtldGpvaW4uY29tXCIsXG4gICAgXCJrcmFrZW4uZW1haWxcIixcbiAgICBcIm11c2ljZXF1aXBtZW50LnNpdGVcIixcbiAgICBcIm15ZXJoZXR3YWxsZXIuY29tXCIsXG4gICAgXCJwb2xvbmlleHdhbGxldC5jb21cIixcbiAgICBcInBvbG9uaXdhbGxldC5jb21cIixcbiAgICBcInJlc3RvcmUtY29pbmJhc2UuY29tXCIsXG4gICAgXCJzaGFwZXNoaWZ0LmNhc2hcIixcbiAgICBcInZlcmlmeXBheGZ1bC5jb21cIixcbiAgICBcInRlc2xhY29pbi5zcGFjZVwiLFxuICAgIFwib2ZmaWNpYWxhaXJkcm9wLnRlY2hcIixcbiAgICBcInRlc2xhY29pbi50dW1ibHIuY29tXCIsXG4gICAgXCJzdXBwb3J0YmluYW5jZS44OTBtLmNvbVwiLFxuICAgIFwiODkwbS5jb21cIixcbiAgICBcImtyYWxrZW4uY29cIixcbiAgICBcImJpbHR0cmV4LmNvXCIsXG4gICAgXCJiaW1hbnJjZS5jb21cIixcbiAgICBcImV4cm5vLmV1XCIsXG4gICAgXCJwb2xyb25laXguY29tXCIsXG4gICAgXCJibG9jbGtjaGFpbi5jb1wiLFxuICAgIFwiaGl0bGJ0Yy5jb1wiLFxuICAgIFwieW9iaXRyLm5ldFwiLFxuICAgIFwieW9iaWx0Lm5ldFwiLFxuICAgIFwieGdpdmV4LmJsb2dzcG90LmNvbVwiLFxuICAgIFwicG9wdWxvdXMubmV0d29ya1wiLFxuICAgIFwiYmlhbmFjZS5vbmxpbmVcIixcbiAgICBcImJsb2NrY2hhaW4tZXhjaGFuZ2Uub25saW5lXCIsXG4gICAgXCJiaXR0ZXJ4Lm9ubGluZVwiLFxuICAgIFwiYmxmdGluZXguY29tXCIsXG4gICAgXCJibHRtaWFuLmNvbVwiLFxuICAgIFwiY3J5cHRub2F0b3IuY29tXCIsXG4gICAgXCJjcnlwdG9wbGEub25saW5lXCIsXG4gICAgXCJleHdvLm9ubGluZVwiLFxuICAgIFwia3Vja2lvbi5jb21cIixcbiAgICBcImxvZ2ludHdpdHRlci5nYVwiLFxuICAgIFwibXlldGhlY3dhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtZml4LnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXJseC5zcGFjZVwiLFxuICAgIFwicG9sbm9pZXguc2l0ZVwiLFxuICAgIFwidHdpdHRlcmdpcmlzLmdxXCIsXG4gICAgXCJ0d2l0dGVybG9ja2VkaW5nLmdhXCIsXG4gICAgXCJ0d2l0dGVybG9naW5zLmdxXCIsXG4gICAgXCJ4bi0tcG9sb2lleC1rcWMuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyZXdhbGxlLTltZS5jb21cIixcbiAgICBcInhuLS1teWV0aHJld2FsZXQtazRiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldC1qNGIuY29tXCIsXG4gICAgXCJ4bi0ta3VvaW4tenJhLmNvbVwiLFxuICAgIFwieG4tLWJpdG1hbi1mOWEuY29tXCIsXG4gICAgXCJkZXhsYXVuY2NoLmNvbVwiLFxuICAgIFwibGluZS1jcnlwdG8uY29tXCIsXG4gICAgXCJldGhlcmRlbHRhLmljdVwiLFxuICAgIFwieHRyb255LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYml0aHVtYnZpZXRuYW0uY29tXCIsXG4gICAgXCJiaXRodW1idmlldG5hbS5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWJvbnVzLmNvLnVrXCIsXG4gICAgXCJjb2luYmFzZWJvbnVzLnRoZWhvc3RydW5uZXIuY28udWtcIixcbiAgICBcImV0aC1iaW5hbmNlLnJ1XCIsXG4gICAgXCJpZGV4LW1hcmtldC5ydVwiLFxuICAgIFwiaWRleG1hcmtldC5ydVwiLFxuICAgIFwibWVyY2F0b3guaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5yZWRcIixcbiAgICBcInhuLS1jb2lueC1xNTFiLmNvbVwiLFxuICAgIFwiYmlpbmFuY2Uub25saW5lXCIsXG4gICAgXCJiaW5hbmNlLWxvZ2luLmNvbVwiLFxuICAgIFwiYmluYXJyY2UuY29tXCIsXG4gICAgXCJteWVsaGVyd29sZXR0LmluZm9cIixcbiAgICBcInBvbG9uaWV4YWR2YW5jZWQuY29tXCIsXG4gICAgXCJwb2xvbmlleGxvZ2luLnRyYWRlXCIsXG4gICAgXCJiaW5hbmNlLXRva2VuLmNvbVwiLFxuICAgIFwiYmluYW5jZS5jb203ODEyNjg2MjM2LnNwYWNlXCIsXG4gICAgXCJiaW5hbmNlLnBhZ2VcIixcbiAgICBcImJpdGx0dHJleC5jb21cIixcbiAgICBcImNvaW5zYmFzZWV4Y2hhbmdlLmNvbVwiLFxuICAgIFwiaGl0YnRsYy5jb21cIixcbiAgICBcImhqanRidGMuY29tXCIsXG4gICAgXCJrcmFrZW4uc2l0ZVwiLFxuICAgIFwia3JhcmNrZW4uY29tXCIsXG4gICAgXCJteWVyaGV0d2FsbGV0LmNvbVwiLFxuICAgIFwicGF4ZnVsbC5jb20ueW9udHNrLnRrXCIsXG4gICAgXCJwb2xvbmlleC5jb20uemFuZGVpLm9ubGluZVwiLFxuICAgIFwicG9sb25uaXguY29tXCIsXG4gICAgXCJwb2xvbm5peC5zaXRlXCIsXG4gICAgXCJwb2xvbmlleC5jb20xMzVpNDc4ODQ3MjU4NDc3Lm1sXCIsXG4gICAgXCJjb20xMzVpNDc4ODQ3MjU4NDc3Lm1sXCIsXG4gICAgXCJtbnlpY3RoZXJ2dmFsbGlldC5jb21cIixcbiAgICBcImRleGNoYWluZXZlbnQuY29tXCIsXG4gICAgXCJteWV0aGVyZXVtd2Fsa2V0LmNvbVwiLFxuICAgIFwiYm5iZGV4Y2hhaW5jb21wZXRpdGlvbi5jb21cIixcbiAgICBcImJuYmRleGNoYWluY29tcGV0aXRpb24uaW5mb1wiLFxuICAgIFwiYm5iZXRoYWlyZHJvcHAuY29tXCIsXG4gICAgXCJkZXhjaGFpbmNhbXBhaWduLmNvbVwiLFxuICAgIFwibW5peWVodGN3YWxsaWN0LmNvbVwiLFxuICAgIFwib2tleGNhbXBhaWduLmluZm9cIixcbiAgICBcIm9rZXhzcGVjaWFsY2FtcGFpZ24uaW5mb1wiLFxuICAgIFwiYm5iY2hhaW5jb21wZXRpdGlvbi5pbmZvXCIsXG4gICAgXCJibmJldGhlcmFpcmRyb3BwLmNvbVwiLFxuICAgIFwiZGV4Y2hhaW5jb21wZXRpdGlvbi5pbmZvXCIsXG4gICAgXCJva2V4c3BlY2lhbGNhbXBhaWduLmNvbVwiLFxuICAgIFwib2tleGNhbXBhaWduLmNvbVwiLFxuICAgIFwiYmluYWNhbXBhaWduLmNvbVwiLFxuICAgIFwiZGV4Y2hhaW5jYW1wYWlnbi5pbmZvXCIsXG4gICAgXCJldGhlcmV1bS1jb3Jwb3JhdGlvbi5vcmdcIixcbiAgICBcIm15dm9sdC5zaXRlXCIsXG4gICAgXCJjb2luZGVzay1sb2dpbi5jb21cIixcbiAgICBcInd3d2NvaW5kZXNrLmNvbVwiLFxuICAgIFwieG4tLWNvbmRlc2stZ3c0Yy5jb21cIixcbiAgICBcImNvaW5iYXNlLWNvZGVwcm9tby5jb21cIixcbiAgICBcImNvaW5iYXNlLWN1c3RvbWVyLXN1cHBvcnQub25saW5lXCIsXG4gICAgXCJjb2luYmFzZS1oZWxwZGVzay5pbmZvXCIsXG4gICAgXCJjb2luYmFzZS1zdXBwb3J0Lm5ldFwiLFxuICAgIFwiY29pbmJhc2VjdXN0b21lcnN1cHBvcnQuaW5mb1wiLFxuICAgIFwiY29pbmJhc2Vlc3VwcG9ydC5jbHViXCIsXG4gICAgXCJjb2luYmFzZWVzdXBwb3J0c2VydmljZXMuY2x1YlwiLFxuICAgIFwiY29pbmJhc2Vsb2dpbi5zdXBwb3J0XCIsXG4gICAgXCJjb2luYmFzZXN1cHBvcnQuY28udWtcIixcbiAgICBcImNvaW5iYXNlc3VwcG9ydC5vbmxpbmVcIixcbiAgICBcImNvaW5iYXNlc3VwcG9ydG51bWJlci5jb21cIixcbiAgICBcImxvY2FsZXRoZXJldW0tYWNjb3VudC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuYnlldGhvc3QxMS5jb21cIixcbiAgICBcImdvb2dsLWFjY2Vzcy5jb21cIixcbiAgICBcImJpbmFuY2UuY29tMTM4NjczNDcubWxcIixcbiAgICBcImNvbTEzODY3MzQ3Lm1sXCIsXG4gICAgXCJjb20xNzM1ODM1LmdxXCIsXG4gICAgXCJiaW5hbmNlLmNvbTE3MzU4MzUuZ3FcIixcbiAgICBcImNvbTU2NDU3Lm1sXCIsXG4gICAgXCJiaW5hbmNlLmNvbTU2NDU3Lm1sXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Lm5vdGV4dGJvb2submV0XCIsXG4gICAgXCJzc2xzZWN1cmUtdmVyaWZ5aWQudGtcIixcbiAgICBcImNvaW5zZW5kZXIudGVjaFwiLFxuICAgIFwid2FsbWFydGxlYWYuY29tXCIsXG4gICAgXCIxZGV4Lm1hcmtldFwiLFxuICAgIFwiYmlyaHVtYi5jb21cIixcbiAgICBcImJpdG1leDEuaW5mb1wiLFxuICAgIFwiYml0dHJleC1pby5jb21cIixcbiAgICBcImJpdHRyZXgtb28uY29tXCIsXG4gICAgXCJjb2luYmFzZS1wcm9tby5jb21cIixcbiAgICBcImNvaW5iYXNlcHJvcHJvbW9zLmNvbVwiLFxuICAgIFwiY29tMTI3ODYzMTI2MzQuc3BhY2VcIixcbiAgICBcImZvcm0tbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcImhpdGJ0YzguY29tXCIsXG4gICAgXCJoaXRzYnRjLmNsdWJcIixcbiAgICBcImxvZ2lubWljcm9zb2Z0ZXhjZWwtb25saW5lLmNvbVwiLFxuICAgIFwibWVyY2F0b3guY2x1YlwiLFxuICAgIFwibXlldGxyZXdhbGxldC5jb21cIixcbiAgICBcInBvbG9uaWV4LXRtLmNvbVwiLFxuICAgIFwicG9sb25pZXgteC5jb21cIixcbiAgICBcIndhbGxldC1ibG9ja2NoaWFuLmluZm9cIixcbiAgICBcIndhbGxldG1vYmlsZS5pb1wiLFxuICAgIFwid2FsbGV0bGl2ZXN5bmNjb25uZWN0LmlvXCIsXG4gICAgXCJ3YWxsZXRjb25uZWN0c2xpdmUuaW9cIixcbiAgICBcInd2dy1iaXR0cmV4LmNvbVwiLFxuICAgIFwieG4tLWJsb2NrY2hhaS1vd2IuY29tXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGluLXIyYS5jb21cIixcbiAgICBcInhuLS1rcmFrZS1kOGEuY29tXCIsXG4gICAgXCJ4bi0ta3JrZW4tdWNjLmNvbVwiLFxuICAgIFwieG4tLW1ldGhlcndsbGV0LWlmZTM0NjVnLmNvbVwiLFxuICAgIFwieG4tLXlldGhlcndsbGV0LXR2OGV4OGIuY29tXCIsXG4gICAgXCJnaWZ0Zm9yZmFucy53ZWJzaXRlXCIsXG4gICAgXCJldGhlcml1bS5vcmcucGF5bWVudC43dDI3LXNydi5zaXRlXCIsXG4gICAgXCI3dDI3LXNydi5zaXRlXCIsXG4gICAgXCJnaXZlYXdleS50dW1ibHIuY29tXCIsXG4gICAgXCJqb2hubWNhZmZlLnR1bWJsci5jb21cIixcbiAgICBcIm1lZGl1bS5jb20uN3QyNy1zcnYuc2l0ZVwiLFxuICAgIFwid2lucGxhdGZvcm0ucHJvXCIsXG4gICAgXCJpY29uLmNhc2hcIixcbiAgICBcInhuLS1kZXgtdW1hLm1hcmtldFwiLFxuICAgIFwicG9sb25uaWV4Lm9ubGluZVwiLFxuICAgIFwicG9sb25uaWV4LnRvcFwiLFxuICAgIFwibmljZWloYXNoLmNvbVwiLFxuICAgIFwibmljZW5oYXNoLnNwYWNlXCIsXG4gICAgXCJiLWNyeXB0by5tZVwiLFxuICAgIFwiYXBleG9uZS5vbmxpbmVcIixcbiAgICBcIm1veWx1Y2hzaGl5cmVtb250LnRvcFwiLFxuICAgIFwicGl6emFvYmFsZGluaWRvc3RhdmthLnNpdGVcIixcbiAgICBcImJpbmFuc2UuY2hcIixcbiAgICBcImJpdHRyZXgtd2ViLmNvbVwiLFxuICAgIFwiYml0dHJleC15ZGQuY29tXCIsXG4gICAgXCJoaXRidGMud2Vic2l0ZVwiLFxuICAgIFwic2NyaXMuY2x1YlwiLFxuICAgIFwiZWxlY3RydW4ub3JnXCIsXG4gICAgXCJ4bi0tbXl0aHdhbGxldC1uN2FjLmNvbVwiLFxuICAgIFwiaGl0bG9lay5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXhibWMuc3BhY2VcIixcbiAgICBcImV0aGl6LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZ2ktdmUuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJlbG9ubXVza2FpcmRyb3AudGVjaFwiLFxuICAgIFwiYmluYW5jZS5jb20xMzY3MzQ3Lm1sXCIsXG4gICAgXCJiaW5hbmNlLmNvbTcxNjIzNzgxLmdhXCIsXG4gICAgXCJiaW5hbmNlLmNvbTc2MjM3ODMxLmdxXCIsXG4gICAgXCJpbmJveC1yZWRpcmVjdC1iaW5hbmNlLmNvbTEzNjczNDcubWxcIixcbiAgICBcImNvbTEzNjczNDcubWxcIixcbiAgICBcImNvbTc2MjM3ODMxLmdxXCIsXG4gICAgXCJjb203MTYyMzc4MS5nYVwiLFxuICAgIFwiYmluYW5jZS5jb20xODk3NjIzLmdhXCIsXG4gICAgXCJiaW5hbmNlLmNvbTc4MTY2MjMuZ3FcIixcbiAgICBcImJpbmFuY2VleGNoYW5nZS51c1wiLFxuICAgIFwiYmluYW5jZXZpZXRuYW0ubmV0XCIsXG4gICAgXCJjb3JzMDEuYmluYW5jZXZpZXcuY29tXCIsXG4gICAgXCJwYXhmdWwuc3VwcG9ydFwiLFxuICAgIFwicHJvbW9iaXR0cmV4LndlYnNpdGVcIixcbiAgICBcInd3di1iaXR0cmV4LmNvbVwiLFxuICAgIFwid3d2LWJpdHRyZXguY29tLmNwLTM0LndlYmhvc3Rib3gubmV0XCIsXG4gICAgXCJ4bi0tYmlpbmFuYy16OGEuY29tXCIsXG4gICAgXCJiaW5hbmNlbG9naW4ub3JnXCIsXG4gICAgXCJpZGV4LmF1cm9yYWRhcHAubWFya2V0XCIsXG4gICAgXCJhdXJvcmFkYXBwLm1hcmtldFwiLFxuICAgIFwicm9hZGdyaWRlcXVpcG1lbnQucHdcIixcbiAgICBcImJpbmFuY2UuY29tMTc4NjIzNi5tbFwiLFxuICAgIFwiYmluYW5jZS5jb20xOTc2MjM0NjIubWxcIixcbiAgICBcImJpbmFuY2VpeC5jb21cIixcbiAgICBcIm1leWV0aGNyd2FsbGV0LmNvbVwiLFxuICAgIFwibWV5ZmhlcndhbGxldC5jb21cIixcbiAgICBcIm1leWZoZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJtZXloZmVyd2VsbGV0LmNvbVwiLFxuICAgIFwibWV5dGhyZXdlbGxldC5jb21cIixcbiAgICBcIm1leXRocm93YWxsZXQuY29tXCIsXG4gICAgXCJteWNodGVydnZhbGxldC5jb21cIixcbiAgICBcIm15Y2h0ZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJzaGFwZXNoaWlmdC54eXpcIixcbiAgICBcInBheGZ1bC5jb20tYml0Y29pbi13YWxsZXQtdHJhZGUtZXNjcm93LnBheGZ1bHNlY3VyZS5jb21cIixcbiAgICBcInBheGZ1bHNlY3VyZS5jb21cIixcbiAgICBcIm1ueWljdGhlcnZhbGxpY3QuY29tXCIsXG4gICAgXCJtbnlpZHRoZXdhbGxpb3QuY29tXCIsXG4gICAgXCJiaW5jaGFpbmNhbXBhaWduLmNvbVwiLFxuICAgIFwiYmluYWNoYWluY29tcGV0aXRpb24uaW5mb1wiLFxuICAgIFwiYmluYWNoYWluY29tcGV0aXRpb24uY29tXCIsXG4gICAgXCJiaW5hY29tcGV0aXRpb24uY29tXCIsXG4gICAgXCJiaW5hY29tcGV0aXRpb24uaW5mb1wiLFxuICAgIFwiZmlyc3RjcnlwdC5pbmZvXCIsXG4gICAgXCJiaW5hbmNlLmNvbTY1MzcyNjEubWxcIixcbiAgICBcImJpbmFuY2UuY29tNzYyMzgxLmNmXCIsXG4gICAgXCJjb203NjIzODEuY2ZcIixcbiAgICBcImNvbTY1MzcyNjEubWxcIixcbiAgICBcImNvbTEzNzM0LnNwYWNlXCIsXG4gICAgXCJ2aXRhbGlrLWNhbXBhaWduLnh5elwiLFxuICAgIFwiZ2V0Z2lmdC50ZWNoXCIsXG4gICAgXCJlbG9uZ2lmdC5jb21cIixcbiAgICBcIm11c2ttYXJzLnRlY2hcIixcbiAgICBcImJpbmFuY2UuY29tMTI3NTQ4MjUubWxcIixcbiAgICBcImJpbmFuY2UuY29tMTI4MjM2Lm1sXCIsXG4gICAgXCJ2aWV0bmFtZXNlLWJpbmFuY2UuY29tXCIsXG4gICAgXCJ2aWV0bmFtLWxvZ2luLWJpbmFuY2UuY29tXCIsXG4gICAgXCJ2aWV0bmFtLWJpbmFuY2UuY29tXCIsXG4gICAgXCJsb2dpbnZpZXQtYmluYW5jZS5jb21cIixcbiAgICBcImJpbmFuY2UtbG9naW4tdm4ub25saW5lXCIsXG4gICAgXCJjb20xMjc1NDgyNS5tbFwiLFxuICAgIFwiY29tMTI3ODYzMTI2MzRcIixcbiAgICBcImNvbTE4NjUyMzYuZ2FcIixcbiAgICBcImNvbTc2MzI3MTIzMS5ncVwiLFxuICAgIFwiY29tMTI4MjM2Lm1sXCIsXG4gICAgXCJjb203MjM3ODEyMzEub25saW5lXCIsXG4gICAgXCJlbG9uLXNoYXJlLmluZm9cIixcbiAgICBcImV0aGVyZXVtLWdpdmVhd2F5LnJ1XCIsXG4gICAgXCJsb2dpbi1ibG5hbmNlLnNwYWNlXCIsXG4gICAgXCJzZW5kLWdpZnQud2Vic2l0ZVwiLFxuICAgIFwiZXRoZXJpdW0ub3JnLnBheW1lbnQuN3QyNC1zcnYuc2l0ZVwiLFxuICAgIFwiN3QyNC1zcnYuc2l0ZVwiLFxuICAgIFwiYWlyZHJvcHMudGVjaG5vbG9neVwiLFxuICAgIFwibXlldGhlcndhbGxldC1jcHQuc3BhY2VcIixcbiAgICBcInRyb24tbmV0d29yay5pbmZvXCIsXG4gICAgXCJlbGVjdHJ1bXdhbGxldC5vcmdcIixcbiAgICBcIm1lZGl1bS5jb20uN3QyMy1zcnYuc2l0ZVwiLFxuICAgIFwiN3QyMy1zcnYuc2l0ZVwiLFxuICAgIFwiZXRoZXJpdW0ub3JnLnBheW1lbnQuN3QyMy1zcnYuc2l0ZVwiLFxuICAgIFwiZmlyZWNyeXB0by5pbmZvXCIsXG4gICAgXCJiaXRiYWtvY2ZmaWNlLnNpdGVcIixcbiAgICBcInNhbnRlY2hzdHJveXdhbGtlci5zaXRlXCIsXG4gICAgXCJhaXJkcm9wLWV2ZW50LmNvbVwiLFxuICAgIFwic2dpdmV4LmJsb2dzcG90LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaGwuc3BhY2VcIixcbiAgICBcImdldC5mYXN0Y3J5cHRvZ2lmdC5jb21cIixcbiAgICBcImZhc3RjcnlwdG9naWZ0LmNvbVwiLFxuICAgIFwicG9sb25pZXguY29tLmFjY291bnQyZmEtbG9naW4uY29tXCIsXG4gICAgXCJhY2NvdW50MmZhLWxvZ2luLmNvbVwiLFxuICAgIFwiYml0dHJleC1sb2dpbi5hY2NvdW50MmZhLWxvZ2luLmNvbVwiLFxuICAgIFwiZy1pdmUuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJjcnlwdG9wcm9tby5qdXN0c2hhcmVkdGhpcy5pbmZvXCIsXG4gICAgXCJidGNnaXZlLmtpc3NyLmNvbVwiLFxuICAgIFwiYmluYW4tY2VoLmNvbVwiLFxuICAgIFwiaWJjZXhvZm1hcmtldC5jb21cIixcbiAgICBcImliZXhvZm1hcmsuY29tXCIsXG4gICAgXCJpY2V4b2ZtYXJrLmNvbVwiLFxuICAgIFwiaWNsZXhtYXJrZXQuY29tXCIsXG4gICAgXCJpY2xleG9mbWFya2V0XCIsXG4gICAgXCJpY2xleG9mbWFya2V0LmNvbVwiLFxuICAgIFwid2lkZ2V0cy5pYmV4b2ZtYXJrLmNvbVwiLFxuICAgIFwid2lnaGZnaGZoLmliZXhvZm1hcmsuY29tXCIsXG4gICAgXCJpZGV4LmF1cm9yYWRhby5tYXJrZXRcIixcbiAgICBcImF1cm9yYWRhby5tYXJrZXRcIixcbiAgICBcImJuYmRlY2VudHJhbGl6ZWRjb21wZXRpdGlvbi5jb21cIixcbiAgICBcImJuYmRlY2VudHJhbGl6ZWRjb21wZXRpdGlvbi5pbmZvXCIsXG4gICAgXCJibmJkZWNlbnRyYWxpemVkZXZlbnQuaW5mb1wiLFxuICAgIFwiYm5iZXRoYWlyZHJvcHAuaW5mb1wiLFxuICAgIFwiYm5iZXRoZXJldW1haXJkcm9wcC5jb21cIixcbiAgICBcImJuYmV0aGVyZXVtYWlyZHJvcHBldmVudC5jb21cIixcbiAgICBcImJvcnRuYXJuY2UuY29tXCIsXG4gICAgXCJjaGVjazEucHdcIixcbiAgICBcImRlY2VudHJhbGl6ZWRzcGVjaWFsZXZlbnQuaW5mb1wiLFxuICAgIFwibW5peWVodGN3YWxsaW90LmNvbVwiLFxuICAgIFwibW55aWN0aGVydmFsbGF0LmNvbVwiLFxuICAgIFwibW55aWN0aGVydnZhbGxldC5jb21cIixcbiAgICBcIm1ueWljdGhlcnZ3dmFsbGN0LmNvbVwiLFxuICAgIFwiZ2V0eW91cmNvaW5zLm9yZ1wiLFxuICAgIFwiYmluYW5jZS1naXZlYXdheS53ZWJjaW5kYXJpby5jb21cIixcbiAgICBcImdpZnQtdG9kYXkud2Vic2l0ZVwiLFxuICAgIFwiY3J5cHRvcHJvbW8ua2lzc3IuY29tXCIsXG4gICAgXCJldGhlcml1bS5vcmcucGF5bWVudC43dDIxLXNydi5zaXRlXCIsXG4gICAgXCI3dDIxLXNydi5zaXRlXCIsXG4gICAgXCJ0b3AtZGVhbHMucHJvXCIsXG4gICAgXCJtZWRpdW0uY29tLjd0MjEtc3J2LnNpdGVcIixcbiAgICBcImRlY2VudHJhbGl6ZWRiaXRjb2luY2FtcGFpZ24uaW5mb1wiLFxuICAgIFwiYml0dHJleGwuaW4udXMuYml4LWwuY29tXCIsXG4gICAgXCJiaXgtbC5jb21cIixcbiAgICBcImJpbmFuY2UuY29tMTgzNjM0NjIubWxcIixcbiAgICBcImJpbmFuY2VidGNzcGVjaWFsLmNvbVwiLFxuICAgIFwiYnJpdm5hcm5jZS5jb21cIixcbiAgICBcImJyb3ZpbmFtY2UuY29tXCIsXG4gICAgXCJicm92bmFybmNlLmNvbVwiLFxuICAgIFwiYnJ0dm5hcm5jZS5jb21cIixcbiAgICBcImNwYW5lbC5iaXR0cmV4MS5jb21cIixcbiAgICBcImRlY2VudHJhbGl6ZWRzcGVjaWFsY2FtcGFpZ24uY29tXCIsXG4gICAgXCJkZWNlbnRyYWxpemVkc3BlY2lhbGV2ZW50LmNvbVwiLFxuICAgIFwiaGl0YnRjLmNvbS5jb1wiLFxuICAgIFwibWlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZWl0aGVyd2FsbGV0dC5jb21cIixcbiAgICBcIm15ZW5jcnlwdHdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGV3YWxsZXJ0LmNvbVwiLFxuICAgIFwic2hhcGVzaGlmdC5iaXpcIixcbiAgICBcImJqdHRyZXguY29tXCIsXG4gICAgXCJpZC1leC5tYXJrZXRcIixcbiAgICBcImlpZGV4LW1hcmtldC5ldVwiLFxuICAgIFwibXlldGhlcndhbGxldC5iaXpcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuYXV0aC5zbGdubXNnLmluZm9cIixcbiAgICBcInNsZ25tc2cuaW5mb1wiLFxuICAgIFwic3BlY3Ryb2NvaW5sb2ctaW4uY29tXCIsXG4gICAgXCJnaWZ0ZXRobm93LndlYnNpdGVcIixcbiAgICBcImV0aGVyaXVtLm9yZy5wYXltZW50Ljd0MjAtc3J2LnNpdGVcIixcbiAgICBcIjd0MjAtc3J2LnNpdGVcIixcbiAgICBcIngtZ2l2ZXMuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJldGhnaXZlLmtpc3NyLmNvbVwiLFxuICAgIFwiaWNvLW5lb24uZXhjaGFuZ2VcIixcbiAgICBcIm15ZXRoZXJhaXJkcm9wLmNvbVwiLFxuICAgIFwibXlldG5lcndhbGxldC5jb20uc2VuZC1zdGF0dXMuaW5mb1wiLFxuICAgIFwic2VuZC1zdGF0dXMuaW5mb1wiLFxuICAgIFwicGF4ZnVsLmNvbS5wbFwiLFxuICAgIFwibXlldGhlcndhbGxldC1pZC5zcGFjZVwiLFxuICAgIFwiZXRoLWRhdGFiYXNlY29udHJhY3Qud2Vic2l0ZVwiLFxuICAgIFwiZ2V0ZW9zLmV1XCIsXG4gICAgXCJiaW5hbmNlLWNhbXBhaWduLmluZm9cIixcbiAgICBcImJpbmFuY2UtY2FtcGFpZ24uc2l0ZVwiLFxuICAgIFwiYmluYW5jZS1leGNoYW5nZS5jcmlja2V0XCIsXG4gICAgXCJiaW5hbmNlLWV4Y2hhbmdlLmZ1blwiLFxuICAgIFwiYmluYW5jZS1odHRwcy5jb21cIixcbiAgICBcImJpbmFuY2UuY29tLWxvZy1pbi5nb29nbC1hY2Nlc3MuY29tXCIsXG4gICAgXCJiaXR0cmV4LWxvZy1pbi5jb21cIixcbiAgICBcImJpdHRyZXgtbG9naW4uYXNzZXQyZmEtZXhjaGFuZ2UuY29tXCIsXG4gICAgXCJiaXR0cmV4LmFzc2V0MmZhLWV4Y2hhbmdlLmNvbVwiLFxuICAgIFwiYml0dHJleC5jb20uYXNzZXQyZmEtZXhjaGFuZ2UuY29tXCIsXG4gICAgXCJjb25pZGFzZS5jb21cIixcbiAgICBcIm1qZXRoZXJ3YXR0ZXQuY29tXCIsXG4gICAgXCJ1cy5iaXR0cmV4LmFzc2V0MmZhLWV4Y2hhbmdlLmNvbVwiLFxuICAgIFwidXMuYml0dHJleC5jb20uYXNzZXQyZmEtZXhjaGFuZ2UuY29tXCIsXG4gICAgXCIzZGF5cHJvZml0cy5pbmZvXCIsXG4gICAgXCJldGhlcml1bS5vcmcucGF5bWVudC43ZDE5LXNydi5zaXRlXCIsXG4gICAgXCI3ZDE5LXNydi5zaXRlXCIsXG4gICAgXCJhdG1idGMuYml6XCIsXG4gICAgXCJiZXN0LWdpZnQud2Vic2l0ZVwiLFxuICAgIFwiYWlyZHJvcC5jb20uZGVcIixcbiAgICBcInZpdGFsaWtwcm9tby5ldVwiLFxuICAgIFwibWVkaXVtLmJ5ZXRob3N0MTAuY29tXCIsXG4gICAgXCJtZWRpdW0uY29tLjdkMTktc3J2LnNpdGVcIixcbiAgICBcInByb21vMi5ldGhlcmJvbnVzLnRvcFwiLFxuICAgIFwiZXRoZXJib251cy50b3BcIixcbiAgICBcInhuLS1oaWJ0Yy1sZWIuY29tXCIsXG4gICAgXCJoaXRidGMtZXUuY29tXCIsXG4gICAgXCJoaXRidGMuY2FtXCIsXG4gICAgXCJnZXQtNWstcHJvbW8ud2Vic2l0ZVwiLFxuICAgIFwiZnJlc2hib251cy5ldVwiLFxuICAgIFwiZS1naXZlcy5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGVyaXVtLm9yZy5wYXltZW50LjdkMTgtc3J2LnNpdGVcIixcbiAgICBcIjdkMTgtc3J2LnNpdGVcIixcbiAgICBcImFpcmRyb3BzLmxpZmVcIixcbiAgICBcImJpbmFuY2UtY29tLWNsdWQud2ViY2luZGFyaW8uY29tXCIsXG4gICAgXCJnbzcuZ2lmdGV0aGVyLnRvcFwiLFxuICAgIFwiaGl0YnRjLmxpXCIsXG4gICAgXCJ4bi0tc3BlY3Ryb2Nvbm4tN3piLmNvbVwiLFxuICAgIFwicGF4ZnVsbHdhbGxldC5jb21cIixcbiAgICBcInVzZXIucGF4ZnVscG9saWN5LmNvbVwiLFxuICAgIFwicGF4ZnVscG9saWN5LmNvbVwiLFxuICAgIFwicGF4ZnVsLmNvbS5iYWx1bXMuZ3FcIixcbiAgICBcImZvcmtkZWlsdGEuYXBwXCIsXG4gICAgXCJ4bi0tZGV4LXR0YS5tYXJrZXRcIixcbiAgICBcInZlcmlmeS54bi0tbXl0aGVyd2FsZXQtM3FiMTBjLmNvbVwiLFxuICAgIFwiZ2V0ZnJlZWV0aGhoLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZ2V0ZnJlZWJpdGNvaW4ubmV0d29ya1wiLFxuICAgIFwiY29pbmFjdGlvbi54eXpcIixcbiAgICBcImNyeXB0b3hmYW4uaW5mb1wiLFxuICAgIFwiZ282LmdpZnRldGhlci50b3BcIixcbiAgICBcImJpbmFuY2UtZ2l2ZWF3YXlwcm9tby5iYW5hbmNlLnh5elwiLFxuICAgIFwiYmFuYW5jZS54eXpcIixcbiAgICBcIm1lZ2EtYWlyZHJvcC53ZWJzaXRlXCIsXG4gICAgXCJqb2lubm93LmluZm9cIixcbiAgICBcImJpbmFuY2UtY2FtcGFpZ24uY29tXCIsXG4gICAgXCJiaW5hbmNlLWV0aC5jbHViXCIsXG4gICAgXCJiaW5hbmNlZXRoLWNhbXBhaWduLmNvbVwiLFxuICAgIFwiYmluYW5jZWV0aC1jb21wZXRpdGlvbi5jb21cIixcbiAgICBcImJpbmFuY2VldGhlcmdpdmVhd2F5LmNvbVwiLFxuICAgIFwiYmluYW5jby5saXZlXCIsXG4gICAgXCJldGhlcnZ2YWxsZXQuY29tXCIsXG4gICAgXCJteWN0aGVyd2FsbGV0Lm5ldFwiLFxuICAgIFwiZ281LmdpZnRldGhlci50b3BcIixcbiAgICBcImV0aGVyaXVtLm9yZy5wYXltZW50LjdkMTctc3J2LnNpdGVcIixcbiAgICBcIjdkMTctc3J2LnNpdGVcIixcbiAgICBcImJpZ2JvbnVzLmV1XCIsXG4gICAgXCJtZWRpdW0uY29tLjdkMTctc3J2LnNpdGVcIixcbiAgICBcImdldG5vd2NyeXB0by5jb21cIixcbiAgICBcImJpdHRjcmV4LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1rbnQuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQta25jLnNwYWNlXCIsXG4gICAgXCJldGhlcmRlbHRhLnByZXNzXCIsXG4gICAgXCJ4bi0tcGF4ZmwtbnZhLmNvbVwiLFxuICAgIFwiZ29vZGFjdGlvbi5ldVwiLFxuICAgIFwiY29pbnByb21vLnh5elwiLFxuICAgIFwic2VwdGVtYmVyLWJvbnVzLnVzXCIsXG4gICAgXCJnZXRib251cy5ldVwiLFxuICAgIFwiYWlyZHJvcC1naWZ0LndlYnNpdGVcIixcbiAgICBcIm11c2tvbmxpbmUudGVjaFwiLFxuICAgIFwiY3J5cHRvZ2l2bmcuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJ0b2RheS1ldGgucHdcIixcbiAgICBcImJpbmFuY2UtYm9udXMuY2x1YlwiLFxuICAgIFwiYmluYW5jZS1ib251cy5uZXRcIixcbiAgICBcImJpbmFuY2UtcHJvbW8ub3JnXCIsXG4gICAgXCJiaW5hbmNlLXQuY29tXCIsXG4gICAgXCJiaW5hbmNlZXRoZXJldW1haXJkcm9wcGV2ZW50LmluZm9cIixcbiAgICBcImJpbmFuY2Vwcm9tb3MubGl2ZVwiLFxuICAgIFwiYmxvY2tjaGFpbi1zZWN1cmUuaW5mb1wiLFxuICAgIFwiYm9udXNiaW5hbmNlLm9yZ1wiLFxuICAgIFwiaS1kZXgubWFya2V0XCIsXG4gICAgXCJpZGV4LXJuYXJrZXQuaW5mb1wiLFxuICAgIFwiaWRleC5tYXJrZWwudHJhbnNhY3Rpb25zLXdhbGxldC5pbmZvXCIsXG4gICAgXCJteWV0bGhlcndhbGxlbHQuY29tXCIsXG4gICAgXCJteW1hbmVyby5jb21cIixcbiAgICBcImdyYW1uZXR3b3JrLm5ldFwiLFxuICAgIFwidG9wY3J5cHRvZ2lmdC5vcmdcIixcbiAgICBcInBheWV0aGVyZXIyMC4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwidmdncy5pbmZvXCIsXG4gICAgXCJnbzQuZ2lmdGV0aGVyLnRvcFwiLFxuICAgIFwiZXRoZXJpdW0ub3JnLnBheW1lbnQuN2QxNi1zcnYuc2l0ZVwiLFxuICAgIFwicGF5bWVudC43ZDE2LXNydi5zaXRlXCIsXG4gICAgXCJnaXZpbmdzYXdheS5ibG9nc3BvdC5jb21cIixcbiAgICBcIm1zZy54bi0tbXl0aGVyd2FsZXQtM3FiMTBjLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5hdXRoLnNnbm1zZy5jb21cIixcbiAgICBcInNnbm1zZy5jb21cIixcbiAgICBcImhpdGJ0Y3NwYWNlLmhlcm9rdWFwcC5jb21cIixcbiAgICBcIjJmYS1wYXhmdWwuY29tXCIsXG4gICAgXCJlaGVycHJvLnR1bWJsci5jb21cIixcbiAgICBcInNtYXJ0LWdpZnQud2Vic2l0ZVwiLFxuICAgIFwiY29pbnNoYXJlLnh5elwiLFxuICAgIFwiYnV0ZXJpbnRvZGF5LmV1XCIsXG4gICAgXCJ0cm9uaWNzLnRlY2hcIixcbiAgICBcImdpdmVhd2F5LW1lZGl1bS50b3BcIixcbiAgICBcInRlc2xhLWdpdmVhd2F5LmxpdmVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQta25iLnNwYWNlXCIsXG4gICAgXCJ3YWxsZXRzLWNyeXB0by1icmlkZ2Uub3JnXCIsXG4gICAgXCJjb2luYmFzZWJsb2dpdmVhd2F5aGcudHVtYmxyLmNvbVwiLFxuICAgIFwiYmluYW5jZS1ldGhwcm9tby5vcmdcIixcbiAgICBcImJpbmFuY2UuZmFpbFwiLFxuICAgIFwiYmluYW5jZXZhdWx0LmNvbVwiLFxuICAgIFwiZ2V0LWJ0Yy1iaW5hbmNlLmNvbVwiLFxuICAgIFwiZ2V0LWV0aC1iaW5hbmNlLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWduLmZ1blwiLFxuICAgIFwidGVhbW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJ4bi0tZGV4LXltYS5tYXJrZXRcIixcbiAgICBcInRyeGdvbGQuaW9cIixcbiAgICBcInNpZ25hdHVyZS54bi0tbXl0aGVyd2FsZXQtM3FiMTBjLmNvbVwiLFxuICAgIFwiYmxvY2tjaGlhbi1sb2dpbi5pbmZvXCIsXG4gICAgXCJsb2dpbi1ibG9rY2hhaW4uY29tXCIsXG4gICAgXCJsb2dpbi1ibG9ja2NoaWFuLm5ldFwiLFxuICAgIFwiYmxvY2tjaGlhbi13YWxsZXRzLmNvbVwiLFxuICAgIFwiYmxvY2tjaGlhbi5jYVwiLFxuICAgIFwiYmxvY2tjaGlhbi13YWxsZXQuY29tXCIsXG4gICAgXCJibG9ja2NoaWFuLWxvZ2luLmNvbVwiLFxuICAgIFwiaWRleC1tYXJrZXQucHJvXCIsXG4gICAgXCJiaWJveXguY29tXCIsXG4gICAgXCJibmItZXRoY2FtcGFpZ24uY29tXCIsXG4gICAgXCJjcnlwdG9idGMuY2x1YlwiLFxuICAgIFwicGVybGluLmdsb2JhbFwiLFxuICAgIFwidGVzbGEtZ2l2ZWF3YXlzLnNwYWNlXCIsXG4gICAgXCJ0b3AtZXRoZXJldW0uaW5mb1wiLFxuICAgIFwibW5heHkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJnbzMuZ2lmdGV0aGVyLnRvcFwiLFxuICAgIFwiZXRoZXJpdW0ub3JnLnBheW1lbnQucHJvbW9hY3Rpb24uc2l0ZVwiLFxuICAgIFwicHJvbW9hY3Rpb24uc2l0ZVwiLFxuICAgIFwiYWlyZHJvcGJ0Yy50ZWNoXCIsXG4gICAgXCJzZWN1cmUudG9wY29pbnNnaWZ0LmNvbVwiLFxuICAgIFwidG9wY29pbnNnaWZ0LmNvbVwiLFxuICAgIFwibXVzay1jcnlwdG8uaW5mb1wiLFxuICAgIFwiNWstZ2lmdC53ZWJzaXRlXCIsXG4gICAgXCJwbGF0Zm9ybS1naXZlLmNvbVwiLFxuICAgIFwiZXRoZ2l2ZWF3YXkuY28udWtcIixcbiAgICBcImJpLW5hbmNlci5jb21cIixcbiAgICBcImJpbmFuY2UtZXRoLWNvbXBldGl0aW9uLmNvbVwiLFxuICAgIFwiYmluYW5jZS1ldGhlci5jbHViXCIsXG4gICAgXCJiaW5hbmNlLWV0aGVyZXVtLmNvbVwiLFxuICAgIFwiYmluYW5jZS1ldGhlcmV1bS5pbmZvXCIsXG4gICAgXCJiaW5hbmNlLWV0aGVyZXVtLnRlY2hcIixcbiAgICBcImJpbmFuY2UtZXRoZXZlbnQubmV0XCIsXG4gICAgXCJiaW5hbmNlLWV0aGV2ZW50Lm9yZ1wiLFxuICAgIFwiYmluYW5jZS14LmNsdWJcIixcbiAgICBcImJpbmFuY2Vib251cy5uZXRcIixcbiAgICBcImJpbmFuY2Vib251cy5vcmdcIixcbiAgICBcImJpbmFuY2VldGguY2x1YlwiLFxuICAgIFwiYmluYW5jZWV0aGNvbXBldGl0aW9uLmNvbVwiLFxuICAgIFwiYmluYW5jZWV0aGVyLmNsdWJcIixcbiAgICBcImJpbmFuY2VldGhlcmV1bS5jbHViXCIsXG4gICAgXCJiaW5hbmNlcHJvbW8uY2x1YlwiLFxuICAgIFwiYmluYW5jZXNwZWNpYWxjb21wZXRpdGlvbi5jb21cIixcbiAgICBcImJpbmFuY2VzcGVjaWFsZXRoY29tcGV0aXRpb24uY29tXCIsXG4gICAgXCJiaW5hbmNldGguY2x1YlwiLFxuICAgIFwiYmluYW5jZXRoZXIuY2x1YlwiLFxuICAgIFwiYmluYW5jZXRoZXJldW0uY2x1YlwiLFxuICAgIFwiZXRoLWJpbmFuY2UuY2x1YlwiLFxuICAgIFwiZXRoYmluYW5jZS5jbHViXCIsXG4gICAgXCJldGhjb21wZXRpdGlvbmJpbmFuY2UuY29tXCIsXG4gICAgXCJldGhlci1iaW5hbmNlLmNsdWJcIixcbiAgICBcImV0aGVyYmluYW5jZS5jbHViXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5pcDEzLmljdVwiLFxuICAgIFwibXlldGhlcndlbGV0Lm5ldFwiLFxuICAgIFwibXlldGhlcndvbGxsZXQuY29tXCIsXG4gICAgXCJteWV0aHN3YWxsZXQuY2x1YlwiLFxuICAgIFwic3Vwb3J0YmluYW5jZS5jb21cIixcbiAgICBcInRva2Vucy5teWV0aGVyd2FpbGV0LmNmXCIsXG4gICAgXCJtZWRpdW0tY29pbmJhc2VibG9nLnR1bWJsci5jb21cIixcbiAgICBcInNhZmUuZ2V0ZWFzeWNyeXB0by5jb21cIixcbiAgICBcImdldGVhc3ljcnlwdG8uY29tXCIsXG4gICAgXCJsaXhvenkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJlbG9uY3J5cHRvLmluZm9cIixcbiAgICBcIm1lZGl1bWNvaW5iYXNlLnR1bWJsci5jb21cIixcbiAgICBcImNyeXB0b2V0aC5saXZlXCIsXG4gICAgXCJjcnlwdG8td2luLmNsdWJcIixcbiAgICBcImNyeXB0by1tZWRpdW0uY29tXCIsXG4gICAgXCJnZXRhaXJkcm9wLmV1XCIsXG4gICAgXCJzZW5kaW5nLXNtYXJ0Y29udHJhY3Qud2Vic2l0ZVwiLFxuICAgIFwiaWRleC1tYXJrZXQuZXhjaGFuZ2VcIixcbiAgICBcInByb3RlY3QubWluZWRjb2lucy5vbmxpbmVcIixcbiAgICBcIm1pbmVkY29pbnMub25saW5lXCIsXG4gICAgXCJnbzIuZ2lmdGV0aGVyLnRvcFwiLFxuICAgIFwiY29udHJhY3QtdmVyaWZ5LnNwYWNlXCIsXG4gICAgXCJjcnlwdG9naWZ0LmNuXCIsXG4gICAgXCJldGhlcmdpZnRzLnRvcFwiLFxuICAgIFwibWVkaXVtLWdpZnRzLnRvcFwiLFxuICAgIFwiZ2V0Lm9mZmljaWFsY3J5cHRvZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJvZmZpY2lhbGNyeXB0b2dpdmVhd2F5LmNvbVwiLFxuICAgIFwiY3ZpZmV4LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tbHRkLm5ldFwiLFxuICAgIFwiZ2l2ZWF3YXkuZXRoZXItcHJpemUuY29tXCIsXG4gICAgXCJ0aXRhbi1nLnByb1wiLFxuICAgIFwiY29pbmJhc2VibG9naXZlYXdheW5ld3MudHVtYmxyLmNvbVwiLFxuICAgIFwiZXRoLWdpZnQud2l4c2l0ZS5jb21cIixcbiAgICBcImJ0Yy1naWZ0LndpeHNpdGUuY29tXCIsXG4gICAgXCJycG1zb24tZXRoY2FtcGFpZ24uY29tXCIsXG4gICAgXCI0NDRldGgubWxcIixcbiAgICBcImdpdmUtdGguYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJhcHBsZXgxLmNvbVwiLFxuICAgIFwicmlrbGV4LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRocHJvbW8ueHl6XCIsXG4gICAgXCJiaXRibGVuZGVyLm1lXCIsXG4gICAgXCJzYWZlLnBheW5vd2NvaW5zLmNvbVwiLFxuICAgIFwicGF5bm93Y29pbnMuY29tXCIsXG4gICAgXCJnbzEuZ2lmdGV0aGVyLnRvcFwiLFxuICAgIFwiZW5qb3kudG9wY3J5cHRvZ2lmdC5jb21cIixcbiAgICBcInRvcGNyeXB0b2dpZnQuY29tXCIsXG4gICAgXCJiaWdkcm9wLmNuXCIsXG4gICAgXCJzZWtha3V4LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiNGV2ZXIuZnVuXCIsXG4gICAgXCJ0aGV0cmV5Lm5ldFwiLFxuICAgIFwibXllY2xpZW50c2lkZXdhbGxldC5jb21cIixcbiAgICBcImJuYmV0aGVyY29tcGV0aXRpb25sYXVuY2guY29tXCIsXG4gICAgXCJldGhlcmV1bS1jb3Jwb3JhdGlvbi5jb21cIixcbiAgICBcImJpbmFuLWNlLmNvbVwiLFxuICAgIFwiYmluYW5jZS5zZWN1cml0eVwiLFxuICAgIFwiYmlub2FuY2UuY29tXCIsXG4gICAgXCJldGhlcmV1bS1iaW5hbmNlLmNsdWJcIixcbiAgICBcImV0aGV2ZW50YmluYW5jZS5vcmdcIixcbiAgICBcImlkZXguY2VudGVyXCIsXG4gICAgXCJtbXlldGhlcmV1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJldW13YWxsZXIuY29tXCIsXG4gICAgXCJteWV0aGVyZXVtd3dhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJldXVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV5bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJyZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnJ1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1bWVhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1bW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVydW13YWFsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FrbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FsZWx0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FsbGUuY29tXCIsXG4gICAgXCJteWV0aGVydW13YWxsZWV0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FsbGVyLmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FsbGV5LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FsbHJ0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2FsbHd0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd2xhbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd3NsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnVtd3dhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1bndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1dW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVydXdtYWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyeW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGV0ZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhldHVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhldW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGV1cm13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGhlcmV1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoaGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHJydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHJ1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXR0ZXJ3YWxldC5jb21cIixcbiAgICBcIm15ZXR0aGVyZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwidmVyaWZ5LWJpbmFuY2UuY29tXCIsXG4gICAgXCJlYXJuLmRhaWx5ZGl2cy5jb21cIixcbiAgICBcInNhZmUubWluZWR0b2tlbnMuY29tXCIsXG4gICAgXCJzbWFydHNlbmQtNTAwMC53ZWJzaXRlXCIsXG4gICAgXCJhaXJkcm9wZXRoLnRlY2hcIixcbiAgICBcImlteWV0aGVyYm9udXMuY29tXCIsXG4gICAgXCJtaW5lZHRva2Vucy5jb21cIixcbiAgICBcImNyeXB0by1wcm9tby5vcmdcIixcbiAgICBcImNvaW5iYXNlc2VjdXJpdHl0b2tlbnMuY29tXCIsXG4gICAgXCJjb2luYmFzZXBheS5pbmZvXCIsXG4gICAgXCJoaXRidGNyZWNvdmVyeS5jb21cIixcbiAgICBcImhpdGJ0Yy1hZHYuY29tXCIsXG4gICAgXCJnZW1pbmktd2FsbGV0LmNvbVwiLFxuICAgIFwiZ2VtaW5pMmZhLmNvbVwiLFxuICAgIFwiZ2VtaW5pYWNjb3VudC5jb21cIixcbiAgICBcImJpbmFudGxhYnNpbmZvLmNvbVwiLFxuICAgIFwiYmluYW5ldGxhYnNpbmZvLmNvbVwiLFxuICAgIFwibXltb25lcm9jb20uY29tXCIsXG4gICAgXCJiaW5hbnRydXN0d2FpaWV0LmNvbVwiLFxuICAgIFwiYmluYW50cnVzdHdhaWxldC5jb21cIixcbiAgICBcImJpbmFudHJ1c3R3YWxpZXQuY29tXCIsXG4gICAgXCJiaW5hbmNldHJ1c3R3YWlpZXQuY29tXCIsXG4gICAgXCJiaW5hbmNldHJ1c3R3YWlsZXQuY29tXCIsXG4gICAgXCJiaW5hbmNldHJ1c3R3YWxpZXQuY29tXCIsXG4gICAgXCJiaW5hbmN0bGFic2luZm8uY29tXCIsXG4gICAgXCJiaW5hbmN0cnVzdHdhaWlldC5jb21cIixcbiAgICBcImJpbmFuY3RydXN0d2FpbGV0LmNvbVwiLFxuICAgIFwiYmluYW5jdHJ1c3R3YWxpZXQuY29tXCIsXG4gICAgXCJiaW5hbmNlLWFjY291bnRzLmNvbVwiLFxuICAgIFwiYmluYXRydXN0d2FpaWV0LmNvbVwiLFxuICAgIFwiYmluYXRydXN0d2FpbGV0LmNvbVwiLFxuICAgIFwiYmluYXRydXN0d2FsaWV0LmNvbVwiLFxuICAgIFwiYmludHJ1c3R3YWlpZXQuY29tXCIsXG4gICAgXCJiaW50cnVzdHdhaWxldC5jb21cIixcbiAgICBcImJpbnRydXN0d2FsaWV0LmNvbVwiLFxuICAgIFwidWJleC51c1wiLFxuICAgIFwiYm5iZGV4LWV0aGNhbXBhaWduLmNvbVwiLFxuICAgIFwiYmluYW5jZS1ldGhlci5vbmxpbmVcIixcbiAgICBcImJpbmFuY2Uud2luXCIsXG4gICAgXCJiaW5hbmNlZXRoZXZlbnQubmV0XCIsXG4gICAgXCJldGhldmVudGJpbmFuY2UubmV0XCIsXG4gICAgXCJtZXRoZXJ1bXdhbGxldC5jb21cIixcbiAgICBcIm1teWV0aGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJtdGV0aGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJtdWV0aGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWVldGhlcmV1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZWhlcnVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXllcmhlcnVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0Z2VydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVlZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlZXJldW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVlcnVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmVldW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyZWltd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bWVhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJldW1td2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXFhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJldW13YWFsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmltd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcm11d2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlc3dhbGxldHMub3JnXCIsXG4gICAgXCJteWV0aHdydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0amVydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0bmVyd2FsbGV0LWNvbS5yZXZpZXdcIixcbiAgICBcIm15ZXR0ZXJ3ZWxsbGV0LmNvbVwiLFxuICAgIFwibXlldHRoZXJ1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXloZXJ1bXdhbGxldC5jb21cIixcbiAgICBcIm15cnRoZXJ1bXdhbGxldC5jb21cIixcbiAgICBcIm15dGhlcnVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXl3dGhlcnVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXl5ZXRoZXJ1bXdhbGxldC5jb21cIixcbiAgICBcIm55ZXRoZXJldW13YWxsZXQuY29tXCIsXG4gICAgXCJueWV0aGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJ5bWV0aGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJhaXJkcm9wcy1leGNoYW5nZS5jb21cIixcbiAgICBcImJ1dGVyaW5kcm9wLmV1XCIsXG4gICAgXCJjYW1wYWlnbi5ldGhlcmFjdGlvbi5pblwiLFxuICAgIFwiZXRoZXJhY3Rpb24uaW5cIixcbiAgICBcImV0aHRha2UuaWN1XCIsXG4gICAgXCJjcnlwdG9jdXJyZW5jeS1naXZlYXdheS5jb21cIixcbiAgICBcIm1jYWZlZS5jb29scGFnZS5iaXpcIixcbiAgICBcInNlcHRlbWJlci1ldmVudC51c1wiLFxuICAgIFwic2VwdGVtYmVyLXByb21vLnVzXCIsXG4gICAgXCJmcmVlZXRoZXJldW01MDAuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLndlYndhbGxldC12aWV3LmluZm9cIixcbiAgICBcIndlYndhbGxldC12aWV3LmluZm9cIixcbiAgICBcImJpbmFuY2UtZXRoLm5ldFwiLFxuICAgIFwiYmluYW5jZS1ldGhlci5uZXRcIixcbiAgICBcImJpbmFuY2Utbi5jb21cIixcbiAgICBcImJpbmFuY2VldGgub3JnXCIsXG4gICAgXCJldGgtYmluYW5jZS5uZXRcIixcbiAgICBcImV0aGVyZXVtd2FsbGV0cy50ZWNoXCIsXG4gICAgXCJtZXl0aGVyd2FsbGV0Lm5ldFwiLFxuICAgIFwibXlldGhlZm9yd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20udXBkYXRlLnByaXZhdGVrZXkud2FsbGV0LWNyeXB0by1tZW1iZXIuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnVwZGF0ZS5zeXN0ZW0uY3J5cHRvLXdhbGxldC1tZW1iZXIuY29tXCIsXG4gICAgXCJteWV0aHN3YWxsZXQubmV0XCIsXG4gICAgXCJteWV0aHN3YWxsZXQudG9wXCIsXG4gICAgXCJteWV0dHdhbGxldC5iaWRcIixcbiAgICBcIm15eWV0aGVyd2FsbGV0Lm9ubGluZVwiLFxuICAgIFwiYm5iZXRoc3BlY2lhbGNhbXBhaWducy5jb21cIixcbiAgICBcImJuYmNoYWluZXRoLmNvbVwiLFxuICAgIFwiYm5iZXRoY2hhaW4uY29tXCIsXG4gICAgXCJibmJkZXhldGhsYXVuY2guY29tXCIsXG4gICAgXCJibmJldGhwcm9tb3Rpb24uY29tXCIsXG4gICAgXCJiaW5hbmV0aHByb21vdGlvbi5jb21cIixcbiAgICBcImJuYnByb21vdGlvbi5jb21cIixcbiAgICBcImJuYnNwZWNpYWxjYW1wYWlnbi5jb21cIixcbiAgICBcImJuYmRleGNhbXBhaWduLmNvbVwiLFxuICAgIFwiYm5iZXhjaGFuZ2VkZXguY29tXCIsXG4gICAgXCJibmJleGNoYW5nZXNwZWNpYWxjYW1wYWlnbi5jb21cIixcbiAgICBcImJuYmV4Y2hhbmdlc3BlY2lhbC5jb21cIixcbiAgICBcImJuYmRleGV0aGNhbXBhaWduLmNvbVwiLFxuICAgIFwiYm5iZXhjaGFuZ2VldGhzcGVjaWFsY2FtcGFpZ24uY29tXCIsXG4gICAgXCJibmJleGNoYW5nZXNwZWNpYWxldGhjYW1wYWlnbi5jb21cIixcbiAgICBcImJuYmV0aGV4Y2hhbmdlc3BlY2lhbC5jb21cIixcbiAgICBcImJvbnVzLmNsaWVudC1zdGVsbGFydGVybS5jb21cIixcbiAgICBcImNsaWVudC1zdGVsbGFydGVybS5jb21cIixcbiAgICBcIm1peHByaXplLmNuXCIsXG4gICAgXCJtZWRpdW0tc2VjdXJlLmNvbVwiLFxuICAgIFwiZ2luZXhpcy5ibG9nc3BvdC5jb21cIixcbiAgICBcImdpZnRzYXRvc2hpLnNwYWNlXCIsXG4gICAgXCJteWV0aGNyd2FsbGV0Lm5ldFwiLFxuICAgIFwibXlldGhlcmV3YTExZXRzLmNvbVwiLFxuICAgIFwibXZ5ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWVodGVyd2FsbGV0cy54eXpcIixcbiAgICBcInhuLS1tZWhlcndhbGxldC15YjlldXAuY29tXCIsXG4gICAgXCJsb2dpbi1ibG9ja2NoYWluLnRvcFwiLFxuICAgIFwibG9naW4tYmxvY2tjaGFpbi5ncVwiLFxuICAgIFwiZW9zYXV0aG9yaXR5LWFjY291bnRwb2xpY3kub21hc3RyYWwub3JnXCIsXG4gICAgXCJjbGFpbS5wYXlzYWZlY29pbnMuY29tXCIsXG4gICAgXCJwYXlzYWZlY29pbnMuY29tXCIsXG4gICAgXCJnb29kZHJvcC5jblwiLFxuICAgIFwiZ2l2ZWF3YXktZXRoLWJ0Yy5ldXdlYi5jelwiLFxuICAgIFwiZXRoNDMxMmxlZnQucHdcIixcbiAgICBcInNlY3VyZS50b3Bjb2luZ2lmdC5jb21cIixcbiAgICBcInRvcGNvaW5naWZ0LmNvbVwiLFxuICAgIFwiZXRoZ29sZC5wcm9cIixcbiAgICBcInNlbmQtc21hcnRjb250cmFjdC5zcGFjZVwiLFxuICAgIFwiZ2V0eW91cmV0aC5uZXR3b3JrXCIsXG4gICAgXCJnZXRldGgucHJvXCIsXG4gICAgXCJsb3BpeHkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJ6aWxsaXFhZ29sZC5jb1wiLFxuICAgIFwieG4tLXRlc2wtdHpiLmNvbVwiLFxuICAgIFwibGl0ZWNvaW5vbmUub3JnXCIsXG4gICAgXCJtZWRpdW0tbWNhZmVlLnRvcFwiLFxuICAgIFwiYmluYW5jZXRoLm5ldFwiLFxuICAgIFwidGVzbGEtZ2l2ZWF3YXlzLm9yZ1wiLFxuICAgIFwic2VwdGVtYmVyLWJvbnVzcy5jb21cIixcbiAgICBcImV0aGVyc2NsYWltLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZnJlZS5naWZ0ZXRoZXIudG9wXCIsXG4gICAgXCJnaWZ0ZXRoZXIudG9wXCIsXG4gICAgXCJnZXQtYm9udXMub25saW5lXCIsXG4gICAgXCJnZXRldGhlci5ldVwiLFxuICAgIFwiZWFzeWRyb3AucHJvXCIsXG4gICAgXCJjbGFpbS1ldmVudC1ldGgub3JnLnVrXCIsXG4gICAgXCJ2ZWNpbWF4LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRocHJvbW8tYmluYW5jZS5vcmdcIixcbiAgICBcIm15ZXRoZXJib251cy5uZXRcIixcbiAgICBcImdldC5zYWZlcGF5Y29pbi5jb21cIixcbiAgICBcInNhZmVwYXljb2luLmNvbVwiLFxuICAgIFwiZXRoZXJldW00ZXZlci5jb21cIixcbiAgICBcImNvbnRhZ2lvbi5jZlwiLFxuICAgIFwic2VwdGVtYmVyLWJvbnVzLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tYWlyZHJvcC50dW1ibHIuY29tXCIsXG4gICAgXCJnaXZlYXdheS5hdC51YVwiLFxuICAgIFwibXlldGgtY2xhaW0uY29tXCIsXG4gICAgXCJldGhlcmV1bXZlcnQuY29tXCIsXG4gICAgXCJtZWRpdW1wb3N0aW5nLnZpcFwiLFxuICAgIFwiZ2l2ZS1hd2F5LmNvLnVrXCIsXG4gICAgXCJldGg0MzIzbGVmdC5wd1wiLFxuICAgIFwic2FmZS5jb2luc3BheW5vdy5jb21cIixcbiAgICBcImNvaW5zcGF5bm93LmNvbVwiLFxuICAgIFwibWl4Z2lmdC50b3BcIixcbiAgICBcImJsb2ctbWVkaXVtLmNvbVwiLFxuICAgIFwiZXRoZXJkZWx0YS53ZWJzaXRlXCIsXG4gICAgXCJibG9ja2hhaW5lLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZ2V0ZXRoLmNuXCIsXG4gICAgXCJtZWRpdW0uY29tLjdhNGM3YjIzNDA2OS5zaXRlXCIsXG4gICAgXCJldGhlcml1bS5vcmcuN2E0YzdiMjM0MDY5LnNpdGVcIixcbiAgICBcIjdhNGM3YjIzNDA2OS5zaXRlXCIsXG4gICAgXCJlbGN0cnVybi5vcmdcIixcbiAgICBcImpheHgub25lXCIsXG4gICAgXCJsa3Jha2VuLnhidHh2LmNvbVwiLFxuICAgIFwiYmVzdGJ1aWxkZXJjb21wYW55LnB3XCIsXG4gICAgXCJpLWlkZXhtYXJrZXQuY29tXCIsXG4gICAgXCJteWV0aGVyZXdhbGxldC5nYVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2lnbm1lc3NhZ2UuaW5mb1wiLFxuICAgIFwibXlldGhyZXdhbGxldC5zZXJ2aWNlc1wiLFxuICAgIFwidG9wdGlyZXNob3AucHdcIixcbiAgICBcImluZGV4bWFyeC5jb21cIixcbiAgICBcIm15ZXRoZXJld2FsbGV0Lm9ubGluZVwiLFxuICAgIFwibXlldGhlcnJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVycndhbGxldC5zaWdubWVzc2FnZS54eXpcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtaHlkcm8uc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnZlcmlmaXkuaWN1XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0dC5taW5pbmcyNC5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsbHdldC5jb21cIixcbiAgICBcIm15ZXRoaGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhyd2FsbGV0LmNvbVwiLFxuICAgIFwibXVzay1wcml6ZS5pbmZvXCIsXG4gICAgXCJtZWRpdW0taW8uc2l0ZVwiLFxuICAgIFwiY2xhaW0uc2FmZXBheWNvaW5zLmNvbVwiLFxuICAgIFwic2FmZXBheWNvaW5zLmNvbVwiLFxuICAgIFwiYWlyZHJvcC1leGNoYW5nZS5jb21cIixcbiAgICBcInNlY3VyZS5ldGgtY2xhaW0ub25saW5lXCIsXG4gICAgXCJldGgtY2xhaW0ub25saW5lXCIsXG4gICAgXCJhaXJkcm9wcy5pbnZlc3RtZW50c1wiLFxuICAgIFwibWVkaXVtLmluLm5ldFwiLFxuICAgIFwiZXRoNTMyMWxlZnQucHdcIixcbiAgICBcInNlbmQtdHJhbnNhY3Rpb24ub25saW5lXCIsXG4gICAgXCJtZWRpdW0tc21hcnRjb250cmFjdC5zcGFjZVwiLFxuICAgIFwiYWNjZXNzLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJtZXctbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm1leXRoZXJldW13YWxsZXQuY29tXCIsXG4gICAgXCJtaW5lZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWVodGVyZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGVocmV1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJlbXV3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyZXVtd2FsbHRlLmNvbVwiLFxuICAgIFwibXlldGhlcmV1d21hbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWlsZXQub25saW5lXCIsXG4gICAgXCJteWV0aGVyd2FsbGF0cy54eXpcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNpZ25tZXNzYWdlLnh5elwiLFxuICAgIFwibXlldGhlcndhbGxldC53aWtpXCIsXG4gICAgXCJteWV0aGVyd2FsbHd0LmNvbVwiLFxuICAgIFwibXlldGhldHdhbGxldC5jb21cIixcbiAgICBcIm15dGVoZXJldW13YWxsZXQuY29tXCIsXG4gICAgXCJ3YWxsZXQtbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcImxvZ2luLWNvaW5vbmUtY28ta3IuY29tXCIsXG4gICAgXCJwdW1wa2lucHJvLmNvXCIsXG4gICAgXCJwYW5lbWljYXYyLnJmLmdkXCIsXG4gICAgXCJldGhib251cy5saXZlXCIsXG4gICAgXCJldGhhY3RpdmUub25saW5lXCIsXG4gICAgXCJldGgtdGFrZS5jb21cIixcbiAgICBcImNyeXB0by1naXZlYXdheS54eXpcIixcbiAgICBcImV0aGVyLXByaXplLmNvbVwiLFxuICAgIFwic21hcnQtY29udHJhY3Quc3BhY2VcIixcbiAgICBcInNhZmUuanVzdGdldGNyeXB0by5jb21cIixcbiAgICBcImp1c3RnZXRjcnlwdG8uY29tXCIsXG4gICAgXCJzZXB0ZW1iZXItZXZlbnQuY29tXCIsXG4gICAgXCJob21lLW15ZXRoZXIudG9wXCIsXG4gICAgXCJldGhjb2luZGVzay5ibG9nc3BvdC5jb21cIixcbiAgICBcIm1lZGl1bS1haXJkcm9wLm5ldFwiLFxuICAgIFwiYWlyZHJvcC51cGRvZy5jb1wiLFxuICAgIFwic2VuZC5zZWN1cmV0aC5ob3N0XCIsXG4gICAgXCJzZWN1cmV0aC5ob3N0XCIsXG4gICAgXCJtaXhkcm9wLmV1XCIsXG4gICAgXCJnaXZlYXdheS1idGMuY29tXCIsXG4gICAgXCJiaW5tZWRzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiamlkZXgubWFya2V0XCIsXG4gICAgXCJtbGpldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZWh0ZXJtYWxsZXJ0LmNvbVwiLFxuICAgIFwibXlldGhlZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bWFsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXdhbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXdhbGxlLmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXdhbGxldC5jb1wiLFxuICAgIFwibXlldGhlcmV1bXdhbGx0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXdsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcml3YWxsZXQub25saW5lXCIsXG4gICAgXCJteWV0aGVycndhbGxldC5taW5pbmcyNC5pbmZvXCIsXG4gICAgXCJteWV0aGVycndhbGxuZXQuY29tXCIsXG4gICAgXCJteWV0aGVycndhbGxuZXQubWluaW5nMjQuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGV0cy5zaXRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGF0cy5jbHViXCIsXG4gICAgXCJteWV0aGVyd2FsbGF0cy5vbmxpbmVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZS10LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxlLXQudmUtcnkuY2x1YlwiLFxuICAgIFwibXlldGhlcndhbGxldC1ncmFtLndlYnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmdwZy5zZXJ2aWNlc1wiLFxuICAgIFwibXlldGhlcndhbGxldC5zaWduZ3BnbWVzc2FnZS5jb1wiLFxuICAgIFwibXlldGhyZXdhbGxldC5jbHViXCIsXG4gICAgXCJteWV0dGhlcndhbGV0Lm5ldFwiLFxuICAgIFwibXl0aGVyZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwieW91cmV0aGVyd2FsbGV0LmlvXCIsXG4gICAgXCJldGhtaXhkcm9wLnByb1wiLFxuICAgIFwiYXhpYm92cy5ibG9nc3BvdC5jb21cIixcbiAgICBcInNlbmQuZXRocGFydHkudXNcIixcbiAgICBcImV0aHBhcnR5LnVzXCIsXG4gICAgXCJldGhhd2F5LjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJibG9nbmFuY2UuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJzZXB0ZW1iZXItcHJvbW8uY29tXCIsXG4gICAgXCJjcnlwdG9haXJkcm9wLmNlbnRlclwiLFxuICAgIFwiYWlyLWRyb3Aud2Vic2l0ZVwiLFxuICAgIFwidGV6Ym94Lm5ldFwiLFxuICAgIFwid2V0aW1veC5ibG9nc3BvdC5jb21cIixcbiAgICBcImJ1dGVyaW5wcm9tby5jblwiLFxuICAgIFwiZXRoMjR3aW4uY28ubmZcIixcbiAgICBcImFpcmRyb3AtcG9ydGFsLmNvbVwiLFxuICAgIFwiZ2l2ZS1ldGguYml6XCIsXG4gICAgXCJtZWRpdW0tcHJvbW9zLnh5elwiLFxuICAgIFwiYnV0ZXJpbnByb21vLmxpdmVcIixcbiAgICBcImV0aGNsYWltLm9ubGluZVwiLFxuICAgIFwibXl3aW5kb3J3YWxsZXJ0LnNpdGVcIixcbiAgICBcImJpbmFuY2VnaXZlYXdheS5jb21cIixcbiAgICBcIm15ZXRoZXJ2dmVsbGV0LmNvXCIsXG4gICAgXCJteWV0aGhlcndhbGxldHIudG9wXCIsXG4gICAgXCJ4bi0tbXlldGhyZXdhbGxlLXhvYy5jb21cIixcbiAgICBcInhuLS1teWV0aHJld2FldC16M2JhLmNvbVwiLFxuICAgIFwibWV2ZXRoZXJ3YWxsZXRyLnNpdGVcIixcbiAgICBcIm12ZXRuZXJ3YWxsZXRyLndlYnNpdGVcIixcbiAgICBcIm1ldmV0aGVyd2FsbGV0ci5jb21cIixcbiAgICBcIm15dmV0aGVyd2FsbGV0cy5jb21cIixcbiAgICBcInB1bXBraW5wcm8uaW9cIixcbiAgICBcImJpbmFuY2V0aGVyZXVtLmNvbVwiLFxuICAgIFwibWFpbGJpbmFuY2UuY29tXCIsXG4gICAgXCJidGMtYm9udXMtbGl2ZTItYmluYW5jZS5jb21cIixcbiAgICBcIm1vbmVyby1teS5jb21cIixcbiAgICBcImV0aDQxMjNsZWZ0LnB3XCIsXG4gICAgXCJ4bGJsb2d6LmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRoLXByb21vLmJvcmVjLmN6XCIsXG4gICAgXCJldGhlci10YWtlLm9yZ1wiLFxuICAgIFwiZXRoZXJnb3QueHl6XCIsXG4gICAgXCJjcnlwdG8tZ2l2ZWF3YXkubmV0XCIsXG4gICAgXCJldGhlcnByaXplLm5ldFwiLFxuICAgIFwiZXRocHJvbXpvbmUuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmlwMTQuaWN1XCIsXG4gICAgXCJpcDE0LmljdVwiLFxuICAgIFwic3RhdHVzaWNvLmNvbVwiLFxuICAgIFwicmVkZWVtLW15ZXRoZXJ3YWxsZXQucHdcIixcbiAgICBcIm9taXNlZ29nb2xkLmlvXCIsXG4gICAgXCJjbGFpbS13YWxsZXQuY29tXCIsXG4gICAgXCJiaGFza2FyLmR4LmFtXCIsXG4gICAgXCJldGhlcnRva2VuLm9ubGluZVwiLFxuICAgIFwibXl3aW5kb3J3YWxsZXJ0LnNwYWNlXCIsXG4gICAgXCJiaW5hbmNlLWV0aGVyLm9yZ1wiLFxuICAgIFwibmVvc3RyYWNrZXIuY29tXCIsXG4gICAgXCJlbG9ubXVzay5sdGRcIixcbiAgICBcImVsb25tdXNrLmZ1bmRcIixcbiAgICBcImxvZ2luYmluYW5jZS1jb20udW1ibGVyLm5ldFwiLFxuICAgIFwic2VsbGV0aC5pb1wiLFxuICAgIFwiYmxva2NsbmFpbi5jb21cIixcbiAgICBcImdpZnRyZXR1cm4ubXlzdGVyaWEuY3pcIixcbiAgICBcImV0aGRyb3AuY25cIixcbiAgICBcImdpdmVhd2F5czI0LmluZm9cIixcbiAgICBcImFpcmRyb3AtbGl2ZS5jb21cIixcbiAgICBcImdyaWp1Yi5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGVyZHJvcC5zcGFjZVwiLFxuICAgIFwiaW5mb2NsYWltZXRoLnVjb3oub3JnXCIsXG4gICAgXCJzZWN1cmUuZXRoYWNjZXNzLm9ubGluZVwiLFxuICAgIFwiZXRoYWNjZXNzLm9ubGluZVwiLFxuICAgIFwidGVzbGEuY2VudGVyXCIsXG4gICAgXCJnby5wYXlldGgub25saW5lXCIsXG4gICAgXCJwYXlldGgub25saW5lXCIsXG4gICAgXCJjcnlwdG8tZXhjaGFuZ2Uucm9cIixcbiAgICBcImV0aGJvbnVzLmNuXCIsXG4gICAgXCJjbGFpbS1oZXJlLmNvbVwiLFxuICAgIFwiaGl6eXRveC5ibG9nc3BvdC5jb21cIixcbiAgICBcImNsYWltLWV2ZW50LWV0aC5iaXpcIixcbiAgICBcImxvY2FsZXRoZXJldW0tc3VwcG9ydC5jb21cIixcbiAgICBcInppbGxpcWEucGx1c1wiLFxuICAgIFwiY2xhaW0tZ2lmdHdhdmVzLmNvbVwiLFxuICAgIFwicGFuZGVtaWNhLm9ubGluZVwiLFxuICAgIFwiYnRjZHJvcC5jblwiLFxuICAgIFwiZXRoLWJvbnVzLWxpdmUtYmluYW5jZS5jb21cIixcbiAgICBcImV0aGJpbmFuY2Uub3JnXCIsXG4gICAgXCJ4bi0tYm9ja2NoYWluLTBzYi5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsbGV0Lnh5elwiLFxuICAgIFwibXlldGhlcnN3YWxsZXQud2Vic2l0ZVwiLFxuICAgIFwiYmxvY2tjaGFsaC5jb21cIixcbiAgICBcImJsb2tjbGhhaW4uY29tXCIsXG4gICAgXCJibG9rY2xuYWxuLmNvbVwiLFxuICAgIFwiYmxvY2tjaGFpam4uY29tXCIsXG4gICAgXCJibG9ja2NoYXRuLmNvbVwiLFxuICAgIFwieG4tLWJsb2NrY2hhaS0zdmIuY29tXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGFpLXQ2YS5jb21cIixcbiAgICBcImJsb2NrY2xoYWluLmluXCIsXG4gICAgXCJibG9ja2NoYWxsbnMuaW5mb1wiLFxuICAgIFwiY2xhaW0tbm93Z2lmdC5jb21cIixcbiAgICBcImFpci1kcm9wLWV0aG1hcmsud2Vic2l0ZVwiLFxuICAgIFwiZXRoYm9vbS5ldVwiLFxuICAgIFwiZG9udG1pc3MuaW5mb1wiLFxuICAgIFwidG9wLWV0aGVyZXVtLm5ldFwiLFxuICAgIFwiYWlyZHJvcHMuc2VydmljZXNcIixcbiAgICBcImV0aGVyZXVtLWF3YXJkLmNsdWJcIixcbiAgICBcImNyeXB0b2N1cnJlbmN5LWdpZnQudHVtYmxyLmNvbVwiLFxuICAgIFwic2VjdXJlLmdldGNyeXB0b2dpZnQuY29tXCIsXG4gICAgXCJnZXRjcnlwdG9naWZ0LmNvbVwiLFxuICAgIFwiZXRoYm9vbS5pb1wiLFxuICAgIFwiZXRoYmluYW5jZS5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGVyLWFpcmRyb3AtcHJvbW8uaW5mb1wiLFxuICAgIFwibWVkaXVtLWV0aGVyLWFpcmRyb3AubmV0XCIsXG4gICAgXCJpb3N0LmdpZnRcIixcbiAgICBcImV0aGFjdGl2YXRlLmNvbVwiLFxuICAgIFwibWVkaXVtLXByb21vLnh5elwiLFxuICAgIFwiYWNjZXNzLmV0aC1hY2Nlc3MuY29tXCIsXG4gICAgXCJldGgtYWNjZXNzLmNvbVwiLFxuICAgIFwic2VjdXJlLmJ0Y2V0aGdvbGRtaW5lLmNvbVwiLFxuICAgIFwiYnRjZXRoZ29sZG1pbmUuY29tXCIsXG4gICAgXCJjbGFpbS5ldGhzeC5zcGFjZVwiLFxuICAgIFwiZXRoc3guc3BhY2VcIixcbiAgICBcImFza3RvbGxmcmVlLmNvbVwiLFxuICAgIFwiYmluYW5jZS1leGNoYW5nZS5vbmxpbmVcIixcbiAgICBcImJpbmFuY2UtZXhjaGFuZ2UueHl6XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXdhYi5zcGFjZVwiLFxuICAgIFwibXlldGhlcndhbGxldC5yZXZpZXdcIixcbiAgICBcIm15ZXRocmV3YWxsZWwuY29tXCIsXG4gICAgXCJiaW5hbmNlLWxnaW4uY29tXCIsXG4gICAgXCJpYngtbC5jb21cIixcbiAgICBcIm12ZXRuZXJ3YWxsZXRyLm9ubGluZVwiLFxuICAgIFwibXZldG5lcndhbGxldHIuc2l0ZVwiLFxuICAgIFwibXZ5ZXRoZXJ3YWxsZXR0Lm9ubGluZVwiLFxuICAgIFwieG4tLW1ldGhld2FsbGV0LXY0OGUxeC5jb21cIixcbiAgICBcImluZm8tbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcInhuLS1teWVoZXJ3bGxldC13dGU3NTY0Zy5jb21cIixcbiAgICBcImVudGVybm93LmluZm9cIixcbiAgICBcImNsYWltLWV2ZW50LWV0aC5jb21cIixcbiAgICBcImNsYWltLWdpdmVhd2F5LmNsdWJcIixcbiAgICBcImJpbmFiaW5zLmJsb2dzcG90LmNvbVwiLFxuICAgIFwibWVkaXVtLWV0aGVyZXVtLXByb21vLmluZm9cIixcbiAgICBcImV0aGVyZXVtLWJvbnVzLmluZm9cIixcbiAgICBcImV0aGVyZXVtLWV2ZW50LXByb21vdGlvbi5vcmcudWtcIixcbiAgICBcImpibGFnei5ibG9nc3BvdC5jb21cIixcbiAgICBcImV2ZW50LWV0aC5iaXpcIixcbiAgICBcImV0aGVyZXVtYm9udXMucnVcIixcbiAgICBcInhuLS1jcnlwdG9uYW9yLWhjYy5jb21cIixcbiAgICBcInBvbG9uaS1leC5jb21cIixcbiAgICBcInhuLS1iaW5hbmMtZ3BjLmNvbVwiLFxuICAgIFwiYWNjb3VudGxvZ2luMmZhLmNvbVwiLFxuICAgIFwiZXRocHJvbW8xMC4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwiZGlnaXRhbGFzc2V0LWFwcC5jb21cIixcbiAgICBcImxvZy1pbi1iaW5hbmNlLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxhdC5jbHViXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvLm56XCIsXG4gICAgXCJteWV0aGZvcmt3YWxsZXQuY29tLnJ1XCIsXG4gICAgXCJteWV0aGhlcndhbGxldHIuY29tXCIsXG4gICAgXCJ3dzI1Lm15ZXRoZXJldW0uaW5mb1wiLFxuICAgIFwibXlldGhzd2FsZXQuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyZXdhbGx0LWZ3Yi5jb21cIixcbiAgICBcInZpZXctd2Vid2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRuZXJ3YWxsZXQuY29tLnZpZXctd2Vid2FsbGV0LmluZm9cIixcbiAgICBcImxiaXRtZXgtaW4uY29tXCIsXG4gICAgXCJteWV0YWxvbndpbmRvdy5pbmZvXCIsXG4gICAgXCJiaXRtZXgtaW4uY29cIixcbiAgICBcImFpcmRyb3AtZXRoLndlYnNpdGVcIixcbiAgICBcImV0aGVyZXVtcHJvbW8uaW9cIixcbiAgICBcImV0aHJldHVybi5ldXdlYi5jelwiLFxuICAgIFwiYm9udXMtY2xhaW0ueGYuY3pcIixcbiAgICBcImV0aC1jbGFpbS5pbmZvXCIsXG4gICAgXCJhY2Nlc3MuZXRoc3VwcGx5LmNvbVwiLFxuICAgIFwiZXRoc3VwcGx5LmNvbVwiLFxuICAgIFwiZXRoYWN0aXZlLmNvbVwiLFxuICAgIFwibHRjLWV2ZW50LW5vdy54eXpcIixcbiAgICBcImJpbHRtZXguY29tXCIsXG4gICAgXCJsYnRzeC5jb21cIixcbiAgICBcInhuLS1iaW1leC1sZWIuY29tXCIsXG4gICAgXCJiaXRtZXgtbG9naW4uY29tXCIsXG4gICAgXCJiaW5hbmJsb2cuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJldGhlcmZhc3QuZXVcIixcbiAgICBcImV0aHJldW0ucnVcIixcbiAgICBcImV0aC1vZmZpY2lhbC5mdW5kXCIsXG4gICAgXCJib251c2V0aC50b3BcIixcbiAgICBcImJpbmFuY2UtZXRoLWdpdmVhd2F5cy5vbmxpbmVcIixcbiAgICBcInJldHVybmV0aC53ZWJ6LmN6XCIsXG4gICAgXCJleGNoYW5nZS1haXJkcm9wLmNvbVwiLFxuICAgIFwiZXRoZXItcmV3YXJkLmluZm9cIixcbiAgICBcIm1lZGl1bS1haXJkcm9wLndlYnNpdGVcIixcbiAgICBcImV0aC1taW5lci5pbmZvXCIsXG4gICAgXCJ0cm9uLWV2ZW50Lm5ldHdvcmtcIixcbiAgICBcImV0aGVyNTAwMC5pblwiLFxuICAgIFwiZWZpcml1bWdpdmVhd2F5LnRrXCIsXG4gICAgXCJ0ZWRqYW5nNjgud2l4c2l0ZS5jb21cIixcbiAgICBcImV0aGdpdmV3YXlvZmZpY2lhbC5pbmZvXCIsXG4gICAgXCJnaXZlYXdheWJpbmFuY2UuY29tXCIsXG4gICAgXCJwcm9tb2V0aC4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwiaW1kZXgubWFya2V0XCIsXG4gICAgXCJvZmZpY2lhbC1naXZlLWF3YXkudHVtYmxyLmNvbVwiLFxuICAgIFwidHdncmFtLmluZm9cIixcbiAgICBcImV0aGVyLWNsYWltLm5ldFwiLFxuICAgIFwiYWlyZHJvcHZlcnQuaW5mb1wiLFxuICAgIFwiYmlnY3J5cHRvZ2lmdC5uZXRcIixcbiAgICBcImV0aC1naXZlLmlvXCIsXG4gICAgXCJtY2FmZWVwcm9tby54eXpcIixcbiAgICBcImNyeXB0by1naWZ0cy5tbFwiLFxuICAgIFwiYW1hemluZy1zbWFydGNvbnRyYWN0LnNwYWNlXCIsXG4gICAgXCJlbG9uLXNoYXJlcy5pbmZvXCIsXG4gICAgXCJibG9nc2JpbmEuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJtZWRpdW0tY29tLndlYnNpdGVcIixcbiAgICBcImJpZy1naXZlYXdheS54Zi5jelwiLFxuICAgIFwiY3J5cHRvZHJvcC5ldVwiLFxuICAgIFwiYmluYy1ibG9nLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRoZnJlZWdpdmVhd2F5LmdhXCIsXG4gICAgXCJhcHAtMTUyNDMzNjMxMS4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwiZXRoZXJpdW0tY29tLnNpdGVcIixcbiAgICBcImJvbnVzZXRoMTAuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcIm1lZGl1bS1ldGhlcmV1bS1wcm9tby5iaXpcIixcbiAgICBcInRva2Vuc2FsZS53c1wiLFxuICAgIFwiZ29vZ2xlLmNvbS50b2tlbnNhbGUud3NcIixcbiAgICBcImdvb2dsZS1jb2luLmlvXCIsXG4gICAgXCJhaXJkcm9wLWJpbmFuY2UuY29tXCIsXG4gICAgXCJhdXJvcmFkYW8uY28udWtcIixcbiAgICBcImJpbmFuY2VldGhlcmV1bS5jb21cIixcbiAgICBcImV0aGVyd2FsbGV0bG9naW4uY2x1YlwiLFxuICAgIFwiZXRoZXJ3YWxsZXRsb2dpbi5vbmxpbmVcIixcbiAgICBcImh0dHBzbXlldGhlcndhbGxldC5wd1wiLFxuICAgIFwiaWRleC5tYXJrZXRpbmdcIixcbiAgICBcIm15ZWxoZXJ3YWxsZXQuY29cIixcbiAgICBcIm15ZXRoZXJsd2FsaWV0LmluZm9cIixcbiAgICBcIm15ZXRoZXJzd2FsbGV0LnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRseS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRzLmxpdmVcIixcbiAgICBcIm15ZXRocndhbGxldC5jb20uY29cIixcbiAgICBcImlkZXhtYXJrLm9ubGluZVwiLFxuICAgIFwiZXRoLWdpZnRpbmcuY29tXCIsXG4gICAgXCJldGhlcmV1bS1ib251cy5iaXpcIixcbiAgICBcImJpZ2NyeXB0b2dpZnQuYm9yZWMuY3pcIixcbiAgICBcIndlYnNpdGUtZXZlbnRzLndlYnNpdGVcIixcbiAgICBcInNhdG9zaGlsaXRlLWV0aC50dW1ibHIuY29tXCIsXG4gICAgXCJzdGVsbGFydGVybS5vcmdcIixcbiAgICBcImdpZnRzZXRoMTAuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcInByb21vZXRoMTAuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcInhuLS1teWV0aHJld2xsZXQtamJiLmNvbVwiLFxuICAgIFwieGxzLWxvZy5jb21cIixcbiAgICBcImhpdGJ0YzEud2Vic2l0ZVwiLFxuICAgIFwicHJvbW8tZ2l2aW5nLmdhXCIsXG4gICAgXCJtZWRpdW1sYXN0Lm1sXCIsXG4gICAgXCJldGhlcmV1bWJvbnVzLm5ldFwiLFxuICAgIFwic2VjdXJlLWV0aC5pbmZvXCIsXG4gICAgXCJldGhmcy5ibG9nc3BvdC5jb21cIixcbiAgICBcImJsb2dnZXJjb20uaW5mb1wiLFxuICAgIFwibmJsb2dpei5ibG9nc3BvdC5jb21cIixcbiAgICBcInNlY3VyZTIuZXRocmV3YXJkaW5nLmNvbVwiLFxuICAgIFwiYmlnY3J5cHRvZ2lmdC5vcmdcIixcbiAgICBcIm11ZGl1bS54eXpcIixcbiAgICBcImV0aGVyZXVtLWdpZnQuc2l0ZVwiLFxuICAgIFwiY2xhaW1ldGguaW5mb1wiLFxuICAgIFwiZ28uZXRoc2VjLnVzXCIsXG4gICAgXCJldGhzZWMudXNcIixcbiAgICBcImV0aC1jbGFpbS5wd1wiLFxuICAgIFwieG4tLXRyb25zY24tbXdhLmNvbVwiLFxuICAgIFwidHJvbi1zY2FuLmluZm9cIixcbiAgICBcImV0aGVyZXVtLWZvdW5kYXRpb24uaW5mb1wiLFxuICAgIFwiYmlnY3J5cHRvZ2lmdC5pbmZvXCIsXG4gICAgXCJjbGFpbS1iaW5hbmNlLmNvbVwiLFxuICAgIFwiYml0Y2FzaG91dC53aXhzaXRlLmNvbVwiLFxuICAgIFwiZ2V0LnNhZmVwYXljcnlwdG8uY29tXCIsXG4gICAgXCJzYWZlcGF5Y3J5cHRvLmNvbVwiLFxuICAgIFwiYWV0ZXJuaXR5LmNsaWNrXCIsXG4gICAgXCJhaXJkcm9wLWV2ZW50LndlYnNpdGVcIixcbiAgICBcImNsYWltZXRoMTAuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcImNyeXB0b3ByaXplLmluXCIsXG4gICAgXCJjb2luYmFzZS50eC1wcjAuY29tXCIsXG4gICAgXCJ0eC1wcjAuY29tXCIsXG4gICAgXCJleHBsb3JldHJhbnNhY3Rpb25zLmluZm9cIixcbiAgICBcImJpbmFoY2UubmV0XCIsXG4gICAgXCJibG9ja2NuYWxoLmNvbVwiLFxuICAgIFwiYmxvY2tjbmFsbi5jb21cIixcbiAgICBcImJpaGFoY2UubmV0XCIsXG4gICAgXCJiaW9ja2NoYWluLmNvXCIsXG4gICAgXCJibHQtbWV4LmNvbVwiLFxuICAgIFwia3Vlb2luLmNvbVwiLFxuICAgIFwiYml0dHJlcS5jb21cIixcbiAgICBcImJqb2NrY2hhaW4uY29tXCIsXG4gICAgXCJibG9ja2NoYW0uY29tXCIsXG4gICAgXCJibG9ja2NsbmFtLmNvbVwiLFxuICAgIFwibWF5dGhlcndhbGxldC5jb21cIixcbiAgICBcImJqb2NrY2hham4uY29tXCIsXG4gICAgXCJleG1pdS5jb21cIixcbiAgICBcImt1cW9pbi5jb21cIixcbiAgICBcIm55ZXRoZXJtYWxsZXQuY29tXCIsXG4gICAgXCJwb2lvbmxleC5jb21cIixcbiAgICBcImJsdHRpbmV4LmNvbVwiLFxuICAgIFwibXlldG5lcm1hbGxldC5jb21cIixcbiAgICBcImJpZXRtZXguY29tXCIsXG4gICAgXCJrdWNvaWVuLmNvbVwiLFxuICAgIFwia3Vjb2Vpbi5jb21cIixcbiAgICBcInZlcmlmeS4xMDAwMGV0aC5wcm9cIixcbiAgICBcIjEwMDAwZXRoLnByb1wiLFxuICAgIFwiZXRoLXR3aXR0ZXIuY29tXCIsXG4gICAgXCJldGhjYXAuaW5mb1wiLFxuICAgIFwiZ2lmdC1wcm9tby53ei5jelwiLFxuICAgIFwidml0ZDEuaW5mb1wiLFxuICAgIFwicmVibG9naXouYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJwcm9tby1ldGhlci5vcmdcIixcbiAgICBcImV0aGVyZXVtLXByb21vLm5ldFwiLFxuICAgIFwiZXRoZXJldW1wcm9tby5ldVwiLFxuICAgIFwiZ2V0LmJpZ2NyeXB0b2dpZnQuY29tXCIsXG4gICAgXCJiaWdjcnlwdG9naWZ0LmNvbVwiLFxuICAgIFwiZXhjaGFuZ2VzLmNsYWltc1wiLFxuICAgIFwiYnRjLXByb21vLnhmLmN6XCIsXG4gICAgXCJldGhwcm9tb2dpdmluZy5jb21cIixcbiAgICBcImV0aHByb21vZ2l2aW5nLm5ldFwiLFxuICAgIFwiZXRocHJvbW9zZW5kLm5ldFwiLFxuICAgIFwiZXRocHJvbW9kb25hdGUuY29tXCIsXG4gICAgXCJldGhwcm9tb2dpdmUuaW5mb1wiLFxuICAgIFwiZXRocHJvbW9nZXQuaW5mb1wiLFxuICAgIFwiZXRocHJvbW90YWtlLmluZm9cIixcbiAgICBcImV0aHByb21vZ2l2ZW5vdy5pbmZvXCIsXG4gICAgXCJ0aGVldGhwcm9tb2dpdmUuaW5mb1wiLFxuICAgIFwiZXRocHJvbW9naXZpbmcuaW5mb1wiLFxuICAgIFwiZXRocHJvbW8tZ2l2ZS5vcmdcIixcbiAgICBcImV0aHByb21vZ2l2ZS5vcmdcIixcbiAgICBcImV0aHByb21vZ2V0Lm9yZ1wiLFxuICAgIFwiZXRodHcuaW5mb1wiLFxuICAgIFwiZXRoZXJ0YWtlLm9yZ1wiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZWF3YXkuY3p3ZWIub3JnXCIsXG4gICAgXCJldGhzaGlmdC53ZWJzaXRlXCIsXG4gICAgXCJnYXRoZXJldGguY29tXCIsXG4gICAgXCJodWdlZHJvcC5ldVwiLFxuICAgIFwiZXRocHJvbW8tZ2l2ZS5pbmZvXCIsXG4gICAgXCJlbG9ubXVzay5yYWNpbmdcIixcbiAgICBcImhpdGJ0Yy5jY1wiLFxuICAgIFwiaGl0Yi10Y28uY29tXCIsXG4gICAgXCJteWV0aGVydnZhbGxldC5wd1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jby56YVwiLFxuICAgIFwibXlldGhlcndhbGxldHQuZmhhcHAueHl6XCIsXG4gICAgXCJ3ZWItYmluYW5jZS5jb21cIixcbiAgICBcInhuLS1iaXR0cnh4LXZ5YS5jb21cIixcbiAgICBcIm1lbW9uZXJvLmNvXCIsXG4gICAgXCJ3YWxsZXR2ZXJpZnkuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20ud2FsbGV0dmVyaWZ5LmluZm9cIixcbiAgICBcIm15ZXRoZXJ3d2xsZXQuZ2l0aHViLmlvXCIsXG4gICAgXCJldGgtc2VjdXJlLnRvcFwiLFxuICAgIFwiZnJlZXRva2Vucy5vbmxpbmVcIixcbiAgICBcImV0aGVyLXByb21vLmJpelwiLFxuICAgIFwibWVkaXVtLWV0aGVyLWJsb2cuaW5mb1wiLFxuICAgIFwiZXRoLXJldHVybi1ub3cuYm9yZWMuY3pcIixcbiAgICBcImV0aGVhc3lkcm9wLmV1XCIsXG4gICAgXCJuZXctbXlldGhld2FsbGV0LTFhLmNvbVwiLFxuICAgIFwibWV3ZXdhbGxldC5pbmZvXCIsXG4gICAgXCJlbGVjdHJ1bXdhbGxldC5pb1wiLFxuICAgIFwiYmluYW5jZS1jb20ub25saW5lXCIsXG4gICAgXCJzaGFwZXNoaWZsdC5jb21cIixcbiAgICBcImJpZmZyZXguY29tXCIsXG4gICAgXCJiaXR0cmV4bi5jb21cIixcbiAgICBcInNoYXBlc2hpZnRldS5jb21cIixcbiAgICBcImV0aGVybXl3YWxsZXQuY29tXCIsXG4gICAgXCJob21lLW15ZXRoZXJ3YWxsYXQuY29tXCIsXG4gICAgXCJob21lLW15ZXRoZXJ3YWxsYXQudG9wXCIsXG4gICAgXCJpZGV4LnNwYWNlXCIsXG4gICAgXCJpbGRleC5tYXJrZXRcIixcbiAgICBcIm1haWwubXlldGhlZm9yd2FsbGV0LmNvbVwiLFxuICAgIFwibWplaGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXllbHRoZXJ3YWxsZXQucHdcIixcbiAgICBcIm15ZXRoZXJldW13YWxsZXQubmV0XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ2VuLnNwYWNlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS1vbWlzZWdvLmNvbVwiLFxuICAgIFwibXlldG5lbHdhbGxldC5jb21cIixcbiAgICBcIm15ZXRuZWx3YWxsZXQub25saW5lXCIsXG4gICAgXCJ3YWxsZXQuaWRleC5zcGFjZVwiLFxuICAgIFwid2VibWFpbC5teWVsdGhlcndhbGxldC5wd1wiLFxuICAgIFwieG4tLWRleC1tbWEubWFya2V0XCIsXG4gICAgXCJiZXN0Y2hhZ25lLmNvbVwiLFxuICAgIFwiYmlmdGluZXgub3JnXCIsXG4gICAgXCJteWVodGVyd2VsbGV0Lm9yZ1wiLFxuICAgIFwiZXRoY2xhaW0udG9wXCIsXG4gICAgXCJiaXR0cmV4LW4uY29tXCIsXG4gICAgXCJldGgtYWlyZHJvcC5iaXpcIixcbiAgICBcImV0aGZzLmluZm9cIixcbiAgICBcImV0aGVyLWdpdmUtYmluYW5jZS5jb21cIixcbiAgICBcInRha2UucmVhbGNyeXB0b2dpZnQuY29tXCIsXG4gICAgXCJyZWFsY3J5cHRvZ2lmdC5jb21cIixcbiAgICBcImV0aGVyLWFpcmRyb3AuaW5mb1wiLFxuICAgIFwiZXRoZXJldW1hY3Rpb24uZXVcIixcbiAgICBcImV0aGVyLWFpcmRyb3AuYml6XCIsXG4gICAgXCJtZWRpdW0tZXRoZXItYmxvZy5iaXpcIixcbiAgICBcImluZm8tbGl2ZS1iaW5hbmNlLmNvbVwiLFxuICAgIFwid3VzZC5jZlwiLFxuICAgIFwiYmluYW1lZGl1bS5ibG9nc3BvdC5jb21cIixcbiAgICBcIm15ZXRoZXJ2dmVsbGV0Lm5ldFwiLFxuICAgIFwiY29pbmJhc2UtbmV3cy50dW1ibHIuY29tXCIsXG4gICAgXCJleGNoYW5nZXRoLm9ubGluZVwiLFxuICAgIFwiaG9tZS1teWV0aGVyd2FsbGF0LmluZm9cIixcbiAgICBcImV0aGdldGJvbnVzLmV1XCIsXG4gICAgXCJldGgtb2ZmaWNpYWwuY2xhaW1zXCIsXG4gICAgXCJldGhyZXN1bHRzLmluZm9cIixcbiAgICBcImV0aGVyZXVtZHJvcC5ldVwiLFxuICAgIFwiZ28uZXRoZ2Z0LnBhcnR5XCIsXG4gICAgXCJldGhnZnQucGFydHlcIixcbiAgICBcInNhZmVzY2xhaW0uaW5mb1wiLFxuICAgIFwiZXRoZXJldW0tYWlyZHJvcC5iaXpcIixcbiAgICBcImdpdmUtYXdheS53aW5cIixcbiAgICBcImdpdmVhd2F5LWNvaW5iYXNlLmNsdWJcIixcbiAgICBcImV0aGVyc2Nhbi5zcGFjZVwiLFxuICAgIFwiYmlubWVkaXVtLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tY2xhaW0ucnVcIixcbiAgICBcImNvaW5iYXNlLWdpZnQudHVtYmxyLmNvbVwiLFxuICAgIFwibWVkaXVtLW5ld3MuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJtdXNrLWFpci5vcmdcIixcbiAgICBcInNhZmUtY2xhaW1zLmluZm9cIixcbiAgICBcImJpdHN0YW1wLnB3XCIsXG4gICAgXCJiaW5hbmNlLXdlYi5jb21cIixcbiAgICBcImV0aC1jbHViLmNsdWJcIixcbiAgICBcImV0aGdpdmluZy4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwibWVkaXVtYXBwLm9yZ1wiLFxuICAgIFwiZXRocHJvbW9zZW5kLmNvbVwiLFxuICAgIFwiZXRoNTAwMC5pblwiLFxuICAgIFwiY29pbm15ZXRoZXJzLm9vb1wiLFxuICAgIFwiYmluYW5jZS1leGNoYW5nZS51cGRvZy5jb1wiLFxuICAgIFwieG4tLXlldGhlcmFsbGV0LXR2OGVzN2EuY29tXCIsXG4gICAgXCJldGhib251cy5ldVwiLFxuICAgIFwib21pc2Vxby5uZXR3b3JrXCIsXG4gICAgXCJzbWFydGNvbnRyYWN0LTUwMDAuc3BhY2VcIixcbiAgICBcIm1lZGl1bS1ibG9nLWFpcmRyb3AuaW5mb1wiLFxuICAgIFwiYWlyZHJvcC1ldGgubmV0XCIsXG4gICAgXCJibG9nLWNvaW5iYXNlLnR1bWJsci5jb21cIixcbiAgICBcImdpdmVhd2F5LWNvaW5iYXNlLnRvcFwiLFxuICAgIFwiZWxvbi1tdXNrLnRlYW1cIixcbiAgICBcIm11c2stc2hhcmUuaW5mb1wiLFxuICAgIFwiY3J5cHRvLXByb21vLmN6d2ViLm9yZ1wiLFxuICAgIFwiY29pbmJhcy1lc2lnbmluLmNvbVwiLFxuICAgIFwiZWUtbXlldGhlcndhbGxldC11bi5jb21cIixcbiAgICBcIm15ZWh0ZXJ3YWxsZXRlLmNvbVwiLFxuICAgIFwibXlldGhlcnZ2YWxsbGV0dC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuYXBpMjAuaWN1XCIsXG4gICAgXCJteWV0aGZvcmt3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGlyd2FsaWV0LmluZm9cIixcbiAgICBcImJpdHRyZXgtc2lnaW4uY29tXCIsXG4gICAgXCJzYWZlLmp1c3RnZXRldGguY29tXCIsXG4gICAgXCJwcm9tb3Rpb24tZXRoLm5ldFwiLFxuICAgIFwiZXRoLWFpcmRyb3AuaW5mb1wiLFxuICAgIFwibWVkaXVybi5wcmVzc1wiLFxuICAgIFwiZXRoZXJldW0xMDAwMC5wcmVzc1wiLFxuICAgIFwic2l0ZS1iaW5hbmNlLmNvXCIsXG4gICAgXCJiaXR0cmV4dXAuY29tXCIsXG4gICAgXCJnaXZlYXdheS1ldGhlcmV1bS50b3BcIixcbiAgICBcInNtYXJ0c2VudC5zcGFjZVwiLFxuICAgIFwiZ2l2ZWF3YXktZXRoLnR1bWJsci5jb21cIixcbiAgICBcIm1lZGl1bS1ldGgubmV0XCIsXG4gICAgXCJldGhlci1naXZlYXdheS50b3BcIixcbiAgICBcImFpcmRyb3AuY3JlZGl0XCIsXG4gICAgXCJtdXNrLXNoYXJlLmNvbVwiLFxuICAgIFwibXVldGh3YWl0dC5pbmZvXCIsXG4gICAgXCJnaXZlYXdheS54Zi5jelwiLFxuICAgIFwiYml0dHJleC1ici5jb21cIixcbiAgICBcImFjY291bnRzLWJsb2NrY2hhaW4uaW5mb1wiLFxuICAgIFwiYmluYW5jZS5jb204NzY1NDg5Ny5tbFwiLFxuICAgIFwiY29tODc2NTQ4OTcubWxcIixcbiAgICBcImJpbmFuY2UtaW4uY29tXCIsXG4gICAgXCJuZWN0cmFja2VyLmNvXCIsXG4gICAgXCJteWV0aGVydnZhbGxldC5vcmdcIixcbiAgICBcImV0aGVyZXVtMTAwMDAud2Vic2l0ZVwiLFxuICAgIFwieG4tLWR4LWVqYW8ubWFya2V0XCIsXG4gICAgXCJldGhjaGFuZ2Uub25saW5lXCIsXG4gICAgXCJpZGV4LWxvZ2lpbi5jb21cIixcbiAgICBcIm15ZXRoZXJ3ZWxsaWV0Lm5ldFwiLFxuICAgIFwibXl0aGVyd2FpbGV0LmluZm9cIixcbiAgICBcIm15ZWh0ZXJ2dmFsbGlldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3ZWxsZXQub3JnXCIsXG4gICAgXCJrcmFrZW4tdHIuY29tXCIsXG4gICAgXCJrcmFrZW4tbG9nbi5jb21cIixcbiAgICBcImtyYWtlbi1zaWdpbi5jb20ucnVcIixcbiAgICBcImFwaS1iaW5hbmNlLmNvXCIsXG4gICAgXCJiaW5hbmNlLmNvbS5ldGgtYm9udXMubWVcIixcbiAgICBcImV0aC1ib251cy5tZVwiLFxuICAgIFwiZWxvbi1tdXNrLmNvbXBhbnlcIixcbiAgICBcInNhZmUtZXRoLmluZm9cIixcbiAgICBcInByb21vdGlvbi1ldGguY29tXCIsXG4gICAgXCJ0cm9uaWNzLnVwZG9nLmNvXCIsXG4gICAgXCJiaW5hbmNlLnVwZG9nLmNvXCIsXG4gICAgXCJhaXJkcm9wLWV0aGVyLmluZm9cIixcbiAgICBcIm1lZGl1bS1ibG9nLWV0aGVyZXVtLm9yZ1wiLFxuICAgIFwiZ28uZXRocGF5cy51c1wiLFxuICAgIFwiY29pbmJhc2VzcHJvbW8udHVtYmxyLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tYXdhcmQudG9wXCIsXG4gICAgXCJjcnlwdG95b2Rhcy50dW1ibHIuY29tXCIsXG4gICAgXCJwcm9tby5ldGh4LnNpdGVcIixcbiAgICBcImV0aHguc2l0ZVwiLFxuICAgIFwic2VuZC50b2tlbnByb21vLnNpdGVcIixcbiAgICBcInRva2VucHJvbW8uc2l0ZVwiLFxuICAgIFwiZXRoZXJldW1wcml6ZS5ldVwiLFxuICAgIFwiNTAwMGV0aGVyZXVtLmluXCIsXG4gICAgXCJldGhiaW5hbmNlLmluZm9cIixcbiAgICBcImV0aG9mZmljaWFsLjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJtZWRpdW0tZXRoLmNvbVwiLFxuICAgIFwicHJvbW90aW9uLWV0aC5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWJvZ2dldGhlci50dW1ibHIuY29tXCIsXG4gICAgXCJwcm9tby5ldGhnZnQudXNcIixcbiAgICBcImJlZXRocHJvbW9naXZlLmNvbVwiLFxuICAgIFwic2FmZS5jb25maXJtZXRoLmNvbVwiLFxuICAgIFwiY29uZmlybWV0aC5jb21cIixcbiAgICBcInByb21vLnRva2VucHJvbW8uc2l0ZVwiLFxuICAgIFwiYXJrYmxvY2submV0XCIsXG4gICAgXCJjYmFzZS1wcm8uY29tXCIsXG4gICAgXCJldGhlcmV1bXByaXplLmlvXCIsXG4gICAgXCJhaXJkcm9wc3ZlcnQueHl6XCIsXG4gICAgXCJldGhlcml1bS5ob3N0XCIsXG4gICAgXCJjbGFpbWV0aC50b3BcIixcbiAgICBcIm1lZGl1bS5jb20ucnVcIixcbiAgICBcImV0aGVyaXVtLnByb1wiLFxuICAgIFwidGVzbGEubXlldGhlcmdldC5pbmZvXCIsXG4gICAgXCJteWV0aGVyZ2V0LmluZm9cIixcbiAgICBcImV0aHNlY3VyZS50b3BcIixcbiAgICBcImNvaW5zZHJvcC5vcmdcIixcbiAgICBcImJsb2dtZWRpdW1zLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiZXRoZXJldW1wcml6ZS5hcnRcIixcbiAgICBcImdldGV0aGVyZXVtMjAwLjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJzYWZlLnNoYXJpbmdldGguY29tXCIsXG4gICAgXCJzaGFyaW5nZXRoLmNvbVwiLFxuICAgIFwibWVkaXVtLWJsb2ctZXRoZXJldW0ubmV0XCIsXG4gICAgXCJldGhlcmV1bS1haXJkcm9wLm5ldFwiLFxuICAgIFwiZXRoLWJvbnVzLWJpbmFuY2UuY29tXCIsXG4gICAgXCJjem9mZmljaWFsLnNpdGVcIixcbiAgICBcImV0aGljby5pbmZvXCIsXG4gICAgXCJlbG9uLXN1cnByaXNlLnNpdGVcIixcbiAgICBcInhuLS15ZXRoZXJhbGxldC10djhldTZhLmNvbVwiLFxuICAgIFwiZXRoLXNhZmUuaW5mb1wiLFxuICAgIFwiZWxvbi1tdXNrLnNpdGVcIixcbiAgICBcImV0aG9mZmljaWFsLnNpdGVcIixcbiAgICBcImJlc3Rwcm9tby5vbmxpbmVcIixcbiAgICBcImNyeXB0by1naXZlYXdheS50b3BcIixcbiAgICBcImFpcmRyb3AtZXRoZXIuY29tXCIsXG4gICAgXCJtZWRpdW0tYmxvZy1ldGhlcmV1bS5pbmZvXCIsXG4gICAgXCJldGhwcm9tb2dpdmVncm91cC5uZXRcIixcbiAgICBcImlkZXh3YWxsLm9ubGluZVwiLFxuICAgIFwibXV5dGhlcndhbGxldC5pbmZvXCIsXG4gICAgXCJteWV0aGVyeXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoaXJ3YWxpZS5pbmZvXCIsXG4gICAgXCJteWV0aGlyd2FsaWUueHl6XCIsXG4gICAgXCJteWV0aHdhbGxldC5jb21cIixcbiAgICBcInhuLS1vbWlzZWctdWw4Yi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZS02cWI0Mjc4Zy5jb21cIixcbiAgICBcIm15ZWh0ZXJ3ZWxsaWV0LmNvbVwiLFxuICAgIFwibWFpbC5teWV3dGhlcndhbGxldC5wd1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uaXAxMS5pY3VcIixcbiAgICBcImlwMTEuaWN1XCIsXG4gICAgXCJldGhjb2luLnN0b3JlXCIsXG4gICAgXCJrcmFsa2VtLmNvbVwiLFxuICAgIFwiYmxvY2tjaGFsaW0uaW5mb1wiLFxuICAgIFwibmVvLXRyYWNsZXIuY29cIixcbiAgICBcImFwcC1iaXR0cmV4LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXdhbGxldC5vcmdcIixcbiAgICBcIm15ZXRoZXJ2dmFsbGV0Lm5ldFwiLFxuICAgIFwid215ZXRoZXJ3YWxsZXQucHdcIixcbiAgICBcInhuLS1ibmFuYy1yNTFiemUuY29tXCIsXG4gICAgXCJ5Y2JpdC5uZXRcIixcbiAgICBcImt1Y2Npbi5jb21cIixcbiAgICBcImxuaXRidGMuY29tXCIsXG4gICAgXCJ3d3ctbnljcnlxdG8uY29tXCIsXG4gICAgXCJ3d3ctbnljcnlwdG9zLmNvbVwiLFxuICAgIFwiZ28uZXRoZXJzLnB3XCIsXG4gICAgXCJldGhlcnMucHdcIixcbiAgICBcImFpcmRyb3Bib3guc2l0ZVwiLFxuICAgIFwiZXRoZXJlc2Nhbi5uZXRcIixcbiAgICBcInRyYW5zYWN0aW9uLnN0YXR1cy1ldGgudG9wXCIsXG4gICAgXCJtZWRpdW1ibG9nLnRvZGF5XCIsXG4gICAgXCJldGhlcmV1bS1naXZlYXdheS50b3BcIixcbiAgICBcImV0aGVyZXVtLWFpcmRvcC5jb21cIixcbiAgICBcIm1lZGl1bS1ibG9ncG9zdC5pbmZvXCIsXG4gICAgXCJib251cy5zdGF0dXMtZXRoLnRvcFwiLFxuICAgIFwic3RhdHVzLWV0aC50b3BcIixcbiAgICBcImV0aGVyZXVtLnNtYXJ0LmNvbnRyYWN0Lm15ZWx0aGVyd2FsbGV0Lm1sXCIsXG4gICAgXCJteWVsdGhlcndhbGxldC5tbFwiLFxuICAgIFwibGVsZWN0cnVtLmNvbVwiLFxuICAgIFwiZ2V0LjEwa2V0aC5jb21cIixcbiAgICBcIjEwa2V0aC5jb21cIixcbiAgICBcImFpcmRyb3AtdG9rZW4ud2Vic2l0ZVwiLFxuICAgIFwiZXRodmVudC5uZXRcIixcbiAgICBcImV0aGNsYWltLmxpdmVcIixcbiAgICBcImNsYWltLnN0YXR1cy1ldGgudG9wXCIsXG4gICAgXCJnY294MDg2LmNvbVwiLFxuICAgIFwiZ2NveGtvcmVhLmNvbVwiLFxuICAgIFwibXktZm9sbG93ZXJzLm1sXCIsXG4gICAgXCJtYXJrZXQtaWRleC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnZlcmlmaWNhdGlvbi5tdmtjYXRlcmVyLmNvbVwiLFxuICAgIFwiYmluYW5jZXByb21vcy50eXBlZm9ybS5jb21cIixcbiAgICBcImJsaW92bmFybmNlLmNvbVwiLFxuICAgIFwibWV5aGZlcndhbGxldC5jb21cIixcbiAgICBcImV0aGVyZXVtLWdpdmVhd2F5LnRlY2hcIixcbiAgICBcImJpbmdtb25jZXMuY29tXCIsXG4gICAgXCJldGhjbGFpbS5pbmZvXCIsXG4gICAgXCJldGhnaWZ0b25saW5lLmNvbVwiLFxuICAgIFwiZXRoZXIuYmxvZ21lZGl1bS50b3BcIixcbiAgICBcImJuYi5tZWRpdW0tYWlyLm9yZ1wiLFxuICAgIFwibWVkaXVtLWFpci5vcmdcIixcbiAgICBcImV0aGVyLWFpcmRyb3Aud2Vic2l0ZVwiLFxuICAgIFwiZ2l2ZWF3YXkuZXRoZXItY2xhaW0ub3JnXCIsXG4gICAgXCJldGhlci1jbGFpbS5vcmdcIixcbiAgICBcImdpZnRzZm9yeW91Lm9ubGluZVwiLFxuICAgIFwiY29pbnNwcml6ZS5vcmdcIixcbiAgICBcImV0aGVyZXVtd2luLmluXCIsXG4gICAgXCJzbWFydC1ldGgtY29udHJhY3Quc2l0ZVwiLFxuICAgIFwic2FmZWM0MTk0NC5uaWNob3N0LnJ1XCIsXG4gICAgXCJpZGUteC5tYXJrZXRcIixcbiAgICBcImlkZXgtbWFya2V0LmNvbVwiLFxuICAgIFwiaWRleC5uZXR3b3JrXCIsXG4gICAgXCJpZGV4Y2hhbmdlLmluZm9cIixcbiAgICBcImlkZXhjb3JwLmRvd25sb2FkXCIsXG4gICAgXCJpZGxleC5tYXJrZXRcIixcbiAgICBcImlkd3gubWFya2V0XCIsXG4gICAgXCJpaWJleC5tYXJrZXRcIixcbiAgICBcImlpZGV4Lm1hcmtldFwiLFxuICAgIFwibXlldGhlcndhbGV0LmdhXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWluZm8uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXRva2Vucy5jb21cIixcbiAgICBcIm15ZXRoZXJ3b2xldC5ncVwiLFxuICAgIFwib21nLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJzdGlja2FtZ2ZzLmNvbVwiLFxuICAgIFwic2FmZWNsYWltcy5zcGFjZVwiLFxuICAgIFwic2FmZWNsYWltcy5uZXRcIixcbiAgICBcIm15ZXRoZ2lmdC5uZXRcIixcbiAgICBcIm9mZmljaWFsLmV0aHgxMC5jb21cIixcbiAgICBcImV0aHgxMC5jb21cIixcbiAgICBcImV0aGVyLWFpcmRyb3Aub3JnXCIsXG4gICAgXCJlbG9uLWdpdmVhd2F5Lm9yZ1wiLFxuICAgIFwibXllaHRlcndhaWxsZXQuY29tXCIsXG4gICAgXCJ0cm9uLWdpZnQuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJkdWJhaS1vaWxjb3JwLmNvbXBhbnlcIixcbiAgICBcInhuLS15ZXRoZXJhbGxldC1pdzhldzVhLmNvbVwiLFxuICAgIFwiYmpsdHRyZXguY29tXCIsXG4gICAgXCJibG9jcmtjaGVpbi5jb21cIixcbiAgICBcImxvZ2luLmJsb2Nya2NoZWluLmNvbVwiLFxuICAgIFwiYmxyb2NrY2hlaW4uY29tXCIsXG4gICAgXCJsb2dpbi5ibHJvY2tjaGVpbi5jb21cIixcbiAgICBcImV4cm5vLnN1XCIsXG4gICAgXCJnYXRlcmh1Yi5uZXRcIixcbiAgICBcInNpZ25pbi5nYXRlcmh1Yi5uZXRcIixcbiAgICBcImt1Y2lvcm4uY29tXCIsXG4gICAgXCJsaGl0ZHRjLmNvbVwiLFxuICAgIFwibGtyYWxrZW4uY29tXCIsXG4gICAgXCJwb2xvbnJlaXguY29tXCIsXG4gICAgXCJ5b2JpcnQubmV0XCIsXG4gICAgXCJmb3JrZGVsdGEuYml6XCIsXG4gICAgXCJodHRwcy1teWV0aGVyd2FsbGV0Lm5ldFwiLFxuICAgIFwiZXRoZXJkZWl0YS50b3BcIixcbiAgICBcImV0aGVyZGVpdGEuc2l0ZVwiLFxuICAgIFwibXlldGhlcnZ2YWxsZXQucnVcIixcbiAgICBcIm15ZXRoZXJ2dmFsbGV0LnRvcFwiLFxuICAgIFwibXlldGhpZXJ3YWxldC5jb21cIixcbiAgICBcIm15ZXRocHJvbW9naXZlLmNvbVwiLFxuICAgIFwibXlldGhpcnZ2YWxlLmluZm9cIixcbiAgICBcImxiaW5hbnJjZS5jb21cIixcbiAgICBcIm1lZGV1bS1haXJkcm9wLW5ld3MuY29tXCIsXG4gICAgXCJldGhlcmV1bS10cmFuc2Zlci5uZXRcIixcbiAgICBcInNhZmVjbGFpbS5pbmZvXCIsXG4gICAgXCJ0ZXNsYS1naXZlYXdheS5nZXRmb3JnZS5pb1wiLFxuICAgIFwiZXRoLmdldGZvcmdlLmlvXCIsXG4gICAgXCJlbG9uLW11c2suZnVuXCIsXG4gICAgXCJnZXRldGhmcmVlLmNvbVwiLFxuICAgIFwiYWlyZHJvcC1ldmVudC5zaXRlXCIsXG4gICAgXCJ4bi0tbWV0aGV3YWxsZXQtNjM4ZTk1ZS5jb21cIixcbiAgICBcImJpZ2V0aGVyZXVtLm9yZ1wiLFxuICAgIFwiZ2lmdG9mZXRoLmluZm9cIixcbiAgICBcImNyeXB0by1wcm9tby53ZWJzaXRlXCIsXG4gICAgXCJldGhkcm9wLmluXCIsXG4gICAgXCJldGhpbnZlc3RpbmcuaW5mb1wiLFxuICAgIFwibmV3c21lZGl1bS5pbmZvXCIsXG4gICAgXCJibmIubmV3c21lZGl1bS5pbmZvXCIsXG4gICAgXCJtZWRpdW12ZXJ0Lnh5elwiLFxuICAgIFwiZ2V0ZXRoZXJub3cudG9wXCIsXG4gICAgXCJ2ZWNoYWlueC5uZXRcIixcbiAgICBcImhhZGljYS5jb21cIixcbiAgICBcImdvYXN0cmEuZ2FcIixcbiAgICBcImpheC14LmNvbVwiLFxuICAgIFwibWZvdW5kYXRpb24uY2ZcIixcbiAgICBcIm15ZXRoZWF0cndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ0YXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaTEyLmljdVwiLFxuICAgIFwiYXBpMTIuaWN1XCIsXG4gICAgXCJ4bi0tZXRlcmV1bS15dDNjLmNvbVwiLFxuICAgIFwibXlldGhlcnV3bGxlZXQuc2l0ZVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2lnbm1zZy5hcGkxMS5pY3VcIixcbiAgICBcImFwaTExLmljdVwiLFxuICAgIFwibXlldHp3YWxsZXQuY29tXCIsXG4gICAgXCJhcm9udW0uY29tXCIsXG4gICAgXCJ2ZWNoYWlueC5pb1wiLFxuICAgIFwiZXRoZXJkcm9wLnRvcFwiLFxuICAgIFwiYnRjZHJvcC5pblwiLFxuICAgIFwicHJvbW8tY2xhaW1zLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uYXBpMTAuaWN1XCIsXG4gICAgXCJhcGkxMC5pY3VcIixcbiAgICBcImV0aGVyLWdhdGhlci5jb21cIixcbiAgICBcInNhZmVjbGFpbXMuaW5mb1wiLFxuICAgIFwiZXRodmVyaWZ5LmluZm9cIixcbiAgICBcImVsb24tbXVzay5vcmdcIixcbiAgICBcImV0aGVyZXVtZmFzdC5pb1wiLFxuICAgIFwidHJvbi1naWZ0cy5ibG9nc3BvdC5jb21cIixcbiAgICBcImV0aGVyZXVtc3dhbGxldC5jb21cIixcbiAgICBcImV0aGVyZXVtd2FsbGV0cy5jb21cIixcbiAgICBcIm15ZWxoZXJ3YWxsZWwuaW5mb1wiLFxuICAgIFwibXlldGhlcnV3YWxsZWV0LnNpdGVcIixcbiAgICBcIm15ZXRoZXJ1d2xsZWV0LndlYnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaTExLmljdVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uYXBpOC5pY3VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaTkuaWN1XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnR2XCIsXG4gICAgXCJteWV0aGVyd2VsbGVpdC5jb21cIixcbiAgICBcIm15ZXRoZXJ3ZWxsaWV0LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tcHJvbW90aW9uLm9yZ1wiLFxuICAgIFwiZXRobW9yZS5pb1wiLFxuICAgIFwib2ZmaWNpYWwtcHJvbW90aW9uLm9yZ1wiLFxuICAgIFwiYWlyZHJvcHNldGguaW5mb1wiLFxuICAgIFwibWVkaXVtLWFpcmRyb3AtcHJvbW8uY29tXCIsXG4gICAgXCJldGhlcmV1bS1haXJkcm9wLm9yZ1wiLFxuICAgIFwiYWlyLWRyb3Aub3JnXCIsXG4gICAgXCJldGhlcmV1bS1yZXR1cm4udG9wXCIsXG4gICAgXCJldGhlcmV1bS1wcm9tb3Rpb24ud2Vic2l0ZVwiLFxuICAgIFwia3Jha2VuLWl4ei5jb21cIixcbiAgICBcImtyYWtlbi1jaGVjay5jb21cIixcbiAgICBcImFpcmRyb3BzLmRlbGl2ZXJ5XCIsXG4gICAgXCJidXpvdmFjb2luLmlvXCIsXG4gICAgXCJidXotY29pbi5pb1wiLFxuICAgIFwiYnV6Y29pbmlvLmNvbVwiLFxuICAgIFwiY2x1YmV0aC5saXZlXCIsXG4gICAgXCJjbHViYnRjLmxpdmVcIixcbiAgICBcImJpbmFuY2Utb2ZmaWNpYWwuY29tXCIsXG4gICAgXCJzaGFwZXNoaWZ0LWV4Y2hhbmdlLmlvXCIsXG4gICAgXCJteWV0aGdpZnQuY29tXCIsXG4gICAgXCJ2aWV3LXdhbGxlbC5pbmZvXCIsXG4gICAgXCJjYXJsaWZ0Y2F0YWxvZy5zaXRlXCIsXG4gICAgXCJodm1vZWNqcHhuLmluZm9cIixcbiAgICBcImlkZXguaW1cIixcbiAgICBcImlkZXguc2l0ZVwiLFxuICAgIFwibGRleC5zdVwiLFxuICAgIFwibGRleGNoYW5nZS5pbmZvXCIsXG4gICAgXCJteWVoZXJ3YWxsZWwuaW5mb1wiLFxuICAgIFwibXlldGhlcnV2dmFsbGVldC5jb21cIixcbiAgICBcIm15ZXRoZXJ1dnZhbGxlZXQuc2l0ZVwiLFxuICAgIFwibXlldGhlcnV2dmFsbGVldC53ZWJzaXRlXCIsXG4gICAgXCJteWV0aGVydXZ2YWxsZWV0Lnh5elwiLFxuICAgIFwibXlldGhlcnZ2YWxsZS5pbmZvXCIsXG4gICAgXCJteWV0aGVydnZhbGxlLnRvcFwiLFxuICAgIFwibXVldGhlcmVzd2FsbGV0LmNvbVwiLFxuICAgIFwibXllZXRoZXJ3YWxsZXRzLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20udmVyaWZpY2F0aW9uLmNvaGVuY3Vlcy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tcGFueVwiLFxuICAgIFwibXlldGhlcndvbGV0LnVzXCIsXG4gICAgXCJteXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJ0b3BiaXQuaW5mb1wiLFxuICAgIFwiZ2l2ZWF3YXktcHJvbW8ubmV0XCIsXG4gICAgXCJldGgtcHJvLmNvLm5mXCIsXG4gICAgXCJibG9rY2tjaGlhbi5jb21cIixcbiAgICBcImNvaW5iYXNlbG9naW4uY29tLnJ1XCIsXG4gICAgXCJodWIueG4tLW15dGVyd2FsbGV0LTNxYjkwODdnLmNvbVwiLFxuICAgIFwiYmluY29uYXJuY2UuY29tXCIsXG4gICAgXCJiaW5jb25hbWNlLmNvbVwiLFxuICAgIFwiaGl0YnRjLm1vYmlcIixcbiAgICBcImtyYWtlbi1wb3J0YWwuY29tXCIsXG4gICAgXCJrcmFrZW4tdmFsaWRhdGlvbi5jb21cIixcbiAgICBcImdyYWJldGguY2ZcIixcbiAgICBcImVvcy1haXJkcm9wLmluZm9cIixcbiAgICBcImV0aGVyLWNsYWltLmNvbVwiLFxuICAgIFwibXlldGhlcnZhbGxldC4wMDB3ZWJob3N0YXBwLmNvbVwiLFxuICAgIFwibXlldGhlcnV2dmFsZXQuY29tXCIsXG4gICAgXCJtYWlsLm15bmV0aGVyd2FsbGV0LnNpdGVcIixcbiAgICBcIm15Y3J5cnB0dG8uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hcGk3LmljdVwiLFxuICAgIFwibXlldGhlcndsbGFldC5jb21cIixcbiAgICBcIm15bmV0aGVyd2FsbGV0Lm1pbmluZzI0LmluZm9cIixcbiAgICBcIm15bmV0aGVyd2FsbGV0LnNpdGVcIixcbiAgICBcInhuLS1pZGV4LXVwYS5tYXJrZXRcIixcbiAgICBcImZhbnRvbS1mb3VuZGF0aW9uLmRlXCIsXG4gICAgXCJiaW5jb21hbmNlLmNvbVwiLFxuICAgIFwia3Jha2VuLWF1dGhlbnRpY2F0aW9uLmNvbVwiLFxuICAgIFwia3Jha2VuLXdlLmNvbVwiLFxuICAgIFwia3Jha2VuLWl4LmNvbVwiLFxuICAgIFwia3Jha2VuLW9uLmNvbVwiLFxuICAgIFwiYmluYW5jZS12YWxpZGF0aW9uLmNvbVwiLFxuICAgIFwiZXRoZXJzZHJvcC5vbmxpbmVcIixcbiAgICBcImV0aGRyb3AudG9wXCIsXG4gICAgXCJlbG9uLW11c2sucHJvbW9cIixcbiAgICBcImNyeXB0b2NhbmRpZXMudXBkb2cuY29cIixcbiAgICBcImVsb24tZ2lmdC5jbHViXCIsXG4gICAgXCJlbG9uLWdpZnQuaW5mb1wiLFxuICAgIFwiZXRoZXItZnJlZS50ZWNoXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNvaW5zLnNwYWNlXCIsXG4gICAgXCJ0cm9uLXByZXNlbnRzLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYWlyZHJvcGV0aC5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNvaW5zcy5zcGFjZVwiLFxuICAgIFwiYmxvdnJuYW5jZS5jb21cIixcbiAgICBcImJpbmdtYW5jb2wuY29tXCIsXG4gICAgXCJibmJuZXdzLm9yZ1wiLFxuICAgIFwiYnRjZHJvcC50b3BcIixcbiAgICBcImpvaG5tY2FmZWUucHJvbW9cIixcbiAgICBcInNhZmUuZ2V0YmVzdGV0aC5jb21cIixcbiAgICBcImdldGJlc3RldGguY29tXCIsXG4gICAgXCJtZWRpdW1ibG9nc290LnRvcFwiLFxuICAgIFwiYmlmbG5leC5jb21cIixcbiAgICBcImJsZmluZXguY29tXCIsXG4gICAgXCJiaW5hbmNlLWFwcC5jb21cIixcbiAgICBcImJpbmFuY2UtY2x1Yi5jb21cIixcbiAgICBcImJpbmFuY2UtY29pbnMuY29tXCIsXG4gICAgXCJiaW5hbmNlLWRheXRyYWRpbmcuY29tXCIsXG4gICAgXCJiaW5hbmNlLWV0aGguY29tXCIsXG4gICAgXCJiaW5hbmNlLW1hcmtldC5jb21cIixcbiAgICBcImJpbmFuY2VwLmNvbVwiLFxuICAgIFwiaHR0cHMtYmluYW5jZS5jb21cIixcbiAgICBcIm0tYmluYW5jZS5jb21cIixcbiAgICBcInBheS1iaW5hbmNlLmNvbVwiLFxuICAgIFwic2l0ZS1iaW5hbmNlLmNvbVwiLFxuICAgIFwieG4tLWlkZXgtdnBhLm1hcmtldFwiLFxuICAgIFwiZXRoLWdpdmVhd2F5LnNwYWNlXCIsXG4gICAgXCJjbGFpbXByaXplLnh5elwiLFxuICAgIFwiZXRoZXJldW0tdHJhbnNmZXIuY29tXCIsXG4gICAgXCJldGhmYXN0LnRvcFwiLFxuICAgIFwibWVkaXVtLXByb21vLmNvbVwiLFxuICAgIFwiYmV0YWNsaWVudC13YnRjZ3dhcC5jZlwiLFxuICAgIFwiZXRoYm9udXMtYmluYW5jZS5jb21cIixcbiAgICBcImZhc3QuZ2V0ZXRoZXIueHl6XCIsXG4gICAgXCJnZXRldGhlci54eXpcIixcbiAgICBcImJ0Y2JvbnVzLWJpbmFuY2UuY29tXCIsXG4gICAgXCJteS1jcnktcHRvLmNvbVwiLFxuICAgIFwibXllcnRoZXdhbGxldC5jb21cIixcbiAgICBcIm15ZXJ0aGV3YWxsZXQuaG9zc3Rpbmdlci5pbmZvXCIsXG4gICAgXCJteWV0aGFld2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhhZXdhbGxldDEuaG9zc3Rpbmdlci5pbmZvXCIsXG4gICAgXCJteS1jcnlwdG8uY29tXCIsXG4gICAgXCJrdWNpb3JuLmhvc3N0aW5nZXIuaW5mb1wiLFxuICAgIFwibGhpdGxidGMuaG9zc3Rpbmdlci5pbmZvXCIsXG4gICAgXCJzaGFwZXNoaWZ0LWV4Y2hhbmdlLm9ubGluZVwiLFxuICAgIFwic2hhcGVzaGxmdC5uZXRcIixcbiAgICBcImZnY29pbi5pb1wiLFxuICAgIFwiZXZvdHJ1c3RsbGMuY29tXCIsXG4gICAgXCJqb2huLW1jYWZlZS5jb21cIixcbiAgICBcImFtYXp5LWV0aC5jb21cIixcbiAgICBcImV0aC1kcm9wLmlvXCIsXG4gICAgXCJldGhlcm1vbmUuaW5mb1wiLFxuICAgIFwiZXRocHJvbW9zLmluZm9cIixcbiAgICBcIm15Y3lycHR0by5jb21cIixcbiAgICBcImJsZ2VtLmJsb2dzcG90LmNvbVwiLFxuICAgIFwiYWlyZHJvcC5kZWxpdmVyeVwiLFxuICAgIFwiZ2l2ZWF3YXlvZmZpY2lhbC5pbmZvXCIsXG4gICAgXCJldGgtYmluYW5jZS5jb21cIixcbiAgICBcImV0aGdvbGRtaW4uY29tXCIsXG4gICAgXCJ0YWtlLWV0aC53ZWJzaXRlXCIsXG4gICAgXCJzYWZlLmVhcm5ldGhub3cuY29tXCIsXG4gICAgXCJlYXJuZXRobm93LmNvbVwiLFxuICAgIFwibXlldG5lcndhbGxldC5jb20uY2hlY2tiYWxhbmNlLmluZm9cIixcbiAgICBcImNoZWNrYmFsYW5jZS5pbmZvXCIsXG4gICAgXCJhdXRvZGlzY292ZXIubXlldGhlcndhaWxldC5jZlwiLFxuICAgIFwiYmluYW5jZS1ob21lLmNvbVwiLFxuICAgIFwiYmluYW5jZS5kZWxpdmVyeVwiLFxuICAgIFwiYml0ZmlsaW5leC5jb21cIixcbiAgICBcImJpdGZpbmV4Lm1lLnVrXCIsXG4gICAgXCJjcGFuZWwubXlldGhlcndhaWxldC5jZlwiLFxuICAgIFwibWFpbC5teWV0aGVyd2FpbGV0LmNmXCIsXG4gICAgXCJtYWlsLm15ZXRoZXJ3YWxsZXQuaWN1XCIsXG4gICAgXCJteWV0aGVyd2FpbGV0LmNmXCIsXG4gICAgXCJteWV0aGVyd2FsZXQud2F0Y2hmdWxsbW92aWUuZG93bmxvYWRcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXJ0Lm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldC1jbGljay5kYXRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNsaWNrLmxvYW5cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtb25saW5lLmRvd25sb2FkXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmljdVwiLFxuICAgIFwibXlldGhlcndhbGxldC5taW5pbmcyNC5pbmZvXCIsXG4gICAgXCJ3ZWJkaXNrLm15ZXRoZXJ3YWlsZXQuY2ZcIixcbiAgICBcIndlYm1haWwubXlldGhlcndhaWxldC5jZlwiLFxuICAgIFwiZXRoY3J5cHRvY29tcC5jeFwiLFxuICAgIFwiZXRocHJvbW91aS5jb21cIixcbiAgICBcImV0aHByb21vbm93LmNvbVwiLFxuICAgIFwiZXRoLWdpdmUtYXdheS1wcm9tby5jb21cIixcbiAgICBcImV0aC1wcm9tby1naXZlLWF3YXkuY29tXCIsXG4gICAgXCJldGgtcHJvbm9naXZlLmNvbVwiLFxuICAgIFwiZXRoLXByb21vc2dpdmV4LmNvbVwiLFxuICAgIFwiZXRocHJhbWVuZ2l2ZS5jb21cIixcbiAgICBcImV0LWdpLm5ldFwiLFxuICAgIFwiZ2V0ZXRoZXJldW1mb3JmcmVlLmNvbVwiLFxuICAgIFwiaWRleC1tYXJrZXQuYml6LnBsXCIsXG4gICAgXCJtZWRpdW0taGl0YnRjLnR1bWJsci5jb21cIixcbiAgICBcImV0aGVyZXVtLXJldHVybi5jb21cIixcbiAgICBcImJ0Yy1iaW5hbmNlLmNvbVwiLFxuICAgIFwiZGVzY2VudHguY29tXCIsXG4gICAgXCJldGgtYXdheS5jb21cIixcbiAgICBcInRoZWV0aHByb21vZ2l2ZS5uZXRcIixcbiAgICBcImV0aHByb21vdGFrZS5uZXRcIixcbiAgICBcImV0aHByb21vZ2l2ZW5vdy5uZXRcIixcbiAgICBcImV0aHByb21vZ2V0Lm5ldFwiLFxuICAgIFwiZXRocHJvbW9naXZlY2FyZS5jb21cIixcbiAgICBcImV0aG5ld3Byb21vLmNvbVwiLFxuICAgIFwiYWV0aHByb21vZ2l2ZS5jb21cIixcbiAgICBcInJlY2VpdmVldGhwcm9tby5jeFwiLFxuICAgIFwiZXRoLXByb21vc2dpdmUuY29tXCIsXG4gICAgXCJldGgtcHJvbW91aS5jb21cIixcbiAgICBcImVsb24tbXVzay5tZVwiLFxuICAgIFwiZXRoLXByb21vLWF3YXl4LmNvbVwiLFxuICAgIFwiZXRocHJvbW8tZ2l2ZS5jb21cIixcbiAgICBcImV0aC1wcm9ub3NnaXZlLmNvbVwiLFxuICAgIFwicmVjZWl2ZWV0aGZyZWUuY3hcIixcbiAgICBcImV0aHBvb2xjb21wZXQuY3hcIixcbiAgICBcImNvaW5sZWZ0Lm9yZ1wiLFxuICAgIFwiYmxvZ21lZGl1bS50a1wiLFxuICAgIFwiMjA5LjE1OS4xNTQuMTU2XCIsXG4gICAgXCJpZGV4LW1hcmtldC50cmFkZVwiLFxuICAgIFwianVzdGluc3VuLnByb21vXCIsXG4gICAgXCJldHRlcmV1bS5pbmZvXCIsXG4gICAgXCJiaW5hbmFjZS5zaXplbWVkaXVtLnRvcFwiLFxuICAgIFwic2l6ZW1lZGl1bS50b3BcIixcbiAgICBcImV0aGVyd2FsbGV0LmFkYW1sdXZzaGlzLmNvbVwiLFxuICAgIFwibXllbGhlcndhbHRldC5pbmZvXCIsXG4gICAgXCJteWV0aGVpd2FsbGV0dC5jb21cIixcbiAgICBcIm15ZXRoZXItdnZhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJldW1zd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxlZXQub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0di5vcmdcIixcbiAgICBcIm15bW9uZWVyby5jb21cIixcbiAgICBcIm15c2V0aGVyd2FsbGVkLmNsdWJcIixcbiAgICBcInRvdGFseS1teWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwieW91cmV0aGVyd2FsbGV0Lm5ldFwiLFxuICAgIFwibXlldGhlcndhbGxldC1oeWRyb3NpZ24uc3BhY2VcIixcbiAgICBcImRhaWx5Y3VycmVuY3kucHJvbW9cIixcbiAgICBcImNsYWltc2FmZS5vcmdcIixcbiAgICBcIm11c2stcHJlc2VudC5ibG9nc3BvdC5jb21cIixcbiAgICBcImJpbmFuY2UtZ2V0LmNsYWltc1wiLFxuICAgIFwiZG9kb2ZseWVyLmNvbVwiLFxuICAgIFwiZXRoLXRyYW5zZmVyLmNvbVwiLFxuICAgIFwic2F2ZXRva2VuLm9yZ1wiLFxuICAgIFwiZm9sbG93ZXJzLXNwZWNpYWwubWxcIixcbiAgICBcImdpdmVhd2F5LmV0aGVyZXVtLXByb21vLmNvbVwiLFxuICAgIFwiY2xhaW1wcml6ZS5vcmdcIixcbiAgICBcImVvc2dhcy5uZXRcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaTYuaWN1XCIsXG4gICAgXCJhcGk2LmljdVwiLFxuICAgIFwiYXBpNy5pY3VcIixcbiAgICBcImFwaTguaWN1XCIsXG4gICAgXCJhcGk5LmljdVwiLFxuICAgIFwiYXBpMTAudWljdVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uYXBpNS5pY3VcIixcbiAgICBcImFwaTUuaWN1XCIsXG4gICAgXCJudWV0aGVyaXVtbGxldC5jb21cIixcbiAgICBcIm15ZWxoZXJ2dmFsZXQuY29tXCIsXG4gICAgXCJzZW9zaXRlc3dvcmxkLm9ubGluZVwiLFxuICAgIFwiZ2V0LWV0aGVyZXVtLm5ldFwiLFxuICAgIFwiZW9zZ2FzLmNvXCIsXG4gICAgXCJhcGk0LmljdVwiLFxuICAgIFwiYWlyZHJvcHMucHJvbW9cIixcbiAgICBcImJpbmFuY2UuY2xhaW1zXCIsXG4gICAgXCJ2ZXJpZnkubWVkaXVtcHJvbW9zLnRvcFwiLFxuICAgIFwibWVkaXVtcHJvbW9zLnRvcFwiLFxuICAgIFwic2FmZWNyeXB0Lm5ldFwiLFxuICAgIFwiYmluYW5jZS1jbGFpbXMuY29tXCIsXG4gICAgXCJtZWRpdW0tcHJvbW90aW9ucy5jb21cIixcbiAgICBcInByaXplLWV0aC5jb21cIixcbiAgICBcImV0aHNhZmUucHJvbW9cIixcbiAgICBcImV0aHByZXNlbnQuaW9cIixcbiAgICBcImdpdmVjb2lucy5pbmZvXCIsXG4gICAgXCJtdXNrLW9mZmljaWFsLXByb21vLmNvbVwiLFxuICAgIFwiY29pbnNhaXIub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hcGkucm9vdDMuaWN1XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hcGkzLmljdVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uYXBpNC5pY3VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnJvb3Q0LmljdVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2lnbmludmVyaWNhdGlvbi5rYXJhb2tla2lyYWxhbWEuY2x1YlwiLFxuICAgIFwibXlldGhyd2VsbGxldC5uZXRcIixcbiAgICBcInhuLS1teWN5cHRvLXhsZC5jb21cIixcbiAgICBcInhuLS1teWNycHRvLThpNGMuY29tXCIsXG4gICAgXCJ4bi0tbWNyeXB0by01aTRjLmNvbVwiLFxuICAgIFwieG4tLWMxYXJoaGRpZGMuY29tXCIsXG4gICAgXCJ4bi0teWNyeXB0by11ejNjLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxlLWpiOWUuY29tXCIsXG4gICAgXCJwcm9tby5ldGhlcnBheS5zaXRlXCIsXG4gICAgXCJldGhlcnBheS5zaXRlXCIsXG4gICAgXCJibmItdG9rZW4ub3JnXCIsXG4gICAgXCJibG9nLm1lZGl1bXByb21vLnRvcFwiLFxuICAgIFwibWVkaXVtLXByb21vdGlvbi5jb21cIixcbiAgICBcImVvc2dhcy5pb1wiLFxuICAgIFwiaW50ZXJuYXRpb25hbHN0dWR5Lm9ubGluZVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20ucm9vdDUuaWN1XCIsXG4gICAgXCJyb290NS5pY3VcIixcbiAgICBcImlkZWl4Lm1hcmtldFwiLFxuICAgIFwiaWRleC1mcmVlLm9ubGluZVwiLFxuICAgIFwiaWRleHdhbGxldC5jb21cIixcbiAgICBcIm1leXRoZXJ3YWxldHQuY29tXCIsXG4gICAgXCJteWVmaGVlcndhbGxldC5jb21cIixcbiAgICBcIm15ZWZoZXJ3YWxsZXR0LmNvbVwiLFxuICAgIFwibXllaHRjcndhbGxldHQuY29tXCIsXG4gICAgXCJteWVsaGVyd2FsZXQuaW5mb1wiLFxuICAgIFwibXlldGZlcndhbGxldHQuY29tXCIsXG4gICAgXCJteWV0aGFyd2FsbGV0dC5jb21cIixcbiAgICBcIm15ZXRoZWVyd2FsZXQuY29tXCIsXG4gICAgXCJteWV0aGVpcndhbGxldHQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5zaWduaW52ZXJpY2F0aW9uLnNpZ25tZXNzYWdlLmthcmFva2VraXJhbGFtYS5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS52ZXJpZmljYXRpb24ua2FyYW9rZXNlcGV0aS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLndhbGxldHZlcmlmaWNhdGlvbi5rYXJkZXNsZXJndW51LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5tZW5cIixcbiAgICBcIm15ZXRoZXJ3YXlsbGV0LmNvbVwiLFxuICAgIFwibXlldGhyYXdhbGxldHQuY29tXCIsXG4gICAgXCJteWV0aHJldnZhbGxldC5jb21cIixcbiAgICBcImJpdGZhbmV4LmNvbVwiLFxuICAgIFwiaWRleC1tYXJrZXQucGhcIixcbiAgICBcImlkZXgtbWFya2V0LmNvbS5ydVwiLFxuICAgIFwiaWRleC5jb20udWFcIixcbiAgICBcImlkZXgtbWFya2VmLm9yZ1wiLFxuICAgIFwiaWRleHgtY29ycGNvbS5jb20ucGhcIixcbiAgICBcImlkZXgtbWFya2VmLmlvXCIsXG4gICAgXCJpZGV4LW1hcmtldC5jaFwiLFxuICAgIFwiaWRleC1tYXJrZXQuY2x1YlwiLFxuICAgIFwiaWRleC1tYXJrZXQuYml6XCIsXG4gICAgXCJpZGV4aHViLm1hcmtldFwiLFxuICAgIFwiaWRleG1hcmt0LmRlXCIsXG4gICAgXCJpZGV4LWFwcC5zdG9yZVwiLFxuICAgIFwiZ2l2ZWF3YXktYmluYW5jZS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtY29pbmluLnRvcFwiLFxuICAgIFwibWVkaXVtLXByb21vLnRvcFwiLFxuICAgIFwiZXRoZXJldW1jbGFpbS5uZXRcIixcbiAgICBcImV0aGVzY2FuLmluZm9cIixcbiAgICBcInZlcmlmeS5nZXRiaWdldGguY29tXCIsXG4gICAgXCJnZXRiaWdldGguY29tXCIsXG4gICAgXCJiaW5hbmNlLmJuYi10b2tlbi5zYWxlXCIsXG4gICAgXCJibmItdG9rZW4uc2FsZVwiLFxuICAgIFwib2tleGdpdmVhd2F5LmNvbVwiLFxuICAgIFwiaGl0YnRjLnN0cmVhbVwiLFxuICAgIFwicHJvbW9oaXRidGMud2Vic2l0ZVwiLFxuICAgIFwiaGl0YnRjLmx0ZFwiLFxuICAgIFwiZW4taGl0YnRjLmNvbVwiLFxuICAgIFwiaGl0YnRjLmljdVwiLFxuICAgIFwiaGl0YnRjLm9vb1wiLFxuICAgIFwiaGl0YnRjc3VwcG9ydC5jb1wiLFxuICAgIFwiaGl0YnRjLmF0XCIsXG4gICAgXCJoaXRidGNjaGFpbi5jb21cIixcbiAgICBcImhpdGJ0Y3N1cHBvcnQuc2l0ZVwiLFxuICAgIFwiaGl0YnRjLWFkcy5jb21cIixcbiAgICBcImhpdGJ0Yy1pbC5jb21cIixcbiAgICBcImhpdGJ0Yy1vbi5jb21cIixcbiAgICBcImhpdGJ0LmNvXCIsXG4gICAgXCJibGFjay13YWxsZXQuY29cIixcbiAgICBcImRhaWx5Y3VycmVuY3kubWxcIixcbiAgICBcImV0aGdpdmV3YXlwcm9tby5pbmZvXCIsXG4gICAgXCJ4bi0tZXRoZXJlbS15MjRjLmNvbVwiLFxuICAgIFwic3RlbGxhci13LmNvbVwiLFxuICAgIFwiYml0ZmluZXguaW1cIixcbiAgICBcImlkZXgtbWFya3Qtcm9vc2VuLWdtYmguY29tXCIsXG4gICAgXCJpZGV4LW1hcmtldC5tZVwiLFxuICAgIFwiaWNsZXgtbWFya2V0LmNvbVwiLFxuICAgIFwieG4tLWRleC1tYXJrZXQtNThhLmNvbVwiLFxuICAgIFwiaWRleC1tYXJrZXR0LmNvbVwiLFxuICAgIFwidmVyaWZ5LmV0aGVyZXVtbm93LnRvcFwiLFxuICAgIFwiZXRoZXJldW1ub3cudG9wXCIsXG4gICAgXCJzb2NpYWxsLm9vb1wiLFxuICAgIFwiZXRoZXItZ2lmdC53ZWJzaXRlXCIsXG4gICAgXCJhdXRob3JpemUtdHJhbnNmZXIuZHJvcHBhZ2VzLmNvbVwiLFxuICAgIFwibG9naW4tYmluYW5jZS5jb21cIixcbiAgICBcImF1dGhoaXRidGMuY29tXCIsXG4gICAgXCJobHRidGMuY2FtXCIsXG4gICAgXCJoaWl0ZHRjLmNvbVwiLFxuICAgIFwiZ2V0ZXRoZXJub3cub3JnXCIsXG4gICAgXCJiaW5hbmNlLWFjZXNzLmNvbVwiLFxuICAgIFwib2ZmaWNpYWxhaXJkcm9wLmNvbVwiLFxuICAgIFwiZXRoLWV2ZW50LmNvbVwiLFxuICAgIFwiZXRoY2xvc2UuaW5mb1wiLFxuICAgIFwiZnJlZWNvaW5kcm9wLmNvbVwiLFxuICAgIFwibXllZXRoZXJ3YWxsZXQuZ2FcIixcbiAgICBcIm15ZWh0bGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnJ3YWxsZXQuZ2FcIixcbiAgICBcIm15ZXRoZXJzd2FsbGVpdC50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtY29pbnNpZ24udG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnBhcnR5XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Lndpbi1ldGgub3JnXCIsXG4gICAgXCJteWV0aHJlcmV3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aHJ3YWxsZXQudG9wXCIsXG4gICAgXCJteWxldGhlcndhbGxldGVzLmNvbVwiLFxuICAgIFwibXlsZXRoZXJ3YWxsZXRzLmNvbVwiLFxuICAgIFwiY29pbnNzYWZlLm9yZ1wiLFxuICAgIFwiaWRleC5ncm91cFwiLFxuICAgIFwibWNhZmVlLnByb21vXCIsXG4gICAgXCJldGg2MC50b3BcIixcbiAgICBcImdldGZyZWUtZXRoLm9yZ1wiLFxuICAgIFwidmF4eC5jb1wiLFxuICAgIFwiY3J5cHRvZXRoZXIuaW5mb1wiLFxuICAgIFwiY29pbmNhcGl0YWxzLm9yZ1wiLFxuICAgIFwiYm9uYW5jcmUuY29tXCIsXG4gICAgXCJsb2dpbi5ibG9ja2NoYWltLmNvXCIsXG4gICAgXCJibG9ja2NoYWltLmNvXCIsXG4gICAgXCJ0cmFuc2FjdGlvbmxpc3QuaW5mb1wiLFxuICAgIFwiaWRleHgtY29ycGNvbS5jb21cIixcbiAgICBcIm1ldGhlcndhbGxldC5pbmZvXCIsXG4gICAgXCJtZXl0aGVyd2FsbGV0ZS5jb21cIixcbiAgICBcIm15ZXJ0aGVyd3dlbGxldC5jb21cIixcbiAgICBcIm15ZXRmZXJ3YWxsZXRlLmNvbVwiLFxuICAgIFwibXlldGZlcndhbGxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWNvaW5sLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWduY29pbi50b3BcIixcbiAgICBcIm15ZXR0aGVyaXdhbGxldC53aW5cIixcbiAgICBcIm15aGVyaXdhbGxldC50cmFkZVwiLFxuICAgIFwibXltb2VuZXJvLmNvbVwiLFxuICAgIFwiYmxvY29rY2hhaW4udG9wXCIsXG4gICAgXCJ4bi0tYmluYW5jLW40YS5leGNoYW5nZVwiLFxuICAgIFwiaWRleC5tYXJrZXQudHJhbnNhY3Rsb24uaW5mb1wiLFxuICAgIFwidHJhbnNhY3Rsb24uaW5mb1wiLFxuICAgIFwiZ28uZXRoZXIxMDAwMC53aW5cIixcbiAgICBcImV0aDEwMDAwLndpblwiLFxuICAgIFwiYmRpbmFtY2UuY29tXCIsXG4gICAgXCJidXRlcmluZnJlZS5vcmdcIixcbiAgICBcInNhdG9zaGktZ2l2ZWF3YXkub3JnXCIsXG4gICAgXCJldmVudC1ldGgtZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJldGh6ZXJkZWx0YS5jb21cIixcbiAgICBcImZvcmtkZWx0YS5zdVwiLFxuICAgIFwiZm9ya2RlbHRhZ2l0aHViLmluZm9cIixcbiAgICBcIm15ZXRocmV3YWxsZXR0LmNvbVwiLFxuICAgIFwiZHhjaGFpbi5ldVwiLFxuICAgIFwid3d3LWJpdGZpbmV4LmNvbVwiLFxuICAgIFwiYmx2b25hbmNlLmNvbVwiLFxuICAgIFwiYWlyZHJvcC1ldmVudC5pbmZvXCIsXG4gICAgXCJjdXJyZW5jeS5wcm9tb1wiLFxuICAgIFwiY3pnaXZlLnNpdGVcIixcbiAgICBcInZlcmlmeS5ib251c2V0aC5pbmZvXCIsXG4gICAgXCJib251c2V0aC5pbmZvXCIsXG4gICAgXCJnZXQuYmlnZXRoZ2lmdC5jb21cIixcbiAgICBcImJpZ2V0aGdpZnQuY29tXCIsXG4gICAgXCJldGhzYWZlLmluZm9cIixcbiAgICBcImV0aG5ld3Byb21vYXdheS5jb21cIixcbiAgICBcImJ0Y2dpdmVhd2F5Lm9yZ1wiLFxuICAgIFwiYnRjcHJvbW9naXZlZ3JvdXAuY29tXCIsXG4gICAgXCJtZXRhbWFza3Byby5pb1wiLFxuICAgIFwiaWRleGNoYW5nZS5wcm9cIixcbiAgICBcIm15ZTFoZXJ3YWxsZXQuY29cIixcbiAgICBcIm15ZXRoZXJzd2FsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGVzLm5ldFwiLFxuICAgIFwibXlldGhlcndhbGxldC1yZWJsLnRvcFwiLFxuICAgIFwibXlldGxoZXJ3YWxsZS5jb21cIixcbiAgICBcIm15ZXRsaGVyd2FsbGUubXlldHRoZXJyd2FsbGV0dC5jb21cIixcbiAgICBcIm15bGV0aGVyd2FsbGV0ZXN0LmNvbVwiLFxuICAgIFwibXlsZXRoZXJ3YWxsZXRlc3QubXlldHRoZXJyd2FsbGV0dC5jb21cIixcbiAgICBcIm15bGV0aGVyd2FsbGV0cy5pbmZvXCIsXG4gICAgXCJteXZldGhlcndhbGxldC5jb21cIixcbiAgICBcImV0aGVyLWV2ZW50LmNvbVwiLFxuICAgIFwidy1lb3MuY29tXCIsXG4gICAgXCJpZGV4bWFya2V0Lm1lXCIsXG4gICAgXCJqb2hubWNhZmVlLmV0aGdpdmluZ3MubmV0XCIsXG4gICAgXCJldGhwYXlzOTkudG9wXCIsXG4gICAgXCJpZGV4LnByZXNzXCIsXG4gICAgXCJ0cm9uaWNzLnByb21vXCIsXG4gICAgXCJldGhnaXZlYXdheWdpZnQuaW5mb1wiLFxuICAgIFwiYmxvY2tjaGFpbmdpdmVhd2F5LmJpelwiLFxuICAgIFwiZXRoZXItYm9udXMubmV0XCIsXG4gICAgXCJ2aXRhbGlrZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJldGhlcmdpZnRub3cuY29tXCIsXG4gICAgXCJldGh0d2l0dGVyLm9yZ1wiLFxuICAgIFwiZWxvbi1ib3VudHkuYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJib3VudHktZXRoLmNvbVwiLFxuICAgIFwiYm91bnR5LWJ0Yy5jb21cIixcbiAgICBcImV0aDYwLmdldG15ZXRoLnRvcFwiLFxuICAgIFwiZ2V0bXlldGgudG9wXCIsXG4gICAgXCJtdXNrLW9mZmljaWFsLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwic2VjdXJlLmV0aGdpdmluZ3MubmV0XCIsXG4gICAgXCJteWVsdGhlcndhbGxlZXQuY29tXCIsXG4gICAgXCJteWVyaGVyd2VsbGV0LmNvbVwiLFxuICAgIFwibXllcnRoZXJ3d2VsbGV0Lm9ubGluZVwiLFxuICAgIFwibXllcnRoZXJ3d2VsbGV0LnNpdGVcIixcbiAgICBcIm15ZXJ0aGVyd3dlbGxldC5zcGFjZVwiLFxuICAgIFwibXlldGhlcnZhbGV0LmNmXCIsXG4gICAgXCJteWV0aGVydnVhbGxldC5jZlwiLFxuICAgIFwibXlldGhlcndlbGV0LmdhXCIsXG4gICAgXCJteWV0aGVyd2VsbGV0Lm1sXCIsXG4gICAgXCJteWV0aHJlcndhZWxsZXQuY29tXCIsXG4gICAgXCJteWV0dGhlcnJ3YWxsZXR0LmNvbVwiLFxuICAgIFwibXlld2h0ZXJhbGxldC5jb21cIixcbiAgICBcIm15ZXdodGVyYWxsZXQuaW5mb1wiLFxuICAgIFwibXlld2h0ZXJhbGxldC5uZXRcIixcbiAgICBcIm15ZXdodGVyYWxsZXQucHdcIixcbiAgICBcIm15d3RoZXJ3YWxpZXQuY29tXCIsXG4gICAgXCJpbmRleC1tYXJrZXR0LW5ldHdvcmsuY29tXCIsXG4gICAgXCJpZGV4bWFya2tldHNsb2dpbi5jb21cIixcbiAgICBcImlkZWV3ZWIxLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxlLm5ldFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zZW5kLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20udmVyaWZ5LmFwaXNpZ24ubWVcIixcbiAgICBcImVsb25tdXNrLmV0aGdpdmluZ3MubmV0XCIsXG4gICAgXCJldGhnaXZpbmdzLm5ldFwiLFxuICAgIFwicmVmdW5kY29udHJhY3QtZXRoZXJ3YWxsZXQubmV0XCIsXG4gICAgXCJpZGV4ci5tYXJrZXRcIixcbiAgICBcImF1dG9kaXNjb3Zlci5tdmV0aGVyd2FsbGV0Lm1sXCIsXG4gICAgXCJldGhlcndhbGxldC5ldGhzaWduLmljdVwiLFxuICAgIFwibXZldGhlcndhbGxldC5tbFwiLFxuICAgIFwibXlldGhlcndhbGxlZC51c1wiLFxuICAgIFwibXlldGhlcndhbGxlcy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtY29pbnMudG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ2VuLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaW5nbXNnLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC5jbi5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaXNpZ24ubWVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmVvcy1ib3VudHkuY29tXCIsXG4gICAgXCJteW1vbm9yby5jb21cIixcbiAgICBcIndlYmRpc2subXZldGhlcndhbGxldC5tbFwiLFxuICAgIFwid2FsbGV0aWNvLmNvbVwiLFxuICAgIFwiaWRpeG1hcmtldC5pbmZvXCIsXG4gICAgXCJjb2luYmFpc2UuY29tXCIsXG4gICAgXCJuZW90cmFjbGVyLmNvXCIsXG4gICAgXCJicmltYW5jZS5jb21cIixcbiAgICBcImJyaWxtYW5jZS5jb21cIixcbiAgICBcImJsaXJtYW5jZS5jb21cIixcbiAgICBcImJyaW5vbmNlLmNvbVwiLFxuICAgIFwiY2FzaGFhcHJpdmF0ZS5jb21cIixcbiAgICBcInNpZ25jb250cmFjdC1ldGhlcndhbGxldC5uZXRcIixcbiAgICBcImV0aGVyLWlkZXgub25saW5lXCIsXG4gICAgXCJtZWRpdW1wb3N0LmdhXCIsXG4gICAgXCJvY250b2tlbi5jb21cIixcbiAgICBcInJvb3RzaWduLmljdVwiLFxuICAgIFwiZXRoZXI0ZnJlZS5jb21cIixcbiAgICBcImdpdmVmcmVlY29pbi5jb21cIixcbiAgICBcImdpdmV1c2V0aGVyLmNvbVwiLFxuICAgIFwiZ2l2ZXVzZXRoZXJldW0uY29tXCIsXG4gICAgXCJwcm9tb2V0aGVybW5ldy5jb21cIixcbiAgICBcIm5ld2V0aHByb21vLmNvbVwiLFxuICAgIFwiZXRoLWdpdmVhdnZheS5jb21cIixcbiAgICBcImluc3RhbnQtZXRoYXdheS5jb21cIixcbiAgICBcImV0aHByb21vZ2V0LmNvbVwiLFxuICAgIFwidGhlZXRocHJvbW9naXZlLmNvbVwiLFxuICAgIFwiZXRocHJvbW9naXZlbm93LmNvbVwiLFxuICAgIFwiZXRocHJvbW8tZ2l2ZS1hd2F5LmNvbVwiLFxuICAgIFwiZXRocHJhbWVuZ3l2ZS5jb21cIixcbiAgICBcImV0aHByb21vdGFrZS5jb21cIixcbiAgICBcImV0aHByb21vLWdpdmUubmV0XCIsXG4gICAgXCJldGhwcm9tb2dpdmVncm91cC5jb21cIixcbiAgICBcImV0aHByb21vZ2l2ZS5uZXRcIixcbiAgICBcImV0aHByb21vZ2l2ZWJhY2suY29tXCIsXG4gICAgXCJtZ2V0aGVyd2FsbGxhdC5jb21cIixcbiAgICBcIm15YWV0aGVyd2FsbGV0Lm9yZ1wiLFxuICAgIFwibXllbGhlcndhbGxldC51c1wiLFxuICAgIFwibXllcmhlcndhbGxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVkd2FsbGlldC5pbmZvXCIsXG4gICAgXCJteWV0aGVyd2FsaWV0LmlvXCIsXG4gICAgXCJteWV0aGVyd2FsbGVkLmNsdWJcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQta3IuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC1zaW5uZy50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc3NpZ24udG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hcGkubXlldGhlcndhbGxldC5jb20udmVyaWZ5bXNnLmljdVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20ucm9vdHNpZ24uaWN1XCIsXG4gICAgXCJteWV0dGhlcml3YWxsZXRpLm1lblwiLFxuICAgIFwibXl0aGVyd2FsZXQuY29tXCIsXG4gICAgXCJ0b2tlbi1lbXJpZnkuY29tXCIsXG4gICAgXCJteWV0aHdhbGxvZmZpY2lpYWxsLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1oeWRyb2dlbi50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaXNpZ24uaWN1XCIsXG4gICAgXCJhcGlzaWduLmljdVwiLFxuICAgIFwiaHlkcm9nZW4tcGxhdGZvcm0uY29tXCIsXG4gICAgXCJiaXRwYXluZy50eXBlZm9ybS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR2ZXJpZmljYXRpb24uc2lnbm1zZy5zZXJ2aWNlc1wiLFxuICAgIFwic2lnbm1zZy5zZXJ2aWNlc1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2lnbmFwaS5pY3VcIixcbiAgICBcInNpZ25hcGkuaWN1XCIsXG4gICAgXCJpZGV4ZC5tYXJrZXRcIixcbiAgICBcImV0aGJvdW50eS5pbmZvXCIsXG4gICAgXCJlb3Nib3VudHkuY29cIixcbiAgICBcImV0aHByb21vdGlvbi5pbmZvXCIsXG4gICAgXCJzZWN1cmUuZXRoZ2lmdG5vdy5jb21cIixcbiAgICBcImJ0Y3Byb21vdGlvbi5pbmZvXCIsXG4gICAgXCJiZXRhY2xpZW50LXJ6Y29pbndhcHMuY2ZcIixcbiAgICBcImV0aG1vcmUubGl2ZVwiLFxuICAgIFwibXllaHRld2FsbGV0LmNvbVwiLFxuICAgIFwibWV5ZWh0ZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJpbmRleG1hcmtrZXQtc2l0ZS5jb21cIixcbiAgICBcImlkZXhuZXRvbmUuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS52ZXJpZnltc2cuaWN1XCIsXG4gICAgXCJ2ZXJpZnltc2cuaWN1XCIsXG4gICAgXCJldGhjb250cmFjdHMub3JnXCIsXG4gICAgXCJldGhkcm9wLmNvXCIsXG4gICAgXCJ0d2l0dGV0aHByb21vLmN4XCIsXG4gICAgXCJldGhhd2F5LWluc3RhbnQuY29tXCIsXG4gICAgXCJ0cngucHJvbW9cIixcbiAgICBcImV0aGNvbXBldC5jeFwiLFxuICAgIFwiZXRocmV3YXJkcy5jeFwiLFxuICAgIFwiY2xhaW15b3VyLWV0aC5vcmdcIixcbiAgICBcImV0aGNvbXBydWxlcy5jeFwiLFxuICAgIFwiZXRoZXJldW1wcm9tby53aW5cIixcbiAgICBcInNhZmUuZXRoZ2lmdG5vdy5jb21cIixcbiAgICBcImV0aGdpZnRub3cuY29tXCIsXG4gICAgXCJjbGFpbXlvdXItYnRjLm9yZ1wiLFxuICAgIFwiYnRjcHJvbW8ud2luXCIsXG4gICAgXCJldHRoZXJpd2FsbGV0LnRyYWRlXCIsXG4gICAgXCJnZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJtYWlsLm15ZXRoaWVyd2FsbGV0LmNvbVwiLFxuICAgIFwibWV5ZXRoZXJ3ZWFsbGV0ci5zcGFjZVwiLFxuICAgIFwibWpldGhlcndlbGxldC5jb21cIixcbiAgICBcIm15LWV0aGVyd2FsbGV0LnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZS5vbmxpbmVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZS50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZS54eXpcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtY29pbi50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaS5zaWdubXNncy5pY3VcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFzdHJvZnVuLmNvLmlsXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnNpZ25tc2cuc2VydmljZXNcIixcbiAgICBcIm15ZXRobHJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0dGhlcml3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0dGhlcndhbGxldC53aW5cIixcbiAgICBcIm15dGhlcndhbGxldHMuY29tXCIsXG4gICAgXCI1MDAwZXRoLWdpdmluZy5vbmxpbmVcIixcbiAgICBcImh5ZHJvZ2VuLXJhaW5kcm9wLmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJhaXJ0b2tlbi50eXBlZm9ybS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuZXRoZXJzaWdubXNnLnNlcnZpY2VzXCIsXG4gICAgXCJldGhlcnNpZ25tc2cuc2VydmljZXNcIixcbiAgICBcImlkZXgueHl6XCIsXG4gICAgXCJ0ZXNsYWdpZnRzLnR1bWJsci5jb21cIixcbiAgICBcImJyaW5hbm5jZS5jb21cIixcbiAgICBcImJpdHRyZXhsLmNvbVwiLFxuICAgIFwiZ2V0ZXRodG9kYXkuY29tXCIsXG4gICAgXCJzYWZlLmdldGV0aHRvZGF5LmNvbVwiLFxuICAgIFwiZWxvbi1mdW4uYmxvZ3Nwb3QuY29tXCIsXG4gICAgXCJjcnlwdG9saW5rbmV0LmNvbVwiLFxuICAgIFwiemlsbGlxYS5uYW1lXCIsXG4gICAgXCJqZW5uaWZlcmF1c3Rpbi50eXBlZm9ybS5jb21cIixcbiAgICBcIm9taXNlZ29jbGFzc2ljLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldC15azZmLmNvbVwiLFxuICAgIFwibXlldGhpZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJtaXlldGhlcndhbGxldC5jb21cIixcbiAgICBcInNpZ25tc2dzLmljdVwiLFxuICAgIFwibXllaHRyZXJ3YWxsZXR0LmNvbVwiLFxuICAgIFwiMWUtbXlldGhlcndhbGxldC16bi5jb21cIixcbiAgICBcImFuZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJhc2lhLWJpbmFuY2UuY29tXCIsXG4gICAgXCJjbGllbnQtY3J5cHRvLWJyaWRnZS5jb21cIixcbiAgICBcImNwYW5lbC5jbGllbnQtY3J5cHRvLWJyaWRnZS5jb21cIixcbiAgICBcImV0aGVyZXVtd2FsbGV0LmdkblwiLFxuICAgIFwiZXUtYmluYW5jZS5jb21cIixcbiAgICBcImxteWV0aGVyd2FsbGV0ci5jb21cIixcbiAgICBcImxvY2FsZXRoZXJ3YWxsZXQubmV0XCIsXG4gICAgXCJtYWlsLmNsaWVudC1jcnlwdG8tYnJpZGdlLmNvbVwiLFxuICAgIFwibWFpbC5teWV0aGVyd2FsaWxldC5jb21cIixcbiAgICBcIm1haWwubXlldGhlcndhbGxldHMuaW9cIixcbiAgICBcIm1leWV0aGVyd2VhbGxldHIub25saW5lXCIsXG4gICAgXCJtZXlodGVyd2FsbGV0dC5jb21cIixcbiAgICBcIm1qZXRoZXJ3YWxldC5jb21cIixcbiAgICBcIm1qZXRoZXJ3ZWxsbGV0LmNvbVwiLFxuICAgIFwibXZldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15LWV0aGVyd2FsbGV0LnRyYWRlXCIsXG4gICAgXCJteS1tb25lcmMuY29tXCIsXG4gICAgXCJteWFldGhlcndhbGV0LmNvbVwiLFxuICAgIFwibXljcnlpcHRvLmNvbVwiLFxuICAgIFwibXllYXRoZXJ3YWxpZXQuY29tXCIsXG4gICAgXCJteWVjdGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXllY3RoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWVodGNyd2FsbGV0LmNvbVwiLFxuICAgIFwibXllaHRlYXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWVodGVzd2FsbGV0LmNvbVwiLFxuICAgIFwibXllaXRoaWVyd2xsZXQuaW5mb1wiLFxuICAgIFwibXllaXRoaWVyd2xsZXQubmV0XCIsXG4gICAgXCJteWVsZmhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZWxoZXJ3YWxsZXQuc2l0ZVwiLFxuICAgIFwibXllbmR0aGVyd2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRlaGVyd2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRlaGVyd2FsbGV0Lm5ldFwiLFxuICAgIFwibXlldGVoZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJteWV0ZXJld2FsbGVkLmNvbVwiLFxuICAgIFwibXlldGVyd2FsbGVkLmNvbVwiLFxuICAgIFwibXlldGhhcndhbGxldC5tbFwiLFxuICAgIFwibXlldGhhcndvbGxldC5jb21cIixcbiAgICBcIm15ZXRoYXJ3b2xsbGV0LmNvbVwiLFxuICAgIFwibXlldGhkd2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRoZW5yd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXdhbGxldC12LmNvbVwiLFxuICAgIFwibXlldGhlcmV3YWxldC5pbmZvXCIsXG4gICAgXCJteWV0aGVyZXdhbGV0Lm5ldFwiLFxuICAgIFwibXlldGhlcmV3YWxsZWQuY29tXCIsXG4gICAgXCJteWV0aGVyZXdhbGxldHMuY29tXCIsXG4gICAgXCJteWV0aGVyaXdhbGV0LmRhdGVcIixcbiAgICBcIm15ZXRoZXJpd2FsbGV0LmNsdWJcIixcbiAgICBcIm15ZXRoZXJyd2FsbGF0LmNvXCIsXG4gICAgXCJteWV0aGVycndhbGxldC5jbHViXCIsXG4gICAgXCJteWV0aGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVydmFsZXQudXNcIixcbiAgICBcIm15ZXRoZXJ2YWxsZXQubmV0XCIsXG4gICAgXCJteWV0aGVydmVsbGV0LnVzXCIsXG4gICAgXCJteWV0aGVydnVhbGV0LnVzXCIsXG4gICAgXCJteWV0aGVydnVhbGxldC5wd1wiLFxuICAgIFwibXlldGhlcndhbGV0LnB3XCIsXG4gICAgXCJteWV0aGVyd2FsZXQuc3BhY2VcIixcbiAgICBcIm15ZXRoZXJ3YWxpZS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZS5vcmdcIixcbiAgICBcIm15ZXRoZXJ3YWxsZS5zdVwiLFxuICAgIFwibXlldGhlcndhbGxlZC5jZlwiLFxuICAgIFwibXlldGhlcndhbGxldC1jbGljay5kb3dubG9hZFwiLFxuICAgIFwibXlldGhlcndhbGxldC1mcmVlLmRvd25sb2FkXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWh5ZHJvLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1tZ3MudG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LW1zZy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbXNnLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1tc2dzaWduLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1vcGVuLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1vcGVuc2lnbi50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtb3BwZW4udG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ25pLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdubXNxLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdubi50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtc2lnbm9wZW4udG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpbmcudG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpbmdnLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC12ZXIudG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXZlcmlmZmljYXRpb24udG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXZlcmlmaWNhdGlvbi50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtdmVyaWZ5LnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC12ZXJyaWZpY2F0aW9uLnRvcFwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2lnbmludmVyaWNhdGlvbi5jbGFpbXRva2Vucy5uZXNla2FyYWFyc2xhbi5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNpZ25pbnZlcmljYXRpb24uc2lnbm1lc3NhZ2UubWVzdXRrYXJhYXJzbGFuLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2lnbm1zZ3MuaWN1XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnJlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnNjaG5laW1pLmRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnN5c3RlbXNcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRrLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldHMuaW9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRzLnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR0LmNsdWJcIixcbiAgICBcIm15ZXRoZXJ3YWxsbGV0cy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YXVsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndlbGV0LnB3XCIsXG4gICAgXCJteWV0aGVyd2VsbGV0LmNsdWJcIixcbiAgICBcIm15ZXRoZXJ3ZWxsZXQubmV0XCIsXG4gICAgXCJteWV0aGVyd2VsbGV0LnByZXNzXCIsXG4gICAgXCJteWV0aGVyd2VsbGxldC5uZXRcIixcbiAgICBcIm15ZXRoZXJ3b2xsZXQuZ2FcIixcbiAgICBcIm15ZXRoZXJ3b2xsZXQudXNcIixcbiAgICBcIm15ZXRoZXJ3b2xsbG90LmNvbVwiLFxuICAgIFwibXlldGhlc3dhbGxldC5jb21cIixcbiAgICBcIm15ZXRoaGVyd3dsbGV0LnNwYWNlXCIsXG4gICAgXCJteWV0aHJld2FsbGV0LmRlLmNvbVwiLFxuICAgIFwibXlldGhyd2FsaWV0LmluZm9cIixcbiAgICBcIm15ZXRocndhbHQuY29tXCIsXG4gICAgXCJteWV0aHJ3ZWxldC5jb21cIixcbiAgICBcIm15ZXRocndlbGV0Lm5ldFwiLFxuICAgIFwibXlldGhyd2VsbGV0LmNvbVwiLFxuICAgIFwibXlldGhyd2VsbGV0Lm5ldFwiLFxuICAgIFwibXlldGhyd2VsbGxldC5jb21cIixcbiAgICBcIm15ZXRoc3dhbGxldC5vcmdcIixcbiAgICBcIm15ZXRpaGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldG5lcndhaWxldC5pbmZvXCIsXG4gICAgXCJteWV0cmhlcndhbGxldHQuY29tXCIsXG4gICAgXCJteWV0c2hld2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXR0ZWFyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldHRlcndhbGxsZXQuY29tXCIsXG4gICAgXCJteWV0dGVyd2VsbGV0LmNvbVwiLFxuICAgIFwibXlldHRoZXJpd2FsbGV0dC5iaWRcIixcbiAgICBcIm15ZXR0aGVyaXdhbGxldHRpLm1lblwiLFxuICAgIFwibXlldHRoZXJ3YWxsZXQudHJhZGVcIixcbiAgICBcIm15bGV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXltb25hcm8uY29tXCIsXG4gICAgXCJteW1vbmVyYy5jb21cIixcbiAgICBcIm15bW9uZXJvLmV1XCIsXG4gICAgXCJteW1vbmVyby5pblwiLFxuICAgIFwibXltb3Jlcm8uY29tXCIsXG4gICAgXCJteW1vcm5lcm8uY29tXCIsXG4gICAgXCJteW1vcm5lcm8ubmV0XCIsXG4gICAgXCJteXBjcnlwdG8uY29tXCIsXG4gICAgXCJteXRlcndhbGxldC5pbmZvXCIsXG4gICAgXCJ3YWxsZXQuY3J5cHRvLWJyaWRnZS50b3BcIixcbiAgICBcIndlYmRpc2suY2xpZW50LWNyeXB0by1icmlkZ2UuY29tXCIsXG4gICAgXCJ3ZWJtYWlsLmNsaWVudC1jcnlwdG8tYnJpZGdlLmNvbVwiLFxuICAgIFwid3d3aWRleC5tYXJrZXRcIixcbiAgICBcIm15ZXRoZXJ3YWxpbGV0LmNvbVwiLFxuICAgIFwiZXRoZXJldW1wcm9tb3RlLndpeHNpdGUuY29tXCIsXG4gICAgXCJldGhnaXZlLmNsdWJcIixcbiAgICBcImV0aGVyY2xhaW1zMjIudG9wXCIsXG4gICAgXCJvZmZpY2lhbG1jYWZlZS5naXRodWIuaW9cIixcbiAgICBcImV0aDEwMDAwLm9yZ1wiLFxuICAgIFwic2FmZS5ldGgxMDAwMC5vcmdcIixcbiAgICBcImdpZnQtZXRoLm9yZ1wiLFxuICAgIFwiZXRob25saW5lLmlvXCIsXG4gICAgXCJtZXlldGhlcndlYWxsZXRyLnNpdGVcIixcbiAgICBcIm15ZXRoZXJ3YTFldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtdmlyaWZpY2F0aW9uc2lnbi50b3BcIixcbiAgICBcImZvcmtkZWx0YXMubmV0XCIsXG4gICAgXCJpZGV4YWlyZHJvcC5jb21cIixcbiAgICBcInNlY3VyZS5ldGhzb2ZmZXIuY29tXCIsXG4gICAgXCJldGhzb2ZmZXIuY29tXCIsXG4gICAgXCJldGhwcm9tby1naXZlYXdheS5hdHNwYWNlLmNjXCIsXG4gICAgXCJtZXlldGhlcndlYWxsZXRyLmNvbVwiLFxuICAgIFwibXllcmh0ZXJ3YWxsZXR0LmNvbVwiLFxuICAgIFwiZXRoY3J5cHRvcHJvbW9zLmNvbVwiLFxuICAgIFwiZXRoZXItZm91bmRhdGlvbi53ZWJzaXRlXCIsXG4gICAgXCJldGhvZmZpY2lhbC5uZXRcIixcbiAgICBcIm1lZGl1bS5ldGhlcmV1bWZvdW5kYXRpb24udG9wXCIsXG4gICAgXCJldGhlcmV1bWZvdW5kYXRpb24udG9wXCIsXG4gICAgXCJiaXR0cmNleC5jb21cIixcbiAgICBcImJpbmFuY2UucHJvbW90aW5nLndvcmxkXCIsXG4gICAgXCJwcm9tb3Rpbmcud29ybGRcIixcbiAgICBcImV0aGVyLXByb21vdGlvbi5pbmZvXCIsXG4gICAgXCJldmVudGV0aC5jb21cIixcbiAgICBcImJ0Y3Byb21vZnJlZS5jb21cIixcbiAgICBcImV0aGJvbnVzLm1lXCIsXG4gICAgXCJpZGV4LmdhXCIsXG4gICAgXCJiaW5hbnljZS5jb21cIixcbiAgICBcImxvZ2luLWJpbmFuY2UubmV0XCIsXG4gICAgXCJhZG1pbi5zYWZlLWV0aC50b3BcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNpZ25tZXNzYWdlLmljdVwiLFxuICAgIFwic2lnbm1lc3NhZ2UuaWN1XCIsXG4gICAgXCJyaXNlZXRoLmNvbVwiLFxuICAgIFwicG9rZXJib3guaW9cIixcbiAgICBcInBva2VyYm94YWlyZHJvcDEudHlwZWZvcm0uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hcGlzLmljdVwiLFxuICAgIFwiYXBpcy5pY3VcIixcbiAgICBcIm9mZmljaWFsLXByb21vLm9yZ1wiLFxuICAgIFwibW15ZXRsaGVyd2FsbGV0dC5jb21cIixcbiAgICBcIm15Y2h0ZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJldGhtb3JlLm5ldFwiLFxuICAgIFwiZWxlY3RydW5uLm9yZ1wiLFxuICAgIFwibXllaHRlcndhbGxjdC5jb21cIixcbiAgICBcImdldC5sb3Rzb2ZldGguY29tXCIsXG4gICAgXCJsb3Rzb2ZldGguY29tXCIsXG4gICAgXCJldGhjb3VudGRvd24uZ2FcIixcbiAgICBcImV0aHByb21vZnJlZS5jb21cIixcbiAgICBcInNwYXJrc3Rlci5jb20uZGVcIixcbiAgICBcImJ1dGVyaW5ldGgub3JnXCIsXG4gICAgXCJldGhlcmV1bS1wcm9tby53ZWJzaXRlXCIsXG4gICAgXCJteWVydG5lcndhbGxldHIuY29tXCIsXG4gICAgXCJteWV0aGVyd2VhbGxldHQuY29tXCIsXG4gICAgXCJpZGV4LnN1XCIsXG4gICAgXCJpbWV0YW1hc2suaW9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtbXNnZy50b3BcIixcbiAgICBcInRva2VuYXdheS5jb21cIixcbiAgICBcInRyb250b2tlbi50a1wiLFxuICAgIFwiYml0Y3J5cHRvbmV4LmNvbVwiLFxuICAgIFwic2F0b3NoaWxpdGVnaWZ0LnR1bWJsci5jb21cIixcbiAgICBcInlvbmlleC5jb21cIixcbiAgICBcImdldC5ldGhpbndhbGxldC5jb21cIixcbiAgICBcImxpenN0YXJrZ2lmdC50dW1ibHIuY29tXCIsXG4gICAgXCJzZWN1cmUuZXRob2ZmZXJzLm5ldFwiLFxuICAgIFwiZXRob2ZmZXJzLm5ldFwiLFxuICAgIFwiZXRoZXJkZWx0aGEuaW5mb1wiLFxuICAgIFwiZm9yY2RlbHRhLmNvbVwiLFxuICAgIFwiZXRoZXJldW1mb3VuZGF0aW9uZ2lmdC50dW1ibHIuY29tXCIsXG4gICAgXCJidGNwcmFtZW5neXZlLmNvbVwiLFxuICAgIFwiY2xhaW0tYnRjLm9yZ1wiLFxuICAgIFwiYnRjYmlnLm9yZ1wiLFxuICAgIFwiYnRjYm9udXMud2luXCIsXG4gICAgXCJidGNwcm9tb2dpdmViYWNrLmNvbVwiLFxuICAgIFwiYnRjcHJvbW9nZXQuY29tXCIsXG4gICAgXCJiaXQtYWlyZHJvcC5jb21cIixcbiAgICBcImdpdmVhd2F5LmNsYWltZXRoLm5ldFwiLFxuICAgIFwiY2xhaW1ldGgubmV0XCIsXG4gICAgXCJlbmNvcmVvZmZpY2lhbC5jb21cIixcbiAgICBcImV0aGNvbXBldGl0aW9ucnVsZXMuY3hcIixcbiAgICBcIm9mZmVyLnN1cHBvcnRldGguY29tXCIsXG4gICAgXCJzdXBwb3J0ZXRoLmNvbVwiLFxuICAgIFwic2FmZS5ldGhkZWxpdmVyLmNvbVwiLFxuICAgIFwiZXRoZGVsaXZlci5jb21cIixcbiAgICBcImNsYWltZXRoLm9yZ1wiLFxuICAgIFwiaW5zdGFudGV0aHByb21vdGlvbi5jeFwiLFxuICAgIFwiZXRocHJvbW90aW9ubm93LmN4XCIsXG4gICAgXCJldGh2ZXJ0LmNvbVwiLFxuICAgIFwiZXZlbnQtZXRoLWFkYS51a1wiLFxuICAgIFwibXllbGVoZXJ3YXJldC5jb21cIixcbiAgICBcIm1leXRoZXJ3ZWxsYXQuY29tXCIsXG4gICAgXCJidGMtZ2l2ZWF3YXkuaW5mb1wiLFxuICAgIFwibm9kZTgyLmJ0Yy1naXZlYXdheS5pbmZvXCIsXG4gICAgXCJ0ZXhhY29uLXZlcmlmeS01NDdmY2QuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImtpbmV0aWN0b2tlbmZvcm1zLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwiZXRoZXJjbGFpbS5vcmdcIixcbiAgICBcInhhdHJhaW52ZXN0LmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbHQtZjdhMDdjNHIuY29tXCIsXG4gICAgXCJ0cnguY2xhaW1zXCIsXG4gICAgXCJjb2luc2NyeXB0by5pbmZvXCIsXG4gICAgXCJnaXZlYXdheS5ldGgtc2FmZS5uZXRcIixcbiAgICBcImV0aC1zYWZlLm5ldFwiLFxuICAgIFwiYm9udXMtZXRoZXJldW0uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0dmVyaWZpY2F0aW9uLnNpZ25tc2cud29ya1wiLFxuICAgIFwic2lnbm1zZy53b3JrXCIsXG4gICAgXCJ4bi0tY29uLXZ0YS5zaXRlXCIsXG4gICAgXCJ4bi0tZXRocmRlbHRhLWlpYi5jb21cIixcbiAgICBcImV0aGVyZ2l2ZWF3YXkuc2l0ZVwiLFxuICAgIFwiZW9zY2xhc3NpYy5uZXR3b3JrXCIsXG4gICAgXCJlb3NhdXRob3JpdHkta3ljLmNvbVwiLFxuICAgIFwiZW9zY291bnRkb3duLm5ldHdvcmtcIixcbiAgICBcInBldHJhZm9yYmluYW5jZS5jb21cIixcbiAgICBcImlkZXgubWFya2V0LnhuLS1jb24tdnRhLnNpdGVcIixcbiAgICBcImV0aGJpZy5uZXRcIixcbiAgICBcInZlY2hhaW4tcGxhdGZvcm0ub3JnXCIsXG4gICAgXCJ2ZWNoYWluLWJsb2NrLmNvbVwiLFxuICAgIFwiZW9zYXV0aG9yaXR5LmNvbS5nbG9iYXRhbGVudC5uZXR3b3JrXCIsXG4gICAgXCJnbG9iYXRhbGVudC5uZXR3b3JrXCIsXG4gICAgXCJldGgtZ2lmdC5jbHViXCIsXG4gICAgXCJidXRlcmluLWdpdmVhd2F5Lm9yZ1wiLFxuICAgIFwiZnJlZWdpdmVhd2F5LWV0aC5jb21cIixcbiAgICBcInN1cHBvcnQuZXRoM3JkeWVhci5pb1wiLFxuICAgIFwiZXRoM3JkeWVhci5pb1wiLFxuICAgIFwiZGFpbHktZnJlZS1ldGgubmV0XCIsXG4gICAgXCJldGgtbmV3cy5jb1wiLFxuICAgIFwiZXRocHJvbW9naXZlLmNvbVwiLFxuICAgIFwiZXRoLWdpdmUubmV0XCIsXG4gICAgXCJ4cnAtYWRkcmVzcy5vcmdcIixcbiAgICBcImhpdGJ0Yy1sb2dpbi5jb21cIixcbiAgICBcInByb21vYmluYW5jZS5jb21cIixcbiAgICBcImJpdHRyZXgtaXguY29tXCIsXG4gICAgXCJiaXR0cmV4LWFwcC5jb21cIixcbiAgICBcImJpdHRyZWN4LmNvbVwiLFxuICAgIFwicHVtcGhhc2guY29tXCIsXG4gICAgXCJ0cm9ucGxheS5uZXR3b3JrXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsZXQtc3JiMzVjLmNvbVwiLFxuICAgIFwiZW9zYXV0aG9yaXR5LmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJiZXR0ZXItaGFzaC5jb21cIixcbiAgICBcInByb21vLmV0aHRha2UuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LXNpZ24udG9wXCIsXG4gICAgXCJoZWRlcmFoYXNoZ3JhcGgucHVibGljdG9rZW4uaWN1XCIsXG4gICAgXCJwdWJsaWN0b2tlbi5pY3VcIixcbiAgICBcInNhZmVwYXlldGgub3JnXCIsXG4gICAgXCJldGgyMDE4LmV0aHRvZXRoLmNvbVwiLFxuICAgIFwiYml0ZmFpbmV4LmNvbVwiLFxuICAgIFwiZXRoaW53YWxsZXQuY29tXCIsXG4gICAgXCJzZWN1cmUuZXRoaW53YWxsZXQuY29tXCIsXG4gICAgXCJldGhlcmV1bXByby5uZXRcIixcbiAgICBcImdpdmVhd2F5Y3J5cHRvLmluZm9cIixcbiAgICBcImRhcHAuZG91YmxlZG91YmxlLmlvXCIsXG4gICAgXCJkb3VibGVkb3VibGUuaW9cIixcbiAgICBcImJpdGNvaW52ZXN0LmNjXCIsXG4gICAgXCJjZWxlYnJhdGlvbi1ldGguY29tXCIsXG4gICAgXCJldGhlcnM0NDQub25saW5lXCIsXG4gICAgXCJldGg1MDAwLmlvXCIsXG4gICAgXCJldGh0b2V0aC5jb21cIixcbiAgICBcImNyeXB0b3NldGgudG9wXCIsXG4gICAgXCJldGhzZm9yLnRvcFwiLFxuICAgIFwid2FsbGV0ZXRoLnRvcFwiLFxuICAgIFwiZXRoYWlyLnRvcFwiLFxuICAgIFwid2luZXRoLnRvcFwiLFxuICAgIFwiZXRoZ2l2ZS5jcmVkaXRcIixcbiAgICBcIndpbmV0aHMudG9wXCIsXG4gICAgXCJlb3NhdXRob3JpdHkud2Vic2l0ZVwiLFxuICAgIFwieW9iaXQudGlsZGEud3NcIixcbiAgICBcImV0aDIwMTgubmV0XCIsXG4gICAgXCJldGh0d2l0dGVyLmNvbVwiLFxuICAgIFwiZXRoZXJldW1zdGFzaC5vcmdcIixcbiAgICBcImlkZXh0Lm1hcmtldFwiLFxuICAgIFwiZXRoZXJkZWx0YS5jb20udWFcIixcbiAgICBcImV0emVyZGVsdGEuY29tXCIsXG4gICAgXCJmb3JrZGVsdGEuY29cIixcbiAgICBcIm15ZWZ0ZXJ2dmVsbGV0LmNvbVwiLFxuICAgIFwidGVzbGFmb3JmcmVlLndvcmRwcmVzcy5jb21cIixcbiAgICBcImdvLmV0aHRha2UuY29tXCIsXG4gICAgXCJldGh0YWtlLmNvbVwiLFxuICAgIFwiZW9zc2F1dGhvcml0aHkuY29tXCIsXG4gICAgXCJlbGVjdHJ1bS5pbmtcIixcbiAgICBcImVsZWN0cnVtd2FsbGV0Lm1sXCIsXG4gICAgXCJteWV0aGVucndhbGxldC5zaXRlXCIsXG4gICAgXCJteWV0aGVyaXVtLnJ1XCIsXG4gICAgXCJteWV0aGVyd2FsbGVmdC5ydVwiLFxuICAgIFwibXlldGhyZXdhbGxldHMuY29tXCIsXG4gICAgXCJteWV0aHJ3YWxldC5jb21cIixcbiAgICBcIm15ZXRoc3dhbGxldHMuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC1zaW5nbWdzLnRvcFwiLFxuICAgIFwic2FmZS5ldGhpbmNyZWFzZS5jb21cIixcbiAgICBcImV0aGluY3JlYXNlLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGwtZXQuY29tXCIsXG4gICAgXCJteWV0aHJlLXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXItd2FsbGV0LmNvbVwiLFxuICAgIFwibS15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWVoZmVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaWdubWdzLnRvcFwiLFxuICAgIFwiZW9zYXV0aG9yaXRoeS5pbmZvXCIsXG4gICAgXCJhbmtyLW5ldHdvcmsudGVjaFwiLFxuICAgIFwiYW5rci1uZXR3b3JrLmNvbS5kZVwiLFxuICAgIFwidmFsaWRidGMuY29tXCIsXG4gICAgXCJldGhjZWxlYnJhdGlvbi5pb1wiLFxuICAgIFwiY3JzYWZlcGF5LmNvbVwiLFxuICAgIFwiZXRoZ29sZG1pbmUuY29tXCIsXG4gICAgXCJ2ZXJpZnkuZXRoZ29sZG1pbmUuY29tXCIsXG4gICAgXCJldGhjb21wZXRpdGlvbi5jeFwiLFxuICAgIFwib2ZmaWNpYWxnaXZlYXdheS5pbmZvXCIsXG4gICAgXCJldGhlcmNvbnRlc3Quc2l0ZVwiLFxuICAgIFwiYnRjZHJvcC5vcmdcIixcbiAgICBcImVvc2F1dGhvcml0aHkuY29tXCIsXG4gICAgXCJldGhlcmV1bWFubml2ZXJzYXJ5Lm9yZ1wiLFxuICAgIFwieG4tLWVvc2F1dGhvcnR5LWp6Yi5jb21cIixcbiAgICBcInhuLS1lb3N1dGhvcml0eS1tN2EuY29tXCIsXG4gICAgXCJ4bi0tZW9zYXV0aG9ydHkta2NiLmNvbVwiLFxuICAgIFwidHJvbmJvbnVzLm5ldHdvcmtcIixcbiAgICBcImV0aGF3YXkuY29tXCIsXG4gICAgXCJldGgtZ2lmdC5uZXRcIixcbiAgICBcImVvc2RhcmsuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FldC15N2E0NmhhLmNvbVwiLFxuICAgIFwiZnJlZXByb21vZXRoLmNvbVwiLFxuICAgIFwid2FsbGV0LmVvc3Rvb2xraXRzLmlvXCIsXG4gICAgXCJlb3N0b29sa2l0cy5pb1wiLFxuICAgIFwiY2hhbmZlbGx5LmNvbVwiLFxuICAgIFwiaWRpZXgubWFya2V0XCIsXG4gICAgXCJldGh0cmFuc2Zlci5vbmxpbmVcIixcbiAgICBcInRlbGVncmFtLm1hcmtldFwiLFxuICAgIFwiZXRoZ2lmdC5uZXRcIixcbiAgICBcImV0aGZvcnR1bmUuY29tXCIsXG4gICAgXCJldGhlcmV1bWRyb3AuaW5mb1wiLFxuICAgIFwiZXRocGF5cy5pbmZvXCIsXG4gICAgXCJldGgtZ2l2ZS1hd2F5LmNvbVwiLFxuICAgIFwic2FmZS5ldGhwYXluZXQuY29tXCIsXG4gICAgXCJldGhwYXluZXQuY29tXCIsXG4gICAgXCJnZXR5b3VyZXRocy5jb21cIixcbiAgICBcImV0aC5mYW5jbHViLnJvY2tzXCIsXG4gICAgXCJmYW5jbHViLnJvY2tzXCIsXG4gICAgXCJnZXQtYml0Y29pbnMtbm93LmNvbVwiLFxuICAgIFwiZXRoc2MzMjgyMS5uaWNob3N0LnJ1XCIsXG4gICAgXCJnZWxlcG8uY29tXCIsXG4gICAgXCJtdXNrLXNoYXJlcy5jb21cIixcbiAgICBcImVsb24tZ2lmdC5jb21cIixcbiAgICBcImVsb24tZ2lmdHMuY29tXCIsXG4gICAgXCJlbG9uLWdpdmVhd2F5cy5jb21cIixcbiAgICBcInZhbGlkZXRoLmNvbVwiLFxuICAgIFwiZXRoLXZlcmlmaWVkLmNvbVwiLFxuICAgIFwiZ3JhYi1ldGguY29tXCIsXG4gICAgXCJtZWRpdW1kb3Rjb20udG9wXCIsXG4gICAgXCJlb3MtYXV0aG9yaXR5LmNvbVwiLFxuICAgIFwibXlldGhyYXdhbGxldC5jb21cIixcbiAgICBcImZyZWVldGhwcm9tby5jb21cIixcbiAgICBcImV0aGVyZXVtLWV2ZW50LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZWF3YXkuc2FmZS1ldGgudG9wXCIsXG4gICAgXCJzYWZlLWV0aC50b3BcIixcbiAgICBcIm15YXV0b2NlbnRtYXJrcy5jb21cIixcbiAgICBcImlvLXRyb24uY29tXCIsXG4gICAgXCJldGhlcmV1bS1wbGF0Zm9ybS5vcmdcIixcbiAgICBcInctdHJvbi5vcmdcIixcbiAgICBcImJvbnVzLmV0aC1wcm9tby5vcmdcIixcbiAgICBcImV0aC1wcm9tby5vcmdcIixcbiAgICBcImJpbmFuY2UtZXRoLmdpdGh1Yi5pb1wiLFxuICAgIFwiNTAwMGV0aC5pb1wiLFxuICAgIFwidHdpdHRlcnByb21vLmluZm9cIixcbiAgICBcInByb21vLWJpbmFuY2Uuc2l0ZVwiLFxuICAgIFwid2FsbGV0LXRvcC11cC5vcmdcIixcbiAgICBcImJpbmFuY2UtYnRjLmdpdGh1Yi5pb1wiLFxuICAgIFwiZXRoZXh0cmEubmV0XCIsXG4gICAgXCJldGhvZmZpY2lhbHBhZ2UudXNcIixcbiAgICBcImV0aGVycy1mcmVlLm9yZ1wiLFxuICAgIFwiY2xhaW1ldGhlcnMub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsZXR0LjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJnaXZlYXdheS5ldGhzYWZlLm5ldFwiLFxuICAgIFwiZXRoZXJldW0tcHJvbW8uaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uc2lnbm1zZy5pY3VcIixcbiAgICBcInNpZ25tc2cuaWN1XCIsXG4gICAgXCJhbmF0b21pYS5pb1wiLFxuICAgIFwiYW5hdG9taWFhaXJkcm9wLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwiZ2l2ZS1ldGhwcml6ZS5jb21cIixcbiAgICBcIm9keXNzZXkuY2VudGVyXCIsXG4gICAgXCJ3b3JsZC1tYXJrZXQub25saW5lXCIsXG4gICAgXCJldGhlcmV1bS5vZHlzc2V5LmNlbnRlclwiLFxuICAgIFwieG4tLWVvc2F1dGhvcnR5LXdjYi5jb21cIixcbiAgICBcImV0aGVyZnJlZS5pbmZvXCIsXG4gICAgXCJmcmVlLWV0aGVycy5vcmdcIixcbiAgICBcIm15ZW9zdHJ1c3QuY29tXCIsXG4gICAgXCJlb3Nkcm9wLnhuLS1teXRocndhbGx0LWM3YTg2YzVhLmNvbVwiLFxuICAgIFwiZXRoLWNsYWltLm5ldFwiLFxuICAgIFwiZXRoZnJlZWdpZnQub3JnXCIsXG4gICAgXCJteWVudGVyd29ybGxkLmNvbVwiLFxuICAgIFwibG9jYWxldGhlcndhbGxldC5pbmZvXCIsXG4gICAgXCJldGhzdXBwb3J0Lm5ldFwiLFxuICAgIFwibmV3c2Fpci5pbmZvXCIsXG4gICAgXCJvZmZpY2lhbGdpdmVhd2F5Lm9yZ1wiLFxuICAgIFwiY29sbGVjdGlvbnNldGguY29tXCIsXG4gICAgXCJhaXJkcm9wZW9zLmNvbVwiLFxuICAgIFwibmVvLXguaW5mb1wiLFxuICAgIFwibXlldGhlcnBsYWNlLmNvbVwiLFxuICAgIFwiZXRoZXItZ2l2ZS5saXZlXCIsXG4gICAgXCJidGMtZ2l2ZS5vcmdcIixcbiAgICBcImV0aGdwcm9tby5jb21cIixcbiAgICBcImVvc2F1dGhvcml0eS5pbmZvXCIsXG4gICAgXCJlb3NhdXRob3JpdHkudW5zdGFrZS54eXpcIixcbiAgICBcInVuc3Rha2UueHl6XCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxldC1jN2EyOWN5cS5jb21cIixcbiAgICBcImV0aGdpdmVycy5jb21cIixcbiAgICBcInNlY3VyZS5ldGhnaXZlcnMuY29tXCIsXG4gICAgXCJldGhlcmdpZnQuaW9cIixcbiAgICBcInN1cmV0eXRva2VuLmNvbVwiLFxuICAgIFwiZ2V0ZXRoZXJzLm9yZ1wiLFxuICAgIFwiaW5kZXhtYWtlci1uZXR3b3JrLmNvbVwiLFxuICAgIFwiaWRleG1hcmtldC1jb3JwLmNvbVwiLFxuICAgIFwiaWRleG9udGltZS5jb21cIixcbiAgICBcImlkZXhtYXJrZXRjb3JwLmNvbVwiLFxuICAgIFwiaWRleC1tYXJrZXRzc2l0ZS5jb21cIixcbiAgICBcImlkZXhtYXJrZXQtbGxjLmNvbVwiLFxuICAgIFwiZXRoLWFpci1jb20uMWdiLnJ1XCIsXG4gICAgXCJpZGV4eHNvZnRsb2FkLmNvbVwiLFxuICAgIFwiaWRleG1hcmtldC1jb3Jwcy5jb21cIixcbiAgICBcImVvcy1wbGF0Zm9ybS5uZXRcIixcbiAgICBcImJ0Y2Zhc3QuaW9cIixcbiAgICBcImdpdmVhd2F5cHJvbW8ub3JnXCIsXG4gICAgXCJldmVudC1ldGgub3JnXCIsXG4gICAgXCJldGhhY3Rpb24uaW9cIixcbiAgICBcIjI0aC5zemFrZG9nYS5uZXRcIixcbiAgICBcImx1bm8taGVscC1kZXNrLXVwZGF0ZS53ZWVibHkuY29tXCIsXG4gICAgXCJhaXJkcm9wZm9ybTkwMC50eXBlZm9ybS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmFwaS5yb290LnNpZ25tc2cubWVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQudG9rZW4uc2lnbm1zZy5uZXR3b3JrXCIsXG4gICAgXCJzaWdubXNnLm1lXCIsXG4gICAgXCJzaWdubXNnLm5ldHdvcmtcIixcbiAgICBcImlkZXhtYXJrZXRsbGMuY29tXCIsXG4gICAgXCJpZGV4d2ViYWEuY29tXCIsXG4gICAgXCJldGhmYXN0LmlvXCIsXG4gICAgXCJnaXZld2F5cHJvbW8ub3JnXCIsXG4gICAgXCJldGhlcmV1bS1naXZhd2F5LnNvY2lhbFwiLFxuICAgIFwicGVyc29uYWxldGguY29tXCIsXG4gICAgXCJpbmRleG1hcmtldC1pbmMuY29tXCIsXG4gICAgXCJtbnljdGVydmFpbGxpZXQuY29tXCIsXG4gICAgXCJtbnlpZHRoZXdhbGxvdC5jb21cIixcbiAgICBcImMta2Ftb3dza2kuZnJcIixcbiAgICBcImVvc3ByaXZhdGUuaW9cIixcbiAgICBcInNpZ25tZXNzYWdlLm1lXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hcGkuc2lnbm1lc3NhZ2UubWVcIixcbiAgICBcInNoYXBlc2hpZnR2LmNvbVwiLFxuICAgIFwiZ2V0LWV0aGVyLW5vdy5jb21cIixcbiAgICBcIndhdmVzLXBsYXRmb3JtLm5ldFwiLFxuICAgIFwibXllZmhlcndhbGlldC5jb21cIixcbiAgICBcImV0aHNhZmUubmV0XCIsXG4gICAgXCJ4bi0tY29pbmJhcy16OGEudGtcIixcbiAgICBcImV0aHNoYXJlLm9yZ1wiLFxuICAgIFwiZXRoZXJnaXZlLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxldC5oZWxpb2hvc3Qub3JnXCIsXG4gICAgXCJrZXlmdW5kYWlyZHJvcC50eXBlZm9ybS5jb21cIixcbiAgICBcImVvc2Rhc2guaW9cIixcbiAgICBcImV0aGVyZXVtLWNsYWltLm9yZ1wiLFxuICAgIFwic2FmZXN0ZXRoLmNvbVwiLFxuICAgIFwiZXRoc2Nhbi51c1wiLFxuICAgIFwiZ2V0LnBlcmZlY3RldGguY29tXCIsXG4gICAgXCJwZXJmZWN0ZXRoLmNvbVwiLFxuICAgIFwibmV3c2Fpci5vcmdcIixcbiAgICBcInRvcC1ldGhlcmV1bS5jb21cIixcbiAgICBcInMtbXNnLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJlbG9uLXNoYXJlcy5jb21cIixcbiAgICBcInhuLS1teWV0ZXJ3YWxsZXQtbzBiLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHQubmV0XCIsXG4gICAgXCJtYWdudGVjaC50a1wiLFxuICAgIFwiaWNvLm1ldHJvbm9tZS5ielwiLFxuICAgIFwibWV0cm9ub21lLmJ6XCIsXG4gICAgXCJtZXRyb25vbWUuZm91bmRhdGlvblwiLFxuICAgIFwiZXRoZXJldW0tcHJpemUuY29tXCIsXG4gICAgXCJldGhlcmJvbnVzLmxpdmVcIixcbiAgICBcImZhbnRvbS1mb3VuZGF0aW9uLnRlY2hcIixcbiAgICBcInNwYXJrc3Rlci5zaXRlXCIsXG4gICAgXCJpZGV4LWV4Y2hhbmdlLm1hcmtldFwiLFxuICAgIFwiaWRleC1uYXJrZXQuY29tXCIsXG4gICAgXCJpZGV4bWFya2V0LWluYy5jb21cIixcbiAgICBcImlkZXhtYXJrZXQtaW5jcy5jb21cIixcbiAgICBcImluZGV4bWFya2V0dC1jb3JwLmNvbVwiLFxuICAgIFwiZ2l2ZXRoLndzXCIsXG4gICAgXCJnaXZlZXRoLm9yZ1wiLFxuICAgIFwiZXRoZXJldW0ub3JnLmdpdmUtZXRoLnRvZGF5XCIsXG4gICAgXCJnaXZlLWV0aC50b2RheVwiLFxuICAgIFwiY29sbGVjdC1ldGhhd2F5LmNvbVwiLFxuICAgIFwiYWlyZXRoLnRvZGF5XCIsXG4gICAgXCJpbmRleC1tYXJrZXIuY29tXCIsXG4gICAgXCJpZGRleG1hcmtldC5jb21cIixcbiAgICBcImlkZGV4bWFyay5ldC5jb21cIixcbiAgICBcImlkZGV4bWEucmtldC5jb21cIixcbiAgICBcImlkZWV4bWFya2V0LmNvbVwiLFxuICAgIFwiaWRleG1hcmtldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsbGV0Lm9ubGluZVwiLFxuICAgIFwib2R5c3NleS5wbHVzXCIsXG4gICAgXCJldGhlcmV1bWd3Lm9yZ1wiLFxuICAgIFwiZXByb21vLmNjXCIsXG4gICAgXCJpbmRleC1tYXJrZXR6LmNvbVwiLFxuICAgIFwiNjguMTY4LjEyMy44NVwiLFxuICAgIFwiZXRoLXByb21vcy5vcmdcIixcbiAgICBcImV0aHhpbmZvLmNvbVwiLFxuICAgIFwiZXRoZXJldW1wcm9tby5vcmdcIixcbiAgICBcImV0aC1naXZlYXdheS5zdXJnZS5zaFwiLFxuICAgIFwiMTAwMDBldGhlcmV1bS5jb21cIixcbiAgICBcImV0aGNyeXB0by5pbmZvXCIsXG4gICAgXCJodW9iaXRhbGsuZ2FcIixcbiAgICBcInZlcmlmaWVkLm15ZXRoZXJnaWZ0LmNvbVwiLFxuICAgIFwibXlldGhlcmdpZnQuY29tXCIsXG4gICAgXCJldGhhaXJkcm9wLm9yZ1wiLFxuICAgIFwiY2xhaW0uZXRoYWlyZHJvcC5vcmdcIixcbiAgICBcImJpdGNvaW4tcHJvbW8uY2x1YlwiLFxuICAgIFwidG9kYXktZXRoZXJldW0uY29tXCIsXG4gICAgXCJldGhub3cub3JnXCIsXG4gICAgXCJlb3Njb3VudGRvd24uY29cIixcbiAgICBcInhuLS1teXRocndhbGV0LXNtYjBhMDVjLmNvbVwiLFxuICAgIFwiZ28uYm9vc3RldGguY29tXCIsXG4gICAgXCJib29zdGV0aC5jb21cIixcbiAgICBcImNsYWltcy5wYXlldGgucHJvbW9cIixcbiAgICBcInBheWV0aC5wcm9tb1wiLFxuICAgIFwiZ2V0LWV0aC1ub3cuY29tXCIsXG4gICAgXCJldGhwcm9tby53aW5cIixcbiAgICBcImV0aGVyZXVtZ2lmdC5vcmdcIixcbiAgICBcImdldC1idGMtbm93LmNvbVwiLFxuICAgIFwiZXRocGF5cy5vcmdcIixcbiAgICBcInNhZmUuZXRocGF5bm93LmNvbVwiLFxuICAgIFwiZXRocGF5bm93LmNvbVwiLFxuICAgIFwiZWxvbi1naXZlcy5jb21cIixcbiAgICBcImluZGV4LW1hcmtlbHMuY29tXCIsXG4gICAgXCJldGhlcmJvbnVzLndpblwiLFxuICAgIFwiZ2V0ZXRocHJvLmNvbVwiLFxuICAgIFwiZXZlbnQtZXRoZXJldW0ub3JnLnVrXCIsXG4gICAgXCJ4bi0tbXlldGhyd2xsdC15NGE3Z2YuY29tXCIsXG4gICAgXCJnaXZlYXdheXByb21vLmJ5ZXRob3N0MTQuY29tXCIsXG4gICAgXCJwbG9sb25laXguY29tXCIsXG4gICAgXCJwb3Jsb25laXgxLmRvbWVuLWhvc3Rpbmcub3JnXCIsXG4gICAgXCJwb3Jsb25laXguY29tXCIsXG4gICAgXCJwb2xyb25pZXguY29tXCIsXG4gICAgXCJwb3Jsb25pZXguY29tXCIsXG4gICAgXCJwb3Jsb25pZXgxLmRvbWVuLWhvc3Rpbmcub3JnXCIsXG4gICAgXCJnZXRiaWdkZWFscy5vcmdcIixcbiAgICBcImV0aHByb21vdGlvbnMub3JnXCIsXG4gICAgXCJ3aW5jaGVjay5vcmdcIixcbiAgICBcImV0aGZvci5pbmZvXCIsXG4gICAgXCJoZWRlcmFoYXNoZ3JhcGgudG9rZW5pY28ubWVcIixcbiAgICBcInRva2VuaWNvLm1lXCIsXG4gICAgXCJzZWN1cmUuZXRoeGNoYW5nZXMuY29tXCIsXG4gICAgXCJldGhnaWZ0LmlvXCIsXG4gICAgXCJ2ZXJpZnkub2ZmaWNpYWxldGguY29tXCIsXG4gICAgXCJvZmZpY2lhbGV0aC5jb21cIixcbiAgICBcIndlbGNvbWUucHJvbW90aW9uYWxldGguY29tXCIsXG4gICAgXCJwcm9tb3Rpb25hbGV0aC5jb21cIixcbiAgICBcImJpbmFuY2UtZ2l2ZWF3YXkuY29tXCIsXG4gICAgXCJ3YWxsZXRlb3MuaW9cIixcbiAgICBcIm15ZWZoZXJ2dmFsbGV0LmNvbVwiLFxuICAgIFwic3BhcmtzdGVyLmJlXCIsXG4gICAgXCJldGhlcmd1aWRlLmluZm9cIixcbiAgICBcImFwcC1teWV0aGVydnZhaWlldC5jb21cIixcbiAgICBcIm15ZXRoZWhlYXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVydmVsbGV0LmdxXCIsXG4gICAgXCJteWV0aGVyd2FsbGVrLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldC5naWZ0c1wiLFxuICAgIFwibXlldGhld2FsbGUuY29tXCIsXG4gICAgXCJteWV0aHJld2FsbGV0Lm5ldFwiLFxuICAgIFwibXlldGh3YWxsZXQudG9wXCIsXG4gICAgXCJ4bi0tbXlldGhycndhbGxldC1tMGIubmV0XCIsXG4gICAgXCJnb25ldHZ2b3JrLmNvbVwiLFxuICAgIFwiYWlydGFrZS5pbmZvXCIsXG4gICAgXCJldGhlcmdpdmUubmV0XCIsXG4gICAgXCJpZGl4LW1hcmtldC5pbmZvXCIsXG4gICAgXCJpY29uLWJsb2NrLm9yZ1wiLFxuICAgIFwibWFzdGVydGhlY3J5cHRvLm9yZ1wiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGxldC1uY2Iub3JnXCIsXG4gICAgXCJldGhwcm9tb2FjdGlvbi5jb21cIixcbiAgICBcImV0aGluZm8ub3JnXCIsXG4gICAgXCJhaXJnd3Mub3JnXCIsXG4gICAgXCJldGguYmxvZ21lZGl1bS50b3BcIixcbiAgICBcImJsb2dtZWRpdW0udG9wXCIsXG4gICAgXCJlb3NyZWdpc3RyeS5zaXRlXCIsXG4gICAgXCJnaXZlZXRoZXJzLmluZm9cIixcbiAgICBcImNyZXRlcHJpbnQtZHJpdmV3YXlzLmNvLnVrXCIsXG4gICAgXCJldGh5cGUub3JnXCIsXG4gICAgXCJldGhlcnByb21vdGlvbi5vcmdcIixcbiAgICBcImlkZXhzLm1hcmtldFwiLFxuICAgIFwiaXRleC5tYXJrZXRcIixcbiAgICBcImlkZWgubWFya2V0XCIsXG4gICAgXCJ4bi0taWR4LWttYS5tYXJrZXRcIixcbiAgICBcInhuLS1pZHgtY21hLm1hcmtldFwiLFxuICAgIFwiaWNsZXgubWFya2V0XCIsXG4gICAgXCJ4bi0taWR4LTRxYS5tYXJrZXRcIixcbiAgICBcInhuLS1kZXgtcW1hLm1hcmtldFwiLFxuICAgIFwieG4tLWlkeC1nbWEubWFya2V0XCIsXG4gICAgXCJpZGRleC5tYXJrZXRcIixcbiAgICBcImV0ZWNsdW0ub3JnXCIsXG4gICAgXCJteWlnaHRoZXIubmV0XCIsXG4gICAgXCJldGhwdWJzLmNvbVwiLFxuICAgIFwiYmluYW5jZWdpdmVhd2F5Lm9yZ1wiLFxuICAgIFwiZXRoZ3dzLm9yZ1wiLFxuICAgIFwiZXRoZXJldW1yZXR1cm5zLmNvbVwiLFxuICAgIFwidGFrZWV0aC5vcmdcIixcbiAgICBcImlkZXgtbWFya2V0LmF0XCIsXG4gICAgXCJ3YWxsZXQtaWRleC5uZXRcIixcbiAgICBcImJpdHRyZXgtaWQuY29tXCIsXG4gICAgXCJwdXR0eS1wb3J0YWwuY29tXCIsXG4gICAgXCJhcndlYXZlLnB3XCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsdC1pbmJlNjRjLmNvbVwiLFxuICAgIFwia2VudHJhLnRlY2hcIixcbiAgICBcInhuLS1teWV0aGVyd2FsbGUtbW01Zi5jb21cIixcbiAgICBcInhuLS1teWVoZXJ3YWxsZXQtNGo1Zi5uZXRcIixcbiAgICBcInhuLS1teWV0aHJ3bGxldC1xN2E1aC5jb21cIixcbiAgICBcInhuLS1kZXhtYXJrZXQtOThkLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsZXQtc21iMGExNWMuY29tXCIsXG4gICAgXCJzaWdubXNnLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNpZ25tc2cuaW5mb1wiLFxuICAgIFwib3JhY29uLmlvXCIsXG4gICAgXCJldGgtYm9udXMub3JnXCIsXG4gICAgXCJwaXNjb3JlYWxlc3RhdGUuY29tXCIsXG4gICAgXCJteWV0aHJ3YXR0LmluZm9cIixcbiAgICBcImRlZnJhZ2dsZXItY29kZS5jb21cIixcbiAgICBcImV0aGJvbnVzLmlvXCIsXG4gICAgXCJldGh4cHJvbW8uY29tXCIsXG4gICAgXCJvbWlzZS1nby5pbmZvXCIsXG4gICAgXCJ4bi0tbXlldGhlcnJ3YWxldC01aGMubmV0XCIsXG4gICAgXCJpZGljZS5lcGl6eS5jb21cIixcbiAgICBcImdlbmUubmV0d29ya1wiLFxuICAgIFwiYmFocy5lZHUudHRcIixcbiAgICBcImV0aGVyb2xsLmlvXCIsXG4gICAgXCJtZXRhLW1hc2suY29tXCIsXG4gICAgXCJtZXRhbWFza3dhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ0cnVzdC5jb21cIixcbiAgICBcImFjYWRlbWljb25zd2FwLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwiemlsbG93YmxvY2tjaGFpbi5vcmdcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuc2lnbm1zZy5vbmxpbmVcIixcbiAgICBcInNpZ25tc2cub25saW5lXCIsXG4gICAgXCJmYWxjb25zd2FwLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwiaWRleC1tYXJrZXQuY29cIixcbiAgICBcInNwYXJrc3Rlci5wcm9cIixcbiAgICBcInZpYmVyYXRlLmJldHRlcm1vc3QubmV0XCIsXG4gICAgXCJiZXR0ZXJtb3N0Lm5ldFwiLFxuICAgIFwicXVhcmtjaGFpbi50eXBlZm9ybS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRwcml6ZS50b3BcIixcbiAgICBcInJlYmVsbGlvdXMtYWlyZHJvcC50b3BcIixcbiAgICBcIm12eWV0aGVyd2FsbGV0LnRvcFwiLFxuICAgIFwia3ljdmVyaWZpY2F0aW9uLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldHQtNWhjLm5ldFwiLFxuICAgIFwieG4tLW15dGhlcmFsbGV0LTNxYjIxMTlnLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdsbGV0LTczOGVuN2EuY29tXCIsXG4gICAgXCJteWV0ZmVyd2VsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV0aHdhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ2dWFsZXQuZ3FcIixcbiAgICBcIm15ZXRoZXJ3YWxsZWEub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsbGVlLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldGwub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsbGV1Lm9yZ1wiLFxuICAgIFwieG4tLW15ZXRocndhbGV0dC04dmIxOWMubmV0XCIsXG4gICAgXCJmcmVlLWV0aGVyZXVtLnVzXCIsXG4gICAgXCJ0cm9uLW1haW5uZXQubmV0d29ya1wiLFxuICAgIFwicmVjZWl2ZS1jcnlwdG8uY29tXCIsXG4gICAgXCJyZWNlaXZlLWV0aC5jb21cIixcbiAgICBcInJlY2VpdmUtZXRoZXIuY29tXCIsXG4gICAgXCJ0b24udnVcIixcbiAgICBcImV0aGVyZnJlZS5vcmdcIixcbiAgICBcImV0aGdhaW4ub3JnXCIsXG4gICAgXCJnaWZ0ZXRoLm9yZ1wiLFxuICAgIFwibXllYXRoZXJ3YWxsZXRyMi5kb21lbi1ob3N0aW5nLm9yZ1wiLFxuICAgIFwiZG9tZW4taG9zdGluZy5vcmdcIixcbiAgICBcIm15ZXRoZWFyd2VsbGV0LmNvbVwiLFxuICAgIFwibXllYXRoZXJ3YWxsZXRyLmNvbVwiLFxuICAgIFwibXllYXRoZXJ3YWxsZXJ0LmNvbVwiLFxuICAgIFwibXlldGhlYXJyd2FsbGV0NS5kb21lbi1ob3N0aW5nLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldDEuZG9tZW4taG9zdGluZy5vcmdcIixcbiAgICBcIm15ZXRoZWFycndhbGxldC5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsdC1mN2ExM2UuY29tXCIsXG4gICAgXCJldGhzcGFjZS5wcm9tb1wiLFxuICAgIFwiZXRoZXhjaGFucy5jb21cIixcbiAgICBcInNhZmUuZXRoeGNoYW5nZXMuY29tXCIsXG4gICAgXCJldGh4Y2hhbmdlcy5jb21cIixcbiAgICBcInhuLS1teXRocndhbGV0LWM3YWM0N2kuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC1jN2E4NmM1YS5jb21cIixcbiAgICBcImNyeXB0b2F3YXkub3JnXCIsXG4gICAgXCJldGhkZWFscy5vcmdcIixcbiAgICBcImV0aGdpdmVhd2F5LmlvXCIsXG4gICAgXCJjbGFpbWV0aC5tZVwiLFxuICAgIFwiZXRoZXJldW1naXZlYXdheS50eXBlZm9ybS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsZXR0LTRoYy5uZXRcIixcbiAgICBcInplY2Jsb2NrLmluZm9cIixcbiAgICBcImxpdGVjb2luLWNoYWluLmluZm9cIixcbiAgICBcInJpcHBsZS1jaGFpbi5vcmdcIixcbiAgICBcIm9ubGluZS1zdGVsbGFyLmluZm9cIixcbiAgICBcImNvaW4tbW9uZXJvLm9yZ1wiLFxuICAgIFwibXlldGhyd2F0dC5jb21cIixcbiAgICBcImV0aGVyLXNoYXJlLmNvbVwiLFxuICAgIFwiYnRjcy1zaGFyZS5jb21cIixcbiAgICBcImV0aGVyZXByb21vLndpblwiLFxuICAgIFwiZXRodG93YWxsZXQuY29tXCIsXG4gICAgXCJldGhzY2xhaW0uY29tXCIsXG4gICAgXCJldGhhd2FyZC5jb21cIixcbiAgICBcImFpcmRyb3AyNC5jb21cIixcbiAgICBcImV0aC5tZWRpdW1ibG9nLnRvcFwiLFxuICAgIFwibWVkaXVtYmxvZy50b3BcIixcbiAgICBcImRyb3BldGgub3JnXCIsXG4gICAgXCJnZXQuZXRocHVibGljLmNvbVwiLFxuICAgIFwiZXRocHVibGljLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZ2V0Lm9yZ1wiLFxuICAgIFwiZXRoZXJldW0ud2Vic2l0ZS50a1wiLFxuICAgIFwiZXRoZXJldW0tYm9udXMuY29tXCIsXG4gICAgXCJibHR0cmV4LnVzXCIsXG4gICAgXCJteWV0aGVyd2FsbGF0LmNvXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxldC11bWJ2MzVjLmNvbVwiLFxuICAgIFwiaGVsYml6LXRva2VuLnRyYWRlXCIsXG4gICAgXCJlb3N0b2tlbi1lb3MtaW8udHlwZWZvcm0uY29tXCIsXG4gICAgXCJzd2l0Y2hlby1sb2dpbi5jb21cIixcbiAgICBcInN3aXRjaGVlLmV4Y2hhbmdlXCIsXG4gICAgXCJmYWxjb25ldHdvcmsuZGVcIixcbiAgICBcInhuLS1teWV0aGVyd2FldHQtbGNjYS5uZXRcIixcbiAgICBcInNlY3VyZS5ldGh0b2dpdmUuY29tXCIsXG4gICAgXCJldGh0b2dpdmUuY29tXCIsXG4gICAgXCJmYW50b20ucHViXCIsXG4gICAgXCJrdWNyb2luLmNvbVwiLFxuICAgIFwiZmFudG9tcy5mb3VuZGF0aW9uXCIsXG4gICAgXCJldGhlcnNrYW4uaW9cIixcbiAgICBcImV0aGVyc2Nhbi5sdGRcIixcbiAgICBcIm15aXRlaGVyLmNvbVwiLFxuICAgIFwibXVzay1naXZlYXdheS5jb21cIixcbiAgICBcImdldC1ldGhlci5jYXNoXCIsXG4gICAgXCJmcmVlLWV0aGVycy5jb21cIixcbiAgICBcImV0aGVyc2hhcmVzLmJsb2dzcG90Lm5sXCIsXG4gICAgXCJyaXBwbGUtZ2l2ZXMtZXRoLmNvbVwiLFxuICAgIFwidGVsZWdyYW0udnVcIixcbiAgICBcIm15ZGVsaXZlcnljdi5jb21cIixcbiAgICBcImV0aGVyZXVtYm9udXMub3JnXCIsXG4gICAgXCJldGhlci1naXZlYXdheS5vbmxpbmVcIixcbiAgICBcImlkZXgtbWFya2V0LmlvXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsdC1zbWI1YTU0Yy5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxldC12cmIxNWMuY29tXCIsXG4gICAgXCJ4bi0tbWV0aGVyd2FsbHQtNWhiMTZhLmNvbVwiLFxuICAgIFwiZ2V0LWV0aGVycy5uZXRcIixcbiAgICBcImV0aGZyZWViaWUuaWN1XCIsXG4gICAgXCJnYXRoZXItZ2lmdC5jb21cIixcbiAgICBcInN3ZHdkLmV0aGVyZ2V0MjIuem9uZVwiLFxuICAgIFwiZXRoZXJnZXQyMi56b25lXCIsXG4gICAgXCJnaXZlYXdheS5uZW9jaXRpZXMub3JnXCIsXG4gICAgXCJldGhlcmRyb3Aub3JnXCIsXG4gICAgXCJzYWZlcGF5LWV0aC5vcmdcIixcbiAgICBcImVsZWN0cm9jb2luLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxsZXQudHJhZGVcIixcbiAgICBcImJ0Y29pbi52dVwiLFxuICAgIFwiYnRjLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwiYnRjb2ZmaWNpYWwuaW5mb1wiLFxuICAgIFwiY29sbGVjdC5iZXN0ZXRoZ2lmdC5jb21cIixcbiAgICBcImJlc3RldGhnaWZ0LmNvbVwiLFxuICAgIFwiaWRlay5pb1wiLFxuICAgIFwiaWRleDI0LmlvXCIsXG4gICAgXCJldGgtZ2V0LmNvbVwiLFxuICAgIFwiZ2l2ZWF3YXktZXRoZXIuaW5mb1wiLFxuICAgIFwiZXRoZXItZ2l2ZS5jbHViXCIsXG4gICAgXCJldGgucHJvbW8tZXRoZXJ1bS5jb21cIixcbiAgICBcInByb21vLWV0aGVydW0uY29tXCIsXG4gICAgXCJ3aW5wbGF0Zm9ybS5pb1wiLFxuICAgIFwiaW5kZXgtbWFjcm8uY29tXCIsXG4gICAgXCIxODUuMTU2LjE3My44N1wiLFxuICAgIFwiZW9zLXBhcGVyd2FsbGV0LmNvbVwiLFxuICAgIFwicHJvbW90b2V0aC5vcmdcIixcbiAgICBcImV0aHByb21vLmNjXCIsXG4gICAgXCJpZGV4LW1hcmtldC5ldVwiLFxuICAgIFwiaWRleC1sb2dpbi5uZXRcIixcbiAgICBcImVvcy1zd2FwLmNvbVwiLFxuICAgIFwia2V5ZnVuZC5pb1wiLFxuICAgIFwiZXRoZXJldW0tcHJvbW8ueGYuY3pcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tc2lnbmludmVyaWNhdGlvbi5zaWdubWVzc2FnZS5jcm9jd2ViLm9ubGluZVwiLFxuICAgIFwiY3JvY3dlYi5vbmxpbmVcIixcbiAgICBcIm15ZW9zZGFjLnRvcFwiLFxuICAgIFwiZXRob2ZmaWNpYWwuaW5mb1wiLFxuICAgIFwiZ2V0c29tZWV0aC5jb21cIixcbiAgICBcImdpdmVhd2F5Y3J5cHRvLm9yZ1wiLFxuICAgIFwiaWRleG1hcmtldC5pb1wiLFxuICAgIFwibXlldGVocmV3YWxsZXQuY29tXCIsXG4gICAgXCJsYmV4Lm1hcmtldFwiLFxuICAgIFwiaWRleC1pbmZvLm5ldFwiLFxuICAgIFwiZ2V0LWV0aC53aW5cIixcbiAgICBcImV0aC1jbGFpbS5vcmdcIixcbiAgICBcImV0aC1naXZlYmFja25vdy50dW1ibHIuY29tXCIsXG4gICAgXCJldGhmcmVlYmllLmNvbVwiLFxuICAgIFwiZXRocGF5ZXRoZXJzLmNvbVwiLFxuICAgIFwia2luZXRpY3Rva2VuZm9ybS50eXBlZm9ybS5jb21cIixcbiAgICBcImtpbmV0aWN0b2tlbi5uZXRcIixcbiAgICBcInhuLS1teWV0aGVyd2xsdC1yN2E0NGUuY29tXCIsXG4gICAgXCJzYWZlcnBheWV0aGVyLmNvbVwiLFxuICAgIFwiZXRoZ2l2ZS5nbG9iYWxcIixcbiAgICBcImV0aHByb21vLmluZm9cIixcbiAgICBcImV0aGVyZXVtLXByb21vLm9yZ1wiLFxuICAgIFwiY3J5cHRvLWNsYWltcy5vcmdcIixcbiAgICBcImdldGV0aG5vdy5jb21cIixcbiAgICBcInRyb24uZ2dcIixcbiAgICBcInRyb25mb3VuZGF0aW9uLmNjXCIsXG4gICAgXCJ0cm9uZm91bmRhdGlvbi5naWZ0XCIsXG4gICAgXCJldGhuLmdpZnRcIixcbiAgICBcImdldGguZnlpXCIsXG4gICAgXCJldGhjLmxpdmVcIixcbiAgICBcImV0aHMuZnlpXCIsXG4gICAgXCJzaHIuc3RcIixcbiAgICBcImdhdGUxLmV0aHMudnVcIixcbiAgICBcImV0aGMuY2FzaFwiLFxuICAgIFwiZXRobi5saVwiLFxuICAgIFwiZXRoYy5jY1wiLFxuICAgIFwiZXRobi5wd1wiLFxuICAgIFwiZ2V0LWV0aC50b3BcIixcbiAgICBcImV0aGd3LmluZm9cIixcbiAgICBcImV0aGJpZ3Byb21vLWNvbS4xZ2IucnVcIixcbiAgICBcImNsYWltY3J5cHRvLm9yZ1wiLFxuICAgIFwiZXRocHJvbW8uaW9cIixcbiAgICBcInZlcmlmY2Fvbi5zaXRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5zaWduaW52ZXJpY2F0aW9uLnZlcmlmY2Fvbi5zaXRlXCIsXG4gICAgXCJ2ZXJpZnl3YWxsZXQudHlwZWZvcm0uY29tXCIsXG4gICAgXCJ4bi0tbXlldGhld2FsbGV0LTRuZi5uZXRcIixcbiAgICBcInhuLS1teWV0aGVyd2xsdC1mN2E3NWUuY29tXCIsXG4gICAgXCJldGhnaXZlLm1lXCIsXG4gICAgXCJldGhnaXZlcy5tZVwiLFxuICAgIFwicHJvbWFlc3Ryb3MuY28udWtcIixcbiAgICBcImV0aGFkZHJlc3MubmVvY2l0aWVzLm9yZ1wiLFxuICAgIFwiY2hhbmdlbGx5aWNvLmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJldGhlcmZhdWNldC50ZWNoXCIsXG4gICAgXCJ0cmFuc2FjdGlvbi1hdXRob3JpemF0aW9uLmRyb3BwYWdlcy5jb21cIixcbiAgICBcImJpdGNvaW5icmF2YWRvLmlvXCIsXG4gICAgXCJjb2luLXNlY3VyZS10cmFuc2FjdGlvbi5jb21cIixcbiAgICBcImV0aGVyZXVtLXBheS5jb21cIixcbiAgICBcImV0aGVyZXVtZ2l2ZWF3YXkud2luXCIsXG4gICAgXCJjYWxjaGFpbi5uZXRcIixcbiAgICBcImV0aHBheXMubWVcIixcbiAgICBcImlkZXgtaW5mby5jb21cIixcbiAgICBcImlkZXgtbWFya2V0Lm9yZ1wiLFxuICAgIFwibXlldGhlcmV3YWxsZXRlLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGV0LTM3YTM2ai5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsdC0zN2E1MGUuY29tXCIsXG4gICAgXCJybnlldGhlc3dhbGxldC5jb21cIixcbiAgICBcIm1leW1vbmVycm8uY29tXCIsXG4gICAgXCJteWVudGVyd2VsbGV0LmNvbVwiLFxuICAgIFwibXlldG5lcndlbGxldC50b3BcIixcbiAgICBcIndhaWxsYnRjLmNvbVwiLFxuICAgIFwibXllbHRoZXJ3YWxsZXRyLmNvbVwiLFxuICAgIFwibXllcmh0ZXJ3ZWxsZXQuY29tXCIsXG4gICAgXCJtZXlldGhlcndhbGxsZXQuY29tXCIsXG4gICAgXCJtZXl0aGVyd2FsbGVudC5jb21cIixcbiAgICBcIm1leXRoZXJ3YWxscmV0LmNvbVwiLFxuICAgIFwiZXRoZXJib251cy5uZXRcIixcbiAgICBcImV0aHRvcHJvbW8ub3JnXCIsXG4gICAgXCJyZWdpc3Rlci1lb3MuaW9cIixcbiAgICBcImV0aGVyZXVtLWdldC5pbmZvXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FldC1pbmI5MGNhLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20udG9rZW4uc2lnbmludmVyaWNhdGlvbi5zaWdubWVzc2FnZS5jYXJwZWRpZW0ubGVnYWxcIixcbiAgICBcImNhcnBlZGllbS5sZWdhbFwiLFxuICAgIFwibXlldGhlcndhaWxldC5wd1wiLFxuICAgIFwieG4tLW15ZXRocmFsbGV0LW9sOWU4di5jb21cIixcbiAgICBcImtleXRyb24uaW9cIixcbiAgICBcInhuLS1teXRoZXJ3YWx0LXNtYmgxN2MuY29tXCIsXG4gICAgXCJiaXRjb2ludGFsay50b1wiLFxuICAgIFwiYml0Y29pbnRvbGsub3JnXCIsXG4gICAgXCJzZWJpbHR2LmNvbS50clwiLFxuICAgIFwiZXRoYm9udXMubmV0XCIsXG4gICAgXCJldGhlcnNwcm9tby5vcmdcIixcbiAgICBcImV0aGVyZ2l2aW5nLm9yZ1wiLFxuICAgIFwiZXRobi5jY1wiLFxuICAgIFwieG4tLW15ZXRocndhbHQtem1idDA1Yy5jb21cIixcbiAgICBcImV0aC5zaGFyZS1jb2luLm5ldFwiLFxuICAgIFwic2hhcmUtY29pbi5uZXRcIixcbiAgICBcInNhZmUuZXRoZ2l2ZXIuY29tXCIsXG4gICAgXCJldGhnaXZlci5jb21cIixcbiAgICBcImV0aGVyZXVtdXAudG9wXCIsXG4gICAgXCJpZGV4bWFya2V0cy1vZmZpY2lhbC5jb21cIixcbiAgICBcImlkZXgtbWFya2V0c2luLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGV0LXI3YTY3ai5jb21cIixcbiAgICBcInNwYXJrc3Rlci50ZWNoXCIsXG4gICAgXCJmbGFzaGJsb2Nrcy5pb1wiLFxuICAgIFwiZXRobm93Lm1lXCIsXG4gICAgXCJxdWFya2NoYWluLnN1cHBseVwiLFxuICAgIFwiZmFzdGV0aGdldC5jb21cIixcbiAgICBcInNlY3VyZXBldGguY2x1YlwiLFxuICAgIFwidHJvbi1vbmxpbmUuaW5mb1wiLFxuICAgIFwiYW5hdG9taWEuY29cIixcbiAgICBcInhuLS1teWV0aHJ3YWx0LXZtYmUxN2MuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS52ZXJpZmljYXRpb24uYXRsYXNlcmJpbC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRpLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxhdHQuY29tXCIsXG4gICAgXCJpZGV4LW1hcmtldHNsb2dpbi5jb21cIixcbiAgICBcImllZHgubWFya2V0XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5zaWduaW52ZXJpY2F0aW9uLnNpZ25tZXNzYWdlLmthcmFva2VzZXBldGkuY29tXCIsXG4gICAgXCJtb3JlLWV0aC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNpZ25pbnZlcmljYXRpb24uc2lnbm1lc3NhZ2Uud2JhYS5jb1wiLFxuICAgIFwidHViaWcuY29cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNpZ25pbnZlcmljYXRpb24uc2lnbm1lc3NhZ2UuY2FycGVkaWVtLmxlZ2FsXCIsXG4gICAgXCJzZW50aW5lbC1wcm90b2NvbC5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsdC1rYmI5NmkuY29tXCIsXG4gICAgXCJkZmluaXR5ZHJvcC5tbFwiLFxuICAgIFwiY29pbmJhc2V2ZXJpZmllci5jb21cIixcbiAgICBcImV0aGVyLWdpdmVhd2F5Lm5ldFwiLFxuICAgIFwiZXRoZ2V0Lm1lXCIsXG4gICAgXCJldGhib251cy5vcmdcIixcbiAgICBcImV0aC1naXZlLm1lXCIsXG4gICAgXCJldGhnZXRub3cuY29tXCIsXG4gICAgXCJldGhub3dwcm9tby5vcmdcIixcbiAgICBcImV0aGVyZ2lmdGluZy5jb21cIixcbiAgICBcImV0aGdyYWIuY29tXCIsXG4gICAgXCJldGhnLm1lXCIsXG4gICAgXCJqZGV4Lm1hcmtldFwiLFxuICAgIFwiaWRleC1teWFjY291bnQuY29tXCIsXG4gICAgXCJpbmRleC1tYXJrY3QuY29tXCIsXG4gICAgXCJsZG94Lm1hcmtldFwiLFxuICAgIFwiMTAwMDBldGgubmV0XCIsXG4gICAgXCJlb3NsYXVuY2guaW9cIixcbiAgICBcImNvaW5iYXNlLnByby1mb3JrLmNvbVwiLFxuICAgIFwicHJvLWZvcmsuY29tXCIsXG4gICAgXCJldGhnaXZlYXdheS56a3Iua3JcIixcbiAgICBcImV0aC1wcm9tby53aXhzaXRlLmNvbVwiLFxuICAgIFwiY2FsY2hhaW4uaW9cIixcbiAgICBcImFpci1lb3MuY29tXCIsXG4gICAgXCJnb3QtZXRoLmNvbVwiLFxuICAgIFwiZ2V0ZXRoLm9ubGluZVwiLFxuICAgIFwiZ2V0LmV0aGVyb2ZmaWNpYWwuY29tXCIsXG4gICAgXCJldGhlcm9mZmljaWFsLmNvbVwiLFxuICAgIFwidG9tb2NoYWluLnRlY2hcIixcbiAgICBcInhuLS1laHRlcmRldGEtd2Q2ZC5jb21cIixcbiAgICBcIm15Y3J5aXB0b3dhbGlldC5jb21cIixcbiAgICBcImxlbmRpdW0udGVjaFwiLFxuICAgIFwieG4tLW15ZXRocndhbGV0LXZyYjA1Yy5jb21cIixcbiAgICBcImtpbmV0aWNhaXJkcm9wLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwiZWxvbi1naXZlcy1ldGgucGFwZXJwbGFuZS5pb1wiLFxuICAgIFwicmVibDk4NC45OTk5ZXRoLmNvbVwiLFxuICAgIFwiOTk5OWV0aC5jb21cIixcbiAgICBcImV0aGNsYWltZXIuYnlldGhvc3QzMi5jb21cIixcbiAgICBcImVzc2VudGlhbGFpcmRyb3AudHlwZWZvcm0uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0cy1vZmZpY2lhbC5jb21cIixcbiAgICBcInVkZXgubWFya2V0XCIsXG4gICAgXCJpY2V4Lm1hcmtldFwiLFxuICAgIFwiaWRleHgubWFya2V0XCIsXG4gICAgXCJzdGFya3dhcmUub25saW5lXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0YS5vcmdcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRvLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldHQub3JnXCIsXG4gICAgXCJvbmVtZXcub25saW5lXCIsXG4gICAgXCJteWV0aGVydnZhbGV0LmlvXCIsXG4gICAgXCJldGgtcmVxdWVzdC5vcmdcIixcbiAgICBcImV0aHMuc3BhY2VcIixcbiAgICBcImJ0Yy1naWZ0Lm9yZ1wiLFxuICAgIFwiZXRoLWZyZWUuZ2l0aHViLmlvXCIsXG4gICAgXCJldGhlcmdpdmVtZS5jb21cIixcbiAgICBcImV0aGVyLWdpdmUuY29tXCIsXG4gICAgXCJldGgtc2hhcmUub3JnXCIsXG4gICAgXCJteWVyaGVyd2FsbGV0LnRrXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Lm5ld3NcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR6Lm9yZ1wiLFxuICAgIFwibXlldGhyd2FsbGV0Lm9yZ1wiLFxuICAgIFwibXlydm53YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FubGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3ZWxsYXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2VsbGV0cy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsdC1jcmIxN2MuY29tXCIsXG4gICAgXCJxdWFya2NoYWluLnB1YlwiLFxuICAgIFwiY2xhaW0tZXRoLmNvbVwiLFxuICAgIFwic2VuZC5ldGhlcmdvdC5jb21cIixcbiAgICBcImV0aGVyZ290LmNvbVwiLFxuICAgIFwic2VjdXJlcGF5LWV0aC5vcmdcIixcbiAgICBcImdpZnQtMTAwMDBldGguY29tXCIsXG4gICAgXCJteS1ldGhlcndhbGxzZWN1cmUuY29tXCIsXG4gICAgXCJzZWN1cmUzNzU0NDY4ODQ1MjEuc2FmZWV0aHBheS5jb21cIixcbiAgICBcInNhZmVldGhwYXkuY29tXCIsXG4gICAgXCJxdWFya2NoYWluLmluXCIsXG4gICAgXCJybnlldGhlcndhbGxlbC5jb21cIixcbiAgICBcInhuLS1tZXRocndhbGxldC11aWI5MmEuY29tXCIsXG4gICAgXCJkb21haW41MDFkb20uY29tXCIsXG4gICAgXCJteWV0aHdhbGxsZXQuaW5mb1wiLFxuICAgIFwic2VjdXJlNzU0MDU3MzI5MzUuc2FmZXRocGF5LmNvbVwiLFxuICAgIFwid2FsbGV0cy1ldGhlci5jb21cIixcbiAgICBcImJybS4xMDAwMGV0aC1naWZ0LmNvbVwiLFxuICAgIFwiZXRoc2VjdXJlLmluZm9cIixcbiAgICBcImdldC5pY28tZXRoLm5ldFwiLFxuICAgIFwiaWNvLWV0aC5uZXRcIixcbiAgICBcImNvbGxlY3RteWV0aGVycy5vcmdcIixcbiAgICBcImdpdmVmcmVlLWV0aC5jb21cIixcbiAgICBcIm5vdy01MDAwZXRoZXIucGFwZXJwbGFuZS5pb1wiLFxuICAgIFwiZXRoLWdpdmUuaW5mb1wiLFxuICAgIFwieG4tLW15dGhlcndhbGxldC1mdmIubmV0XCIsXG4gICAgXCJ4bi0tbXlldGhld2xsZXQtaWZlMjc5NGcuY29tXCIsXG4gICAgXCJ4bi0tbWV0aGVyd2FsbHQtY3JiNjcxOWcuY29tXCIsXG4gICAgXCJ4bi0tbXlldGVyd2xsZXQtbmw4ZXIyZC5jb21cIixcbiAgICBcInhuLS1tZXRoZXJhbGxldC1vbDllMDNjLmNvbVwiLFxuICAgIFwieG4tLW15dGhlcndhbGV0LXNyYjQ1Yy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xldC00OGE0MmouY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbHQtczhhN2cuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FldC1tbGIxOGNhLmNvbVwiLFxuICAgIFwieG4tLW1ldGhlcndhbGxlLXVpYjA1ay5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxldC1vYmI1NmkuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsZXQtNnFiNzdjLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsdC1md2IubmV0XCIsXG4gICAgXCJldGhnaXZlLm5ldFwiLFxuICAgIFwidHJvbi1ibG9jay5jb21cIixcbiAgICBcImlkZXgtbWFya2V0LnNpdGVcIixcbiAgICBcImV0aDRldmVyeW9uZS5jb21cIixcbiAgICBcIm1ldy1laHRlcndhbGxhdC5jb21cIixcbiAgICBcIjk0LjEwMC4xOC45NlwiLFxuICAgIFwiZ2V0Lml0LW5vdy1ldGguY29tXCIsXG4gICAgXCJpdC1ub3ctZXRoLmNvbVwiLFxuICAgIFwiZ2l2ZS5wcm9tb2V0aC5uZXRcIixcbiAgICBcInByb21vZXRoLm5ldFwiLFxuICAgIFwiZXRoZXJraWNrc3RhcnQuY29tXCIsXG4gICAgXCJldGgtaHlwZS5jb21cIixcbiAgICBcImluc3RhbnQtZXRoZXIuY29tXCIsXG4gICAgXCJwYXkuZXRod2l0aGV0aC5jb21cIixcbiAgICBcImV0aHdpdGhldGguY29tXCIsXG4gICAgXCIxMDAwMGV0aC1naWZ0LmNvbVwiLFxuICAgIFwia2xhcmVvbDUucnVcIixcbiAgICBcIjIwMDAwLnBhcGVycGxhbmUuaW9cIixcbiAgICBcInNlY3VyZTA5MzU1NTYxMy5zYWZldGhwYXkuY29tXCIsXG4gICAgXCJnZXQuaWNvLWV0aC5vcmdcIixcbiAgICBcImljby1ldGgub3JnXCIsXG4gICAgXCJwYXltZW50LWV0aGVyZXVtLm9ubGluZVwiLFxuICAgIFwidHJvbi1ibG9jay5pbmZvXCIsXG4gICAgXCJuZW8tb25saW5lLmluZm9cIixcbiAgICBcImV0aGNvbmZpcm0uaW5mb1wiLFxuICAgIFwib2ZmZXIuZXRoc24uY29tXCIsXG4gICAgXCJldGhzbi5jb21cIixcbiAgICBcImh5ZHJvcmFpbmRyb3AudHlwZWZvcm0uY29tXCIsXG4gICAgXCJldGhnaWZ0Lm9yZ1wiLFxuICAgIFwiZXRoZXJkZWx0YS5naXRoaXViLmlvXCIsXG4gICAgXCJnaXRoaXViLmlvXCIsXG4gICAgXCJldGhlci1wcm9tby5vcmdcIixcbiAgICBcImF0bjQzNy5ldGhnaXZlZXRoLmNvbVwiLFxuICAgIFwiZXRoZ2l2ZWV0aC5jb21cIixcbiAgICBcIjUwMDBldGgtcHJvbW8uY29tXCIsXG4gICAgXCJteWV0aGVyb2ZmaWNpYWwuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGF0Lm9ubGluZVwiLFxuICAgIFwibXlldGhlcndhbGxldHcub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsbHRlLm5ldFwiLFxuICAgIFwibXlldGhlcndhbHJldC5ydVwiLFxuICAgIFwieG4tLW1ldGhlcndhbGV0LXVpYjM5Zi5jb21cIixcbiAgICBcIm15ZXRsaGVyd2FsbGV0LnByb1wiLFxuICAgIFwiYml0dHJleGEuY29tXCIsXG4gICAgXCJ4bi0tYnR0cngtN3JhNWEuY29tXCIsXG4gICAgXCJiaXR0cmV4ci5jb21cIixcbiAgICBcImJpdHRyZXgtYWNjb3VudC12ZXJpZmljYXRpb24uY29tXCIsXG4gICAgXCJiaXR0cmV4LWxvZ2luLmNvbVwiLFxuICAgIFwiYmlpdGJheS5jb21cIixcbiAgICBcImtjdWNvaW4uY29tXCIsXG4gICAgXCJ2dmFsbGJ0Yy5jb21cIixcbiAgICBcImV0aC1wcm9tby5uZXRcIixcbiAgICBcInRkZXgubWFya2V0XCIsXG4gICAgXCJsb2dpbi1teWV0aGVyd2FsbGV0cy5jb21cIixcbiAgICBcImNsYWltZXRoLmVwaXp5LmNvbVwiLFxuICAgIFwid2FsbGV0ZW9zLm9yZ1wiLFxuICAgIFwibmF0aGFuaWVscG9wcGVyLnByb21vLWV0aHMuY29tXCIsXG4gICAgXCJwcm9tby1ldGhzLmNvbVwiLFxuICAgIFwicGF5LmV0aGNvbmZpcm0uY29tXCIsXG4gICAgXCJldGhjb25maXJtLmNvbVwiLFxuICAgIFwiZXRoLXNoYXJlLmNvbVwiLFxuICAgIFwiZXRoLWdpZnQuY29tLnBhcGVycGxhbmUuaW9cIixcbiAgICBcImlpZGV4bWFya2V0LmNvbVwiLFxuICAgIFwiZWJ0d2VpbmZpbmFuY2UuY29tXCIsXG4gICAgXCJjYXJkYW5vZXRoZXJldW0uY29tXCIsXG4gICAgXCJldGhlcmdpdmVhd2F5LndlYnNpdGVcIixcbiAgICBcImdldC1ldGhlcmV1bS5pbmZvXCIsXG4gICAgXCJnZXQtZXZlbnQtZXRoZXJldW0uaW5mb1wiLFxuICAgIFwiZ2l2ZS1ldGgubmV3c1wiLFxuICAgIFwiZXRoLWJveC54Zi5jelwiLFxuICAgIFwiZXRoZXJzZm9ybWUubmV0XCIsXG4gICAgXCJnaWZ0ZXRoZXJzLmNvbVwiLFxuICAgIFwibTM0MmVkaXVtLmV0aGVyc2Zvcm1lLm5ldFwiLFxuICAgIFwiMTAwMDAtZXRoLmNvbVwiLFxuICAgIFwiaWNvc3RhcmV4Lm1pcHJvcGlhLmNvbVwiLFxuICAgIFwiZXRoc2dpdmUuY29tXCIsXG4gICAgXCJnaXZlYXdheS1ldGhlci5jb21cIixcbiAgICBcImJvbnVzLmdpZnRldGhlcnMuY29tXCIsXG4gICAgXCJnZXQtZXRocy5jb21cIixcbiAgICBcImdldC1ldGhlcmV1bS5zaXRlXCIsXG4gICAgXCJjcnlwdG9zLXByb21vcy5jb21cIixcbiAgICBcInNhZmV0aHBheS5jb21cIixcbiAgICBcInBheWdpdmVhd2F5LmNvbVwiLFxuICAgIFwidG9rZW5wdWJsaWNzYWxlcy5jb21cIixcbiAgICBcImV0aGdpdmUub25saW5lXCIsXG4gICAgXCJldGhlci52dVwiLFxuICAgIFwiZ2V0bm93ZXRoLmNvbVwiLFxuICAgIFwid2F2ZXMtZXRoZXJldW0tZXRoLm9yZ1wiLFxuICAgIFwiZXRoZXJldW0tZXRoLmxpZmVcIixcbiAgICBcIm15Y3J5cHRvLWNvbS5jb21cIixcbiAgICBcInF1YXJrY2hhaW4ucGxcIixcbiAgICBcImdldC01MDAxLWV0aGVyZXVtLmNvbVwiLFxuICAgIFwiZ2V0LTUwMDAtZXRoZXJldW0uY29tXCIsXG4gICAgXCJteWV0emVyd2FsbGV0LmNvbVwiLFxuICAgIFwicHJvbW9idGMud2luXCIsXG4gICAgXCJ0b2tlbmFpcmRyb3AudHlwZWZvcm0uY29tXCIsXG4gICAgXCJ0cmFuc2Zlci5zYWZlcnBheWV0aC5jb21cIixcbiAgICBcInNhZmVycGF5ZXRoLmNvbVwiLFxuICAgIFwicjUubXNcIixcbiAgICBcInhuLS1teXRoZXJ3YWxldC0zcWI5N2MuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2xsZXQtcGpiNXUuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbHQtMHJiNjRjLmNvbVwiLFxuICAgIFwiY3J5cHRvZmF6ZS5jb21cIixcbiAgICBcImhlZGVyYWhlc2hncmFwaC5jb21cIixcbiAgICBcImV0aGVyZ2lmdC5vcmdcIixcbiAgICBcIm15ZXRoZWVyd2FsbGV0LnB3XCIsXG4gICAgXCJzZWN1cmUtZ2l2ZS1ldGguY29tXCIsXG4gICAgXCJrYW5uLmlvXCIsXG4gICAgXCJwdW5kaXgudGVjaFwiLFxuICAgIFwicXVhcmtjaGFpbnMuaW9cIixcbiAgICBcImV0aGNvbGxlY3Rpb24ucGFwZXJwbGFuZS5pb1wiLFxuICAgIFwiaHlkcm9nZ2VucGxhdGZvcm0uY29tXCIsXG4gICAgXCJsZGN4Lm1hcmtldFwiLFxuICAgIFwiZXRoLWFpcmRyb3AuY29tXCIsXG4gICAgXCJldGhlci1wcm9tby51bmFzLmN6XCIsXG4gICAgXCJ4bi0tdGJ0Yy16cGEzNGEuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbHQtY3JiMjdjLmNvbVwiLFxuICAgIFwiaHlkcm9wbGF0Zm9ybS5vcmdcIixcbiAgICBcImV0aC1naXZlYXdheS50b2RheVwiLFxuICAgIFwiZXRoZXJnZXQub25saW5lXCIsXG4gICAgXCJldGhwbGF0Zm9ybS5vcmdcIixcbiAgICBcIm15Y3J5cHRvbi5uZXRcIixcbiAgICBcIjUwMDBldGhlcmV1bS5vbmxpbmVcIixcbiAgICBcImhlZGVyYWhhc2hnYXBoLmNvbVwiLFxuICAgIFwiNTAwMC1ldGgucGFwZXJwbGFuZS5pb1wiLFxuICAgIFwiemlsbGlxYWJsb2NrY2hhaW4ub3JnXCIsXG4gICAgXCJpZGVjLm1hcmtldFwiLFxuICAgIFwiaWhleC5tYXJrZXRcIixcbiAgICBcInpjbGFzc2ljY29pbnMuY29tXCIsXG4gICAgXCJvbWlzZWdvd2FsbGV0Lm5ldHdvcmtcIixcbiAgICBcIm11c2sudnVcIixcbiAgICBcInF1YXJrY2hhaW4tcHJlc2FsZS5pb1wiLFxuICAgIFwiZXRoYWlyZHJvcC5saXZlXCIsXG4gICAgXCJldGhnaXZlYXZ2YXkuc2l0ZVwiLFxuICAgIFwiZXRoZXJ1bXMtZ2l2aW5nYXdheS5hdHNwYWNlLnR2XCIsXG4gICAgXCJldGhlcmZyZWUudGVjaFwiLFxuICAgIFwic2VjdXJlLWV0aGVyZXVtLnR3MS5zdVwiLFxuICAgIFwicGhhbnRhc21hLWljby5pb1wiLFxuICAgIFwic2VudGluZWxwcm90b2NvbC5wd1wiLFxuICAgIFwiMjRoLmluZm9yYS5odVwiLFxuICAgIFwiZXRoLXNlY3VyZXBheS5jb21cIixcbiAgICBcInNlY3VyZWNldGguY29tXCIsXG4gICAgXCJldGgtZ2l2aW5nLmdhXCIsXG4gICAgXCJmcmVlLWV0aHMucGFwZXJwbGFuZS5pb1wiLFxuICAgIFwibmV4b3Rva2VuLm9yZ1wiLFxuICAgIFwicXVhcmtjaGFpbi10b2tlbnMuaW9cIixcbiAgICBcImdpdmVhdnZheS0xMDAwMGV0aC5vbmxpbmVcIixcbiAgICBcImV0aHByb21vLm9yZ1wiLFxuICAgIFwiaS1kZXhtYXJrZXRzLmNvbVwiLFxuICAgIFwiZWRlbmNoYWluLnNpdGVcIixcbiAgICBcInhuLS1teXRoZXJ3YWxsZXQtNXZiLm5ldFwiLFxuICAgIFwiaS1kZXhtYXJrZXQuY29tXCIsXG4gICAgXCJiaS10dHJleC5jb21cIixcbiAgICBcInd3dy1iaXR0cmV4LmNvbVwiLFxuICAgIFwieG4tLWJpZmluZXgtZmI0Yy5jb21cIixcbiAgICBcInhuLS1ibG9ja2NhaW4tZzk1ZC5jb21cIixcbiAgICBcInhuLS1jb2luYmFzLXo4YS5pbmZvXCIsXG4gICAgXCJ4bi0taHRidC0zb2EwYS5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsdC1jcmI5NzQ4Zy5jb21cIixcbiAgICBcInhuLS1wb2xvbml4LTE3YS5jb21cIixcbiAgICBcInhuLS10cm8tazV5LmNvbVwiLFxuICAgIFwicHJpdmNvaW4uaW9cIixcbiAgICBcImZyZWUtZXRoLnBhcGVycGxhbmUuaW9cIixcbiAgICBcImloY3gubWFya2V0XCIsXG4gICAgXCJoZWxiaXpjb2luLm5ldFwiLFxuICAgIFwidGVsZWdyYW0tdG9rZW4uaW9cIixcbiAgICBcImljb3N0YXRzLmlvXCIsXG4gICAgXCJtdXNrLXBhcnR5LWdpZnRzLnVwZG9nLmNvXCIsXG4gICAgXCJ5b2JpdHRyYWRpbmcubmV0XCIsXG4gICAgXCJ5b2JpdC10cmFkaW5nLm5ldFwiLFxuICAgIFwic2VjdXJldHJhbnNmZXIuZXRocHJvbW90aW9uLmNvbVwiLFxuICAgIFwiZXRocHJvbW90aW9uLmNvbVwiLFxuICAgIFwiYnJpY2tibG9ja2lvLmluZm9cIixcbiAgICBcImNvbGxlY3QuZXRoZm9yeW91LmNvbVwiLFxuICAgIFwiZXRoZm9yeW91LmNvbVwiLFxuICAgIFwiZ2V0bXlldGhvLnBhcGVycGxhbmUuaW9cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbHQtb3ZiLm5ldFwiLFxuICAgIFwiaWRleG1hcmtldHMuY29tXCIsXG4gICAgXCJldGhzYWZlcGF5Lm5ldFwiLFxuICAgIFwicHJlc2FsZS5nZXRteWV0aGVycy5uZXRcIixcbiAgICBcImdldG15ZXRoZXJzLm5ldFwiLFxuICAgIFwieG4tLXRidGMtdXBhOTRhLmNvbVwiLFxuICAgIFwieG4tLWl0YnRjLTlnMWIuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0aC5vcmdcIixcbiAgICBcImJyaWNrYmxvY2tzLmlvXCIsXG4gICAgXCJ6aWxsaXFhbmV0d29yay5jb21cIixcbiAgICBcImJyaWNrYmxvY2suY2NcIixcbiAgICBcInF1YXJrY2hhaW4uZGVcIixcbiAgICBcInByb21vLWdpdmUtZXRoZXJldW0ub3JnXCIsXG4gICAgXCJnaXZlLWV0aGVyZXVtLm9yZ1wiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZWF3YXkuc2l0ZVwiLFxuICAgIFwiZm9ya2RlbHRhLm5ldFwiLFxuICAgIFwiaS1pZGV4Lm1hcmtldFwiLFxuICAgIFwia2luZWNvc3lzdGVtLmlvXCIsXG4gICAgXCJxdWFyay1jaGFpbi5pb1wiLFxuICAgIFwicXVhcmtjaGFpbi5vcmdcIixcbiAgICBcInF1YXJrY2hhbG4uaW9cIixcbiAgICBcInF1YXJrY2hhaW4ud2Vic2l0ZVwiLFxuICAgIFwiZ2V0LWV0aGVyZXVtLm1sXCIsXG4gICAgXCI1MDAwZXRoLm5ldFwiLFxuICAgIFwiY2xhaW0ucGF5ZXRocy5jb21cIixcbiAgICBcInBheWV0aHMuY29tXCIsXG4gICAgXCJnYW1lb2ZkZWNlcHRpb24uZ2V0LTUwMDAtZXRoLmNvbVwiLFxuICAgIFwiemlsbGlxYWJsb2NrY2hhaW4uY29tXCIsXG4gICAgXCJldGhnaXZlYXZ2YXkuY29tXCIsXG4gICAgXCJyZWJlbGxpb3MuY29tXCIsXG4gICAgXCJraW5lY29zeXN0ZW1zLm9yZ1wiLFxuICAgIFwiemlsbGlxYS5vbmxpbmVcIixcbiAgICBcIm15Y3J5cHRvLmdldC01MDAwLWV0aC5jb21cIixcbiAgICBcImdldC01MDAwLWV0aC5jb21cIixcbiAgICBcImVkZW4tY2hhaW4uaW9cIixcbiAgICBcImNvaW5idGNuZXdzLmNvbVwiLFxuICAgIFwieG4tLXBvbG9tZXgtY3phLmNvbVwiLFxuICAgIFwiaGVscGNvaW5iYXNlLmNvbVwiLFxuICAgIFwiYWNjb3VudC1jb2luYmFzZS5jb21cIixcbiAgICBcImNvaW5iYXNlLWV0aC1naXZlYXdheS5jb21cIixcbiAgICBcImZyZWUtZXRoLm5ld3NcIixcbiAgICBcImZvcmtkZWx0YXMuY29tXCIsXG4gICAgXCJlbG9uLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5zZWN1cmUuYWNjZXNzLWNoZWNrZXIuY29tXCIsXG4gICAgXCJhY2Nlc3MtY2hlY2tlci5jb21cIixcbiAgICBcImV0aGVyZ2V0LnVzXCIsXG4gICAgXCJmcmVlY29pbmdpZnRzLmNvbVwiLFxuICAgIFwicXVpY2sucGF5ZXRocy5jb21cIixcbiAgICBcInRha2UtZXRoLm9ubGluZVwiLFxuICAgIFwiZXRoZXItZ2l2ZWF3YXkudGVjaFwiLFxuICAgIFwieG4tLXNoYXBlc2hmdC1jNWEuY29tXCIsXG4gICAgXCJ4bi0tbXljcnB0by1rNjRjLmNvbVwiLFxuICAgIFwib3JjaGlkcHJvdG9jb2xzLmNvbVwiLFxuICAgIFwiaGFkZXBsYXRmb3JtLm5ldFwiLFxuICAgIFwicXVhcmtjaGFpbi50ZWNoXCIsXG4gICAgXCJoZWRlcmFoYXNoZ3JhcGguc3RvcmVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuYWNjZXNzLWNoZWNrZXIuY29tXCIsXG4gICAgXCJmcmVlZXRoLmluZm9cIixcbiAgICBcImNvaW5iYXNsZS5jb21cIixcbiAgICBcImV0aC1wYXltZW50Lm9ubGluZVwiLFxuICAgIFwiZXRoZXJldW01MDAwLmNvbVwiLFxuICAgIFwiZ2V0LWV0aC51c1wiLFxuICAgIFwiZXRoc2VjdXJlcGF5LmNvbVwiLFxuICAgIFwiYm9udXMuZXRoZXJnaXZlcy5jb21cIixcbiAgICBcImV0aGVyZ2l2ZXMuY29tXCIsXG4gICAgXCJvY29pbnMudGVjaFwiLFxuICAgIFwiaGVkZXJhaGFzaGdyYXBoLm9ubGluZVwiLFxuICAgIFwiNTAwMC5ldGhlcmV1bWdpdmUuY29tXCIsXG4gICAgXCJldGhlcmV1bWdpdmUuY29tXCIsXG4gICAgXCJldGhlcmdpdmUuMDAwd2ViaG9zdGFwcC5jb21cIixcbiAgICBcInZlcmlmaWVkZXRoLmNvbVwiLFxuICAgIFwiZXRoLWdpdmVhd2F5LmNvLm5mXCIsXG4gICAgXCJnaXZlYXZ2YXkxMDAwMGV0aC5ob3N0XCIsXG4gICAgXCI1MDAwZXRoLm9yZ1wiLFxuICAgIFwiZXRoLWdpdmVhd2F5LnVwZG9nLmNvXCIsXG4gICAgXCJnaWZ0LWV0aGVyLmNvbVwiLFxuICAgIFwiYm9udXMuZ2lmdC1ldGhlci5jb21cIixcbiAgICBcIm15Y3J5cHRvLmNtXCIsXG4gICAgXCJ0cm9ubGFic25ldHdvcmsuY29tXCIsXG4gICAgXCJjZG5zZmlsZXMuY29tXCIsXG4gICAgXCJ4bi0tY29uYmFzZS1jZmIuY29tXCIsXG4gICAgXCJibG9ja3NjaGFqbi5pbmZvXCIsXG4gICAgXCJibG9ja2NoYWpucy5pbmZvXCIsXG4gICAgXCJibG9ja2NoYWxqbi5pbmZvXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FsbGV0LWZjYy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsZS0za2IwMWYuY29tXCIsXG4gICAgXCJibG9ja3MtY2hhaW5zLmluZm9cIixcbiAgICBcImJsb2Nrc2NoYWxuLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NoYWotM3ZiLmluZm9cIixcbiAgICBcImJsb2tjbG5haW4uaW5mb1wiLFxuICAgIFwiYmxva2NsbmFsbi5pbmZvXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbGV0LWVkYi5jb21cIixcbiAgICBcInhuLS1ibG9ja2NobG4taGRiLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NobG4tYzNhLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NobG4tNjFhLmluZm9cIixcbiAgICBcInhuLS1ibGNrY2hhbG4tYzZhLmluZm9cIixcbiAgICBcInhuLS1ibGNrY2hhbG4tNjZhLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2hhaS00OGE3MmQuaW5mb1wiLFxuICAgIFwiY2tlbi5zaXRlXCIsXG4gICAgXCJibG9ja2NoYWlocy5pbmZvXCIsXG4gICAgXCJldGhlcmV1bS52dVwiLFxuICAgIFwibXlldGhlcmV3YWxsZXQubmV0XCIsXG4gICAgXCJteWV0aGFyd2FsbGV0LnN0cmVhbVwiLFxuICAgIFwibWV5dGhjcnJ3YWxsZXQucnUuY29tXCIsXG4gICAgXCJnZXQtZXRoZXJldW0ub3JnXCIsXG4gICAgXCJheHBpcmUudGVjaFwiLFxuICAgIFwiZXRoLWdpdmVhLXdheS5jb21cIixcbiAgICBcImVvc3Jld2FyZC5pb1wiLFxuICAgIFwiYml0ZmluZXguZXVcIixcbiAgICBcInd3dy1teWNyeXB0b3MuY29tXCIsXG4gICAgXCJ3d3ctbXljcnlxdG8uY29tXCIsXG4gICAgXCJteWNyeXB0bzRjYXNoLmNvbVwiLFxuICAgIFwibXljcnlsdG8uY29tXCIsXG4gICAgXCJteWNyeXB0OS5jb21cIixcbiAgICBcIm15Y3J5cHRvYy5jb21cIixcbiAgICBcImdpdmVhd2F5LWV0aC5jb21cIixcbiAgICBcInF1YXJrY2hhaW4taWNvLmlvXCIsXG4gICAgXCJldGgtMjRoLmNvbVwiLFxuICAgIFwiZXRoZ2l2ZWF3YXlzLm5ldFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zdGFydC5kb3dubG9hZFwiLFxuICAgIFwibXlldGhlcmV1bXdhbGxldHByby5jb21cIixcbiAgICBcIm15ZWhyZXRld2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC1jYXNoLmRvd25sb2FkXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LW9mZmljaWFsLmRvd25sb2FkXCIsXG4gICAgXCJteWV0cmhyZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteW5lcnRod2FsbGV0LmNvbVwiLFxuICAgIFwibXluZXRod2FsbGV0LmNvbVwiLFxuICAgIFwibXluZXR3YWxsZXRldGguY29tXCIsXG4gICAgXCJteW5ld2FsbGV0ZXRoLmNvbVwiLFxuICAgIFwiYmFuY2F0b2tlbi5vcmdcIixcbiAgICBcInppbGxpcWEuc2l0ZVwiLFxuICAgIFwiZnJlZS1naXZlLWV0aC5jb21cIixcbiAgICBcImljb25mb3VuZGF0b24uY29tXCIsXG4gICAgXCJnZXRldGhzLmxpdmVcIixcbiAgICBcImV0aGVyZHJvcHMuY29tXCIsXG4gICAgXCJldGhlcmV1bWRyb3AuYmF0Y2F2ZS5uZXRcIixcbiAgICBcImJhdGNhdmUubmV0XCIsXG4gICAgXCJldGgtcGxhdGZvcm0uY29tXCIsXG4gICAgXCJtYWluLW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJldGgtZ2V0Lm9ubGluZVwiLFxuICAgIFwiY29sbGVjdGV0aC5jb21cIixcbiAgICBcInByb21vLWV0aGVyLmNvbVwiLFxuICAgIFwiZXRoZXJldW13YWxsZXRnZW5lcmF0b3IuY29tXCIsXG4gICAgXCJldGhlcmV1bXMubGl2ZVwiLFxuICAgIFwiZXRocHJvbW8ubmV0XCIsXG4gICAgXCJnaWZ0LTUwMDBldGgub3JnXCIsXG4gICAgXCJwcm9tb3Rpb25ldGguY29tXCIsXG4gICAgXCJib251cy5naWZ0LWV0aGVycy5jb21cIixcbiAgICBcImdpZnQtZXRoZXJzLmNvbVwiLFxuICAgIFwiZ3JhbS10b2tlbi1zYWxlLmNvbVwiLFxuICAgIFwibXlldGhlcndhbHQuY29tXCIsXG4gICAgXCJubnljcnlwdG8uY29tXCIsXG4gICAgXCJteXJjcnlwdG8uY29tXCIsXG4gICAgXCJteWVyeXB0by5jb21cIixcbiAgICBcIm1yeWNyeXB0by5jb21cIixcbiAgICBcIm15Y3J5cnB0by5jb21cIixcbiAgICBcIm15Y3J5cHRvLmx0ZFwiLFxuICAgIFwibXljcnlwdG8uZ3JvdXBcIixcbiAgICBcIm15Y3J5cHRvLmlua1wiLFxuICAgIFwibXljcnlwdG8ucHJvbW9cIixcbiAgICBcImV0aC1yZXdhcmQuY29tXCIsXG4gICAgXCJnaXZlLWV0aC5vbmxpbmVcIixcbiAgICBcIm12bW9uZXJvLmNvXCIsXG4gICAgXCI1MDAwZXRoZ2lmdC5jb21cIixcbiAgICBcInF1YXJrY2hhaW4tdG9rZW5zYWxlLmlvXCIsXG4gICAgXCJldGhlcmV1bWdpdmVhd2F5NTAwMC5jb21cIixcbiAgICBcImdldC01MDAwZXRoLmNvbVwiLFxuICAgIFwidGFrZTUwMDBldGguY29tXCIsXG4gICAgXCJldGhlcl9wcm9tby5raXNzci5jb21cIixcbiAgICBcImtpc3NyLmNvbVwiLFxuICAgIFwiZXRoLWdpdmVhdnZheS5vbmxpbmVcIixcbiAgICBcImV0aGVyZXVtcy5jbG91ZFwiLFxuICAgIFwiaWNvLXRlbGVncmFtLm5ldFwiLFxuICAgIFwiaWNvdGVsZWdyYW1ncm91cC5jb21cIixcbiAgICBcImljby10ZWxlZ3JhbS5pc1wiLFxuICAgIFwiaWNvLXRlbGVncmFtY29pbi5jb21cIixcbiAgICBcImljby10ZWxlZ3JhbS5jY1wiLFxuICAgIFwidG9rZW50ZWxlZ3JhbS5pbmZvXCIsXG4gICAgXCJ0b2tlbnRlbGVncmFtLmxpdmVcIixcbiAgICBcImxldGhlcndpbmRvd3MuY29tXCIsXG4gICAgXCI1MDAwZXRoLWdpZnQuY29tXCIsXG4gICAgXCJnZXQtZXRoZXJldW0uZ2lmdFwiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZS5jendlYi5vcmdcIixcbiAgICBcImN6d2ViLm9yZ1wiLFxuICAgIFwiNTAwMGV0aC1naXZlYXdheS5jb21cIixcbiAgICBcImV0aGVyLWdpdmVhd2F5LmF0c3BhY2UuZXVcIixcbiAgICBcImF0c3BhY2UuZXVcIixcbiAgICBcImV0aC1haXJkcm9wLm9ubGluZVwiLFxuICAgIFwicG9seW1hdGgtbmV0d29yay5jb21cIixcbiAgICBcInNlY3VyZXBheWV0aC5jb21cIixcbiAgICBcImdpZnQ1MDAwZXRoLmNvbVwiLFxuICAgIFwibG9jYWxldGhlcmlldW0uY29tXCIsXG4gICAgXCJnaXZlLTUwMDBldGgub3JnXCIsXG4gICAgXCJib251cy5ldGhlcnNnaWZ0cy5jb21cIixcbiAgICBcImV0aGVyc2dpZnRzLmNvbVwiLFxuICAgIFwibXlva25hd2VsbC5jb21cIixcbiAgICBcIm15bGV0aGVyd2FybGV0LmNvbVwiLFxuICAgIFwibXl3aW5kb3J3YWxsZXQuY29tXCIsXG4gICAgXCJ0cm9uLWNvaW4ub3JnXCIsXG4gICAgXCJnaWZ0LTUwMDBldGguY29tXCIsXG4gICAgXCJkYW9zdGFjay1pY28uaW9cIixcbiAgICBcInhuLS1teWV0aGV3YWxldC1tczhlcnEuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGV3YWxsZXQtM3FiMzE1OGcuY29tXCIsXG4gICAgXCJ4bi0tbXllZXJ3YWxsZXQtbWw4ZWw3YS5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC01cWJ4LmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGx0LWNyYjUwNThnLmNvbVwiLFxuICAgIFwieG4tLW1laGVyd2FsbGV0LTk5OGUyN2QuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2xsZXQteHQ5ZTBrLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGxlLWpiOWUweS5jb21cIixcbiAgICBcInhuLS1teWV0ZXJhbGxldC1jbThlbzBjLmNvbVwiLFxuICAgIFwieG4tLW15ZWhld2FsbGUtaXcyZTFnaS5jb21cIixcbiAgICBcInhuLS1teWN5cHRvLWM2M2MuY29tXCIsXG4gICAgXCJ4bi0tbXlldGVyd2FsbHQtY3JiMTA4N2cuY29tXCIsXG4gICAgXCJ4bi0tbXl0ZXJ3YWxsZXQtM3FiOTA4N2cuY29tXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FlLXhkNmRhMTNkaWEuY29tXCIsXG4gICAgXCJ4bi0teXRoZXJ3YWxsZXQtMnFiNjkxOGcuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsZXQtbXM4ZTUzZC5jb21cIixcbiAgICBcImVvc3Jld2FyZHMuaW9cIixcbiAgICBcInRyb24tbmV0d29yay5vcmdcIixcbiAgICBcImJvbnVzLmV0aGVyc2dpZnQuY29tXCIsXG4gICAgXCJldGhlcnNnaWZ0LmNvbVwiLFxuICAgIFwicXVhcmtjaGFpbi10b2tlbi5pb1wiLFxuICAgIFwiZ2lmdDUwMDAtZXRoLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC14bjEuY29tXCIsXG4gICAgXCJ4bi0taHRidGMtcTgxYi5jb21cIixcbiAgICBcImhpdHRidGUuY29tXCIsXG4gICAgXCJoaXRsYnRjLmNvbVwiLFxuICAgIFwicG9sb25laXguY29cIixcbiAgICBcInBvbG9tZWl4LmNvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0MC5jb21cIixcbiAgICBcIm15ZWh0ZXJ3YWxsZXQtaHQuY29tXCIsXG4gICAgXCJjbG8tYWlyZHJvcC5pbmZvXCIsXG4gICAgXCJmcmVlY29pbmVycy5jb21cIixcbiAgICBcImdldC1ldGhlcmV1bS5jY1wiLFxuICAgIFwibm15ZXRsZXJ3YWlsZXQuY29tXCIsXG4gICAgXCJldGgtcHJvbW8ud2Viei5jelwiLFxuICAgIFwiZXRoZXJjbGFpbXMucmYuZ2RcIixcbiAgICBcIjUwMDBldGgucmYuZ2RcIixcbiAgICBcImV0aC1wcm9tby5raXNzci5jb21cIixcbiAgICBcIm5teWV0bGVyd2FpaWV0LmNvbVwiLFxuICAgIFwiZ2V0eW91cmV0aC5jb21cIixcbiAgICBcImV0aC10b2RheS5yZi5nZFwiLFxuICAgIFwiZXRoZXJldW0ub3JnLWdpdmVhd2F5LmxpdmVcIixcbiAgICBcImJvbnVzLmV0aGVyLWdpZnQuY29tXCIsXG4gICAgXCJldGhlci1naWZ0LmNvbVwiLFxuICAgIFwiZXRoLWdpdmluZ2F3YXkuY29tXCIsXG4gICAgXCJldGhnaXZlYXdheS5saXZlXCIsXG4gICAgXCJldGhnaXZlYXdheS5vcmdcIixcbiAgICBcImdldDUwMDBldGguY29tXCIsXG4gICAgXCI1MDAwZXRoLWdpdmVhd2F5LmdldGZvcmdlLmlvXCIsXG4gICAgXCJzaGFwZXNsaGlmdC5pb1wiLFxuICAgIFwic2hhcGVza2lmdC5pb1wiLFxuICAgIFwiYm9udXMuZXRoLWdpZnRzLmNvbVwiLFxuICAgIFwiZXRoLWdpZnRzLmNvbVwiLFxuICAgIFwib2ZmcHJvbW9ldGguY29tXCIsXG4gICAgXCJldGhwcm9tb3ZlcmdlLmNvbVwiLFxuICAgIFwicG9sb25pZXgtd2l0aGRyYXdhbHMuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImdldGhlci1naWZ0LmNvbVwiLFxuICAgIFwiZ2V0LWV0aGVyLmZ1bmRcIixcbiAgICBcImV0aC1haXJkcm9wLmxpdmVcIixcbiAgICBcImNsYXNzaWNldGhlcndhbGx0LmNvbVwiLFxuICAgIFwiaGVkZXJhaGFzaGdyYXBoLmluZm90b2tlbnNhbGUuY29tXCIsXG4gICAgXCJubXlldGxlcndhbGlldC5jb21cIixcbiAgICBcImV0aC1kcm9wLmNvbVwiLFxuICAgIFwibW55Y3J5cHRvZXRod2FsbGV0LmNvbVwiLFxuICAgIFwiYm9udXMuZXRoZXItZ2l2ZXMuY29tXCIsXG4gICAgXCJldGhlci1naXZlcy5jb21cIixcbiAgICBcImV0aGZvcmV0aC5jb21cIixcbiAgICBcImV0aGVyZXVtcG9tby5vbmxpbmVcIixcbiAgICBcIm1ueWV0bmhlcndhbGlldC5jb21cIixcbiAgICBcImV0aC1mb3VuZGF0aW9uLmdpdGh1Yi5pb1wiLFxuICAgIFwiZm9ya2RlbHRhZ2l0aHViLmlvXCIsXG4gICAgXCJ3d3dldGhlcmRlbHRhLmNvbVwiLFxuICAgIFwieG4tLWV0aGVyZGx0YS1saWIuY29tXCIsXG4gICAgXCJ4bi0tZXRoZXJkZWx0LTg3NmQuY29tXCIsXG4gICAgXCJ4bi0tZXRoZXJkZWxhLXNzNmQuY29tXCIsXG4gICAgXCJ4bi0tdGhlcmRlbHRhLXVmN2QuY29tXCIsXG4gICAgXCJ4bi0tZXRoZXJ3YWxsZXQtdHY4ZXE3Zi5jb21cIixcbiAgICBcInhuLS1tZWhlcndhbGxlLTIxMmVpMTdvLmNvbVwiLFxuICAgIFwieG4tLW15ZXRld2FsbGV0LTRkYzQ3OTZnLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJhbGx0LTBrOWVqeC5jb21cIixcbiAgICBcInhuLS1ldGVyZWx0YS1vdTljOWguY29tXCIsXG4gICAgXCJ3YWxsZXQtbWV3LmNvbVwiLFxuICAgIFwieG4tLWV0aGVyZWx0YS11MDVkLmNvbVwiLFxuICAgIFwieG4tLW1jcnlwdG8tcnBkLmNvbVwiLFxuICAgIFwiZ2l2ZS01MDAwZXRoLmNvbVwiLFxuICAgIFwiYm9udXMuZXRoZXItZ2lmdHMuY29tXCIsXG4gICAgXCJnaXZlNTAwMC1ldGguY29tXCIsXG4gICAgXCI1MDAwZXRoZ2l2ZS5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxldC1uczhlNzNkLmNvbVwiLFxuICAgIFwiYWVsZnRva2VuLmNvbVwiLFxuICAgIFwiZGZpbml0eS5tbFwiLFxuICAgIFwibXlldGh2ZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJtaXRocmlsdG9rZW4udGVjaFwiLFxuICAgIFwid2luLWV0aC5vcmdcIixcbiAgICBcImV0aC10b2RheS5lcGl6eS5jb21cIixcbiAgICBcImdpdmU1MDAwZXRoLmNvbVwiLFxuICAgIFwiZXRoaGl0Lm9yZ1wiLFxuICAgIFwibmtuLXRva2VuLmlvXCIsXG4gICAgXCJnZXQtZXRoZXIubWVcIixcbiAgICBcInhuLS1teWV0aGVyd2FsbGUtb2NjLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdsbGV0LXc0OGVwNmEuY29tXCIsXG4gICAgXCJwcm9tby5ldGhlcmV1bWJvbnVzLm9ubGluZVwiLFxuICAgIFwiZXRoZXJldW1ib251cy5vbmxpbmVcIixcbiAgICBcImV0aHRvZ2V0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHJ1LmNvbVwiLFxuICAgIFwiaS1teWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwiZW9zLWNhbmR5LmNvbVwiLFxuICAgIFwibmVvbmV4Y2hhbmdlLndlYnNpdGVcIixcbiAgICBcImdldC1ldGhlci5naWZ0XCIsXG4gICAgXCJldGhlcnNjYW4udGVjaFwiLFxuICAgIFwieG4tLW15ZXRoZXdsbGV0LWlmZTY0OTRnLmNvbVwiLFxuICAgIFwibmNhc2h0b2tlbi5vcmdcIixcbiAgICBcImV0aC5raXNzci5jb21cIixcbiAgICBcImV0aHRyYW5zYWN0aW9uLmV6eXJvLmNvbVwiLFxuICAgIFwiZXRoLWdpdmUub3JnXCIsXG4gICAgXCJldGh0b3RyYWRlLmNvbVwiLFxuICAgIFwidG9rZW50ZWxlZ3JhbS5uZXRcIixcbiAgICBcImV0aC1wcml2YXRlLWtleS53ZWJ6LmN6XCIsXG4gICAgXCJjb2xsZWN0LWV0aC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQubHRcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQtcmVnaXN0ZXIuY29tXCIsXG4gICAgXCJldGgtcHJvbW90aW9uLmdldGZvcmdlLmlvXCIsXG4gICAgXCJidGMtZ2lmdHMuaW5mb1wiLFxuICAgIFwiZW9zLWRhYy5jb21cIixcbiAgICBcImxvY2FsZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJmcmVlNTAwMGV0aC5jb21cIixcbiAgICBcImV0aHBheXNhZmUuY29tXCIsXG4gICAgXCJpY28tdGVsZWdyYW0uY29cIixcbiAgICBcImV0aC1naXZpbmcuY29tXCIsXG4gICAgXCJ4bi0tY29uYmFzLWd2YTFhLmNvbVwiLFxuICAgIFwid3d3LWNvbG5iYXNlLmNvbVwiLFxuICAgIFwiNTAwMGV0aC1naXZlYXdheS5vbmxpbmVcIixcbiAgICBcImdpdmVmcmVlZXRoLmNvbVwiLFxuICAgIFwiZXRoZXItcHJvbW8uZ2V0Zm9yZ2UuaW9cIixcbiAgICBcImdldGhlci5mdW5kXCIsXG4gICAgXCJldGhlcmV1bS1naXZlYXdheS50ZWtjaXRpZXMuY29tXCIsXG4gICAgXCJ0cm9uLWFpcmRyb3AuaW5mb1wiLFxuICAgIFwiZXRobi5jYXNoXCIsXG4gICAgXCJlb3MtYWlyZHJvcC5jb21cIixcbiAgICBcInhuLS1tZWRpbS05ZDJiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocmFsbGV0LXprOWU2dy5jb21cIixcbiAgICBcImV0aGVyZXVtcy0yMDE4LWdpdmUtYXdheS5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwiZ2l2aW5nYXdheWV0aC5jb21cIixcbiAgICBcImV0aGVyZXVtLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwiZXRoc2FmZS50cmFkZVwiLFxuICAgIFwiY2hlY2stZXRocGF5bWVudHMxLmtpc3NyLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZWF3YXkua2lzc3IuY29tXCIsXG4gICAgXCJzbWFydG9saW5rcy5jb21cIixcbiAgICBcImxpdml2aWQuY29tXCIsXG4gICAgXCJjbGlja21vbmV5c3lzdGVtMS5jb21cIixcbiAgICBcImV0aGVyZXVtLWdpdmUuYnlldGhvc3QxNi5jb21cIixcbiAgICBcImdpdmluZ2F3YXlldGhlcmV1bS5jb21cIixcbiAgICBcImV0aGVyZXVtLmN6d2ViLm9yZ1wiLFxuICAgIFwiZXRoYy5mdW5kXCIsXG4gICAgXCJldGgtZ2l2ZWF3YXkudHJhZGVcIixcbiAgICBcImdyYW0taWNvLmlvXCIsXG4gICAgXCJldGhlcnNjYW5zLm5ldFwiLFxuICAgIFwiaW8tZW9zLmNvbVwiLFxuICAgIFwidGVsZWdyYW0taWNvLnRlY2hcIixcbiAgICBcImljby10ZWxlZ3JhbS5tb25leVwiLFxuICAgIFwiaWNvbnRva2VuLmZvdW5kYXRpb25cIixcbiAgICBcImV0aC1naXZlLWF3YXkud2Viei5jelwiLFxuICAgIFwiNTAwMGV0aC5pbmZvXCIsXG4gICAgXCJhdXRob3JpemUubGl2ZVwiLFxuICAgIFwiYXpvbmUtd2ViLmNvbVwiLFxuICAgIFwiYmluYW5jZS1naXZlYXdheS5maXJlYmFzZWFwcC5jb21cIixcbiAgICBcImJpdHdlbGZhcmUuYml6XCIsXG4gICAgXCJjcnlwdG9jdXJyZW5jaWVzLWJpdGNvaW4uY29tXCIsXG4gICAgXCJldGgtZnJlZXNoYXJpbmcuY29tXCIsXG4gICAgXCJldGgtZ2l2ZXMuY29tXCIsXG4gICAgXCJldGgtcHJpdmF0ZS5jb21cIixcbiAgICBcImV0aC10cmFucy5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwiZXRoLXRyYW5zYWN0aW9ucy5jb21cIixcbiAgICBcImV0aGVyLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwiZXRoZXItdHJhbnNmZXIub25saW5lXCIsXG4gICAgXCJldGhlcmJsZXNzaW5ncy5jb21cIixcbiAgICBcImV0aGVyY2xhaW1zLmJ5ZXRob3N0OC5jb21cIixcbiAgICBcImV0aGVyZXVtZHJvcC5jb21cIixcbiAgICBcImV0aGVyZXVtZHJvcC5vcmdcIixcbiAgICBcImV0aGVyZXVtb25lLmluZm9cIixcbiAgICBcImV0aGVyZ2l2ZWF3YXkud2luXCIsXG4gICAgXCJldGhlcmdpdmVhd2F5cy50dW1ibHIuY29tXCIsXG4gICAgXCJldGhlcml1bWFpcmRyb3AuY29tXCIsXG4gICAgXCJldGhlcnVtLnNpdGUxMjMubWVcIixcbiAgICBcImV0aGYuYmlkXCIsXG4gICAgXCJldGhnaXZlLmluZm9cIixcbiAgICBcImV0aGdpdmVhd2F5Lm9ubGluZVwiLFxuICAgIFwiZXRoc2VuZC5vbmxpbmVcIixcbiAgICBcImV0aHRyYW5zYWN0aW9uLnVuYXV4LmNvbVwiLFxuICAgIFwiZ2V0LWV0aGVycy5jb20uY3AtMzIud2ViaG9zdGJveC5uZXRcIixcbiAgICBcImdpdmUtYmluYW5jZS5wYXJ0eVwiLFxuICAgIFwiaXAyMjIuaXAtNTQtMzgtMTIwLmV1XCIsXG4gICAgXCJteWV0aGVycHJvbW8uY29tXCIsXG4gICAgXCJuZW9uZXhjaGFuZ2Uub25saW5lXCIsXG4gICAgXCJ0b2tlbmNyb3dkc2FsZS5pbmZvXCIsXG4gICAgXCJldGhlcmdpZnR3YWxsZXQuY29tXCIsXG4gICAgXCJldGhwcm9tby5naWZ0XCIsXG4gICAgXCJnaXZlYXdheS1ldGhlcmV1bS5jb21cIixcbiAgICBcImdpdmVhd2F5ZXRoZXIuY29tXCIsXG4gICAgXCJldGhlcmV1bXByb21vLmluZm9cIixcbiAgICBcImV0aGhpdC5jb21cIixcbiAgICBcImZyZWUtNTAwMGV0aC5jb21cIixcbiAgICBcImV0aGMuZ2lmdFwiLFxuICAgIFwiZGZuaXR5Lm9yZ1wiLFxuICAgIFwiY29pbmJhc2UuZHJvcHBhZ2VzLmNvbVwiLFxuICAgIFwibWV5dGhhcHZldHRhbC5jb21cIixcbiAgICBcImdldC1ldGhlcnMuY29tXCIsXG4gICAgXCJncmFtZm91bmRhdGlvbi5pb1wiLFxuICAgIFwiY2hlY2stZXRocGF5bWVudHMua2lzc3IuY29tXCIsXG4gICAgXCJjZW50cmF0b2tlbi5zaXRlXCIsXG4gICAgXCJncmFtdG9rZW5pY28uY29tXCIsXG4gICAgXCJldGgtZ2lmdGluZy5zaXRlXCIsXG4gICAgXCJldGhlcmV1bXMtcHJvbW8uYml0YmFsbG9vbi5jb21cIixcbiAgICBcImV0aGVyZXVtLXByb21vMjAxOC5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwiZXRocHJvbW8uY29tXCIsXG4gICAgXCJmcmVlLWV0aGVyZXVtLmN6d2ViLm9yZ1wiLFxuICAgIFwiZXRobi52dVwiLFxuICAgIFwiZXRoZXJwcm9tby5vcmdcIixcbiAgICBcImV0aHBheS5zaXRlXCIsXG4gICAgXCJldGhnaWZ0LmluZm9cIixcbiAgICBcInRva2VucHVibGljc2FsZS5jb21cIixcbiAgICBcImV0aGVycHJvbW8ub25saW5lXCIsXG4gICAgXCJ0cm9uLW5leHRsZXZlbC5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwibXljcnlwdG8uY29tcGFueVwiLFxuICAgIFwibXlldGhlcmFweXdhaWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyYXB5d2FsaWxldC5jb21cIixcbiAgICBcIm15ZXRoZXJhcHl3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyYXB5d2FsbGlldC5jb21cIixcbiAgICBcIm15YmV0aGVybnZ3YWxsZXQuY29tXCIsXG4gICAgXCJteW90aGVyYXB5d2FsbGV0LmNvbVwiLFxuICAgIFwibXl1dWV0aGVyYXN3YWxsZXQuY29tXCIsXG4gICAgXCJubnljdG5jcndhbGxpZXQuY29tXCIsXG4gICAgXCJubnljdG5jcnZ2YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGV1cndhbGxldC5jb21cIixcbiAgICBcImljby10ZWxlZ3JhbS10b24uY29tLnJ1XCIsXG4gICAgXCJ0b24taWNvLmdhXCIsXG4gICAgXCJtYWlsaW5nc2VydmVyMi5jb21cIixcbiAgICBcImdyYW0tdG9rZW4ub3JnXCIsXG4gICAgXCJsY28tdGVsZWdyYW0ub3JnXCIsXG4gICAgXCJ0b25vZ3JhbS5vcmdcIixcbiAgICBcImV0aC1naXZlLmtpc3NyLmNvbVwiLFxuICAgIFwibXllZ2V0aGVyY293d2FsbGV0LmNvbVwiLFxuICAgIFwidHJvbi1naXZlYXZheS13ZWVrbHlyZXBvcnQuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImV0aGRyb3BuZXcubWxcIixcbiAgICBcImNyeXB0b3BsdXMuYmVcIixcbiAgICBcImRmaW5pdHkub3JnLmluXCIsXG4gICAgXCJwYXlmb3JmZWVzLm9ubGluZVwiLFxuICAgIFwibm55Y3RuY3J3YWlsbGV0LmNvbVwiLFxuICAgIFwibXl1bmV0aGVyaGF3YWxsZXQuY29tXCIsXG4gICAgXCJhaXJkcm9wLWJsdXplbGxlLmNvbVwiLFxuICAgIFwidHJvbmZvdW5kYXRpb24udGVjaFwiLFxuICAgIFwic2FmZWx5LXRyYW5zZmVyLmNvbVwiLFxuICAgIFwiZXRoLnZ1XCIsXG4gICAgXCJ4bi0tbXlldGVyYWxsZXQtbmw4ZW8wYy5jb21cIixcbiAgICBcImdldC1ldGgucGxcIixcbiAgICBcImN6LWJpbmFuY2UuY29tXCIsXG4gICAgXCJzaWduYWxzeC5jb21cIixcbiAgICBcImV0aC1naWZ0LnR3MS5zdVwiLFxuICAgIFwibXlldG5hcnZlbGxhdC5jb21cIixcbiAgICBcIm15bmJldGhlcm52d2FsbGV0LmNvbVwiLFxuICAgIFwibXllaGNyd2FsaWxldC5jb21cIixcbiAgICBcImdkYXhzdXBwb3J0LmNvbVwiLFxuICAgIFwiY29pbmJhc2VleGNoYW5nZS5vcmdcIixcbiAgICBcImNvaW5iYXNlaGVscC5pbmZvXCIsXG4gICAgXCJjb2luYmFzZWFzc2lzdC5pbmZvXCIsXG4gICAgXCJraW5lY29zeXN0ZW0ubmV0XCIsXG4gICAgXCJ0ZWxlZ3JhbXRva2VuLmdsb2JhbFwiLFxuICAgIFwidGVsY29pbmFpcmRyb3AuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsZXQtM3FiMTBjLmNvbVwiLFxuICAgIFwiZXRoZ2l2ZWF3YXkuY2x1YlwiLFxuICAgIFwiY29pbm5iYXNlLmNvbVwiLFxuICAgIFwiZGFpbHlpbmVxdWFsaXR5Lm9yZ1wiLFxuICAgIFwiZXRoZy5jelwiLFxuICAgIFwiY3J5cHRvLXBheW91dC50a1wiLFxuICAgIFwidmVjaGFpbi12ZW4uY29tXCIsXG4gICAgXCJ0b2tlbnNhbGUtdGVsZWdyYW0uY29tXCIsXG4gICAgXCJldGhyLmNjXCIsXG4gICAgXCJubnllY3RoZW53ZWxsYXQuY29tXCIsXG4gICAgXCJubnlpaWN0ZWhlcndhaWxpYXR0LmNvbVwiLFxuICAgIFwidGhlbWlzbmV0d29yay5vcmdcIixcbiAgICBcInd3dy1teWV0aGVyd2VsbGV0LmNvbVwiLFxuICAgIFwiZXRoLXRvZGF5LmNvbVwiLFxuICAgIFwiZXRoZy5naWZ0XCIsXG4gICAgXCJldGhlci16ZXJvLmluZm9cIixcbiAgICBcImV0aGdpdmVhd2F5LmluZm9cIixcbiAgICBcImJvbnVzLmV0aGVyc2dpdmUuY29tXCIsXG4gICAgXCJldGhlcnNnaXZlLmNvbVwiLFxuICAgIFwidHJvbmZvdW5kYXRpb24ubWVcIixcbiAgICBcImV0aHMubGlcIixcbiAgICBcImF1Y3R1cy5uZXR3b3JrXCIsXG4gICAgXCJhdWN0dXNzLm9yZ1wiLFxuICAgIFwiYXVjdHVzLm9yZy5pblwiLFxuICAgIFwiYXVjdHVzLWljby5uZXR3b3JrXCIsXG4gICAgXCJ4bi0tYXVjdHMtMWdiLm9yZ1wiLFxuICAgIFwiY29pbm1ha2VyYm90LmNvbVwiLFxuICAgIFwiYmxubmFuY2UuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmhlbGlvaG9zdC5vcmdcIixcbiAgICBcInRvbi10ZWxlZ3JhbS5jb21cIixcbiAgICBcInRvbnB1YmxpYy5vcmdcIixcbiAgICBcImNsYWltLmV0aGRlYWwuaW5mb1wiLFxuICAgIFwidGVsZWdyYW0udHJhZGVcIixcbiAgICBcInRlbGVncmFtLWNvaW4ub3JnXCIsXG4gICAgXCJubnlpaWN0ZWhlcnZ2YWlsaWF0dC5jb21cIixcbiAgICBcImV0aHMudnVcIixcbiAgICBcInNoaXZvbXMuaW9cIixcbiAgICBcInRlbGVncmFtc2FsZS5jb21cIixcbiAgICBcImhlZGVyYXNoYXNoZ3JhcGguY29tXCIsXG4gICAgXCJldGgtdHJhbnNhY3Rpb24uc2l0ZTQ0LmNvbVwiLFxuICAgIFwieG4tLW1ldGhlcndsbGV0LWxuOWVxaS5jb21cIixcbiAgICBcInhuLS1iaXRjb2ludGxrLTg1YS5vcmdcIixcbiAgICBcImNvaW5iYWFzZS5jZlwiLFxuICAgIFwiY29pbm5iYXNlLm1sXCIsXG4gICAgXCJjb2lubmJhc2UudGtcIixcbiAgICBcImJpbmFhbmNlLmdhXCIsXG4gICAgXCJiaW5hYW5jZS5jZlwiLFxuICAgIFwiYmluYW5jY2UuY2ZcIixcbiAgICBcImJpbmFuY2NlLm1sXCIsXG4gICAgXCJ4bi0tbXlldGxoZXJhbGxldC0zNDFnLmNvbVwiLFxuICAgIFwicGF2ZWxkdXJvdi5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwic2VjdXJlLWV0aC10cmFuc2FjdGlvbnMuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImdpdmVhd2F5LWV0aGVyZXVtLm9yZ1wiLFxuICAgIFwiZXRocGF5ZC5jb21cIixcbiAgICBcImV0aGRyb3AuaW5mb1wiLFxuICAgIFwiaS1teWV0aGVyd2FsbmV0LmNvbVwiLFxuICAgIFwibWV0cm9ub21lLXRva2VuLmlvXCIsXG4gICAgXCJjb2luLXpjLmNvbVwiLFxuICAgIFwieG4tLWJpdGNvbi1td2EuY29tXCIsXG4gICAgXCJteWV0dGhlcndhbGxldC54eXpcIixcbiAgICBcImV0aHBheW1lbnQuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImV0aG9wZW4uY29tXCIsXG4gICAgXCJ0ZWxlZ3JhbW5ldHdvcmsub3JnXCIsXG4gICAgXCJnZXRoLmNjXCIsXG4gICAgXCJ0ZWxlZ3JhbS5jZW9cIixcbiAgICBcImV0aGVyc2Nhbi1naXZlYXdheS5lcGl6eS5jb21cIixcbiAgICBcImV0aHMuYnpcIixcbiAgICBcInN3YWFweS5uZXR3b3JrXCIsXG4gICAgXCJiaW5hbmNlLmV0aGRlYWwuaW5mb1wiLFxuICAgIFwiZXRoZGVhbC5pbmZvXCIsXG4gICAgXCJncmFtbmV0d29yay5vcmdcIixcbiAgICBcImdhbGF4eS1lczBsdXRpb25zLmNvbVwiLFxuICAgIFwiZXRoLmFsdGVydmlzdGEub3JnXCIsXG4gICAgXCJtdXNrLmdpZnRcIixcbiAgICBcIm15Y3J5cHRvLmJ6XCIsXG4gICAgXCJldGgudmdcIixcbiAgICBcImV0aC1naXZlYXdheS12b3RlLmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJldGgtcHJvbW8uY29tXCIsXG4gICAgXCJ3b3JrLm5lbHNjb25zdWx0LmNvbS5uZ1wiLFxuICAgIFwiZXRoZXJmcmVlZ2l2ZS5jb21cIixcbiAgICBcInNlY3VyZS1zMjhoM2gyajU0amVoZGg0M2poM2s1aDQybDRoMjNoazZsNDlzanh2c2F0b3NoaWxpdGUuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImdpdmVhd2F5LXBheW1lbnQtYWRkLmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJiaWctcHJvbW8tbWFyY2gudHVtYmxyLmNvbVwiLFxuICAgIFwiZXRoZ2l2ZS5naXRodWIuaW9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRyYWRlaWNvLmJsb2dzcG90LmRlXCIsXG4gICAgXCJvd2FpbnByaXRjaGFyZC5jby51a1wiLFxuICAgIFwiZXQuZ2xcIixcbiAgICBcInhuLS1jb25kZXNrLXd3NGMuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2xsZXQtNnFiMjI0OWcuY29tXCIsXG4gICAgXCJhaXJkcm9wLWV0aGVyLmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJpbmZvLXRyYW5zYWN0aW9uLmNvbVwiLFxuICAgIFwiZXRoLmhuXCIsXG4gICAgXCJiaW5hbmNlLXByb21vLm5ldFwiLFxuICAgIFwidHJ1c3QtY3J5cHRvcGF5bWVudC5jb21cIixcbiAgICBcImV0aGVyZXVtLXRyYW5zZmVyLm9ubGluZVwiLFxuICAgIFwiaWNvdG9uc2FsZS5jb21cIixcbiAgICBcImV0aGVyYm9udXNlcy5jb21cIixcbiAgICBcImV0aGZyZWVnZXQuY29tXCIsXG4gICAgXCJ0b25ncmFtLm1lXCIsXG4gICAgXCJmdW5mYWlyY29pbi5vcmdcIixcbiAgICBcImNvaW5iYXNlLXNlY3VyZS1hMmszNGouYml0YmFsbG9vbi5jb21cIixcbiAgICBcImV0aGVyZXVtdHJhbnMuY29tXCIsXG4gICAgXCJ4bi0tY29uZGVzLThiYjE2NjFkLmNvbVwiLFxuICAgIFwiZXRoZXJnaXZlYXdheXR3ZWV0LnRrXCIsXG4gICAgXCJldGgtZ2l2ZWF3YXkuZ3FcIixcbiAgICBcIm5ueWV0dGllcnZ3YWxsYXQuY29tXCIsXG4gICAgXCJubnlldHRpZXJ2d2FsbGV0LmNvbVwiLFxuICAgIFwiZXRoLnZvdGVcIixcbiAgICBcImV0aC1wcm9tby5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwiZXRoZnJlZXBheS5jb21cIixcbiAgICBcInByb21vLXRyeC50a1wiLFxuICAgIFwicGF5bWVudGFkZHJlc3MudHVtYmxyLmNvbVwiLFxuICAgIFwiY3J5cHRvbmdyYW0ub3JnXCIsXG4gICAgXCJjYW1wYWlnbnRva2VuLmJsb2dzcG90LmRlXCIsXG4gICAgXCJjb2luLXByb21vcy5jb21cIixcbiAgICBcInhuLS15dGhlcndhbGxldC1pdzhleDhjLmNvbVwiLFxuICAgIFwic21hcnRleGNoYW5nZWNlbnRlci50a1wiLFxuICAgIFwieG4tLW9pbmRlc2stMTVhLmNvbVwiLFxuICAgIFwiZXRoLXRyYW5zYWN0aW9uLnNlY3VyZS5raXNzci5jb21cIixcbiAgICBcIm90b2V2ZXJ5ZGF5LmluZm9cIixcbiAgICBcImV0aGZyZWVjYW5keS5iaXRiYWxsb29uLmNvbVwiLFxuICAgIFwiZXRoZXJzY2FuaW8uZ2l0aHViLmlvXCIsXG4gICAgXCJpY28tZ3JhbS5uZXRcIixcbiAgICBcImdyYW10b2tlbi5uZXR3b3JrXCIsXG4gICAgXCJldGhmcmVlZ2l2ZS5jb21cIixcbiAgICBcImV0aGVyLXByb21vLmJpdGJhbGxvb24uY29tXCIsXG4gICAgXCJ4bi0tY2luZGVzay1jeDRjLmNvbVwiLFxuICAgIFwidGhlYWRzbGVhZGVyLjAwMHdlYmhvc3RhcHAuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0aWNvLmJsb2dzcG90LmRlXCIsXG4gICAgXCJldGgtZ2l2ZWF3YXkuaW5mb1wiLFxuICAgIFwic3luY2ZhYi5ldVwiLFxuICAgIFwiZXRoLWdpdmVhd2F5LmNvbVwiLFxuICAgIFwiaWNvZXRoLnRrXCIsXG4gICAgXCJldGgtZ2l2ZWF3YXktNzA2Lmh0bWxjb21wb25lbnRzZXJ2aWNlLmNvbVwiLFxuICAgIFwibXliaW5hbmNlLmluZm9cIixcbiAgICBcInhuLS1teWV0aGV3YWxsZXQta2pjLmNvbVwiLFxuICAgIFwicG9seXN3YW1yLmlvXCIsXG4gICAgXCJwb2x5c3dhcm0ubWVcIixcbiAgICBcInBvbHlzd2FybXMuaW9cIixcbiAgICBcImV0aDRmcmVlLm1sXCIsXG4gICAgXCJpY28tdGVsZWdyYW0tdG9uLmNvbVwiLFxuICAgIFwidGVsZWdyYW0udHdcIixcbiAgICBcImdyYW10b24uaW5mb1wiLFxuICAgIFwiZ3JhbXNhcC5lbnRlcnByaXNlc1wiLFxuICAgIFwiaWNvLXRlbGVncmFtLmNsdWJcIixcbiAgICBcInRlbGVncmFtLm9uZVwiLFxuICAgIFwiZXRoYXJzY2FuLmlvXCIsXG4gICAgXCJ4bi0tY29pbmRlcy1qaGIuY29tXCIsXG4gICAgXCJibG9jaWtjaGFpci5pbmZvXCIsXG4gICAgXCJldGgtY3otMzE5Lmh0bWxjb21wb25lbnRzZXJ2aWNlLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWV0LTB0OGVhLmNvbVwiLFxuICAgIFwiZXRoLWdpdmVhd2F5LTUxNC5odG1sY29tcG9uZW50c2VydmljZS5jb21cIixcbiAgICBcInhuLS1tdGhlcndhbGxldC16MTlleDFhLmNvbVwiLFxuICAgIFwieG4tLWVvLWU5YS5jb21cIixcbiAgICBcImNvc3NzLmlvXCIsXG4gICAgXCJjYWxsaXN0b25ldHdvcmsudGVjaFwiLFxuICAgIFwieG4tLW1ldGhlcndhbGx0LTgxOWVvMWEuY29tXCIsXG4gICAgXCJldGhmcmVlcGF5cy5jb21cIixcbiAgICBcIm5ueWV0dGllcnZ3YWlsZXQuY29tXCIsXG4gICAgXCJ4bi0taGFwZWhpZnQtb2gwZGUuY29tXCIsXG4gICAgXCJncmFtLnZjXCIsXG4gICAgXCJib251cy5ldGhlcnBheW91dC5jb21cIixcbiAgICBcImV0aGVycGF5b3V0LmNvbVwiLFxuICAgIFwiZXRoZXJldW0tZ2l2ZWF3YXkuaW5mb1wiLFxuICAgIFwieG4tLWJuYW5jLWZzYXguY29tXCIsXG4gICAgXCJ4bi0tYmlubmNlLXkwYS5jb21cIixcbiAgICBcImV0aC1naXZlYXdheS0yMDkuc3RhdGljaHRtbGFwcC5jb21cIixcbiAgICBcImJpbmFuY2UuYml0YmFsbG9vbi5jb21cIixcbiAgICBcImJpbmFuY2UtZ2l2ZS5jb21cIixcbiAgICBcImlsaWwucHdcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnNlbmQtdHJhbnNhY3Rpb25fOGhsZzZ6OG1ndDZ6eWcuaWxpbC5wd1wiLFxuICAgIFwidGVsZWdyYW0uc2l0ZVwiLFxuICAgIFwidGVsZWdyYW0uYXVjdGlvblwiLFxuICAgIFwibWlyb3NraWkuY29tXCIsXG4gICAgXCJldGgtdHJhbnNhY3Rpb25zLm5lb2NpdGllcy5vcmdcIixcbiAgICBcIm9ubGluZS1lb3Mub3JnXCIsXG4gICAgXCJkYXRhLXRva2VuLm9yZ1wiLFxuICAgIFwiZXRoOTUzODgzLmh0bWxjb21wb25lbnRzZXJ2aWNlLmNvbVwiLFxuICAgIFwicmVldmVjbGFuY3kud2l4c2l0ZS5jb21cIixcbiAgICBcInRyYW5zZmVyLWV0aC5uZW9jaXRpZXMub3JnXCIsXG4gICAgXCJldGguc2VjdXJlLXRyYW5zYWN0aW9uc3NlY3VyZS5jb21cIixcbiAgICBcInNlY3VyZS10cmFuc2FjdGlvbnNzZWN1cmUuY29tXCIsXG4gICAgXCJubnlpaWN0ZWhlcnZ2YWlsaWF0LmNvbVwiLFxuICAgIFwib2RhY2hpLm5lb2NpdGllcy5vcmdcIixcbiAgICBcImJpdHRyZXgtZ2l2ZS5jb21cIixcbiAgICBcInBvbGljeXBhbC5pbmZvXCIsXG4gICAgXCJjaGFuZ2xsZXkub3JnXCIsXG4gICAgXCJybnllcnRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJ4bi0tdGhhYnlzcy11OGEuY29tXCIsXG4gICAgXCJjYWxsaXN0by1haXJkcm9wLmNvbVwiLFxuICAgIFwidGVsZWdyYW1mb3VuZGF0aW9uLm9yZ1wiLFxuICAgIFwicG9seW1hdGhuZXR3b3JrLm9yZ1wiLFxuICAgIFwiZXRoZXJldW0tcHJvbW8uYml0YmFsbG9vbi5jb21cIixcbiAgICBcImRmaW50dHkub3JnXCIsXG4gICAgXCJkZnRuaXR5Lm9yZ1wiLFxuICAgIFwidXNlcm1kLm5ldFwiLFxuICAgIFwieG4tLWdlbW4tbnphYi5jb21cIixcbiAgICBcInhuLS1ibmFuY2UtM3ZhLmNvbVwiLFxuICAgIFwieG4tLWJpbm5jZS15YzhiLmNvbVwiLFxuICAgIFwieG4tLWJuYW5jZS1wOWEuY29tXCIsXG4gICAgXCJ4bi0tYmluYW5lLTB1YS5jb21cIixcbiAgICBcImJpbmFsY2UuY29tXCIsXG4gICAgXCJiaW5pbmNlLmNvbVwiLFxuICAgIFwieG4tLWNvbmJhc2UtcHphLmNvbVwiLFxuICAgIFwieG4tLWNvbmJhc2Utc2ZiLmNvbVwiLFxuICAgIFwieG4tLWNvaW5iYXMteHlhLmNvbVwiLFxuICAgIFwieG4tLWNvaW5iYXMtejhhLmNvbVwiLFxuICAgIFwieG4tLWNvaW5ic2UtOXdhLmNvbVwiLFxuICAgIFwieG4tLWNvaW5ic2UtbHdhLmNvbVwiLFxuICAgIFwieG4tLXBvbG9uZXgtdmZiLmNvbVwiLFxuICAgIFwieG4tLXBsb25pZXgtbDBhLmNvbVwiLFxuICAgIFwieG4tLXBsbmlleC1ieGFiLmNvbVwiLFxuICAgIFwieG4tLWhhdnZuLTl6YS5pb1wiLFxuICAgIFwiaGF2dmVuaW8uY29tXCIsXG4gICAgXCJudWNlbHVzLnZpc2lvblwiLFxuICAgIFwibWV0cm9ub21ldG9rZW4uaW9cIixcbiAgICBcIm1lZ2FuZm94bG92ZXlvdS5jb21cIixcbiAgICBcInhuLS15ZXRoZXJ3YWxsZS1pdzhlMXMuY29tXCIsXG4gICAgXCJ0cm9uLW9ubGluZS5vcmdcIixcbiAgICBcIm15ZW50aGVyZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC10ZWFtLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC51c2VybWQubmV0XCIsXG4gICAgXCJ4bi0teWV0aGVyd2FsbGUtdHY4ZXp0LmNvbVwiLFxuICAgIFwieG4tLWNvaW5kZWstODczYy5jb21cIixcbiAgICBcImRmbGluaXR5Lm9yZ1wiLFxuICAgIFwiaXBzeC5wcm9tb1wiLFxuICAgIFwiaGF2dmVuLXNhbGUuY29tXCIsXG4gICAgXCJ0b2tlbnNhbGUtYWRoaXZlLmNvbVwiLFxuICAgIFwiYXRhcml0b2tlbi5sdGRcIixcbiAgICBcInRyYW5zZmVyLWFkZHJlc3MtY29uZmlybWF0aW9uLmRyb3BwYWdlcy5jb21cIixcbiAgICBcImRmaW5sdHkub3JnXCIsXG4gICAgXCJwb2xvbmlleC53b3JrXCIsXG4gICAgXCJ0b2tlbnNhbGUtaGF2dmVuLmluXCIsXG4gICAgXCJpY28taGF2dmVuLm9yZ1wiLFxuICAgIFwic2VjdXJlLnBvbG9uaWV4LndvcmtcIixcbiAgICBcInZlY2hhaW4tZm91bmRhdGlvbi5vcmdcIixcbiAgICBcInRlbGVncmFtLnRva3lvXCIsXG4gICAgXCJmb3JrZGVsdGEuaW9cIixcbiAgICBcInRvbi1zYWxlLmNvbVwiLFxuICAgIFwiaWNvLXRlbGVncmFtLm9ubGluZVwiLFxuICAgIFwidGVsZWdyYW10b2tlbi5pb1wiLFxuICAgIFwiZ29uZXR3b3JrLWFpcmRyb3AuY29cIixcbiAgICBcInNlY3VyZS10cmFuc2FjdGlvbi1jb25maXJtYXRpb24uZHJvcHBhZ2VzLmNvbVwiLFxuICAgIFwibmVvbmV4Y2hhbmdlcy5vcmdcIixcbiAgICBcImV0aC10cmFuc2FjdC5zZWN1cmUuZHJvcHBhZ2VzLmNvbVwiLFxuICAgIFwiNmtoYi5wYXltZW50LWNoZWNrZXItZXRoZXJldW0taWQtYnNseWZ0ZXhqdXdjZ3Y4LmZpbGVzdXNyLmNvbVwiLFxuICAgIFwiYWthc2hhLXdvcmxkLmNvbVwiLFxuICAgIFwiYWRkcmVzcy10cmFuc2Zlci1jb25maXJtYXRpb24uZHJvcHBhZ2VzLmNvbVwiLFxuICAgIFwiYjV6Lm5ldFwiLFxuICAgIFwicC5iNXoubmV0XCIsXG4gICAgXCJ0b2tlbnNhbGUueG4tLWhhdnZlLTdsMWIuY29tXCIsXG4gICAgXCJ4bi0tY29pbmRlcy1ieDNjLmNvbVwiLFxuICAgIFwieG4tLWNvaW5kZWstczczYy5jb21cIixcbiAgICBcImxvY2FlbHRoZXJ1bS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQudG9rZW5pbXBvcnQuY29tXCIsXG4gICAgXCJ0b2tlbmltcG9ydC5jb21cIixcbiAgICBcImxlYWRzY29pbi5uZXR3b3JrXCIsXG4gICAgXCJsb2NhbGV0aGVyZW9tLmNvbVwiLFxuICAgIFwiaGF2dmVucy53aW5cIixcbiAgICBcInhuLS1tZXRoZXJ3YWxsZS1qYjllanEuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcmFsbGUtamI5ZXhtLmNvbVwiLFxuICAgIFwidGVmb29kLm1lXCIsXG4gICAgXCJoYXZ2ZW50b2tlbi5jb21cIixcbiAgICBcImhhdnZlbi5jY1wiLFxuICAgIFwiaGF2dmVuLmV1XCIsXG4gICAgXCJoYXZ2ZW4udG9wXCIsXG4gICAgXCJteXdhbGxldGV0aGVyLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHQuc2l0ZVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGxlLXc0OGVyaC5jb21cIixcbiAgICBcImVsLXBldHJvLWNvaW4uY29tXCIsXG4gICAgXCJ4bi0teWV0ZXJ3YWxsZXQtYm04ZXltLmNvbVwiLFxuICAgIFwic2FsZS1vcmNoaWQuY29tXCIsXG4gICAgXCJlbGVjdHJpZnktYXNpYS5pbmZvXCIsXG4gICAgXCJ0cm9uLWZvdW5kYXRpb24ub3JnXCIsXG4gICAgXCJkZmxubHR5Lm9yZ1wiLFxuICAgIFwicG9seXN3YXJtLnRlY2hcIixcbiAgICBcInRva2Vuc2FsZS5wb2x5c3dhcm0udGVjaFwiLFxuICAgIFwicG9seXN3YXJtLnJ1XCIsXG4gICAgXCJkb2NrLmNsaWNrXCIsXG4gICAgXCJsZWFkY29pbnMubmV0d29ya1wiLFxuICAgIFwiZG9jay10b2tlbnNhbGUuZXVcIixcbiAgICBcInBvbHlzd2FybS5wd1wiLFxuICAgIFwiZG9jay1pby5vcmdcIixcbiAgICBcImhlYXZ2ZW4uaW9cIixcbiAgICBcImhhdnZlbi5saXZlXCIsXG4gICAgXCJoYXZ2ZW4uc2FsZVwiLFxuICAgIFwiaGF2dmVuLmluZm9cIixcbiAgICBcImRvY2submV0d29ya1wiLFxuICAgIFwiYmxvY2tsYW5jZXIubWVcIixcbiAgICBcInRva2Vuc2FsZS1oYXZ2ZW4uaW9cIixcbiAgICBcImhhdnZlbi5wcm9cIixcbiAgICBcInRva2VudGVsZWdyYW0uY29tXCIsXG4gICAgXCJpY28tdGVsZWdyYW0ubWVcIixcbiAgICBcIm15ZXRoZXJ6ZXJvLmNvbVwiLFxuICAgIFwic2VlbGUtdG9rZW4ucHJvXCIsXG4gICAgXCJ0b2tlbnNhbGUtaGF2dmVuLmNvbVwiLFxuICAgIFwicG9seXN3YXJtLmluXCIsXG4gICAgXCJzYWxlLWRvY2suY29tXCIsXG4gICAgXCJwb2x5c3dhcm0uY29cIixcbiAgICBcInBvbHlzd2FybS5iaWRcIixcbiAgICBcInRvbi5mdW5kXCIsXG4gICAgXCJmb3JrZGVpdGEuZ2l0aHViLmlvXCIsXG4gICAgXCJ4bi0tYmlubmNlLTVuZi5jb21cIixcbiAgICBcInhuLS1iaWFjZS00bDFiYi5jb21cIixcbiAgICBcImppb2NvaW5zLmlvXCIsXG4gICAgXCJ4bi0tcG9sb254LTB2YTI2dC5jb21cIixcbiAgICBcIm15ZXRsaGVyZXdhbGxldC5vcmdcIixcbiAgICBcIm15ZWl0aGVyZWl1d2FsbGV0LmNvbVwiLFxuICAgIFwiZmluLXRydXguY29tXCIsXG4gICAgXCJmaW5ldHJ1eC5jb21cIixcbiAgICBcInRlbGNvaW4ucHJvXCIsXG4gICAgXCJ4bi0tZXMtOGJiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJhbGx0LXBsOWVsdy5jb21cIixcbiAgICBcImljby1kb2NrLm9yZ1wiLFxuICAgIFwiZG9jay5pby1ib251cy5vbmxpbmVcIixcbiAgICBcImRvY2tzLnNpdGVcIixcbiAgICBcImRvY2staWNvLnByb1wiLFxuICAgIFwiZG9jay1pY28uZXVcIixcbiAgICBcImRvY2suc3VcIixcbiAgICBcInRva2Vuc2FsZS1kb2NrLmlvXCIsXG4gICAgXCJkb2NrLWljby5zaXRlXCIsXG4gICAgXCJvcGVucGxhdGZvcm0udGVjaFwiLFxuICAgIFwicmlnaHRtZXNoLmluXCIsXG4gICAgXCJ3YXh0b2tlbi5pblwiLFxuICAgIFwibWV0YW1hc2tnaXZlYXdheS54eXpcIixcbiAgICBcIm5lYnVsYXN0b2tlbi5pblwiLFxuICAgIFwidmVjaGFpbi1mb3VuZGF0aW9uLmNvbVwiLFxuICAgIFwiaWNvdG9rZW4tY3VycmVudC50b3BcIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZS1qYjllMTlhLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJhbGxlLTdiOWV6bC5jb21cIixcbiAgICBcImljb25mb3VuZGF0aW9uLmNvXCIsXG4gICAgXCJmdW5kcmVxdWVzdC5pbmZvXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGUtb3M4ZTd4LmNvbVwiLFxuICAgIFwicmVtbWUtaWNvLmV1XCIsXG4gICAgXCJnb25ldHdvcmsubGl2ZVwiLFxuICAgIFwidG9rZW4uZ29uZXR3b3JrLnByb1wiLFxuICAgIFwiZ29uZXR3b3JrLnByb1wiLFxuICAgIFwiZ29uZXR3b3JrLmV1XCIsXG4gICAgXCJudWNsZXVzLXZpc2lvbi5jY1wiLFxuICAgIFwiamlicmVsdG9rZW4uaW5cIixcbiAgICBcImRvY2suc29cIixcbiAgICBcImRvY2sucHJvbW9cIixcbiAgICBcInhuLS1teWNyeXB0LXIwYS5jb21cIixcbiAgICBcInhuLS1teWNyeXB0LWcxYS5jb21cIixcbiAgICBcInhuLS1teWNycHRvLXkyYS5jb21cIixcbiAgICBcImV0aGV4cGxvaXQub3JnXCIsXG4gICAgXCJyZW1tZS5pblwiLFxuICAgIFwicmVtbWUud3NcIixcbiAgICBcInJlbW1lLmNvbS5uZ1wiLFxuICAgIFwibnllaXR0aGVydnZhbGxldC5jb21cIixcbiAgICBcInhuLS1teWVlcmh3YWlsZXQtb29jLmNvbVwiLFxuICAgIFwibXlldGVyaHdhbGlvdC5jb21cIixcbiAgICBcInJlbW1lLmxpdmVcIixcbiAgICBcInhuLS15ZXRoZXdhbGxlLXRvMmV4a2hpLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jdXN0b20tdG9rZW4uY29tXCIsXG4gICAgXCJjdXN0b20tdG9rZW4uY29tXCIsXG4gICAgXCJzYWxlLWVhcm4uY29tXCIsXG4gICAgXCJiYW5rZXJhLmxpdmVcIixcbiAgICBcIm9yaWdpbnByb3RvY29sLmlvXCIsXG4gICAgXCJvcmlnaW5wcm90b2NvbC5vbmxpbmVcIixcbiAgICBcIm9yaWdpbnByb3RvY29scy5jb21cIixcbiAgICBcIm9yaWdpcnByb3RvY29sLmNvbVwiLFxuICAgIFwib3JpZ2lucHJvdG9jb2wudG9rZW5wdWJsaWNzYWxlcy5jb21cIixcbiAgICBcIm9yaWdpbnByb3RvY29sLnR5cGVmb3JtLmNvbVwiLFxuICAgIFwib3JpZ2lucHJvZm9jb2wuY29tXCIsXG4gICAgXCJoY2Vwcm8uY29tXCIsXG4gICAgXCJ0cnguZm91bmRhdGlvblwiLFxuICAgIFwidG9rZW5zYWxlLmFkaGl2ZS5uZXRcIixcbiAgICBcImFkaGl2ZS5uZXRcIixcbiAgICBcImRlY2VudHJhbC5tYXJrZXRcIixcbiAgICBcImNyeXB0b2V4cGxvaXRlLmNvbVwiLFxuICAgIFwiYmxvY2tjbGFpbi5uZXRcIixcbiAgICBcInhuLS1ibGNrY2hpbi01emE5by5pbmZvXCIsXG4gICAgXCJ4bi0tYmxraGFpbi1tMGE0cGIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NjaGFsLWdtYjhtLmluZm9cIixcbiAgICBcInhuLS1ibG9jY2hhbG4tb3JiLmluZm9cIixcbiAgICBcInhuLS1ibG9jY2hhbi1nbWI3Yy5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2thZGVuLWxzZW4tNXBiLmNvbVwiLFxuICAgIFwieG4tLWJsb2NrY2hhaS0zdmIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hhaS1qdmIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hhbC0zdmIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hhbS1pcGIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hhbi0ycGIuY29tXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGFuLTc1YS5jb21cIixcbiAgICBcInhuLS1ibG9ja2NoYW4tN3NiLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NoYW4tZDVhLm5ldFwiLFxuICAgIFwieG4tLWJsb2NrY2hhbi1kb2IuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hhbi1pcGIuY29tXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGFuLWlwYi5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGFuLW5rN2QuY29tXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGFuLXh1Yi5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGFubi00dWIuY29tXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGktbjdhNTBlLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NoaS1vOGE1NGQuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hpLXA5OWNvOGEuY29tXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGltLWhkYi5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGluLTF4Yi5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGluLTYxYS5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2tjaGluLTYxYS5uZXRcIixcbiAgICBcInhuLS1ibG9ja2NoaW4tNmliLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NoaW4tY2NiLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NoaW4taDRhLmNvbVwiLFxuICAgIFwieG4tLWJsb2NrY2hpbi1oNGEuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hpbi1oZGIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hpbi1oaGIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2hpbi1taWIubmV0XCIsXG4gICAgXCJ4bi0tYmxvY2tjaGluLXdjYi5jb21cIixcbiAgICBcInhuLS1ibG9ja2Nobi1memE0ai5jb21cIixcbiAgICBcInhuLS1ibG9ja2Nobi1memE0ai5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2tjaG4tbjdhNDNiLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2Nobi1wMGEuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2huLXR4MGQ0cC5jb21cIixcbiAgICBcInhuLS1ibG9ja2NsYWktM3ZiLmluZm9cIixcbiAgICBcInhuLS1ibG9ja2NsaW4taGRiLmNvbVwiLFxuICAgIFwieG4tLWJsb2NrY2xpbi1oZGIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NrY2xpbi1oZGIub3JnXCIsXG4gICAgXCJ4bi0tYmxvY2tmbHRlLWtpcmNocm9kZS13NmIuZGVcIixcbiAgICBcInhuLS1ibG9ja2ZsdGVucXVhcnRldHQtd2luZHNwaWVsLTgxYy5kZVwiLFxuICAgIFwieG4tLWJsb2NraGFpLW9iYjc4Yy5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2toYWluLTRlYi5jb21cIixcbiAgICBcInhuLS1ibG9ja2hhaW4tcGZiLmNvbVwiLFxuICAgIFwieG4tLWJsb2NraGFpbi1wZmIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NraGFpbi16ZGIuaW5mb1wiLFxuICAgIFwieG4tLWJsb2NraGFuLW9iYjY1YS5pbmZvXCIsXG4gICAgXCJ4bi0tYmxvY2toYXMtZDZhLmNvbVwiLFxuICAgIFwieG4tLWJsb2Nrd2FsbHQtajdhLmNvbVwiLFxuICAgIFwieG4tLWJsb2tjaGFpLWZxYi5pbmZvXCIsXG4gICAgXCJ4bi0tYmxva2NoYWluLW5mYi5pbmZvXCIsXG4gICAgXCJ4bi0tYmxva2hhaW4tMjhhYi5pbmZvXCIsXG4gICAgXCJ4bi0tYm9ja2NsbmFpbi1leWIuaW5mb1wiLFxuICAgIFwieG4tLW15bW9lby16dDdiemYuY29tXCIsXG4gICAgXCJ4bi0tbXltb2VyLW5xYzEzNjhjLmNvbVwiLFxuICAgIFwieG4tLW15bW9lcm8tYzEzYy5jb21cIixcbiAgICBcInhuLS1teW1vZXJvLXMxM2MuY29tXCIsXG4gICAgXCJ4bi0tbXltb25lby1mNjNjLmNvbVwiLFxuICAgIFwieG4tLW15bW9uZW8tdjYzYy5jb21cIixcbiAgICBcInhuLS1teW1vbmVvLXk1M2MuY29tXCIsXG4gICAgXCJ4bi0tbXltb25lci1qMGEuY29tXCIsXG4gICAgXCJ4bi0tbXltb25lci1qNWIuY29tXCIsXG4gICAgXCJ4bi0tbXltb25lci1yMGEuY29tXCIsXG4gICAgXCJ4bi0tbXltb25lci16MGEuY29tXCIsXG4gICAgXCJ4bi0tbXltb25lci16MmMuY29tXCIsXG4gICAgXCJ4bi0tbXltb25yby1meWEuY29tXCIsXG4gICAgXCJ4bi0tbXltb25yby14OGEuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlYWxsZXQtbDU4ZW11LmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJhZXQtOWsyZWE3N2guY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcmFsZXQtbXM4ZTIxYi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyYWxsZS03YjlleG0uY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcmFsbGV0LTVzNWYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcmFsbGV0LWZzNWYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcmV3YWxsZS0xdDFnLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJsbGV0LXBsOWU2ay5jb21cIixcbiAgICBcInhuLS1teWV0aGVydnZhbGxlLTh2Yy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FldC02MWVhLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWV0LThlZGEuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhZXQtbnM4ZWEuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGUtbnM4ZTh4LmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldC0wZmIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGV0LTB6NGYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGV0LTgxNGYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGV0LWQ5Yi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsZXQtaDE0Zi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbGUtOW1lLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsZS1lazVmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsZS1mcWMuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGxlLW9wYy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbGUtcTA1Zi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsZXQtd29iLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGx0LXI3YTBpLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGlldC05ZDVmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGxlLTNpYzA5NDdnLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGxldC0wZTVmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGxldC0xa2MuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhld2FsbGV0LWJrYy5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsZXQtdm9mLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGxpZXQtbm0xZy5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsdC1rYmIzMDE5Zy5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsdC13NDhldzdiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGV0LTZxYjY0MDhnLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGV0LW1zOGU4M2QuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbGV0LTFkYi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsdC0yOWFmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGx0LTI5YXMuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2xsZXQtcTdhMzFlLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndsbGV0LXI4YTNjLmNvbVwiLFxuICAgIFwiZmludHJ1eC5ldVwiLFxuICAgIFwicmVmZXJldW0taWNvLmV1XCIsXG4gICAgXCJhcmNibG9jay1pY28ub3JnXCIsXG4gICAgXCJ4bi0tZnVzb24tMXNhLm9yZ1wiLFxuICAgIFwicmVmZXJldW0tdG9rZW4uY29tXCIsXG4gICAgXCJmaW50cnV4LmNvXCIsXG4gICAgXCJpY28tdG9uLm9yZ1wiLFxuICAgIFwieG4tLW15dGhlcndhbGx0LWNiYnYuY29tXCIsXG4gICAgXCJ4bW9uZXRhLmNvXCIsXG4gICAgXCJkYXRhLXdhbGxldC5jb1wiLFxuICAgIFwidG9rZW5zYWxlLmRhdGEtd2FsbGV0LmNvXCIsXG4gICAgXCJ4bi0tbXllZXJod2FsbG90LW9vYy5jb21cIixcbiAgICBcInhuLS1teWV0ZXJ3YWxldC1jbThlcGkuY29tXCIsXG4gICAgXCJ4bi0tbXlldGVyd2FsbGUtY204ZXY2YS5jb21cIixcbiAgICBcInJueWV0aGVydW13YWxsZXQuY29tXCIsXG4gICAgXCJyZXB1YmxpYy1wcm90b2NvbC5uZXRcIixcbiAgICBcIm55ZWloaXRlcnZ2YWxsYXR0LmNvbVwiLFxuICAgIFwiYXJjYmxvY2suZXVcIixcbiAgICBcInJlcHVibGljcHJvdG9jb2wuZXVcIixcbiAgICBcInRva2Vuc2FsZS1mdXNpb24uY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0am9pbi5jb21cIixcbiAgICBcIm1lZGljYWxjaGlhbi5jb21cIixcbiAgICBcIm15ZWFodGVpcndhbGlldC5jb21cIixcbiAgICBcIm15ZW5odGVyc3Z2YWlsY3QuY29tXCIsXG4gICAgXCJ0cmluaXR5LXRva2VuLmNvbVwiLFxuICAgIFwieG4tLWVvLXl6cy5jb21cIixcbiAgICBcInppbGxpcWEuaW5cIixcbiAgICBcInNwYXJjLnByb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5pbXBvcnQtdG9rZW5zLmNvbVwiLFxuICAgIFwidG9rZW4tZ3JhbS5vcmdcIixcbiAgICBcInhuLS1zaGFwc2hpZnQtZTRhLmNvbVwiLFxuICAgIFwieG4tLXNoYXBzaGlmdC15NGEuY29tXCIsXG4gICAgXCJ4bi0tc2hwZXNoaWZ0LWMyYS5jb21cIixcbiAgICBcInhuLS1zaHBlc2hpZnQtcjFhLmNvbVwiLFxuICAgIFwieG4tLXNoYXBzaGlmdC1vNGEuY29tXCIsXG4gICAgXCJ4bi0tc2hwZXNoaWZ0LXcyYS5jb21cIixcbiAgICBcInhuLS1zaGFwZXNoZnQtdzVhLmNvbVwiLFxuICAgIFwidG9rZW5zYWxlLWZ1c2lvbi5vcmdcIixcbiAgICBcImZ1c2lvbi1pY28uY29tXCIsXG4gICAgXCJiZWV0b2xlbi5jb21cIixcbiAgICBcInRva2VuY3Jvd2RzYWxlLm9ubGluZVwiLFxuICAgIFwiZnVzaW9uLnRva2VuY3Jvd2RzYWxlLm9ubGluZVwiLFxuICAgIFwiYmVldG9rZW0uY29tXCIsXG4gICAgXCJibG9jay5jaGFpaW5zLmluXCIsXG4gICAgXCJvcmlnaW50cmFpbC5pblwiLFxuICAgIFwiYml0LXoucnVcIixcbiAgICBcInhuLS1teWV0aGVyYWxsZXQtbnU1Zi5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxldC0zcWIwOGMuY29tXCIsXG4gICAgXCJ4bi0tbXlldGVyd2xsZXQtY204ZXQxZC5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3bGxldC1xN2EwMWUuY29tXCIsXG4gICAgXCJ4bi0tYmlhbmNlLXh0N2IuY29tXCIsXG4gICAgXCJ4bi0tYm5hbmNlLXdpYy5jb21cIixcbiAgICBcInhuLS1iaWFuY2UtamViLmNvbVwiLFxuICAgIFwieG4tLWJ0dHJ4LTl6YTgzMzRjLmNvbVwiLFxuICAgIFwid3d3a29kYWtjb2luLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC51ay5jb21cIixcbiAgICBcImtvZGFrb25lLmNjXCIsXG4gICAgXCJueWVpaGl0ZXJ2dmFsbGV0LmNvbVwiLFxuICAgIFwieG4tLW15ZXRlcndhbGV0LWNtOGVvaS5jb21cIixcbiAgICBcIm51Y2xldXMuZm91bmRhdGlvblwiLFxuICAgIFwiYmVldG9rZW4taWNvLmNvbVwiLFxuICAgIFwiZGF0YS10b2tlbi5jb21cIixcbiAgICBcInRyb24tbGFicy5jb21cIixcbiAgICBcIm9jb2luLnRlY2hcIixcbiAgICBcImFpb25mb3VuZGF0aW9uLmNvbVwiLFxuICAgIFwiaWNvLXRlbGVncmFtLm9yZ1wiLFxuICAgIFwibnllaWhpdGVydnZhbGxhdC5jb21cIixcbiAgICBcInRlbGVncmFtY29pbi51c1wiLFxuICAgIFwiZGFkZGkuY2xvdWRcIixcbiAgICBcImRhZGl0b2tlbi5jb21cIixcbiAgICBcImJsb2NrYXJyYXkub3JnXCIsXG4gICAgXCJkYWRpLWNsb3VkLm5ldFwiLFxuICAgIFwid2FuY2hhaW5mdW5kaW5nLm9yZ1wiLFxuICAgIFwiaWNvLXRlbGVncmFtLmlvXCIsXG4gICAgXCJpY29uZm91bmRhdGlvbi5zaXRlXCIsXG4gICAgXCJpb3N0LmNvXCIsXG4gICAgXCJiZWV0b2tlbi1pY28uZXVcIixcbiAgICBcImNpbmRpY2F0b3IubmV0d29ya1wiLFxuICAgIFwid2FuY2hhaW5ldHdvcmsub3JnXCIsXG4gICAgXCJ3YW1jaGFpbi5vcmdcIixcbiAgICBcIndhbmNoYWlubHRkLm9yZ1wiLFxuICAgIFwid2FuY2hhaW5hbGxpYW5jZS5vcmdcIixcbiAgICBcIm51Y2xldXMtdmlzaW9uLm5ldFwiLFxuICAgIFwibGVkZ2Vyd2FsbGV0LmJ5XCIsXG4gICAgXCJudWNsZXVzcy52aXNpb25cIixcbiAgICBcIm15ZW5odGVyc3dhaWxjdC5jb21cIixcbiAgICBcImNvYmluLWhvb2QuY29tXCIsXG4gICAgXCJ3YW5jaGFpbmZvdW5kYXRpb24ub3JnXCIsXG4gICAgXCJ4bi0tcG9sbmlleC1leDRjLmNvbVwiLFxuICAgIFwieG4tLXBvbG5pZXgtczFhLmNvbVwiLFxuICAgIFwieG4tLXBvbG9uZXgtaWViLmNvbVwiLFxuICAgIFwieG4tLXBvbG9uZXgtc3phLmNvbVwiLFxuICAgIFwieG4tLXBvbG9uZXgtenc0Yy5jb21cIixcbiAgICBcInhuLS1wb2xvbml4LXdzNGMuY29tXCIsXG4gICAgXCJ4bi0tcG9sb25peC15OGEuY29tXCIsXG4gICAgXCJ4bi0tcG9vbmlleC1vamIuY29tXCIsXG4gICAgXCJncmFtaWNvLmluZm9cIixcbiAgICBcImRpbW5zaW9ucy5uZXR3b3JrXCIsXG4gICAgXCJ3d3ctZ2VtaW5pLmNvbVwiLFxuICAgIFwibG9naW4ta3Vjb2luLm5ldFwiLFxuICAgIFwidmVuY2hhaW4uZm91bmRhdGlvblwiLFxuICAgIFwiZ3JhbXByZWljby5jb21cIixcbiAgICBcInRncmFtLmNjXCIsXG4gICAgXCJ0b24tZ3JhbWljby5jb21cIixcbiAgICBcInd3d3BheXdpdGhpbmsuY29tXCIsXG4gICAgXCJjb25pb21pLmNvbVwiLFxuICAgIFwicGF5d2l0aG5rLmNvbVwiLFxuICAgIFwicGF5d2l0aGxuay5jb21cIixcbiAgICBcImlsdW1pbmF0dG8uY29tLmJyXCIsXG4gICAgXCJwdW5kaXguZXVcIixcbiAgICBcInhuLS1idHRyeC1lc2F5LmNvbVwiLFxuICAgIFwieG4tLWJ0dHJleC13OGEuY29tXCIsXG4gICAgXCJ4bi0tYm5hbmNlLWJ3YS5jb21cIixcbiAgICBcInhuLS1zaHBlc2hpZnQtMTFhLmNvbVwiLFxuICAgIFwieG4tLXNoYXBlc2hpZi10czZkLmNvbVwiLFxuICAgIFwieG4tLXNoYXBzaGlmdC15ZjdkLmNvbVwiLFxuICAgIFwid3d3Ymx1emVsbGUuY29tXCIsXG4gICAgXCJibHV6ZWxpZS5jb21cIixcbiAgICBcIm51Y2xldXMtdmlzaW9uLm9yZ1wiLFxuICAgIFwib21pc2Vnb25ldHdvcmsuc2l0ZVwiLFxuICAgIFwiZXRsaGVyemVyby5jb21cIixcbiAgICBcImV0bGhlcmRlbHRhLmNvbVwiLFxuICAgIFwieG4tLWNvbmRlc2stMHlhLmNvbVwiLFxuICAgIFwieG4tLWNvbmRlc2stc2ZiLmNvbVwiLFxuICAgIFwieG4tLWNvaW5kc2stdnM0Yy5jb21cIixcbiAgICBcImlleGVjcGxhdGZvcm0uY29tXCIsXG4gICAgXCJ0b25ncmFtaWNvLmNvbVwiLFxuICAgIFwibnVjbGV1cy12aXNpb24uZXVcIixcbiAgICBcImludGNoYWluLm5ldHdvcmtcIixcbiAgICBcIndhbmNoYWluLmNsb3VkXCIsXG4gICAgXCJibHV6ZWxsZS1pY28uY29tXCIsXG4gICAgXCJldGh6ZXJvLXdhbGxldC5jb21cIixcbiAgICBcInhuLS1tZXRoZXJ3YWxsZS1qYjlldDdkLmNvbVwiLFxuICAgIFwieG4tLWNvaW5lc2stam8zYy5jb21cIixcbiAgICBcInZlbmNoYWluZm91bmRhdGlvbi5jb21cIixcbiAgICBcIm15ZW5odGVyc3Z2YWlsb3QuY29tXCIsXG4gICAgXCJldGhlci16ZXJvLm5ldFwiLFxuICAgIFwiaW5zLmZvdW5kYXRpb25cIixcbiAgICBcIm5hc3Rva2VuLm9yZ1wiLFxuICAgIFwidGVsY29pbnRva2VuLmNvbVwiLFxuICAgIFwiZXRoZXIwLm9yZ1wiLFxuICAgIFwiZXRlcnplcm8ub3JnXCIsXG4gICAgXCJibHV6ZWxsZS1pY28uZXVcIixcbiAgICBcImJsZXV6ZWxsZS5jb21cIixcbiAgICBcImFwcGNvaW5zdG9rZW4ub3JnXCIsXG4gICAgXCJ4bi0tcXVhbnN0YW1wLThzNmQuY29tXCIsXG4gICAgXCJteWVobnRlcnN2dmFpbGN0LmNvbVwiLFxuICAgIFwibXllaGVyd2FsbGxldC5jb21cIixcbiAgICBcImljby1ibHV6ZWxsZS5jb21cIixcbiAgICBcImJsdXplbGxlLmltXCIsXG4gICAgXCJibHV6ZWxsZS5vbmVcIixcbiAgICBcImJsdXplbGUuc2FsZVwiLFxuICAgIFwiYmx1emVsZS5jb1wiLFxuICAgIFwic2V0aGVyLndzXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGV0LTZnZi5jb21cIixcbiAgICBcInhuLS1ybnlldGhld2FsaWV0LW9tMWcuY29tXCIsXG4gICAgXCJybnlldGhlcnZhaWxldC5jb21cIixcbiAgICBcIm12ZXRoZXJ3YWxpZXQuY29tXCIsXG4gICAgXCJybnlldGhlcndhaWxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ2YWxpZXQuY29tXCIsXG4gICAgXCJybnlldGhlcnZhbGlldC5jb21cIixcbiAgICBcIm12ZXRoZXJ3YWxpbGV0LmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGllLTNpYzA5NDdnLmNvbVwiLFxuICAgIFwieG4tLW10aHJ3YWxsZXQtejZhYzN5LmNvbVwiLFxuICAgIFwieG4tLW15ZWhlcndhbGllLXZpY2kuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcnZ2YWxpZS04dmMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC0wNmFjZi5jb21cIixcbiAgICBcInhuLS1tdGhlcndhbGxldC15OWE2eS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuYXBwbHl0b2tlbi50a1wiLFxuICAgIFwiZXRoZXJldW0temVyby5jb21cIixcbiAgICBcInF1YW5zdGFtcHRva2VuLnRrXCIsXG4gICAgXCJibHV6ZWxsZS5uZXR3b3JrXCIsXG4gICAgXCJldGhlci13YWxsZXQub3JnXCIsXG4gICAgXCJ0cm9uLXdhbGxldC5pbmZvXCIsXG4gICAgXCJhcHBjb2luc3Byb2plY3QuY29tXCIsXG4gICAgXCJ2ZWNoYWluLmZvdW5kYXRpb25cIixcbiAgICBcInRyb25sYWIuc2l0ZVwiLFxuICAgIFwidHJvbmxhYnMubmV0d29ya1wiLFxuICAgIFwiYmx1emVsbGUuY2NcIixcbiAgICBcImV0aGJsZW5kZXIuY29tXCIsXG4gICAgXCJldGhwYXBlcndhbGxldC5uZXRcIixcbiAgICBcIndhbHRvbnRva2VuLm9yZ1wiLFxuICAgIFwiaWNvc2VsZmtleS5vcmdcIixcbiAgICBcImV0aGVyemVyb2NsYWltLmNvbVwiLFxuICAgIFwiZXRoZXJ6ZXJvLnByb21vXCIsXG4gICAgXCJibHV6ZWxsZS5wcm9cIixcbiAgICBcInRva2VuLXNlbGZrZXkub3JnXCIsXG4gICAgXCJ4bi0tZXRoZXJkbHRhLTBmN2QuY29tXCIsXG4gICAgXCJzZXRoZXIuaW5cIixcbiAgICBcInhuLS10dHJleC15c2E5NDIzYy5jb21cIixcbiAgICBcImJsdXplbGxlLmV1XCIsXG4gICAgXCJibHV6ZWxsZS5zaXRlXCIsXG4gICAgXCJnaWZ0by50ZWNoXCIsXG4gICAgXCJ4bi0tb3MtZzdzLmNvbVwiLFxuICAgIFwic2VsZmtleS5jb1wiLFxuICAgIFwieG4tLW15ZWhlcndhbGV0LW5zOGV4eS5jb21cIixcbiAgICBcInhuLS1jb2luZWxlZ3JhcGgtd2s1Zi5jb21cIixcbiAgICBcImRhaS1zdGFibGVjb2luLmNvbVwiLFxuICAgIFwiZW9zLXRva2VuLm9yZ1wiLFxuICAgIFwidmVuY2hhaW4ub3JnXCIsXG4gICAgXCJnYXRjb2lucy5pb1wiLFxuICAgIFwiZGVlcGJyYWluY2hhaW4uY29cIixcbiAgICBcIm15ZXRoZXJ3YWxpbGlsZXQuaW5mb1wiLFxuICAgIFwibXllaHZ0ZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWVodGVydW1zd2FsbGV0LmNvbVwiLFxuICAgIFwibnVjbGV1c2ljby5jb21cIixcbiAgICBcInRyb25sYWIudGVjaFwiLFxuICAgIFwiMHgtcHJvamVjdC5jb21cIixcbiAgICBcImdpZnQtdG9rZW4tZXZlbnRzLm15d2ViY29tbXVuaXR5Lm9yZ1wiLFxuICAgIFwiZnVuZmFpcnRva2VuLm9yZ1wiLFxuICAgIFwiYnJlYWR0b2tlbmFwcC5jb21cIixcbiAgICBcImNsb3VkcGV0c3RvcmUuY29tXCIsXG4gICAgXCJteWV0aHdhbGlsZXQuY29tXCIsXG4gICAgXCJzZWxma2V5cy5vcmdcIixcbiAgICBcIndhbGxldC1ldGhlcmV1bS5jb21cIixcbiAgICBcInhuLS1tZXRocndhbGx0LTI2YXIwei5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3bGxldC1yOGEwYy5jb21cIixcbiAgICBcImJsdXplbGxlLnByb21vXCIsXG4gICAgXCJ0b2tlbnNhbGUuYmx1emVsbGUucHJvbW9cIixcbiAgICBcImNlZGFybGFrZS5vcmdcIixcbiAgICBcIm1hcmtldGluZ2xlYWRzNHUuY29tXCIsXG4gICAgXCJjYXNoYWEuY29cIixcbiAgICBcInhuLS1pbmFuY2UtaHJiLmNvbVwiLFxuICAgIFwid2FuY2hhaW4udGVjaFwiLFxuICAgIFwiemVucHJvbG9jb2wuY29tXCIsXG4gICAgXCJldGhzY2FuLmlvXCIsXG4gICAgXCJldGhlcnNjYW4uaW5cIixcbiAgICBcInByb3BzLXByb2plY3QuY29tXCIsXG4gICAgXCJ6aWxsaWFxLmNvbVwiLFxuICAgIFwicmVxZXN0bmV0d29yay5jb21cIixcbiAgICBcImV0aGVyZGVsdGEucHdcIixcbiAgICBcImV0aGVyZXVtLWdpdmVhd2F5Lm9yZ1wiLFxuICAgIFwibXlzaW1wbGV0b2tlbi5vcmdcIixcbiAgICBcImJpbmFuY2MuY29tXCIsXG4gICAgXCJibG5hbmNlLm9yZ1wiLFxuICAgIFwiZWxoZXJkZWx0YS5pb1wiLFxuICAgIFwieG4tLWhhcGVzaGl0LWV6OWMyeS5jb21cIixcbiAgICBcInRlbnh3YWxsZXQuY29cIixcbiAgICBcInNpbmd1bGFyaXR5bmV0LmluZm9cIixcbiAgICBcIm15dGxoZXJ3YWxpZXQuaW5mb1wiLFxuICAgIFwiaWNvbm1haW5uZXQubWxcIixcbiAgICBcInRva2Vuc2VsZmtleS5vcmdcIixcbiAgICBcInhuLS1teWV0ZXdhbGxldC1jbThlNXkuY29tXCIsXG4gICAgXCJlbnZpb25lLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldGV0LmNvbVwiLFxuICAgIFwiY2xhaW1iY2QuY29tXCIsXG4gICAgXCJyaXBpb2NyZWRpdG5ldHdvcmsuaW5cIixcbiAgICBcInhuLS15ZXRlcndhbGxldC1tbDhldW8uY29tXCIsXG4gICAgXCJldGhjbGFzc2ljd2FsbGV0LmluZm9cIixcbiAgICBcIm15bHRoZXJ3YWxsZXQucnUuY29tXCIsXG4gICAgXCJldGhlcmRlbGxhLmNvbVwiLFxuICAgIFwieG4tLXlldGVyd2FsbGV0LWJtOGV3bi5jb21cIixcbiAgICBcInNpbmd1bGFydHkubmV0XCIsXG4gICAgXCJjbG91ZGtpdHRpZXMuY29cIixcbiAgICBcImljb25mb3VuZGF0aW9uLmlvXCIsXG4gICAgXCJraXR0eXN0YXQuY29tXCIsXG4gICAgXCJnYXRzY29pbi5pb1wiLFxuICAgIFwic2luZ3VsYXJpdHluZXQuaW5cIixcbiAgICBcInNhbGUuY2FuYXkuaW9cIixcbiAgICBcImNhbmF5LmlvXCIsXG4gICAgXCJ3YWJpY29pbi5jb1wiLFxuICAgIFwiZW52aW9uLnRvcFwiLFxuICAgIFwic2lyaW5zbGFicy5jb21cIixcbiAgICBcInRyb25sYWIuY29cIixcbiAgICBcInBheGZ1bC5jb20ubmdcIixcbiAgICBcImNoYW5nZWxseWxpLmNvbVwiLFxuICAgIFwiZXRoZXJldW0tY29kZS5jb21cIixcbiAgICBcInhuLS1wbG9uZXgtNnZhNmMuY29tXCIsXG4gICAgXCJlbnZpb24uY29cIixcbiAgICBcImVudmlvbi5jY1wiLFxuICAgIFwiZW52aW9uLnNpdGVcIixcbiAgICBcImV0aGVyZXVtY2hhaW4uaW5mb1wiLFxuICAgIFwieG4tLWVudm9uLTFzYS5vcmdcIixcbiAgICBcInhuLS1idHN0YW1wLXJmYi5uZXRcIixcbiAgICBcImVudmxvbi5vcmdcIixcbiAgICBcImVudmlvbi1pY28ub3JnXCIsXG4gICAgXCJzcGVjdGl2dnIub3JnXCIsXG4gICAgXCJzaXJpbmxicy5jb21cIixcbiAgICBcImV0aGVyZXVtZG91Ymxlci5saWZlXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbGV0LWZuYi5jb21cIixcbiAgICBcInNpcmluLWxhYnMuY29tXCIsXG4gICAgXCJzaXJpbi1sYWJzLm9yZ1wiLFxuICAgIFwiZW52aW9uLm9uZVwiLFxuICAgIFwiZW52aW9uLmxpdmVcIixcbiAgICBcInByb3BzcHJvamVjdC5vcmdcIixcbiAgICBcInByb3BzcHJvamVjdHMuY29tXCIsXG4gICAgXCJkZWNlbnRyYWxsYW5kLm9yZ1wiLFxuICAgIFwieG4tLW1ldGhlcndhbGV0LW5zOGVwNGIuY29tXCIsXG4gICAgXCJyZWRwdWxzZXRva2VuLmNvXCIsXG4gICAgXCJwcm9wc3Byb2plY3QudGVjaFwiLFxuICAgIFwieG4tLW15ZXRlcndhbGV0LW5sOGVtai5jb21cIixcbiAgICBcInBvd3JlcmxlZGdlci5jb21cIixcbiAgICBcImNyeXB0b2tpdHRpZXMuY29tXCIsXG4gICAgXCJzaXJpbmxhYnMucHJvXCIsXG4gICAgXCJzaXJpbmxhYnMuY29cIixcbiAgICBcInNpcm5sYWJzLmNvbVwiLFxuICAgIFwic3VwZXJiaXRjb2luLWJsb2NrY2hhaW4uaW5mb1wiLFxuICAgIFwiaGVsbG9ibG9vbS5tZVwiLFxuICAgIFwibW9idXMubmV0d29ya1wiLFxuICAgIFwicG93cnJsZWRnZXIuY29tXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FsZXQtbXM4ZXl5LmNvbVwiLFxuICAgIFwicWxpbmstaWNvLmNvbVwiLFxuICAgIFwiZ2F0Y29pbi5pblwiLFxuICAgIFwidG9rZW5zYWxlLmdhbWVmbGxwLmNvbVwiLFxuICAgIFwiZ2FtZWZsbHAuY29tXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FsbGUtdmljaS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsZXQtMzliLmNvbVwiLFxuICAgIFwieG4tLXBvbG9uZXgtZmZiLmNvbVwiLFxuICAgIFwieG4tLWJpcmV4LWxlYmEuY29tXCIsXG4gICAgXCJyYWlkZW4tbmV0d29yay5vcmdcIixcbiAgICBcInNpcmludGFicy5jb21cIixcbiAgICBcInhuLS1tZXRoZXJ3YWxsdC03OWEzMGEuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2xsZXQtMmtiM3AuY29tXCIsXG4gICAgXCJteWV0aGxlcndhbGxldC5ldVwiLFxuICAgIFwieG4tLWJ0cmV4LWI0YS5jb21cIixcbiAgICBcInBvd2VycmxlZGdlci5jb21cIixcbiAgICBcInhuLS1jb2ludGVlZ3JhcGgtd3o0Zi5jb21cIixcbiAgICBcIm15ZXJoZXJ3YWxldC5jb21cIixcbiAgICBcInFhdW50c3RhbnAuY29tXCIsXG4gICAgXCJteWV0aGVyZXJtd2FsbGV0LmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGV0LW5zOGVxcS5jb21cIixcbiAgICBcInhuLS1udmlvbi1oemEub3JnXCIsXG4gICAgXCJubnlldGhlcndhbGxlbHQucnUuY29tXCIsXG4gICAgXCJpY28td2Fjb2luLmNvbVwiLFxuICAgIFwieG4tLW15ZXRlcndhbGV0LW5sOGVuai5jb21cIixcbiAgICBcImJpdGNvaW5zaWx2ZXIuaW9cIixcbiAgICBcInQwemVyby5jb21cIixcbiAgICBcInRva2Vuc2FsZS5naXplci5pblwiLFxuICAgIFwiZ2l6ZXIuaW5cIixcbiAgICBcIndhYml0b2tlbi5jb21cIixcbiAgICBcImdsYWRpdXMud3NcIixcbiAgICBcInhuLS1tZXRoZXJ3YWxsdC04YmI0dy5jb21cIixcbiAgICBcInF1YW50dHN0YW1wLmNvbVwiLFxuICAgIFwiZ2xhZGl1cy5pbVwiLFxuICAgIFwiZXRoZXJldW1zdG9yYWdlLm5ldFwiLFxuICAgIFwicG93ZXJsZWRnZXJyLmNvbVwiLFxuICAgIFwieG4tLW15ZWhlcndhbGxldC00ajVmLmNvbVwiLFxuICAgIFwicXVhbXRzdGFtcC5jb21cIixcbiAgICBcInF1bnRzdGFtcC5jb21cIixcbiAgICBcInhuLS1jaGFuZ2VseS1qNTljLmNvbVwiLFxuICAgIFwic2hhcGVzaGxmdC5jb21cIixcbiAgICBcImNvaW5iYXNlbmV3cy5jby51a1wiLFxuICAgIFwieG4tLW1ldGhlcndhbGxldC1obWIuY29tXCIsXG4gICAgXCJlbnZvaW4ub3JnXCIsXG4gICAgXCJwb3dlcmxlZGdlci5jb21cIixcbiAgICBcImJpdHN0YW5ucC5uZXRcIixcbiAgICBcInhuLS1teWV0aGVyYWxsZXQtNGs1ZnduLmNvbVwiLFxuICAgIFwieG4tLWNvaW5iYXMtcHlhLmNvbVwiLFxuICAgIFwicmVxdWVzdHQubmV0d29ya1wiLFxuICAgIFwib3JhY2xzLm5ldHdvcmtcIixcbiAgICBcInNpcmlubGFicy53ZWJzaXRlXCIsXG4gICAgXCJwb3dybGVkZ2VyLmlvXCIsXG4gICAgXCJzbGFja2NvbmZpcm0uY29tXCIsXG4gICAgXCJzaGFwZS1zaGlmdC5pb1wiLFxuICAgIFwib3JhY2xlcy1uZXR3b3JrLm9yZ1wiLFxuICAgIFwieG4tLW15ZWhlcndhbGxlLXpiOWVpYS5jb21cIixcbiAgICBcImJsb2Nrc3RhY2sub25lXCIsXG4gICAgXCJ1cnR1c3QuaW9cIixcbiAgICBcImJpdHRyZXgub25lXCIsXG4gICAgXCJ0MC1pY28uY29tXCIsXG4gICAgXCJ4bi0tY2luYmFzZS05MGEuY29tXCIsXG4gICAgXCJ4bi0tbWV0aGVyd2FsZXQtbnM4ZXoxZy5jb21cIixcbiAgICBcInR6ZXJvLWljby5jb21cIixcbiAgICBcInR6ZXJvLnN1XCIsXG4gICAgXCJ0emVyby53ZWJzaXRlXCIsXG4gICAgXCJibG9ja3N0YWNrLm5ldHdvcmtcIixcbiAgICBcImljby10emVyby5jb21cIixcbiAgICBcInNwZWN0cmUuc2l0ZVwiLFxuICAgIFwidHplcm8ucHdcIixcbiAgICBcInNwZWN0cmUtYWkubmV0XCIsXG4gICAgXCJ4bi0td2F4dG9rbi15OGEuY29tXCIsXG4gICAgXCJkbWFya2V0LnByb1wiLFxuICAgIFwiYml0dHJleC5jb20xMTY0ODcyNDMyODc3NC5jZlwiLFxuICAgIFwiYml0dHJleC5jb20xOTg3NDY1Nzk4LmdhXCIsXG4gICAgXCJhdXRjdXMub3JnXCIsXG4gICAgXCJ0LXplcm8ub3JnXCIsXG4gICAgXCJ4bi0temVyby16eGIuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Zm9yay5jb21cIixcbiAgICBcImJsb2tjbGJhaW4uaW5mb1wiLFxuICAgIFwiZGF0dW0uc2FsZVwiLFxuICAgIFwic3BlY3RyZS1haS5vcmdcIixcbiAgICBcInBvd2VybGVkZ3IuY29tXCIsXG4gICAgXCJzaW1wbGV0b2tlbi5saXZlXCIsXG4gICAgXCJzYWxlLnNpbXBsZXRva2VuLmxpdmVcIixcbiAgICBcInFhdW50c3RhbXAuY29tXCIsXG4gICAgXCJyYWlkZW4tbmV0d29yay5jb21cIixcbiAgICBcIm1ldGFscGF5bWUuY29tXCIsXG4gICAgXCJxdWFudHN0YW1wLWljby5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWlsZXRjbGllbnQuY29tXCIsXG4gICAgXCJiaW9ja2NoYWluLmJpelwiLFxuICAgIFwid2FsbGV0cy1ibG9ja2NoYWluLmNvbVwiLFxuICAgIFwiZ29sZW1haXJkcm9wLmNvbVwiLFxuICAgIFwib21pc2Vnb2FpcmRyb3AubmV0XCIsXG4gICAgXCJibG9ka2NoYWlud2FsbGV0LmluZm9cIixcbiAgICBcIndhbHRvbi1jaGFpbi5vcmdcIixcbiAgICBcImVsaXRlODg4LWljby5jb21cIixcbiAgICBcImJpdGZseWVyanAuY29tXCIsXG4gICAgXCJjaGFpbmxpbmtzbWFydGNvbnRyYWN0LmNvbVwiLFxuICAgIFwic3Rvcm10b2tlbi5ldVwiLFxuICAgIFwib21pc2UtZ28udGVjaFwiLFxuICAgIFwic2FsdGVuZGluZy5jb21cIixcbiAgICBcInN0b3JtbHRva2VuLmNvbVwiLFxuICAgIFwieG4tLXF1YW50dGFtcC00MmIuY29tXCIsXG4gICAgXCJzdG9ybXRva2VuLmNvXCIsXG4gICAgXCJzdG9ybnRva2VuLmNvbVwiLFxuICAgIFwic3Ryb210b2tlbi5jb21cIixcbiAgICBcInN0b3JtLXRva2VuLmNvbVwiLFxuICAgIFwic3Rvcm10b2tlbnMuaW9cIixcbiAgICBcImV0aGVyLWRlbHRhLmNvbVwiLFxuICAgIFwiZXRoY29ubmVjdC5saXZlXCIsXG4gICAgXCJldGhjb25uZWN0LnRyYWRlXCIsXG4gICAgXCJ4bi0tYnR0cmV4LTN2YS5uZXRcIixcbiAgICBcInF1YW50c3RhbXAuY29tLmNvXCIsXG4gICAgXCJ3YW5jaGEuaW5cIixcbiAgICBcImF1Z3VyLW5ldHdvcmsuY29tXCIsXG4gICAgXCJxdWFudHN0YW1wLmNvbS51YVwiLFxuICAgIFwibXlldGhlcndhbGxldG1ldy5jb21cIixcbiAgICBcIm15ZXRoZXJ1bXdhbGxldHRzLmNvbVwiLFxuICAgIFwieG4tLXF1YW5zdGFtcC10bWQuY29tXCIsXG4gICAgXCJxdWFudHNzdGFtcHMuY29tXCIsXG4gICAgXCJjaGFuZ2VsbHlsLm5ldFwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldC0xZmIuY29tXCIsXG4gICAgXCJteWV0aGVyZXVtd2FsbGV0cy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsZXQtZTliLmNvbVwiLFxuICAgIFwicXVhbnRzbGFtcC5jb21cIixcbiAgICBcIm1ldGVscGF5LmNvbVwiLFxuICAgIFwieG4tLWV0ZXJkZWx0YS1tNzVkLmNvbVwiLFxuICAgIFwibGlua3NtYXJ0Y29udHJhY3QuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0YWNjZXNzLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGNoZWNrLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGNoZWNrLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRjb25mLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGVhbC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRlYy5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRnZXRoLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldG1ldGFtYXNrLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldG1tLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldG15LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldG5oLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldG5vZC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRyci5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRydHkuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0c2VjLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHNlY3VyZS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR1dGMuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0dmVyLmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR2aWV3LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHZpZXcuaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldHZyZi5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRtaXN0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGV4dC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRqc29uLmNvbVwiLFxuICAgIFwibWV0dGFscGF5LmNvbVwiLFxuICAgIFwiYnJpY2tsYmxvY2suaW9cIixcbiAgICBcImJpdHRyZXh5LmNvbVwiLFxuICAgIFwidXRydXN0LnNvXCIsXG4gICAgXCJteWV0aGllcndhbGxldC5vcmdcIixcbiAgICBcIm1ldGFsbHBheS5jb21cIixcbiAgICBcImtyYWtlbi13YWxsZXQuY29tXCIsXG4gICAgXCJkbWFya3QuaW9cIixcbiAgICBcImV0aGVyZGVsdGxhLmNvbVwiLFxuICAgIFwidW5sdmVyc2EuaW9cIixcbiAgICBcInVuaXZlcnNhLnNhbGVcIixcbiAgICBcIm1lcmN1cnlwcm90b2NvbC5saXZlXCIsXG4gICAgXCJyaXBpb2NyZWRsdC5uZXR3b3JrXCIsXG4gICAgXCJteWV0bGhlcndhMTFldC5jb21cIixcbiAgICBcImRlbnRhY29pbi5pblwiLFxuICAgIFwicmRydGcuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5yZHJnaC5jb21cIixcbiAgICBcInJkcmdoLmNvbVwiLFxuICAgIFwicmlwaW9jcmVkaXRuZXR3b3JrLmNvXCIsXG4gICAgXCJyaWFkZW4ubmV0d29ya1wiLFxuICAgIFwiaHlkcm9taW5lci5iaXpcIixcbiAgICBcInJkcmJsb2NrLmNvbVwiLFxuICAgIFwicmVxZXN0Lm5ldHdvcmtcIixcbiAgICBcInNlbnN0b2tlbi5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsYXQuc2VydmljZXNcIixcbiAgICBcInJpcGlvY3JlZGl0Lm5ldFwiLFxuICAgIFwieG4tLW1ldGhlcndhbGxldC1jMDZmLmNvbVwiLFxuICAgIFwiaWNvLnJpcGlvY3JlZGl0cy5jb21cIixcbiAgICBcInJpcGlvY3JlZGl0cy5jb21cIixcbiAgICBcInJhaWRlbnMubmV0d29ya1wiLFxuICAgIFwiYXJ0b2tlbi5jb1wiLFxuICAgIFwibXlldGhlcndhbGxldGxnbi5jb21cIixcbiAgICBcImV0aGVyYmxvZy5jbGlja1wiLFxuICAgIFwic3Rvcm10b2tlbi5zaXRlXCIsXG4gICAgXCJodHRwbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR2ZXJpZnkuY29tXCIsXG4gICAgXCJieXphbnRpdW1mb3JrLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uYnl6YW50aXVtZm9yay5jb21cIixcbiAgICBcInd3dy1teWV0aGVydnZhbGxldC5jb21cIixcbiAgICBcImV0aGVyMjQuaW5mb1wiLFxuICAgIFwiYmxvY2stdi5pb1wiLFxuICAgIFwiYml0dHJleC5jYXNoXCIsXG4gICAgXCJzaGFwaXNoaWZ0LmlvXCIsXG4gICAgXCJyaXBpb2NlcmRpdC5uZXR3b3JrXCIsXG4gICAgXCJybnlldGhlcndhMTFldC5jb21cIixcbiAgICBcImNsYWltZXRoZXIuY29tXCIsXG4gICAgXCJlbmlnbWF0b2tlbnNhbGUuY29tXCIsXG4gICAgXCJldGhlcmV1bS1vcmcuY29tXCIsXG4gICAgXCJtdmV0bmVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXljdGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWx0ZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2F0bGV0LmNvbVwiLFxuICAgIFwicHJpdmF0aXgubWVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRjbmYuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0dmVyLmNvbVwiLFxuICAgIFwicHJpdmF0aXgudG9wXCIsXG4gICAgXCJwcml2YXRpeC5wcm9cIixcbiAgICBcInN0b3JtdG9rZW4uY2NcIixcbiAgICBcInJhaWRlbi5vbmxpbmVcIixcbiAgICBcInN0b3Jtc3Rva2VuLmNvbVwiLFxuICAgIFwibXlldGVyZXVtd2FsbGV0LmNvbVwiLFxuICAgIFwic3Rvcm10b2tlbnMubmV0XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Y29uZi5pbmZvXCIsXG4gICAgXCJzdG9ycm50b2tlbi5jb21cIixcbiAgICBcIndvcmxkb2ZiYXR0bGVzLmlvXCIsXG4gICAgXCJpY28ud29ybGRvZmJhdHRsZXMuaW9cIixcbiAgICBcInByaXZhdGl4LmxpdmVcIixcbiAgICBcInJpZGVuLm5ldHdvcmtcIixcbiAgICBcInJhaWRhbi5uZXR3b3JrXCIsXG4gICAgXCJyYWxkZW4ubmV0d29ya1wiLFxuICAgIFwibXlteWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHMubmV0XCIsXG4gICAgXCJteWV0aGVyd2FsbGV0dmVyaWZ5LmluZm9cIixcbiAgICBcInN0b3JteHRva2VuLmNvbVwiLFxuICAgIFwibXlldGhlcmV1bS13YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LWZvcmtwcmVwLnBhZ2VkZW1vLmNvXCIsXG4gICAgXCJteWV0bmVyd2FpbGV0LmNvbVwiLFxuICAgIFwid3d3LW12ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJldGhlaXJkZWx0YS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRpdS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWlpZXR0LmNvbVwiLFxuICAgIFwieG4tLW15dGhlcndhbGV0LWNiYjg3aS5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZXQtaXZiLmNvXCIsXG4gICAgXCJ4bi0tbXlldGVyd2FsbGV0LWYxYi5jb21cIixcbiAgICBcIm15ZWh0ZXJ3YWxpZXQuY29tXCIsXG4gICAgXCJvbWVnYW9uZS5jb1wiLFxuICAgIFwibXlldGhlcndhaWlldHcuY29tXCIsXG4gICAgXCJzbGFjay5jb20ucnVcIixcbiAgICBcInBvbGtvZG90Lm5ldHdvcmtcIixcbiAgICBcInJlcXVlc3QtbmV0d29yay5uZXRcIixcbiAgICBcInJlcXVlc3RuZXR3b3JrLmxpdmVcIixcbiAgICBcImJpbmFuY2llLmNvbVwiLFxuICAgIFwiZmlyc3QtZXRoLmluZm9cIixcbiAgICBcIm15ZXdlcnRod2FsbGlldC5jb21cIixcbiAgICBcImVuamluY29pbi5wd1wiLFxuICAgIFwieG4tLWJpdHJleC1rMTdiLmNvbVwiLFxuICAgIFwiYWxyc3dhcC5pb1wiLFxuICAgIFwid3d3LXJlcXVlc3QubmV0d29ya1wiLFxuICAgIFwibXlldG5lbndhbGxldC5jb21cIixcbiAgICBcInd3dy1lbmlnbWEuY29cIixcbiAgICBcImNyeXB0b2luc2lkZW5ld3MuY29tXCIsXG4gICAgXCJhaXItc3dhcC50ZWNoXCIsXG4gICAgXCJsYXVuY2guYWlyc3dhcC5jY1wiLFxuICAgIFwiYWlyc3dhcC5jY1wiLFxuICAgIFwiYWlyc3dhcHRva2VuLmNvbVwiLFxuICAgIFwibGF1bmNoLmFpcnN3YXAuaW5cIixcbiAgICBcImFpcnN3YXAuaW5cIixcbiAgICBcInNlY3VyaXR5LXN0ZWVtaXQuY29tLm14XCIsXG4gICAgXCJibG9ja2NoYWxud2FsbGV0LmNvbVwiLFxuICAgIFwiYmxvZGtjaGFpbndhbGxldC5jb21cIixcbiAgICBcImJsb2RrY2hhbG4uY29tXCIsXG4gICAgXCJteWV0aGVyZXVtd2FpaWV0LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bXdhbGlldC5jb21cIixcbiAgICBcIm15ZXRoZXJldW13YWxpbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcnN3YWlsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyc3dhbGlldC5jb21cIixcbiAgICBcIm15ZXRoZXJzd2FsaWxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxpbGV0dC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRsLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHd3LmNvbVwiLFxuICAgIFwibXlldGhlcmV1bndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJldW13YWxsY3QuY29tXCIsXG4gICAgXCJteWV0aGVyd2FpaWV0aS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWlpZXRlLmNvbVwiLFxuICAgIFwidXBmaXJuZy5jb21cIixcbiAgICBcInBheXBpZS5uZXRcIixcbiAgICBcInBheXBpZS50ZWNoXCIsXG4gICAgXCJzb2FtLmNvXCIsXG4gICAgXCJteWV0aGVyd2FpaWN0LmNvbVwiLFxuICAgIFwibnVtZXJhaS10b2tlbi5jb21cIixcbiAgICBcInd3dy1iYW5rZXJhLmNvbVwiLFxuICAgIFwidnZhbmNoYWluLm9yZ1wiLFxuICAgIFwib21pc2Vnb2FpcmRyb3AuY29tXCIsXG4gICAgXCJ4bi0tZW5qbmNvaW4tNDFhLmlvXCIsXG4gICAgXCJzdW5jb250cmFjdC5zdVwiLFxuICAgIFwibXlldGhlcndhaWlldHIuY29tXCIsXG4gICAgXCJzaGFwZXNoaWZmLmlvXCIsXG4gICAgXCJ3YXJjaGFpbi5vcmdcIixcbiAgICBcIm15ZXRod2FsbGV0dC5jb21cIixcbiAgICBcIm15ZXRoZXJ2dmFsaWV0LmNvbVwiLFxuICAgIFwid2FuY2hhaW5zLm9yZ1wiLFxuICAgIFwiZXRoZXJwYXJ0eS5pblwiLFxuICAgIFwiZW5qaW5jb2luLm1lXCIsXG4gICAgXCJldGlhbS5pb1wiLFxuICAgIFwiaW52ZXN0LnNtYXJ0bGFuZHMudGVjaFwiLFxuICAgIFwic21hcnRsYW5kcy50ZWNoXCIsXG4gICAgXCJlbmlqbmNvaW4uaW9cIixcbiAgICBcIndhbmNoYWluLm5ldHdvcmtcIixcbiAgICBcIm5pbWlxLnN1XCIsXG4gICAgXCJlbmppbmNvaW4uc2FsZVwiLFxuICAgIFwidGVueHdhbGxldC5pb1wiLFxuICAgIFwiZ29sZW0tbmV0d29yay5uZXRcIixcbiAgICBcIm15eWV0aHdhbGxldC5tbFwiLFxuICAgIFwibXl3ZXRoZXJ3YWlsaWV0LmNvbVwiLFxuICAgIFwib21nLW9taXNlLmNvbVwiLFxuICAgIFwiZGlzdHJpY3QweC50ZWNoXCIsXG4gICAgXCJjZW50cmEtdG9rZW4uY29tXCIsXG4gICAgXCJldGhlcmRldGxhLmNvbVwiLFxuICAgIFwiZXRuZXJwYXJ0eS5pb1wiLFxuICAgIFwiZXRoZXJkZWx0YS5zdVwiLFxuICAgIFwibXlldGhlcndhbGxldHQubmVvY2l0aWVzLm9yZ1wiLFxuICAgIFwibXlldGhlcndhbGxldC1zZWN1cmUuY29tXCIsXG4gICAgXCJteWV0aGVyZXVtd2FsbGV0bnR3LmluZm9cIixcbiAgICBcInJlYWwtbWFya2V0cy5pb1wiLFxuICAgIFwid2FsbGV0LWV0aGVyZXVtLm9yZ1wiLFxuICAgIFwicmVxdWVzdC1uZXR3b3JrLmNvbVwiLFxuICAgIFwic2hhcGVzaGlmdGguaW9cIixcbiAgICBcInNoaWFwZXNoaWZ0LmluXCIsXG4gICAgXCJjb2luLnJlZC1wdWlzZS5jb21cIixcbiAgICBcImliaXR0cmVpeC5jb21cIixcbiAgICBcImNvaW5rYmFzZS5jb21cIixcbiAgICBcImNpbmRpY2F0b3IucHJvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5haWxvZ2luLm1lXCIsXG4gICAgXCJldmVudGNoYWluLmNvXCIsXG4gICAgXCJraW5raWsuaW5cIixcbiAgICBcIm15ZXRoZXJ1bXdhbGxldHZpZXcuY29tXCIsXG4gICAgXCJwcm90b3N0b2tlbmh1Yi5jb21cIixcbiAgICBcImNvaW5yYmFzZS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRsb2dpbi5jb21cIixcbiAgICBcIm9taXNlZ290b2tlbi5jb21cIixcbiAgICBcIm15ZXRoZXJldW13YWxsZXRudHcuY29tXCIsXG4gICAgXCJyZWFsbC5tYXJrZXRzXCIsXG4gICAgXCJjb2Jpbmhvb2Qub3JnXCIsXG4gICAgXCJjb2Jpbmhvb2QuaW9cIixcbiAgICBcImhhcHB5LWNvaW4ub3JnXCIsXG4gICAgXCJiaXRmaW5leC5jb20uY29cIixcbiAgICBcImJpdGZpZW5leC5jb21cIixcbiAgICBcImljb25uLmZvdW5kYXRpb25cIixcbiAgICBcImNlbnRyYS52aXBcIixcbiAgICBcInNtYXJ0Y29udHJhY3QubGl2ZVwiLFxuICAgIFwiYWlyLXRva2VuLmNvbVwiLFxuICAgIFwiY2VudHJhLmNyZWRpdFwiLFxuICAgIFwibXlldGhlcndhbGxldC1zaW5naW4uY29tXCIsXG4gICAgXCJzbWFydGNvbnRyYWN0bGluay5jb21cIixcbiAgICBcInNoYXBlc3NoaWZ0LmlvXCIsXG4gICAgXCIweHRva2VuLmlvXCIsXG4gICAgXCJhdWd1cnByb2plY3QuY29cIixcbiAgICBcImV0aGVyZXVtdXMub25lXCIsXG4gICAgXCJteWV0aGVydW13YWxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRzaWduaW4uY29tXCIsXG4gICAgXCJjaGFuZ2UtYmFuay5vcmdcIixcbiAgICBcImNoYXJnZS1iYW5rLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldHNpbmdpbi5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRjb250cmFjdC5jb21cIixcbiAgICBcImNoYW5nZS1iYW5rLmlvXCIsXG4gICAgXCJjaGFpbmxpbmsudGVjaFwiLFxuICAgIFwibXlldGhlcndhbGxldC1jb25maXJtLmNvbVwiLFxuICAgIFwidG9rZW5zYWxlLmt5YmVybmV0Lm5ldHdvcmtcIixcbiAgICBcImt5YmVybmV0Lm5ldHdvcmtcIixcbiAgICBcImt5YmVyci5uZXR3b3JrXCIsXG4gICAgXCJreWJlcm5ldHdvcmsuaW9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRjb25maXJtLmNvbVwiLFxuICAgIFwia3ZudWtlLmdpdGh1Yi5pb1wiLFxuICAgIFwia2luLmtpa3Byby5jb1wiLFxuICAgIFwibXlldGhlcmV1bXdhbGxldC5jby51a1wiLFxuICAgIFwidG9rZW5zYWxlLWt5YmVyLm5ldHdvcmtcIixcbiAgICBcImt5YmVyLW5ldHdvcmsuY29cIixcbiAgICBcInRva2Vuc2FsZS5reWJlci1uZXR3b3JrLmNvXCIsXG4gICAgXCJweXJvMC5naXRodWIuaW9cIixcbiAgICBcInRva2Vuc2FsZS5reWJlci5kaWdpdGFsXCIsXG4gICAgXCJreWJlci5kaWdpdGFsXCIsXG4gICAgXCJvbWlzZS1nby5tZVwiLFxuICAgIFwibXkuZXRoZXJ3YWxsZXQuY29tLmRlXCIsXG4gICAgXCJiZXBhcnRvZi5jaGFuZ2UtYmFuay5jb1wiLFxuICAgIFwiY2hhbmdlLWJhbmsuY29cIixcbiAgICBcImVuaWdtYS10b2tlbnMuY29cIixcbiAgICBcImNvaW5iYXNlLmNvbS5lc2xvZ2luLmNvXCIsXG4gICAgXCJ4bi0tYml0dHJ4LW12YS5jb21cIixcbiAgICBcImV0aHJkZWx0YS5naXRodWIuaW9cIixcbiAgICBcImV0aGVyZGVsbHRhLmNvbVwiLFxuICAgIFwiaWNvLW5leHVzLnNvY2lhbFwiLFxuICAgIFwicmVkLXB1bHNlLnRlY2hcIixcbiAgICBcImJpdGowYi5pb1wiLFxuICAgIFwieG4tLWJ0dHJleC1id2EuY29tXCIsXG4gICAgXCJraW4ta2xrLmNvbVwiLFxuICAgIFwia2luLWNyb3dkc2FsZS5jb21cIixcbiAgICBcImV0aGVkZWx0YS5jb21cIixcbiAgICBcImNvaW5kYXNoLnN1XCIsXG4gICAgXCJteWV0aHdhbGxldC5jby51a1wiLFxuICAgIFwic3dhcm0uY3JlZGl0XCIsXG4gICAgXCJteWV0aGVyZXVtd2FsbGV0LnVrXCIsXG4gICAgXCJpY29uZXh1LnNvY2lhbFwiLFxuICAgIFwid2FuY2hhaW4uY29cIixcbiAgICBcImVuaWdybmEuY29cIixcbiAgICBcImxpbmtuZXR3b3JrLmNvXCIsXG4gICAgXCJxdHVtLXRva2VuLmNvbVwiLFxuICAgIFwib21pc2Vnby5jb20uY29cIixcbiAgICBcInJpdmV0emludGwub3JnXCIsXG4gICAgXCJldGhlcmRlbHRhLm9uZVwiLFxuICAgIFwidGhlLWV0aGVyLnByb1wiLFxuICAgIFwiZXRoZXJkZWx0YS5naXRudWIuaW9cIixcbiAgICBcImtpcmtpay5jb21cIixcbiAgICBcIm1vbmV0aGEubHRkXCIsXG4gICAgXCJ2bGJlcmF0ZS5pb1wiLFxuICAgIFwiZXRoZXJldW13YWxsZXQta3IuaW5mb1wiLFxuICAgIFwib21pc2UtZ28ub3JnXCIsXG4gICAgXCJpY29uZXh1cy5zb2NpYWxcIixcbiAgICBcImJpdHRpcnJleC5jb21cIixcbiAgICBcImF2ZW50dXMucHJvXCIsXG4gICAgXCJhdGxhbnQuc29sdXRpb25zXCIsXG4gICAgXCJhdmVudHVzLmdyb3VwXCIsXG4gICAgXCJtZXRhbWFrLmlvXCIsXG4gICAgXCJvbWlzZS5jb20uY29cIixcbiAgICBcImhlcm90b2tlbnMuaW9cIixcbiAgICBcInN0YXJiYXNlLnByb1wiLFxuICAgIFwiZXRoZXJkZWx0YS5naXRodWxiLmlvXCIsXG4gICAgXCJoZXJvdG9rZW4uY29cIixcbiAgICBcImtpbmljby5uZXRcIixcbiAgICBcImRtYXJrZXQubHRkXCIsXG4gICAgXCJldGhlcmRlbHRhLmdpbHRodWIuaW9cIixcbiAgICBcImdvbGVtLW5ldHdvcmsuY29tXCIsXG4gICAgXCJldG5lcnNjYW4uaW9cIixcbiAgICBcImJsbHR0cmlleC5jb21cIixcbiAgICBcIm1vbmV0aGEubWVcIixcbiAgICBcIm1vbmV0aGEuY29cIixcbiAgICBcIm1vbmV0aGEtY3Jvd2RzYWxlLmNvbVwiLFxuICAgIFwic3RhcmJhc2UudGVjaFwiLFxuICAgIFwiYXZlbnR1cy1jcm93ZHNhbGUuY29tXCIsXG4gICAgXCJzaGFwZXNoaWZ0LnByb1wiLFxuICAgIFwiYmxsdHRyZXguY29tXCIsXG4gICAgXCJraWNraWNvLmNvXCIsXG4gICAgXCJzdGF0dXN0b2tlbi5pbVwiLFxuICAgIFwiYmlsdHRyZXguY29tXCIsXG4gICAgXCJ0ZW54cGF5LmlvXCIsXG4gICAgXCJiaXR0cmV4Lmx0ZFwiLFxuICAgIFwibWV0YWxwYXkuaW1cIixcbiAgICBcImFyYWdvbi5pbVwiLFxuICAgIFwiY29pbmRhc2gudGVjaFwiLFxuICAgIFwiZGVjZW50cmFsYW5kLnRlY2hcIixcbiAgICBcImRlY2VudHJhbGFuZC5wcm9cIixcbiAgICBcInN0YXR1cy10b2tlbi5jb21cIixcbiAgICBcImJpdHRyZXguY2FtXCIsXG4gICAgXCJlbmlnbWF0b2tlbi5jb21cIixcbiAgICBcInVub2NvaW4uY29tcGFueVwiLFxuICAgIFwidW5vY29pbi5mdW5kXCIsXG4gICAgXCIweHByb2plY3QuaW9cIixcbiAgICBcIjB4dG9rZW4uY29tXCIsXG4gICAgXCJudW1lcmFpLnRlY2hcIixcbiAgICBcImRlY2VudHJhaWFuZC5vcmdcIixcbiAgICBcImJsb2NrY3JlaW4uaW5mb1wiLFxuICAgIFwiYmxvY2tjaGVhbG4uaW5mb1wiLFxuICAgIFwiYmxsb29rY2hhaW4uaW5mb1wiLFxuICAgIFwiYmxvY2tjYmhhaW4uaW5mb1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uZXRocHJvbW9ub2Rlcy5jb21cIixcbiAgICBcIm1ldHRhbWFzay5pb1wiLFxuICAgIFwidG9rZW5zd2FwLm9yZ1wiLFxuICAgIFwibmV0aGVydW0uY29tXCIsXG4gICAgXCJldGhlcmV4eC5vcmdcIixcbiAgICBcImV0aGVydW1lLmlvXCIsXG4gICAgXCJldGhlcmV1bS5wbHVzXCIsXG4gICAgXCJlaHRlcmV1bS5vcmdcIixcbiAgICBcImV0ZXJldXJtLm9yZ1wiLFxuICAgIFwiZXRoZXJlYW0uY29tXCIsXG4gICAgXCJldGhlcmVydW0ub3JnXCIsXG4gICAgXCJldGhlcmV1bS5pb1wiLFxuICAgIFwiZXRoZXJkZWx0YS1nbHRodWIuY29tXCIsXG4gICAgXCJjcnlwdG9hbGxpYW5jZS5oZXJva3VhcHAuY29tXCIsXG4gICAgXCJiaXRzcGFyazIuY29tXCIsXG4gICAgXCJpbmRvcnNldG9rZW4uY29tXCIsXG4gICAgXCJpY29uZXh1cy50a1wiLFxuICAgIFwiaWNvbmV4dXMubWxcIixcbiAgICBcImljb25leHVzLmdhXCIsXG4gICAgXCJpY29uZXh1cy5jZlwiLFxuICAgIFwiZXRoZXJ3YWxsZXQub25saW5lXCIsXG4gICAgXCJ3YWxsZXQtZXRoZXJldW0ubmV0XCIsXG4gICAgXCJiaXRzZGlnaXQuY29tXCIsXG4gICAgXCJldGhlcnN3YXAub3JnXCIsXG4gICAgXCJlb3MuYWNcIixcbiAgICBcInVhc2Z3YWxsZXQuY29tXCIsXG4gICAgXCJ6aWJlci5pb1wiLFxuICAgIFwibXVsdGlwbHktZXRoZXJldW0uaW5mb1wiLFxuICAgIFwiYml0dHJleC5jb216ZS5jb21cIixcbiAgICBcImthcmJvbi52YWNhdS5jb21cIixcbiAgICBcImV0aGVyZGVsdGEuZ2l0bGh1Yi5pb1wiLFxuICAgIFwiZXRoZXJkZWx0YS5nbHRodWIuaW9cIixcbiAgICBcImRpZ2l0YWxkZXZlbG9wZXJzZnVuZC52YWNhdS5jb21cIixcbiAgICBcImRpc3RyaWN0LTB4LmlvXCIsXG4gICAgXCJjb2luLWRhc2guY29tXCIsXG4gICAgXCJjb2luZGFzaC5ydVwiLFxuICAgIFwiZGlzdHJpY3QweC5uZXRcIixcbiAgICBcImFyYWdvbnByb2plY3QuaW9cIixcbiAgICBcImNvaW4td2FsbGV0LmluZm9cIixcbiAgICBcImNvaW5zd2FsbGV0LmluZm9cIixcbiAgICBcImNvbnRyaWJ1dGUtc3RhdHVzLmltXCIsXG4gICAgXCJldGhlci1hcGkuY29tXCIsXG4gICAgXCJldGhlci13YWxsLmNvbVwiLFxuICAgIFwibXljb2lud2FsbGV0Lm5ldFwiLFxuICAgIFwiZXRoZXJldW1jaGFtYmVyLmNvbVwiLFxuICAgIFwiZXRoZXJldW1jaGFtYmVyLm5ldFwiLFxuICAgIFwiZXRoZXJldW1jaGVzdC5jb21cIixcbiAgICBcImV0aGV3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS52Y1wiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20ucGVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQudXMuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS51MDM4NzgzMS5jcC5yZWdydWhvc3RpbmcucnVcIixcbiAgICBcIm15ZXRoZXJldW13YWxsZXQuc3VcIixcbiAgICBcIm15ZXRoZXJ3ZWIuY29tLmRlXCIsXG4gICAgXCJteWV0aGVyaWV1bXdhbGxldC5jb21cIixcbiAgICBcIm15ZXRlaHJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0ZXJ3YWxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWlpZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmluZm9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY2hcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQub21cIixcbiAgICBcIm15ZXRoZXJ2YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5jbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uY29cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLmRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5nbFwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uaW1cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnVhXCIsXG4gICAgXCJzZWN1cmUtbXlldGhlcndhbGxldC5jb21cIixcbiAgICBcInVwZGF0ZS1teWV0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwid3d3bXlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZWF0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhhcndhbGxldC5jb21cIixcbiAgICBcIm15ZWxoZXJ3YWxsZWwuY29tXCIsXG4gICAgXCJteWV0aGVyd2FpbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxpZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGVsLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jYW1cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY2NcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY3pcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQub3JnXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LnRlY2hcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQudG9wXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0Lm5ldFwiLFxuICAgIFwibXlldGhlcndhbGxldC5ydS5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY29tLnJ1XCIsXG4gICAgXCJtZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0cmVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGxlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRodGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGh3YWxsZXQuaW9cIixcbiAgICBcIm15ZXRodGVyd2FsbGV0LmNvXCIsXG4gICAgXCJteWVodGVyd2FsbGV0LmNvXCIsXG4gICAgXCJteWFldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXR0aHRlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQub25lXCIsXG4gICAgXCJteWVsdGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5nZG5cIixcbiAgICBcIm15ZXRoZXJ3YWxsdC5jb21cIixcbiAgICBcIm15ZXRlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRlaGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlYXJ3YWlsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGVsdC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXR0LmNvbVwiLFxuICAgIFwiZXRoZXJ3YWxsZXQub3JnXCIsXG4gICAgXCJteWV0aGVyZXdhbGxldC5jb21cIixcbiAgICBcIm15ZWhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoY3J3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmxpbmtcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRzLmNvbVwiLFxuICAgIFwibXlldGhlYXJ3YWlsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlYXJ3YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyYXdsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcmVhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZXJzd2FsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxlci5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsaWV0LmNvbVwiLFxuICAgIFwibXlldGhlcndsbGV0LmNvbVwiLFxuICAgIFwiZXRoZXJ3YWxsZXQuaW9cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuY2FcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQubWVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQucnVcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQueHl6XCIsXG4gICAgXCJteWV0aGVyd2FsbHRlLmNvbVwiLFxuICAgIFwibXlldGhpcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRocmV3YWxsZXQuY29tXCIsXG4gICAgXCJldGhlcndhbGxldC5uZXRcIixcbiAgICBcIm1hZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJtZXlldGhlcndhbGxldC5jb21cIixcbiAgICBcIm15LmV0aGVyLXdhbGxldC5wd1wiLFxuICAgIFwibXllaHRlcndhbGxldC5jb21cIixcbiAgICBcIm15ZWl0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXllbGhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZWx0aGVyd2FsbGV0LmNvbVwiLFxuICAgIFwibXllcmhlcndhbGxldC5jb21cIixcbiAgICBcIm15ZXRoZWFyd2FsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyZXdhbGxlLmNvbVwiLFxuICAgIFwibXlldGhlcnZ2YWxsZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd2FsbGVudC5jb21cIixcbiAgICBcIm15ZXRoZXJ3YWxsZXQuZm1cIixcbiAgICBcIm15ZXRoZXJ3YWxsbGV0LmNvbVwiLFxuICAgIFwibXlldGhlcndhbGx0ZXQuY29tXCIsXG4gICAgXCJteWV0aGVyd29sbGV0LmNvbVwiLFxuICAgIFwibXlldGxoZXJ3YWxldC5jb21cIixcbiAgICBcIm15ZXRsaGVyd2FsbGV0LmNvbVwiLFxuICAgIFwicm55ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJldGhlcmNsYXNzaWN3YWxsZXQuY29tXCIsXG4gICAgXCJvbWctb21pc2UuY29cIixcbiAgICBcIm9taXNlLWdvLmNvbVwiLFxuICAgIFwib21pc2UtZ28ubmV0XCIsXG4gICAgXCJvbWlzZS1vbWcuY29tXCIsXG4gICAgXCJvbWlzZS1nby5pb1wiLFxuICAgIFwidGVueC10ZWNoLmNvbVwiLFxuICAgIFwiYml0Y2xhaXZlLmNvbVwiLFxuICAgIFwidG9rZW5zYWxlLXRlbngudGVjaFwiLFxuICAgIFwidWJpcWNvaW4ub3JnXCIsXG4gICAgXCJtZXRhbWFzay5jb21cIixcbiAgICBcImV0aHRyYWRlLmlvXCIsXG4gICAgXCJteWV0Y3dhbGxldC5jb21cIixcbiAgICBcImFjY291bnQta2lnby5uZXRcIixcbiAgICBcImJpdGNvaW4td2FsbGV0Lm5ldFwiLFxuICAgIFwiYmxvY2tsaWNoYW4uaW5mb1wiLFxuICAgIFwiYmxvY2xraWNpaGFuLmluZm9cIixcbiAgICBcImNvaW5kYXNoLm1sXCIsXG4gICAgXCJlb3MtYm9udXMuY29tXCIsXG4gICAgXCJlb3MtaW8uaW5mb1wiLFxuICAgIFwiZXRoZXItd2FsbGV0Lm5ldFwiLFxuICAgIFwiZXRoZXJldW0td2FsbGV0LmluZm9cIixcbiAgICBcImV0aGVyZXVtLXdhbGxldC5uZXRcIixcbiAgICBcImV0aGVyZXVtY2hlc3QubmV0XCIsXG4gICAgXCJyZXNlcnZhdGlvbnMta2lnby5uZXRcIixcbiAgICBcInJlc2VydmF0aW9ucy1sb2RnaXguY29tXCIsXG4gICAgXCJzZWN1cmUtbGl2ZXJlei5jb21cIixcbiAgICBcInNlY3VyZS1vbmVyb29mdG9wLmNvbVwiLFxuICAgIFwic2V0dGluZ3MtbGl2ZXJlei5jb21cIixcbiAgICBcInNvZnR3YXJlLWxpdmVyZXouY29tXCIsXG4gICAgXCJzb2Z0d2FyZS1sb2RnaXguY29tXCIsXG4gICAgXCJ1bmhhY2thYmxlZXRoZXJ3YWxsZXRzLmNvbVwiLFxuICAgIFwid3d3LW15ZXRoZXJ3YWxsZXQuY29tXCIsXG4gICAgXCJldGhlcndhbGxldC5jby56YVwiLFxuICAgIFwiZXRoZXJ3YWxsZXRjaGFpbi5jb21cIixcbiAgICBcImV0aGVyd2FsbGV0cy5uZXRcIixcbiAgICBcImV0aGVyd2FsbGV0cy5ubFwiLFxuICAgIFwibXktZXRod2FsbGV0LmNvbVwiLFxuICAgIFwibXkuZXRoZXItd2FsbGV0LmNvXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmNvbS5hbVwiLFxuICAgIFwibXlldGhlcndhbGxldC5jb20uaHRcIixcbiAgICBcIm15ZXRoZXJ3YWxsZXRjb20uY29tXCIsXG4gICAgXCJteWVodGVyd2FpbGV0LmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsZS14b2MuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGxlLTQ0aS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbGUteGhrLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsdC1jZmIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGx0LTZ0Yi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbHQteHViLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsdC1vdmIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGx0LWZ3Yi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbHQtNXdiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsdC1qemkuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGx0LTJjay5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbHQtbG9rLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsdC1sc2wuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGx0LWNlNmYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGV0LW1jYy5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsZXQteGhmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxldC1sY2MuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhZXQtMTViYS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsZXQtd2hmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWV0LXYyZWEuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbGV0LTU5YS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsZXQtamJiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGxldC13YmIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbGV0LTliYi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsZXQtbmNiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGxldC0wY2IuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbGV0LTVuYi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsZXQta3RkLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGxldC1tcmUuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndsbGV0LTc2ZS5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2xsZXQtbzBsLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3bGxldC1jNDVmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJhbGxldC1lam4uY29tXCIsXG4gICAgXCJ4bi0tbXlldGhld2FsbGV0LTRuZi5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsZXQtaW9mLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXdhbGxldC1tcGYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhld2FsbGV0LTZiay5jb21cIixcbiAgICBcInhuLS1teWV0aGV3YWxsZXQtaTMxZi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZXQtZmViLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGx0LWZiYmYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbGV0LXNlYi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsdC1yYmJmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGxldC01ZWIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbHQtM2JiZi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZXQtMHRiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGx0LXRwYmYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbGV0LXJ1Yi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsdC1pcWJmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGxldC1pdmIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbHQtNnFiZi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZXQtOHZiLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGx0LXZyYmYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbGV0LXp3Yi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsdC1rc2JmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGxldC1kemkuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbHQtd2JpZi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZXQtd2NrLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGx0LXNramYuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbGV0LWZvay5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsdC1mdmpmLmNvbVwiLFxuICAgIFwieG4tLW15ZXRocndhbGxldC1mc2wuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhyd2FsbHQtZndrZi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsZXQtNWQ2Zi5jb21cIixcbiAgICBcInhuLS1teWV0aHJ3YWxsdC0zMTllZi5jb21cIixcbiAgICBcInhuLS1teWV0ZXJ3YWxsZXQtdWZrLmNvbVwiLFxuICAgIFwieG4tLW15ZXRlcndhbGxldC1ucmwuY29tXCIsXG4gICAgXCJ4bi0tbXlldGVyd2FsbGV0LXZvbi5jb21cIixcbiAgICBcInhuLS1teWV0ZXJ3YWxsZXQtamw2Yy5jb21cIixcbiAgICBcInhuLS1teWVoZXJ3YWxsZXQtb29jLmNvbVwiLFxuICAgIFwieG4tLW15ZWhlcndhbGxlLTZoY2kuY29tXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FsbGV0LXY0aS5jb21cIixcbiAgICBcInhuLS1teWVoZXJ3YWxsZS16Z2lpLmNvbVwiLFxuICAgIFwieG4tLW15ZWhlcndhbGxldC1vaGsuY29tXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FsbGUtNm9qaS5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxsZXQtY2ViLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbGV0LWNiYmMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC1jN2FjZi5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxsZXQtcGViLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbGV0LW9iYmMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC1uN2FjZi5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxsZXQtMmViLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbGV0LTBiYmMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC15N2FjZi5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxsZXQteHRiLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbGV0LXFwYmMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC1qbGJjZi5jb21cIixcbiAgICBcInhuLS1teXRoZXJ3YWxsZXQtb3ViLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbGV0LWZxYmMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC01bGJjZi5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC0zcWJjLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbHQtc21iY2YuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGV0LTV2Yi5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC1zcmJjLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbHQtZm5iY2YuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGV0LXd3Yi5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC1oc2JjLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbHQtMW5iY2YuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGV0LTl5aS5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC10YmljLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbHQtZG5oY2YuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGV0LXRjay5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC1wa2pjLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbHQtbHNpY2YuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGV0LWNvay5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC1jdmpjLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbHQtYzJpY2YuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGV0LWNzbC5jb21cIixcbiAgICBcInhuLS1teXRocndhbGxldC1jd2tjLmNvbVwiLFxuICAgIFwieG4tLW15dGhyd2FsbHQtYzBqY2YuY29tXCIsXG4gICAgXCJ4bi0tbXl0aGVyd2FsbGV0LTJkNmYuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsZXQtMDE5ZWMuY29tXCIsXG4gICAgXCJ4bi0tbXl0aHJ3YWxsdC15cTNlY2YuY29tXCIsXG4gICAgXCJ4bi0tbWV0aGVyd2FsbGV0LXFsYi5jb21cIixcbiAgICBcInhuLS1tZXRoZXJ3YWxsZXQtMXVmLmNvbVwiLFxuICAgIFwieG4tLW1ldGhlcndhbGxldC1peWkuY29tXCIsXG4gICAgXCJ4bi0tbWV0aGVyd2FsbGV0LXpoay5jb21cIixcbiAgICBcInhuLS1tZXRoZXJ3YWxsZXQtM21sLmNvbVwiLFxuICAgIFwieG4tLW15dGhlcndhbGxldC1mdmIuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhlcndhbGx0LTdkYi5jb21cIixcbiAgICBcInhuLS1teWV0aGVyd2FsbHQtbGViLmNvbVwiLFxuICAgIFwieG4tLW15ZXRoZXJ3YWxsdC15ZWIuY29tXCIsXG4gICAgXCJ4bi0teWV0aGVyd2FsbGV0LXZqZi5jb21cIixcbiAgICBcInhuLS15ZXRoZXJ3YWxsZXQtZGZrLmNvbVwiLFxuICAgIFwieG4tLXlldGhlcndhbGxldC0xdDFmLmNvbVwiLFxuICAgIFwieG4tLXlldGhlcndhbGxldC02MzRmLmNvbVwiLFxuICAgIFwieG4tLW15ZWhlcndhbGxldC1mcGMuY29tXCIsXG4gICAgXCJ4bi0tbXlldGhld2FsbHQtY3JiLmNvbVwiLFxuICAgIFwieG4tLW1ldGhlcndhbGxldC0xdmMuY29tXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FsbHQta2JiODAzOWcuY29tXCIsXG4gICAgXCJ4bi0tbXllaGVyd2FsbGV0LXZrNWYuY29tXCIsXG4gICAgXCJ4bi0teWV0aGV3YWxsZXQtaXc4ZWpsLmNvbVwiLFxuICAgIFwieG4tLWJpdHRyeC10aDhiLmNvbVwiLFxuICAgIFwieG4tLXBvbG5pZXgtbjBhLmNvbVwiLFxuICAgIFwidGhla2V5LnZpblwiLFxuICAgIFwidGhla2V5LXZpcC5jb21cIixcbiAgICBcImRpZ2l0ZXhmdHVyZXMuY29tXCIsXG4gICAgXCJldGh6ZXJvLXdhbGxldC5vcmdcIixcbiAgICBcInplZXBsbi5pb1wiLFxuICAgIFwid2Vwb3dlcnMubmV0d29ya1wiLFxuICAgIFwid2Vwb3dlci52aXNpb25cIixcbiAgICBcInNlZWxlLnByb21vXCIsXG4gICAgXCJzZWVsZS1pY28uZXVcIixcbiAgICBcInNlZWxlLWljby5wcm9cIixcbiAgICBcInN5bmNmYWIudGVjaFwiLFxuICAgIFwidG9rZW5zYWxlLnN5bmNmYWIudGVjaFwiLFxuICAgIFwiaGF2dmVuLnByb21vXCIsXG4gICAgXCJoYXZ2ZW4taWNvLmNvbVwiLFxuICAgIFwiaGF2dmVuLWljby5ldVwiLFxuICAgIFwiaGF3ZW4uaW9cIixcbiAgICBcImhhdnZlbi54eXpcIixcbiAgICBcInRvbW8tY29pbi5pb1wiLFxuICAgIFwidG9tb2NvbG4uaW9cIixcbiAgICBcImRvY2FpLnNjaWVuY2VcIixcbiAgICBcInRvbW9jb2luLm5ldHdvcmtcIixcbiAgICBcImNlbHNpdXMtaWNvLm5ldHdvcmtcIixcbiAgICBcImNlbHNpdXNzLm5ldHdvcmtcIixcbiAgICBcImNvdGkuY2ZcIixcbiAgICBcInhuLS1tZXJjYWRvYnRjb24tbWZiZC5jb21cIixcbiAgICBcInF1YW50c3R1bXAuY29tXCIsXG4gICAgXCJxdWFudHN0YW1wY29pbi5jb21cIixcbiAgICBcInF1YW50aXN0YW1wLmNvbVwiLFxuICAgIFwiZWxlY3RydW0uY29tXCIsXG4gICAgXCJ0cm9uZm91bmRhdGlvbi51c1wiLFxuICAgIFwiZGF2LW5ldHdvcmsuaW9cIixcbiAgICBcInB5YXBheS5jb1wiLFxuICAgIFwiZGFvc3RhY2stdG9rZW4uaW9cIixcbiAgICBcImljb2xpc3Quc2FsZVwiLFxuICAgIFwic2hpdm9tLnNhbGVcIixcbiAgICBcImRhb3N0YWNrLm9udW5pdmVyc2UuY29tXCIsXG4gICAgXCJkYXYuaWNvY3Jvd2RzYWxlLmlvXCIsXG4gICAgXCJteWV0aGNyd2FsbGV0LWYuY29tXCIsXG4gICAgXCJteWV0aGNyd2FsbGV0LWcuY29tXCIsXG4gICAgXCJteWV0aGVyZXdhbGxldC5jZlwiLFxuICAgIFwibXlldGhlcndhbGxldC1pLmNvbVwiLFxuICAgIFwibXlldGhlcndhbGxldGMub3JnXCIsXG4gICAgXCJteWV0ZXJ3YWxsY3QtcC5jb21cIixcbiAgICBcIm15ZXRoY3J3YWxsY3QtYS5jb21cIixcbiAgICBcIm15ZXRoY3J3YWxsZXQtYi5jb21cIixcbiAgICBcIm15ZXRoY3J3YWxsZXQtYy5jb21cIixcbiAgICBcIm15ZXRoY3J3YWxsZXQtZC5jb21cIixcbiAgICBcIm15ZXRoZXJ2dmFsbGV0LndpblwiLFxuICAgIFwibXlldGhlcndhbGxhdC5kYXRlXCIsXG4gICAgXCJteWV0aGVyd2FsbGV0LmFjY291bnRhbnRcIixcbiAgICBcInF1YXJrY2hhaW4ubGl2ZVwiLFxuICAgIFwidmVyYXNpaXR5LmNvXCIsXG4gICAgXCJtb25lcm96ZXJvLnRyYWRlXCIsXG4gICAgXCJkYXYuc3lzdGVtc1wiLFxuICAgIFwiZXRoLm1lZGl1bWJsb2cub3JnXCIsXG4gICAgXCJldGhlLm1lZGl1bWJsb2cudG9wXCIsXG4gICAgXCJjbGFpbS5ldGhlcjMzLm9ubGluZVwiLFxuICAgIFwiYW55LmV0aGVyMzMub25saW5lXCIsXG4gICAgXCJtZWRpdW1ibG9nLm9yZ1wiLFxuICAgIFwic3dzd2QuZXRoZXIzMy5vbmxpbmVcIixcbiAgICBcInN3ZHdkLmV0aGVyczQ0NC5vbmxpbmVcIixcbiAgICBcImV0aDIyLm1lZGl1bWJsb2cudG9wXCIsXG4gICAgXCJldG9yb2dsb2JhbC5jb21cIixcbiAgICBcImJjcnlwdG8uY2x1YlwiLFxuICAgIFwiYWlyZHJvcC1iaXRuYXRpb25hbC5jb21cIixcbiAgICBcIndhc2FiaWJpdGNvaW53YWxsZXQub3JnXCIsXG4gICAgXCJ4ZW5pdW14LmNvbVwiLFxuICAgIFwiaWRleC1jbGFpbS5zdVwiLFxuICAgIFwiZnVsY3J1bS5jbGlja1wiLFxuICAgIFwiYml0YmFuay5ndXJ1XCIsXG4gICAgXCJiaXRiYW5rLmxhbmRcIixcbiAgICBcImZ1bGNydW0ucnVuXCIsXG4gICAgXCJjdXJ2ZS5mbVwiLFxuICAgIFwiY3VydmUuZnJsXCIsXG4gICAgXCJjdXJ2ZS5meWlcIixcbiAgICBcImN1cnZlcy5maVwiLFxuICAgIFwiY3VydmVzLmV4Y2hhbmdlXCIsXG4gICAgXCJ4bi0tbGVkZ3ItOXphLmNvbVwiLFxuICAgIFwieG4tLWxlZGdyLWVzYS5jb21cIixcbiAgICBcInhuLS1sZWRlci1iM2IuY29tXCIsXG4gICAgXCJ4bi0tbGRnZXItajBhLmNvbVwiLFxuICAgIFwieG4tLWxlZGdyLTdyYS5jb21cIixcbiAgICBcInhuLS1sZGdyLWJwYWMuY29tXCIsXG4gICAgXCJ4bi0tbGVkci14dmEzZC5jb21cIixcbiAgICBcInhuLS1sZWRlci1iMmEuY29tXCIsXG4gICAgXCJ4bi0tbGVkZXItazBiLmNvbVwiLFxuICAgIFwieG4tLWVkZ2VyLWk2YS5jb21cIixcbiAgICBcInhuLS1lZGdlci1qN2EuY29tXCIsXG4gICAgXCJ4bi0tbGRnZXItYnNhLmFwcFwiLFxuICAgIFwieG4tLWVkZ2VyLXU2YS5jb21cIixcbiAgICBcInhuLS1sZWRnZXItYmxhLmNvbVwiLFxuICAgIFwieG4tLWVkZ2VyLW1uYi5jb21cIixcbiAgICBcInhuLS1lZGdlci1kcWIuY29tXCIsXG4gICAgXCJ4bi0tZWRnZXItMGVjLmNvbVwiLFxuICAgIFwieG4tLWVkZ2VyLWNqMWIuY29tXCIsXG4gICAgXCJ4bi0tZWRnZXItb2oxYi5jb21cIixcbiAgICBcInhuLS1lZGdlci1kazFiLmNvbVwiLFxuICAgIFwieG4tLWVkZ2VyLWZlM3MuY29tXCIsXG4gICAgXCJ4bi0tZWRnZXItc2wzcy5jb21cIixcbiAgICBcInhuLS1sZGdlci00cmEuY29tXCIsXG4gICAgXCJ4bi0tbGRnZXItaHNhLmNvbVwiLFxuICAgIFwieG4tLWxkZ2VyLWl6YS5jb21cIixcbiAgICBcInhuLS1sZGdlci12MGEuY29tXCIsXG4gICAgXCJ4bi0tbGRnZXItYzZiLmNvbVwiLFxuICAgIFwieG4tLWxkZ2VyLWJpYy5jb21cIixcbiAgICBcInhuLS1sZGdlci12ZDFiLmNvbVwiLFxuICAgIFwieG4tLWxkZ2VyLWtlMWIuY29tXCIsXG4gICAgXCJ4bi0tbGRnZXItYzYxYi5jb21cIixcbiAgICBcInhuLS1sZGdlci0wNjFiLmNvbVwiLFxuICAgIFwieG4tLWxkZ2VyLXA3MWIuY29tXCIsXG4gICAgXCJ4bi0tbGRnZXItd2U5Yy5jb21cIixcbiAgICBcInhuLS1sZWdlci02eWEuY29tXCIsXG4gICAgXCJ4bi0tbGVnZXItOWtiLmNvbVwiLFxuICAgIFwieG4tLWxlZ2VyLXRiYy5jb21cIixcbiAgICBcInhuLS1sZWdlci02YjFiLmNvbVwiLFxuICAgIFwieG4tLWxlZ2VyLXZjMWIuY29tXCIsXG4gICAgXCJ4bi0tbGVnZXItb2wzcy5jb21cIixcbiAgICBcInhuLS1sZWRlci1tMWEuY29tXCIsXG4gICAgXCJ4bi0tbGVkZXItbmYxYi5jb21cIixcbiAgICBcInhuLS1sZWRnci1rc2EuY29tXCIsXG4gICAgXCJ4bi0tbGVkZ3ItbHphLmNvbVwiLFxuICAgIFwieG4tLWxlZGdyLW0wYS5jb21cIixcbiAgICBcInhuLS1sZWRnci0yNWIuY29tXCIsXG4gICAgXCJ4bi0tbGVkZ3ItOGNjLmNvbVwiLFxuICAgIFwieG4tLWxlZGdyLW1kMWIuY29tXCIsXG4gICAgXCJ4bi0tbGVkZ3ItYmUxYi5jb21cIixcbiAgICBcInhuLS1sZWRnci16ZTFiLmNvbVwiLFxuICAgIFwieG4tLWxlZGdyLWY2MWIuY29tXCIsXG4gICAgXCJ4bi0tbGVkZ3ItMzYxYi5jb21cIixcbiAgICBcInhuLS1sZWRnci1zNzFiLmNvbVwiLFxuICAgIFwieG4tLWxlZGdyLXplOWMuY29tXCIsXG4gICAgXCJ4bi0tbGVkZ2UtNTdiLmNvbVwiLFxuICAgIFwieG4tLWxlZGdlLWdqYy5jb21cIixcbiAgICBcInhuLS1sZWRnZS1ucDFiLmNvbVwiLFxuICAgIFwieG4tLWxlZGdlLWNxMWIuY29tXCIsXG4gICAgXCJ4bi0tbGVkZ2UtZ20zcy5jb21cIixcbiAgICBcInhuLS1sZWRnZS02bzNzLmNvbVwiLFxuICAgIFwieG4tLWxkZ3ItdnZhMjM2NmIuY29tXCIsXG4gICAgXCJ4bi0tbGRnci14dmE3MjY2Yi5jb21cIixcbiAgICBcInhuLS1sZGVyLXZ2YTVkLmNvbVwiLFxuICAgIFwieG4tLWxkci1rcmFiM2QuY29tXCIsXG4gICAgXCJ4bi0tbGVkcXItOXphLmNvbVwiLFxuICAgIFwibGVkZ2Vyc3VwcG9ydC5pb1wiLFxuICAgIFwibG9sZGV2cy5jb21cIixcbiAgICBcImN1cnZlLnNpXCIsXG4gICAgXCJjdXJ2ZS5zb1wiLFxuICAgIFwiY3VydmVmaS5pb1wiLFxuICAgIFwiY3Vyd2UuZmlcIixcbiAgICBcImxlY2RnZXIuY29tXCIsXG4gICAgXCJsZWRjZ2VyLmNvbVwiLFxuICAgIFwibGVkcWVyLmNjXCIsXG4gICAgXCJsZWRnZXJ3YWxsZXRyZXN0b3JlLmNvbVwiLFxuICAgIFwibGVkbHFlci5jb21cIixcbiAgICBcImxhYmdlci5jb21cIixcbiAgICBcInhuLS1lZGdyLXoxYTU3MzZiLmNvbVwiLFxuICAgIFwieG4tLWxlZGdlci1tY2IuY29tXCIsXG4gICAgXCJsZWRnZXIuY29tLWRldmljZS5pZDczNDU3LmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1kZXZpY2UuaWQ0NTY2My5hcHBcIixcbiAgICBcImxlZGdlci5jb20tZGV2aWNlLmlkNDYyNjcuYXBwXCIsXG4gICAgXCJ4bi0tbGVkci1keGEwNzU2Yi5jb21cIixcbiAgICBcImxlZGdlci1saXZlLm9yZ1wiLFxuICAgIFwibGVkZ2VyLmNvbS42MzQ2NDQuYXBwXCIsXG4gICAgXCJsZWRnZXIuY29tLjgzNzcyOS5hcHBcIixcbiAgICBcImxlZGdlci5jb20uNTY1MzMzLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS40NTM0NTUuYXBwXCIsXG4gICAgXCJsZWRnZXIuY29tLjM0MjM0NC5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjgzNzcyOS5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjYzNDY0NC5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjU2NTMzMy5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjQ1MzQ1NS5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjM0MjM0NC5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjc1NjcyOC5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjcyNzc4My5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjY1NzM3Ny5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjg5MzkwMC5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjc0NTU4My5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjY4ODMzOC5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLmlkLjg4Mzg4Mi5hcHBcIixcbiAgICBcImxlZGdlci5jb20uZGV2aWNlLXUyMy12ZXJpZmljYXRpb24uYXBwXCIsXG4gICAgXCJsZWRnZXIuY29tLmRldmljZS1lNzItdmVyaWZpY2F0aW9uLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS52ZXJpZmljYXRpb24tbG9naW4tczYxLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS5hY2MtdmVyaWZpY2F0aW9uLWxvZ2luLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS5kZXZpY2UuaWQuNzUzNzQ3Mi5hcHBcIixcbiAgICBcImxlZGdlci5jb20uaGFyZHdhcmUuaWQuNTQ2NTYzNDYuYXBwXCIsXG4gICAgXCJsZWRnZXIuY29tLmRldmljZS5pZC42NTY3Mjg4LmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS5oYXJkd2FyZS5pZC45NTM3ODE4MzIuYXBwXCIsXG4gICAgXCJ4bi0tbGRyLXFzYTI5OThhY2EuY29tXCIsXG4gICAgXCJsZWRnZXIuY29tLXNldHRpbmdzLmRldmljZS1pZC00NTY4Mi5hcHBcIixcbiAgICBcInhuLS1sZWRlLWR4YTkzYS5jb21cIixcbiAgICBcInhuLS1sZWRyLXh2YTVlLmNvbVwiLFxuICAgIFwibGVkZ2VyLmNvbS1zZXR0aW5ncy5kZXZpY2UtaWQtNjgzOTkuYXBwXCIsXG4gICAgXCJ4bi0tbGRlci12dmE3ZS5jb21cIixcbiAgICBcInhuLS1lZGVyLW14YTlrLmNvbVwiLFxuICAgIFwibGVkZ2VyLmNvbTEzNDY3ODk3NjU4MS5pbmZvXCIsXG4gICAgXCJsZWRnZXIuY29tLmxvZ2luLXdhbGxldC5hcHBcIixcbiAgICBcImxlZGdlci5jb20udmVyaWZpY2F0aW9uLWxvZ2luLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1sb2dpbi1hdXRob3JpemF0aW9uLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1sb2dpbi12ZXJpZmljYXRpb24uYXBwXCIsXG4gICAgXCJiYWxhbnNjZXIuZXhjaGFuZ2VcIixcbiAgICBcInhuLS1sZHIta3JhYjVlLmNvbVwiLFxuICAgIFwieG4tLWxlZHItbnhhODU1NmIuY29tXCIsXG4gICAgXCJsZWRnZXIuY29tLmxvZ2luLWFjY291bnQuYXBwXCIsXG4gICAgXCJsZWRnZXIuY29tLndhbGxldC1sb2dpbi5hcHBcIixcbiAgICBcImxlZGdlci5jb20ubG9naW4tdmVyaWZpY2F0aW9uLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1sb2dpbi1hY2NvdW50LmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1sb2dpbi1hY3Rpdml0eS5hcHBcIixcbiAgICBcInhuLS1sZGVyLWN4YTg2NTZiLmNvbVwiLFxuICAgIFwibGVkZ2VyLmNvbTE2Mjguc3VwcG9ydFwiLFxuICAgIFwibGVkZ2VyLmNvbTE3MjY2NTQ4Mjk1NjQzLmluZm9cIixcbiAgICBcImxlZGdlci5jb20tbG9naW4td2FsbGV0LmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1sb2dpbi1zZWN1cmUuYXBwXCIsXG4gICAgXCJsZWRnZXIuY29tLWFjdGl2aXR5LWxvZ2luLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1hY2NvdW50LWxvZ2luLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS1hdXRob3JpemF0aW9uLWxvZ2luLmFwcFwiLFxuICAgIFwibGVkZ2VyLmNvbS12ZXJpZmljYXRpb24tbG9naW4uYXBwXCIsXG4gICAgXCJsZWRnZXIuY29tMTkyNzU3Mi5pbmZvXCIsXG4gICAgXCJsZWRnZXIuY29tMTgyOTU4Mi5pbmZvXCIsXG4gICAgXCJsZWRnZXIuY29tNDAxLnN1cHBvcnRcIixcbiAgICBcImxlZGdlci5jb20xNzIuc3VwcG9ydFwiLFxuICAgIFwibGVkZ2RyLmNvbVwiLFxuICAgIFwibGVsZ2VyLmNvbVwiLFxuICAgIFwid3d3LWxlZGdlci5jb21cIixcbiAgICBcImxlZGdlcnJlY292ZXJ5LmNvbVwiLFxuICAgIFwibGVkZ2VyLmNvbS12aWV3YWNjb3VudC5jb21cIixcbiAgICBcIndhbGxldGNvbm5lY3RzLm9yZ1wiLFxuICAgIFwid2FsbGV0Y29ubmVjdC5jb20uc2VcIixcbiAgICBcInRvcm5hZG9jYXNoLm9yZ1wiLFxuICAgIFwibG9naW4ueG4tLWJvY2tjaGFsbi12cGIuY29tXCIsXG4gICAgXCJ3d3cubGJsaGJsb2NrY2hhaW4uY29tXCIsXG4gICAgXCJ3YWxsZXRjb25uZWNsLm9yZ1wiLFxuICAgIFwid2FsbGV0c2Nvbm5lY3QuaG9zdFwiLFxuICAgIFwid2FsbGV0c2Nvbm5lY3RhcHAuY29tXCIsXG4gICAgXCJ3YWxsZXRzY29ubmVjdC5kZXZcIixcbiAgICBcIndhbGxldGNvbm5lY3RsaXZlLnZpcFwiLFxuICAgIFwid2FsbGV0c3luY2hyb25pemUubGl2ZVwiLFxuICAgIFwiZHJvcGVsb24uaW9cIixcbiAgICBcImdpdmVtdXNrLnNwYWNlXCIsXG4gICAgXCJtdXNreC5kaWdpdGFsXCIsXG4gICAgXCJtdXNrZnJlZS5jb21cIixcbiAgICBcIm11c2t4LmlvXCIsXG4gICAgXCJ1bmkyMDIxLmNvbVwiLFxuICAgIFwidW5pYXdhcmQubmV0XCIsXG4gICAgXCJ1bmlwcm9tby5vcmdcIixcbiAgICBcInVuaXJld2FyZC5vcmdcIixcbiAgICBcInVuaXN3YXAuc3VwcGx5XCIsXG4gICAgXCJ0bHAtaW52ZXN0LmNvbVwiLFxuICAgIFwiY29pbndvei5jb21cIixcbiAgICBcImJ0Y2RpcmUuY29tXCIsXG4gICAgXCJidGNzaGFkZS5jb21cIixcbiAgICBcImxlbW1leHJwLmNvbVwiLFxuICAgIFwic21lbGxiaXQuY29tXCIsXG4gICAgXCJ1bml3c2FwLmlvXCIsXG4gICAgXCJ1bmlzd25hcC5pb1wiLFxuICAgIFwidW5pd3NhcC5jb21cIixcbiAgICBcInVuaXN3bmFwLmNvbVwiLFxuICAgIFwiYXBwLnVuaXN3YXAuYWlyZHJvcC10b2tlbi1ob2xkZXIuY29tXCIsXG4gICAgXCJhcHAudW5pc3dhcC50b2tlbi1wcm90b2NvbC1haXJkcm9wLmNvbVwiLFxuICAgIFwidW5pc3dhcC12My5vcmdcIixcbiAgICBcInVuaXN3YXB2Mm5vZGUubmV0XCIsXG4gICAgXCJ1bmlzd2FwdjJ2MS5uZXR3b3JrXCIsXG4gICAgXCJsaXJiaXQuY29tXCIsXG4gICAgXCJwZWV0ZGVjZW50cmFsaXplZC5maW5hbmNlXCIsXG4gICAgXCJjb2lubWlrLmNvbVwiLFxuICAgIFwiYml0emF1LmNvbVwiLFxuICAgIFwieWZpbmV3LmNvbVwiLFxuICAgIFwibWV0YW1hc2tyZXN0b3Jlcy5saW5rXCIsXG4gICAgXCJob2hiaXQuY29tXCIsXG4gICAgXCJtZXRhbWFza3NpdGUubGl2ZVwiLFxuICAgIFwibWV0YW1hc2t3YWxsZXQuaGVscFwiLFxuICAgIFwiaW10b2tlbnBheS54eXpcIixcbiAgICBcImltdG9rZW4udG91cnNcIixcbiAgICBcImltdG9rZW4tMS5jb21cIixcbiAgICBcImltdG9rZW51c2EudG9wXCIsXG4gICAgXCJpbnRva2VuLnRvcFwiLFxuICAgIFwiaW10b2tlbnNkdC54eXpcIixcbiAgICBcImltdG9rZW5nLmNvbVwiLFxuICAgIFwiaW10b2tlbi1pYy5jb21cIixcbiAgICBcImltdG9rZW4tbG9naW4uY29tXCIsXG4gICAgXCJpbXRva2VuLnNob3dcIixcbiAgICBcImltdG9rZW5nLnh5elwiLFxuICAgIFwiaW10b2tlbi5leHByZXNzXCIsXG4gICAgXCJpbXRva2VuLmdvbGRcIixcbiAgICBcImltdG9rZW5oLm5ldFwiLFxuICAgIFwiaW10b2tlbi56b25lXCIsXG4gICAgXCJpbXRva2Vucy5uZXRcIixcbiAgICBcImltdG9rZW4ubGFcIixcbiAgICBcImltdG9rZW4uY29tLmNuXCIsXG4gICAgXCJ3d3cuaW0tdG9rZW4uY2NcIixcbiAgICBcImltdG9rZW4uY25cIixcbiAgICBcInd3dy5pbS10b2tlbi5tZVwiLFxuICAgIFwidG9rZW5pbS5jb20uY25cIixcbiAgICBcIndhbGxldDMuaW10b2tlbnMubGl2ZVwiLFxuICAgIFwidG9rZW5pLmNuXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuZ3IuY29tXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIud29ybGRcIixcbiAgICBcInBvbGthc3RhcnRlci5sdGRcIixcbiAgICBcInBvbGthc2xhcnRlci5jb21cIixcbiAgICBcInBvbGthc3RhcnRlci5jbi5jb21cIixcbiAgICBcImF0b21pY3dhbGxldHdlYnMubmV0XCIsXG4gICAgXCJteWVmbGhlcndhbGxldC5jb21cIixcbiAgICBcInBhbmNha2Vzd2FwLmZpdFwiLFxuICAgIFwidHJ1c3R3YWxsZXR0cy5uZXRcIixcbiAgICBcIndhbGxlY3Rjb25lY3QueHl6XCIsXG4gICAgXCJ3YWxsZXRhdXRoZW50aWNhdGlvbi5vcmdcIixcbiAgICBcIndhbGxldGF1dGhlbnRpY2F0b3Iub3JnXCIsXG4gICAgXCJ3YWxsZXRzLXJlYXV0aG9yaXphdGlvbi5jb21cIixcbiAgICBcIndhbGxldHNlY3VyZS5hcHBcIixcbiAgICBcIndhbGxldHNlY3VyZW9ubGluZS5jb21cIixcbiAgICBcIndhbGxldHNlY3VyZW9ubGluZS5vcmdcIixcbiAgICBcInBvbGthc3RhcnRlci50b1wiLFxuICAgIFwicG9sa2Fhc3RhcnRlci5jb21cIixcbiAgICBcInBvbGthc3RhcmZlci5jb21cIixcbiAgICBcInBvbGthc3RhcnRlaWRvLmNvbVwiLFxuICAgIFwicG9sa2FzdGFydGVyLmFwcFwiLFxuICAgIFwicG9sa2FzdGFydGVyLmNvbS5jb1wiLFxuICAgIFwicG9sa2FzdGFydGVyLmNvbW11bml0eVwiLFxuICAgIFwicG9sa2FzdGFydGVyLmZ1blwiLFxuICAgIFwicG9sa2FzdGFydGVyLmdyb3VwXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIubGxjXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIub25lXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIudHJhZGVcIixcbiAgICBcInBvbGthdHNhcnRlci5jb21cIixcbiAgICBcInBvbGthc3RhcnRlcmJvbnVzLmxpdmVcIixcbiAgICBcInBvbGthc3RhcnRlcmNvbm5lY3QuY29tXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXJzLnNhbGVcIixcbiAgICBcInBvbGthc3RhcnRlci5jYXNoXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXJhcHAuY29tXCIsXG4gICAgXCJwb2xrYS1zdGFydGVyLmluZm9cIixcbiAgICBcInBvbGthc3RhcnRlci50b29sc1wiLFxuICAgIFwicG9sa2Fyc3RhcnRlci5jb21cIixcbiAgICBcInBvbGthbHN0YXJ0ZXIuY29tXCIsXG4gICAgXCJwb2xrYS1zdGFydGVycy5jb21cIixcbiAgICBcInBvbGthc3RhcnRlci5kZS5jb21cIixcbiAgICBcInBvbGthc3J0YXJ0ZXIuY29tXCIsXG4gICAgXCJiZWVmeS5maW5hbmNpYWxcIixcbiAgICBcImZvcnRlcy5saWZlXCIsXG4gICAgXCJtb29uY2FrZWJzYy5jb21cIixcbiAgICBcInBvbGthc3RhcnRyZXIuY29tXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuZml0XCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuY29kZXNcIixcbiAgICBcInBvbGthc3RhcnRlci5nZG5cIixcbiAgICBcInBvbGthc3RhcnRlci5tb21cIixcbiAgICBcInBvbGxsa2FzdGFydGVyLmNvbVwiLFxuICAgIFwicG9sa2FzdGFydGVyLnRlbFwiLFxuICAgIFwicG9sa2FzdGFydGVyLmNvbnRhY3RcIixcbiAgICBcInBvbGthc3RhcnRlci5wYXJ0eVwiLFxuICAgIFwicG9sa2FzdGFydGVyLmxlZ2FsXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuc29sYXJcIixcbiAgICBcInBvbGthc3RhcnRlci5zb2x1dGlvbnNcIixcbiAgICBcInBvbGthc3RhcnRlci5zb2NpYWxcIixcbiAgICBcInBvbGthc3RhcnRlci5kb21haW5zXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuc3RyZWFtXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuZXZlbnRzXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIud2F0Y2hcIixcbiAgICBcInBvbGthc3RhcnRlci5iYXJcIixcbiAgICBcInBvbGthc3RhcnRlci5tZWRpYVwiLFxuICAgIFwicG9sa2FzdGFydGVyLm1vbnN0ZXJcIixcbiAgICBcInBvbGthc3RhcnRlci5xdWVzdFwiLFxuICAgIFwicG9sa2FzdGFydGVyLmNhbXBcIixcbiAgICBcInBvbGthc3RhcnRlci5meWlcIixcbiAgICBcInBvbGthc3RhcnRlci5mdXRib2xcIixcbiAgICBcInBvbGthc3RhcnRlci5nb2xkXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuc3R1ZHlcIixcbiAgICBcInBvbGthc3RhcnRlci5jb20uZXNcIixcbiAgICBcIm9yaW9uLW1vbmV5LnNhbGVcIixcbiAgICBcInBvbGthc3RhcnRlcnMub25lXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIucmVoYWJcIixcbiAgICBcImdub3Npcy1zYWZlLm9yZ1wiLFxuICAgIFwiZ25vc2lzLWFpcmRyb3AubGl2ZVwiLFxuICAgIFwiYWJjaGFuZ2UuaW9cIixcbiAgICBcInBvbGthc2ZhcnRlci5jb21cIixcbiAgICBcInBvbGthc3RhcnRlci5jYW1cIixcbiAgICBcInBvbGthc3RhcnRlci5kaXJlY3RcIixcbiAgICBcInBvbGthc3RhcnRlci5jYXJlXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuZGlyZWN0b3J5XCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuZXhwcmVzc1wiLFxuICAgIFwicG9sa2FzdGFydGVyLnN1cHBseVwiLFxuICAgIFwicG9sa2FzdGFydGVyLmxpZ2h0aW5nXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuYXVjdGlvblwiLFxuICAgIFwicG9sa2FzdGFydGVyLmNhcmRzXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuY29tcHV0ZXJcIixcbiAgICBcInBvbGthc3RhcnRlci5zYS5jb21cIixcbiAgICBcInBvbGthc3RhcnRyZS5jb21cIixcbiAgICBcInBvbGthc3RyYXJ0ZXIuY29tXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuY29vbFwiLFxuICAgIFwicG9sa2FzdGFydGVyLmN5b3VcIixcbiAgICBcInBvbGthc3RhcnRlci5leHBlcnRcIixcbiAgICBcInBvbGthc3RhcnRlci50ZWFtXCIsXG4gICAgXCJwb2xrYXN0b3J0ZXIuY29tXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIuaG9tZXNcIixcbiAgICBcInBvbGthc3RhcnRlci5mYXJtXCIsXG4gICAgXCJwb2xrYXN0YXJ0ZXIud3RmXCIsXG4gICAgXCJzeW5hcHNlcHJvdG9jb2xtaWdyYXRpb24uY29tXCIsXG4gICAgXCJjb252ZXhmaW5hbmNlLm9yZ1wiLFxuICAgIFwibWV0YWxtYXNrLm1lXCIsXG4gICAgXCJ3YWxsZXRhY2Nlc3NwYXNzLm9ubGluZVwiLFxuICAgIFwiZHlkeGV4Y2hhbmdlLm5ldFwiLFxuICAgIFwiYWF4c3dhcC5jb21cIixcbiAgICBcInJlcG9zd2FwLmNvXCIsXG4gICAgXCJlc2xhYi5pb1wiLFxuICAgIFwiYnNjc3Bpbi5jb21cIixcbiAgICBcIm1lbGxvYnNjLmNvbVwiLFxuICAgIFwiY2hyb21pYWNvaW4uaW9cIixcbiAgICBcInd4ZmkuaW9cIixcbiAgICBcImltbWNvaW4uaW9cIixcbiAgICBcInB1bmtldGguaW9cIixcbiAgICBcInVzZHR3LmluZm9cIixcbiAgICBcInhjaDUuaW9cIixcbiAgICBcImR5ZGV4LmlvXCIsXG4gICAgXCJ2ZWxvY2hhaW4uaW9cIixcbiAgICBcImNoYXJwdW5rLmNvbVwiLFxuICAgIFwidGVzdC5jb21cIixcbiAgICBcInl1aS5maW5hbmNlXCIsXG4gICAgXCJwdXBkb2dlY2xhaW0uY29tXCIsXG4gICAgXCJic2N0b2tlbi5pb1wiLFxuICAgIFwicGF5b3UuZmluYW5jZVwiLFxuICAgIFwiYWxwYWNhYWlyZHJvcC5saXZlXCIsXG4gICAgXCJkZWFweS5vcmdcIixcbiAgICBcImJlZXpleC5uZXRcIixcbiAgICBcImFsaWNlZHJvcC5jb21cIixcbiAgICBcInN1cGRhby5jb21cIixcbiAgICBcImFpcnN0YWNrLm5ldFwiLFxuICAgIFwidHd0bG9hbi5jb21cIixcbiAgICBcImJzY21lbGxvLmlvXCIsXG4gICAgXCJrZXk3Lm5ldFwiLFxuICAgIFwia3J5b3NzLm5ldFwiLFxuICAgIFwiYmlvc3dhcC5maW5hbmNlXCIsXG4gICAgXCJmZjkuaW9cIixcbiAgICBcInNhZmVtb29uLWRpdmlkZW5kLmNvbVwiLFxuICAgIFwic2Zhci5pb1wiLFxuICAgIFwib3B0aW1pc20udHJhZGVcIixcbiAgICBcImNvd3N3YXAuc2FsZVwiLFxuICAgIFwibWV0YW1hc2std2FsbGV0LXNlY3VyaXR5LndlYi5hcHBcIixcbiAgICBcImx5cmEuc2FsZVwiLFxuICAgIFwicmFja2V0cG9vbC5jb21cIixcbiAgICBcImNvbGFicmF0aW9uLmNjXCIsXG4gICAgXCJyZXZva2VjYXNoLmNvbVwiLFxuICAgIFwidGhvci5mdW5kXCIsXG4gICAgXCJkb2dhbWwubmV0XCIsXG4gICAgXCJhY3Jvcy50b1wiLFxuICAgIFwidHJlem9yLnJ1blwiLFxuICAgIFwidHJlem9yLnVzXCIsXG4gICAgXCJzYXRvc2hpbGFicy5jb1wiLFxuICAgIFwidHJlem9ybmV3cy5pb1wiLFxuICAgIFwic3VpdGUudHJlem9yLnJ1blwiLFxuICAgIFwidHJlem9yd2FsbGV0Lm9yZ1wiLFxuICAgIFwiZGFwcC1maXgubmV0XCJcbiAgXVxufVxuIiwiY29uc3QgbGV2ZW5zaHRlaW4gPSByZXF1aXJlKCdmYXN0LWxldmVuc2h0ZWluJylcbmNvbnN0IERFRkFVTFRfVE9MRVJBTkNFID0gM1xuXG5jbGFzcyBQaGlzaGluZ0RldGVjdG9yIHtcblxuICAvKipcbiAgICogTGVnYWN5IHBoaXNoaW5nIGRldGVjdG9yIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IExlZ2FjeVBoaXNoaW5nRGV0ZWN0b3JDb25maWd1cmF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFt3aGl0ZWxpc3RdIC0gT3JpZ2lucyB0aGF0IHNob3VsZCBub3QgYmUgYmxvY2tlZC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2JsYWNrbGlzdF0gLSBPcmlnaW5zIHRvIGJsb2NrLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbZnV6enlsaXN0XSAtIE9yaWdpbnMgb2YgY29tbW9uIHBoaXNoaW5nIHRhcmdldHMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdG9sZXJhbmNlXSAtIFRvbGVyYW5jZSB0byB1c2UgZm9yIHRoZSBmdXp6eWxpc3QgbGV2ZW5zaHRlaW4gbWF0Y2guXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBwaGlzaGluZyBkZXRlY3Rpb24uXG4gICAqXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IFBoaXNoaW5nRGV0ZWN0b3JDb25maWd1cmF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFthbGxvd2xpc3RdIC0gT3JpZ2lucyB0aGF0IHNob3VsZCBub3QgYmUgYmxvY2tlZC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2Jsb2NrbGlzdF0gLSBPcmlnaW5zIHRvIGJsb2NrLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbZnV6enlsaXN0XSAtIE9yaWdpbnMgb2YgY29tbW9uIHBoaXNoaW5nIHRhcmdldHMuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhpcyBjb25maWd1cmF0aW9uLiBVc2VkIHRvIGV4cGxhaW4gdG8gdXNlcnMgd2h5IGEgc2l0ZSBpcyBiZWluZyBibG9ja2VkLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3RvbGVyYW5jZV0gLSBUb2xlcmFuY2UgdG8gdXNlIGZvciB0aGUgZnV6enlsaXN0IGxldmVuc2h0ZWluIG1hdGNoLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2lvbiAtIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBwaGlzaGluZyBkZXRlY3Rvciwgd2hpY2ggY2FuIGNoZWNrIHdoZXRoZXIgb3JpZ2lucyBhcmUga25vd25cbiAgICogdG8gYmUgbWFsaWNpb3VzIG9yIHNpbWlsYXIgdG8gY29tbW9uIHBoaXNoaW5nIHRhcmdldHMuXG4gICAqXG4gICAqIEEgbGlzdCBvZiBjb25maWd1cmF0aW9ucyBpcyBhY2NlcHRlZC4gRWFjaCBvcmlnaW4gY2hlY2tlZCBpcyBwcm9jZXNzZWRcbiAgICogdXNpbmcgZWFjaCBjb25maWd1cmF0aW9uIGluIHNlcXVlbmNlLCBzbyB0aGUgb3JkZXIgZGVmaW5lcyB3aGljaFxuICAgKiBjb25maWd1cmF0aW9ucyB0YWtlIHByZWNlZGVuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TGVnYWN5UGhpc2hpbmdEZXRlY3RvckNvbmZpZ3VyYXRpb24gfCBQaGlzaGluZ0RldGVjdG9yQ29uZmlndXJhdGlvbltdfSBvcHRzIC0gUGhpc2hpbmcgZGV0ZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgLy8gcmVjb21tZW5kZWQgY29uZmlndXJhdGlvblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICB0aGlzLmNvbmZpZ3MgPSBwcm9jZXNzQ29uZmlncyhvcHRzKVxuICAgICAgdGhpcy5sZWdhY3lDb25maWcgPSBmYWxzZVxuICAgIC8vIGxlZ2FjeSBjb25maWd1cmF0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uZmlncyA9IFt7XG4gICAgICAgIGFsbG93bGlzdDogcHJvY2Vzc0RvbWFpbkxpc3Qob3B0cy53aGl0ZWxpc3QgfHwgW10pLFxuICAgICAgICBibG9ja2xpc3Q6IHByb2Nlc3NEb21haW5MaXN0KG9wdHMuYmxhY2tsaXN0IHx8IFtdKSxcbiAgICAgICAgZnV6enlsaXN0OiBwcm9jZXNzRG9tYWluTGlzdChvcHRzLmZ1enp5bGlzdCB8fCBbXSksXG4gICAgICAgIHRvbGVyYW5jZTogKCd0b2xlcmFuY2UnIGluIG9wdHMpID8gb3B0cy50b2xlcmFuY2UgOiBERUZBVUxUX1RPTEVSQU5DRVxuICAgICAgfV1cbiAgICAgIHRoaXMubGVnYWN5Q29uZmlnID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGNoZWNrKGRvbWFpbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NoZWNrKGRvbWFpbilcblxuICAgIGlmICh0aGlzLmxlZ2FjeUNvbmZpZykge1xuICAgICAgbGV0IGxlZ2FjeVR5cGUgPSByZXN1bHQudHlwZTtcbiAgICAgIGlmIChsZWdhY3lUeXBlID09PSAnYWxsb3dsaXN0Jykge1xuICAgICAgICBsZWdhY3lUeXBlID0gJ3doaXRlbGlzdCdcbiAgICAgIH0gZWxzZSBpZiAobGVnYWN5VHlwZSA9PT0gJ2Jsb2NrbGlzdCcpIHtcbiAgICAgICAgbGVnYWN5VHlwZSA9ICdibGFja2xpc3QnXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaDogcmVzdWx0Lm1hdGNoLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdC5yZXN1bHQsXG4gICAgICAgIHR5cGU6IGxlZ2FjeVR5cGUsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIF9jaGVjayAoZG9tYWluKSB7XG4gICAgbGV0IGZxZG4gPSBkb21haW4uc3Vic3RyaW5nKGRvbWFpbi5sZW5ndGggLSAxKSA9PT0gXCIuXCJcbiAgICAgID8gZG9tYWluLnNsaWNlKDAsIC0xKVxuICAgICAgOiBkb21haW47XG5cbiAgICBjb25zdCBzb3VyY2UgPSBkb21haW5Ub1BhcnRzKGZxZG4pXG5cbiAgICBmb3IgKGNvbnN0IHsgYWxsb3dsaXN0LCBuYW1lLCB2ZXJzaW9uIH0gb2YgdGhpcy5jb25maWdzKSB7XG4gICAgICAvLyBpZiBzb3VyY2UgbWF0Y2hlcyB3aGl0ZWxpc3QgZG9tYWluIChvciBzdWJkb21haW4gdGhlcmVvZiksIFBBU1NcbiAgICAgIGNvbnN0IHdoaXRlbGlzdE1hdGNoID0gbWF0Y2hQYXJ0c0FnYWluc3RMaXN0KHNvdXJjZSwgYWxsb3dsaXN0KVxuICAgICAgaWYgKHdoaXRlbGlzdE1hdGNoKSByZXR1cm4geyBuYW1lLCByZXN1bHQ6IGZhbHNlLCB0eXBlOiAnYWxsb3dsaXN0JywgdmVyc2lvbiB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IGJsb2NrbGlzdCwgZnV6enlsaXN0LCBuYW1lLCB0b2xlcmFuY2UsIHZlcnNpb24gfSBvZiB0aGlzLmNvbmZpZ3MpIHtcbiAgICAgIC8vIGlmIHNvdXJjZSBtYXRjaGVzIGJsYWNrbGlzdCBkb21haW4gKG9yIHN1YmRvbWFpbiB0aGVyZW9mKSwgRkFJTFxuICAgICAgY29uc3QgYmxhY2tsaXN0TWF0Y2ggPSBtYXRjaFBhcnRzQWdhaW5zdExpc3Qoc291cmNlLCBibG9ja2xpc3QpXG4gICAgICBpZiAoYmxhY2tsaXN0TWF0Y2gpIHJldHVybiB7IG5hbWUsIHJlc3VsdDogdHJ1ZSwgdHlwZTogJ2Jsb2NrbGlzdCcsIHZlcnNpb24gfVxuXG4gICAgICBpZiAodG9sZXJhbmNlID4gMCkge1xuICAgICAgICAvLyBjaGVjayBpZiBuZWFyLW1hdGNoIG9mIHdoaXRlbGlzdCBkb21haW4sIEZBSUxcbiAgICAgICAgbGV0IGZ1enp5Rm9ybSA9IGRvbWFpblBhcnRzVG9GdXp6eUZvcm0oc291cmNlKVxuICAgICAgICAvLyBzdHJpcCB3d3dcbiAgICAgICAgZnV6enlGb3JtID0gZnV6enlGb3JtLnJlcGxhY2UoJ3d3dy4nLCAnJylcbiAgICAgICAgLy8gY2hlY2sgYWdhaW5zdCBmdXp6eWxpc3RcbiAgICAgICAgY29uc3QgbGV2ZW5zaHRlaW5NYXRjaGVkID0gZnV6enlsaXN0LmZpbmQoKHRhcmdldFBhcnRzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZnV6enlUYXJnZXQgPSBkb21haW5QYXJ0c1RvRnV6enlGb3JtKHRhcmdldFBhcnRzKVxuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbGV2ZW5zaHRlaW4uZ2V0KGZ1enp5Rm9ybSwgZnV6enlUYXJnZXQpXG4gICAgICAgICAgcmV0dXJuIGRpc3RhbmNlIDw9IHRvbGVyYW5jZVxuICAgICAgICB9KVxuICAgICAgICBpZiAobGV2ZW5zaHRlaW5NYXRjaGVkKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBkb21haW5QYXJ0c1RvRG9tYWluKGxldmVuc2h0ZWluTWF0Y2hlZClcbiAgICAgICAgICByZXR1cm4geyBuYW1lLCBtYXRjaCwgcmVzdWx0OiB0cnVlLCB0eXBlOiAnZnV6enknLCB2ZXJzaW9uIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1hdGNoZWQgbm90aGluZywgUEFTU1xuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHR5cGU6ICdhbGwnIH1cbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGhpc2hpbmdEZXRlY3RvclxuXG4vLyB1dGlsXG5cbmZ1bmN0aW9uIHByb2Nlc3NDb25maWdzKGNvbmZpZ3MgPSBbXSkge1xuICByZXR1cm4gY29uZmlncy5tYXAoKGNvbmZpZykgPT4ge1xuICAgIHZhbGlkYXRlQ29uZmlnKGNvbmZpZylcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICBhbGxvd2xpc3Q6IHByb2Nlc3NEb21haW5MaXN0KGNvbmZpZy5hbGxvd2xpc3QgfHwgW10pLFxuICAgICAgYmxvY2tsaXN0OiBwcm9jZXNzRG9tYWluTGlzdChjb25maWcuYmxvY2tsaXN0IHx8IFtdKSxcbiAgICAgIGZ1enp5bGlzdDogcHJvY2Vzc0RvbWFpbkxpc3QoY29uZmlnLmZ1enp5bGlzdCB8fCBbXSksXG4gICAgICB0b2xlcmFuY2U6ICgndG9sZXJhbmNlJyBpbiBjb25maWcpID8gY29uZmlnLnRvbGVyYW5jZSA6IERFRkFVTFRfVE9MRVJBTkNFXG4gICAgfSlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSBudWxsIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbmZpZycpXG4gIH1cblxuICBpZiAoY29uZmlnLnRvbGVyYW5jZSAmJiAhY29uZmlnLmZ1enp5bGlzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnV6enlsaXN0IHRvbGVyYW5jZSBwcm92aWRlZCB3aXRob3V0IGZ1enp5bGlzdCcpXG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIGNvbmZpZy5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgIGNvbmZpZy5uYW1lID09PSAnJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZyBwYXJhbWV0ZXI6ICduYW1lJ1wiKVxuICB9XG5cbiAgaWYgKFxuICAgICFbJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlb2YgY29uZmlnLnZlcnNpb24pIHx8XG4gICAgY29uZmlnLnZlcnNpb24gPT09ICcnXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlnIHBhcmFtZXRlcjogJ3ZlcnNpb24nXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0RvbWFpbkxpc3QgKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubWFwKGRvbWFpblRvUGFydHMpXG59XG5cbmZ1bmN0aW9uIGRvbWFpblRvUGFydHMgKGRvbWFpbikge1xuICB0cnkge1xuICByZXR1cm4gZG9tYWluLnNwbGl0KCcuJykucmV2ZXJzZSgpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZG9tYWluKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21haW5QYXJ0c1RvRG9tYWluKGRvbWFpblBhcnRzKSB7XG4gIHJldHVybiBkb21haW5QYXJ0cy5zbGljZSgpLnJldmVyc2UoKS5qb2luKCcuJylcbn1cblxuLy8gZm9yIGZ1enp5IHNlYXJjaCwgZHJvcCBUTEQgYW5kIHJlLXN0cmluZ2lmeVxuZnVuY3Rpb24gZG9tYWluUGFydHNUb0Z1enp5Rm9ybShkb21haW5QYXJ0cykge1xuICByZXR1cm4gZG9tYWluUGFydHMuc2xpY2UoMSkucmV2ZXJzZSgpLmpvaW4oJy4nKVxufVxuXG4vLyBtYXRjaCB0aGUgdGFyZ2V0IHBhcnRzLCBpZ25vcmluZyBleHRyYSBzdWJkb21haW5zIG9uIHNvdXJjZVxuLy8gICBzb3VyY2U6IFtpbywgbWV0YW1hc2ssIHh5el1cbi8vICAgdGFyZ2V0OiBbaW8sIG1ldGFtYXNrXVxuLy8gICByZXN1bHQ6IFBBU1NcbmZ1bmN0aW9uIG1hdGNoUGFydHNBZ2FpbnN0TGlzdChzb3VyY2UsIGxpc3QpIHtcbiAgcmV0dXJuIGxpc3Quc29tZSgodGFyZ2V0KSA9PiB7XG4gICAgLy8gdGFyZ2V0IGRvbWFpbiBoYXMgbW9yZSBwYXJ0cyB0aGFuIHNvdXJjZSwgZmFpbFxuICAgIGlmICh0YXJnZXQubGVuZ3RoID4gc291cmNlLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgLy8gc291cmNlIG1hdGNoZXMgdGFyZ2V0IG9yIChpcyBkZWVwZXIgc3ViZG9tYWluKVxuICAgIHJldHVybiB0YXJnZXQuZXZlcnkoKHBhcnQsIGluZGV4KSA9PiBzb3VyY2VbaW5kZXhdID09PSBwYXJ0KVxuICB9KVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0ID0gZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSBleHBvcnRzLnNpZ25UeXBlZERhdGFfdjQgPSBleHBvcnRzLnNpZ25UeXBlZERhdGEgPSBleHBvcnRzLnJlY292ZXJUeXBlZE1lc3NhZ2UgPSBleHBvcnRzLnNpZ25UeXBlZE1lc3NhZ2UgPSBleHBvcnRzLmdldEVuY3J5cHRpb25QdWJsaWNLZXkgPSBleHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBleHBvcnRzLmRlY3J5cHQgPSBleHBvcnRzLmVuY3J5cHRTYWZlbHkgPSBleHBvcnRzLmVuY3J5cHQgPSBleHBvcnRzLnJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeSA9IGV4cG9ydHMuc2lnblR5cGVkRGF0YUxlZ2FjeSA9IGV4cG9ydHMudHlwZWRTaWduYXR1cmVIYXNoID0gZXhwb3J0cy5leHRyYWN0UHVibGljS2V5ID0gZXhwb3J0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSBleHBvcnRzLnBlcnNvbmFsU2lnbiA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5jb25jYXRTaWcgPSBleHBvcnRzLlR5cGVkRGF0YVV0aWxzID0gZXhwb3J0cy5UWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHZvaWQgMDtcbmNvbnN0IGV0aFV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKSk7XG5jb25zdCBldGhBYmkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImV0aGVyZXVtanMtYWJpXCIpKTtcbmNvbnN0IG5hY2wgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInR3ZWV0bmFjbFwiKSk7XG5jb25zdCBuYWNsVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHdlZXRuYWNsLXV0aWxcIikpO1xuY29uc3QgVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICBtZXNzYWdlOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgfSxcbiAgICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufTtcbmV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSBUWVBFRF9NRVNTQUdFX1NDSEVNQTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgZm9yIHNpZ25pbmcgdHlwZWQgZGF0YVxuICovXG5jb25zdCBUeXBlZERhdGFVdGlscyA9IHtcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIG9iamVjdCBieSBlbmNvZGluZyBhbmQgY29uY2F0ZW5hdGluZyBlYWNoIG9mIGl0cyBtZW1iZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gLSBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdFxuICAgICAqL1xuICAgIGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ107XG4gICAgICAgIGNvbnN0IGVuY29kZWRWYWx1ZXMgPSBbdGhpcy5oYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpXTtcbiAgICAgICAgaWYgKHVzZVY0KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVGaWVsZCA9IChuYW1lLCB0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV0aFV0aWwua2VjY2FrKHRoaXMuZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSwgdHlwZXMsIHVzZVY0KSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgZmllbGQgJHtuYW1lfSBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIgLSBwcmV2ZW50cyBldGhVdGlsIGZyb20gaW50ZXJwcmV0aW5nIHN0cmluZ3MgbGlrZSAnMHhhYmNkJyBhcyBoZXhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlVmFsdWVQYWlycyA9IHZhbHVlLm1hcCgoaXRlbSkgPT4gZW5jb2RlRmllbGQobmFtZSwgcGFyc2VkVHlwZSwgaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2J5dGVzMzInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXRoVXRpbC5rZWNjYWsoZXRoQWJpLnJhd0VuY29kZSh0eXBlVmFsdWVQYWlycy5tYXAoKFt0XSkgPT4gdCksIHR5cGVWYWx1ZVBhaXJzLm1hcCgoWywgdl0pID0+IHYpKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdmFsdWVdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0pO1xuICAgICAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIgLSBwcmV2ZW50cyBldGhVdGlsIGZyb20gaW50ZXJwcmV0aW5nIHN0cmluZ3MgbGlrZSAnMHhhYmNkJyBhcyBoZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1tmaWVsZC50eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCgnYnl0ZXMzMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEoZmllbGQudHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC50eXBlLmxhc3RJbmRleE9mKCddJykgPT09IGZpZWxkLnR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgYXJlIHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YTsgdXNlIFY0IGV4dGVuc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goZmllbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldGhBYmkucmF3RW5jb2RlKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBieSBlbmNvZGluZyBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIGl0cyBtZW1iZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKi9cbiAgICBlbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGxldCBkZXBzID0gdGhpcy5maW5kVHlwZURlcGVuZGVuY2llcyhwcmltYXJ5VHlwZSwgdHlwZXMpLmZpbHRlcigoZGVwKSA9PiBkZXAgIT09IHByaW1hcnlUeXBlKTtcbiAgICAgICAgZGVwcyA9IFtwcmltYXJ5VHlwZV0uY29uY2F0KGRlcHMuc29ydCgpKTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHlwZXNbdHlwZV07XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXVxuICAgICAgICAgICAgICAgIC5tYXAoKHsgbmFtZSwgdHlwZTogdCB9KSA9PiBgJHt0fSAke25hbWV9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCcpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgdHlwZXMgd2l0aGluIGEgdHlwZSBkZWZpbml0aW9uIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdHMgLSBjdXJyZW50IHNldCBvZiBhY2N1bXVsYXRlZCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBTZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBmaW5kVHlwZURlcGVuZGVuY2llcyhwcmltYXJ5VHlwZSwgdHlwZXMsIHJlc3VsdHMgPSBbXSkge1xuICAgICAgICBbcHJpbWFyeVR5cGVdID0gcHJpbWFyeVR5cGUubWF0Y2goL15cXHcqL3UpO1xuICAgICAgICBpZiAocmVzdWx0cy5pbmNsdWRlcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMucHVzaChwcmltYXJ5VHlwZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKSkge1xuICAgICAgICAgICAgICAgICFyZXN1bHRzLmluY2x1ZGVzKGRlcCkgJiYgcmVzdWx0cy5wdXNoKGRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBIYXNoZXMgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBoYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IC0gSGFzaCBvZiBhbiBvYmplY3RcbiAgICAgKi9cbiAgICBoYXNoU3RydWN0KHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSGFzaGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlIHRvIGhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgICAqL1xuICAgIGhhc2hUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgICAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0eXBlZCBtZXNzYWdlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzXG4gICAgICovXG4gICAgc2FuaXRpemVEYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBUWVBFRF9NRVNTQUdFX1NDSEVNQS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgndHlwZXMnIGluIHNhbml0aXplZERhdGEpIHtcbiAgICAgICAgICAgIHNhbml0aXplZERhdGEudHlwZXMgPSBPYmplY3QuYXNzaWduKHsgRUlQNzEyRG9tYWluOiBbXSB9LCBzYW5pdGl6ZWREYXRhLnR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FuaXRpemVkRGF0YTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgdHlwZWQgbWVzc2FnZSBhcyBwZXIgRUlQLTcxMiBhbmQgcmV0dXJucyBpdHMga2VjY2FrIGhhc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZERhdGEgLSBUeXBlcyBtZXNzYWdlIGRhdGEgdG8gc2lnblxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IC0ga2VjY2FrIGhhc2ggb2YgdGhlIHJlc3VsdGluZyBzaWduZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIHNpZ24odHlwZWREYXRhLCB1c2VWNCA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHRoaXMuc2FuaXRpemVEYXRhKHR5cGVkRGF0YSk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW0J1ZmZlci5mcm9tKCcxOTAxJywgJ2hleCcpXTtcbiAgICAgICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIHNhbml0aXplZERhdGEuZG9tYWluLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpO1xuICAgICAgICBpZiAoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSAhPT0gJ0VJUDcxMkRvbWFpbicpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5oYXNoU3RydWN0KHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUsIHNhbml0aXplZERhdGEubWVzc2FnZSwgc2FuaXRpemVkRGF0YS50eXBlcywgdXNlVjQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsoQnVmZmVyLmNvbmNhdChwYXJ0cykpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5UeXBlZERhdGFVdGlscyA9IFR5cGVkRGF0YVV0aWxzO1xuZnVuY3Rpb24gY29uY2F0U2lnKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpO1xuICAgIGNvbnN0IHNTaWcgPSBldGhVdGlsLmZyb21TaWduZWQocyk7XG4gICAgY29uc3QgdlNpZyA9IGV0aFV0aWwuYnVmZmVyVG9JbnQodik7XG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKGV0aFV0aWwudG9VbnNpZ25lZChzU2lnKS50b1N0cmluZygnaGV4JyksIDY0KTtcbiAgICBjb25zdCB2U3RyID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeChldGhVdGlsLmludFRvSGV4KHZTaWcpKTtcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKTtcbn1cbmV4cG9ydHMuY29uY2F0U2lnID0gY29uY2F0U2lnO1xuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBldGhVdGlsLnRvQnVmZmVyKGlucHV0KTtcbiAgICAgICAgaW5wdXQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nO1xuICAgICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeChpbnB1dC50b0xvd2VyQ2FzZSgpKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZnVuY3Rpb24gcGVyc29uYWxTaWduKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZyA9IGV0aFV0aWwuZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KGNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5leHBvcnRzLnBlcnNvbmFsU2lnbiA9IHBlcnNvbmFsU2lnbjtcbmZ1bmN0aW9uIHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZShtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKTtcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHNlbmRlckhleCA9IGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbiAgICByZXR1cm4gc2VuZGVySGV4O1xufVxuZXhwb3J0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSByZWNvdmVyUGVyc29uYWxTaWduYXR1cmU7XG5mdW5jdGlvbiBleHRyYWN0UHVibGljS2V5KG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihtc2dQYXJhbXMpO1xuICAgIHJldHVybiBgMHgke3B1YmxpY0tleS50b1N0cmluZygnaGV4Jyl9YDtcbn1cbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4dHJhY3RQdWJsaWNLZXk7XG5mdW5jdGlvbiBleHRlcm5hbFR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoaGFzaEJ1ZmZlcik7XG59XG5leHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IGV4dGVybmFsVHlwZWRTaWduYXR1cmVIYXNoO1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YUxlZ2FjeShwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChjb25jYXRTaWcoc2lnLnYsIHNpZy5yLCBzaWcucykpO1xufVxuZXhwb3J0cy5zaWduVHlwZWREYXRhTGVnYWN5ID0gc2lnblR5cGVkRGF0YUxlZ2FjeTtcbmZ1bmN0aW9uIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpO1xuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlTGVnYWN5ID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlTGVnYWN5O1xuZnVuY3Rpb24gZW5jcnlwdChyZWNlaXZlclB1YmxpY0tleSwgbXNnUGFyYW1zLCB2ZXJzaW9uKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbXNnUGFyYW1zLmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0ZWN0IHNlY3JldCBtZXNzYWdlLCBtZXNzYWdlIHBhcmFtcyBzaG91bGQgYmUgb2YgdGhlIGZvcm0ge2RhdGE6IFwic2VjcmV0IG1lc3NhZ2VcIn0gJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBlcGhlbWVyYWwga2V5cGFpclxuICAgICAgICAgICAgY29uc3QgZXBoZW1lcmFsS2V5UGFpciA9IG5hY2wuYm94LmtleVBhaXIoKTtcbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGVuY3J5cHRpb24gcGFyYW1ldGVycyAtIGZyb20gc3RyaW5nIHRvIFVJbnQ4XG4gICAgICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHViS2V5VUludDhBcnJheSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChyZWNlaXZlclB1YmxpY0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcHVibGljIGtleScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXNnUGFyYW1zVUludDhBcnJheSA9IG5hY2xVdGlsLmRlY29kZVVURjgobXNnUGFyYW1zLmRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveChtc2dQYXJhbXNVSW50OEFycmF5LCBub25jZSwgcHViS2V5VUludDhBcnJheSwgZXBoZW1lcmFsS2V5UGFpci5zZWNyZXRLZXkpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGVuY3J5cHRlZCBkYXRhXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNScsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgICAgICAgICAgZXBoZW1QdWJsaWNLZXk6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogbmFjbFV0aWwuZW5jb2RlQmFzZTY0KGVuY3J5cHRlZE1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJldHVybiBlbmNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGVuY3J5cHQ7XG5mdW5jdGlvbiBlbmNyeXB0U2FmZWx5KHJlY2VpdmVyUHVibGljS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24pIHtcbiAgICBjb25zdCBERUZBVUxUX1BBRERJTkdfTEVOR1RIID0gMiAqKiAxMTtcbiAgICBjb25zdCBOQUNMX0VYVFJBX0JZVEVTID0gMTY7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBtc2dQYXJhbXM7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgZW1wdHkgbXNnLmRhdGEnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAndG9KU09OJyBpbiBkYXRhKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgICAvLyBUT0RPLCBjaGVjayBhbGwgcG9zc2libGUgY2hpbGRyZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCB3aXRoIHRvSlNPTiBwcm9wZXJ0eS4gIFBsZWFzZSByZW1vdmUgdG9KU09OIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYWRkaW5nOiAnJyxcbiAgICB9O1xuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpO1xuICAgIGNvbnN0IG1vZFZhbCA9IGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIO1xuICAgIGxldCBwYWRMZW5ndGggPSAwO1xuICAgIC8vIE9ubHkgcGFkIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChtb2RWYWwgPiAwKSB7XG4gICAgICAgIHBhZExlbmd0aCA9IERFRkFVTFRfUEFERElOR19MRU5HVEggLSBtb2RWYWwgLSBOQUNMX0VYVFJBX0JZVEVTOyAvLyBuYWNsIGV4dHJhIGJ5dGVzXG4gICAgfVxuICAgIGRhdGFXaXRoUGFkZGluZy5wYWRkaW5nID0gJzAnLnJlcGVhdChwYWRMZW5ndGgpO1xuICAgIGNvbnN0IHBhZGRlZE1zZ1BhcmFtcyA9IHsgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKSB9O1xuICAgIHJldHVybiBlbmNyeXB0KHJlY2VpdmVyUHVibGljS2V5LCBwYWRkZWRNc2dQYXJhbXMsIHZlcnNpb24pO1xufVxuZXhwb3J0cy5lbmNyeXB0U2FmZWx5ID0gZW5jcnlwdFNhZmVseTtcbmZ1bmN0aW9uIGRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAgICAgLy8gc3RyaW5nIHRvIGJ1ZmZlciB0byBVSW50OEFycmF5XG4gICAgICAgICAgICBjb25zdCByZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbF9kZWNvZGVIZXgocmVjZWl2ZXJQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSkuc2VjcmV0S2V5O1xuICAgICAgICAgICAgLy8gYXNzZW1ibGUgZGVjcnlwdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLm5vbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQoZW5jcnlwdGVkRGF0YS5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpO1xuICAgICAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIGVwaGVtUHVibGljS2V5LCByZWNpZXZlckVuY3J5cHRpb25Qcml2YXRlS2V5KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBkZWNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG5hY2xVdGlsLmVuY29kZVVURjgoZGVjcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG5mdW5jdGlvbiBkZWNyeXB0U2FmZWx5KGVuY3J5cHRlZERhdGEsIHJlY2VpdmVyUHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IEpTT04ucGFyc2UoZGVjcnlwdChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpKTtcbiAgICByZXR1cm4gZGF0YVdpdGhQYWRkaW5nLmRhdGE7XG59XG5leHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBkZWNyeXB0U2FmZWx5O1xuZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleVVpbnQ4QXJyYXkgPSBuYWNsX2RlY29kZUhleChwcml2YXRlS2V5KTtcbiAgICBjb25zdCBlbmNyeXB0aW9uUHVibGljS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlVaW50OEFycmF5KS5wdWJsaWNLZXk7XG4gICAgcmV0dXJuIG5hY2xVdGlsLmVuY29kZUJhc2U2NChlbmNyeXB0aW9uUHVibGljS2V5KTtcbn1cbmV4cG9ydHMuZ2V0RW5jcnlwdGlvblB1YmxpY0tleSA9IGdldEVuY3J5cHRpb25QdWJsaWNLZXk7XG4vKipcbiAqIEEgZ2VuZXJpYyBlbnRyeSBwb2ludCBmb3IgYWxsIHR5cGVkIGRhdGEgbWV0aG9kcyB0byBiZSBwYXNzZWQsIGluY2x1ZGVzIGEgdmVyc2lvbiBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIHNpZ25UeXBlZE1lc3NhZ2UocHJpdmF0ZUtleSwgbXNnUGFyYW1zLCB2ZXJzaW9uID0gJ1Y0Jykge1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlICdWMSc6XG4gICAgICAgICAgICByZXR1cm4gc2lnblR5cGVkRGF0YUxlZ2FjeShwcml2YXRlS2V5LCBtc2dQYXJhbXMpO1xuICAgICAgICBjYXNlICdWMyc6XG4gICAgICAgICAgICByZXR1cm4gc2lnblR5cGVkRGF0YShwcml2YXRlS2V5LCBtc2dQYXJhbXMpO1xuICAgICAgICBjYXNlICdWNCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc2lnblR5cGVkRGF0YV92NChwcml2YXRlS2V5LCBtc2dQYXJhbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuc2lnblR5cGVkTWVzc2FnZSA9IHNpZ25UeXBlZE1lc3NhZ2U7XG5mdW5jdGlvbiByZWNvdmVyVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgdmVyc2lvbiA9ICdWNCcpIHtcbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAnVjEnOlxuICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpO1xuICAgICAgICBjYXNlICdWMyc6XG4gICAgICAgICAgICByZXR1cm4gcmVjb3ZlclR5cGVkU2lnbmF0dXJlKG1zZ1BhcmFtcyk7XG4gICAgICAgIGNhc2UgJ1Y0JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQobXNnUGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLnJlY292ZXJUeXBlZE1lc3NhZ2UgPSByZWNvdmVyVHlwZWRNZXNzYWdlO1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YShwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSwgZmFsc2UpO1xuICAgIGNvbnN0IHNpZyA9IGV0aFV0aWwuZWNzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpO1xuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSk7XG59XG5leHBvcnRzLnNpZ25UeXBlZERhdGEgPSBzaWduVHlwZWREYXRhO1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YV92NChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSk7XG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKTtcbn1cbmV4cG9ydHMuc2lnblR5cGVkRGF0YV92NCA9IHNpZ25UeXBlZERhdGFfdjQ7XG5mdW5jdGlvbiByZWNvdmVyVHlwZWRTaWduYXR1cmUobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UsIG1zZ1BhcmFtcy5zaWcpO1xuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlO1xuZnVuY3Rpb24gcmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0KG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBUeXBlZERhdGFVdGlscy5zaWduKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UsIG1zZ1BhcmFtcy5zaWcpO1xuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0ID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0O1xuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpO1xuICAgIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhKCdsZW5ndGgnIGluIHR5cGVkRGF0YSkgfHxcbiAgICAgICAgIXR5cGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdieXRlcycgPyBldGhVdGlsLnRvQnVmZmVyKGUudmFsdWUpIDogZS52YWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudHlwZTtcbiAgICB9KTtcbiAgICBjb25zdCBzY2hlbWEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gO1xuICAgIH0pO1xuICAgIHJldHVybiBldGhBYmkuc29saWRpdHlTSEEzKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtcbiAgICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyhuZXcgQXJyYXkodHlwZWREYXRhLmxlbmd0aCkuZmlsbCgnc3RyaW5nJyksIHNjaGVtYSksXG4gICAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTModHlwZXMsIGRhdGEpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShoYXNoLCBzaWcpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBldGhVdGlsLnRvQnVmZmVyKHNpZyk7XG4gICAgY29uc3Qgc2lnUGFyYW1zID0gZXRoVXRpbC5mcm9tUnBjU2lnKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuZWNyZWNvdmVyKGhhc2gsIHNpZ1BhcmFtcy52LCBzaWdQYXJhbXMuciwgc2lnUGFyYW1zLnMpO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpO1xufVxuZnVuY3Rpb24gcGFkV2l0aFplcm9lcyhudW1iZXIsIGxlbmd0aCkge1xuICAgIGxldCBteVN0cmluZyA9IGAke251bWJlcn1gO1xuICAgIHdoaWxlIChteVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgbXlTdHJpbmcgPSBgMCR7bXlTdHJpbmd9YDtcbiAgICB9XG4gICAgcmV0dXJuIG15U3RyaW5nO1xufVxuLy8gY29udmVydHMgaGV4IHN0cmluZ3MgdG8gdGhlIFVpbnQ4QXJyYXkgZm9ybWF0IHVzZWQgYnkgbmFjbFxuZnVuY3Rpb24gbmFjbF9kZWNvZGVIZXgobXNnSGV4KSB7XG4gICAgY29uc3QgbXNnQmFzZTY0ID0gQnVmZmVyLmZyb20obXNnSGV4LCAnaGV4JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJldHVybiBuYWNsVXRpbC5kZWNvZGVCYXNlNjQobXNnQmFzZTY0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gY3JlYXRlSGFzaEZ1bmN0aW9uKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBoYXNoID0gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGhhc2gudXBkYXRlKG1zZyk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVIYXNoRnVuY3Rpb24gPSBjcmVhdGVIYXNoRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhc2hfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2hhc2gtdXRpbHNcIik7XG52YXIgY3JlYXRlS2VjY2FrSGFzaCA9IHJlcXVpcmUoXCJrZWNjYWtcIik7XG5leHBvcnRzLmtlY2NhazIyNCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMjI0XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazI1NiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMjU2XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazM4NCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMzg0XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazUxMiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrNTEyXCIpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKFwicmFuZG9tYnl0ZXNcIik7XG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhieXRlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJhbmRvbWJ5dGVzKGJ5dGVzLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFJhbmRvbUJ5dGVzID0gZ2V0UmFuZG9tQnl0ZXM7XG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlc1N5bmMoYnl0ZXMpIHtcbiAgICByZXR1cm4gcmFuZG9tYnl0ZXMoYnl0ZXMpO1xufVxuZXhwb3J0cy5nZXRSYW5kb21CeXRlc1N5bmMgPSBnZXRSYW5kb21CeXRlc1N5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJzZWNwMjU2azFcIik7XG52YXIgcmFuZG9tXzEgPSByZXF1aXJlKFwiLi9yYW5kb21cIik7XG52YXIgU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUgPSAzMjtcbmZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGs7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJhbmRvbV8xLmdldFJhbmRvbUJ5dGVzKFNFQ1AyNTZLMV9QUklWQVRFX0tFWV9TSVpFKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBwayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3AyNTZrMV8xLnByaXZhdGVLZXlWZXJpZnkocGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleSA9IGNyZWF0ZVByaXZhdGVLZXk7XG5mdW5jdGlvbiBjcmVhdGVQcml2YXRlS2V5U3luYygpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcGsgPSByYW5kb21fMS5nZXRSYW5kb21CeXRlc1N5bmMoU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUpO1xuICAgICAgICBpZiAoc2VjcDI1NmsxXzEucHJpdmF0ZUtleVZlcmlmeShwaykpIHtcbiAgICAgICAgICAgIHJldHVybiBwaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleVN5bmMgPSBjcmVhdGVQcml2YXRlS2V5U3luYztcbl9fZXhwb3J0KHJlcXVpcmUoXCJzZWNwMjU2azFcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJyksXG4gICAga2VjY2FrMjI0ID0gX3JlcXVpcmUua2VjY2FrMjI0LFxuICAgIGtlY2NhazM4NCA9IF9yZXF1aXJlLmtlY2NhazM4NCxcbiAgICBrMjU2ID0gX3JlcXVpcmUua2VjY2FrMjU2LFxuICAgIGtlY2NhazUxMiA9IF9yZXF1aXJlLmtlY2NhazUxMjtcblxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWFkYXB0ZXInKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBybHAgPSByZXF1aXJlKCdybHAnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIHJlcXVpcmUoJ2V0aGpzLXV0aWwnKSk7XG5cbi8qKlxuICogdGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhpcyBWTSBjYW4gaGFuZGxlIChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IE1BWF9JTlRFR0VSXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG5cbi8qKlxuICogMl4yNTYgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gVFdPX1BPVzI1NlxuICovXG5leHBvcnRzLlRXT19QT1cyNTYgPSBuZXcgQk4oJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMTYpO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsIChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X05VTExfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSAnYzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCc7XG5leHBvcnRzLlNIQTNfTlVMTF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X05VTExcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X1JMUF9BUlJBWV9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gJzFkY2M0ZGU4ZGVjNzVkN2FhYjg1YjU2N2I2Y2NkNDFhZDMxMjQ1MWI5NDhhNzQxM2YwYTE0MmZkNDBkNDkzNDcnO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWV9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQX0FSUkFZXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgIChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X1JMUF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xuZXhwb3J0cy5TSEEzX1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFAgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFA7XG5cbi8qKlxuICogW2BCTmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuQk4gPSBCTjtcblxuLyoqXG4gKiBbYHJscGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscClcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLnJscCA9IHJscDtcblxuLyoqXG4gKiBbYHNlY3AyNTZrMWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvKVxuICogQHZhciB7T2JqZWN0fVxuICovXG5leHBvcnRzLnNlY3AyNTZrMSA9IHNlY3AyNTZrMTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIGZpbGxlZCB3aXRoIDBzXG4gKiBAbWV0aG9kIHplcm9zXG4gKiBAcGFyYW0ge051bWJlcn0gYnl0ZXMgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGJ1ZmZlciBzaG91bGQgYmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy56ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcblxuLyoqXG4gICogUmV0dXJucyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgemVyb0FkZHJlc3NcbiAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5leHBvcnRzLnplcm9BZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9zKGFkZHJlc3NMZW5ndGgpO1xuICByZXR1cm4gZXhwb3J0cy5idWZmZXJUb0hleCh6ZXJvQWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIExlZnQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAbWV0aG9kIGxzZXRMZW5ndGhcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtyaWdodD1mYWxzZV0gd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheX1cbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy5zZXRMZW5ndGggPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgsIHJpZ2h0KSB7XG4gIHZhciBidWYgPSBleHBvcnRzLnplcm9zKGxlbmd0aCk7XG4gIG1zZyA9IGV4cG9ydHMudG9CdWZmZXIobXNnKTtcbiAgaWYgKHJpZ2h0KSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gbXNnLnNsaWNlKDAsIGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJpZ2h0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheX1cbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICByZXR1cm4gZXhwb3J0cy5zZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcblxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYCBvciBhbiBgQXJyYXlgXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd9IGFcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheXxTdHJpbmd9XG4gKi9cbmV4cG9ydHMudW5wYWQgPSBleHBvcnRzLnN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhKTtcbiAgdmFyIGZpcnN0ID0gYVswXTtcbiAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICBhID0gYS5zbGljZSgxKTtcbiAgICBmaXJzdCA9IGFbMF07XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0cyBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHsqfSB2IHRoZSB2YWx1ZVxuICovXG5leHBvcnRzLnRvQnVmZmVyID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20oZXhwb3J0cy5wYWRUb0V2ZW4oZXhwb3J0cy5zdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgdiA9IGV4cG9ydHMuaW50VG9CdWZmZXIodik7XG4gICAgfSBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICB9IGVsc2UgaWYgKEJOLmlzQk4odikpIHtcbiAgICAgIHYgPSB2LnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmBcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9JbnQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBuZXcgQk4oZXhwb3J0cy50b0J1ZmZlcihidWYpKS50b051bWJlcigpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgYnVmID0gZXhwb3J0cy50b0J1ZmZlcihidWYpO1xuICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuXG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbnVtXG4gKiBAcmV0dXJuIHtCTn1cbiAqL1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbmV3IEJOKG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQk5gIHRvIGFuIHVuc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgaXQgYXMgYSBgQnVmZmVyYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0ge0JOfSBudW1cbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy50b1Vuc2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20obnVtLnRvVHdvcygyNTYpLnRvQXJyYXkoKSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgS2VjY2FrIHdpZHRoXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrID0gZnVuY3Rpb24gKGEsIGJpdHMpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIGlmICghYml0cykgYml0cyA9IDI1NjtcblxuICBzd2l0Y2ggKGJpdHMpIHtcbiAgICBjYXNlIDIyNDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazIyNChhKTtcbiAgICAgIH1cbiAgICBjYXNlIDI1NjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGsyNTYoYSk7XG4gICAgICB9XG4gICAgY2FzZSAzODQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWszODQoYSk7XG4gICAgICB9XG4gICAgY2FzZSA1MTI6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWs1MTIoYSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgYWxnb3JpdGhtOiBrZWNjYWsnICsgYml0cyk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0LCBhbGlhcyBmb3Iga2VjY2FrKGEsIDI1NilcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoYSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgKEtlY2NhaykgaGFzaCBvZiB0aGUgaW5wdXQgW09CU09MRVRFXVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIFNIQS0zIHdpZHRoXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2hhMyA9IGV4cG9ydHMua2VjY2FrO1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhZGRlZCB3aGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgdmFyIGhhc2ggPSBjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG4gIGlmIChwYWRkZWQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5zZXRMZW5ndGgoaGFzaCwgMzIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNoO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgaGFzaCBvZiB0aGUgUkxQIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5ybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHJscC5lbmNvZGUoYSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByaXZhdGUga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHB1YmxpYyBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxXG4gKiBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiBFdGhlcmV1bS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgc2FuaXRpemUpIHtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY0KSB7XG4gICAgLy8gQ29udmVydCB0byBTRUMxIGZvciBzZWNwMjU2azFcbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gIH1cblxuICBpZiAoIXNhbml0aXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplKSB7XG4gIHB1YktleSA9IGV4cG9ydHMudG9CdWZmZXIocHViS2V5KTtcbiAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHViS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgYXNzZXJ0KHB1YktleS5sZW5ndGggPT09IDY0KTtcbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhwdWJLZXkpLnNsaWNlKC0yMCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIHB1YmxpYyBrZXkgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcHJpdmF0ZUtleSA9IGV4cG9ydHMudG9CdWZmZXIocHJpdmF0ZUtleSk7XG4gIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byB0aGUgRXRoZXJldW0gZm9ybWF0LlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgcHVibGljS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJsaWNLZXkpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gcHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBFQ0RTQSBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5lY3NpZ24gPSBmdW5jdGlvbiAobXNnSGFzaCwgcHJpdmF0ZUtleSkge1xuICB2YXIgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSk7XG5cbiAgdmFyIHJldCA9IHt9O1xuICByZXQuciA9IHNpZy5zaWduYXR1cmUuc2xpY2UoMCwgMzIpO1xuICByZXQucyA9IHNpZy5zaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgcmV0LnYgPSBzaWcucmVjb3ZlcnkgKyAyNztcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2VjY2FrLTI1NiBoYXNoIG9mIGBtZXNzYWdlYCwgcHJlZml4ZWQgd2l0aCB0aGUgaGVhZGVyIHVzZWQgYnkgdGhlIGBldGhfc2lnbmAgUlBDIGNhbGwuXG4gKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGZlZCBpbnRvIGBlY3NpZ25gIHRvIHByb2R1Y2UgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIHRoZSBgZXRoX3NpZ25gXG4gKiBjYWxsIGZvciBhIGdpdmVuIGBtZXNzYWdlYCwgb3IgZmVkIHRvIGBlY3JlY292ZXJgIGFsb25nIHdpdGggYSBzaWduYXR1cmUgdG8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICogdXNlZCB0byBwcm9kdWNlIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gbWVzc2FnZVxuICogQHJldHVybnMge0J1ZmZlcn0gaGFzaFxuICovXG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICB2YXIgcHJlZml4ID0gZXhwb3J0cy50b0J1ZmZlcignXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4nICsgbWVzc2FnZS5sZW5ndGgudG9TdHJpbmcoKSk7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IHB1YmxpY0tleVxuICovXG5leHBvcnRzLmVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzKSB7XG4gIHZhciBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFtleHBvcnRzLnNldExlbmd0aChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoKHMsIDMyKV0sIDY0KTtcbiAgdmFyIHJlY292ZXJ5ID0gdiAtIDI3O1xuICBpZiAocmVjb3ZlcnkgIT09IDAgJiYgcmVjb3ZlcnkgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgfVxuICB2YXIgc2VuZGVyUHViS2V5ID0gc2VjcDI1NmsxLnJlY292ZXIobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSk7XG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgYGV0aF9zaWduYCBSUEMgbWV0aG9kXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHNpZ1xuICovXG5leHBvcnRzLnRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMpIHtcbiAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlY292ZXJ5IGlkJyk7XG4gIH1cblxuICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAvLyBGSVhNRTogdGhpcyBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICByZXR1cm4gZXhwb3J0cy5idWZmZXJUb0hleChCdWZmZXIuY29uY2F0KFtleHBvcnRzLnNldExlbmd0aExlZnQociwgMzIpLCBleHBvcnRzLnNldExlbmd0aExlZnQocywgMzIpLCBleHBvcnRzLnRvQnVmZmVyKHYgLSAyNyldKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICBzaWcgPSBleHBvcnRzLnRvQnVmZmVyKHNpZyk7XG5cbiAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgaWYgKHNpZy5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhciB2ID0gc2lnWzY0XTtcbiAgLy8gc3VwcG9ydCBib3RoIHZlcnNpb25zIG9mIGBldGhfc2lnbmAgcmVzcG9uc2VzXG4gIGlmICh2IDwgMjcpIHtcbiAgICB2ICs9IDI3O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2OiB2LFxuICAgIHI6IHNpZy5zbGljZSgwLCAzMiksXG4gICAgczogc2lnLnNsaWNlKDMyLCA2NClcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MocHJpdmF0ZVRvUHVibGljKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvb1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICByZXR1cm4gKC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpXG4gICk7XG59O1xuXG4vKipcbiAgKiBDaGVja3MgaWYgYSBnaXZlbiBhZGRyZXNzIGlzIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCBpc1plcm9BZGRyZXNzXG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqL1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvQWRkcmVzcygpO1xuICByZXR1cm4gemVyb0FkZHJlc3MgPT09IGV4cG9ydHMuYWRkSGV4UHJlZml4KGFkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBoYXNoID0gZXhwb3J0cy5rZWNjYWsoYWRkcmVzcykudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgcmV0ID0gJzB4JztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VJbnQoaGFzaFtpXSwgMTYpID49IDgpIHtcbiAgICAgIHJldCArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7QnVmZmVyfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICByZXR1cm4gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSAmJiBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpID09PSBhZGRyZXNzO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3RcbiAqIEBwYXJhbSB7QnVmZmVyfSBmcm9tIHRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSB7QnVmZmVyfSBub25jZSB0aGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICBmcm9tID0gZXhwb3J0cy50b0J1ZmZlcihmcm9tKTtcbiAgbm9uY2UgPSBuZXcgQk4obm9uY2UpO1xuXG4gIGlmIChub25jZS5pc1plcm8oKSkge1xuICAgIC8vIGluIFJMUCB3ZSB3YW50IHRvIGVuY29kZSBudWxsIGluIHRoZSBjYXNlIG9mIHplcm8gbm9uY2VcbiAgICAvLyByZWFkIHRoZSBSTFAgZG9jdW1lbnRhdGlvbiBmb3IgYW4gYW5zd2VyIGlmIHlvdSBkYXJlXG4gICAgbm9uY2UgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vbmNlID0gQnVmZmVyLmZyb20obm9uY2UudG9BcnJheSgpKTtcbiAgfVxuXG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5ybHBoYXNoKFtmcm9tLCBub25jZV0pLnNsaWNlKC0yMCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3VwcGxpZWQgYWRkcmVzcyBiZWxvbmdzIHRvIGEgcHJlY29tcGlsZWQgYWNjb3VudCAoQnl6YW50aXVtKVxuICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzUHJlY29tcGlsZWQgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgYSA9IGV4cG9ydHMudW5wYWQoYWRkcmVzcyk7XG4gIHJldHVybiBhLmxlbmd0aCA9PT0gMSAmJiBhWzBdID49IDEgJiYgYVswXSA8PSA4O1xufTtcblxuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBFQ0RTQSBzaWduYXR1cmVcbiAqIEBtZXRob2QgaXNWYWxpZFNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHBhcmFtIHtCb29sZWFufSBbaG9tZXN0ZWFkPXRydWVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWQpIHtcbiAgdmFyIFNFQ1AyNTZLMV9OX0RJVl8yID0gbmV3IEJOKCc3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjVkNTc2ZTczNTdhNDUwMWRkZmU5MmY0NjY4MWIyMGEwJywgMTYpO1xuICB2YXIgU0VDUDI1NksxX04gPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnLCAxNik7XG5cbiAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByID0gbmV3IEJOKHIpO1xuICBzID0gbmV3IEJOKHMpO1xuXG4gIGlmIChyLmlzWmVybygpIHx8IHIuZ3QoU0VDUDI1NksxX04pIHx8IHMuaXNaZXJvKCkgfHwgcy5ndChTRUNQMjU2SzFfTikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaG9tZXN0ZWFkID09PSBmYWxzZSAmJiBuZXcgQk4ocykuY21wKFNFQ1AyNTZLMV9OX0RJVl8yKSA9PT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IGJhXG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd8bnVsbH1cbiAqL1xuZXhwb3J0cy5iYVRvSlNPTiA9IGZ1bmN0aW9uIChiYSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJhKSkge1xuICAgIHJldHVybiAnMHgnICsgYmEudG9TdHJpbmcoJ2hleCcpO1xuICB9IGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKGV4cG9ydHMuYmFUb0pTT04oYmFbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59O1xuXG4vKipcbiAqIERlZmluZXMgcHJvcGVydGllcyBvbiBhIGBPYmplY3RgLiBJdCBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgdW5kZXJseWluZyBkYXRhIGlzIGJpbmFyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIHRoZSBgT2JqZWN0YCB0byBkZWZpbmUgcHJvcGVydGllcyBvblxuICogQHBhcmFtIHtBcnJheX0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0geyp9IGRhdGEgZGF0YSB0byBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgZGVmaW5pdGlvbnNcbiAqL1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xuICBzZWxmLnJhdyA9IFtdO1xuICBzZWxmLl9maWVsZHMgPSBbXTtcblxuICAvLyBhdHRhY2ggdGhlIGB0b0pTT05gXG4gIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgb2JqW2ZpZWxkXSA9ICcweCcgKyBzZWxmW2ZpZWxkXS50b1N0cmluZygnaGV4Jyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmJhVG9KU09OKHRoaXMucmF3KTtcbiAgfTtcblxuICBzZWxmLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gcmxwLmVuY29kZShzZWxmLnJhdyk7XG4gIH07XG5cbiAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpKSB7XG4gICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgcmV0dXJuIHNlbGYucmF3W2ldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgdiA9IGV4cG9ydHMudG9CdWZmZXIodik7XG5cbiAgICAgIGlmICh2LnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwJyAmJiAhZmllbGQuYWxsb3daZXJvKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZC5hbGxvd0xlc3MgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIHYgPSBleHBvcnRzLnN0cmlwWmVyb3Modik7XG4gICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3Qgbm90IGhhdmUgbW9yZSAnICsgZmllbGQubGVuZ3RoICsgJyBieXRlcycpO1xuICAgICAgfSBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPT09IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IGhhdmUgYnl0ZSBsZW5ndGggb2YgJyArIGZpZWxkLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmF3W2ldID0gdjtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgc2V0OiBzZXR0ZXJcbiAgICB9KTtcblxuICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdDtcbiAgICB9XG5cbiAgICAvLyBhdHRhY2ggYWxpYXNcbiAgICBpZiAoZmllbGQuYWxpYXMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5hbGlhcywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgZ2V0OiBnZXR0ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaWYgdGhlIGNvbnN0dWN0b3IgaXMgcGFzc2VkIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZXhwb3J0cy5zdHJpcEhleFByZWZpeChkYXRhKSwgJ2hleCcpO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBybHAuZGVjb2RlKGRhdGEpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiBzZWxmLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgbnVtYmVyIG9mIGZpZWxkcyBpbiBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGl0ZW1zIGFyZSBidWZmZXJzXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgc2VsZltzZWxmLl9maWVsZHNbaV1dID0gZXhwb3J0cy50b0J1ZmZlcihkKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQubmFtZSkgIT09IC0xKSBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKSBzZWxmW2ZpZWxkLmFsaWFzXSA9IGRhdGFbZmllbGQuYWxpYXNdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRhJyk7XG4gICAgfVxuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEnKTtcblxuZnVuY3Rpb24gZ2V0U2VjcDI1NmsxICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9pbmRleCcpOyB9XG52YXIgZGVyID0gcmVxdWlyZSgnLi9zZWNwMjU2azEtbGliL2RlcicpO1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwcml2YXRlS2V5XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlWZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHJpdmF0ZUtleVZlcmlmeSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkge1xuICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiBwcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHNlY3AyNTZrMXYzID0gZ2V0U2VjcDI1NmsxKCk7XG4gIC8vIHByaXZhdGVLZXlFeHBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMXYzLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZCk7XG5cbiAgcmV0dXJuIGRlci5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCk7XG59O1xuXG4vKipcbiAqIEltcG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5SW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5cbnZhciBwcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KSB7XG4gIC8vIHByaXZhdGVLZXlJbXBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgcHJpdmF0ZUtleSA9IGRlci5wcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpO1xuICBpZiAocHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgcHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBwcml2YXRlS2V5O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgaW1wb3J0IGZyb20gREVSIGZvcm1hdFwiKTtcbn07XG5cbi8qKlxuICogTmVnYXRlIGEgcHJpdmF0ZUtleSBieSBzdWJ0cmFjdGluZyBpdCBmcm9tIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlOZWdhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5TmVnYXRlID0gZnVuY3Rpb24gcHJpdmF0ZUtleU5lZ2F0ZShwcml2YXRlS2V5KSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHByaXZhdGVLZXkgKG1vZHVsbyB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludCkuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlNb2RJbnZlcnNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiBwcml2YXRlS2V5TW9kSW52ZXJzZShwcml2YXRlS2V5KSB7XG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgdmFyIHNlY3AyNTZrMXYzID0gZ2V0U2VjcDI1NmsxKCk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5wcml2YXRlS2V5TW9kSW52ZXJzZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IGFkZGluZyB0d2VhayB0byBpdC5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiBwcml2YXRlS2V5VHdlYWtBZGQocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB0d2VhaykpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHByaXZhdGVLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2Vhay5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwcml2YXRlS2V5VHdlYWtNdWwocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZUtleS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q3JlYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHB1YmxpY0tleSB0byBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBmb3JtLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb252ZXJ0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbnZlcnQgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHB1YmxpY0tleS5cbiAqIEBtZXRob2QgcHVibGljS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gcHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSkge1xuICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwdWJsaWNLZXkgbGVuZ3RoIGlzIG5vdCAzMyBvciA2NVxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IGFkZGluZyB0d2VhayB0aW1lcyB0aGUgZ2VuZXJhdG9yIHRvIGl0LlxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHVibGljS2V5VHdlYWtBZGQocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsgdmFsdWVcbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtNdWxcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha011bCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrTXVsKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBnaXZlbiBwdWJsaWNLZXlzIHRvZ2V0aGVyLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb21iaW5lXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlcj59IHB1YmxpY0tleXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q29tYmluZSA9IGZ1bmN0aW9uIHB1YmxpY0tleUNvbWJpbmUocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBwdWJsaWNLZXlzLmZvckVhY2goZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIGtleXMucHVzaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG4gIH0pO1xuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShrZXlzLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduYXR1cmUgdG8gYSBub3JtYWxpemVkIGxvd2VyLVMgZm9ybS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlTm9ybWFsaXplXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVOb3JtYWxpemUgPSBmdW5jdGlvbiBzaWduYXR1cmVOb3JtYWxpemUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSBhbiBFQ0RTQSBzaWduYXR1cmUgaW4gREVSIGZvcm1hdC5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlRXhwb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVFeHBvcnQgPSBmdW5jdGlvbiBzaWduYXR1cmVFeHBvcnQoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAoZm9sbG93IGJ5IFtCSVA2Nl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2kpKS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlSW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiBzaWduYXR1cmVJbXBvcnQoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAobm90IGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydExheFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSkge1xuICAvLyBzaWduYXR1cmVJbXBvcnRMYXggbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgLy8gZW5zdXJlIHRoYXQgc2lnbmF0dXJlIGlzIGdyZWF0ZXIgdGhhbiAwXG4gIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpZ25hdHVyZSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG4gIHZhciBzZWNwMjU2azF2MyA9IGdldFNlY3AyNTZrMSgpO1xuXG4gIHZhciBzaWdPYmogPSBkZXIuc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSk7XG4gIGlmIChzaWdPYmogPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBwYXJzZSBERVIgc2lnbmF0dXJlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMXYzLnNpZ25hdHVyZUltcG9ydChzaWdPYmopO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRUNEU0Egc2lnbmF0dXJlLiBBbHdheXMgcmV0dXJuIGxvdy1TIHNpZ25hdHVyZS5cbiAqIEBtZXRob2Qgc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIE9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHNpZ25PcHRpb25zID0gdm9pZCAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc2lnbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXInKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBvcHRpb24uZGF0YSBsZW5ndGhcbiAgICAgIGlmIChvcHRpb25zLmRhdGEubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3B0aW9ucy5kYXRhIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25PcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgIC8vICBjb252ZXJ0IG9wdGlvbi5ub25jZWZuIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgc2lnbk9wdGlvbnMubm9uY2VmbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBhbGdvLCBkYXRhLCBhdHRlbXB0KSB7XG4gICAgICAgIHZhciBidWZmZXJBbGdvID0gYWxnbyAhPSBudWxsID8gQnVmZmVyLmZyb20oYWxnbykgOiBudWxsO1xuICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGEgIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGRhdGEpIDogbnVsbDtcblxuICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oJycpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICBidWZmZXIgPSBvcHRpb25zLm5vbmNlZm4oQnVmZmVyLmZyb20obWVzc2FnZSksIEJ1ZmZlci5mcm9tKHByaXZhdGVLZXkpLCBidWZmZXJBbGdvLCBidWZmZXJEYXRhLCBhdHRlbXB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5lY2RzYVNpZ24oVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHNpZ25PcHRpb25zKTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnNpZ25hdHVyZSksXG4gICAgcmVjb3Zlcnk6IHNpZy5yZWNpZFxuICB9O1xufTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0Egc2lnbmF0dXJlLlxuICogQG1ldGhvZCB2ZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgdmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2NCB2ZXJpZnkgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJlY292ZXIgYW4gRUNEU0EgcHVibGljIGtleSBmcm9tIGEgc2lnbmF0dXJlLlxuICogQG1ldGhvZCByZWNvdmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJlY2lkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHJlY292ZXIgPSBmdW5jdGlvbiByZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjaWQsIGNvbXByZXNzZWQpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHY0IHJlY292ZXIgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgcmVjaWQsIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgYXBwbGllZCBzaGEyNTYgdG8gY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICogQG1ldGhvZCBlY2RoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgZWNkaCA9IGZ1bmN0aW9uIGVjZGgocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2MyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIHBhcmFtZXRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZGgoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwge30pKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIHJldHVybiBwdWJsaWMga2V5IGFzIHJlc3VsdFxuICogQG1ldGhvZCBlY2RoVW5zYWZlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBlY2RoVW5zYWZlID0gZnVuY3Rpb24gZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgLy8gZWNkaFVuc2FmZSBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAvLyBlbnN1cmUgdmFsaWQgcHVibGljS2V5IGxlbmd0aFxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHVibGljIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbGlkIHByaXZhdGVLZXkgbGVuZ3RoXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuICB2YXIgc2VjcDI1NmsxdjMgPSBnZXRTZWNwMjU2azEoKTtcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMuZWNkaFVuc2FmZShVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHJpdmF0ZUtleVZlcmlmeTogcHJpdmF0ZUtleVZlcmlmeSxcbiAgcHJpdmF0ZUtleUV4cG9ydDogcHJpdmF0ZUtleUV4cG9ydCxcbiAgcHJpdmF0ZUtleUltcG9ydDogcHJpdmF0ZUtleUltcG9ydCxcbiAgcHJpdmF0ZUtleU5lZ2F0ZTogcHJpdmF0ZUtleU5lZ2F0ZSxcbiAgcHJpdmF0ZUtleU1vZEludmVyc2U6IHByaXZhdGVLZXlNb2RJbnZlcnNlLFxuICBwcml2YXRlS2V5VHdlYWtBZGQ6IHByaXZhdGVLZXlUd2Vha0FkZCxcbiAgcHJpdmF0ZUtleVR3ZWFrTXVsOiBwcml2YXRlS2V5VHdlYWtNdWwsXG5cbiAgcHVibGljS2V5Q3JlYXRlOiBwdWJsaWNLZXlDcmVhdGUsXG4gIHB1YmxpY0tleUNvbnZlcnQ6IHB1YmxpY0tleUNvbnZlcnQsXG4gIHB1YmxpY0tleVZlcmlmeTogcHVibGljS2V5VmVyaWZ5LFxuICBwdWJsaWNLZXlUd2Vha0FkZDogcHVibGljS2V5VHdlYWtBZGQsXG4gIHB1YmxpY0tleVR3ZWFrTXVsOiBwdWJsaWNLZXlUd2Vha011bCxcbiAgcHVibGljS2V5Q29tYmluZTogcHVibGljS2V5Q29tYmluZSxcblxuICBzaWduYXR1cmVOb3JtYWxpemU6IHNpZ25hdHVyZU5vcm1hbGl6ZSxcbiAgc2lnbmF0dXJlRXhwb3J0OiBzaWduYXR1cmVFeHBvcnQsXG4gIHNpZ25hdHVyZUltcG9ydDogc2lnbmF0dXJlSW1wb3J0LFxuICBzaWduYXR1cmVJbXBvcnRMYXg6IHNpZ25hdHVyZUltcG9ydExheCxcblxuICBzaWduOiBzaWduLFxuICB2ZXJpZnk6IHZlcmlmeSxcbiAgcmVjb3ZlcjogcmVjb3ZlcixcblxuICBlY2RoOiBlY2RoLFxuICBlY2RoVW5zYWZlOiBlY2RoVW5zYWZlXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgZnJvbSBzZWNwMjU2azEgdjNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4vLyBiZWdpblxuMHgzMCwgMHg4MSwgMHhkMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbi8vIHByaXZhdGUga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuLy8gbWlkZGxlXG4weGEwLCAweDgxLCAweDg1LCAweDMwLCAweDgxLCAweDgyLCAweDAyLCAweDAxLCAweDAxLCAweDMwLCAweDJjLCAweDA2LCAweDA3LCAweDJhLCAweDg2LCAweDQ4LCAweGNlLCAweDNkLCAweDAxLCAweDAxLCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGZmLCAweGZmLCAweGZjLCAweDJmLCAweDMwLCAweDA2LCAweDA0LCAweDAxLCAweDAwLCAweDA0LCAweDAxLCAweDA3LCAweDA0LCAweDIxLCAweDAyLCAweDc5LCAweGJlLCAweDY2LCAweDdlLCAweGY5LCAweGRjLCAweGJiLCAweGFjLCAweDU1LCAweGEwLCAweDYyLCAweDk1LCAweGNlLCAweDg3LCAweDBiLCAweDA3LCAweDAyLCAweDliLCAweGZjLCAweGRiLCAweDJkLCAweGNlLCAweDI4LCAweGQ5LCAweDU5LCAweGYyLCAweDgxLCAweDViLCAweDE2LCAweGY4LCAweDE3LCAweDk4LCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGJhLCAweGFlLCAweGRjLCAweGU2LCAweGFmLCAweDQ4LCAweGEwLCAweDNiLCAweGJmLCAweGQyLCAweDVlLCAweDhjLCAweGQwLCAweDM2LCAweDQxLCAweDQxLCAweDAyLCAweDAxLCAweDAxLCAweGExLCAweDI0LCAweDAzLCAweDIyLCAweDAwLFxuLy8gcHVibGljIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuXG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbi8vIGJlZ2luXG4weDMwLCAweDgyLCAweDAxLCAweDEzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuLy8gcHJpdmF0ZSBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4vLyBtaWRkbGVcbjB4YTAsIDB4ODEsIDB4YTUsIDB4MzAsIDB4ODEsIDB4YTIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsIDB4Y2UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsIDB4NDEsIDB4MDQsIDB4NzksIDB4YmUsIDB4NjYsIDB4N2UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y2UsIDB4ODcsIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y2UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsIDB4MTcsIDB4OTgsIDB4NDgsIDB4M2EsIDB4ZGEsIDB4NzcsIDB4MjYsIDB4YTMsIDB4YzQsIDB4NjUsIDB4NWQsIDB4YTQsIDB4ZmIsIDB4ZmMsIDB4MGUsIDB4MTEsIDB4MDgsIDB4YTgsIDB4ZmQsIDB4MTcsIDB4YjQsIDB4NDgsIDB4YTYsIDB4ODUsIDB4NTQsIDB4MTksIDB4OWMsIDB4NDcsIDB4ZDAsIDB4OGYsIDB4ZmIsIDB4MTAsIDB4ZDQsIDB4YjgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4YmEsIDB4YWUsIDB4ZGMsIDB4ZTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NWUsIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4NDQsIDB4MDMsIDB4NDIsIDB4MDAsXG4vLyBwdWJsaWMga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXSk7XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpO1xuICBwcml2YXRlS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gOCA6IDkpO1xuICBwdWJsaWNLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyAxODEgOiAyMTQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5wcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGxlbmd0aCA9IHByaXZhdGVLZXkubGVuZ3RoO1xuXG4gIC8vIHNlcXVlbmNlIGhlYWRlclxuICB2YXIgaW5kZXggPSAwO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDMwKSByZXR1cm4gbnVsbDtcbiAgaW5kZXggKz0gMTtcblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggY29uc3RydWN0b3JcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCAhKHByaXZhdGVLZXlbaW5kZXhdICYgMHg4MCkpIHJldHVybiBudWxsO1xuXG4gIHZhciBsZW5iID0gcHJpdmF0ZUtleVtpbmRleF0gJiAweDdmO1xuICBpbmRleCArPSAxO1xuICBpZiAobGVuYiA8IDEgfHwgbGVuYiA+IDIpIHJldHVybiBudWxsO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW5iKSByZXR1cm4gbnVsbDtcblxuICAvLyBzZXF1ZW5jZSBsZW5ndGhcbiAgdmFyIGxlbiA9IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMV0gfCAobGVuYiA+IDEgPyBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDJdIDw8IDggOiAwKTtcbiAgaW5kZXggKz0gbGVuYjtcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuKSByZXR1cm4gbnVsbDtcblxuICAvLyBzZXF1ZW5jZSBlbGVtZW50IDA6IHZlcnNpb24gbnVtYmVyICg9MSlcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMyB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwMiB8fCBwcml2YXRlS2V5W2luZGV4ICsgMV0gIT09IDB4MDEgfHwgcHJpdmF0ZUtleVtpbmRleCArIDJdICE9PSAweDAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaW5kZXggKz0gMztcblxuICAvLyBzZXF1ZW5jZSBlbGVtZW50IDE6IG9jdGV0IHN0cmluZywgdXAgdG8gMzIgYnl0ZXNcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMiB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwNCB8fCBwcml2YXRlS2V5W2luZGV4ICsgMV0gPiAweDIwIHx8IGxlbmd0aCA8IGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByaXZhdGVLZXkuc2xpY2UoaW5kZXggKyAyLCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pO1xufTtcblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgdmFyIHMgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuXG4gIHZhciBsZW5ndGggPSBzaWduYXR1cmUubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlXG4gIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MzApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aCBieXRlXG4gIHZhciBsZW5ieXRlID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAobGVuYnl0ZSAmIDB4ODApIHtcbiAgICBpbmRleCArPSBsZW5ieXRlIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciByXG4gIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGxlbmd0aCBmb3IgclxuICB2YXIgcmxlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgaWYgKHJsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHJsZW4gLSAweDgwO1xuICAgIGlmIChpbmRleCArIGxlbmJ5dGUgPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7fVxuICAgIGZvciAocmxlbiA9IDA7IGxlbmJ5dGUgPiAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHtcbiAgICAgIHJsZW4gPSAocmxlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICB9XG4gIGlmIChybGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmluZGV4ID0gaW5kZXg7XG4gIGluZGV4ICs9IHJsZW47XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHNcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbGVuZ3RoIGZvciBzXG4gIHZhciBzbGVuID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAoc2xlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gc2xlbiAtIDB4ODA7XG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWduYXR1cmVbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHt9XG4gICAgZm9yIChzbGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge1xuICAgICAgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKHNsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzaW5kZXggPSBpbmRleDtcbiAgaW5kZXggKz0gc2xlbjtcblxuICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiByXG4gIGZvciAoOyBybGVuID4gMCAmJiBzaWduYXR1cmVbcmluZGV4XSA9PT0gMHgwMDsgcmxlbiAtPSAxLCByaW5kZXggKz0gMSkge31cbiAgLy8gY29weSByIHZhbHVlXG4gIGlmIChybGVuID4gMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcnZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHJpbmRleCwgcmluZGV4ICsgcmxlbik7XG4gIHJ2YWx1ZS5jb3B5KHIsIDMyIC0gcnZhbHVlLmxlbmd0aCk7XG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gc1xuICBmb3IgKDsgc2xlbiA+IDAgJiYgc2lnbmF0dXJlW3NpbmRleF0gPT09IDB4MDA7IHNsZW4gLT0gMSwgc2luZGV4ICs9IDEpIHt9XG4gIC8vIGNvcHkgcyB2YWx1ZVxuICBpZiAoc2xlbiA+IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHN2YWx1ZSA9IHNpZ25hdHVyZS5zbGljZShzaW5kZXgsIHNpbmRleCArIHNsZW4pO1xuICBzdmFsdWUuY29weShzLCAzMiAtIHN2YWx1ZS5sZW5ndGgpO1xuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgZnJvbSBzZWNwMjU2azEgdjNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcblxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKTtcbnZhciBlY3BhcmFtcyA9IGVjLmN1cnZlO1xuXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGQudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG5cXCd0IGV4cG9ydCB0byBERVIgZm9ybWF0Jyk7XG4gIH1cblxuICB2YXIgcG9pbnQgPSBlYy5nLm11bChkKTtcbiAgcmV0dXJuIHRvUHVibGljS2V5KHBvaW50LmdldFgoKSwgcG9pbnQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG5cbmV4cG9ydHMucHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgYm4gPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChibi51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IHJhbmdlIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpO1xufTtcblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gbmV3IEJOKHNpZ09iai5yKTtcbiAgaWYgKHIudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgciA9IG5ldyBCTigwKTtcbiAgfVxuXG4gIHZhciBzID0gbmV3IEJOKHNpZ09iai5zKTtcbiAgaWYgKHMudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgcyA9IG5ldyBCTigwKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtyLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLCBzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXSk7XG59O1xuXG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwb2ludCA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5KTtcblxuICB2YXIgc2NhbGFyID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoc2NhbGFyLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdyknKTtcbiAgfVxuXG4gIHZhciBzaGFyZWQgPSBwb2ludC5wdWIubXVsKHNjYWxhcik7XG4gIHJldHVybiB0b1B1YmxpY0tleShzaGFyZWQuZ2V0WCgpLCBzaGFyZWQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG5cbnZhciB0b1B1YmxpY0tleSA9IGZ1bmN0aW9uIHRvUHVibGljS2V5KHgsIHksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHB1YmxpY0tleSA9IHZvaWQgMDtcblxuICBpZiAoY29tcHJlc3NlZCkge1xuICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvYygzMyk7XG4gICAgcHVibGljS2V5WzBdID0geS5pc09kZCgpID8gMHgwMyA6IDB4MDI7XG4gICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gIH0gZWxzZSB7XG4gICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDY1KTtcbiAgICBwdWJsaWNLZXlbMF0gPSAweDA0O1xuICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICAgIHkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDMzKTtcbiAgfVxuXG4gIHJldHVybiBwdWJsaWNLZXk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcbnZhciBzdHJpcEhleFByZWZpeCA9IHJlcXVpcmUoJ3N0cmlwLWhleC1wcmVmaXgnKTtcblxuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgdmFyIGEgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBwYWRkaW5nIHRvIGV2ZW4sIHZhbHVlIG11c3QgYmUgc3RyaW5nLCBpcyBjdXJyZW50bHkgJyArIHR5cGVvZiBhICsgJywgd2hpbGUgcGFkVG9FdmVuLicpO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICUgMikge1xuICAgIGEgPSAnMCcgKyBhO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHBhZFRvRXZlbihoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBnZXR0aW5nIGJpbmFyeSBzaXplLCBtZXRob2QgZ2V0QmluYXJ5U2l6ZSByZXF1aXJlcyBpbnB1dCBcXCdzdHJcXCcgdG8gYmUgdHlwZSBTdHJpbmcsIGdvdCBcXCcnICsgdHlwZW9mIHN0ciArICdcXCcuJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN1cGVyc2V0XG4gKiBAcGFyYW0ge2FycmF5fSBzdWJzZXRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdXBlcnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1cGVyc2V0ICsgJ1xcJycpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1YnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1YnNldCArICdcXCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdWJzZXRbQm9vbGVhbihzb21lKSAmJiAnc29tZScgfHwgJ2V2ZXJ5J10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1V0ZjgoaGV4KSB7XG4gIHZhciBidWZmZXJWYWx1ZSA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KGhleCkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIGJ1ZmZlclZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgdmFyIHN0ciA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBpID0gMCxcbiAgICAgIGwgPSBoZXgubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICBpID0gMjtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIHN0ciA9IG5ldyBCdWZmZXIoc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICB2YXIgaGV4ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gIH1cblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBnZXRLZXlzKFt7YTogMSwgYjogMn0sIHthOiAzLCBiOiA0fV0sICdhJykgPT4gWzEsIDNdXG4gKlxuICogQG1ldGhvZCBnZXRLZXlzIGdldCBzcGVjaWZpYyBrZXkgZnJvbSBpbm5lciBvYmplY3QgYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBBcnJheSBhcyBcXCdwYXJhbXNcXCcgaW5wdXQsIGdvdCBcXCcnICsgdHlwZW9mIHBhcmFtcyArICdcXCcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBTdHJpbmcgZm9yIGlucHV0IFxcJ2tleVxcJyBnb3QgXFwnJyArIHR5cGVvZiBrZXkgKyAnXFwnLicpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWJpJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBjaGVjayBpZiBzdHJpbmcgaXMgaGV4IHN0cmluZyBvZiBzcGVjaWZpYyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge0Jvb2xlYW59IG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUNvbnRhaW5zQXJyYXk6IGFycmF5Q29udGFpbnNBcnJheSxcbiAgaW50VG9CdWZmZXI6IGludFRvQnVmZmVyLFxuICBnZXRCaW5hcnlTaXplOiBnZXRCaW5hcnlTaXplLFxuICBpc0hleFByZWZpeGVkOiBpc0hleFByZWZpeGVkLFxuICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gIHBhZFRvRXZlbjogcGFkVG9FdmVuLFxuICBpbnRUb0hleDogaW50VG9IZXgsXG4gIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gIHRvQXNjaWk6IHRvQXNjaWksXG4gIHRvVXRmODogdG9VdGY4LFxuICBnZXRLZXlzOiBnZXRLZXlzLFxuICBpc0hleFN0cmluZzogaXNIZXhTdHJpbmdcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhES2V5ID0gZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQgPSB2b2lkIDA7XG52YXIgYmlwMzJfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmlwMzJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIQVJERU5FRF9PRkZTRVRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpcDMyXzEuSEFSREVORURfT0ZGU0VUOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSERLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpcDMyXzEuSERLZXk7IH0gfSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIGV0aFV0aWwgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG52YXIgc2NyeXB0c3kgPSByZXF1aXJlKCdzY3J5cHRzeScpO1xudmFyIHV1aWR2NCA9IHJlcXVpcmUoJ3V1aWQvdjQnKTtcbnZhciBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bkNpcGhlckJ1ZmZlcihjaXBoZXIsIGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUoZGF0YSksIGNpcGhlci5maW5hbCgpXSk7XG59XG5cbnZhciBXYWxsZXQgPSBmdW5jdGlvbiBXYWxsZXQocHJpdiwgcHViKSB7XG4gIGlmIChwcml2ICYmIHB1Yikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN1cHBseSBib3RoIGEgcHJpdmF0ZSBhbmQgYSBwdWJsaWMga2V5IHRvIHRoZSBjb25zdHJ1Y3RvcicpO1xuICB9XG5cbiAgaWYgKHByaXYgJiYgIWV0aFV0aWwuaXNWYWxpZFByaXZhdGUocHJpdikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IGRvZXMgbm90IHNhdGlzZnkgdGhlIGN1cnZlIHJlcXVpcmVtZW50cyAoaWUuIGl0IGlzIGludmFsaWQpJyk7XG4gIH1cblxuICBpZiAocHViICYmICFldGhVdGlsLmlzVmFsaWRQdWJsaWMocHViKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5Jyk7XG4gIH1cblxuICB0aGlzLl9wcml2S2V5ID0gcHJpdjtcbiAgdGhpcy5fcHViS2V5ID0gcHViO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhbGxldC5wcm90b3R5cGUsICdwcml2S2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBhc3NlcnQodGhpcy5fcHJpdktleSwgJ1RoaXMgaXMgYSBwdWJsaWMga2V5IG9ubHkgd2FsbGV0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZLZXk7XG4gIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgJ3B1YktleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJLZXkpIHtcbiAgICAgIHRoaXMuX3B1YktleSA9IGV0aFV0aWwucHJpdmF0ZVRvUHVibGljKHRoaXMucHJpdktleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdWJLZXk7XG4gIH1cbn0pO1xuXG5XYWxsZXQuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoaWNhcERpcmVjdCkge1xuICBpZiAoaWNhcERpcmVjdCkge1xuICAgIHZhciBtYXggPSBuZXcgZXRoVXRpbC5CTignMDg4ZjkyNGVlY2VlZGE3ZmU5MmUxZjViMGZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHByaXZLZXkgPSByYW5kb21CeXRlcygzMik7XG4gICAgICBpZiAobmV3IGV0aFV0aWwuQk4oZXRoVXRpbC5wcml2YXRlVG9BZGRyZXNzKHByaXZLZXkpKS5sdGUobWF4KSkge1xuICAgICAgICByZXR1cm4gbmV3IFdhbGxldChwcml2S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQocmFuZG9tQnl0ZXMoMzIpKTtcbiAgfVxufTtcblxuV2FsbGV0LmdlbmVyYXRlVmFuaXR5QWRkcmVzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIGlmICgodHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdHRlcm4pKSAhPT0gJ29iamVjdCcpIHtcbiAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgfVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHByaXZLZXkgPSByYW5kb21CeXRlcygzMik7XG4gICAgdmFyIGFkZHJlc3MgPSBldGhVdGlsLnByaXZhdGVUb0FkZHJlc3MocHJpdktleSk7XG5cbiAgICBpZiAocGF0dGVybi50ZXN0KGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKSkge1xuICAgICAgcmV0dXJuIG5ldyBXYWxsZXQocHJpdktleSk7XG4gICAgfVxuICB9XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByaXZLZXk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldFByaXZhdGVLZXlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuZ2V0UHJpdmF0ZUtleSgpKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wdWJLZXk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldFB1YmxpY0tleVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgodGhpcy5nZXRQdWJsaWNLZXkoKSk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyh0aGlzLnB1YktleSk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldEFkZHJlc3NTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuZ2V0QWRkcmVzcygpKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0Q2hlY2tzdW1BZGRyZXNzU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyh0aGlzLmdldEFkZHJlc3NTdHJpbmcoKSk7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1dlYjMtU2VjcmV0LVN0b3JhZ2UtRGVmaW5pdGlvblxuV2FsbGV0LnByb3RvdHlwZS50b1YzID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBvcHRzKSB7XG4gIGFzc2VydCh0aGlzLl9wcml2S2V5LCAnVGhpcyBpcyBhIHB1YmxpYyBrZXkgb25seSB3YWxsZXQnKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHNhbHQgPSBvcHRzLnNhbHQgfHwgcmFuZG9tQnl0ZXMoMzIpO1xuICB2YXIgaXYgPSBvcHRzLml2IHx8IHJhbmRvbUJ5dGVzKDE2KTtcblxuICB2YXIgZGVyaXZlZEtleTtcbiAgdmFyIGtkZiA9IG9wdHMua2RmIHx8ICdzY3J5cHQnO1xuICB2YXIga2RmcGFyYW1zID0ge1xuICAgIGRrbGVuOiBvcHRzLmRrbGVuIHx8IDMyLFxuICAgIHNhbHQ6IHNhbHQudG9TdHJpbmcoJ2hleCcpXG4gIH07XG5cbiAgaWYgKGtkZiA9PT0gJ3Bia2RmMicpIHtcbiAgICBrZGZwYXJhbXMuYyA9IG9wdHMuYyB8fCAyNjIxNDQ7XG4gICAga2RmcGFyYW1zLnByZiA9ICdobWFjLXNoYTI1Nic7XG4gICAgZGVyaXZlZEtleSA9IGNyeXB0by5wYmtkZjJTeW5jKEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgc2FsdCwga2RmcGFyYW1zLmMsIGtkZnBhcmFtcy5ka2xlbiwgJ3NoYTI1NicpO1xuICB9IGVsc2UgaWYgKGtkZiA9PT0gJ3NjcnlwdCcpIHtcbiAgICAvLyBGSVhNRTogc3VwcG9ydCBwcm9ncmVzcyByZXBvcnRpbmcgY2FsbGJhY2tcbiAgICBrZGZwYXJhbXMubiA9IG9wdHMubiB8fCAyNjIxNDQ7XG4gICAga2RmcGFyYW1zLnIgPSBvcHRzLnIgfHwgODtcbiAgICBrZGZwYXJhbXMucCA9IG9wdHMucCB8fCAxO1xuICAgIGRlcml2ZWRLZXkgPSBzY3J5cHRzeShCdWZmZXIuZnJvbShwYXNzd29yZCksIHNhbHQsIGtkZnBhcmFtcy5uLCBrZGZwYXJhbXMuciwga2RmcGFyYW1zLnAsIGtkZnBhcmFtcy5ka2xlbik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZGYnKTtcbiAgfVxuXG4gIHZhciBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYob3B0cy5jaXBoZXIgfHwgJ2Flcy0xMjgtY3RyJywgZGVyaXZlZEtleS5zbGljZSgwLCAxNiksIGl2KTtcbiAgaWYgKCFjaXBoZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNpcGhlcicpO1xuICB9XG5cbiAgdmFyIGNpcGhlcnRleHQgPSBydW5DaXBoZXJCdWZmZXIoY2lwaGVyLCB0aGlzLnByaXZLZXkpO1xuXG4gIHZhciBtYWMgPSBldGhVdGlsLmtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtkZXJpdmVkS2V5LnNsaWNlKDE2LCAzMiksIEJ1ZmZlci5mcm9tKGNpcGhlcnRleHQsICdoZXgnKV0pKTtcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246IDMsXG4gICAgaWQ6IHV1aWR2NCh7IHJhbmRvbTogb3B0cy51dWlkIHx8IHJhbmRvbUJ5dGVzKDE2KSB9KSxcbiAgICBhZGRyZXNzOiB0aGlzLmdldEFkZHJlc3MoKS50b1N0cmluZygnaGV4JyksXG4gICAgY3J5cHRvOiB7XG4gICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIGNpcGhlcnBhcmFtczoge1xuICAgICAgICBpdjogaXYudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9LFxuICAgICAgY2lwaGVyOiBvcHRzLmNpcGhlciB8fCAnYWVzLTEyOC1jdHInLFxuICAgICAga2RmOiBrZGYsXG4gICAgICBrZGZwYXJhbXM6IGtkZnBhcmFtcyxcbiAgICAgIG1hYzogbWFjLnRvU3RyaW5nKCdoZXgnKVxuICAgIH1cbiAgfTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0VjNGaWxlbmFtZSA9IGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgLypcbiAgICogV2Ugd2FudCBhIHRpbWVzdGFtcCBsaWtlIDIwMTYtMDMtMTVUMTctMTEtMzMuMDA3NTk4Mjg4Wi4gRGF0ZSBmb3JtYXR0aW5nXG4gICAqIGlzIGEgcGFpbiBpbiBKYXZhc2NyaXB0LCBldmVyYm9keSBrbm93cyB0aGF0LiBXZSBjb3VsZCB1c2UgbW9tZW50LmpzLFxuICAgKiBidXQgZGVjaWRlIHRvIGRvIGl0IG1hbnVhbGx5IGluIG9yZGVyIHRvIHNhdmUgc3BhY2UuXG4gICAqXG4gICAqIHRvSlNPTigpIHJldHVybnMgYSBwcmV0dHkgY2xvc2UgdmVyc2lvbiwgc28gbGV0J3MgdXNlIGl0LiBJdCBpcyBub3QgVVRDIHRob3VnaCxcbiAgICogYnV0IGRvZXMgaXQgcmVhbGx5IG1hdHRlcj9cbiAgICpcbiAgICogQWx0ZXJuYXRpdmUgbWFudWFsIHdheSB3aXRoIHBhZGRpbmcgYW5kIERhdGUgZmllbGRzOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MjQ0Mjg4LzQ5NjQ4MTlcbiAgICpcbiAgICovXG4gIHZhciB0cyA9IHRpbWVzdGFtcCA/IG5ldyBEYXRlKHRpbWVzdGFtcCkgOiBuZXcgRGF0ZSgpO1xuXG4gIHJldHVybiBbJ1VUQy0tJywgdHMudG9KU09OKCkucmVwbGFjZSgvOi9nLCAnLScpLCAnLS0nLCB0aGlzLmdldEFkZHJlc3MoKS50b1N0cmluZygnaGV4JyldLmpvaW4oJycpO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS50b1YzU3RyaW5nID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBvcHRzKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvVjMocGFzc3dvcmQsIG9wdHMpKTtcbn07XG5cbldhbGxldC5mcm9tUHVibGljS2V5ID0gZnVuY3Rpb24gKHB1Yiwgbm9uU3RyaWN0KSB7XG4gIGlmIChub25TdHJpY3QpIHtcbiAgICBwdWIgPSBldGhVdGlsLmltcG9ydFB1YmxpYyhwdWIpO1xuICB9XG4gIHJldHVybiBuZXcgV2FsbGV0KG51bGwsIHB1Yik7XG59O1xuXG5XYWxsZXQuZnJvbUV4dGVuZGVkUHVibGljS2V5ID0gZnVuY3Rpb24gKHB1Yikge1xuICBhc3NlcnQocHViLnNsaWNlKDAsIDQpID09PSAneHB1YicsICdOb3QgYW4gZXh0ZW5kZWQgcHVibGljIGtleScpO1xuICBwdWIgPSBiczU4Y2hlY2suZGVjb2RlKHB1Yikuc2xpY2UoNDUpO1xuICAvLyBDb252ZXJ0IHRvIGFuIEV0aGVyZXVtIHB1YmxpYyBrZXlcbiAgcmV0dXJuIFdhbGxldC5mcm9tUHVibGljS2V5KHB1YiwgdHJ1ZSk7XG59O1xuXG5XYWxsZXQuZnJvbVByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdikge1xuICByZXR1cm4gbmV3IFdhbGxldChwcml2KTtcbn07XG5cbldhbGxldC5mcm9tRXh0ZW5kZWRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXYpIHtcbiAgYXNzZXJ0KHByaXYuc2xpY2UoMCwgNCkgPT09ICd4cHJ2JywgJ05vdCBhbiBleHRlbmRlZCBwcml2YXRlIGtleScpO1xuICB2YXIgdG1wID0gYnM1OGNoZWNrLmRlY29kZShwcml2KTtcbiAgYXNzZXJ0KHRtcFs0NV0gPT09IDAsICdJbnZhbGlkIGV4dGVuZGVkIHByaXZhdGUga2V5Jyk7XG4gIHJldHVybiBXYWxsZXQuZnJvbVByaXZhdGVLZXkodG1wLnNsaWNlKDQ2KSk7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vd2lraS9QYXNzcGhyYXNlLXByb3RlY3RlZC1rZXktc3RvcmUtc3BlY1xuV2FsbGV0LmZyb21WMSA9IGZ1bmN0aW9uIChpbnB1dCwgcGFzc3dvcmQpIHtcbiAgYXNzZXJ0KHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpO1xuICB2YXIganNvbiA9ICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSkgPT09ICdvYmplY3QnID8gaW5wdXQgOiBKU09OLnBhcnNlKGlucHV0KTtcblxuICBpZiAoanNvbi5WZXJzaW9uICE9PSAnMScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIFYxIHdhbGxldCcpO1xuICB9XG5cbiAgaWYgKGpzb24uQ3J5cHRvLktleUhlYWRlci5LZGYgIT09ICdzY3J5cHQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBzY2hlbWUnKTtcbiAgfVxuXG4gIHZhciBrZGZwYXJhbXMgPSBqc29uLkNyeXB0by5LZXlIZWFkZXIuS2RmUGFyYW1zO1xuICB2YXIgZGVyaXZlZEtleSA9IHNjcnlwdHN5KEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oanNvbi5DcnlwdG8uU2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMuTiwga2RmcGFyYW1zLlIsIGtkZnBhcmFtcy5QLCBrZGZwYXJhbXMuRGtMZW4pO1xuXG4gIHZhciBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oanNvbi5DcnlwdG8uQ2lwaGVyVGV4dCwgJ2hleCcpO1xuXG4gIHZhciBtYWMgPSBldGhVdGlsLmtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtkZXJpdmVkS2V5LnNsaWNlKDE2LCAzMiksIGNpcGhlcnRleHRdKSk7XG5cbiAgaWYgKG1hYy50b1N0cmluZygnaGV4JykgIT09IGpzb24uQ3J5cHRvLk1BQykge1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IGRlcml2YXRpb24gZmFpbGVkIC0gcG9zc2libHkgd3JvbmcgcGFzc3BocmFzZScpO1xuICB9XG5cbiAgdmFyIGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoJ2Flcy0xMjgtY2JjJywgZXRoVXRpbC5rZWNjYWsyNTYoZGVyaXZlZEtleS5zbGljZSgwLCAxNikpLnNsaWNlKDAsIDE2KSwgQnVmZmVyLmZyb20oanNvbi5DcnlwdG8uSVYsICdoZXgnKSk7XG4gIHZhciBzZWVkID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBjaXBoZXJ0ZXh0KTtcblxuICByZXR1cm4gbmV3IFdhbGxldChzZWVkKTtcbn07XG5cbldhbGxldC5mcm9tVjMgPSBmdW5jdGlvbiAoaW5wdXQsIHBhc3N3b3JkLCBub25TdHJpY3QpIHtcbiAgYXNzZXJ0KHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpO1xuICB2YXIganNvbiA9ICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSkgPT09ICdvYmplY3QnID8gaW5wdXQgOiBKU09OLnBhcnNlKG5vblN0cmljdCA/IGlucHV0LnRvTG93ZXJDYXNlKCkgOiBpbnB1dCk7XG5cbiAgaWYgKGpzb24udmVyc2lvbiAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgVjMgd2FsbGV0Jyk7XG4gIH1cblxuICB2YXIgZGVyaXZlZEtleTtcbiAgdmFyIGtkZnBhcmFtcztcbiAgaWYgKGpzb24uY3J5cHRvLmtkZiA9PT0gJ3NjcnlwdCcpIHtcbiAgICBrZGZwYXJhbXMgPSBqc29uLmNyeXB0by5rZGZwYXJhbXM7XG5cbiAgICAvLyBGSVhNRTogc3VwcG9ydCBwcm9ncmVzcyByZXBvcnRpbmcgY2FsbGJhY2tcbiAgICBkZXJpdmVkS2V5ID0gc2NyeXB0c3koQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBCdWZmZXIuZnJvbShrZGZwYXJhbXMuc2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMubiwga2RmcGFyYW1zLnIsIGtkZnBhcmFtcy5wLCBrZGZwYXJhbXMuZGtsZW4pO1xuICB9IGVsc2UgaWYgKGpzb24uY3J5cHRvLmtkZiA9PT0gJ3Bia2RmMicpIHtcbiAgICBrZGZwYXJhbXMgPSBqc29uLmNyeXB0by5rZGZwYXJhbXM7XG5cbiAgICBpZiAoa2RmcGFyYW1zLnByZiAhPT0gJ2htYWMtc2hhMjU2Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXJzIHRvIFBCS0RGMicpO1xuICAgIH1cblxuICAgIGRlcml2ZWRLZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGtkZnBhcmFtcy5zYWx0LCAnaGV4JyksIGtkZnBhcmFtcy5jLCBrZGZwYXJhbXMuZGtsZW4sICdzaGEyNTYnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSBkZXJpdmF0aW9uIHNjaGVtZScpO1xuICB9XG5cbiAgdmFyIGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShqc29uLmNyeXB0by5jaXBoZXJ0ZXh0LCAnaGV4Jyk7XG5cbiAgdmFyIG1hYyA9IGV0aFV0aWwua2VjY2FrMjU2KEJ1ZmZlci5jb25jYXQoW2Rlcml2ZWRLZXkuc2xpY2UoMTYsIDMyKSwgY2lwaGVydGV4dF0pKTtcbiAgaWYgKG1hYy50b1N0cmluZygnaGV4JykgIT09IGpzb24uY3J5cHRvLm1hYykge1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IGRlcml2YXRpb24gZmFpbGVkIC0gcG9zc2libHkgd3JvbmcgcGFzc3BocmFzZScpO1xuICB9XG5cbiAgdmFyIGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoanNvbi5jcnlwdG8uY2lwaGVyLCBkZXJpdmVkS2V5LnNsaWNlKDAsIDE2KSwgQnVmZmVyLmZyb20oanNvbi5jcnlwdG8uY2lwaGVycGFyYW1zLml2LCAnaGV4JykpO1xuICB2YXIgc2VlZCA9IHJ1bkNpcGhlckJ1ZmZlcihkZWNpcGhlciwgY2lwaGVydGV4dCk7XG5cbiAgcmV0dXJuIG5ldyBXYWxsZXQoc2VlZCk7XG59O1xuXG4vKlxuICogQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3B5ZXRoc2FsZXRvb2wvYmxvYi9tYXN0ZXIvcHlldGhzYWxldG9vbC5weVxuICogSlNPTiBmaWVsZHM6IGVuY3NlZWQsIGV0aGFkZHIsIGJ0Y2FkZHIsIGVtYWlsXG4gKi9cbldhbGxldC5mcm9tRXRoU2FsZSA9IGZ1bmN0aW9uIChpbnB1dCwgcGFzc3dvcmQpIHtcbiAgYXNzZXJ0KHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpO1xuICB2YXIganNvbiA9ICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSkgPT09ICdvYmplY3QnID8gaW5wdXQgOiBKU09OLnBhcnNlKGlucHV0KTtcblxuICB2YXIgZW5jc2VlZCA9IEJ1ZmZlci5mcm9tKGpzb24uZW5jc2VlZCwgJ2hleCcpO1xuXG4gIC8vIGtleSBkZXJpdmF0aW9uXG4gIHZhciBkZXJpdmVkS2V5ID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIHBhc3N3b3JkLCAyMDAwLCAzMiwgJ3NoYTI1NicpLnNsaWNlKDAsIDE2KTtcblxuICAvLyBzZWVkIGRlY29kaW5nIChJViBpcyBmaXJzdCAxNiBieXRlcylcbiAgLy8gTk9URTogY3J5cHRvIChkZXJpdmVkIGZyb20gb3BlbnNzbCkgd2hlbiB1c2VkIHdpdGggYWVzLSotY2JjIHdpbGwgaGFuZGxlIFBLQ1MjNyBwYWRkaW5nIGludGVybmFsbHlcbiAgLy8gICAgICAgc2VlIGFsc28gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE2MTQ3NzAvNDk2NDgxOVxuICB2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTEyOC1jYmMnLCBkZXJpdmVkS2V5LCBlbmNzZWVkLnNsaWNlKDAsIDE2KSk7XG4gIHZhciBzZWVkID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBlbmNzZWVkLnNsaWNlKDE2KSk7XG5cbiAgdmFyIHdhbGxldCA9IG5ldyBXYWxsZXQoZXRoVXRpbC5rZWNjYWsyNTYoc2VlZCkpO1xuICBpZiAod2FsbGV0LmdldEFkZHJlc3MoKS50b1N0cmluZygnaGV4JykgIT09IGpzb24uZXRoYWRkcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlZCBrZXkgbWlzbWF0Y2ggLSBwb3NzaWJseSB3cm9uZyBwYXNzcGhyYXNlJyk7XG4gIH1cbiAgcmV0dXJuIHdhbGxldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2FsbGV0OyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gY3JlYXRlSGFzaEZ1bmN0aW9uKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBoYXNoID0gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGhhc2gudXBkYXRlKG1zZyk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVIYXNoRnVuY3Rpb24gPSBjcmVhdGVIYXNoRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhc2hfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2hhc2gtdXRpbHNcIik7XG52YXIgY3JlYXRlS2VjY2FrSGFzaCA9IHJlcXVpcmUoXCJrZWNjYWtcIik7XG5leHBvcnRzLmtlY2NhazIyNCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMjI0XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazI1NiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMjU2XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazM4NCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMzg0XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazUxMiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrNTEyXCIpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKFwicmFuZG9tYnl0ZXNcIik7XG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhieXRlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJhbmRvbWJ5dGVzKGJ5dGVzLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFJhbmRvbUJ5dGVzID0gZ2V0UmFuZG9tQnl0ZXM7XG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlc1N5bmMoYnl0ZXMpIHtcbiAgICByZXR1cm4gcmFuZG9tYnl0ZXMoYnl0ZXMpO1xufVxuZXhwb3J0cy5nZXRSYW5kb21CeXRlc1N5bmMgPSBnZXRSYW5kb21CeXRlc1N5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJzZWNwMjU2azFcIik7XG52YXIgcmFuZG9tXzEgPSByZXF1aXJlKFwiLi9yYW5kb21cIik7XG52YXIgU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUgPSAzMjtcbmZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGs7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJhbmRvbV8xLmdldFJhbmRvbUJ5dGVzKFNFQ1AyNTZLMV9QUklWQVRFX0tFWV9TSVpFKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBwayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3AyNTZrMV8xLnByaXZhdGVLZXlWZXJpZnkocGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleSA9IGNyZWF0ZVByaXZhdGVLZXk7XG5mdW5jdGlvbiBjcmVhdGVQcml2YXRlS2V5U3luYygpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcGsgPSByYW5kb21fMS5nZXRSYW5kb21CeXRlc1N5bmMoU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUpO1xuICAgICAgICBpZiAoc2VjcDI1NmsxXzEucHJpdmF0ZUtleVZlcmlmeShwaykpIHtcbiAgICAgICAgICAgIHJldHVybiBwaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleVN5bmMgPSBjcmVhdGVQcml2YXRlS2V5U3luYztcbl9fZXhwb3J0KHJlcXVpcmUoXCJzZWNwMjU2azFcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBleHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MgPSB2b2lkIDA7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgZXRoanNVdGlsID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtYWRhcHRlcicpO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzLlxuICovXG5leHBvcnRzLnplcm9BZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gICAgdmFyIGFkZHIgPSBieXRlc18xLnplcm9zKGFkZHJlc3NMZW5ndGgpO1xuICAgIHJldHVybiBieXRlc18xLmJ1ZmZlclRvSGV4KGFkZHIpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvby5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgemVyb0FkZHIgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gICAgcmV0dXJuIHplcm9BZGRyID09PSBieXRlc18xLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIElmIGEgZWlwMTE5MUNoYWluSWQgaXMgcHJvdmlkZWQsIHRoZSBjaGFpbklkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNoZWNrc3VtIGNhbGN1bGF0aW9uLiBUaGlzXG4gKiBoYXMgdGhlIGVmZmVjdCBvZiBjaGVja3N1bW1lZCBhZGRyZXNzZXMgZm9yIG9uZSBjaGFpbiBoYXZpbmcgaW52YWxpZCBjaGVja3N1bXMgZm9yIG90aGVycy5cbiAqIEZvciBtb3JlIGRldGFpbHMsIGNvbnN1bHQgRUlQLTExOTEuXG4gKlxuICogV0FSTklORzogQ2hlY2tzdW1zIHdpdGggYW5kIHdpdGhvdXQgdGhlIGNoYWluSWQgd2lsbCBkaWZmZXIuIEFzIG9mIDIwMTktMDYtMjYsIHRoZSBtb3N0IGNvbW1vbmx5XG4gKiB1c2VkIHZhcmlhdGlvbiBpbiBFdGhlcmV1bSB3YXMgd2l0aG91dCB0aGUgY2hhaW5JZC4gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICBhZGRyZXNzID0gZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KGFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHByZWZpeCA9IGVpcDExOTFDaGFpbklkICE9PSB1bmRlZmluZWQgPyBlaXAxMTkxQ2hhaW5JZC50b1N0cmluZygpICsgJzB4JyA6ICcnO1xuICAgIHZhciBoYXNoID0gaGFzaF8xLmtlY2NhayhwcmVmaXggKyBhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gICAgdmFyIHJldCA9ICcweCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIFNlZSB0b0NoZWNrc3VtQWRkcmVzcycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyBhYm91dCB0aGUgZWlwMTE5MUNoYWluSWQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSAmJiBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSA9PT0gYWRkcmVzcztcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICAgIGZyb20gPSBieXRlc18xLnRvQnVmZmVyKGZyb20pO1xuICAgIHZhciBub25jZUJOID0gbmV3IEJOKG5vbmNlKTtcbiAgICBpZiAobm9uY2VCTi5pc1plcm8oKSkge1xuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICAgICAgcmV0dXJuIGhhc2hfMS5ybHBoYXNoKFtmcm9tLCBudWxsXSkuc2xpY2UoLTIwKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIGhhc2hfMS5ybHBoYXNoKFtmcm9tLCBCdWZmZXIuZnJvbShub25jZUJOLnRvQXJyYXkoKSldKS5zbGljZSgtMjApO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBmdW5jdGlvbiAoZnJvbSwgc2FsdCwgaW5pdENvZGUpIHtcbiAgICB2YXIgZnJvbUJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoZnJvbSk7XG4gICAgdmFyIHNhbHRCdWYgPSBieXRlc18xLnRvQnVmZmVyKHNhbHQpO1xuICAgIHZhciBpbml0Q29kZUJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoaW5pdENvZGUpO1xuICAgIGFzc2VydChmcm9tQnVmLmxlbmd0aCA9PT0gMjApO1xuICAgIGFzc2VydChzYWx0QnVmLmxlbmd0aCA9PT0gMzIpO1xuICAgIHZhciBhZGRyZXNzID0gaGFzaF8xLmtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnZmYnLCAnaGV4JyksIGZyb21CdWYsIHNhbHRCdWYsIGhhc2hfMS5rZWNjYWsyNTYoaW5pdENvZGVCdWYpXSkpO1xuICAgIHJldHVybiBhZGRyZXNzLnNsaWNlKC0yMCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSkuXG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgdmFyIGEgPSBieXRlc18xLnVucGFkKGFkZHJlc3MpO1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMSAmJiBhWzBdID49IDEgJiYgYVswXSA8PSA4O1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gICAgaWYgKHNhbml0aXplID09PSB2b2lkIDApIHsgc2FuaXRpemUgPSBmYWxzZTsgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gICAgfVxuICAgIGlmICghc2FuaXRpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICAgIGlmIChzYW5pdGl6ZSA9PT0gdm9pZCAwKSB7IHNhbml0aXplID0gZmFsc2U7IH1cbiAgICBwdWJLZXkgPSBieXRlc18xLnRvQnVmZmVyKHB1YktleSk7XG4gICAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAgIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICAgIHJldHVybiBoYXNoXzEua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhleHBvcnRzLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5leHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcHJpdmF0ZUtleSA9IGJ5dGVzXzEudG9CdWZmZXIocHJpdmF0ZUtleSk7XG4gICAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIHB1YmxpY0tleSA9IGJ5dGVzXzEudG9CdWZmZXIocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFUb0pTT04gPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLmJ1ZmZlclRvSW50ID0gZXhwb3J0cy50b0J1ZmZlciA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGV4cG9ydHMudW5wYWQgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGggPSBleHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnplcm9zID0gdm9pZCAwO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyfEFycmF5KVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0gcmlnaHQgd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheSlcbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gZmFsc2U7IH1cbiAgICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICAgIG1zZyA9IGV4cG9ydHMudG9CdWZmZXIobXNnKTtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICAgIH1cbn07XG5leHBvcnRzLnNldExlbmd0aCA9IGV4cG9ydHMuc2V0TGVuZ3RoTGVmdDtcbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcnxBcnJheSlcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyfEFycmF5KVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmV4cG9ydHMudW5wYWQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEgPSBldGhqc1V0aWwuc3RyaXBIZXhQcmVmaXgoYSk7XG4gICAgdmFyIGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5leHBvcnRzLnN0cmlwWmVyb3MgPSBleHBvcnRzLnVucGFkO1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0cyBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZXRoanNVdGlsLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV0aGpzVXRpbC5wYWRUb0V2ZW4oZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlci4gdG9CdWZmZXIgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBhbmQgdGhpcyBzdHJpbmcgd2FzIGdpdmVuOiBcIiArIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdiA9IGV0aGpzVXRpbC5pbnRUb0J1ZmZlcih2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICAgICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmAuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiBuZXcgQk4oZXhwb3J0cy50b0J1ZmZlcihidWYpKS50b051bWJlcigpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgYDB4YC1wcmVmaXhlZCBoZXggYFN0cmluZ2AuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgYnVmID0gZXhwb3J0cy50b0J1ZmZlcihidWYpO1xuICAgIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtIFNpZ25lZCBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gbmV3IEJOKG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiLlxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGpzVXRpbC5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT04uXG4gKiBAcGFyYW0gYmEgKEJ1ZmZlcnxBcnJheSlcbiAqIEByZXR1cm4gKEFycmF5fFN0cmluZ3xudWxsKVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gZXhwb3J0cy5UV09fUE9XMjU2ID0gZXhwb3J0cy5NQVhfSU5URUdFUiA9IHZvaWQgMDtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbi8qKlxuICogVGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhpcyBWTSBjYW4gaGFuZGxlXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG4vKipcbiAqIDJeMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3Jztcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ybHBoYXNoID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMua2VjY2FrMjU2ID0gZXhwb3J0cy5rZWNjYWsgPSB2b2lkIDA7XG52YXIgX2EgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJyksIGtlY2NhazIyNCA9IF9hLmtlY2NhazIyNCwga2VjY2FrMzg0ID0gX2Eua2VjY2FrMzg0LCBrMjU2ID0gX2Eua2VjY2FrMjU2LCBrZWNjYWs1MTIgPSBfYS5rZWNjYWs1MTI7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgZXRoanNVdGlsID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIHJscCA9IHJlcXVpcmUoXCJybHBcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKSBJZiB0aGUgc3RyaW5nIGlzIGEgMHgtcHJlZml4ZWQgaGV4IHZhbHVlXG4gKiBpdCdzIGludGVycHJldGVkIGFzIGhleGFkZWNpbWFsLCBvdGhlcndpc2UgYXMgdXRmOC5cbiAqIEBwYXJhbSBiaXRzIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICAgIGlmIChiaXRzID09PSB2b2lkIDApIHsgYml0cyA9IDI1NjsgfVxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgJiYgIWV0aGpzVXRpbC5pc0hleFN0cmluZyhhKSkge1xuICAgICAgICBhID0gQnVmZmVyLmZyb20oYSwgJ3V0ZjgnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGEgPSBieXRlc18xLnRvQnVmZmVyKGEpO1xuICAgIH1cbiAgICBpZiAoIWJpdHMpXG4gICAgICAgIGJpdHMgPSAyNTY7XG4gICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICAgIGNhc2UgMjI0OiB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjI0KGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjU2OiB7XG4gICAgICAgICAgICByZXR1cm4gazI1NihhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDM4NDoge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazM4NChhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDUxMjoge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazUxMihhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGQgYWxnb3JpdGhtOiBrZWNjYWtcIiArIGJpdHMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0LCBhbGlhcyBmb3Iga2VjY2FrKGEsIDI1NikuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpXG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoYSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcilcbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEgPSBieXRlc18xLnRvQnVmZmVyKGEpO1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKGEpXG4gICAgICAgIC5kaWdlc3QoKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmV4cG9ydHMucmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgIGEgPSBieXRlc18xLnRvQnVmZmVyKGEpO1xuICAgIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJylcbiAgICAgICAgLnVwZGF0ZShhKVxuICAgICAgICAuZGlnZXN0KCk7XG4gICAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYnl0ZXNfMS5zZXRMZW5ndGgoaGFzaCwgMzIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxufTtcbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhXG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHJscC5lbmNvZGUoYSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IGV4cG9ydHMucmxwID0gZXhwb3J0cy5CTiA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWFkYXB0ZXInKTtcbmV4cG9ydHMuc2VjcDI1NmsxID0gc2VjcDI1NmsxO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbmV4cG9ydHMuQk4gPSBCTjtcbnZhciBybHAgPSByZXF1aXJlKFwicmxwXCIpO1xuZXhwb3J0cy5ybHAgPSBybHA7XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIGV0aGpzVXRpbCk7XG4vKipcbiAqIENvbnN0YW50c1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogUHVibGljLWtleSBjcnlwdG9ncmFwaHkgKHNlY3AyNTZrMSkgYW5kIGFkZHJlc3Nlc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWNjb3VudFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEhhc2ggZnVuY3Rpb25zXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oYXNoXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRUNEU0Egc2lnbmF0dXJlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduYXR1cmVcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBCdWZmZXJzLCBieXRlIGFycmF5cywgZXRjLlxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBGdW5jdGlvbiBmb3IgZGVmaW5pbmluZyBwcm9wZXJ0aWVzIG9uIGFuIG9iamVjdFxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2JqZWN0XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gdm9pZCAwO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBybHAgPSByZXF1aXJlKFwicmxwXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xuICAgIHNlbGYucmF3ID0gW107XG4gICAgc2VsZi5fZmllbGRzID0gW107XG4gICAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICAgIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIGlmIChsYWJlbCA9PT0gdm9pZCAwKSB7IGxhYmVsID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgb2JqXzEgPSB7fTtcbiAgICAgICAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIG9ial8xW2ZpZWxkXSA9IFwiMHhcIiArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9ial8xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlc18xLmJhVG9KU09OKHNlbGYucmF3KTtcbiAgICB9O1xuICAgIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gcmxwLmVuY29kZShzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICAgICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgICAgICAgdiA9IGJ5dGVzXzEudG9CdWZmZXIodik7XG4gICAgICAgICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICAgICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHYgPSBieXRlc18xLnN0cmlwWmVyb3Modik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgXCJUaGUgZmllbGQgXCIgKyBmaWVsZC5uYW1lICsgXCIgbXVzdCBub3QgaGF2ZSBtb3JlIFwiICsgZmllbGQubGVuZ3RoICsgXCIgYnl0ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsIFwiVGhlIGZpZWxkIFwiICsgZmllbGQubmFtZSArIFwiIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiBcIiArIGZpZWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgICAgICBpZiAoZmllbGQuYWxpYXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5hbGlhcywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgdGhlIGNvbnN0dWN0b3IgaXMgcGFzc2VkIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGJ5dGVzXzEudG9CdWZmZXIoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBrZXlzXzEgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzXzEuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzXzEuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLmFsaWFzXSA9IGRhdGFbZmllbGQuYWxpYXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGV4cG9ydHMuZWNkaCA9IGV4cG9ydHMucmVjb3ZlciA9IGV4cG9ydHMudmVyaWZ5ID0gZXhwb3J0cy5zaWduID0gZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBleHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGV4cG9ydHMuc2lnbmF0dXJlRXhwb3J0ID0gZXhwb3J0cy5zaWduYXR1cmVOb3JtYWxpemUgPSBleHBvcnRzLnB1YmxpY0tleUNvbWJpbmUgPSBleHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBleHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeSA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG52YXIgc2VjcDI1NmsxdjMgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWxpYi9pbmRleCcpO1xudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtbGliL2RlcicpO1xuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSk7XG59O1xuLyoqXG4gKiBFeHBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxdjMucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKTtcbiAgICByZXR1cm4gZGVyLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKTtcbn07XG4vKipcbiAqIEltcG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5SW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIC8vIHByaXZhdGVLZXlJbXBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KTtcbiAgICBpZiAocHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIpO1xufTtcbi8qKlxuICogTmVnYXRlIGEgcHJpdmF0ZUtleSBieSBzdWJ0cmFjdGluZyBpdCBmcm9tIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlOZWdhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHByaXZhdGVLZXkgKG1vZHVsbyB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludCkuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlNb2RJbnZlcnNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLnByaXZhdGVLZXlNb2RJbnZlcnNlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IGFkZGluZyB0d2VhayB0byBpdC5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB0d2VhaykpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgYSBwcml2YXRlS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlDcmVhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQ29udmVydCBhIHB1YmxpY0tleSB0byBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBmb3JtLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb252ZXJ0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHB1YmxpY0tleS5cbiAqIEBtZXRob2QgcHVibGljS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLnB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwdWJsaWNLZXkgbGVuZ3RoIGlzIG5vdCAzMyBvciA2NVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbn07XG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IGFkZGluZyB0d2VhayB0aW1lcyB0aGUgZ2VuZXJhdG9yIHRvIGl0LlxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2VhayB2YWx1ZVxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDb21iaW5lID0gZnVuY3Rpb24gKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHB1YmxpY0tleXMuZm9yRWFjaChmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAgICAgIGtleXMucHVzaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKGtleXMsIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBzaWduYXR1cmUgdG8gYSBub3JtYWxpemVkIGxvd2VyLVMgZm9ybS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlTm9ybWFsaXplXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAobm90IGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydExheFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAvLyBzaWduYXR1cmVJbXBvcnRMYXggbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKTtcbiAgICBpZiAoc2lnT2JqID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IHBhcnNlIERFUiBzaWduYXR1cmVcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azF2My5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBFQ0RTQSBzaWduYXR1cmUuIEFsd2F5cyByZXR1cm4gbG93LVMgc2lnbmF0dXJlLlxuICogQG1ldGhvZCBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0Jyk7XG4gICAgfVxuICAgIHZhciBzaWduT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBzaWduT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSBvcHRpb24uZGF0YSBsZW5ndGhcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLmxlbmd0aCAhPSAzMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ25PcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgb3B0aW9uLm5vbmNlZm4gZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICAgICAgICBzaWduT3B0aW9ucy5ub25jZWZuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIGFsZ28sIGRhdGEsIGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyQWxnbyA9IGFsZ28gIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGFsZ28pIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGEgIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGRhdGEpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oJycpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gb3B0aW9ucy5ub25jZWZuKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLCBCdWZmZXIuZnJvbShwcml2YXRlS2V5KSwgYnVmZmVyQWxnbywgYnVmZmVyRGF0YSwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2lnID0gc2VjcDI1NmsxLmVjZHNhU2lnbihVaW50OEFycmF5LmZyb20obWVzc2FnZSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgc2lnbk9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnNpZ25hdHVyZSksXG4gICAgICAgIHJlY292ZXJ5OiBzaWcucmVjaWQsXG4gICAgfTtcbn07XG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5lY2RzYVZlcmlmeShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBwdWJsaWNLZXkpO1xufTtcbi8qKlxuICogUmVjb3ZlciBhbiBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHJlY292ZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gcmVjaWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJlY292ZXIgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNpZCwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkc2FSZWNvdmVyKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCByZWNpZCwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgYXBwbGllZCBzaGEyNTYgdG8gY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICogQG1ldGhvZCBlY2RoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVjZGggPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgLy8gbm90ZTogc2VjcDI1NmsxIHYzIGRvZXNuJ3QgYWxsb3cgb3B0aW9uYWwgcGFyYW1ldGVyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHt9KSk7XG59O1xuZXhwb3J0cy5lY2RoVW5zYWZlID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIC8vIGVjZGhVbnNhZmUgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIC8vIGVuc3VyZSB2YWxpZCBwdWJsaWNLZXkgbGVuZ3RoXG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIC8vIGVuc3VyZSB2YWxpZCBwcml2YXRlS2V5IGxlbmd0aFxuICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5lY2RoVW5zYWZlKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azF2My1hZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgICAvLyBiZWdpblxuICAgIDB4MzAsXG4gICAgMHg4MSxcbiAgICAweGQzLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDQsXG4gICAgMHgyMCxcbiAgICAvLyBwcml2YXRlIGtleVxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAvLyBtaWRkbGVcbiAgICAweGEwLFxuICAgIDB4ODEsXG4gICAgMHg4NSxcbiAgICAweDMwLFxuICAgIDB4ODEsXG4gICAgMHg4MixcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDMwLFxuICAgIDB4MmMsXG4gICAgMHgwNixcbiAgICAweDA3LFxuICAgIDB4MmEsXG4gICAgMHg4NixcbiAgICAweDQ4LFxuICAgIDB4Y2UsXG4gICAgMHgzZCxcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmYyxcbiAgICAweDJmLFxuICAgIDB4MzAsXG4gICAgMHgwNixcbiAgICAweDA0LFxuICAgIDB4MDEsXG4gICAgMHgwMCxcbiAgICAweDA0LFxuICAgIDB4MDEsXG4gICAgMHgwNyxcbiAgICAweDA0LFxuICAgIDB4MjEsXG4gICAgMHgwMixcbiAgICAweDc5LFxuICAgIDB4YmUsXG4gICAgMHg2NixcbiAgICAweDdlLFxuICAgIDB4ZjksXG4gICAgMHhkYyxcbiAgICAweGJiLFxuICAgIDB4YWMsXG4gICAgMHg1NSxcbiAgICAweGEwLFxuICAgIDB4NjIsXG4gICAgMHg5NSxcbiAgICAweGNlLFxuICAgIDB4ODcsXG4gICAgMHgwYixcbiAgICAweDA3LFxuICAgIDB4MDIsXG4gICAgMHg5YixcbiAgICAweGZjLFxuICAgIDB4ZGIsXG4gICAgMHgyZCxcbiAgICAweGNlLFxuICAgIDB4MjgsXG4gICAgMHhkOSxcbiAgICAweDU5LFxuICAgIDB4ZjIsXG4gICAgMHg4MSxcbiAgICAweDViLFxuICAgIDB4MTYsXG4gICAgMHhmOCxcbiAgICAweDE3LFxuICAgIDB4OTgsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGJhLFxuICAgIDB4YWUsXG4gICAgMHhkYyxcbiAgICAweGU2LFxuICAgIDB4YWYsXG4gICAgMHg0OCxcbiAgICAweGEwLFxuICAgIDB4M2IsXG4gICAgMHhiZixcbiAgICAweGQyLFxuICAgIDB4NWUsXG4gICAgMHg4YyxcbiAgICAweGQwLFxuICAgIDB4MzYsXG4gICAgMHg0MSxcbiAgICAweDQxLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4YTEsXG4gICAgMHgyNCxcbiAgICAweDAzLFxuICAgIDB4MjIsXG4gICAgMHgwMCxcbiAgICAvLyBwdWJsaWMga2V5XG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG5dKTtcbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuICAgIC8vIGJlZ2luXG4gICAgMHgzMCxcbiAgICAweDgyLFxuICAgIDB4MDEsXG4gICAgMHgxMyxcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDA0LFxuICAgIDB4MjAsXG4gICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgLy8gbWlkZGxlXG4gICAgMHhhMCxcbiAgICAweDgxLFxuICAgIDB4YTUsXG4gICAgMHgzMCxcbiAgICAweDgxLFxuICAgIDB4YTIsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgzMCxcbiAgICAweDJjLFxuICAgIDB4MDYsXG4gICAgMHgwNyxcbiAgICAweDJhLFxuICAgIDB4ODYsXG4gICAgMHg0OCxcbiAgICAweGNlLFxuICAgIDB4M2QsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDIsXG4gICAgMHgyMSxcbiAgICAweDAwLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmUsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmMsXG4gICAgMHgyZixcbiAgICAweDMwLFxuICAgIDB4MDYsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDAsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDcsXG4gICAgMHgwNCxcbiAgICAweDQxLFxuICAgIDB4MDQsXG4gICAgMHg3OSxcbiAgICAweGJlLFxuICAgIDB4NjYsXG4gICAgMHg3ZSxcbiAgICAweGY5LFxuICAgIDB4ZGMsXG4gICAgMHhiYixcbiAgICAweGFjLFxuICAgIDB4NTUsXG4gICAgMHhhMCxcbiAgICAweDYyLFxuICAgIDB4OTUsXG4gICAgMHhjZSxcbiAgICAweDg3LFxuICAgIDB4MGIsXG4gICAgMHgwNyxcbiAgICAweDAyLFxuICAgIDB4OWIsXG4gICAgMHhmYyxcbiAgICAweGRiLFxuICAgIDB4MmQsXG4gICAgMHhjZSxcbiAgICAweDI4LFxuICAgIDB4ZDksXG4gICAgMHg1OSxcbiAgICAweGYyLFxuICAgIDB4ODEsXG4gICAgMHg1YixcbiAgICAweDE2LFxuICAgIDB4ZjgsXG4gICAgMHgxNyxcbiAgICAweDk4LFxuICAgIDB4NDgsXG4gICAgMHgzYSxcbiAgICAweGRhLFxuICAgIDB4NzcsXG4gICAgMHgyNixcbiAgICAweGEzLFxuICAgIDB4YzQsXG4gICAgMHg2NSxcbiAgICAweDVkLFxuICAgIDB4YTQsXG4gICAgMHhmYixcbiAgICAweGZjLFxuICAgIDB4MGUsXG4gICAgMHgxMSxcbiAgICAweDA4LFxuICAgIDB4YTgsXG4gICAgMHhmZCxcbiAgICAweDE3LFxuICAgIDB4YjQsXG4gICAgMHg0OCxcbiAgICAweGE2LFxuICAgIDB4ODUsXG4gICAgMHg1NCxcbiAgICAweDE5LFxuICAgIDB4OWMsXG4gICAgMHg0NyxcbiAgICAweGQwLFxuICAgIDB4OGYsXG4gICAgMHhmYixcbiAgICAweDEwLFxuICAgIDB4ZDQsXG4gICAgMHhiOCxcbiAgICAweDAyLFxuICAgIDB4MjEsXG4gICAgMHgwMCxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZlLFxuICAgIDB4YmEsXG4gICAgMHhhZSxcbiAgICAweGRjLFxuICAgIDB4ZTYsXG4gICAgMHhhZixcbiAgICAweDQ4LFxuICAgIDB4YTAsXG4gICAgMHgzYixcbiAgICAweGJmLFxuICAgIDB4ZDIsXG4gICAgMHg1ZSxcbiAgICAweDhjLFxuICAgIDB4ZDAsXG4gICAgMHgzNixcbiAgICAweDQxLFxuICAgIDB4NDEsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHhhMSxcbiAgICAweDQ0LFxuICAgIDB4MDMsXG4gICAgMHg0MixcbiAgICAweDAwLFxuICAgIC8vIHB1YmxpYyBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG5dKTtcbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpO1xuICAgIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gICAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgdmFyIGxlbmd0aCA9IHByaXZhdGVLZXkubGVuZ3RoO1xuICAgIC8vIHNlcXVlbmNlIGhlYWRlclxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgzMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaW5kZXggKz0gMTtcbiAgICAvLyBzZXF1ZW5jZSBsZW5ndGggY29uc3RydWN0b3JcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gICAgaW5kZXggKz0gMTtcbiAgICBpZiAobGVuYiA8IDEgfHwgbGVuYiA+IDIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNlcXVlbmNlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDFdIHwgKGxlbmIgPiAxID8gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAyXSA8PCA4IDogMCk7XG4gICAgaW5kZXggKz0gbGVuYjtcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICAgIGlmIChsZW5ndGggPCBpbmRleCArIDMgfHxcbiAgICAgICAgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHxcbiAgICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdICE9PSAweDAxIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAyXSAhPT0gMHgwMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaW5kZXggKz0gMztcbiAgICAvLyBzZXF1ZW5jZSBlbGVtZW50IDE6IG9jdGV0IHN0cmluZywgdXAgdG8gMzIgYnl0ZXNcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHxcbiAgICAgICAgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICB2YXIgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIC8vIHNlcXVlbmNlIHRhZyBieXRlXG4gICAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgICB2YXIgbGVuYnl0ZSA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAobGVuYnl0ZSAmIDB4ODApIHtcbiAgICAgICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODA7XG4gICAgICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBsZW5ndGggZm9yIHJcbiAgICB2YXIgcmxlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICAgICAgbGVuYnl0ZSA9IHJsZW4gLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICBmb3IgKHJsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJpbmRleCA9IGluZGV4O1xuICAgIGluZGV4ICs9IHJsZW47XG4gICAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHNcbiAgICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBsZW5ndGggZm9yIHNcbiAgICB2YXIgc2xlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAoc2xlbiAmIDB4ODApIHtcbiAgICAgICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKHNsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNpbmRleCA9IGluZGV4O1xuICAgIGluZGV4ICs9IHNsZW47XG4gICAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gclxuICAgIGZvciAoOyBybGVuID4gMCAmJiBzaWduYXR1cmVbcmluZGV4XSA9PT0gMHgwMDsgcmxlbiAtPSAxLCByaW5kZXggKz0gMSlcbiAgICAgICAgO1xuICAgIC8vIGNvcHkgciB2YWx1ZVxuICAgIGlmIChybGVuID4gMzIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgICBydmFsdWUuY29weShyLCAzMiAtIHJ2YWx1ZS5sZW5ndGgpO1xuICAgIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgICBmb3IgKDsgc2xlbiA+IDAgJiYgc2lnbmF0dXJlW3NpbmRleF0gPT09IDB4MDA7IHNsZW4gLT0gMSwgc2luZGV4ICs9IDEpXG4gICAgICAgIDtcbiAgICAvLyBjb3B5IHMgdmFsdWVcbiAgICBpZiAoc2xlbiA+IDMyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gICAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4geyByOiByLCBzOiBzIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWM7XG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIGlmIChjb21wcmVzc2VkID09PSB2b2lkIDApIHsgY29tcHJlc3NlZCA9IHRydWU7IH1cbiAgICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXRcIik7XG4gICAgfVxuICAgIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICAgIHJldHVybiB0b1B1YmxpY0tleShwb2ludC5nZXRYKCksIHBvaW50LmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICAgIGlmIChibi51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSByYW5nZSBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpO1xufTtcbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gKHNpZ09iaikge1xuICAgIHZhciByID0gbmV3IEJOKHNpZ09iai5yKTtcbiAgICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICAgICAgciA9IG5ldyBCTigwKTtcbiAgICB9XG4gICAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICAgIGlmIChzLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgICAgICBzID0gbmV3IEJOKDApO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbci50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSwgcy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKV0pO1xufTtcbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuICAgIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gICAgaWYgKHNjYWxhci51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICAgIH1cbiAgICB2YXIgc2hhcmVkID0gcG9pbnQucHViLm11bChzY2FsYXIpO1xuICAgIHJldHVybiB0b1B1YmxpY0tleShzaGFyZWQuZ2V0WCgpLCBzaGFyZWQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG52YXIgdG9QdWJsaWNLZXkgPSBmdW5jdGlvbiAoeCwgeSwgY29tcHJlc3NlZCkge1xuICAgIHZhciBwdWJsaWNLZXk7XG4gICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICAgICAgcHVibGljS2V5WzBdID0geS5pc09kZCgpID8gMHgwMyA6IDB4MDI7XG4gICAgICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDY1KTtcbiAgICAgICAgcHVibGljS2V5WzBdID0gMHgwNDtcbiAgICAgICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgICAgIHkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDMzKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGV4cG9ydHMuZnJvbVJwY1NpZyA9IGV4cG9ydHMudG9ScGNTaWcgPSBleHBvcnRzLmVjcmVjb3ZlciA9IGV4cG9ydHMuZWNzaWduID0gdm9pZCAwO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtYWRhcHRlcicpO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBFQ0RTQSBzaWduYXR1cmUgb2YgYSBtZXNzYWdlIGhhc2guXG4gKi9cbmV4cG9ydHMuZWNzaWduID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHByaXZhdGVLZXksIGNoYWluSWQpIHtcbiAgICB2YXIgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgdmFyIHJlY292ZXJ5ID0gc2lnLnJlY292ZXJ5O1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIHI6IHNpZy5zaWduYXR1cmUuc2xpY2UoMCwgMzIpLFxuICAgICAgICBzOiBzaWcuc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCksXG4gICAgICAgIHY6IGNoYWluSWQgPyByZWNvdmVyeSArIChjaGFpbklkICogMiArIDM1KSA6IHJlY292ZXJ5ICsgMjcsXG4gICAgfTtcbiAgICByZXR1cm4gcmV0O1xufTtcbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFJlY292ZXJlZCBwdWJsaWMga2V5XG4gKi9cbmV4cG9ydHMuZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbYnl0ZXNfMS5zZXRMZW5ndGgociwgMzIpLCBieXRlc18xLnNldExlbmd0aChzLCAzMildLCA2NCk7XG4gICAgdmFyIHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICB2YXIgc2VuZGVyUHViS2V5ID0gc2VjcDI1NmsxLnJlY292ZXIobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSk7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgYGV0aF9zaWduYCBSUEMgbWV0aG9kLlxuICogQHJldHVybnMgU2lnbmF0dXJlXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xuICAgIHZhciByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgICByZXR1cm4gYnl0ZXNfMS5idWZmZXJUb0hleChCdWZmZXIuY29uY2F0KFtieXRlc18xLnNldExlbmd0aExlZnQociwgMzIpLCBieXRlc18xLnNldExlbmd0aExlZnQocywgMzIpLCBieXRlc18xLnRvQnVmZmVyKHYpXSkpO1xufTtcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICovXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoc2lnKTtcbiAgICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICAgIGlmIChidWYubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICAgIH1cbiAgICB2YXIgdiA9IGJ1Zls2NF07XG4gICAgLy8gc3VwcG9ydCBib3RoIHZlcnNpb25zIG9mIGBldGhfc2lnbmAgcmVzcG9uc2VzXG4gICAgaWYgKHYgPCAyNykge1xuICAgICAgICB2ICs9IDI3O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2OiB2LFxuICAgICAgICByOiBidWYuc2xpY2UoMCwgMzIpLFxuICAgICAgICBzOiBidWYuc2xpY2UoMzIsIDY0KSxcbiAgICB9O1xufTtcbi8qKlxuICogVmFsaWRhdGUgYSBFQ0RTQSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gaG9tZXN0ZWFkT3JMYXRlciBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGJlaW5nIHVzZWQgb24gZWl0aGVyIHRoZSBob21lc3RlYWQgaGFyZGZvcmsgb3IgYSBsYXRlciBvbmVcbiAqL1xuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZE9yTGF0ZXIsIGNoYWluSWQpIHtcbiAgICBpZiAoaG9tZXN0ZWFkT3JMYXRlciA9PT0gdm9pZCAwKSB7IGhvbWVzdGVhZE9yTGF0ZXIgPSB0cnVlOyB9XG4gICAgdmFyIFNFQ1AyNTZLMV9OX0RJVl8yID0gbmV3IEJOKCc3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjVkNTc2ZTczNTdhNDUwMWRkZmU5MmY0NjY4MWIyMGEwJywgMTYpO1xuICAgIHZhciBTRUNQMjU2SzFfTiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcbiAgICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByQk4gPSBuZXcgQk4ocik7XG4gICAgdmFyIHNCTiA9IG5ldyBCTihzKTtcbiAgICBpZiAockJOLmlzWmVybygpIHx8IHJCTi5ndChTRUNQMjU2SzFfTikgfHwgc0JOLmlzWmVybygpIHx8IHNCTi5ndChTRUNQMjU2SzFfTikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaG9tZXN0ZWFkT3JMYXRlciAmJiBzQk4uY21wKFNFQ1AyNTZLMV9OX0RJVl8yKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUga2VjY2FrLTI1NiBoYXNoIG9mIGBtZXNzYWdlYCwgcHJlZml4ZWQgd2l0aCB0aGUgaGVhZGVyIHVzZWQgYnkgdGhlIGBldGhfc2lnbmAgUlBDIGNhbGwuXG4gKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGZlZCBpbnRvIGBlY3NpZ25gIHRvIHByb2R1Y2UgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIHRoZSBgZXRoX3NpZ25gXG4gKiBjYWxsIGZvciBhIGdpdmVuIGBtZXNzYWdlYCwgb3IgZmVkIHRvIGBlY3JlY292ZXJgIGFsb25nIHdpdGggYSBzaWduYXR1cmUgdG8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICogdXNlZCB0byBwcm9kdWNlIHRoZSBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdmFyIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFwiXFx1MDAxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiICsgbWVzc2FnZS5sZW5ndGgudG9TdHJpbmcoKSwgJ3V0Zi04Jyk7XG4gICAgcmV0dXJuIGhhc2hfMS5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpIHtcbiAgICByZXR1cm4gY2hhaW5JZCA/IHYgLSAoMiAqIGNoYWluSWQgKyAzNSkgOiB2IC0gMjc7XG59XG5mdW5jdGlvbiBpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpIHtcbiAgICByZXR1cm4gcmVjb3ZlcnkgPT09IDAgfHwgcmVjb3ZlcnkgPT09IDE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1cbiAgXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgV2FsbGV0ID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xudmFyIGV0aFV0aWwgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBzY3J5cHRzeSA9IHJlcXVpcmUoJ3NjcnlwdHN5Jyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcbnZhciBhZXNqcyA9IHJlcXVpcmUoJ2Flcy1qcycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuQ2lwaGVyQnVmZmVyKGNpcGhlciwgZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhKSwgY2lwaGVyLmZpbmFsKCldKTtcbn1cblxudmFyIFRoaXJkcGFydHkgPSB7fTtcblxuLypcbiAqIG9wdHM6XG4gKiAtIGRpZ2VzdCAtIGRpZ2VzdCBhbGdvcml0aG0sIGRlZmF1bHRzIHRvIG1kNVxuICogLSBjb3VudCAtIGhhc2ggaXRlcmF0aW9uc1xuICogLSBrZXlzaXplIC0gZGVzaXJlZCBrZXkgc2l6ZVxuICogLSBpdnNpemUgLSBkZXNpcmVkIElWIHNpemVcbiAqXG4gKiBBbGdvcml0aG0gZm9ybSBodHRwczovL3d3dy5vcGVuc3NsLm9yZy9kb2NzL21hbm1hc3Rlci9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEZJWE1FOiBub3Qgb3B0aW1pc2VkIGF0IGFsbFxuICovXG5mdW5jdGlvbiBldnBfa2RmKGRhdGEsIHNhbHQsIG9wdHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAvLyBBIHNpbmdsZSBFVlAgaXRlcmF0aW9uLCByZXR1cm5zIGBEX2lgLCB3aGVyZSBibG9jayBlcXVsYXMgdG8gYERfKGktMSlgXG4gIGZ1bmN0aW9uIGl0ZXIoYmxvY2spIHtcbiAgICB2YXIgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKG9wdHMuZGlnZXN0IHx8ICdtZDUnKTtcbiAgICBoYXNoLnVwZGF0ZShibG9jayk7XG4gICAgaGFzaC51cGRhdGUoZGF0YSk7XG4gICAgaGFzaC51cGRhdGUoc2FsdCk7XG4gICAgYmxvY2sgPSBoYXNoLmRpZ2VzdCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAob3B0cy5jb3VudCB8fCAxKTsgaSsrKSB7XG4gICAgICBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2gob3B0cy5kaWdlc3QgfHwgJ21kNScpO1xuICAgICAgaGFzaC51cGRhdGUoYmxvY2spO1xuICAgICAgYmxvY2sgPSBoYXNoLmRpZ2VzdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIHZhciBrZXlzaXplID0gb3B0cy5rZXlzaXplIHx8IDE2O1xuICB2YXIgaXZzaXplID0gb3B0cy5pdnNpemUgfHwgMTY7XG5cbiAgdmFyIHJldCA9IFtdO1xuXG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKEJ1ZmZlci5jb25jYXQocmV0KS5sZW5ndGggPCBrZXlzaXplICsgaXZzaXplKSB7XG4gICAgcmV0W2ldID0gaXRlcihpID09PSAwID8gQnVmZmVyLmFsbG9jKDApIDogcmV0W2kgLSAxXSk7XG4gICAgaSsrO1xuICB9XG5cbiAgdmFyIHRtcCA9IEJ1ZmZlci5jb25jYXQocmV0KTtcblxuICByZXR1cm4ge1xuICAgIGtleTogdG1wLnNsaWNlKDAsIGtleXNpemUpLFxuICAgIGl2OiB0bXAuc2xpY2Uoa2V5c2l6ZSwga2V5c2l6ZSArIGl2c2l6ZSlcbiAgfTtcbn1cblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTI4ODMxMS9jcnlwdG9qcy1hZXMtcGF0dGVybi1hbHdheXMtZW5kcy13aXRoXG5mdW5jdGlvbiBkZWNvZGVDcnlwdG9qc1NhbHQoaW5wdXQpIHtcbiAgdmFyIGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpO1xuICBpZiAoY2lwaGVydGV4dC5zbGljZSgwLCA4KS50b1N0cmluZygpID09PSAnU2FsdGVkX18nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbHQ6IGNpcGhlcnRleHQuc2xpY2UoOCwgMTYpLFxuICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dC5zbGljZSgxNilcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0XG4gICAgfTtcbiAgfVxufVxuXG4vKlxuICogVGhpcyB3YWxsZXQgZm9ybWF0IGlzIGNyZWF0ZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL1NpbGVudENpY2Vyby9ldGhlcmV1bWpzLWFjY291bnRzXG4gKiBhbmQgdXNlZCBvbiBodHRwczovL3d3dy5teWV0aGVyd2FsbGV0LmNvbS9cbiAqL1xuVGhpcmRwYXJ0eS5mcm9tRXRoZXJXYWxsZXQgPSBmdW5jdGlvbiAoaW5wdXQsIHBhc3N3b3JkKSB7XG4gIHZhciBqc29uID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpKSA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2UoaW5wdXQpO1xuXG4gIHZhciBwcml2S2V5O1xuICBpZiAoIWpzb24ubG9ja2VkKSB7XG4gICAgaWYgKGpzb24ucHJpdmF0ZS5sZW5ndGggIT09IDY0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXkgbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgcHJpdktleSA9IEJ1ZmZlci5mcm9tKGpzb24ucHJpdmF0ZSwgJ2hleCcpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCA3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgNyBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gdGhlIFwiZW5jcnlwdGVkXCIgdmVyc2lvbiBoYXMgdGhlIGxvdyA0IGJ5dGVzXG4gICAgLy8gb2YgdGhlIGhhc2ggb2YgdGhlIGFkZHJlc3MgYXBwZW5kZWRcbiAgICB2YXIgY2lwaGVyID0ganNvbi5lbmNyeXB0ZWQgPyBqc29uLnByaXZhdGUuc2xpY2UoMCwgMTI4KSA6IGpzb24ucHJpdmF0ZTtcblxuICAgIC8vIGRlY29kZSBvcGVuc3NsIGNpcGhlcnRleHQgKyBzYWx0IGVuY29kaW5nXG4gICAgY2lwaGVyID0gZGVjb2RlQ3J5cHRvanNTYWx0KGNpcGhlcik7XG5cbiAgICBpZiAoIWNpcGhlci5zYWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEV0aGVyV2FsbGV0IGtleSBmb3JtYXQnKTtcbiAgICB9XG5cbiAgICAvLyBkZXJpdmUga2V5L2l2IHVzaW5nIE9wZW5TU0wgRVZQIGFzIGltcGxlbWVudGVkIGluIENyeXB0b0pTXG4gICAgdmFyIGV2cCA9IGV2cF9rZGYoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBjaXBoZXIuc2FsdCwgeyBrZXlzaXplOiAzMiwgaXZzaXplOiAxNiB9KTtcblxuICAgIHZhciBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMjU2LWNiYycsIGV2cC5rZXksIGV2cC5pdik7XG4gICAgcHJpdktleSA9IHJ1bkNpcGhlckJ1ZmZlcihkZWNpcGhlciwgQnVmZmVyLmZyb20oY2lwaGVyLmNpcGhlcnRleHQpKTtcblxuICAgIC8vIE5PVEU6IHllcywgdGhleSd2ZSBydW4gaXQgdGhyb3VnaCBVVEY4XG4gICAgcHJpdktleSA9IEJ1ZmZlci5mcm9tKHV0ZjguZGVjb2RlKHByaXZLZXkudG9TdHJpbmcoKSksICdoZXgnKTtcbiAgfVxuXG4gIHZhciB3YWxsZXQgPSBuZXcgV2FsbGV0KHByaXZLZXkpO1xuXG4gIGlmICh3YWxsZXQuZ2V0QWRkcmVzc1N0cmluZygpICE9PSBqc29uLmFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXkgb3IgYWRkcmVzcycpO1xuICB9XG5cbiAgcmV0dXJuIHdhbGxldDtcbn07XG5cblRoaXJkcGFydHkuZnJvbUV0aGVyQ2FtcCA9IGZ1bmN0aW9uIChwYXNzcGhyYXNlKSB7XG4gIHJldHVybiBuZXcgV2FsbGV0KGV0aFV0aWwua2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHBhc3NwaHJhc2UpKSk7XG59O1xuXG5UaGlyZHBhcnR5LmZyb21LcnlwdG9LaXQgPSBmdW5jdGlvbiAoZW50cm9weSwgcGFzc3dvcmQpIHtcbiAgZnVuY3Rpb24ga3J5cHRvS2l0QnJva2VuU2NyeXB0U2VlZChidWYpIHtcbiAgICAvLyBqcy1zY3J5cHQgY2FsbHMgYEJ1ZmZlci5mcm9tKFN0cmluZyhzYWx0KSwgJ3V0ZjgnKWAgb24gdGhlIHNlZWQgZXZlbiB0aG91Z2ggaXQgaXMgYSBidWZmZXJcbiAgICAvL1xuICAgIC8vIFRoZSBgYnVmZmVyYGAgaW1wbGVtZW50YXRpb24gdXNlZCBkb2VzIHRoZSBiZWxvdyB0cmFuc2Zvcm1hdGlvbiAoZG9lc24ndCBtYXRjaGVzIHRoZSBjdXJyZW50IHZlcnNpb24pOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjdjNjExODFiOTM4YjE3ZDEwZGJmYzBhNTQ1ZjcxM2I4YmQ1OWRlOC9pbmRleC5qc1xuXG4gICAgZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIoc3RyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHZhciB0bXAgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgIHRtcCA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCkpO1xuICB9XG5cbiAgaWYgKGVudHJvcHlbMF0gPT09ICcjJykge1xuICAgIGVudHJvcHkgPSBlbnRyb3B5LnNsaWNlKDEpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbnRyb3B5WzBdO1xuICBlbnRyb3B5ID0gZW50cm9weS5zbGljZSgxKTtcblxuICB2YXIgcHJpdktleTtcbiAgaWYgKHR5cGUgPT09ICdkJykge1xuICAgIHByaXZLZXkgPSBldGhVdGlsLnNoYTI1NihCdWZmZXIuZnJvbShlbnRyb3B5KSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3EnKSB7XG4gICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgZW5jcnlwdGVkU2VlZCA9IGV0aFV0aWwuc2hhMjU2KEJ1ZmZlci5mcm9tKGVudHJvcHkuc2xpY2UoMCwgMzApKSk7XG4gICAgdmFyIGNoZWNrc3VtID0gZW50cm9weS5zbGljZSgzMCwgNDYpO1xuXG4gICAgdmFyIHNhbHQgPSBrcnlwdG9LaXRCcm9rZW5TY3J5cHRTZWVkKGVuY3J5cHRlZFNlZWQpO1xuICAgIHZhciBhZXNLZXkgPSBzY3J5cHRzeShCdWZmZXIuZnJvbShwYXNzd29yZCwgJ3V0ZjgnKSwgc2FsdCwgMTYzODQsIDgsIDEsIDMyKTtcblxuICAgIC8qIEZJWE1FOiB0cnkgdG8gdXNlIGBjcnlwdG9gIGluc3RlYWQgb2YgYGFlc2pzYFxuICAgICAvLyBOT1RFOiBFQ0IgZG9lc24ndCB1c2UgdGhlIElWLCBzbyBpdCBjYW4gYmUgYW55dGhpbmdcbiAgICB2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtZWNiXCIsIGFlc0tleSwgQnVmZmVyLmZyb20oMCkpXG4gICAgIC8vIEZJWE1FOiB0aGlzIGlzIGEgY2xlYXIgYWJ1c2UsIGJ1dCBzZWVtcyB0byBtYXRjaCBob3cgRUNCIGluIGFlc2pzIHdvcmtzXG4gICAgcHJpdktleSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgZGVjaXBoZXIudXBkYXRlKGVuY3J5cHRlZFNlZWQpLnNsaWNlKDAsIDE2KSxcbiAgICAgIGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWRTZWVkKS5zbGljZSgwLCAxNiksXG4gICAgXSlcbiAgICAqL1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICAgIHZhciBkZWNpcGhlciA9IG5ldyBhZXNqcy5Nb2RlT2ZPcGVyYXRpb24uZWNiKGFlc0tleSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuZXctY2FwICovXG4gICAgLyogZGVjcnlwdCByZXR1cm5zIGFuIFVpbnQ4QXJyYXksIHBlcmhhcHMgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIGNvbmNhdGVuYXRlICovXG4gICAgcHJpdktleSA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKGRlY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkU2VlZC5zbGljZSgwLCAxNikpKSwgQnVmZmVyLmZyb20oZGVjaXBoZXIuZGVjcnlwdChlbmNyeXB0ZWRTZWVkLnNsaWNlKDE2LCAzMikpKV0pO1xuXG4gICAgaWYgKGNoZWNrc3VtLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChjaGVja3N1bSAhPT0gZXRoVXRpbC5zaGEyNTYoZXRoVXRpbC5zaGEyNTYocHJpdktleSkpLnNsaWNlKDAsIDgpLnRvU3RyaW5nKCdoZXgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGlucHV0IC0gcG9zc2libHkgaW52YWxpZCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCBlbnRyb3B5IHR5cGUnKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgV2FsbGV0KHByaXZLZXkpO1xufTtcblxuVGhpcmRwYXJ0eS5mcm9tUXVvcnVtV2FsbGV0ID0gZnVuY3Rpb24gKHBhc3NwaHJhc2UsIHVzZXJpZCkge1xuICBhc3NlcnQocGFzc3BocmFzZS5sZW5ndGggPj0gMTApO1xuICBhc3NlcnQodXNlcmlkLmxlbmd0aCA+PSAxMCk7XG5cbiAgdmFyIHNlZWQgPSBwYXNzcGhyYXNlICsgdXNlcmlkO1xuICBzZWVkID0gY3J5cHRvLnBia2RmMlN5bmMoc2VlZCwgc2VlZCwgMjAwMCwgMzIsICdzaGEyNTYnKTtcblxuICByZXR1cm4gbmV3IFdhbGxldChzZWVkKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGhpcmRwYXJ0eTsiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGVscGVyc19qc18xID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKTtcbmV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSBoZWxwZXJzX2pzXzEuUGF0Y2hFcnJvcjtcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc19qc18xLl9kZWVwQ2xvbmU7XG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxuIGZ1bmN0aW9uLiBFYWNoIGhhc2ggZW50cnkgKHByb3BlcnR5KSB1c2VzXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxuIHRvIGl0cyBkZWRpY2F0ZWQgZnVuY3Rpb24gaW4gZWZmaWNpZW50IHdheS5cbiAqL1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cbnZhciBvYmpPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgLyogaW4gY2FzZSBtb3ZlIHRhcmdldCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHZhbHVlLFxuICAgICAgICByZXR1cm4gdGhlIHJlbW92ZWQgdmFsdWUsIHRoaXMgY2FuIGJlIHRheGluZyBwZXJmb3JtYW5jZS13aXNlLFxuICAgICAgICBhbmQgaXMgcG90ZW50aWFsbHkgdW5uZWVkZWQgKi9cbiAgICAgICAgdmFyIHJlbW92ZWQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiB0aGlzLmZyb20gfSkucmVtb3ZlZDtcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwiYWRkXCIsIHBhdGg6IHRoaXMucGF0aCwgdmFsdWU6IG9yaWdpbmFsVmFsdWUgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwiYWRkXCIsIHBhdGg6IHRoaXMucGF0aCwgdmFsdWU6IGhlbHBlcnNfanNfMS5fZGVlcENsb25lKHZhbHVlVG9Db3B5KSB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogX2FyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9XG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaGVscGVyc19qc18xLmlzSW50ZWdlcihpKSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXRcbn07XG4vKipcbiAqIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gYSBKU09OIGRvY3VtZW50IGJ5IGEgSlNPTiBwb2ludGVyLlxuICogUmV0dXJucyB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBnZXQgdGhlIHZhbHVlIGZyb21cbiAqIEBwYXJhbSBwb2ludGVyIGFuIGVzY2FwZWQgSlNPTiBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSByZXRyaWV2ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHBvaW50ZXIpIHtcbiAgICBpZiAocG9pbnRlciA9PSAnJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBnZXRPcmlnaW5hbERlc3RpbmF0aW9uID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IHBvaW50ZXIgfTtcbiAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbik7XG4gICAgcmV0dXJuIGdldE9yaWdpbmFsRGVzdGluYXRpb24udmFsdWU7XG59XG5leHBvcnRzLmdldFZhbHVlQnlQb2ludGVyID0gZ2V0VmFsdWVCeVBvaW50ZXI7XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgb3BlcmF0aW9uLlxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgYW5kIGBvcGVyYXRpb25gIG9iamVjdHMgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShvcGVyYXRpb24pKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xuICogQHBhcmFtIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgV2hldGhlciB0byBiYW4gbW9kaWZpY2F0aW9ucyB0byBgX19wcm90b19fYCwgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogQHJldHVybiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24sIHZhbGlkYXRlT3BlcmF0aW9uLCBtdXRhdGVEb2N1bWVudCwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaW5kZXgpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gPT09IHZvaWQgMCkgeyB2YWxpZGF0ZU9wZXJhdGlvbiA9IGZhbHNlOyB9XG4gICAgaWYgKG11dGF0ZURvY3VtZW50ID09PSB2b2lkIDApIHsgbXV0YXRlRG9jdW1lbnQgPSB0cnVlOyB9XG4gICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPT09IHZvaWQgMCkgeyBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZTsgfVxuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlT3BlcmF0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIG9wZXJhdGlvbi5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihvcGVyYXRpb24sIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGlmIChvcGVyYXRpb24ucGF0aCA9PT0gXCJcIikge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSAnYWRkJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50OyAvL2RvY3VtZW50IHdlIHJlbW92ZWRcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgeyAvLyBpdCdzIGEgbW92ZSBvciBjb3B5IHRvIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIG9wZXJhdGlvbi5mcm9tKTsgLy8gZ2V0IHRoZSB2YWx1ZSBieSBqc29uLXBvaW50ZXIgaW4gYGZyb21gIGZpZWxkXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScpIHsgLy8gcmVwb3J0IHJlbW92ZWQgaXRlbVxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICd0ZXN0Jykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUudGVzdCA9IF9hcmVFcXVhbHMoZG9jdW1lbnQsIG9wZXJhdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnKSB7IC8vIGEgcmVtb3ZlIG9uIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8qIGJhZCBvcGVyYXRpb24gKi9cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IGhlbHBlcnNfanNfMS5fZGVlcENsb25lKGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XG4gICAgICAgIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQ7XG4gICAgICAgIHZhciB0ID0gMTsgLy9za2lwIGVtcHR5IGVsZW1lbnQgLSBodHRwOi8vanNwZXJmLmNvbS90by1zaGlmdC1vci1ub3QtdG8tc2hpZnRcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICB2YXIgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgIHZhciB2YWxpZGF0ZUZ1bmN0aW9uID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XG4gICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKCd+JykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBoZWxwZXJzX2pzXzEudW5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyAmJlxuICAgICAgICAgICAgICAgIChrZXkgPT0gJ19fcHJvdG9fXycgfHxcbiAgICAgICAgICAgICAgICAgICAgKGtleSA9PSAncHJvdG90eXBlJyAmJiB0ID4gMCAmJiBrZXlzW3QgLSAxXSA9PSAnY29uc3RydWN0b3InKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2Agb3IgYGNvbnN0cnVjdG9yL3Byb3RvdHlwZWAgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgIWhlbHBlcnNfanNfMS5pc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIG9ubHkgcGFyc2Uga2V5IHdoZW4gaXQncyBhbiBpbnRlZ2VyIGZvciBgYXJyLnByb3BgIHRvIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVscGVyc19qc18xLmlzSW50ZWdlcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiAmJiBrZXkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFyck9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBrZXlzIGluIHRoZSBwYXRoLCBidXQgdGhlIG5leHQgdmFsdWUgaXNuJ3QgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUgZXJyb3IgaW5zdGVhZCBvZiBpdGVyYXRpbmcgYWdhaW4uXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgdCA8IGxlbiAmJiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gYXBwbHlPcGVyYXRpb247XG4vKipcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgcGF0Y2guXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5UGF0Y2goZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKHBhdGNoKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBwYXRjaCBUaGUgcGF0Y2ggdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBwYXRjaFxuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50LCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zKSB7XG4gICAgaWYgKG11dGF0ZURvY3VtZW50ID09PSB2b2lkIDApIHsgbXV0YXRlRG9jdW1lbnQgPSB0cnVlOyB9XG4gICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPT09IHZvaWQgMCkgeyBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZTsgfVxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gaGVscGVyc19qc18xLl9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IHBhdGNoLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG11dGF0ZURvY3VtZW50IGFyZ3VtZW50IGJlY2F1c2UgaWYgaXQgd2FzIHRydWUsIHdlIGFscmVhZHkgZGVlcCBjbG9uZWQgdGhlIG9iamVjdCwgd2UnbGwganVzdCBwYXNzIGB0cnVlYFxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaSk7XG4gICAgICAgIGRvY3VtZW50ID0gcmVzdWx0c1tpXS5uZXdEb2N1bWVudDsgLy8gaW4gY2FzZSByb290IHdhcyByZXBsYWNlZFxuICAgIH1cbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxuICogU3VpdGFibGUgYXMgYSByZWR1Y2VyLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICB2YXIgb3BlcmF0aW9uUmVzdWx0ID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbik7XG4gICAgaWYgKG9wZXJhdGlvblJlc3VsdC50ZXN0ID09PSBmYWxzZSkgeyAvLyBmYWlsZWQgdGVzdFxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xufVxuZXhwb3J0cy5hcHBseVJlZHVjZXIgPSBhcHBseVJlZHVjZXI7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5mdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gIT09ICdvYmplY3QnIHx8IG9wZXJhdGlvbiA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0JywgJ09QRVJBVElPTl9OT1RfQU5fT0JKRUNUJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqT3BzW29wZXJhdGlvbi5vcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3BlcmF0aW9uLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IGlzIG5vdCBhIHN0cmluZycsICdPUEVSQVRJT05fUEFUSF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5pbmRleE9mKCcvJykgIT09IDAgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgJiYgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fRlJPTV9SRVFVSVJFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnYWRkJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICd0ZXN0JykgJiYgaGVscGVyc19qc18xLmhhc1VuZGVmaW5lZChvcGVyYXRpb24udmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSBhbiBgYWRkYCBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aCcsICdPUEVSQVRJT05fUEFUSF9DQU5OT1RfQUREJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnX2dldCcpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IG9wZXJhdGlvbi5mcm9tLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGZyb20gYSBwYXRoIHRoYXQgZG9lcyBub3QgZXhpc3QnLCAnT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxuICogQHBhcmFtIHNlcXVlbmNlXG4gKiBAcGFyYW0gZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgYXBwbHlQYXRjaChoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShkb2N1bWVudCksIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBleHBvcnRzLkpzb25QYXRjaEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXBvYmVyZXpraW4vZmFzdC1kZWVwLWVxdWFsXG4vLyBNSVQgTGljZW5zZVxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEV2Z2VueSBQb2JlcmV6a2luXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4vLyBTT0ZUV0FSRS5cbmZ1bmN0aW9uIF9hcmVFcXVhbHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksIGksIGxlbmd0aCwga2V5O1xuICAgICAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckEgIT0gYXJyQilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5leHBvcnRzLl9hcmVFcXVhbHMgPSBfYXJlRXF1YWxzO1xuO1xuIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNy0yMDIxIEpvYWNoaW0gV2VzdGVyXG4gKiBNSVQgbGljZW5zZVxuICovXG52YXIgaGVscGVyc19qc18xID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKTtcbnZhciBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xudmFyIGJlZm9yZURpY3QgPSBuZXcgV2Vha01hcCgpO1xudmFyIE1pcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaXJyb3Iob2JqKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB9XG4gICAgcmV0dXJuIE1pcnJvcjtcbn0oKSk7XG52YXIgT2JzZXJ2ZXJJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlckluZm87XG59KCkpO1xuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xuICAgIHJldHVybiBiZWZvcmVEaWN0LmdldChvYmopO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWlycm9yLm9ic2VydmVycy5nZXQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpIHtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlci5jYWxsYmFjayk7XG59XG4vKipcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbmV4cG9ydHMudW5vYnNlcnZlID0gdW5vYnNlcnZlO1xuLyoqXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcihvYmopO1xuICAgIGlmICghbWlycm9yKSB7XG4gICAgICAgIG1pcnJvciA9IG5ldyBNaXJyb3Iob2JqKTtcbiAgICAgICAgYmVmb3JlRGljdC5zZXQob2JqLCBtaXJyb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9ic2VydmVySW5mbyA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IHt9O1xuICAgIG1pcnJvci52YWx1ZSA9IGhlbHBlcnNfanNfMS5fZGVlcENsb25lKG9iaik7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xuICAgICAgICB2YXIgZGlydHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZhc3RDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy9ub3QgTm9kZVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IHBhdGNoZXM7XG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWlycm9yLm9ic2VydmVycy5zZXQoY2FsbGJhY2ssIG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuZXhwb3J0cy5vYnNlcnZlID0gb2JzZXJ2ZTtcbi8qKlxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKG9ic2VydmVyLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKGludmVydGlibGUgPT09IHZvaWQgMCkgeyBpbnZlcnRpYmxlID0gZmFsc2U7IH1cbiAgICB2YXIgbWlycm9yID0gYmVmb3JlRGljdC5nZXQob2JzZXJ2ZXIub2JqZWN0KTtcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBjb3JlX2pzXzEuYXBwbHlQYXRjaChtaXJyb3IudmFsdWUsIG9ic2VydmVyLnBhdGNoZXMpO1xuICAgIH1cbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XG4gICAgaWYgKHRlbXAubGVuZ3RoID4gMCkge1xuICAgICAgICBvYnNlcnZlci5wYXRjaGVzID0gW107XG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sodGVtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXA7XG59XG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4vLyBEaXJ0eSBjaGVjayBpZiBvYmogaXMgZGlmZmVyZW50IGZyb20gbWlycm9yLCBnZW5lcmF0ZSBwYXRjaGVzIGFuZCB1cGRhdGUgbWlycm9yXG5mdW5jdGlvbiBfZ2VuZXJhdGUobWlycm9yLCBvYmosIHBhdGNoZXMsIHBhdGgsIGludmVydGlibGUpIHtcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIHZhciBuZXdLZXlzID0gaGVscGVyc19qc18xLl9vYmplY3RLZXlzKG9iaik7XG4gICAgdmFyIG9sZEtleXMgPSBoZWxwZXJzX2pzXzEuX29iamVjdEtleXMobWlycm9yKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XG4gICAgICAgIGlmIChoZWxwZXJzX2pzXzEuaGFzT3duUHJvcGVydHkob2JqLCBrZXkpICYmICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJiBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJiBvbGRWYWwgIT0gbnVsbCAmJiB0eXBlb2YgbmV3VmFsID09IFwib2JqZWN0XCIgJiYgbmV3VmFsICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShvbGRWYWwpID09PSBBcnJheS5pc0FycmF5KG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIGludmVydGlibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gbmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc19qc18xLl9kZWVwQ2xvbmUob2xkVmFsKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShuZXdWYWwpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1pcnJvcikgPT09IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShvbGRWYWwpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgfSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGgsIHZhbHVlOiBtaXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGgsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRlbGV0ZWQgJiYgbmV3S2V5cy5sZW5ndGggPT0gb2xkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5ld0tleXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNbdF07XG4gICAgICAgIGlmICghaGVscGVyc19qc18xLmhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJhZGRcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc19qc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IGhlbHBlcnNfanNfMS5fZGVlcENsb25lKG9ialtrZXldKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gY29tcGFyZSh0cmVlMSwgdHJlZTIsIGludmVydGlibGUpIHtcbiAgICBpZiAoaW52ZXJ0aWJsZSA9PT0gdm9pZCAwKSB7IGludmVydGlibGUgPSBmYWxzZTsgfVxuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgX2dlbmVyYXRlKHRyZWUxLCB0cmVlMiwgcGF0Y2hlcywgJycsIGludmVydGlibGUpO1xuICAgIHJldHVybiBwYXRjaGVzO1xufVxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbiIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTctMjAyMiBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VkXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNPd25Qcm9wZXJ0eVwiLCB7IHZhbHVlOiBoYXNPd25Qcm9wZXJ0eSB9KTtcbmZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGtleXNfMSA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlzXzEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGtleXNfMVtrXSA9IFwiXCIgKyBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzXzE7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBpKSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZXhwb3J0cy5fb2JqZWN0S2V5cyA9IF9vYmplY3RLZXlzO1xuO1xuLyoqXG4qIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxuKiBodHRwczovL2pzcGVyZi5jb20vZGVlcC1jb3B5LXZzLWpzb24tc3RyaW5naWZ5LWpzb24tcGFyc2UvMjUgKHJlY3Vyc2l2ZURlZXBDb3B5KVxuKiBAcGFyYW0gIHthbnl9IG9iaiB2YWx1ZSB0byBjbG9uZVxuKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcbiovXG5mdW5jdGlvbiBfZGVlcENsb25lKG9iaikge1xuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTsgLy9GYXN0ZXIgdGhhbiBFUzUgY2xvbmUgLSBodHRwOi8vanNwZXJmLmNvbS9kZWVwLWNsb25pbmctb2Ytb2JqZWN0cy81XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3RoaXMgaXMgaG93IEpTT04uc3RyaW5naWZ5IGJlaGF2ZXMgZm9yIGFycmF5IGl0ZW1zXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqOyAvL25vIG5lZWQgdG8gY2xvbmUgcHJpbWl0aXZlc1xuICAgIH1cbn1cbmV4cG9ydHMuX2RlZXBDbG9uZSA9IF9kZWVwQ2xvbmU7XG4vLzN4IGZhc3RlciB0aGFuIGNhY2hlZCAvXlxcZCskLy50ZXN0KHN0cilcbmZ1bmN0aW9uIGlzSW50ZWdlcihzdHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGNoYXJDb2RlO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuLyoqXG4qIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuKiBAcGFyYW0gcGF0aCBUaGUgcmF3IHBvaW50ZXJcbiogQHJldHVybiB0aGUgRXNjYXBlZCBwYXRoXG4qL1xuZnVuY3Rpb24gZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZignLycpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoJ34nKSA9PT0gLTEpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXNjYXBlUGF0aENvbXBvbmVudDtcbi8qKlxuICogVW5lc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiAqIEBwYXJhbSBwYXRoIFRoZSBlc2NhcGVkIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHVuZXNjYXBlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xufVxuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQ7XG5mdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICB2YXIgZm91bmQ7XG4gICAgZm9yICh2YXIga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcm9vdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdFtrZXldLCBvYmopO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nICsgZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmV4cG9ydHMuX2dldFBhdGhSZWN1cnNpdmUgPSBfZ2V0UGF0aFJlY3Vyc2l2ZTtcbmZ1bmN0aW9uIGdldFBhdGgocm9vdCwgb2JqKSB7XG4gICAgaWYgKHJvb3QgPT09IG9iaikge1xuICAgICAgICByZXR1cm4gJy8nO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XG4gICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBub3QgZm91bmQgaW4gcm9vdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiL1wiICsgcGF0aDtcbn1cbmV4cG9ydHMuZ2V0UGF0aCA9IGdldFBhdGg7XG4vKipcbiogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXG4qL1xuZnVuY3Rpb24gaGFzVW5kZWZpbmVkKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpXzEgPCBsZW47IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbaV8xXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBvYmpLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICAgICAgICAgIHZhciBvYmpLZXlzTGVuZ3RoID0gb2JqS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW29iaktleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5oYXNVbmRlZmluZWQgPSBoYXNVbmRlZmluZWQ7XG5mdW5jdGlvbiBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCBhcmdzKSB7XG4gICAgdmFyIG1lc3NhZ2VQYXJ0cyA9IFttZXNzYWdlXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXJncykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJnc1trZXldID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGFyZ3Nba2V5XSwgbnVsbCwgMikgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goa2V5ICsgXCI6IFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbignXFxuJyk7XG59XG52YXIgUGF0Y2hFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGF0Y2hFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXRjaEVycm9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCB7IG5hbWU6IG5hbWUsIGluZGV4OiBpbmRleCwgb3BlcmF0aW9uOiBvcGVyYXRpb24sIHRyZWU6IHRyZWUgfSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZTogbmFtZSwgaW5kZXg6IGluZGV4LCBvcGVyYXRpb246IG9wZXJhdGlvbiwgdHJlZTogdHJlZSB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGF0Y2hFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoXCIuL2NvbW1vbmpzL2NvcmUuanNcIik7XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIGNvcmUpO1xuXG52YXIgZHVwbGV4ID0gcmVxdWlyZShcIi4vY29tbW9uanMvZHVwbGV4LmpzXCIpO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBkdXBsZXgpO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2NvbW1vbmpzL2hlbHBlcnMuanNcIik7XG5leHBvcnRzLkpzb25QYXRjaEVycm9yID0gaGVscGVycy5QYXRjaEVycm9yO1xuZXhwb3J0cy5kZWVwQ2xvbmUgPSBoZWxwZXJzLl9kZWVwQ2xvbmU7XG5leHBvcnRzLmVzY2FwZVBhdGhDb21wb25lbnQgPSBoZWxwZXJzLmVzY2FwZVBhdGhDb21wb25lbnQ7XG5leHBvcnRzLnVuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnMudW5lc2NhcGVQYXRoQ29tcG9uZW50O1xuIiwiKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgY29sbGF0b3I7XG4gIHRyeSB7XG4gICAgY29sbGF0b3IgPSAodHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEludGwuQ29sbGF0b3IgIT09IFwidW5kZWZpbmVkXCIpID8gSW50bC5Db2xsYXRvcihcImdlbmVyaWNcIiwgeyBzZW5zaXRpdml0eTogXCJiYXNlXCIgfSkgOiBudWxsO1xuICB9IGNhdGNoIChlcnIpe1xuICAgIGNvbnNvbGUubG9nKFwiQ29sbGF0b3IgY291bGQgbm90IGJlIGluaXRpYWxpemVkIGFuZCB3b3VsZG4ndCBiZSB1c2VkXCIpO1xuICB9XG4gIC8vIGFycmF5cyB0byByZS11c2VcbiAgdmFyIHByZXZSb3cgPSBbXSxcbiAgICBzdHIyQ2hhciA9IFtdO1xuICBcbiAgLyoqXG4gICAqIEJhc2VkIG9uIHRoZSBhbGdvcml0aG0gYXQgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbnNodGVpbl9kaXN0YW5jZS5cbiAgICovXG4gIHZhciBMZXZlbnNodGVpbiA9IHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGV2ZW5zaHRlaW4gZGlzdGFuY2Ugb2YgdGhlIHR3byBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cjEgU3RyaW5nIHRoZSBmaXJzdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHN0cjIgU3RyaW5nIHRoZSBzZWNvbmQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy51c2VDb2xsYXRvcl0gVXNlIGBJbnRsLkNvbGxhdG9yYCBmb3IgbG9jYWxlLXNlbnNpdGl2ZSBzdHJpbmcgY29tcGFyaXNvbi5cbiAgICAgKiBAcmV0dXJuIEludGVnZXIgdGhlIGxldmVuc2h0ZWluIGRpc3RhbmNlICgwIGFuZCBhYm92ZSkuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihzdHIxLCBzdHIyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdXNlQ29sbGF0b3IgPSAob3B0aW9ucyAmJiBjb2xsYXRvciAmJiBvcHRpb25zLnVzZUNvbGxhdG9yKTtcbiAgICAgIFxuICAgICAgdmFyIHN0cjFMZW4gPSBzdHIxLmxlbmd0aCxcbiAgICAgICAgc3RyMkxlbiA9IHN0cjIubGVuZ3RoO1xuICAgICAgXG4gICAgICAvLyBiYXNlIGNhc2VzXG4gICAgICBpZiAoc3RyMUxlbiA9PT0gMCkgcmV0dXJuIHN0cjJMZW47XG4gICAgICBpZiAoc3RyMkxlbiA9PT0gMCkgcmV0dXJuIHN0cjFMZW47XG5cbiAgICAgIC8vIHR3byByb3dzXG4gICAgICB2YXIgY3VyQ29sLCBuZXh0Q29sLCBpLCBqLCB0bXA7XG5cbiAgICAgIC8vIGluaXRpYWxpc2UgcHJldmlvdXMgcm93XG4gICAgICBmb3IgKGk9MDsgaTxzdHIyTGVuOyArK2kpIHtcbiAgICAgICAgcHJldlJvd1tpXSA9IGk7XG4gICAgICAgIHN0cjJDaGFyW2ldID0gc3RyMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgICAgcHJldlJvd1tzdHIyTGVuXSA9IHN0cjJMZW47XG5cbiAgICAgIHZhciBzdHJDbXA7XG4gICAgICBpZiAodXNlQ29sbGF0b3IpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgcm93IGRpc3RhbmNlIGZyb20gcHJldmlvdXMgcm93IHVzaW5nIGNvbGxhdG9yXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHIxTGVuOyArK2kpIHtcbiAgICAgICAgICBuZXh0Q29sID0gaSArIDE7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RyMkxlbjsgKytqKSB7XG4gICAgICAgICAgICBjdXJDb2wgPSBuZXh0Q29sO1xuXG4gICAgICAgICAgICAvLyBzdWJzdHV0aW9uXG4gICAgICAgICAgICBzdHJDbXAgPSAwID09PSBjb2xsYXRvci5jb21wYXJlKHN0cjEuY2hhckF0KGkpLCBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0cjJDaGFyW2pdKSk7XG5cbiAgICAgICAgICAgIG5leHRDb2wgPSBwcmV2Um93W2pdICsgKHN0ckNtcCA/IDAgOiAxKTtcblxuICAgICAgICAgICAgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICB0bXAgPSBjdXJDb2wgKyAxO1xuICAgICAgICAgICAgaWYgKG5leHRDb2wgPiB0bXApIHtcbiAgICAgICAgICAgICAgbmV4dENvbCA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbGV0aW9uXG4gICAgICAgICAgICB0bXAgPSBwcmV2Um93W2ogKyAxXSArIDE7XG4gICAgICAgICAgICBpZiAobmV4dENvbCA+IHRtcCkge1xuICAgICAgICAgICAgICBuZXh0Q29sID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb3B5IGN1cnJlbnQgY29sIHZhbHVlIGludG8gcHJldmlvdXMgKGluIHByZXBhcmF0aW9uIGZvciBuZXh0IGl0ZXJhdGlvbilcbiAgICAgICAgICAgIHByZXZSb3dbal0gPSBjdXJDb2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29weSBsYXN0IGNvbCB2YWx1ZSBpbnRvIHByZXZpb3VzIChpbiBwcmVwYXJhdGlvbiBmb3IgbmV4dCBpdGVyYXRpb24pXG4gICAgICAgICAgcHJldlJvd1tqXSA9IG5leHRDb2w7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCByb3cgZGlzdGFuY2UgZnJvbSBwcmV2aW91cyByb3cgd2l0aG91dCBjb2xsYXRvclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyMUxlbjsgKytpKSB7XG4gICAgICAgICAgbmV4dENvbCA9IGkgKyAxO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0cjJMZW47ICsraikge1xuICAgICAgICAgICAgY3VyQ29sID0gbmV4dENvbDtcblxuICAgICAgICAgICAgLy8gc3Vic3R1dGlvblxuICAgICAgICAgICAgc3RyQ21wID0gc3RyMS5jaGFyQ29kZUF0KGkpID09PSBzdHIyQ2hhcltqXTtcblxuICAgICAgICAgICAgbmV4dENvbCA9IHByZXZSb3dbal0gKyAoc3RyQ21wID8gMCA6IDEpO1xuXG4gICAgICAgICAgICAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgIHRtcCA9IGN1ckNvbCArIDE7XG4gICAgICAgICAgICBpZiAobmV4dENvbCA+IHRtcCkge1xuICAgICAgICAgICAgICBuZXh0Q29sID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsZXRpb25cbiAgICAgICAgICAgIHRtcCA9IHByZXZSb3dbaiArIDFdICsgMTtcbiAgICAgICAgICAgIGlmIChuZXh0Q29sID4gdG1wKSB7XG4gICAgICAgICAgICAgIG5leHRDb2wgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvcHkgY3VycmVudCBjb2wgdmFsdWUgaW50byBwcmV2aW91cyAoaW4gcHJlcGFyYXRpb24gZm9yIG5leHQgaXRlcmF0aW9uKVxuICAgICAgICAgICAgcHJldlJvd1tqXSA9IGN1ckNvbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjb3B5IGxhc3QgY29sIHZhbHVlIGludG8gcHJldmlvdXMgKGluIHByZXBhcmF0aW9uIGZvciBuZXh0IGl0ZXJhdGlvbilcbiAgICAgICAgICBwcmV2Um93W2pdID0gbmV4dENvbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHRDb2w7XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gYW1kXG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIGRlZmluZSAhPT0gbnVsbCAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIExldmVuc2h0ZWluO1xuICAgIH0pO1xuICB9XG4gIC8vIGNvbW1vbmpzXG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsICYmIHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzID09PSBleHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMZXZlbnNodGVpbjtcbiAgfVxuICAvLyB3ZWIgd29ya2VyXG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBzZWxmLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzZWxmLmltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLkxldmVuc2h0ZWluID0gTGV2ZW5zaHRlaW47XG4gIH1cbiAgLy8gYnJvd3NlciBtYWluIHRocmVhZFxuICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgIHdpbmRvdy5MZXZlbnNodGVpbiA9IExldmVuc2h0ZWluO1xuICB9XG59KCkpO1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbW92ZUFkZHJlc3NUYWdzID0gZXhwb3J0cy5mZXRjaEFkZHJlc3NUYWdzID0gZXhwb3J0cy5hZGRBZGRyZXNzVGFncyA9IHZvaWQgMDtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG52YXIgYWRkQWRkcmVzc1RhZ3MgPSBmdW5jdGlvbiAodGFncykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjb3JkcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHJlY29yZHMgPSB0YWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0YWcpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyh0YWcpWzBdO1xuICAgICAgICAgICAgYWNjW2tleV0gPSB0YWdba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB1dGlsaXRpZXNfMS5xdWV1ZSkoZnVuY3Rpb24gKGNsaWVudCkgeyByZXR1cm4gY2xpZW50LmFkZEt2UmVjb3Jkcyh7IHJlY29yZHM6IHJlY29yZHMgfSk7IH0pXTtcbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5hZGRBZGRyZXNzVGFncyA9IGFkZEFkZHJlc3NUYWdzO1xudmFyIGZldGNoQWRkcmVzc1RhZ3MgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8geyBuOiBjb25zdGFudHNfMS5NQVhfQUREUiwgc3RhcnQ6IDAgfSA6IF9hLCBuID0gX2Iubiwgc3RhcnQgPSBfYi5zdGFydDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFkZHJlc3NUYWdzLCByZW1haW5pbmdUb0ZldGNoLCBmZXRjaGVkO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzVGFncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdUb0ZldGNoID0gbjtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlZCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShyZW1haW5pbmdUb0ZldGNoID4gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgdXRpbGl0aWVzXzEucXVldWUpKGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRLdlJlY29yZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmV0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogcmVtYWluaW5nVG9GZXRjaCA+IGNvbnN0YW50c18xLk1BWF9BRERSID8gY29uc3RhbnRzXzEuTUFYX0FERFIgOiByZW1haW5pbmdUb0ZldGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NUYWdzLnB1c2guYXBwbHkoYWRkcmVzc1RhZ3MsIHJlcy5yZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZWQgPSByZXMuZmV0Y2hlZCArIGZldGNoZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdUb0ZldGNoID0gcmVzLnRvdGFsIC0gZmV0Y2hlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBhZGRyZXNzVGFnc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZmV0Y2hBZGRyZXNzVGFncyA9IGZldGNoQWRkcmVzc1RhZ3M7XG52YXIgcmVtb3ZlQWRkcmVzc1RhZ3MgPSBmdW5jdGlvbiAodGFncykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWRzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgaWRzID0gdGFncy5tYXAoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gXCJcIi5jb25jYXQodGFnLmlkKTsgfSk7XG4gICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgdXRpbGl0aWVzXzEucXVldWUpKGZ1bmN0aW9uIChjbGllbnQpIHsgcmV0dXJuIGNsaWVudC5yZW1vdmVLdlJlY29yZHMoeyBpZHM6IGlkcyB9KTsgfSldO1xuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnJlbW92ZUFkZHJlc3NUYWdzID0gcmVtb3ZlQWRkcmVzc1RhZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaExlZGdlckxlZ2FjeUFkZHJlc3NlcyA9IGV4cG9ydHMuZmV0Y2hMZWRnZXJMaXZlQWRkcmVzc2VzID0gZXhwb3J0cy5mZXRjaFNvbGFuYUFkZHJlc3NlcyA9IGV4cG9ydHMuZmV0Y2hCdGNXcmFwcGVkU2Vnd2l0QWRkcmVzc2VzID0gZXhwb3J0cy5mZXRjaEJ0Q1NlZ3dpdEFkZHJlc3NlcyA9IGV4cG9ydHMuZmV0Y2hCdGNMZWdhY3lBZGRyZXNzZXMgPSBleHBvcnRzLmZldGNoQWRkcmVzc2VzID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxpdGllc1wiKTtcbnZhciBmZXRjaEFkZHJlc3NlcyA9IGZ1bmN0aW9uIChvdmVycmlkZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIHV0aWxpdGllc18xLnF1ZXVlKShmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAuZ2V0QWRkcmVzc2VzKF9fYXNzaWduKHsgc3RhcnRQYXRoOiBjb25zdGFudHNfMS5ERUZBVUxUX0VUSF9ERVJJVkFUSU9OLCBuOiBjb25zdGFudHNfMS5NQVhfQUREUiB9LCBvdmVycmlkZXMpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWRkcnMpIHsgcmV0dXJuIGFkZHJzLm1hcChmdW5jdGlvbiAoYWRkcikgeyByZXR1cm4gXCJcIi5jb25jYXQoYWRkcik7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pXTtcbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5mZXRjaEFkZHJlc3NlcyA9IGZldGNoQWRkcmVzc2VzO1xudmFyIGZldGNoQnRjTGVnYWN5QWRkcmVzc2VzID0gZnVuY3Rpb24gKG4sIHN0YXJ0UGF0aEluZGV4KSB7XG4gICAgaWYgKG4gPT09IHZvaWQgMCkgeyBuID0gY29uc3RhbnRzXzEuTUFYX0FERFI7IH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCBleHBvcnRzLmZldGNoQWRkcmVzc2VzKSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGF0aDogKDAsIHV0aWxpdGllc18xLmdldFN0YXJ0UGF0aCkoY29uc3RhbnRzXzEuQlRDX0xFR0FDWV9ERVJJVkFUSU9OLCBzdGFydFBhdGhJbmRleCksXG4gICAgICAgICAgICAgICAgICAgIG46IG4sXG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmZldGNoQnRjTGVnYWN5QWRkcmVzc2VzID0gZmV0Y2hCdGNMZWdhY3lBZGRyZXNzZXM7XG52YXIgZmV0Y2hCdENTZWd3aXRBZGRyZXNzZXMgPSBmdW5jdGlvbiAobiwgc3RhcnRQYXRoSW5kZXgpIHtcbiAgICBpZiAobiA9PT0gdm9pZCAwKSB7IG4gPSBjb25zdGFudHNfMS5NQVhfQUREUjsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGV4cG9ydHMuZmV0Y2hBZGRyZXNzZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXRoOiAoMCwgdXRpbGl0aWVzXzEuZ2V0U3RhcnRQYXRoKShjb25zdGFudHNfMS5CVENfU0VHV0lUX0RFUklWQVRJT04sIHN0YXJ0UGF0aEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgbjogbixcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZmV0Y2hCdENTZWd3aXRBZGRyZXNzZXMgPSBmZXRjaEJ0Q1NlZ3dpdEFkZHJlc3NlcztcbnZhciBmZXRjaEJ0Y1dyYXBwZWRTZWd3aXRBZGRyZXNzZXMgPSBmdW5jdGlvbiAobiwgc3RhcnRQYXRoSW5kZXgpIHtcbiAgICBpZiAobiA9PT0gdm9pZCAwKSB7IG4gPSBjb25zdGFudHNfMS5NQVhfQUREUjsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGV4cG9ydHMuZmV0Y2hBZGRyZXNzZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXRoOiAoMCwgdXRpbGl0aWVzXzEuZ2V0U3RhcnRQYXRoKShjb25zdGFudHNfMS5CVENfV1JBUFBFRF9TRUdXSVRfREVSSVZBVElPTiwgc3RhcnRQYXRoSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBuOiBuLFxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5mZXRjaEJ0Y1dyYXBwZWRTZWd3aXRBZGRyZXNzZXMgPSBmZXRjaEJ0Y1dyYXBwZWRTZWd3aXRBZGRyZXNzZXM7XG52YXIgZmV0Y2hTb2xhbmFBZGRyZXNzZXMgPSBmdW5jdGlvbiAobiwgc3RhcnRQYXRoSW5kZXgpIHtcbiAgICBpZiAobiA9PT0gdm9pZCAwKSB7IG4gPSBjb25zdGFudHNfMS5NQVhfQUREUjsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGV4cG9ydHMuZmV0Y2hBZGRyZXNzZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXRoOiAoMCwgdXRpbGl0aWVzXzEuZ2V0U3RhcnRQYXRoKShjb25zdGFudHNfMS5TT0xBTkFfREVSSVZBVElPTiwgc3RhcnRQYXRoSW5kZXgsIDIpLFxuICAgICAgICAgICAgICAgICAgICBuOiBuLFxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5mZXRjaFNvbGFuYUFkZHJlc3NlcyA9IGZldGNoU29sYW5hQWRkcmVzc2VzO1xudmFyIGZldGNoTGVkZ2VyTGl2ZUFkZHJlc3NlcyA9IGZ1bmN0aW9uIChuLCBzdGFydFBhdGhJbmRleCkge1xuICAgIGlmIChuID09PSB2b2lkIDApIHsgbiA9IGNvbnN0YW50c18xLk1BWF9BRERSOyB9XG4gICAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzZXMsIF9sb29wXzEsIGk7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goKDAsIHV0aWxpdGllc18xLnF1ZXVlKShmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRBZGRyZXNzZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXRoOiAoMCwgdXRpbGl0aWVzXzEuZ2V0U3RhcnRQYXRoKShjb25zdGFudHNfMS5MRURHRVJfTElWRV9ERVJJVkFUSU9OLCBzdGFydFBhdGhJbmRleCArIGksIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbjogMSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhZGRyZXNzZXMpIHsgcmV0dXJuIGFkZHJlc3Nlcy5tYXAoZnVuY3Rpb24gKGFkZHJlc3MpIHsgcmV0dXJuIFwiXCIuY29uY2F0KGFkZHJlc3MpOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UuYWxsKGFkZHJlc3NlcyldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmZldGNoTGVkZ2VyTGl2ZUFkZHJlc3NlcyA9IGZldGNoTGVkZ2VyTGl2ZUFkZHJlc3NlcztcbnZhciBmZXRjaExlZGdlckxlZ2FjeUFkZHJlc3NlcyA9IGZ1bmN0aW9uIChuLCBzdGFydFBhdGhJbmRleCkge1xuICAgIGlmIChuID09PSB2b2lkIDApIHsgbiA9IGNvbnN0YW50c18xLk1BWF9BRERSOyB9XG4gICAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzZXMsIF9sb29wXzIsIGk7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICAgICAgX2xvb3BfMiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goKDAsIHV0aWxpdGllc18xLnF1ZXVlKShmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRBZGRyZXNzZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXRoOiAoMCwgdXRpbGl0aWVzXzEuZ2V0U3RhcnRQYXRoKShjb25zdGFudHNfMS5MRURHRVJfTEVHQUNZX0RFUklWQVRJT04sIHN0YXJ0UGF0aEluZGV4ICsgaSwgMyksXG4gICAgICAgICAgICAgICAgICAgICAgICBuOiAxLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3NlcykgeyByZXR1cm4gYWRkcmVzc2VzLm1hcChmdW5jdGlvbiAoYWRkcmVzcykgeyByZXR1cm4gXCJcIi5jb25jYXQoYWRkcmVzcyk7IH0pOyB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzIoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5hbGwoYWRkcmVzc2VzKV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZmV0Y2hMZWRnZXJMZWdhY3lBZGRyZXNzZXMgPSBmZXRjaExlZGdlckxlZ2FjeUFkZHJlc3NlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaEFjdGl2ZVdhbGxldHMgPSBleHBvcnRzLnBhaXIgPSBleHBvcnRzLmNvbm5lY3QgPSBleHBvcnRzLnNldHVwID0gZXhwb3J0cy5nZXRDbGllbnQgPSB2b2lkIDA7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxpdGllc18xLmdldENsaWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldHVwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsaXRpZXNfMS5zZXR1cDsgfSB9KTtcbnZhciB1dGlsaXRpZXNfMiA9IHJlcXVpcmUoXCIuL3V0aWxpdGllc1wiKTtcbnZhciBjb25uZWN0ID0gZnVuY3Rpb24gKGRldmljZUlkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB1dGlsaXRpZXNfMi5xdWV1ZSkoZnVuY3Rpb24gKGNsaWVudCkgeyByZXR1cm4gY2xpZW50LmNvbm5lY3QoZGV2aWNlSWQpOyB9KV07XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Q7XG52YXIgcGFpciA9IGZ1bmN0aW9uIChwYWlyaW5nQ29kZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgdXRpbGl0aWVzXzIucXVldWUpKGZ1bmN0aW9uIChjbGllbnQpIHsgcmV0dXJuIGNsaWVudC5wYWlyKHBhaXJpbmdDb2RlKTsgfSldO1xuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnBhaXIgPSBwYWlyO1xudmFyIGZldGNoQWN0aXZlV2FsbGV0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIHV0aWxpdGllc18yLnF1ZXVlKShmdW5jdGlvbiAoY2xpZW50KSB7IHJldHVybiBjbGllbnQuZmV0Y2hBY3RpdmVXYWxsZXQoKTsgfSldO1xuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmZldGNoQWN0aXZlV2FsbGV0cyA9IGZldGNoQWN0aXZlV2FsbGV0cztcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGRyZXNzZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FkZHJlc3NUYWdzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduaW5nXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNpZ25Tb2xhbmFUeCA9IGV4cG9ydHMuc2lnbkJ0Y1dyYXBwZWRTZWd3aXRUeCA9IGV4cG9ydHMuc2lnbkJ0Y1NlZ3dpdFR4ID0gZXhwb3J0cy5zaWduQnRjTGVnYWN5VHggPSBleHBvcnRzLnNpZ25NZXNzYWdlID0gZXhwb3J0cy5zaWduID0gdm9pZCAwO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG52YXIgc2lnbiA9IGZ1bmN0aW9uIChwYXlsb2FkLCBvdmVycmlkZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR4O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdHggPSBfX2Fzc2lnbih7IGRhdGE6IHtcbiAgICAgICAgICAgICAgICBzaWduZXJQYXRoOiBjb25zdGFudHNfMS5ERUZBVUxUX0VUSF9ERVJJVkFUSU9OLFxuICAgICAgICAgICAgICAgIGN1cnZlVHlwZTogX18xLkNvbnN0YW50cy5TSUdOSU5HLkNVUlZFUy5TRUNQMjU2SzEsXG4gICAgICAgICAgICAgICAgaGFzaFR5cGU6IF9fMS5Db25zdGFudHMuU0lHTklORy5IQVNIRVMuS0VDQ0FLMjU2LFxuICAgICAgICAgICAgICAgIGVuY29kaW5nVHlwZTogX18xLkNvbnN0YW50cy5TSUdOSU5HLkVOQ09ESU5HUy5FVk0sXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIH0gfSwgb3ZlcnJpZGVzKTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB1dGlsaXRpZXNfMS5xdWV1ZSkoZnVuY3Rpb24gKGNsaWVudCkgeyByZXR1cm4gY2xpZW50LnNpZ24odHgpOyB9KV07XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuc2lnbiA9IHNpZ247XG52YXIgc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAocGF5bG9hZCwgb3ZlcnJpZGVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHR4ID0ge1xuICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oeyBzaWduZXJQYXRoOiBjb25zdGFudHNfMS5ERUZBVUxUX0VUSF9ERVJJVkFUSU9OLCBjdXJ2ZVR5cGU6IF9fMS5Db25zdGFudHMuU0lHTklORy5DVVJWRVMuU0VDUDI1NksxLCBoYXNoVHlwZTogX18xLkNvbnN0YW50cy5TSUdOSU5HLkhBU0hFUy5LRUNDQUsyNTYsIHByb3RvY29sOiAnc2lnblBlcnNvbmFsJywgcGF5bG9hZDogcGF5bG9hZCB9LCBvdmVycmlkZXMpLFxuICAgICAgICAgICAgY3VycmVuY3k6IGNvbnN0YW50c18xLkNVUlJFTkNJRVMuRVRIX01TRyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCgwLCB1dGlsaXRpZXNfMS5pc0VJUDcxMlBheWxvYWQpKHBheWxvYWQpKSB7XG4gICAgICAgICAgICB0eC5kYXRhLnByb3RvY29sID0gJ2VpcDcxMic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB1dGlsaXRpZXNfMS5xdWV1ZSkoZnVuY3Rpb24gKGNsaWVudCkgeyByZXR1cm4gY2xpZW50LnNpZ24odHgpOyB9KV07XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuc2lnbk1lc3NhZ2UgPSBzaWduTWVzc2FnZTtcbnZhciBzaWduQnRjTGVnYWN5VHggPSBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHg7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB0eCA9IHtcbiAgICAgICAgICAgIGRhdGE6IF9fYXNzaWduKHsgc2lnbmVyUGF0aDogY29uc3RhbnRzXzEuQlRDX0xFR0FDWV9ERVJJVkFUSU9OIH0sIHBheWxvYWQpLFxuICAgICAgICAgICAgY3VycmVuY3k6ICdCVEMnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIHV0aWxpdGllc18xLnF1ZXVlKShmdW5jdGlvbiAoY2xpZW50KSB7IHJldHVybiBjbGllbnQuc2lnbih0eCk7IH0pXTtcbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5zaWduQnRjTGVnYWN5VHggPSBzaWduQnRjTGVnYWN5VHg7XG52YXIgc2lnbkJ0Y1NlZ3dpdFR4ID0gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR4O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdHggPSB7XG4gICAgICAgICAgICBkYXRhOiBfX2Fzc2lnbih7IHNpZ25lclBhdGg6IGNvbnN0YW50c18xLkJUQ19TRUdXSVRfREVSSVZBVElPTiB9LCBwYXlsb2FkKSxcbiAgICAgICAgICAgIGN1cnJlbmN5OiAnQlRDJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB1dGlsaXRpZXNfMS5xdWV1ZSkoZnVuY3Rpb24gKGNsaWVudCkgeyByZXR1cm4gY2xpZW50LnNpZ24odHgpOyB9KV07XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuc2lnbkJ0Y1NlZ3dpdFR4ID0gc2lnbkJ0Y1NlZ3dpdFR4O1xudmFyIHNpZ25CdGNXcmFwcGVkU2Vnd2l0VHggPSBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHg7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB0eCA9IHtcbiAgICAgICAgICAgIGRhdGE6IF9fYXNzaWduKHsgc2lnbmVyUGF0aDogY29uc3RhbnRzXzEuQlRDX1dSQVBQRURfU0VHV0lUX0RFUklWQVRJT04gfSwgcGF5bG9hZCksXG4gICAgICAgICAgICBjdXJyZW5jeTogJ0JUQycsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgdXRpbGl0aWVzXzEucXVldWUpKGZ1bmN0aW9uIChjbGllbnQpIHsgcmV0dXJuIGNsaWVudC5zaWduKHR4KTsgfSldO1xuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnNpZ25CdGNXcmFwcGVkU2Vnd2l0VHggPSBzaWduQnRjV3JhcHBlZFNlZ3dpdFR4O1xudmFyIHNpZ25Tb2xhbmFUeCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBvdmVycmlkZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR4O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdHggPSB7XG4gICAgICAgICAgICBkYXRhOiBfX2Fzc2lnbih7IHNpZ25lclBhdGg6IGNvbnN0YW50c18xLlNPTEFOQV9ERVJJVkFUSU9OLCBjdXJ2ZVR5cGU6IF9fMS5Db25zdGFudHMuU0lHTklORy5DVVJWRVMuRUQyNTUxOSwgaGFzaFR5cGU6IF9fMS5Db25zdGFudHMuU0lHTklORy5IQVNIRVMuTk9ORSwgZW5jb2RpbmdUeXBlOiBfXzEuQ29uc3RhbnRzLlNJR05JTkcuRU5DT0RJTkdTLlNPTEFOQSwgcGF5bG9hZDogcGF5bG9hZCB9LCBvdmVycmlkZXMpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIHV0aWxpdGllc18xLnF1ZXVlKShmdW5jdGlvbiAoY2xpZW50KSB7IHJldHVybiBjbGllbnQuc2lnbih0eCk7IH0pXTtcbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5zaWduU29sYW5hVHggPSBzaWduU29sYW5hVHg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0RnVuY3Rpb25RdWV1ZSA9IGV4cG9ydHMuZ2V0RnVuY3Rpb25RdWV1ZSA9IGV4cG9ydHMuc2V0TG9hZENsaWVudCA9IGV4cG9ydHMubG9hZENsaWVudCA9IGV4cG9ydHMuc2V0U2F2ZUNsaWVudCA9IGV4cG9ydHMuc2F2ZUNsaWVudCA9IHZvaWQgMDtcbnZhciBzZXRTYXZlQ2xpZW50ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgZXhwb3J0cy5zYXZlQ2xpZW50ID0gZm47XG59O1xuZXhwb3J0cy5zZXRTYXZlQ2xpZW50ID0gc2V0U2F2ZUNsaWVudDtcbnZhciBzZXRMb2FkQ2xpZW50ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgZXhwb3J0cy5sb2FkQ2xpZW50ID0gZm47XG59O1xuZXhwb3J0cy5zZXRMb2FkQ2xpZW50ID0gc2V0TG9hZENsaWVudDtcbnZhciBmdW5jdGlvblF1ZXVlO1xudmFyIGdldEZ1bmN0aW9uUXVldWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvblF1ZXVlOyB9O1xuZXhwb3J0cy5nZXRGdW5jdGlvblF1ZXVlID0gZ2V0RnVuY3Rpb25RdWV1ZTtcbnZhciBzZXRGdW5jdGlvblF1ZXVlID0gZnVuY3Rpb24gKHF1ZXVlKSB7XG4gICAgZnVuY3Rpb25RdWV1ZSA9IHF1ZXVlO1xufTtcbmV4cG9ydHMuc2V0RnVuY3Rpb25RdWV1ZSA9IHNldEZ1bmN0aW9uUXVldWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzRUlQNzEyUGF5bG9hZCA9IGV4cG9ydHMuZ2V0U3RhcnRQYXRoID0gZXhwb3J0cy5nZXRDbGllbnQgPSBleHBvcnRzLnF1ZXVlID0gZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vY2xpZW50XCIpO1xudmFyIHN0YXRlXzEgPSByZXF1aXJlKFwiLi9zdGF0ZVwiKTtcbi8qKlxuICogYHNldHVwYCBpbml0aWFsaXplcyB0aGUgQ2xpZW50IGFuZCBleGVjdXRlcyBgY29ubmVjdCgpYCBpZiBuZWNlc3NhcnkuIEl0IHJldHVybnMgYSBwcm9taXNlIHRoYXRcbiAqIHJlc29sdmVzIHRvIGEgYm9vbGVhbiB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBDbGllbnQgaXMgcGFpcmVkIHRvIHRoZSBhcHBsaWNhdGlvbiB0byB3aGljaCBpdCdzXG4gKiBhdHRlbXB0aW5nIHRvIGNvbm5lY3QuXG4gKi9cbnZhciBzZXR1cCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBkZXZpY2VJZCA9IF9hLmRldmljZUlkLCBwYXNzd29yZCA9IF9hLnBhc3N3b3JkLCBuYW1lID0gX2EubmFtZSwgZ2V0U3RvcmVkQ2xpZW50ID0gX2EuZ2V0U3RvcmVkQ2xpZW50LCBzZXRTdG9yZWRDbGllbnQgPSBfYS5zZXRTdG9yZWRDbGllbnQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcml2S2V5LCBjbGllbnRfMiwgY2xpZW50LCBkZXZpY2VJZF8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBpZiAoIWdldFN0b3JlZENsaWVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBkYXRhIGdldHRlciByZXF1aXJlZCcpO1xuICAgICAgICAgICAgKDAsIHN0YXRlXzEuc2V0U2F2ZUNsaWVudCkoYnVpbGRTYXZlQ2xpZW50Rm4oc2V0U3RvcmVkQ2xpZW50KSk7XG4gICAgICAgICAgICBpZiAoIXNldFN0b3JlZENsaWVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBkYXRhIHNldHRlciByZXF1aXJlZCcpO1xuICAgICAgICAgICAgKDAsIHN0YXRlXzEuc2V0TG9hZENsaWVudCkoYnVpbGRMb2FkQ2xpZW50Rm4oZ2V0U3RvcmVkQ2xpZW50KSk7XG4gICAgICAgICAgICBpZiAoZGV2aWNlSWQgJiYgcGFzc3dvcmQgJiYgbmFtZSkge1xuICAgICAgICAgICAgICAgIHByaXZLZXkgPSBfXzEuVXRpbHMuZ2VuZXJhdGVBcHBTZWNyZXQoZGV2aWNlSWQsIHBhc3N3b3JkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBjbGllbnRfMiA9IG5ldyBjbGllbnRfMS5DbGllbnQoeyBkZXZpY2VJZDogZGV2aWNlSWQsIHByaXZLZXk6IHByaXZLZXksIG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNsaWVudF8yLmNvbm5lY3QoZGV2aWNlSWQpLnRoZW4oZnVuY3Rpb24gKGlzUGFpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgc3RhdGVfMS5zYXZlQ2xpZW50KShjbGllbnRfMi5nZXRTdGF0ZURhdGEoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNQYWlyZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsaWVudCA9ICgwLCBzdGF0ZV8xLmxvYWRDbGllbnQpKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjbGllbnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgICAgIGRldmljZUlkXzEgPSBjbGllbnQuZ2V0RGV2aWNlSWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaWVudC5lcGhlbWVyYWxQdWIgJiYgZGV2aWNlSWRfMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIF9fMS5jb25uZWN0KShkZXZpY2VJZF8xKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoMCwgc3RhdGVfMS5zYXZlQ2xpZW50KShjbGllbnQuZ2V0U3RhdGVEYXRhKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZXNvbHZlKHRydWUpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8qKlxuICogYHF1ZXVlYCBpcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYWxsIGZ1bmN0aW9uYWwgQVBJIGNhbGxzLiBJdCBsaW1pdHMgdGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gKiByZXF1ZXN0cyB0byB0aGUgc2VydmVyIHRvIDEsIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGNsaWVudCBzdGF0ZSBkYXRhIGlzIHNhdmVkIGFmdGVyIGVhY2ggY2FsbC5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGVwaGVtZXJhbCBwdWJsaWMga2V5IG11c3QgYmUgdXBkYXRlZCBhZnRlciBlYWNoIHN1Y2Nlc3NmdWwgcmVxdWVzdCxcbiAqIGFuZCB0d28gY29uY3VycmVudCByZXF1ZXN0cyBjb3VsZCByZXN1bHQgaW4gdGhlIHNhbWUga2V5IGJlaW5nIHVzZWQgdHdpY2Ugb3IgdGhlIHdyb25nIGtleSBiZWluZ1xuICogd3JpdHRlbiB0byBtZW1vcnkgbG9jYWxseS5cbiAqL1xudmFyIHF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGNsaWVudCA9ICgwLCBzdGF0ZV8xLmxvYWRDbGllbnQpKCk7XG4gICAgaWYgKCFjbGllbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5vdCBpbml0aWFsaXplZCcpO1xuICAgIGlmICghKDAsIHN0YXRlXzEuZ2V0RnVuY3Rpb25RdWV1ZSkoKSkge1xuICAgICAgICAoMCwgc3RhdGVfMS5zZXRGdW5jdGlvblF1ZXVlKShQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgfVxuICAgICgwLCBzdGF0ZV8xLnNldEZ1bmN0aW9uUXVldWUpKCgwLCBzdGF0ZV8xLmdldEZ1bmN0aW9uUXVldWUpKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbihjbGllbnQpXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRW1wdHkgdGhlIHF1ZXVlIGlmIGFueSBmdW5jdGlvbiBjYWxsIGZhaWxzXG4gICAgICAgICAgICAoMCwgc3RhdGVfMS5zZXRGdW5jdGlvblF1ZXVlKShQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICgwLCBzdGF0ZV8xLnNhdmVDbGllbnQpKGNsaWVudC5nZXRTdGF0ZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gKDAsIHN0YXRlXzEuZ2V0RnVuY3Rpb25RdWV1ZSkoKTtcbn07XG5leHBvcnRzLnF1ZXVlID0gcXVldWU7XG52YXIgZ2V0Q2xpZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHN0YXRlXzEubG9hZENsaWVudCA/ICgwLCBzdGF0ZV8xLmxvYWRDbGllbnQpKCkgOiBudWxsKTsgfTtcbmV4cG9ydHMuZ2V0Q2xpZW50ID0gZ2V0Q2xpZW50O1xudmFyIGVuY29kZUNsaWVudERhdGEgPSBmdW5jdGlvbiAoY2xpZW50RGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShjbGllbnREYXRhKS50b1N0cmluZygnYmFzZTY0Jyk7XG59O1xudmFyIGRlY29kZUNsaWVudERhdGEgPSBmdW5jdGlvbiAoY2xpZW50RGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShjbGllbnREYXRhLCAnYmFzZTY0JykudG9TdHJpbmcoKTtcbn07XG52YXIgYnVpbGRTYXZlQ2xpZW50Rm4gPSBmdW5jdGlvbiAoc2V0U3RvcmVkQ2xpZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjbGllbnREYXRhKSB7XG4gICAgICAgIGlmICghY2xpZW50RGF0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGVuY29kZWREYXRhID0gZW5jb2RlQ2xpZW50RGF0YShjbGllbnREYXRhKTtcbiAgICAgICAgc2V0U3RvcmVkQ2xpZW50KGVuY29kZWREYXRhKTtcbiAgICB9O1xufTtcbnZhciBidWlsZExvYWRDbGllbnRGbiA9IGZ1bmN0aW9uIChnZXRTdG9yZWRDbGllbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xpZW50RGF0YSA9IGdldFN0b3JlZENsaWVudCgpO1xuICAgICAgICBpZiAoIWNsaWVudERhdGEpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgc3RhdGVEYXRhID0gZGVjb2RlQ2xpZW50RGF0YShjbGllbnREYXRhKTtcbiAgICAgICAgaWYgKCFzdGF0ZURhdGEpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY2xpZW50ID0gbmV3IGNsaWVudF8xLkNsaWVudCh7IHN0YXRlRGF0YTogc3RhdGVEYXRhIH0pO1xuICAgICAgICBpZiAoIWNsaWVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH07XG59O1xudmFyIGdldFN0YXJ0UGF0aCA9IGZ1bmN0aW9uIChkZWZhdWx0U3RhcnRQYXRoLCBhZGRyZXNzSW5kZXgsIC8vIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgYGRlZmF1bHRTdGFydFBhdGhgXG5wYXRoSW5kZXgpIHtcbiAgICBpZiAoYWRkcmVzc0luZGV4ID09PSB2b2lkIDApIHsgYWRkcmVzc0luZGV4ID0gMDsgfVxuICAgIGlmIChwYXRoSW5kZXggPT09IHZvaWQgMCkgeyBwYXRoSW5kZXggPSA0OyB9XG4gICAgdmFyIHN0YXJ0UGF0aCA9IGRlZmF1bHRTdGFydFBhdGg7XG4gICAgaWYgKGFkZHJlc3NJbmRleCA+IDApIHtcbiAgICAgICAgc3RhcnRQYXRoW3BhdGhJbmRleF0gPSBkZWZhdWx0U3RhcnRQYXRoW3BhdGhJbmRleF0gKyBhZGRyZXNzSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBhdGg7XG59O1xuZXhwb3J0cy5nZXRTdGFydFBhdGggPSBnZXRTdGFydFBhdGg7XG52YXIgaXNFSVA3MTJQYXlsb2FkID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHBheWxvYWQgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICd0eXBlcycgaW4gcGF5bG9hZCAmJlxuICAgICAgICAnZG9tYWluJyBpbiBwYXlsb2FkICYmXG4gICAgICAgICdwcmltYXJ5VHlwZScgaW4gcGF5bG9hZCAmJlxuICAgICAgICAnbWVzc2FnZScgaW4gcGF5bG9hZDtcbn07XG5leHBvcnRzLmlzRUlQNzEyUGF5bG9hZCA9IGlzRUlQNzEyUGF5bG9hZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gVXRpbCBmb3IgQml0Y29pbi1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5XG52YXIgYmVjaDMyXzEgPSByZXF1aXJlKFwiYmVjaDMyXCIpO1xudmFyIGJzNThjaGVja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiczU4Y2hlY2tcIikpO1xudmFyIHJpcGVtZF8xID0gcmVxdWlyZShcImhhc2guanMvbGliL2hhc2gvcmlwZW1kXCIpO1xudmFyIHNoYV8xID0gcmVxdWlyZShcImhhc2guanMvbGliL2hhc2gvc2hhXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbFwiKTtcbnZhciBERUZBVUxUX1NFUVVFTkNFID0gMHhmZmZmZmZmZjtcbnZhciBERUZBVUxUX1NJR0hBU0hfQlVGRkVSID0gQnVmZmVyLmZyb20oJzAxJywgJ2hleCcpOyAvLyBTSUdIQVNIX0FMTCA9IDB4MDFcbnZhciBQVVJQT1NFUyA9IGNvbnN0YW50c18xLkJJUF9DT05TVEFOVFMuUFVSUE9TRVMsIENPSU5TID0gY29uc3RhbnRzXzEuQklQX0NPTlNUQU5UUy5DT0lOUztcbnZhciBPUCA9IHtcbiAgICBaRVJPOiAweDAwLFxuICAgIEhBU0gxNjA6IDB4YTksXG4gICAgRFVQOiAweDc2LFxuICAgIEVRVUFMOiAweDg3LFxuICAgIEVRVUFMVkVSSUZZOiAweDg4LFxuICAgIENIRUNLU0lHOiAweGFjLFxufTtcbnZhciBTRUdXSVRfVjAgPSAweDAwO1xudmFyIFNFR1dJVF9OQVRJVkVfVjBfUFJFRklYID0gJ2JjJztcbnZhciBTRUdXSVRfTkFUSVZFX1YwX1RFU1RORVRfUFJFRklYID0gJ3RiJztcbnZhciBGTVRfU0VHV0lUX05BVElWRV9WMCA9IDB4ZDA7XG52YXIgRk1UX1NFR1dJVF9OQVRJVkVfVjBfVEVTVE5FVCA9IDB4ZjA7XG52YXIgRk1UX1NFR1dJVF9XUkFQUEVEID0gMHgwNTtcbnZhciBGTVRfU0VHV0lUX1dSQVBQRURfVEVTVE5FVCA9IDB4YzQ7XG52YXIgRk1UX0xFR0FDWSA9IDB4MDA7XG52YXIgRk1UX0xFR0FDWV9URVNUTkVUID0gMHg2ZjtcbnZhciBCVENfU0NSSVBUX1RZUEVfUDJQS0ggPSAweDAxO1xudmFyIEJUQ19TQ1JJUFRfVFlQRV9QMlNIX1AyV1BLSCA9IDB4MDM7XG52YXIgQlRDX1NDUklQVF9UWVBFX1AyV1BLSF9WMCA9IDB4MDQ7XG4vLyBXZSBuZWVkIHRvIGJ1aWxkIHR3byBkaWZmZXJlbnQgb2JqZWN0cyBoZXJlOlxuLy8gMS4gYml0Y29pbmpzLWxpYiBUcmFuc2FjdGlvbkJ1aWxkZXIgb2JqZWN0LCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gY29uanVuY3Rpb25cbi8vICAgIHdpdGggdGhlIHJldHVybmVkIHNpZ25hdHVyZXMgdG8gYnVpbGQgYW5kIHNlcmlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24gYmVmb3JlXG4vLyAgICBicm9hZGNhc3RpbmcgaXQuIFdlIHdpbGwgcmVwbGFjZSBgYml0Y29pbmpzLWxpYmAncyBzaWduYXR1cmVzIHdpdGggdGhlIG9uZXNcbi8vICAgIHdlIGdldCBmcm9tIHRoZSBMYXR0aWNlXG4vLyAyLiBUaGUgc2VyaWFsaXplZCBMYXR0aWNlIHJlcXVlc3QsIHdoaWNoIGluY2x1ZGVzIGRhdGEgKG91dGxpbmVkIGluIHRoZSBzcGVjaWZpY2F0aW9uKVxuLy8gICAgdGhhdCBpcyBuZWVkZWQgdG8gc2lnbiBhbGwgb2YgdGhlIGlucHV0cyBhbmQgYnVpbGQgYSBjaGFuZ2Ugb3V0cHV0LlxuLy8gQGlucHV0cyAoY29udGFpbmVkIGluIGBkYXRhYClcbi8vIGBwcmV2T3V0c2A6IGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vLyAgICAgICAgICAgYS4gdHhIYXNoXG4vLyAgICAgICAgICAgYi4gdmFsdWVcbi8vICAgICAgICAgICBjLiBpbmRleCAgICAgICAgICAtLSB0aGUgaW5kZXggb2YgdGhlIG91dHB1dCBpbiB0aGUgdHJhbnNhY3Rpb25cbi8vICAgICAgICAgICBkLiBzaWduZXJQYXRoIC0tIHRoZSBwYXRoIG9mIHRoZSBhZGRyZXNzIGluIG91ciB3YWxsZXQgdGhhdCBpcyBzaWduaW5nIHRoaXMgaW5wdXRcbi8vIGByZWNpcGllbnRgOiBSZWNlaXZpbmcgYWRkcmVzcywgd2hpY2ggbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYSBwdWJrZXloYXNoXG4vLyBgdmFsdWVgOiAgICAgTnVtYmVyIG9mIHNhdG9zaGlzIHRvIHNlbmQgdGhlIHJlY2lwaWVudFxuLy8gYGZlZWA6ICAgICAgIE51bWJlciBvZiBzYXRvc2hpcyB0byB1c2UgZm9yIGEgdHJhbnNhY3Rpb24gZmVlIChzaG91bGQgaGF2ZSBiZWVuIGNhbGN1bGF0ZWQpXG4vLyAgICAgICAgICAgICAgYWxyZWFkeSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGlucHV0cyBwbHVzIHR3byBvdXRwdXRzXG4vLyBgdmVyc2lvbmA6ICAgVHJhbnNhY3Rpb24gdmVyc2lvbiBvZiB0aGUgaW5wdXRzLiBBbGwgaW5wdXRzIG11c3QgYmUgb2YgdGhlIHNhbWUgdmVyc2lvbiFcbi8vIGBpc1NlZ3dpdGA6IGEgYm9vbGVhbiB3aGljaCBkZXRlcm1pbmVzIGhvdyB3ZSBzZXJpYWxpemUgdGhlIGRhdGEgYW5kIHBhcmFtZXRlcml6ZSB0eGJcbnZhciBidWlsZEJpdGNvaW5UeFJlcXVlc3QgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBwcmV2T3V0cyA9IGRhdGEucHJldk91dHMsIHJlY2lwaWVudCA9IGRhdGEucmVjaXBpZW50LCB2YWx1ZSA9IGRhdGEudmFsdWUsIGNoYW5nZVBhdGggPSBkYXRhLmNoYW5nZVBhdGgsIGZlZSA9IGRhdGEuZmVlO1xuICAgIGlmICghY2hhbmdlUGF0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFuZ2VQYXRoIHByb3ZpZGVkLicpO1xuICAgIGlmIChjaGFuZ2VQYXRoLmxlbmd0aCAhPT0gNSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIGZ1bGwgY2hhbmdlIHBhdGguJyk7XG4gICAgLy8gU2VyaWFsaXplIHRoZSByZXF1ZXN0XG4gICAgdmFyIHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoNTkgKyA2OSAqIHByZXZPdXRzLmxlbmd0aCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgLy8gQ2hhbmdlIHZlcnNpb24gYnl0ZSAoYS5rLmEuIGFkZHJlc3MgZm9ybWF0IGJ5dGUpXG4gICAgdmFyIGNoYW5nZUZtdCA9IGdldEFkZHJlc3NGb3JtYXQoY2hhbmdlUGF0aCk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KGNoYW5nZUZtdCwgMCk7XG4gICAgb2ZmKys7XG4gICAgLy8gQnVpbGQgdGhlIGNoYW5nZSBkYXRhXG4gICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKGNoYW5nZVBhdGgubGVuZ3RoLCBvZmYpO1xuICAgIG9mZiArPSA0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoY2hhbmdlUGF0aFtpXSwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgfVxuICAgIC8vIEZlZSBpcyBhIHBhcmFtXG4gICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKGZlZSwgb2ZmKTtcbiAgICBvZmYgKz0gNDtcbiAgICB2YXIgZGVjID0gZGVjb2RlQWRkcmVzcyhyZWNpcGllbnQpO1xuICAgIC8vIFBhcmFtZXRlcml6ZSB0aGUgcmVjaXBpZW50IG91dHB1dFxuICAgIHBheWxvYWQud3JpdGVVSW50OChkZWMudmVyc2lvbkJ5dGUsIG9mZik7XG4gICAgb2ZmKys7XG4gICAgZGVjLnBraC5jb3B5KHBheWxvYWQsIG9mZik7XG4gICAgb2ZmICs9IGRlYy5wa2gubGVuZ3RoO1xuICAgIHdyaXRlVUludDY0TEUodmFsdWUsIHBheWxvYWQsIG9mZik7XG4gICAgb2ZmICs9IDg7XG4gICAgLy8gQnVpbGQgdGhlIGlucHV0cyBmcm9tIHRoZSBwcmV2aW91cyBvdXRwdXRzXG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KHByZXZPdXRzLmxlbmd0aCwgb2ZmKTtcbiAgICBvZmYrKztcbiAgICB2YXIgaW5wdXRTdW0gPSAwO1xuICAgIHByZXZPdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQuc2lnbmVyUGF0aCB8fCBpbnB1dC5zaWduZXJQYXRoLmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdWxsIHJlY2lwaWVudCBwYXRoIG5vdCBzcGVjaWZpZWQgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKGlucHV0LnNpZ25lclBhdGgubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5zaWduZXJQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoaW5wdXQuc2lnbmVyUGF0aFtpXSwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSA0O1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRShpbnB1dC5pbmRleCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIHdyaXRlVUludDY0TEUoaW5wdXQudmFsdWUsIHBheWxvYWQsIG9mZik7XG4gICAgICAgIG9mZiArPSA4O1xuICAgICAgICBpbnB1dFN1bSArPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgdmFyIHNjcmlwdFR5cGUgPSBnZXRTY3JpcHRUeXBlKGlucHV0KTtcbiAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KHNjcmlwdFR5cGUsIG9mZik7XG4gICAgICAgIG9mZisrO1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpbnB1dC50eEhhc2gpKVxuICAgICAgICAgICAgaW5wdXQudHhIYXNoID0gQnVmZmVyLmZyb20oaW5wdXQudHhIYXNoLCAnaGV4Jyk7XG4gICAgICAgIGlucHV0LnR4SGFzaC5jb3B5KHBheWxvYWQsIG9mZik7XG4gICAgICAgIG9mZiArPSBpbnB1dC50eEhhc2gubGVuZ3RoO1xuICAgIH0pO1xuICAgIC8vIFNlbmQgdGhlbSBiYWNrIVxuICAgIHJldHVybiB7XG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIHNjaGVtYTogcHJvdG9jb2xfMS5MYXR0aWNlU2lnblNjaGVtYS5iaXRjb2luLFxuICAgICAgICBvcmlnRGF0YTogZGF0YSxcbiAgICAgICAgY2hhbmdlRGF0YToge1xuICAgICAgICAgICAgLy8gVGhpcyBkYXRhIGhlbHBzIGZpbGwgaW4gdGhlIGNoYW5nZSBvdXRwdXRcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dFN1bSAtICh2YWx1ZSArIGZlZSksXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4vLyBTZXJpYWxpemUgYSB0cmFuc2FjdGlvbiBjb25zaXN0aW5nIG9mIGlucHV0cywgb3V0cHV0cywgYW5kIHNvbWVcbi8vIG1ldGFkYXRhXG4vLyAtLSBpbnB1dHMgID0geyBoYXNoLCBpbmRleCwgc2lnLCBwdWJrZXkgfVxuLy8gLS0gb3V0cHV0cyA9IHsgdmFsdWUsIHJlY2lwaWVudCB9ICAvLyBleHBlY3RzIGFuIGFkZHJlc3Mgc3RyaW5nIGZvciBgcmVjaXBpZW50YFxuLy8gLS0gaXNTZWd3aXRTcGVuZCA9IHRydWUgaWYgdGhlIGlucHV0cyBhcmUgYmVpbmcgc3BlbnQgdXNpbmcgc2Vnd2l0XG4vLyAgICAgICAgICAgICAgICAgICAgKE5PVEU6IGVpdGhlciBBTEwgYXJlIGJlaW5nIHNwZW50LCBvciBub25lIGFyZSlcbi8vIC0tIGxvY2tUaW1lID0gV2lsbCBwcm9iYWJseSBhbHdheXMgYmUgMFxudmFyIHNlcmlhbGl6ZVR4ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgaW5wdXRzID0gZGF0YS5pbnB1dHMsIG91dHB1dHMgPSBkYXRhLm91dHB1dHMsIF9hID0gZGF0YS5sb2NrVGltZSwgbG9ja1RpbWUgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hO1xuICAgIHZhciBwYXlsb2FkID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIC8vIEFsd2F5cyB1c2UgdmVyc2lvbiAyXG4gICAgdmFyIHZlcnNpb24gPSAyO1xuICAgIHZhciB1c2VXaXRuZXNzID0gbmVlZHNXaXRuZXNzKGlucHV0cyk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHZlcnNpb24sIG9mZik7XG4gICAgb2ZmICs9IDQ7XG4gICAgaWYgKHVzZVdpdG5lc3MpIHtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBCdWZmZXIuZnJvbSgnMDAnLCAnaGV4JykpOyAvLyBtYXJrZXIgPSAweDAwXG4gICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgQnVmZmVyLmZyb20oJzAxJywgJ2hleCcpKTsgLy8gZmxhZyA9IDB4MDFcbiAgICB9XG4gICAgLy8gU2VyaWFsaXplIHNpZ25lZCBpbnB1dHNcbiAgICB2YXIgbnVtSW5wdXRzID0gZ2V0VmFySW50KGlucHV0cy5sZW5ndGgpO1xuICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgbnVtSW5wdXRzKTtcbiAgICBvZmYgKz0gbnVtSW5wdXRzLmxlbmd0aDtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBpbnB1dC5oYXNoLnJldmVyc2UoKSk7XG4gICAgICAgIG9mZiArPSBpbnB1dC5oYXNoLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4ID0gZ2V0VTMyTEUoaW5wdXQuaW5kZXgpO1xuICAgICAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIGluZGV4KTtcbiAgICAgICAgb2ZmICs9IGluZGV4Lmxlbmd0aDtcbiAgICAgICAgdmFyIHNjcmlwdFR5cGUgPSBnZXRTY3JpcHRUeXBlKGlucHV0KTtcbiAgICAgICAgLy8gQnVpbGQgdGhlIHNpZ1NjcmlwdC4gTm90ZSB0aGF0IHAyd3BraCBkb2VzIG5vdCBoYXZlIGEgc2NyaXB0U2lnLlxuICAgICAgICBpZiAoc2NyaXB0VHlwZSA9PT0gQlRDX1NDUklQVF9UWVBFX1AyU0hfUDJXUEtIKSB7XG4gICAgICAgICAgICAvLyBCdWlsZCBhIHZlY3RvciAodmFyU2xpY2Ugb2YgdmFyU2xpY2UpIGNvbnRhaW5pbmcgdGhlIHJlZGVlbVNjcmlwdFxuICAgICAgICAgICAgdmFyIHJlZGVlbVNjcmlwdCA9IGJ1aWxkUmVkZWVtU2NyaXB0KGlucHV0LnB1YmtleSk7XG4gICAgICAgICAgICB2YXIgcmVkZWVtU2NyaXB0TGVuID0gZ2V0VmFySW50KHJlZGVlbVNjcmlwdC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHNsaWNlID0gQnVmZmVyLmNvbmNhdChbcmVkZWVtU2NyaXB0TGVuLCByZWRlZW1TY3JpcHRdKTtcbiAgICAgICAgICAgIHZhciBzbGljZUxlbiA9IGdldFZhckludChzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzbGljZUxlbik7XG4gICAgICAgICAgICBvZmYgKz0gc2xpY2VMZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzbGljZSk7XG4gICAgICAgICAgICBvZmYgKz0gc2xpY2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcmlwdFR5cGUgPT09IEJUQ19TQ1JJUFRfVFlQRV9QMlBLSCkge1xuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHNpZ25hdHVyZSArIHB1YmtleSBzY3JpcHQgdG8gc3BlbmQgdGhpcyBpbnB1dFxuICAgICAgICAgICAgdmFyIHNsaWNlID0gYnVpbGRTaWcoaW5wdXQuc2lnLCBpbnB1dC5wdWJrZXkpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzbGljZSk7XG4gICAgICAgICAgICBvZmYgKz0gc2xpY2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcmlwdFR5cGUgPT09IEJUQ19TQ1JJUFRfVFlQRV9QMldQS0hfVjApIHtcbiAgICAgICAgICAgIHZhciBlbXB0eVNjcmlwdCA9IEJ1ZmZlci5mcm9tKCcwMCcsICdoZXgnKTtcbiAgICAgICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgZW1wdHlTY3JpcHQpO1xuICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IHNlcXVlbmNlIGZvciBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICAgIHZhciBzZXF1ZW5jZSA9IGdldFUzMkxFKERFRkFVTFRfU0VRVUVOQ0UpO1xuICAgICAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIHNlcXVlbmNlKTtcbiAgICAgICAgb2ZmICs9IHNlcXVlbmNlLmxlbmd0aDtcbiAgICB9KTtcbiAgICAvLyBTZXJpYWxpemUgb3V0cHV0c1xuICAgIHZhciBudW1PdXRwdXRzID0gZ2V0VmFySW50KG91dHB1dHMubGVuZ3RoKTtcbiAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIG51bU91dHB1dHMpO1xuICAgIG9mZiArPSBudW1PdXRwdXRzLmxlbmd0aDtcbiAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXRVNjRMRShvdXRwdXQudmFsdWUpO1xuICAgICAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIHZhbHVlKTtcbiAgICAgICAgb2ZmICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgLy8gQnVpbGQgdGhlIG91dHB1dCBsb2NraW5nIHNjcmlwdCBhbmQgd3JpdGUgaXQgYXMgYSB2YXIgc2xpY2VcbiAgICAgICAgdmFyIHNjcmlwdCA9IGJ1aWxkTG9ja2luZ1NjcmlwdChvdXRwdXQucmVjaXBpZW50KTtcbiAgICAgICAgdmFyIHNjcmlwdExlbiA9IGdldFZhckludChzY3JpcHQubGVuZ3RoKTtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzY3JpcHRMZW4pO1xuICAgICAgICBvZmYgKz0gc2NyaXB0TGVuLmxlbmd0aDtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzY3JpcHQpO1xuICAgICAgICBvZmYgKz0gc2NyaXB0Lmxlbmd0aDtcbiAgICB9KTtcbiAgICAvLyBBZGQgd2l0bmVzcyBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh1c2VXaXRuZXNzKSB7XG4gICAgICAgIHZhciBzaWdzID0gW107XG4gICAgICAgIHZhciBwdWJrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaWdzLnB1c2goaW5wdXRzW2ldLnNpZyk7XG4gICAgICAgICAgICBwdWJrZXlzLnB1c2goaW5wdXRzW2ldLnB1YmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpdG5lc3NTbGljZSA9IGJ1aWxkV2l0bmVzcyhzaWdzLCBwdWJrZXlzKTtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCB3aXRuZXNzU2xpY2UpO1xuICAgICAgICBvZmYgKz0gd2l0bmVzc1NsaWNlLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gRmluaXNoIHdpdGggbG9ja3RpbWVcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcGF5bG9hZCwgZ2V0VTMyTEUobG9ja1RpbWUpXSkudG9TdHJpbmcoJ2hleCcpO1xufTtcbi8vIENvbnZlcnQgYSBwdWJrZXloYXNoIHRvIGEgYml0Y29pbiBiYXNlNThjaGVjayBhZGRyZXNzIHdpdGggYSB2ZXJzaW9uIGJ5dGVcbnZhciBnZXRCaXRjb2luQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJrZXloYXNoLCB2ZXJzaW9uKSB7XG4gICAgdmFyIGJlY2gzMlByZWZpeCA9IG51bGw7XG4gICAgdmFyIGJlY2gzMlZlcnNpb24gPSBudWxsO1xuICAgIGlmICh2ZXJzaW9uID09PSBGTVRfU0VHV0lUX05BVElWRV9WMCkge1xuICAgICAgICBiZWNoMzJQcmVmaXggPSBTRUdXSVRfTkFUSVZFX1YwX1BSRUZJWDtcbiAgICAgICAgYmVjaDMyVmVyc2lvbiA9IFNFR1dJVF9WMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmVyc2lvbiA9PT0gRk1UX1NFR1dJVF9OQVRJVkVfVjBfVEVTVE5FVCkge1xuICAgICAgICBiZWNoMzJQcmVmaXggPSBTRUdXSVRfTkFUSVZFX1YwX1RFU1RORVRfUFJFRklYO1xuICAgICAgICBiZWNoMzJWZXJzaW9uID0gU0VHV0lUX1YwO1xuICAgIH1cbiAgICBpZiAoYmVjaDMyUHJlZml4ICE9PSBudWxsICYmIGJlY2gzMlZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdvcmRzID0gYmVjaDMyXzEuYmVjaDMyLnRvV29yZHMocHVia2V5aGFzaCk7XG4gICAgICAgIHdvcmRzLnVuc2hpZnQoYmVjaDMyVmVyc2lvbik7XG4gICAgICAgIHJldHVybiBiZWNoMzJfMS5iZWNoMzIuZW5jb2RlKGJlY2gzMlByZWZpeCwgd29yZHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJzNThjaGVja18xLmRlZmF1bHQuZW5jb2RlKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFt2ZXJzaW9uXSksIHB1YmtleWhhc2hdKSk7XG4gICAgfVxufTtcbi8vIEJ1aWxkZXIgdXRpbHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGJ1aWxkUmVkZWVtU2NyaXB0KHB1YmtleSkge1xuICAgIHZhciByZWRlZW1TY3JpcHQgPSBCdWZmZXIuYWxsb2MoMjIpO1xuICAgIHZhciBzaGFIYXNoID0gQnVmZmVyLmZyb20oKDAsIHNoYV8xLnNoYTI1NikoKS51cGRhdGUocHVia2V5KS5kaWdlc3QoJ2hleCcpLCAnaGV4Jyk7XG4gICAgdmFyIHB1YmtleWhhc2ggPSBCdWZmZXIuZnJvbSgoMCwgcmlwZW1kXzEucmlwZW1kMTYwKSgpLnVwZGF0ZShzaGFIYXNoKS5kaWdlc3QoJ2hleCcpLCAnaGV4Jyk7XG4gICAgcmVkZWVtU2NyaXB0LndyaXRlVUludDgoT1AuWkVSTywgMCk7XG4gICAgcmVkZWVtU2NyaXB0LndyaXRlVUludDgocHVia2V5aGFzaC5sZW5ndGgsIDEpO1xuICAgIHB1YmtleWhhc2guY29weShyZWRlZW1TY3JpcHQsIDIpO1xuICAgIHJldHVybiByZWRlZW1TY3JpcHQ7XG59XG4vLyBWYXIgc2xpY2Ugb2Ygc2lnbmF0dXJlICsgdmFyIHNsaWNlIG9mIHB1YmtleVxuZnVuY3Rpb24gYnVpbGRTaWcoc2lnLCBwdWJrZXkpIHtcbiAgICBzaWcgPSBCdWZmZXIuY29uY2F0KFtzaWcsIERFRkFVTFRfU0lHSEFTSF9CVUZGRVJdKTtcbiAgICB2YXIgc2lnTGVuID0gZ2V0VmFySW50KHNpZy5sZW5ndGgpO1xuICAgIHZhciBwdWJrZXlMZW4gPSBnZXRWYXJJbnQocHVia2V5Lmxlbmd0aCk7XG4gICAgdmFyIHNsaWNlID0gQnVmZmVyLmNvbmNhdChbc2lnTGVuLCBzaWcsIHB1YmtleUxlbiwgcHVia2V5XSk7XG4gICAgdmFyIGxlbiA9IGdldFZhckludChzbGljZS5sZW5ndGgpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtsZW4sIHNsaWNlXSk7XG59XG4vLyBXaXRuZXNzIGlzIHdyaXR0ZW4gYXMgYSBcInZlY3RvclwiLCB3aGljaCBpcyBhIGxpc3Qgb2YgdmFyU2xpY2VzXG4vLyBwcmVmaXhlZCBieSB0aGUgbnVtYmVyIG9mIGl0ZW1zXG5mdW5jdGlvbiBidWlsZFdpdG5lc3Moc2lncywgcHVia2V5cykge1xuICAgIHZhciB3aXRuZXNzID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIC8vIFR3byBpdGVtcyBpbiBlYWNoIHZlY3RvciAoc2lnLCBwdWJrZXkpXG4gICAgdmFyIGxlbiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICBsZW4ud3JpdGVVSW50OCgyLCAwKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNpZyA9IEJ1ZmZlci5jb25jYXQoW3NpZ3NbaV0sIERFRkFVTFRfU0lHSEFTSF9CVUZGRVJdKTtcbiAgICAgICAgdmFyIHNpZ0xlbiA9IGdldFZhckludChzaWcubGVuZ3RoKTtcbiAgICAgICAgdmFyIHB1YmtleSA9IHB1YmtleXNbaV07XG4gICAgICAgIHZhciBwdWJrZXlMZW4gPSBnZXRWYXJJbnQocHVia2V5Lmxlbmd0aCk7XG4gICAgICAgIHdpdG5lc3MgPSBCdWZmZXIuY29uY2F0KFt3aXRuZXNzLCBsZW4sIHNpZ0xlbiwgc2lnLCBwdWJrZXlMZW4sIHB1YmtleV0pO1xuICAgIH1cbiAgICByZXR1cm4gd2l0bmVzcztcbn1cbi8vIExvY2tpbmcgc2NyaXB0IGJ1aWRlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGJ1aWxkTG9ja2luZ1NjcmlwdChhZGRyZXNzKSB7XG4gICAgdmFyIGRlYyA9IGRlY29kZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgc3dpdGNoIChkZWMudmVyc2lvbkJ5dGUpIHtcbiAgICAgICAgY2FzZSBGTVRfU0VHV0lUX05BVElWRV9WMDpcbiAgICAgICAgY2FzZSBGTVRfU0VHV0lUX05BVElWRV9WMF9URVNUTkVUOlxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUDJ3cGtoTG9ja2luZ1NjcmlwdChkZWMucGtoKTtcbiAgICAgICAgY2FzZSBGTVRfU0VHV0lUX1dSQVBQRUQ6XG4gICAgICAgIGNhc2UgRk1UX1NFR1dJVF9XUkFQUEVEX1RFU1RORVQ6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQMnNoTG9ja2luZ1NjcmlwdChkZWMucGtoKTtcbiAgICAgICAgY2FzZSBGTVRfTEVHQUNZOlxuICAgICAgICBjYXNlIEZNVF9MRUdBQ1lfVEVTVE5FVDpcbiAgICAgICAgICAgIHJldHVybiBidWlsZFAycGtoTG9ja2luZ1NjcmlwdChkZWMucGtoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdmVyc2lvbiBieXRlOiBcIi5jb25jYXQoZGVjLnZlcnNpb25CeXRlLCBcIi4gQ2Fubm90IGJ1aWxkIEJUQyB0cmFuc2FjdGlvbi5cIikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUDJwa2hMb2NraW5nU2NyaXB0KHB1YmtleWhhc2gpIHtcbiAgICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jKDUgKyBwdWJrZXloYXNoLmxlbmd0aCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgb3V0LndyaXRlVUludDgoT1AuRFVQLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIG91dC53cml0ZVVJbnQ4KE9QLkhBU0gxNjAsIG9mZik7XG4gICAgb2ZmKys7XG4gICAgb3V0LndyaXRlVUludDgocHVia2V5aGFzaC5sZW5ndGgsIG9mZik7XG4gICAgb2ZmKys7XG4gICAgcHVia2V5aGFzaC5jb3B5KG91dCwgb2ZmKTtcbiAgICBvZmYgKz0gcHVia2V5aGFzaC5sZW5ndGg7XG4gICAgb3V0LndyaXRlVUludDgoT1AuRVFVQUxWRVJJRlksIG9mZik7XG4gICAgb2ZmKys7XG4gICAgb3V0LndyaXRlVUludDgoT1AuQ0hFQ0tTSUcsIG9mZik7XG4gICAgb2ZmKys7XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGJ1aWxkUDJzaExvY2tpbmdTY3JpcHQocHVia2V5aGFzaCkge1xuICAgIHZhciBvdXQgPSBCdWZmZXIuYWxsb2MoMyArIHB1YmtleWhhc2gubGVuZ3RoKTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBvdXQud3JpdGVVSW50OChPUC5IQVNIMTYwLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIG91dC53cml0ZVVJbnQ4KHB1YmtleWhhc2gubGVuZ3RoLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIHB1YmtleWhhc2guY29weShvdXQsIG9mZik7XG4gICAgb2ZmICs9IHB1YmtleWhhc2gubGVuZ3RoO1xuICAgIG91dC53cml0ZVVJbnQ4KE9QLkVRVUFMLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBidWlsZFAyd3BraExvY2tpbmdTY3JpcHQocHVia2V5aGFzaCkge1xuICAgIHZhciBvdXQgPSBCdWZmZXIuYWxsb2MoMiArIHB1YmtleWhhc2gubGVuZ3RoKTtcbiAgICBvdXQud3JpdGVVSW50OChPUC5aRVJPLCAwKTtcbiAgICBvdXQud3JpdGVVSW50OChwdWJrZXloYXNoLmxlbmd0aCwgMSk7XG4gICAgcHVia2V5aGFzaC5jb3B5KG91dCwgMik7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8vIFN0YXRpYyBVdGlsc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjb25jYXQoYmFzZSwgYWRkaXRpb24pIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbYmFzZSwgYWRkaXRpb25dKTtcbn1cbmZ1bmN0aW9uIGdldFU2NExFKHgpIHtcbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgIHdyaXRlVUludDY0TEUoeCwgYnVmZmVyLCAwKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gZ2V0VTMyTEUoeCkge1xuICAgIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoeCwgMCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGdldFZhckludCh4KSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoeCA8IDB4ZmQpIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCh4LCAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeCA8PSAweGZmZmYpIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDMpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCgweGZkLCAwKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDE2TEUoeCwgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggPCAweGZmZmZmZmZmKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg1KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgoMHhmZSwgMCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHgsIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDkpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCgweGZmLCAwKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoeCA+Pj4gMCwgMSk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKCh4IC8gMHgxMDAwMDAwMDApIHwgMCwgNSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKG4sIGJ1Ziwgb2ZmKSB7XG4gICAgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJylcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoMTYpO1xuICAgIHZhciBwcmVCdWYgPSBCdWZmZXIuYWxsb2MoOCk7XG4gICAgdmFyIG5TdHIgPSBuLmxlbmd0aCAlIDIgPT09IDAgPyBuLnRvU3RyaW5nKDE2KSA6IFwiMFwiLmNvbmNhdChuLnRvU3RyaW5nKDE2KSk7XG4gICAgdmFyIG5CdWYgPSBCdWZmZXIuZnJvbShuU3RyLCAnaGV4Jyk7XG4gICAgbkJ1Zi5yZXZlcnNlKCkuY29weShwcmVCdWYsIDApO1xuICAgIHByZUJ1Zi5jb3B5KGJ1Ziwgb2ZmKTtcbiAgICByZXR1cm4gcHJlQnVmO1xufVxuZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdmFyIHZlcnNpb25CeXRlLCBwa2g7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBiYXNlNTggZGVjb2RlIHRoZSBhZGRyZXNzLiBUaGlzIHdpbGwgd29yayBmb3Igb2xkZXJcbiAgICAgICAgLy8gUDJQS0gsIFAyU0gsIGFuZCBQMlNILVAyV1BLSCBhZGRyZXNzZXNcbiAgICAgICAgdmVyc2lvbkJ5dGUgPSBiczU4Y2hlY2tfMS5kZWZhdWx0LmRlY29kZShhZGRyZXNzKVswXTtcbiAgICAgICAgcGtoID0gYnM1OGNoZWNrXzEuZGVmYXVsdC5kZWNvZGUoYWRkcmVzcykuc2xpY2UoMSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGJhc2U1OCBkZWNvZGUsIHRoZSBhZGRyZXNzIG11c3QgYmUgYmVjaDMyIGVuY29kZWQuXG4gICAgICAgIC8vIElmIG5laXRoZXIgZGVjb2RpbmcgbWV0aG9kIHdvcmtzLCB0aGUgYWRkcmVzcyBpcyBpbnZhbGlkLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJlY2gzMkRlYyA9IGJlY2gzMl8xLmJlY2gzMi5kZWNvZGUoYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoYmVjaDMyRGVjLnByZWZpeCA9PT0gU0VHV0lUX05BVElWRV9WMF9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uQnl0ZSA9IEZNVF9TRUdXSVRfTkFUSVZFX1YwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVjaDMyRGVjLnByZWZpeCA9PT0gU0VHV0lUX05BVElWRV9WMF9URVNUTkVUX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHZlcnNpb25CeXRlID0gRk1UX1NFR1dJVF9OQVRJVkVfVjBfVEVTVE5FVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJlZml4OiBtdXN0IGJlIGJjIG9yIHRiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRlY29kZWRcbiAgICAgICAgICAgIGlmIChiZWNoMzJEZWMud29yZHNbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzZWd3aXQgdmVyc2lvbjogbXVzdCBiZSAwLCBnb3QgXCIuY29uY2F0KGJlY2gzMkRlYy53b3Jkc1swXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3MgdHlwZSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAvLyBXZSBjdXJyZW50bHkgb25seSBzdXBwb3J0IFAyV1BLSCBhZGRyZXNzZXMsIHdoaWNoIGJlY2gtMzJkZWNvZGUgdG8gMzMgd29yZHMuXG4gICAgICAgICAgICAvLyBQMldTSCBhZGRyZXNzZXMgYXJlIDUzIHdvcmRzLCBidXQgd2UgZG8gbm90IHN1cHBvcnQgdGhlbS5cbiAgICAgICAgICAgIC8vIE5vdCBzdXJlIHdoYXQgb3RoZXIgYWRkcmVzcyB0eXBlcyBjb3VsZCBleGlzdCwgYnV0IGlmIHRoZXkgZXhpc3Qgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgdGhlbSBlaXRoZXIuXG4gICAgICAgICAgICBpZiAoYmVjaDMyRGVjLndvcmRzLmxlbmd0aCAhPT0gMzMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNQMndwc2ggPSBiZWNoMzJEZWMud29yZHMubGVuZ3RoID09PSA1MztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhZGRyZXNzXCIuY29uY2F0KGlzUDJ3cHNoID8gJyAoUDJXU0ggbm90IHN1cHBvcnRlZCknIDogJycsIFwiOiBcIikuY29uY2F0KGFkZHJlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBraCA9IEJ1ZmZlci5mcm9tKGJlY2gzMl8xLmJlY2gzMi5mcm9tV29yZHMoYmVjaDMyRGVjLndvcmRzLnNsaWNlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSBhZGRyZXNzOiBcIi5jb25jYXQoYWRkcmVzcywgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2ZXJzaW9uQnl0ZTogdmVyc2lvbkJ5dGUsIHBraDogcGtoIH07XG59XG4vLyBEZXRlcm1pbmUgdGhlIGFkZHJlc3MgZm9ybWF0IChhLmsuYS4gXCJ2ZXJzaW9uXCIpIGRlcGVuZGluZyBvbiB0aGVcbi8vIHB1cnBvc2Ugb2YgdGhlIGRlcnZhdGlvbiBwYXRoLlxuZnVuY3Rpb24gZ2V0QWRkcmVzc0Zvcm1hdChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgPjEgaW5kZXgnKTtcbiAgICB2YXIgcHVycG9zZSA9IHBhdGhbMF07XG4gICAgdmFyIGNvaW4gPSBwYXRoWzFdO1xuICAgIGlmIChwdXJwb3NlID09PSBQVVJQT1NFUy5CVENfU0VHV0lUICYmIGNvaW4gPT09IENPSU5TLkJUQykge1xuICAgICAgICByZXR1cm4gRk1UX1NFR1dJVF9OQVRJVkVfVjA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHB1cnBvc2UgPT09IFBVUlBPU0VTLkJUQ19TRUdXSVQgJiYgY29pbiA9PT0gQ09JTlMuQlRDX1RFU1RORVQpIHtcbiAgICAgICAgcmV0dXJuIEZNVF9TRUdXSVRfTkFUSVZFX1YwX1RFU1RORVQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHB1cnBvc2UgPT09IFBVUlBPU0VTLkJUQ19XUkFQUEVEX1NFR1dJVCAmJiBjb2luID09PSBDT0lOUy5CVEMpIHtcbiAgICAgICAgcmV0dXJuIEZNVF9TRUdXSVRfV1JBUFBFRDtcbiAgICB9XG4gICAgZWxzZSBpZiAocHVycG9zZSA9PT0gUFVSUE9TRVMuQlRDX1dSQVBQRURfU0VHV0lUICYmXG4gICAgICAgIGNvaW4gPT09IENPSU5TLkJUQ19URVNUTkVUKSB7XG4gICAgICAgIHJldHVybiBGTVRfU0VHV0lUX1dSQVBQRURfVEVTVE5FVDtcbiAgICB9XG4gICAgZWxzZSBpZiAocHVycG9zZSA9PT0gUFVSUE9TRVMuQlRDX0xFR0FDWSAmJiBjb2luID09PSBDT0lOUy5CVEMpIHtcbiAgICAgICAgcmV0dXJuIEZNVF9MRUdBQ1k7XG4gICAgfVxuICAgIGVsc2UgaWYgKHB1cnBvc2UgPT09IFBVUlBPU0VTLkJUQ19MRUdBQ1kgJiYgY29pbiA9PT0gQ09JTlMuQlRDX1RFU1RORVQpIHtcbiAgICAgICAgcmV0dXJuIEZNVF9MRUdBQ1lfVEVTVE5FVDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBCaXRjb2luIHBhdGggcHJvdmlkZWQuIENhbm5vdCBkZXRlcm1pbmUgYWRkcmVzcyBmb3JtYXQuJyk7XG4gICAgfVxufVxuLy8gRGV0ZXJtaW5lIHRoZSBzY3JpcHQgdHlwZSBmb3IgYW4gaW5wdXQgYmFzZWQgb24gaXRzIG93bmVyJ3MgZGVyaXZhdGlvblxuLy8gcGF0aCdzIGBwdXJwb3NlYCBpbmRleC5cbi8vIFdlIGRvIG5vdCBzdXBwb3J0IHAyc2ggYW5kIG9ubHkgaXNzdWUgc2luZ2xlLWtleSBhZGRyZXNzZXMgZnJvbSB0aGUgTGF0dGljZVxuLy8gc28gd2UgY2FuIGRldGVybWluZSB0aGlzIGJhc2VkIG9uIHBhdGggYWxvbmUuXG5mdW5jdGlvbiBnZXRTY3JpcHRUeXBlKGlucHV0KSB7XG4gICAgc3dpdGNoIChpbnB1dC5zaWduZXJQYXRoWzBdKSB7XG4gICAgICAgIGNhc2UgUFVSUE9TRVMuQlRDX0xFR0FDWTpcbiAgICAgICAgICAgIHJldHVybiBCVENfU0NSSVBUX1RZUEVfUDJQS0g7XG4gICAgICAgIGNhc2UgUFVSUE9TRVMuQlRDX1dSQVBQRURfU0VHV0lUOlxuICAgICAgICAgICAgcmV0dXJuIEJUQ19TQ1JJUFRfVFlQRV9QMlNIX1AyV1BLSDtcbiAgICAgICAgY2FzZSBQVVJQT1NFUy5CVENfU0VHV0lUOlxuICAgICAgICAgICAgcmV0dXJuIEJUQ19TQ1JJUFRfVFlQRV9QMldQS0hfVjA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXRoIHB1cnBvc2UgKFwiLmNvbmNhdChpbnB1dC5zaWduZXJQYXRoWzBdLCBcIik6IGNhbm5vdCBkZXRlcm1pbmUgQlRDIHNjcmlwdCB0eXBlLlwiKSk7XG4gICAgfVxufVxuLy8gRGV0ZXJtaW5lIGlmIGEgYSB0cmFuc2FjdGlvbiBzaG91bGQgaGF2ZSBhIHdpdG5lc3MgcG9ydGlvbi5cbi8vIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBpZiBhbnkgaW5wdXQgaXMgcDJzaChwMndwa2gpIG9yIHAyd3BraC5cbi8vIFdlIGRldGVybWluZSB0aGUgc2NyaXB0IHR5cGUgYmFzZWQgb24gdGhlIGRlcml2YXRpb24gcGF0aC5cbmZ1bmN0aW9uIG5lZWRzV2l0bmVzcyhpbnB1dHMpIHtcbiAgICB2YXIgdyA9IGZhbHNlO1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuc2lnbmVyUGF0aFswXSA9PT0gUFVSUE9TRVMuQlRDX1NFR1dJVCB8fFxuICAgICAgICAgICAgaW5wdXQuc2lnbmVyUGF0aFswXSA9PT0gUFVSUE9TRVMuQlRDX1dSQVBQRURfU0VHV0lUKSB7XG4gICAgICAgICAgICB3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGJ1aWxkQml0Y29pblR4UmVxdWVzdDogYnVpbGRCaXRjb2luVHhSZXF1ZXN0LFxuICAgIHNlcmlhbGl6ZVR4OiBzZXJpYWxpemVUeCxcbiAgICBnZXRCaXRjb2luQWRkcmVzczogZ2V0Qml0Y29pbkFkZHJlc3MsXG4gICAgZ2V0QWRkcmVzc0Zvcm1hdDogZ2V0QWRkcmVzc0Zvcm1hdCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwbGFjZU5lc3RlZERlZnMgPSBleHBvcnRzLmdldE5lc3RlZENhbGxkYXRhID0gZXhwb3J0cy5wYXJzZUNhbm9uaWNhbE5hbWUgPSBleHBvcnRzLnBhcnNlU29saWRpdHlKU09OQUJJID0gdm9pZCAwO1xudmFyIGpzX3NoYTNfMSA9IHJlcXVpcmUoXCJqcy1zaGEzXCIpO1xudmFyIGFiaV8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2FiaVwiKTtcbi8qKlxuICogTG9vayB0aHJvdWdoIGFuIEFCSSBkZWZpbml0aW9uIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGZ1bmN0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgc2lnbmF0dXJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHNpZyAgICBhIDB4LXByZWZpeGVkIGhleCBzdHJpbmcgY29udGFpbmluZyA0IGJ5dGVzIG9mIGluZm9cbiAqIEBwYXJhbSBhYmkgICAgYSBTb2xpZGl0eSBKU09OIEFCSSBzdHJ1Y3R1cmUgKFtleHRlcm5hbCBsaW5rXShodHRwczovL2RvY3MuZXRoZXJzLmlvL3Y1L2FwaS91dGlscy9hYmkvZm9ybWF0cy8jYWJpLWZvcm1hdHMtLXNvbGlkaXR5KSlcbiAqIEByZXR1cm5zICAgICAgQnVmZmVyIGNvbnRhaW5pbmcgUkxQLXNlcmlhbGl6ZWQgYXJyYXkgb2YgY2FsbGRhdGEgaW5mbyB0byBwYXNzIHRvIHNpZ25pbmcgcmVxdWVzdFxuICogQHB1YmxpY1xuICovXG52YXIgcGFyc2VTb2xpZGl0eUpTT05BQkkgPSBmdW5jdGlvbiAoc2lnLCBhYmkpIHtcbiAgICBzaWcgPSBjb2VyY2VTaWcoc2lnKTtcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgQUJJXG4gICAgdmFyIG1hdGNoID0gYWJpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udHlwZSA9PT0gJ2Z1bmN0aW9uJzsgfSlcbiAgICAgICAgLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGRlZiA9IHBhcnNlRGVmKGl0ZW0pO1xuICAgICAgICB2YXIgZnVuY1NpZyA9IGdldEZ1bmNTaWcoZGVmLmNhbm9uaWNhbE5hbWUpO1xuICAgICAgICByZXR1cm4gZnVuY1NpZyA9PT0gc2lnO1xuICAgIH0pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgZGVmID0gcGFyc2VEZWYobWF0Y2gpLmRlZjtcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBtYXRjaGluZyBmdW5jdGlvbiBpbiBBQkknKTtcbn07XG5leHBvcnRzLnBhcnNlU29saWRpdHlKU09OQUJJID0gcGFyc2VTb2xpZGl0eUpTT05BQkk7XG4vKipcbiAqIENvbnZlcnQgYSBjYW5vbmljYWwgbmFtZSBpbnRvIGFuIEFCSSBkZWZpbml0aW9uIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHdpdGggY2FsbGRhdGEgdG8gYSBnZW5lcmFsXG4gKiBcIjJcIiwgXCIyLjFcIiwgXCIzXCIpXG4gKiBAcGFyYW0gc2lnICAgIGEgMHgtcHJlZml4ZWQgaGV4IHN0cmluZyBjb250YWluaW5nIDQgYnl0ZXMgb2YgaW5mb1xuICogQHBhcmFtIG5hbWUgICBjYW5vbmljYWwgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqIEByZXR1cm5zICAgICAgQnVmZmVyIGNvbnRhaW5pbmcgUkxQLXNlcmlhbGl6ZWQgYXJyYXkgb2YgY2FsbGRhdGEgaW5mbyB0byBwYXNzIHRvIHNpZ25pbmcgcmVxdWVzdFxuICogQHB1YmxpY1xuICovXG52YXIgcGFyc2VDYW5vbmljYWxOYW1lID0gZnVuY3Rpb24gKHNpZywgbmFtZSkge1xuICAgIHNpZyA9IGNvZXJjZVNpZyhzaWcpO1xuICAgIGlmIChzaWcgIT09IGdldEZ1bmNTaWcobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIGRvZXMgbm90IG1hdGNoIHByb3ZpZGVkIHNpZy4nKTtcbiAgICB9XG4gICAgdmFyIGRlZiA9IFtdO1xuICAgIC8vIEdldCB0aGUgZnVuY3Rpb24gbmFtZVxuICAgIHZhciBwYXJhbVN0YXJ0ID0gbmFtZS5pbmRleE9mKCcoJyk7XG4gICAgaWYgKHBhcmFtU3RhcnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihCQURfQ0FOT05JQ0FMX0VSUik7XG4gICAgfVxuICAgIGRlZi5wdXNoKG5hbWUuc2xpY2UoMCwgcGFyYW1TdGFydCkpO1xuICAgIG5hbWUgPSBuYW1lLnNsaWNlKHBhcmFtU3RhcnQgKyAxKTtcbiAgICB2YXIgcGFyYW1EZWYgPSBbXTtcbiAgICB3aGlsZSAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNjYW4gdW50aWwgdGhlIHRlcm1pbmF0aW5nICcpJ1xuICAgICAgICB2YXIgdHlwZVN0ciA9IHBvcFR5cGVTdHJGcm9tQ2Fub25pY2FsKG5hbWUpO1xuICAgICAgICBwYXJhbURlZiA9IHBhcmFtRGVmLmNvbmNhdChwYXJzZVR5cGVTdHIodHlwZVN0cikpO1xuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSh0eXBlU3RyLmxlbmd0aCArIDEpO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkUGFyYW1EZWYgPSBwYXJzZVBhcmFtRGVmKHBhcmFtRGVmKTtcbiAgICByZXR1cm4gZGVmLmNvbmNhdChwYXJzZWRQYXJhbURlZik7XG59O1xuZXhwb3J0cy5wYXJzZUNhbm9uaWNhbE5hbWUgPSBwYXJzZUNhbm9uaWNhbE5hbWU7XG4vKipcbiAqIFB1bGwgb3V0IG5lc3RlZCBjYWxsZGF0YSB3aGljaCBtYXkgY29ycmVzcG9uZCB0byBuZXN0ZWQgQUJJIGRlZmluaXRpb25zLlxuICogVGhpcyBpcyByZWxldmFudCBmb3IgZS5nLiBgbXVsdGljYWxsYCBwYXR0ZXJucy5cbiAqIEEgZGVmIG1heSBiZSBuZXN0ZWQgaWYgdGhlIHVuZGVybHlpbmcgdHlwZSBpcyBgYnl0ZXNgIG9yIGBieXRlc1tdYCBhbmRcbiAqIHRoZSBjYWxsZGF0YSBwYXJtIGlzIG9mIHNpemUgKDQgKyAzMipuKS5cbiAqIEBwYXJhbSBkZWYgLSBjYWxsZGF0YSBkZWNvZGVyIGRhdGEgZm9yIGEgZGVmXG4gKiBAcGFyYW0gY2FsbGRhdGEgLSBCdWZmZXIgY29udGFpbmluZyBmdWxsIGNhbGxkYXRhIHBheWxvYWRcbiAqIEByZXR1cm4gLSAgQXJyYXkgb2YgY2FsbGRhdGEgcGFyYW1zLCBvciBudWxsIHZhbHVlcy4gSWYgdGhlIHJldHVyblxuICogICAgICAgICAgICBpdGVtIGhhcyBkYXRhICgweC1wcmVmaXhlZCBoZXggc3RyaW5nKSwgaXQgc2hvdWxkIGJlXG4gKiAgICAgICAgICAgIGNoZWNrZWQgYXMgYSBwb3NzaWJsZSBuZXN0ZWQgZGVmXG4gKi9cbnZhciBnZXROZXN0ZWRDYWxsZGF0YSA9IGZ1bmN0aW9uIChkZWYsIGNhbGxkYXRhKSB7XG4gICAgdmFyIHBvc3NpYmxlTmVzdGVkRGVmcyA9IFtdO1xuICAgIC8vIFNraXAgcGFzdCBmaXJzdCBpdGVtLCB3aGljaCBpcyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgIHZhciBkZWZQYXJhbXMgPSBkZWYuc2xpY2UoMSk7XG4gICAgdmFyIHN0clBhcmFtcyA9IGdldFBhcmFtU3RyTmFtZXMoZGVmUGFyYW1zKTtcbiAgICB2YXIgY29kZXIgPSBuZXcgYWJpXzEuQWJpQ29kZXIoKTtcbiAgICB2YXIgZGVjb2RlZCA9IGNvZGVyLmRlY29kZShzdHJQYXJhbXMsICcweCcgKyBjYWxsZGF0YS5zbGljZSg0KS50b1N0cmluZygnaGV4JykpO1xuICAgIGZ1bmN0aW9uIGNvdWxkQmVOZXN0ZWREZWYoeCkge1xuICAgICAgICByZXR1cm4gKHgubGVuZ3RoIC0gNCkgJSAzMiA9PT0gMDtcbiAgICB9XG4gICAgZGVjb2RlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbURhdGEsIGkpIHtcbiAgICAgICAgaWYgKGlzQnl0ZXNUeXBlKGRlZlBhcmFtc1tpXSkpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWREZWZJc1Bvc3NpYmxlXzEgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXNBcnJJdGVtKGRlZlBhcmFtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBgYnl0ZXNbXWAgdHlwZS4gRGVjb2RlIGFsbCB1bmRlcmx5aW5nIGBieXRlc2AgaXRlbXMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZG8gc2l6ZSBjaGVja3Mgb24gdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogV2Ugb25seSBkbyB0aGlzIGZvciBgYnl0ZXNbXWAgYnV0IGNvdWxkLCBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAgICAgICAgIC8vIGV4dGVuZCB0byBtb3JlIGNvbXBsZXggYXJyYXkgc3RydWN0dXJlcyBpZiB3ZSBzZWUgbmVzdGVkIGRlZnNcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIHBhdHRlcm4uIEhvd2V2ZXIsIHdlIGhhdmUgb25seSBldmVyIHNlZW4gYGJ5dGVzW11gLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIGlzIHR5cGljYWxseSB1c2VkIGluIGBtdWx0aWNhbGxgIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgcGFyYW1EYXRhLmZvckVhY2goZnVuY3Rpb24gKG5lc3RlZFBhcmFtRGF0dW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lc3RlZFBhcmFtRGF0dW1CdWYgPSBCdWZmZXIuZnJvbShuZXN0ZWRQYXJhbURhdHVtLnNsaWNlKDIpLCAnaGV4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY291bGRCZU5lc3RlZERlZihuZXN0ZWRQYXJhbURhdHVtQnVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmSXNQb3NzaWJsZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQnl0ZXNJdGVtKGRlZlBhcmFtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIGBieXRlc2AgdHlwZSAtIHBlcmZvcm0gc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbURhdGFCdWYgPSBCdWZmZXIuZnJvbShwYXJhbURhdGEuc2xpY2UoMiksICdoZXgnKTtcbiAgICAgICAgICAgICAgICBuZXN0ZWREZWZJc1Bvc3NpYmxlXzEgPSBjb3VsZEJlTmVzdGVkRGVmKHBhcmFtRGF0YUJ1Zik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVbmtub3duIGBieXRlc2AgaXRlbSB0eXBlXG4gICAgICAgICAgICAgICAgbmVzdGVkRGVmSXNQb3NzaWJsZV8xID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSBjb3VsZCBjb250YWluIGEgbmVzdGVkIGRlZiAoZGV0ZXJtaW5lZCBiYXNlZCBvblxuICAgICAgICAgICAgLy8gZGF0YSBzaXplIG9mIHRoZSBpdGVtKSwgYWRkIHRoZSBwYXJhbURhdGEgdG8gdGhlIHJldHVybiBhcnJheS5cbiAgICAgICAgICAgIHBvc3NpYmxlTmVzdGVkRGVmcy5wdXNoKG5lc3RlZERlZklzUG9zc2libGVfMSA/IHBhcmFtRGF0YSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVzdGVkIGRlZnMgZm9yIG5vbi1ieXRlcyB0eXBlc1xuICAgICAgICAgICAgcG9zc2libGVOZXN0ZWREZWZzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcG9zc2libGVOZXN0ZWREZWZzO1xufTtcbmV4cG9ydHMuZ2V0TmVzdGVkQ2FsbGRhdGEgPSBnZXROZXN0ZWRDYWxsZGF0YTtcbi8qKlxuICogSWYgYXBwbGljYWJsZSwgdXBkYXRlIGRlY29kZXIgZGF0YSB0byByZXByZXNlbnQgbmVzdGVkXG4gKiBkZWZpbml0aW9ucywgd2hpY2ggYXJlIHVzZWQgaW4gZS5nLiBtdWx0aWNhbGwgcGF0dGVybnMuXG4gKiBUaGlzIHdpbGwgdXBkYXRlIGBkZWZgIGluIHBsYWNlIGFuZCByZXR1cm4gaXQgd2l0aCBhbnlcbiAqIGFkZGl0aW9uYWwgaW5mbyBuZWNlc3NhcnkuXG4gKiBAcGFyYW0gZGVmIC0gRGVjb2RlciBkYXRhIGZvciBhIHNwZWNpZmljIGNhbGxkYXRhIGZ1bmN0aW9uIChkZWYpXG4gKiBAcGFyYW0gbmVzdGVkRGVmcyAtIEFycmF5IGNvbnRhaW5pbmcgYSBwb3NzaWJsZSBzZXQgb2YgbmVzdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgIGRlZnMgd2hpY2ggbXVzdCBiZSBhZGRlZCB0byBgZGVmYFxuICogQHJldHVybiAtIFBvc3NpYmx5IG1vZGlmaWVkIHZlcnNpb24gb2YgYGRlZmBcbiAqL1xudmFyIHJlcGxhY2VOZXN0ZWREZWZzID0gZnVuY3Rpb24gKGRlZiwgbmVzdGVkRGVmcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVzdGVkRGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXNBcnJJdGVtID0gaXNCeXRlc0Fyckl0ZW0oZGVmWzEgKyBpXSk7XG4gICAgICAgIHZhciBpc0l0ZW0gPSBpc0J5dGVzSXRlbShkZWZbMSArIGldKTtcbiAgICAgICAgaWYgKG5lc3RlZERlZnNbaV0gIT09IG51bGwgJiYgKGlzQXJySXRlbSB8fCBpc0l0ZW0pKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGRlZiBpdGVtIHR5cGUgdG8gaW5kaWNhdGUgaXQgd2lsbCBob2xkXG4gICAgICAgICAgICAvLyBvbmUgb3IgbW9yZSBuZXN0ZWQgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgIGRlZlsxICsgaV1bMV0gPSBFVk1fVFlQRVMuaW5kZXhPZignbmVzdGVkRGVmJyk7XG4gICAgICAgICAgICAvLyBBZGQgbmVzdGVkIGRlZihzKSBpbiBpbiBhbiBhcnJheS4gSWYgdGhpcyBpcyBhbiBhcnJheVxuICAgICAgICAgICAgLy8gaXRlbSBpdCBtZWFucyB0aGUgbmVzdGVkRGVmcyBzaG91bGQgYWxyZWFkeSBiZSBpbiBhblxuICAgICAgICAgICAgLy8gYXJyYXkuIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHdyYXAgdGhlIHNpbmdsZSBuZXN0ZWRcbiAgICAgICAgICAgIC8vIGRlZiBpbiBhbiBhcnJheSB0byBrZWVwIHRoZSBkYXRhIHR5cGUgY29uc2lzdGVudC5cbiAgICAgICAgICAgIHZhciBkZWZzID0gaXNBcnJJdGVtID8gbmVzdGVkRGVmc1tpXSA6IFtuZXN0ZWREZWZzW2ldXTtcbiAgICAgICAgICAgIGRlZlsxICsgaV0gPSBkZWZbMSArIGldLmNvbmNhdChbZGVmc10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59O1xuZXhwb3J0cy5yZXBsYWNlTmVzdGVkRGVmcyA9IHJlcGxhY2VOZXN0ZWREZWZzO1xuLyoqXG4gKiBDb252ZXJ0IGEgY2Fub25pY2FsIG5hbWUgdG8gYSBmdW5jdGlvbiBzZWxlY3RvciAoYS5rLmEuIFwic2lnXCIpXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY1NpZyhjYW5vbmljYWxOYW1lKSB7XG4gICAgcmV0dXJuIFwiMHhcIi5jb25jYXQoKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGNhbm9uaWNhbE5hbWUpLnNsaWNlKDAsIDgpKTtcbn1cbi8qKlxuICogRW5zdXJlIHRoZSBzaWcgaXMgcHJvcGVybHkgZm9ybWF0dGVkXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVNpZyhzaWcpIHtcbiAgICBpZiAodHlwZW9mIHNpZyAhPT0gJ3N0cmluZycgfHwgKHNpZy5sZW5ndGggIT09IDEwICYmIHNpZy5sZW5ndGggIT09IDgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHNpZ2AgbXVzdCBiZSBhIGhleCBzdHJpbmcgd2l0aCA0IGJ5dGVzIG9mIGRhdGEuJyk7XG4gICAgfVxuICAgIGlmIChzaWcubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHNpZyA9IFwiMHhcIi5jb25jYXQoc2lnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZztcbn1cbi8qKlxuICogQ29udmVydCBjYWxsZGF0YSBwYXJhbSBkZWZpbml0aW9ucyBpbnRvIGFuIGFycmF5IG9mIHRoZWlyXG4gKiBjYW5vbmljYWwgc3RyaW5nIG5hbWVzLlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmcgbmFtZXMgdGhhdCBhcmUgY29uc3VtYWJsZSBieVxuICogdGhlIEBldGhlcnNwcm9qZWN0L2FiaSBBYmlDb2RlciBkZWNvZGVyIGluc3RhbmNlLlxuICogQHBhcmFtIGRlZlBhcmFtcyAtIEFycmF5IG9mIGRlZiBwYXJhbXNcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRQYXJhbVN0ck5hbWVzKGRlZlBhcmFtcykge1xuICAgIHZhciBzdHJOYW1lcyA9IFtdO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gZGVmUGFyYW1zW2ldO1xuICAgICAgICB2YXIgcyA9IEVWTV9UWVBFU1twYXJhbVsxXV07XG4gICAgICAgIGlmIChwYXJhbVsyXSkge1xuICAgICAgICAgICAgcyA9IFwiXCIuY29uY2F0KHMpLmNvbmNhdChwYXJhbVsyXSAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbVszXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJhbVszXS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtWzNdW2RdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBcIlwiLmNvbmNhdChzLCBcIltdXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IFwiXCIuY29uY2F0KHMsIFwiW1wiKS5jb25jYXQocGFyYW1bM11bZF0sIFwiXVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1bNF0pIHtcbiAgICAgICAgICAgIC8vIFR1cGxlIC0gZ2V0IG5lc3RlZCB0eXBlIG5hbWVzXG4gICAgICAgICAgICB2YXIgbmVzdGVkID0gZ2V0UGFyYW1TdHJOYW1lcyhwYXJhbVs0XSk7XG4gICAgICAgICAgICBzID0gXCJcIi5jb25jYXQocywgXCIoXCIpLmNvbmNhdChuZXN0ZWQuam9pbignLCcpLCBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyTmFtZXMucHVzaChzKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmUGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJOYW1lcztcbn1cbi8qKlxuICogVGFrZSB0aGUgbmV4dCB0eXBlIGZyb20gYSBjYW5vbmljYWwgZGVmaW5pdGlvbiBzdHJpbmcuIE5vdGUgdGhhdCB0aGUgc3RyaW5nIGNhbiBiZSB0aGF0IG9mIGFcbiAqIHR1cGxlLiBOT1RFOiBUaGUgc3RyaW5nIHNob3VsZCBzdGFydCBhdCB0aGUgaW5kZXggYWZ0ZXIgdGhlIGxlYWRpbmcgJygnXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcG9wVHlwZVN0ckZyb21DYW5vbmljYWwoc3ViTmFtZSkge1xuICAgIGlmIChpc1R1cGxlKHN1Yk5hbWUpKSB7XG4gICAgICAgIHJldHVybiBnZXRUdXBsZU5hbWUoc3ViTmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN1Yk5hbWUuaW5kZXhPZignLCcpID4gLTEpIHtcbiAgICAgICAgLy8gTm9ybWFsIG5vbi10dXBsZSBwYXJhbVxuICAgICAgICByZXR1cm4gc3ViTmFtZS5zbGljZSgwLCBzdWJOYW1lLmluZGV4T2YoJywnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN1Yk5hbWUuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgLy8gTGFzdCBub24tdHVwbGUgcGFyYW0gaW4gdGhlIG5hbWVcbiAgICAgICAgcmV0dXJuIHN1Yk5hbWUuc2xpY2UoMCwgc3ViTmFtZS5pbmRleE9mKCcpJykpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoQkFEX0NBTk9OSUNBTF9FUlIpO1xufVxuLyoqXG4gKiBQYXJzZSBhIHR5cGUgc3RyaW5nLCBlLmcuICd1aW50MjU2Jy4gQ29udmVydHMgdGhlIHN0cmluZyB0byBhbiBhcnJheSBvZiBFVk1QYXJhbUluZm8sIHdoaWNoIG1heVxuICogaGF2ZSBuZXN0ZWQgc3RydWN0dXJlIGlmIHRoZXJlIGFyZSB0dXBsZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcGFyc2VUeXBlU3RyKHR5cGVTdHIpIHtcbiAgICAvLyBOb24tdHVwbGVzIGNhbiBiZSBkZWNvZGVkIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgcmVjdXJzaW9uXG4gICAgaWYgKCFpc1R1cGxlKHR5cGVTdHIpKSB7XG4gICAgICAgIHJldHVybiBbcGFyc2VCYXNpY1R5cGVTdHIodHlwZVN0cildO1xuICAgIH1cbiAgICAvLyBUdXBsZXMgbWF5IHJlcXVpcmUgcmVjdXJzaW9uXG4gICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBzekJ5dGVzOiAwLFxuICAgICAgICB0eXBlSWR4OiBFVk1fVFlQRVMuaW5kZXhPZigndHVwbGUnKSxcbiAgICAgICAgYXJyYXlTenM6IFtdLFxuICAgIH07XG4gICAgLy8gR2V0IHRoZSBmdWxsIHR1cGxlIHBhcmFtIG5hbWUgYW5kIHNlcGFyYXRlIG91dCB0aGUgYXJyYXkgc3R1ZmZcbiAgICB2YXIgdHlwZVN0ckxlc3NBcnIgPSBnZXRUdXBsZU5hbWUodHlwZVN0ciwgZmFsc2UpO1xuICAgIHZhciB0eXBlU3RyQXJyID0gdHlwZVN0ci5zbGljZSh0eXBlU3RyTGVzc0Fyci5sZW5ndGgpO1xuICAgIHBhcmFtLmFycmF5U3pzID0gZ2V0QXJyYXlTenModHlwZVN0ckFycik7XG4gICAgLy8gU2xpY2Ugb2ZmIHRoZSBsZWFkaW5nIHBhcmVuXG4gICAgdHlwZVN0ckxlc3NBcnIgPSB0eXBlU3RyTGVzc0Fyci5zbGljZSgxKTtcbiAgICAvLyBQYXJzZSBlYWNoIG5lc3RlZCBwYXJhbVxuICAgIHZhciBwYXJhbUFyciA9IFtdO1xuICAgIHdoaWxlICh0eXBlU3RyTGVzc0Fyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdWJUeXBlID0gcG9wVHlwZVN0ckZyb21DYW5vbmljYWwodHlwZVN0ckxlc3NBcnIpO1xuICAgICAgICB0eXBlU3RyTGVzc0FyciA9IHR5cGVTdHJMZXNzQXJyLnNsaWNlKHN1YlR5cGUubGVuZ3RoICsgMSk7XG4gICAgICAgIHBhcmFtQXJyID0gcGFyYW1BcnIuY29uY2F0KHBhcnNlVHlwZVN0cihzdWJUeXBlKSk7XG4gICAgfVxuICAgIC8vIFRoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIHN1Yi1wYXJhbSBpbiB0aGUgdHVwbGVcbiAgICBpZiAoIXBhcmFtQXJyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQkFEX0NBTk9OSUNBTF9FUlIpO1xuICAgIH1cbiAgICByZXR1cm4gW3BhcmFtLCBwYXJhbUFycl07XG59XG4vKipcbiAqIENvbnZlcnQgYSBiYXNpYyB0eXBlIChlLmcuICd1aW50MjU2JykgZnJvbSBhIHN0cmluZyB0byBFVk1QYXJhbUluZm8gdHlwZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwYXJzZUJhc2ljVHlwZVN0cih0eXBlU3RyKSB7XG4gICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBzekJ5dGVzOiAwLFxuICAgICAgICB0eXBlSWR4OiAwLFxuICAgICAgICBhcnJheVN6czogW10sXG4gICAgfTtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBFVk1fVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICBpZiAodHlwZVN0ci5pbmRleE9mKHQpID4gLTEgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgICBwYXJhbS50eXBlSWR4ID0gaTtcbiAgICAgICAgICAgIHBhcmFtLmFycmF5U3pzID0gZ2V0QXJyYXlTenModHlwZVN0cik7XG4gICAgICAgICAgICB2YXIgYXJyU3RhcnQgPSBwYXJhbS5hcnJheVN6cy5sZW5ndGggPiAwID8gdHlwZVN0ci5pbmRleE9mKCdbJykgOiB0eXBlU3RyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0eXBlU3RyTnVtID0gdHlwZVN0ci5zbGljZSh0Lmxlbmd0aCwgYXJyU3RhcnQpO1xuICAgICAgICAgICAgaWYgKHBhcnNlSW50KHR5cGVTdHJOdW0pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uc3pCeXRlcyA9IHBhcnNlSW50KHR5cGVTdHJOdW0pIC8gODtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0uc3pCeXRlcyA+IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihCQURfQ0FOT05JQ0FMX0VSUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQkFEX0NBTk9OSUNBTF9FUlIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG59XG4vKipcbiAqIFBhcnNlIGFuIEV0aGVyc2NhbiBkZWZpbml0aW9uIGludG8gYSBjYWxsZGF0YSBzdHJ1Y3R1cmUgdGhhdCB0aGUgTGF0dGljZSBFVk0gZGVjb2RlciBjYW4gaGFuZGxlXG4gKiAoRVZNRGVmKS4gVGhpcyBmdW5jdGlvbiBtYXkgcmVjdXJzZSBpZiB0aGVyZSBhcmUgdHVwbGUgdHlwZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcGFyc2VEZWYoaXRlbSwgY2Fub25pY2FsTmFtZSwgZGVmLCByZWN1cnNlZCkge1xuICAgIGlmIChjYW5vbmljYWxOYW1lID09PSB2b2lkIDApIHsgY2Fub25pY2FsTmFtZSA9ICcnOyB9XG4gICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7IGRlZiA9IFtdOyB9XG4gICAgaWYgKHJlY3Vyc2VkID09PSB2b2lkIDApIHsgcmVjdXJzZWQgPSBmYWxzZTsgfVxuICAgIC8vIEZ1bmN0aW9uIG5hbWUuIENhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKCFyZWN1cnNlZCkge1xuICAgICAgICB2YXIgbmFtZVN0ciA9IGl0ZW0ubmFtZSB8fCAnJztcbiAgICAgICAgZGVmLnB1c2gobmFtZVN0cik7XG4gICAgICAgIGNhbm9uaWNhbE5hbWUgKz0gbmFtZVN0cjtcbiAgICB9XG4gICAgLy8gTG9vcCB0aHJvdWdoIHBhcmFtc1xuICAgIGlmIChpdGVtLmlucHV0cykge1xuICAgICAgICBjYW5vbmljYWxOYW1lICs9ICcoJztcbiAgICAgICAgaXRlbS5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGlucHV0IHRvIGEgZmxhdCBwYXJhbSB0aGF0IHdlIGNhbiBzZXJpYWxpemVcbiAgICAgICAgICAgIHZhciBmbGF0UGFyYW0gPSBnZXRGbGF0UGFyYW0oaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUuaW5kZXhPZigndHVwbGUnKSA+IC0xICYmIGlucHV0LmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdHVwbGVzIHdlIG5lZWQgdG8gcmVjdXJzZVxuICAgICAgICAgICAgICAgIHZhciByZWN1cnNlZF8xID0gcGFyc2VEZWYoeyBpbnB1dHM6IGlucHV0LmNvbXBvbmVudHMgfSwgY2Fub25pY2FsTmFtZSwgW10sIHRydWUpO1xuICAgICAgICAgICAgICAgIGNhbm9uaWNhbE5hbWUgPSByZWN1cnNlZF8xLmNhbm9uaWNhbE5hbWU7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGJyYWNrZXRzIGlmIHRoaXMgaXMgYSB0dXBsZSBhcnJheSBhbmQgYWxzbyBhZGQgYSBjb21tYVxuICAgICAgICAgICAgICAgIGNhbm9uaWNhbE5hbWUgKz0gXCJcIi5jb25jYXQoaW5wdXQudHlwZS5zbGljZSg1KSwgXCIsXCIpO1xuICAgICAgICAgICAgICAgIGZsYXRQYXJhbS5wdXNoKHJlY3Vyc2VkXzEuZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbm9uaWNhbE5hbWUgKz0gaW5wdXQudHlwZTtcbiAgICAgICAgICAgICAgICBjYW5vbmljYWxOYW1lICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZi5wdXNoKGZsYXRQYXJhbSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUYWtlIG9mZiB0aGUgbGFzdCBjb21tYS4gTm90ZSB0aGF0IHdlIGRvIG5vdCB3YW50IHRvIHNsaWNlIGlmIHRoZSBsYXN0IHBhcmFtIHdhcyBhIHR1cGxlLFxuICAgICAgICAvLyBzaW5jZSB3ZSB3YW50IHRvIGtlZXAgdGhhdCBgKWBcbiAgICAgICAgaWYgKGNhbm9uaWNhbE5hbWVbY2Fub25pY2FsTmFtZS5sZW5ndGggLSAxXSA9PT0gJywnKSB7XG4gICAgICAgICAgICBjYW5vbmljYWxOYW1lID0gY2Fub25pY2FsTmFtZS5zbGljZSgwLCBjYW5vbmljYWxOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY2xvc2luZyBwYXJlbnNcbiAgICAgICAgY2Fub25pY2FsTmFtZSArPSAnKSc7XG4gICAgfVxuICAgIHJldHVybiB7IGRlZjogZGVmLCBjYW5vbmljYWxOYW1lOiBjYW5vbmljYWxOYW1lIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSBzZXQgb2YgRVZNUGFyYW1JbmZvIG9iamVjdHMgaW50byBhbiBhcnJheSB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIGludG8gZGVjb2RlciBpbmZvIHRoYXRcbiAqIGNhbiBiZSBwYXNzZWQgd2l0aCB0aGUgc2lnbmluZyByZXF1ZXN0LiBOT1RFOiBXZSBkbyBub3Qga25vdyBwYXJhbWV0ZXIgbmFtZXMsIHNvIHdlIGp1c3QgbnVtYmVyXG4gKiB0aGVtXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXJhbURlZihkZWYsIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgeyBwcmVmaXggPSAnJzsgfVxuICAgIHZhciBwYXJzZWREZWYgPSBbXTtcbiAgICB2YXIgbnVtVHVwbGVzID0gMDtcbiAgICBkZWYuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgICAgICAvLyBBcnJheXMgaW5kaWNhdGUgbmVzdGVkIHBhcmFtcyBpbnNpZGUgYSB0dXBsZSBhbmQgYWx3YXlzIGNvbWUgYWZ0ZXIgdGhlIGluaXRpYWwgdHVwbGUgdHlwZVxuICAgICAgICAgICAgLy8gaW5mby4gUmVjdXJzZSB0byBwYXJzZSBuZXN0ZWQgdHVwbGUgcGFyYW1zIGFuZCBhcHBlbmQgdGhlbSB0byB0aGUgbW9zdCByZWNlbnQuXG4gICAgICAgICAgICBwYXJzZWREZWZbcGFyc2VkRGVmLmxlbmd0aCAtIDFdLnB1c2gocGFyc2VQYXJhbURlZihwYXJhbSwgXCJcIi5jb25jYXQoaSwgXCItXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0dXBsZSBpbmZvLCBhZGQgdGhlIGZsYXQgcGFyYW0gaW5mbyB0byB0aGUgZGVmXG4gICAgICAgICAgICBwYXJzZWREZWYucHVzaChbXG4gICAgICAgICAgICAgICAgXCIjXCIuY29uY2F0KHByZWZpeCkuY29uY2F0KGkgKyAxIC0gbnVtVHVwbGVzKSxcbiAgICAgICAgICAgICAgICBwYXJhbS50eXBlSWR4LFxuICAgICAgICAgICAgICAgIHBhcmFtLnN6Qnl0ZXMsXG4gICAgICAgICAgICAgICAgcGFyYW0uYXJyYXlTenMsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUdXBsZVxuICAgICAgICBpZiAocGFyYW0udHlwZUlkeCA9PT0gRVZNX1RZUEVTLmluZGV4T2YoJ3R1cGxlJykpIHtcbiAgICAgICAgICAgIG51bVR1cGxlcyArPSAxO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlZERlZjtcbn1cbi8qKlxuICogQ29udmVydCBhIHBhcmFtIGludG8gYW4gRVZNUGFyYW1JbmZvIG9iamVjdCBiZWZvcmUgZmxhdHRlbmluZyBpdHMgZGF0YSBpbnRvIGFuIGFycmF5LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEZsYXRQYXJhbShpbnB1dCkge1xuICAgIGlmICghaW5wdXQudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHR5cGUgaW4gaW5wdXQnKTtcbiAgICB9XG4gICAgdmFyIHBhcmFtID0gW2lucHV0Lm5hbWVdO1xuICAgIHZhciBfYSA9IGdldFBhcmFtVHlwZUluZm8oaW5wdXQudHlwZSksIHR5cGVJZHggPSBfYS50eXBlSWR4LCBzekJ5dGVzID0gX2Euc3pCeXRlcywgYXJyYXlTenMgPSBfYS5hcnJheVN6cztcbiAgICBwYXJhbS5wdXNoKHR5cGVJZHgpO1xuICAgIHBhcmFtLnB1c2goc3pCeXRlcyk7XG4gICAgcGFyYW0ucHVzaChhcnJheVN6cyk7XG4gICAgcmV0dXJuIHBhcmFtO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgcGFyYW0gdHlwZSBzdHJpbmcgaW50byBhbiBFVk1QYXJhbUluZm8gb2JqZWN0IHdpdGggYXR0cmlidXRlczpcbiAqIDEuIHBhcmFtTmFtZSAtICAgICBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIuIFRoaXMgcGllY2Ugb2YgZGF0YSBpcyB1bnZlcmlmaWVkLCBzbyBpdCB3aWxsIGRpc3BsYXlcbiAqICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbnRseSBpZiB0aGUgdXNlciBoYXMgdGhlIGZ1bmN0aW9uIHNhdmVkIGluIHNlY3VyZSBzdG9yYWdlLlxuICogMi4gcGFyYW1UeXBlIC0gICAgIGJhc2ljIHR5cGUgb2YgcGFyYW0uIEZpcm13YXJlIGhhcyBhbiBlbnVtIHdpdGggNyB2YWx1ZXMuXG4gKiAzLiBwYXJhbVN6Qnl0ZXMgLSAgbnVtYmVyIG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIHBhcmFtLiBPbmx5IGNlcnRhaW4gdHlwZXMgY2FuIGhhdmUgbm9uemVyb1xuICogICAgICAgICAgICAgICAgICAgIHZhbHVlIGZvciB0aGlzLiBGb3IgZXhhbXBsZSwgYSBgdWludGAgd2l0aCBhIDQgaW4gdGhpcyBzbG90IHdvdWxkIGJlIHVpbnQzMlxuICogICAgICAgICAgICAgICAgICAgICg4KjQgPSAzMikuIE1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIGlzIGFsd2F5cyAzMiBiZWNhdXNlIHRoZXNlIHR5cGVzIGNhbiBvbmx5XG4gKiAgICAgICAgICAgICAgICAgICAgYmUgdXNlZCBpbiBzaW5nbGUgMzIgYnl0ZSB3b3Jkcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRQYXJhbVR5cGVJbmZvKHR5cGUpIHtcbiAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIHN6Qnl0ZXM6IDAsXG4gICAgICAgIHR5cGVJZHg6IDAsXG4gICAgICAgIGFycmF5U3pzOiBbXSxcbiAgICB9O1xuICAgIHZhciBiYXNlVHlwZTtcbiAgICBFVk1fVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICBpZiAodHlwZS5pbmRleE9mKHQpID4gLTEgJiYgIWJhc2VUeXBlKSB7XG4gICAgICAgICAgICBiYXNlVHlwZSA9IHQ7XG4gICAgICAgICAgICBwYXJhbS50eXBlSWR4ID0gaTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEdldCB0aGUgYXJyYXkgc2l6ZSwgaWYgYW55XG4gICAgcGFyYW0uYXJyYXlTenMgPSBnZXRBcnJheVN6cyh0eXBlKTtcbiAgICAvLyBEZXRlcm1pbmUgd2hlcmUgdG8gc2VhcmNoIGZvciBleHBhbmRlZCBzaXplXG4gICAgdmFyIHN6SWR4ID0gcGFyYW0uYXJyYXlTenMubGVuZ3RoID4gMCA/IHR5cGUuaW5kZXhPZignWycpIDogdHlwZS5sZW5ndGg7XG4gICAgaWYgKFsndWludCcsICdpbnQnLCAnYnl0ZXMnXS5pbmRleE9mKGJhc2VUeXBlKSA+IC0xKSB7XG4gICAgICAgIC8vIElmIHRoaXMgY2FuIGhhdmUgYSBmaXhlZCBzaXplLCBjYXB0dXJlIHRoYXRcbiAgICAgICAgdmFyIHN6Qml0cyA9IHBhcnNlSW50KHR5cGUuc2xpY2UoYmFzZVR5cGUubGVuZ3RoLCBzeklkeCkpIHx8IDA7XG4gICAgICAgIGlmIChzekJpdHMgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbSBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW0uc3pCeXRlcyA9IHN6Qml0cyAvIDg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyBmaXhlZCBzaXplIGluIHRoZSB0eXBlXG4gICAgICAgIHBhcmFtLnN6Qnl0ZXMgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG59XG4vKipcbiAqIERldGVybWluZSB0aGUgZGltZW5zaW9ucyBvZiBhbiBhcnJheSB0eXBlLiBUaGVzZSBkaW1lbnNpb25zIGNhbiBiZSBlaXRoZXIgZml4ZWQgb3IgdmFyaWFibGUgc2l6ZS5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc2l6ZXMuIEV4OiB1aW50MjU2W11bXSAtPiBbMCwgMF0sIHVpbnQyNTZbMV1bM10gLT4gWzEsIDNdLCB1aW50MjU2IC0+IFtdXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0QXJyYXlTenModHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gICAgdmFyIHN6cyA9IFtdO1xuICAgIHZhciB0MSA9IHR5cGU7XG4gICAgd2hpbGUgKHQxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG9wZW5JZHggPSB0MS5pbmRleE9mKCdbJyk7XG4gICAgICAgIGlmIChvcGVuSWR4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN6cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdDIgPSB0MS5zbGljZShvcGVuSWR4KTtcbiAgICAgICAgdmFyIGNsb3NlSWR4ID0gdDIuaW5kZXhPZignXScpO1xuICAgICAgICBpZiAoY2xvc2VJZHggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwYXJhbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQzID0gdDIuc2xpY2UoMSwgY2xvc2VJZHgpO1xuICAgICAgICBpZiAodDMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBWYXJpYWJsZSBzaXplXG4gICAgICAgICAgICBzenMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpeGVkIHNpemVcbiAgICAgICAgICAgIHN6cy5wdXNoKHBhcnNlSW50KHQzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdDEgPSB0Mi5zbGljZShjbG9zZUlkeCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gc3pzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZ2V0VHVwbGVOYW1lKG5hbWUsIHdpdGhBcnIpIHtcbiAgICBpZiAod2l0aEFyciA9PT0gdm9pZCAwKSB7IHdpdGhBcnIgPSB0cnVlOyB9XG4gICAgdmFyIGJyYWNrZXRzID0gMCwgYWRkZWRGaXJzdEJyYWNrZXQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5hbWVbaV0gPT09ICcoJykge1xuICAgICAgICAgICAgYnJhY2tldHMgKz0gMTtcbiAgICAgICAgICAgIGFkZGVkRmlyc3RCcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lW2ldID09PSAnKScpIHtcbiAgICAgICAgICAgIGJyYWNrZXRzIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbkJyZWFrID0gbmFtZVtpICsgMV0gPT09ICcsJyB8fCBuYW1lW2kgKyAxXSA9PT0gJyknIHx8IGkgPT09IG5hbWUubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKCF3aXRoQXJyICYmIG5hbWVbaSArIDFdID09PSAnWycpIHtcbiAgICAgICAgICAgIGNhbkJyZWFrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJyYWNrZXRzICYmIGFkZGVkRmlyc3RCcmFja2V0ICYmIGNhbkJyZWFrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKEJBRF9DQU5PTklDQUxfRVJSKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGlzVHVwbGUodHlwZSkge1xuICAgIHJldHVybiB0eXBlWzBdID09PSAnKCc7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBpc0J5dGVzVHlwZShwYXJhbSkge1xuICAgIHJldHVybiBFVk1fVFlQRVNbcGFyYW1bMV1dID09PSAnYnl0ZXMnO1xufVxuZnVuY3Rpb24gaXNCeXRlc0l0ZW0ocGFyYW0pIHtcbiAgICByZXR1cm4gaXNCeXRlc1R5cGUocGFyYW0pICYmIHBhcmFtWzNdLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXNBcnJJdGVtKHBhcmFtKSB7XG4gICAgcmV0dXJuIGlzQnl0ZXNUeXBlKHBhcmFtKSAmJiBwYXJhbVszXS5sZW5ndGggPT09IDEgJiYgcGFyYW1bM11bMF0gPT09IDA7XG59XG52YXIgQkFEX0NBTk9OSUNBTF9FUlIgPSAnQ291bGQgbm90IHBhcnNlIGNhbm9uaWNhbCBmdW5jdGlvbiBuYW1lLic7XG52YXIgRVZNX1RZUEVTID0gW1xuICAgIG51bGwsXG4gICAgJ2FkZHJlc3MnLFxuICAgICdib29sJyxcbiAgICAndWludCcsXG4gICAgJ2ludCcsXG4gICAgJ2J5dGVzJyxcbiAgICAnc3RyaW5nJyxcbiAgICAndHVwbGUnLFxuICAgICduZXN0ZWREZWYnLFxuXTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DQUxMREFUQSA9IHZvaWQgMDtcbi8qKlxuICogRXhwb3J0cyBjb250YWluaW5nIHV0aWxzIHRoYXQgYWxsb3cgaW5jbHVzaW9uIG9mIGNhbGxkYXRhIGRlY29kZXIgaW5mbyBpbiBzaWduaW5nIHJlcXVlc3RzLiBJZlxuICogY2FsbGRhdGEgZGVjb2RlciBpbmZvIGlzIHBhY2tlZCBpbnRvIHRoZSByZXF1ZXN0LCBpdCBpcyB1c2VkIHRvIGRlY29kZSB0aGUgY2FsbGRhdGEgaW4gdGhlXG4gKiByZXF1ZXN0LiBJdCBpcyBvcHRpb25hbC5cbiAqL1xudmFyIGV2bV8xID0gcmVxdWlyZShcIi4vZXZtXCIpO1xuZXhwb3J0cy5DQUxMREFUQSA9IHtcbiAgICBFVk06IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgcGFyc2Vyczoge1xuICAgICAgICAgICAgcGFyc2VTb2xpZGl0eUpTT05BQkk6IGV2bV8xLnBhcnNlU29saWRpdHlKU09OQUJJLFxuICAgICAgICAgICAgcGFyc2VDYW5vbmljYWxOYW1lOiBldm1fMS5wYXJzZUNhbm9uaWNhbE5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3NvcnM6IHtcbiAgICAgICAgICAgIGdldE5lc3RlZENhbGxkYXRhOiBldm1fMS5nZXROZXN0ZWRDYWxsZGF0YSxcbiAgICAgICAgICAgIHJlcGxhY2VOZXN0ZWREZWZzOiBldm1fMS5yZXBsYWNlTmVzdGVkRGVmcyxcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9pbmRleFwiKTtcbnZhciBmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3NoYXJlZC9mdW5jdGlvbnNcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvdXRpbGl0aWVzXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuL3NoYXJlZC92YWxpZGF0b3JzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKipcbiAqIGBDbGllbnRgIGlzIGEgY2xhc3MtYmFzZWQgaW50ZXJmYWNlIGZvciBtYW5hZ2luZyBhIExhdHRpY2UgZGV2aWNlLlxuICovXG52YXIgQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGFyZSBwYXNzZWQgYXMgYW4gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsaWVudChfYSkge1xuICAgICAgICB2YXIgYmFzZVVybCA9IF9hLmJhc2VVcmwsIG5hbWUgPSBfYS5uYW1lLCBwcml2S2V5ID0gX2EucHJpdktleSwgc3RhdGVEYXRhID0gX2Euc3RhdGVEYXRhLCB0aW1lb3V0ID0gX2EudGltZW91dCwgcmV0cnlDb3VudCA9IF9hLnJldHJ5Q291bnQsIHNraXBSZXRyeU9uV3JvbmdXYWxsZXQgPSBfYS5za2lwUmV0cnlPbldyb25nV2FsbGV0LCBkZXZpY2VJZCA9IF9hLmRldmljZUlkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdVbmtub3duJztcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybCB8fCBjb25zdGFudHNfMS5CQVNFX1VSTDtcbiAgICAgICAgdGhpcy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICB0aGlzLmlzUGFpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlV2FsbGV0cyA9IGNvbnN0YW50c18xLkRFRkFVTFRfQUNUSVZFX1dBTExFVFM7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQgfHwgNjAwMDA7XG4gICAgICAgIHRoaXMucmV0cnlDb3VudCA9IHJldHJ5Q291bnQgfHwgMztcbiAgICAgICAgdGhpcy5za2lwUmV0cnlPbldyb25nV2FsbGV0ID0gc2tpcFJldHJ5T25Xcm9uZ1dhbGxldCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5wcml2S2V5ID0gcHJpdktleSB8fCAoMCwgdXRpbF8xLnJhbmRvbUJ5dGVzKSgzMik7XG4gICAgICAgIHRoaXMua2V5ID0gKDAsIHV0aWxfMS5nZXRQMjU2S2V5UGFpcikodGhpcy5wcml2S2V5KTtcbiAgICAgICAgdGhpcy5yZXRyeVdyYXBwZXIgPSAoMCwgZnVuY3Rpb25zXzEuYnVpbGRSZXRyeVdyYXBwZXIpKHRoaXMsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgICAgIC8qKiBUaGUgdXNlciBtYXkgcGFzcyBpbiBzdGF0ZSBkYXRhIHRvIHJlaHlkcmF0ZSBhIHNlc3Npb24gdGhhdCB3YXMgcHJldmlvdXNseSBjYWNoZWQgKi9cbiAgICAgICAgaWYgKHN0YXRlRGF0YSkge1xuICAgICAgICAgICAgdGhpcy51bnBhY2tBbmRBcHBseVN0YXRlRGF0YShzdGF0ZURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGllbnQucHJvdG90eXBlLCBcInB1YmxpY0tleVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGllbnQncyBzdGF0aWMga2V5cGFpci5cbiAgICAgICAgICogVGhlIHB1YmxpYyBrZXkgaXMgdXNlZCBmb3IgaWRlbnRpZnlpbmcgdGhlIGNsaWVudCB0byB0aGUgTGF0dGljZS5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm5zIEJ1ZmZlclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxpdGllc18xLmdldFB1YktleUJ5dGVzKSh0aGlzLmtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhaXJpbmcgbmFtZSBmb3IgdGhpcyBjbGllbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLmdldEFwcE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGBkZXZpY2VJZGAgZm9yIHRoaXMgY2xpZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXREZXZpY2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlSWQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xpZW50LnByb3RvdHlwZSwgXCJzaGFyZWRTZWNyZXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzaGFyZWQgc2VjcmV0LCBkZXJpdmVkIHZpYSBFQ0RIIGZyb20gdGhlIGxvY2FsIHByaXZhdGUga2V5IGFuZCB0aGUgZXBoZW1lcmFsIHB1YmxpYyBrZXlcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm5zIEJ1ZmZlclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmNlIGV2ZXJ5IH4yNTYgYXR0ZW1wdHMsIHdlIHdpbGwgZ2V0IGEga2V5IHRoYXQgc3RhcnRzIHdpdGggYSBgMDBgIGJ5dGUsIHdoaWNoIGNhbiBsZWFkIHRvXG4gICAgICAgICAgICAvLyBwcm9ibGVtcyBpbml0aWFsaXppbmcgQUVTIGlmIHdlIGRvbid0IGZvcmNlIGEgMzIgYnl0ZSBCRSBidWZmZXIuXG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5rZXkuZGVyaXZlKHRoaXMuZXBoZW1lcmFsUHViLmdldFB1YmxpYygpKS50b0FycmF5KCdiZScsIDMyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xpZW50LnByb3RvdHlwZSwgXCJlcGhlbWVyYWxQdWJcIiwge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VwaGVtZXJhbFB1YjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlcGhlbWVyYWxQdWIpIHtcbiAgICAgICAgICAgICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVFcGhlbWVyYWxQdWIpKGVwaGVtZXJhbFB1Yik7XG4gICAgICAgICAgICB0aGlzLl9lcGhlbWVyYWxQdWIgPSBlcGhlbWVyYWxQdWI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGNvbnRhY3QgYSBkZXZpY2UgYmFzZWQgb24gaXRzIGBkZXZpY2VJZGAuIFRoZSByZXNwb25zZSBzaG91bGQgaW5jbHVkZSBhbiBlcGhlbWVyYWxcbiAgICAgKiBwdWJsaWMga2V5LCB3aGljaCBpcyB1c2VkIHRvIHBhaXIgd2l0aCB0aGUgZGV2aWNlIGluIGEgbGF0ZXIgcmVxdWVzdC5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChkZXZpY2VJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucmV0cnlXcmFwcGVyKGluZGV4XzEuY29ubmVjdCwgeyBpZDogZGV2aWNlSWQgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgYSBwYWlyaW5nIHNlY3JldCBpcyBwcm92aWRlZCwgYHBhaXJgIHVzZXMgaXQgdG8gc2lnbiBhIGhhc2ggb2YgdGhlIHB1YmxpYyBrZXksIG5hbWUsIGFuZFxuICAgICAqIHBhaXJpbmcgc2VjcmV0LiBJdCB0aGVuIHNlbmRzIHRoZSBuYW1lIGFuZCBzaWduYXR1cmUgdG8gdGhlIGRldmljZS4gSWYgbm8gcGFpcmluZyBzZWNyZXQgaXNcbiAgICAgKiBwcm92aWRlZCwgYHBhaXJgIHNlbmRzIGEgemVyby1sZW5ndGggbmFtZSBidWZmZXIgdG8gdGhlIGRldmljZS5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUucGFpciA9IGZ1bmN0aW9uIChwYWlyaW5nU2VjcmV0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXRyeVdyYXBwZXIoaW5kZXhfMS5wYWlyLCB7IHBhaXJpbmdTZWNyZXQ6IHBhaXJpbmdTZWNyZXQgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBzdGFydGluZyBwYXRoIGFuZCBhIG51bWJlciB0byBnZXQgdGhlIGFkZHJlc3NlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFjdGl2ZSB3YWxsZXQuXG4gICAgICogQGNhdGVnb3J5IExhdHRpY2VcbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLmdldEFkZHJlc3NlcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3RhcnRQYXRoID0gX2Euc3RhcnRQYXRoLCBfYiA9IF9hLm4sIG4gPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iLCBfYyA9IF9hLmZsYWcsIGZsYWcgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucmV0cnlXcmFwcGVyKGluZGV4XzEuZ2V0QWRkcmVzc2VzLCB7IHN0YXJ0UGF0aDogc3RhcnRQYXRoLCBuOiBuLCBmbGFnOiBmbGFnIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbmQgc2VuZHMgYSByZXF1ZXN0IGZvciBzaWduaW5nIHRvIHRoZSBMYXR0aWNlLlxuICAgICAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkYXRhID0gX2EuZGF0YSwgY3VycmVuY3kgPSBfYS5jdXJyZW5jeSwgY2FjaGVkRGF0YSA9IF9hLmNhY2hlZERhdGEsIG5leHRDb2RlID0gX2EubmV4dENvZGU7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXRyeVdyYXBwZXIoaW5kZXhfMS5zaWduLCB7IGRhdGE6IGRhdGEsIGN1cnJlbmN5OiBjdXJyZW5jeSwgY2FjaGVkRGF0YTogY2FjaGVkRGF0YSwgbmV4dENvZGU6IG5leHRDb2RlIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBhY3RpdmUgd2FsbGV0IGluIHRoZSBMYXR0aWNlLlxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuZmV0Y2hBY3RpdmVXYWxsZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXRyeVdyYXBwZXIoaW5kZXhfMS5mZXRjaEFjdGl2ZVdhbGxldCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgaW4gYSBzZXQgb2Yga2V5LXZhbHVlIHJlY29yZHMgYW5kIHNlbmRzIGEgcmVxdWVzdCB0byBhZGQgdGhlbSB0byB0aGUgTGF0dGljZS5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuYWRkS3ZSZWNvcmRzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLnR5cGUsIHR5cGUgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCByZWNvcmRzID0gX2EucmVjb3JkcywgX2MgPSBfYS5jYXNlU2Vuc2l0aXZlLCBjYXNlU2Vuc2l0aXZlID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXRyeVdyYXBwZXIoaW5kZXhfMS5hZGRLdlJlY29yZHMsIHsgdHlwZTogdHlwZSwgcmVjb3JkczogcmVjb3JkcywgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSwgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGxpc3Qgb2Yga2V5LXZhbHVlIHJlY29yZHMgZnJvbSB0aGUgTGF0dGljZS5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0S3ZSZWNvcmRzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLnR5cGUsIHR5cGUgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IF9hLm4sIG4gPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jLCBfZCA9IF9hLnN0YXJ0LCBzdGFydCA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZXRyeVdyYXBwZXIoaW5kZXhfMS5nZXRLdlJlY29yZHMsIHsgdHlwZTogdHlwZSwgbjogbiwgc3RhcnQ6IHN0YXJ0LCB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBpbiBhbiBhcnJheSBvZiBpZHMgYW5kIHNlbmRzIGEgcmVxdWVzdCB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBMYXR0aWNlLlxuICAgICAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5yZW1vdmVLdlJlY29yZHMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EudHlwZSwgdHlwZSA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIF9jID0gX2EuaWRzLCBpZHMgPSBfYyA9PT0gdm9pZCAwID8gW10gOiBfYztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnJldHJ5V3JhcHBlcihpbmRleF8xLnJlbW92ZUt2UmVjb3JkcywgeyB0eXBlOiB0eXBlLCBpZHM6IGlkcywgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSByZWNvcmQgb2YgZW5jcnlwdGVkIGRhdGEgZnJvbSB0aGUgTGF0dGljZS5cbiAgICAgKiBNdXN0IHNwZWNpZnkgYSBkYXRhIHR5cGUuIFJldHVybnMgYSBCdWZmZXIgY29udGFpbmluZ1xuICAgICAqIGRhdGEgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAgICogQGNhdGVnb3J5IExhdHRpY2VcbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLmZldGNoRW5jcnlwdGVkRGF0YSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnJldHJ5V3JhcHBlcihpbmRleF8xLmZldGNoRW5jRGF0YSwgcGFyYW1zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogR2V0IHRoZSBhY3RpdmUgd2FsbGV0ICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRBY3RpdmVXYWxsZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwudWlkICYmXG4gICAgICAgICAgICAhY29uc3RhbnRzXzEuRU1QVFlfV0FMTEVUX1VJRC5lcXVhbHModGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLnVpZCAmJlxuICAgICAgICAgICAgIWNvbnN0YW50c18xLkVNUFRZX1dBTExFVF9VSUQuZXF1YWxzKHRoaXMuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC51aWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENoZWNrIGlmIHRoZSB1c2VyIGhhcyBhbiBhY3RpdmUgd2FsbGV0ICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5oYXNBY3RpdmVXYWxsZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0QWN0aXZlV2FsbGV0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgYWN0aXZlIHdhbGxldHMgdG8gZW1wdHkgdmFsdWVzLlxuICAgICAqIEBjYXRlZ29yeSBEZXZpY2UgUmVzcG9uc2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLnJlc2V0QWN0aXZlV2FsbGV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzID0gY29uc3RhbnRzXzEuREVGQVVMVF9BQ1RJVkVfV0FMTEVUUztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGUgZGF0YSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIHNlc3Npb24uIFBhc3MgdGhlXG4gICAgICogY29udGVudHMgb2YgdGhpcyB0byB0aGUgY29uc3RydWN0b3IgYXMgYHN0YXRlRGF0YWAgdG8gcmVoeWRyYXRlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0U3RhdGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWNrU3RhdGVEYXRhKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJtd2FyZSB2ZXJzaW9uIGNvbnN0YW50cyBmb3IgdGhlIGdpdmVuIGZpcm13YXJlIHZlcnNpb24uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRGd0NvbnN0YW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKDAsIGNvbnN0YW50c18xLmdldEZ3VmVyc2lvbkNvbnN0KSgoX2EgPSB0aGlzLmZ3VmVyc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogQnVmZmVyLmFsbG9jKDApKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBnZXRGd1ZlcnNpb25gIGdldHMgdGhlIGZpcm13YXJlIHZlcnNpb24gb2YgdGhlIHBhaXJlZCBkZXZpY2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRGd1ZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZ3VmVyc2lvbiAmJiB0aGlzLmZ3VmVyc2lvbi5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaXg6IHRoaXMuZndWZXJzaW9uWzBdLFxuICAgICAgICAgICAgICAgIG1pbm9yOiB0aGlzLmZ3VmVyc2lvblsxXSxcbiAgICAgICAgICAgICAgICBtYWpvcjogdGhpcy5md1ZlcnNpb25bMl0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpeDogMCwgbWlub3I6IDAsIG1ham9yOiAwIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBtdXRhdGlvbiBvZiBDbGllbnQgc3RhdGUgaW4gdGhlIHByaW1hcnkgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkZXZpY2VJZCA9IF9hLmRldmljZUlkLCBlcGhlbWVyYWxQdWIgPSBfYS5lcGhlbWVyYWxQdWIsIHVybCA9IF9hLnVybCwgaXNQYWlyZWQgPSBfYS5pc1BhaXJlZCwgZndWZXJzaW9uID0gX2EuZndWZXJzaW9uLCBhY3RpdmVXYWxsZXRzID0gX2EuYWN0aXZlV2FsbGV0cztcbiAgICAgICAgaWYgKGRldmljZUlkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgIGlmIChlcGhlbWVyYWxQdWIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuZXBoZW1lcmFsUHViID0gZXBoZW1lcmFsUHViO1xuICAgICAgICBpZiAodXJsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgaWYgKGlzUGFpcmVkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmlzUGFpcmVkID0gaXNQYWlyZWQ7XG4gICAgICAgIGlmIChmd1ZlcnNpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuZndWZXJzaW9uID0gZndWZXJzaW9uO1xuICAgICAgICBpZiAoYWN0aXZlV2FsbGV0cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzID0gYWN0aXZlV2FsbGV0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBKU09OLXN0cmluZ2lmaWVkIHZlcnNpb24gb2Ygc3RhdGUgZGF0YS4gQ2FuIGJlIHVzZWQgdG8gcmVoeWRyYXRlIGFuIFNESyBzZXNzaW9uIHdpdGhvdXRcbiAgICAgKiByZWNvbm5lY3RpbmcgdG8gdGhlIHRhcmdldCBMYXR0aWNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUucGFja1N0YXRlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlV2FsbGV0czoge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiAoX2EgPSB0aGlzLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwudWlkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogKF9iID0gdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLm5hbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB0aGlzLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiAoX2MgPSB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwudWlkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogKF9kID0gdGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLm5hbWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiAoX2YgPSAoX2UgPSB0aGlzLmVwaGVtZXJhbFB1YikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmdldFB1YmxpYygpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZW5jb2RlKCdoZXgnKSxcbiAgICAgICAgICAgICAgICBmd1ZlcnNpb246IChfZyA9IHRoaXMuZndWZXJzaW9uKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBiYXNlVXJsOiB0aGlzLmJhc2VVcmwsXG4gICAgICAgICAgICAgICAgcHJpdktleTogdGhpcy5wcml2S2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICByZXRyeUNvdW50OiB0aGlzLnJldHJ5Q291bnQsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBwYWNrIHN0YXRlIGRhdGEuJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5wYWNrIGEgSlNPTi1zdHJpbmdpZmllZCB2ZXJzaW9uIG9mIHN0YXRlIGRhdGEgYW5kIGFwcGx5IGl0IHRvIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdXMgdG9cbiAgICAgKiByZWh5ZHJhdGUgYW4gb2xkIHNlc3Npb24uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS51bnBhY2tBbmRBcHBseVN0YXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdW5wYWNrZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgZGF0YVxuICAgICAgICAgICAgdmFyIGludGVybmFsV2FsbGV0ID0ge1xuICAgICAgICAgICAgICAgIHVpZDogQnVmZmVyLmZyb20odW5wYWNrZWQuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC51aWQsICdoZXgnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB1bnBhY2tlZC5hY3RpdmVXYWxsZXRzLmludGVybmFsLm5hbWUgP1xuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbSh1bnBhY2tlZC5hY3RpdmVXYWxsZXRzLmludGVybmFsLm5hbWUpIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHVucGFja2VkLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxXYWxsZXQgPSB7XG4gICAgICAgICAgICAgICAgdWlkOiBCdWZmZXIuZnJvbSh1bnBhY2tlZC5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZCwgJ2hleCcpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHVucGFja2VkLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwubmFtZSA/XG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHVucGFja2VkLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwubmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczogdW5wYWNrZWQuYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5jYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGVwaGVtZXJhbFB1YkJ5dGVzID0gQnVmZmVyLmZyb20odW5wYWNrZWQuZXBoZW1lcmFsUHViLCAnaGV4Jyk7XG4gICAgICAgICAgICB2YXIgZndWZXJzaW9uQnl0ZXMgPSBCdWZmZXIuZnJvbSh1bnBhY2tlZC5md1ZlcnNpb24sICdoZXgnKTtcbiAgICAgICAgICAgIHZhciBwcml2S2V5Qnl0ZXMgPSBCdWZmZXIuZnJvbSh1bnBhY2tlZC5wcml2S2V5LCAnaGV4Jyk7XG4gICAgICAgICAgICAvLyBBcHBseSB1bnBhY2tlZCBwYXJhbXNcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbCA9IGludGVybmFsV2FsbGV0O1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsID0gZXh0ZXJuYWxXYWxsZXQ7XG4gICAgICAgICAgICB0aGlzLmVwaGVtZXJhbFB1YiA9ICgwLCB1dGlsXzEuZ2V0UDI1NktleVBhaXJGcm9tUHViKShlcGhlbWVyYWxQdWJCeXRlcyk7XG4gICAgICAgICAgICB0aGlzLmZ3VmVyc2lvbiA9IGZ3VmVyc2lvbkJ5dGVzO1xuICAgICAgICAgICAgdGhpcy5kZXZpY2VJZCA9IHVucGFja2VkLmRldmljZUlkO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdW5wYWNrZWQubmFtZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZVVybCA9IHVucGFja2VkLmJhc2VVcmw7XG4gICAgICAgICAgICB0aGlzLnVybCA9IFwiXCIuY29uY2F0KHRoaXMuYmFzZVVybCwgXCIvXCIpLmNvbmNhdCh0aGlzLmRldmljZUlkKTtcbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9IHByaXZLZXlCeXRlcztcbiAgICAgICAgICAgIHRoaXMua2V5ID0gKDAsIHV0aWxfMS5nZXRQMjU2S2V5UGFpcikodGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlDb3VudCA9IHVucGFja2VkLnJldHJ5Q291bnQ7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSB1bnBhY2tlZC50aW1lb3V0O1xuICAgICAgICAgICAgdGhpcy5yZXRyeVdyYXBwZXIgPSAoMCwgZnVuY3Rpb25zXzEuYnVpbGRSZXRyeVdyYXBwZXIpKHRoaXMsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgYXBwbHkgc3RhdGUgZGF0YS4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUFVCTElDID0gZXhwb3J0cy5FVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgPSBleHBvcnRzLk1BWF9DSEFJTl9JRF9CWVRFUyA9IGV4cG9ydHMuSEFORExFX0xBUkdFUl9DSEFJTl9JRCA9IGV4cG9ydHMuSEFSREVORURfT0ZGU0VUID0gZXhwb3J0cy5WRVJTSU9OX0JZVEUgPSBleHBvcnRzLlJFUVVFU1RfVFlQRV9CWVRFID0gZXhwb3J0cy5zaWduaW5nU2NoZW1hID0gZXhwb3J0cy5ldGhNc2dQcm90b2NvbCA9IGV4cG9ydHMuYWRkcmVzc1NpemVzID0gZXhwb3J0cy5FWFRFUk5BTF9ORVRXT1JLU19CWV9DSEFJTl9JRF9VUkwgPSBleHBvcnRzLk5FVFdPUktTX0JZX0NIQUlOX0lEID0gZXhwb3J0cy5NQVhfQUREUiA9IGV4cG9ydHMuQ1VSUkVOQ0lFUyA9IGV4cG9ydHMuQkFTRV9VUkwgPSBleHBvcnRzLkJJUF9DT05TVEFOVFMgPSBleHBvcnRzLmdldEZ3VmVyc2lvbkNvbnN0ID0gZXhwb3J0cy5BU0NJSV9SRUdFWCA9IGV4cG9ydHMuTEVER0VSX0xFR0FDWV9ERVJJVkFUSU9OID0gZXhwb3J0cy5MRURHRVJfTElWRV9ERVJJVkFUSU9OID0gZXhwb3J0cy5TT0xBTkFfREVSSVZBVElPTiA9IGV4cG9ydHMuQlRDX1dSQVBQRURfU0VHV0lUX0RFUklWQVRJT04gPSBleHBvcnRzLkJUQ19TRUdXSVRfREVSSVZBVElPTiA9IGV4cG9ydHMuQlRDX0xFR0FDWV9ERVJJVkFUSU9OID0gZXhwb3J0cy5ERUZBVUxUX0VUSF9ERVJJVkFUSU9OID0gZXhwb3J0cy5ERUZBVUxUX0FDVElWRV9XQUxMRVRTID0gZXhwb3J0cy5FTVBUWV9XQUxMRVRfVUlEID0gZXhwb3J0cy5FWFRFUk5BTCA9IHZvaWQgMDtcbnZhciBsYXR0aWNlQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbC9sYXR0aWNlQ29uc3RhbnRzXCIpO1xuLyoqXG4gKiBFeHRlcm5hbGx5IGV4cG9ydGVkIGNvbnN0YW50cyB1c2VkIGZvciBidWlsZGluZyByZXF1ZXN0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnRzLkVYVEVSTkFMID0ge1xuICAgIC8vIE9wdGlvbmFsIGZsYWdzIGZvciBgZ2V0QWRkcmVzc2VzYFxuICAgIEdFVF9BRERSX0ZMQUdTOiB7XG4gICAgICAgIFNFQ1AyNTZLMV9QVUI6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlR2V0QWRkcmVzc2VzRmxhZy5zZWNwMjU2azFQdWJrZXksXG4gICAgICAgIEVEMjU1MTlfUFVCOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuZWQyNTUxOVB1YmtleSxcbiAgICAgICAgQkxTMTJfMzgxX0cxX1BVQjogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLmJsczEyXzM4MVB1YmtleSxcbiAgICB9LFxuICAgIC8vIE9wdGlvbnMgZm9yIGJ1aWxkaW5nIGdlbmVyYWwgc2lnbmluZyByZXF1ZXN0c1xuICAgIFNJR05JTkc6IHtcbiAgICAgICAgSEFTSEVTOiB7XG4gICAgICAgICAgICBOT05FOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25IYXNoLm5vbmUsXG4gICAgICAgICAgICBLRUNDQUsyNTY6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2lnbkhhc2gua2VjY2FrMjU2LFxuICAgICAgICAgICAgU0hBMjU2OiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25IYXNoLnNoYTI1NixcbiAgICAgICAgfSxcbiAgICAgICAgQ1VSVkVTOiB7XG4gICAgICAgICAgICBTRUNQMjU2SzE6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2lnbkN1cnZlLnNlY3AyNTZrMSxcbiAgICAgICAgICAgIEVEMjU1MTk6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2lnbkN1cnZlLmVkMjU1MTksXG4gICAgICAgICAgICBCTFMxMl8zODFfRzI6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2lnbkN1cnZlLmJsczEyXzM4MSxcbiAgICAgICAgfSxcbiAgICAgICAgRU5DT0RJTkdTOiB7XG4gICAgICAgICAgICBOT05FOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25FbmNvZGluZy5ub25lLFxuICAgICAgICAgICAgU09MQU5BOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25FbmNvZGluZy5zb2xhbmEsXG4gICAgICAgICAgICBFVk06IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2lnbkVuY29kaW5nLmV2bSxcbiAgICAgICAgICAgIEVUSF9ERVBPU0lUOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25FbmNvZGluZy5ldGhfZGVwb3NpdCxcbiAgICAgICAgfSxcbiAgICAgICAgQkxTX0RTVDoge1xuICAgICAgICAgICAgQkxTX0RTVF9OVUw6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2lnbkJsc0RzdC5OVUwsXG4gICAgICAgICAgICBCTFNfRFNUX1BPUDogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTaWduQmxzRHN0LlBPUCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIE9wdGlvbnMgZm9yIGV4cG9ydGluZyBlbmNyeXB0ZWQgZGF0YVxuICAgIEVOQ19EQVRBOiB7XG4gICAgICAgIFNDSEVNQVM6IHtcbiAgICAgICAgICAgIEJMU19LRVlTVE9SRV9FSVAyMzM1X1BCS0RGX1Y0OiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZUVuY0RhdGFTY2hlbWEuZWlwMjMzNSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEVUSF9DT05TRU5TVVNfU1BFQzoge1xuICAgICAgICBORVRXT1JLUzoge1xuICAgICAgICAgICAgTUFJTk5FVF9HRU5FU0lTOiB7XG4gICAgICAgICAgICAgICAgbmV0d29ya05hbWU6ICdtYWlubmV0JyxcbiAgICAgICAgICAgICAgICBmb3JrVmVyc2lvbjogQnVmZmVyLmFsbG9jKDQpLFxuICAgICAgICAgICAgICAgIC8vIEVtcHR5IHJvb3QgYmVjYXVzZSB0aGVyZSB3ZXJlIG5vIHZhbGlkYXRvcnMgYXQgZ2VuZXNpc1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnNSb290OiBCdWZmZXIuYWxsb2MoMzIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRE9NQUlOUzoge1xuICAgICAgICAgICAgREVQT1NJVDogQnVmZmVyLmZyb20oJzAzMDAwMDAwJywgJ2hleCcpLFxuICAgICAgICAgICAgVk9MVU5UQVJZX0VYSVQ6IEJ1ZmZlci5mcm9tKCcwNDAwMDAwMCcsICdoZXgnKSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmV4cG9ydHMuUFVCTElDID0gZXhwb3J0cy5FWFRFUk5BTDtcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSU5URVJOQUwgQ09OU1RBTlRTXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBhZGRyZXNzU2l6ZXMgPSB7XG4gICAgQlRDOiAyMCxcbiAgICBFVEg6IDIwLCAvLyAyMCBieXRlIGFkZHJlc3Mgbm90IGluY2x1ZGluZyAweCBwcmVmaXhcbn07XG5leHBvcnRzLmFkZHJlc3NTaXplcyA9IGFkZHJlc3NTaXplcztcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBDVVJSRU5DSUVTID0ge1xuICAgIEVUSDogJ0VUSCcsXG4gICAgQlRDOiAnQlRDJyxcbiAgICBFVEhfTVNHOiAnRVRIX01TRycsXG59O1xuZXhwb3J0cy5DVVJSRU5DSUVTID0gQ1VSUkVOQ0lFUztcbi8qKiBAaW50ZXJuYWwgKi9cbi8vIFRISVMgTkVFRFMgVE8gQkUgQSBQUk9UT0NPTCBDT05TVEFOVCBUT09cbnZhciBzaWduaW5nU2NoZW1hID0ge1xuICAgIEJUQ19UUkFOU0ZFUjogMCxcbiAgICBFVEhfVFJBTlNGRVI6IDEsXG4gICAgRVJDMjBfVFJBTlNGRVI6IDIsXG4gICAgRVRIX01TRzogMyxcbiAgICBFWFRSQV9EQVRBOiA0LFxuICAgIEdFTkVSQUxfU0lHTklORzogNSxcbn07XG5leHBvcnRzLnNpZ25pbmdTY2hlbWEgPSBzaWduaW5nU2NoZW1hO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEhBUkRFTkVEX09GRlNFVCA9IDB4ODAwMDAwMDA7IC8vIEhhcmRlbmVkIG9mZnNldFxuZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQgPSBIQVJERU5FRF9PRkZTRVQ7XG4vKiogQGludGVybmFsICovXG52YXIgQklQX0NPTlNUQU5UUyA9IHtcbiAgICBQVVJQT1NFUzoge1xuICAgICAgICBFVEg6IEhBUkRFTkVEX09GRlNFVCArIDQ0LFxuICAgICAgICBCVENfTEVHQUNZOiBIQVJERU5FRF9PRkZTRVQgKyA0NCxcbiAgICAgICAgQlRDX1dSQVBQRURfU0VHV0lUOiBIQVJERU5FRF9PRkZTRVQgKyA0OSxcbiAgICAgICAgQlRDX1NFR1dJVDogSEFSREVORURfT0ZGU0VUICsgODQsXG4gICAgfSxcbiAgICBDT0lOUzoge1xuICAgICAgICBFVEg6IEhBUkRFTkVEX09GRlNFVCArIDYwLFxuICAgICAgICBCVEM6IEhBUkRFTkVEX09GRlNFVCxcbiAgICAgICAgQlRDX1RFU1RORVQ6IEhBUkRFTkVEX09GRlNFVCArIDEsXG4gICAgfSxcbn07XG5leHBvcnRzLkJJUF9DT05TVEFOVFMgPSBCSVBfQ09OU1RBTlRTO1xuLyoqIEBpbnRlcm5hbCBGb3IgYWxsIEhTTS1ib3VuZCByZXF1ZXN0cyAqL1xudmFyIFJFUVVFU1RfVFlQRV9CWVRFID0gMHgwMjtcbmV4cG9ydHMuUkVRVUVTVF9UWVBFX0JZVEUgPSBSRVFVRVNUX1RZUEVfQllURTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBWRVJTSU9OX0JZVEUgPSAxO1xuZXhwb3J0cy5WRVJTSU9OX0JZVEUgPSBWRVJTSU9OX0JZVEU7XG4vKiogQGludGVybmFsIENoYWluSWQgdmFsdWUgdG8gc2lnbmlmeSBsYXJnZXIgY2hhaW5JRCBpcyBpbiBkYXRhIGJ1ZmZlciAqL1xudmFyIEhBTkRMRV9MQVJHRVJfQ0hBSU5fSUQgPSAyNTU7XG5leHBvcnRzLkhBTkRMRV9MQVJHRVJfQ0hBSU5fSUQgPSBIQU5ETEVfTEFSR0VSX0NIQUlOX0lEO1xuLyoqIEBpbnRlcm5hbCBNYXggbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnRhaW4gbGFyZ2VyIGNoYWluSUQgaW4gZGF0YSBidWZmZXIgKi9cbnZhciBNQVhfQ0hBSU5fSURfQllURVMgPSA4O1xuZXhwb3J0cy5NQVhfQ0hBSU5fSURfQllURVMgPSBNQVhfQ0hBSU5fSURfQllURVM7XG4vKiogQGludGVybmFsICovXG52YXIgQkFTRV9VUkwgPSAnaHR0cHM6Ly9zaWduaW5nLmdyaWRwbC51cyc7XG5leHBvcnRzLkJBU0VfVVJMID0gQkFTRV9VUkw7XG4vKiogQGludGVybmFsICovXG52YXIgRUlQNzEyX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQID0ge1xuICAgIGFkZHJlc3M6IDEsXG4gICAgYm9vbDogMixcbiAgICB1aW50ODogMyxcbiAgICB1aW50MTY6IDQsXG4gICAgdWludDI0OiA1LFxuICAgIHVpbnQzMjogNixcbiAgICB1aW50NDA6IDcsXG4gICAgdWludDQ4OiA4LFxuICAgIHVpbnQ1NjogOSxcbiAgICB1aW50NjQ6IDEwLFxuICAgIHVpbnQ3MjogMTEsXG4gICAgdWludDgwOiAxMixcbiAgICB1aW50ODg6IDEzLFxuICAgIHVpbnQ5NjogMTQsXG4gICAgdWludDEwNDogMTUsXG4gICAgdWludDExMjogMTYsXG4gICAgdWludDEyMDogMTcsXG4gICAgdWludDEyODogMTgsXG4gICAgdWludDEzNjogMTksXG4gICAgdWludDE0NDogMjAsXG4gICAgdWludDE1MjogMjEsXG4gICAgdWludDE2MDogMjIsXG4gICAgdWludDE2ODogMjMsXG4gICAgdWludDE3NjogMjQsXG4gICAgdWludDE4NDogMjUsXG4gICAgdWludDE5MjogMjYsXG4gICAgdWludDIwMDogMjcsXG4gICAgdWludDIwODogMjgsXG4gICAgdWludDIxNjogMjksXG4gICAgdWludDIyNDogMzAsXG4gICAgdWludDIzMjogMzEsXG4gICAgdWludDI0MDogMzIsXG4gICAgdWludDI0ODogMzMsXG4gICAgdWludDI1NjogMzQsXG4gICAgaW50ODogMzUsXG4gICAgaW50MTY6IDM2LFxuICAgIGludDI0OiAzNyxcbiAgICBpbnQzMjogMzgsXG4gICAgaW50NDA6IDM5LFxuICAgIGludDQ4OiA0MCxcbiAgICBpbnQ1NjogNDEsXG4gICAgaW50NjQ6IDQyLFxuICAgIGludDcyOiA0MyxcbiAgICBpbnQ4MDogNDQsXG4gICAgaW50ODg6IDQ1LFxuICAgIGludDk2OiA0NixcbiAgICBpbnQxMDQ6IDQ3LFxuICAgIGludDExMjogNDgsXG4gICAgaW50MTIwOiA0OSxcbiAgICBpbnQxMjg6IDUwLFxuICAgIGludDEzNjogNTEsXG4gICAgaW50MTQ0OiA1MixcbiAgICBpbnQxNTI6IDUzLFxuICAgIGludDE2MDogNTQsXG4gICAgaW50MTY4OiA1NSxcbiAgICBpbnQxNzY6IDU2LFxuICAgIGludDE4NDogNTcsXG4gICAgaW50MTkyOiA1OCxcbiAgICBpbnQyMDA6IDU5LFxuICAgIGludDIwODogNjAsXG4gICAgaW50MjE2OiA2MSxcbiAgICBpbnQyMjQ6IDYyLFxuICAgIGludDIzMjogNjMsXG4gICAgaW50MjQwOiA2NCxcbiAgICBpbnQyNDg6IDY1LFxuICAgIGludDI1NjogNjYsXG4gICAgdWludDogNjcsXG4gICAgYnl0ZXMxOiA2OSxcbiAgICBieXRlczI6IDcwLFxuICAgIGJ5dGVzMzogNzEsXG4gICAgYnl0ZXM0OiA3MixcbiAgICBieXRlczU6IDczLFxuICAgIGJ5dGVzNjogNzQsXG4gICAgYnl0ZXM3OiA3NSxcbiAgICBieXRlczg6IDc2LFxuICAgIGJ5dGVzOTogNzcsXG4gICAgYnl0ZXMxMDogNzgsXG4gICAgYnl0ZXMxMTogNzksXG4gICAgYnl0ZXMxMjogODAsXG4gICAgYnl0ZXMxMzogODEsXG4gICAgYnl0ZXMxNDogODIsXG4gICAgYnl0ZXMxNTogODMsXG4gICAgYnl0ZXMxNjogODQsXG4gICAgYnl0ZXMxNzogODUsXG4gICAgYnl0ZXMxODogODYsXG4gICAgYnl0ZXMxOTogODcsXG4gICAgYnl0ZXMyMDogODgsXG4gICAgYnl0ZXMyMTogODksXG4gICAgYnl0ZXMyMjogOTAsXG4gICAgYnl0ZXMyMzogOTEsXG4gICAgYnl0ZXMyNDogOTIsXG4gICAgYnl0ZXMyNTogOTMsXG4gICAgYnl0ZXMyNjogOTQsXG4gICAgYnl0ZXMyNzogOTUsXG4gICAgYnl0ZXMyODogOTYsXG4gICAgYnl0ZXMyOTogOTcsXG4gICAgYnl0ZXMzMDogOTgsXG4gICAgYnl0ZXMzMTogOTksXG4gICAgYnl0ZXMzMjogMTAwLFxuICAgIGJ5dGVzOiAxMDEsXG4gICAgc3RyaW5nOiAxMDIsXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEVUSF9BQklfTEFUVElDRV9GV19UWVBFX01BUCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBFSVA3MTJfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVApLCB7IHR1cGxlMTogMTAzLCB0dXBsZTI6IDEwNCwgdHVwbGUzOiAxMDUsIHR1cGxlNDogMTA2LCB0dXBsZTU6IDEwNywgdHVwbGU2OiAxMDgsIHR1cGxlNzogMTA5LCB0dXBsZTg6IDExMCwgdHVwbGU5OiAxMTEsIHR1cGxlMTA6IDExMiwgdHVwbGUxMTogMTEzLCB0dXBsZTEyOiAxMTQsIHR1cGxlMTM6IDExNSwgdHVwbGUxNDogMTE2LCB0dXBsZTE1OiAxMTcsIHR1cGxlMTY6IDExOCwgdHVwbGUxNzogMTE5IH0pO1xuZXhwb3J0cy5FVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgPSBFVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVA7XG4vKiogQGludGVybmFsICovXG52YXIgZXRoTXNnUHJvdG9jb2wgPSB7XG4gICAgU0lHTl9QRVJTT05BTDoge1xuICAgICAgICBzdHI6ICdzaWduUGVyc29uYWwnLFxuICAgICAgICBlbnVtSWR4OiAwLCAvLyBFbnVtIGluZGV4IG9mIHRoaXMgcHJvdG9jb2wgaW4gTGF0dGljZSBmaXJtd2FyZVxuICAgIH0sXG4gICAgVFlQRURfREFUQToge1xuICAgICAgICBzdHI6ICd0eXBlZERhdGEnLFxuICAgICAgICBlbnVtSWR4OiAxLFxuICAgICAgICByYXdEYXRhTWF4TGVuOiAxNjI5LFxuICAgICAgICB0eXBlQ29kZXM6IEVJUDcxMl9BQklfTEFUVElDRV9GV19UWVBFX01BUCwgLy8gRW51bSBpbmRpY2VzIG9mIGRhdGEgdHlwZXMgaW4gTGF0dGljZSBmaXJtd2FyZVxuICAgIH0sXG59O1xuZXhwb3J0cy5ldGhNc2dQcm90b2NvbCA9IGV0aE1zZ1Byb3RvY29sO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZ2V0RndWZXJzaW9uQ29uc3Qodikge1xuICAgIHZhciBjID0ge1xuICAgICAgICBleHRyYURhdGFGcmFtZVN6OiAwLFxuICAgICAgICBleHRyYURhdGFNYXhGcmFtZXM6IDAsXG4gICAgICAgIGdlbmVyaWNTaWduaW5nOiB7fSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGd0ZSh2LCBleHApIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGB2YCBmaWVsZHMgY29tZSBpbiBhcyBbZml4fG1pbm9yfG1ham9yXVxuICAgICAgICByZXR1cm4gKHZbMl0gPiBleHBbMF0gfHxcbiAgICAgICAgICAgICh2WzJdID09PSBleHBbMF0gJiYgdlsxXSA+IGV4cFsxXSkgfHxcbiAgICAgICAgICAgICh2WzJdID09PSBleHBbMF0gJiYgdlsxXSA9PT0gZXhwWzFdICYmIHZbMF0gPiBleHBbMl0pIHx8XG4gICAgICAgICAgICAodlsyXSA9PT0gZXhwWzBdICYmIHZbMV0gPT09IGV4cFsxXSAmJiB2WzBdID09PSBleHBbMl0pKTtcbiAgICB9XG4gICAgLy8gVmVyeSBvbGQgbGVnYWN5IHZlcnNpb25zIGRvIG5vdCBnaXZlIGEgdmVyc2lvbiBudW1iZXJcbiAgICB2YXIgbGVnYWN5ID0gdi5sZW5ndGggPT09IDA7XG4gICAgLy8gQkFTRSBGSUVMRFNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVmFyaW91cyBzaXplIGNvbnN0YW50cyBoYXZlIGNoYW5nZWQgb24gdGhlIGZpcm13YXJlIHNpZGUgb3ZlciB0aW1lIGFuZFxuICAgIC8vIGFyZSBjYXB0dXJlZCBoZXJlXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMCwgNF0pKSB7XG4gICAgICAgIC8vID49MC4xMC4zXG4gICAgICAgIGMucmVxTWF4RGF0YVN6ID0gMTY3ODtcbiAgICAgICAgYy5ldGhNYXhHYXNQcmljZSA9IDIwMDAwMDAwMDAwMDAwOyAvLyAyMDAwMCBnd2VpXG4gICAgICAgIGMuYWRkckZsYWdzQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMCwgMF0pKSB7XG4gICAgICAgIC8vID49MC4xMC4wXG4gICAgICAgIGMucmVxTWF4RGF0YVN6ID0gMTY3ODtcbiAgICAgICAgYy5ldGhNYXhHYXNQcmljZSA9IDIwMDAwMDAwMDAwMDAwOyAvLyAyMDAwMCBnd2VpXG4gICAgICAgIGMuYWRkckZsYWdzQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBMZWdhY3kgb3IgPDAuMTAuMFxuICAgICAgICBjLnJlcU1heERhdGFTeiA9IDExNTI7XG4gICAgICAgIGMuZXRoTWF4R2FzUHJpY2UgPSA1MDAwMDAwMDAwMDA7IC8vIDUwMCBnd2VpXG4gICAgICAgIGMuYWRkckZsYWdzQWxsb3dlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBUaGVzZSB0cmFuc2Zvcm1hdGlvbnMgYXBwbHkgdG8gYWxsIHZlcnNpb25zLiBUaGUgc3VidHJhY3Rpb25cbiAgICAvLyBvZiAxMjggYnl0ZXMgYWNjb3VudHMgZm9yIG1ldGFkYXRhIGFuZCBpcyBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gICAgLy8gRm9yIGFsbCBtb2Rlcm4gdmVyc2lvbnMsIHRoZXNlIGFyZSAxNTUwIGJ5dGVzLlxuICAgIC8vIE5PVEU6IE5vbi1sZWdhY3kgRVRIIHR4cyAoZS5nLiBFSVAxNTU5KSB3aWxsIHNocmlua1xuICAgIC8vIHRoaXMgbnVtYmVyLlxuICAgIC8vIFNlZSBgRVRIX0JBU0VfVFhfTUFYX0RBVEFfU1pgIGFuZCBgRVRIX01BWF9CQVNFX01TR19TWmAgaW4gZmlybXdhcmVcbiAgICBjLmV0aE1heERhdGFTeiA9IGMucmVxTWF4RGF0YVN6IC0gMTI4O1xuICAgIGMuZXRoTWF4TXNnU3ogPSBjLmV0aE1heERhdGFTejtcbiAgICAvLyBNYXggbnVtYmVyIG9mIHBhcmFtcyBpbiBhbiBFSVA3MTIgdHlwZS4gVGhpcyB3YXMgYWRkZWQgdG8gZmlybXdhcmVcbiAgICAvLyB0byBhdm9pZCBibG93aW5nIHN0YWNrIHNpemUuXG4gICAgYy5laXA3MTJNYXhUeXBlUGFyYW1zID0gMTg7XG4gICAgLy8gLS0tLS1cbiAgICAvLyBFWFRSQSBGSUVMRFMgQURERUQgSU4gTEFURVIgRklSTVdBUkUgVkVSU0lPTlNcbiAgICAvLyAtLS0tLVxuICAgIC8vIC0tLSBWMC4xMC5YIC0tLVxuICAgIC8vIFYwLjEwLjQgaW50cm9kdWNlZCB0aGUgYWJpbGl0eSB0byBzZW5kIHNpZ25pbmcgcmVxdWVzdHMgb3ZlciBtdWx0aXBsZVxuICAgIC8vIGRhdGEgZnJhbWVzIChpLmUuIGluIG11bHRpcGxlIHJlcXVlc3RzKVxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDRdKSkge1xuICAgICAgICBjLmV4dHJhRGF0YUZyYW1lU3ogPSAxNTAwOyAvLyAxNTAwIGJ5dGVzIHBlciBmcmFtZSBvZiBleHRyYURhdGEgYWxsb3dlZFxuICAgICAgICBjLmV4dHJhRGF0YU1heEZyYW1lcyA9IDE7IC8vIDEgZnJhbWUgb2YgZXh0cmFEYXRhIGFsbG93ZWRcbiAgICB9XG4gICAgLy8gVjAuMTAuNSBhZGRlZCB0aGUgYWJpbGl0eSB0byB1c2UgZmxleGlibGUgYWRkcmVzcyBwYXRoIHNpemVzLCB3aGljaFxuICAgIC8vIGNoYW5nZXMgdGhlIGBnZXRBZGRyZXNzYCBBUEkuIEl0IGFsc28gYWRkZWQgc3VwcG9ydCBmb3IgRUlQNzEyXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMCwgNV0pKSB7XG4gICAgICAgIGMudmFyQWRkclBhdGhTekFsbG93ZWQgPSB0cnVlO1xuICAgICAgICBjLmVpcDcxMlN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIFYwLjEwLjggYWxsb3dzIGEgdXNlciB0byBzaWduIGEgcHJlaGFzaGVkIHRyYW5zYWN0aW9uIGlmIHRoZSBwYXlsb2FkXG4gICAgLy8gaXMgdG9vIGJpZ1xuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDhdKSkge1xuICAgICAgICBjLnByZWhhc2hBbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVjAuMTAuMTAgYWxsb3dzIGEgdXNlciB0byBzaWduIGEgcHJlaGFzaGVkIEVUSCBtZXNzYWdlIGlmIHBheWxvYWQgdG9vIGJpZ1xuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDEwXSkpIHtcbiAgICAgICAgYy5ldGhNc2dQcmVIYXNoQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIC0tLSAwLjExLlggLS0tXG4gICAgLy8gVjAuMTEuMCBhbGxvd3MgbmV3IEVUSCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTEsIDBdKSkge1xuICAgICAgICBjLmFsbG93ZWRFdGhUeFR5cGVzID0gW1xuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDIsIC8vIGVpcDE1NTlcbiAgICAgICAgXTtcbiAgICAgICAgLy8gVGhpcyB2ZXJzaW9uIGFkZGVkIGV4dHJhIGRhdGEgZmllbGRzIHRvIHRoZSBFVEggdHhcbiAgICAgICAgYy5ldGhNYXhEYXRhU3ogLT0gMTA7XG4gICAgICAgIGMuZXRoTWF4TXNnU3ogPSBjLmV0aE1heERhdGFTejtcbiAgICB9XG4gICAgLy8gVjAuMTEuMiBjaGFuZ2VkIGhvdyBtZXNzYWdlcyBhcmUgZGlzcGxheWVkLiBGb3IgcGVyc29uYWxfc2lnbiBtZXNzYWdlc1xuICAgIC8vIHdlIG5vdyB3cml0ZSB0aGUgaGVhZGVyIChgU2lnbmVyOiA8cGF0aD5gKSBpbnRvIHRoZSBtYWluIGJvZHkgb2YgdGhlIHNjcmVlbi5cbiAgICAvLyBUaGlzIG1lYW5zIHBlcnNvbmFsIHNpZ24gbWVzc2FnZSBtYXggc2l6ZSBpcyBzbGlnaHRseSBzbWFsbGVyIHRoYW4gZm9yXG4gICAgLy8gRUlQNzEyIG1lc3NhZ2VzIGJlY2F1c2UgaW4gdGhlIGxhdHRlciBjYXNlIHRoZXJlIGlzIG5vIGhlYWRlclxuICAgIC8vIE5vdGUgdGhhdCBgPHBhdGg+YCBoYXMgbWF4IHNpemUgb2YgNjIgYnl0ZXMgKGBtL1gvWC8uLi5gKVxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTEsIDJdKSkge1xuICAgICAgICBjLnBlcnNvbmFsU2lnbkhlYWRlclN6ID0gNzI7XG4gICAgfVxuICAgIC8vIC0tLSBWMC4xMi5YIC0tLVxuICAgIC8vIFYwLjEyLjAgYWRkZWQgYW4gQVBJIGZvciBjcmVhdGluZywgcmVtb3ZpbmcsIGFuZCBmZXRjaGluZyBrZXktdmFsIGZpbGVcbiAgICAvLyByZWNvcmRzLiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgU0RLLCB3ZSBvbmx5IGhvb2sgaW50byBvbmUgdHlwZSBvZiBrdlxuICAgIC8vIGZpbGU6IGFkZHJlc3MgbmFtZXMuXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMiwgMF0pKSB7XG4gICAgICAgIGMua3ZBY3Rpb25zQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIGMua3ZLZXlNYXhTdHJTeiA9IDYzO1xuICAgICAgICBjLmt2VmFsTWF4U3RyU3ogPSA2MztcbiAgICAgICAgYy5rdkFjdGlvbk1heE51bSA9IDEwO1xuICAgICAgICBjLmt2UmVtb3ZlTWF4TnVtID0gMTAwO1xuICAgIH1cbiAgICAvLyAtLS0gVjAuMTMuWCAtLS1cbiAgICAvLyBWMC4xMy4wIGFkZGVkIG5hdGl2ZSBzZWd3aXQgYWRkcmVzc2VzIGFuZCBmaXhlZCBhIGJ1ZyBpbiBleHBvcnRpbmdcbiAgICAvLyBsZWdhY3kgYml0Y29pbiBhZGRyZXNzZXNcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEzLCAwXSkpIHtcbiAgICAgICAgYy5hbGxvd0J0Y0xlZ2FjeUFuZFNlZ3dpdEFkZHJzID0gdHJ1ZTtcbiAgICAgICAgLy8gUmFuZG9tIGFkZHJlc3MgdG8gYmUgdXNlZCB3aGVuIHRyeWluZyB0byBkZXBsb3kgYSBjb250cmFjdFxuICAgICAgICBjLmNvbnRyYWN0RGVwbG95S2V5ID0gJzB4MDgwMDJlMGZlYzhlNmFjZjAwODM1ZjQzYzk3NjRmNzM2NGZhM2Y0Mic7XG4gICAgfVxuICAgIC8vIC0tLSBWMC4xNC5YIC0tLVxuICAgIC8vIFYwLjE0LjAgYWRkZWQgc3VwcG9ydCBmb3IgYSBtb3JlIHJvYnVzdCBBUEkgYXJvdW5kIEFCSSBkZWZpbml0aW9uc1xuICAgIC8vIGFuZCBnZW5lcmljIHNpZ25pbmcgZnVuY3Rpb25hbGl0eVxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTQsIDBdKSkge1xuICAgICAgICAvLyBTaXplIG9mIGBjYXRlZ29yeWAgYnVmZmVyLiBJbmNsdXNpdmUgb2YgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXG4gICAgICAgIGMuYWJpQ2F0ZWdvcnlTeiA9IDMyO1xuICAgICAgICBjLmFiaU1heFJtdiA9IDIwMDsgLy8gTWF4IG51bWJlciBvZiBBQkkgZGVmcyB0aGF0IGNhbiBiZSByZW1vdmVkIHdpdGhcbiAgICAgICAgLy8gYSBzaW5nbGUgcmVxdWVzdFxuICAgICAgICAvLyBTZWUgYHNpemVvZihHZW5lcmljU2lnbmluZ1JlcXVlc3RfdClgIGluIGZpcm13YXJlXG4gICAgICAgIGMuZ2VuZXJpY1NpZ25pbmcuYmFzZVJlcVN6ID0gMTU1MjtcbiAgICAgICAgLy8gU2VlIGBHRU5FUklDX1NJR05JTkdfQkFTRV9NU0dfU1pgIGluIGZpcm13YXJlXG4gICAgICAgIGMuZ2VuZXJpY1NpZ25pbmcuYmFzZURhdGFTeiA9IDE1MTk7XG4gICAgICAgIGMuZ2VuZXJpY1NpZ25pbmcuaGFzaFR5cGVzID0gZXhwb3J0cy5FWFRFUk5BTC5TSUdOSU5HLkhBU0hFUztcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5jdXJ2ZVR5cGVzID0gZXhwb3J0cy5FWFRFUk5BTC5TSUdOSU5HLkNVUlZFUztcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5lbmNvZGluZ1R5cGVzID0ge1xuICAgICAgICAgICAgTk9ORTogZXhwb3J0cy5FWFRFUk5BTC5TSUdOSU5HLkVOQ09ESU5HUy5OT05FLFxuICAgICAgICAgICAgU09MQU5BOiBleHBvcnRzLkVYVEVSTkFMLlNJR05JTkcuRU5DT0RJTkdTLlNPTEFOQSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU3VwcG9ydGVkIGZsYWdzIGZvciBgZ2V0QWRkcmVzc2VzYFxuICAgICAgICBjLmdldEFkZHJlc3NGbGFncyA9IFtcbiAgICAgICAgICAgIGV4cG9ydHMuRVhURVJOQUwuR0VUX0FERFJfRkxBR1MuRUQyNTUxOV9QVUIsXG4gICAgICAgICAgICBleHBvcnRzLkVYVEVSTkFMLkdFVF9BRERSX0ZMQUdTLlNFQ1AyNTZLMV9QVUIsXG4gICAgICAgIF07XG4gICAgICAgIC8vIFdlIHVwZGF0ZWQgdGhlIG1heCBudW1iZXIgb2YgcGFyYW1zIGluIEVJUDcxMiB0eXBlc1xuICAgICAgICBjLmVpcDcxMk1heFR5cGVQYXJhbXMgPSAzNjtcbiAgICB9XG4gICAgLy8gREVQUkVDQVRFRFxuICAgIC8vIFYwLjE0LjEgQWRkZWQgdGhlIFRlcnJhIGRlY29kZXJcbiAgICAvLyBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDE0LCAxXSkpIHtcbiAgICAvLyAgIGMuZ2VuZXJpY1NpZ25pbmcuZW5jb2RpbmdUeXBlcy5URVJSQSA9IEVYVEVSTkFMLlNJR05JTkcuRU5DT0RJTkdTLlRFUlJBO1xuICAgIC8vIH1cbiAgICAvLyAtLS0gVjAuMTUuWCAtLS1cbiAgICAvLyBWMC4xNS4wIGFkZGVkIGFuIEVWTSBkZWNvZGVyIGFuZCByZW1vdmVkIHRoZSBsZWdhY3kgRVRIIHNpZ25pbmcgcGF0aHdheVxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTUsIDBdKSkge1xuICAgICAgICBjLmdlbmVyaWNTaWduaW5nLmVuY29kaW5nVHlwZXMuRVZNID0gZXhwb3J0cy5FWFRFUk5BTC5TSUdOSU5HLkVOQ09ESU5HUy5FVk07XG4gICAgICAgIC8vIFdlIG5vdyB1c2UgdGhlIGdlbmVyYWwgc2lnbmluZyBkYXRhIGZpZWxkIGFzIHRoZSBiYXNlXG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBoYXZlIE5PVCByZW1vdmVkIHRoZSBFVEhfTVNHIHR5cGUgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIG5vdCBjaGFuZ2UgZXRoTWF4TXNnU3pcbiAgICAgICAgYy5ldGhNYXhEYXRhU3ogPSAxNTUwIC0gMzE7XG4gICAgICAgIC8vIE1heCBidWZmZXIgc2l6ZSBmb3IgZ2V0L2FkZCBkZWNvZGVyIHJlcXVlc3RzXG4gICAgICAgIGMubWF4RGVjb2RlckJ1ZlN6ID0gMTYwMDtcbiAgICAgICAgLy8gQ29kZSB1c2VkIHRvIHdyaXRlIGEgY2FsbGRhdGEgZGVjb2RlclxuICAgICAgICBjLmdlbmVyaWNTaWduaW5nLmNhbGxkYXRhRGVjb2RpbmcgPSB7XG4gICAgICAgICAgICByZXNlcnZlZDogMjg5NTcyOCxcbiAgICAgICAgICAgIG1heFN6OiAxMDI0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAtLS0gVjAuMTcuWCAtLS1cbiAgICAvLyBWMC4xNy4wIGFkZGVkIHN1cHBvcnQgZm9yIEJMUzEyLTM4MS1HMSBwdWJrZXlzIGFuZCBHMiBzaWdzXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxNywgMF0pKSB7XG4gICAgICAgIGMuZ2V0QWRkcmVzc0ZsYWdzLnB1c2goZXhwb3J0cy5FWFRFUk5BTC5HRVRfQUREUl9GTEFHUy5CTFMxMl8zODFfRzFfUFVCKTtcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5lbmNvZGluZ1R5cGVzLkVUSF9ERVBPU0lUID0gZXhwb3J0cy5FWFRFUk5BTC5TSUdOSU5HLkVOQ09ESU5HUy5FVEhfREVQT1NJVDtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmdldEZ3VmVyc2lvbkNvbnN0ID0gZ2V0RndWZXJzaW9uQ29uc3Q7XG4vKiogQGludGVybmFsICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIEFTQ0lJX1JFR0VYID0gL15bXFx4MDAtXFx4N0ZdKyQvO1xuZXhwb3J0cy5BU0NJSV9SRUdFWCA9IEFTQ0lJX1JFR0VYO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEVYVEVSTkFMX05FVFdPUktTX0JZX0NIQUlOX0lEX1VSTCA9ICdodHRwczovL2dyaWRwbHVzLmdpdGh1Yi5pby9jaGFpbnMvY2hhaW5zLmpzb24nO1xuZXhwb3J0cy5FWFRFUk5BTF9ORVRXT1JLU19CWV9DSEFJTl9JRF9VUkwgPSBFWFRFUk5BTF9ORVRXT1JLU19CWV9DSEFJTl9JRF9VUkw7XG4vKiogQGludGVybmFsIC0gTWF4IG51bWJlciBvZiBhZGRyZXNzZXMgdG8gZmV0Y2ggKi9cbnZhciBNQVhfQUREUiA9IDEwO1xuZXhwb3J0cy5NQVhfQUREUiA9IE1BWF9BRERSO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIE5FVFdPUktTX0JZX0NIQUlOX0lEID0ge1xuICAgIDE6IHtcbiAgICAgICAgbmFtZTogJ2V0aGVyZXVtJyxcbiAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLmV0aGVyc2Nhbi5pbycsXG4gICAgICAgIGFwaVJvdXRlOiAnYXBpP21vZHVsZT1jb250cmFjdCZhY3Rpb249Z2V0YWJpJyxcbiAgICB9LFxuICAgIDEzNzoge1xuICAgICAgICBuYW1lOiAncG9seWdvbicsXG4gICAgICAgIGJhc2VVcmw6ICdodHRwczovL2FwaS5wb2x5Z29uc2Nhbi5jb20nLFxuICAgICAgICBhcGlSb3V0ZTogJ2FwaT9tb2R1bGU9Y29udHJhY3QmYWN0aW9uPWdldGFiaScsXG4gICAgfSxcbiAgICA1Njoge1xuICAgICAgICBuYW1lOiAnYmluYW5jZScsXG4gICAgICAgIGJhc2VVcmw6ICdodHRwczovL2FwaS5ic2NzY2FuLmNvbScsXG4gICAgICAgIGFwaVJvdXRlOiAnYXBpP21vZHVsZT1jb250cmFjdCZhY3Rpb249Z2V0YWJpJyxcbiAgICB9LFxuICAgIDQyMjIwOiB7XG4gICAgICAgIG5hbWU6ICdjZWxvJyxcbiAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLmNlbG9zY2FuLmlvJyxcbiAgICAgICAgYXBpUm91dGU6ICdhcGk/bW9kdWxlPWNvbnRyYWN0JmFjdGlvbj1nZXRhYmknLFxuICAgIH0sXG4gICAgNDMxMTQ6IHtcbiAgICAgICAgbmFtZTogJ2F2YWxhbmNoZScsXG4gICAgICAgIGJhc2VVcmw6ICdodHRwczovL2FwaS5zbm93dHJhY2UuaW8nLFxuICAgICAgICBhcGlSb3V0ZTogJ2FwaT9tb2R1bGU9Y29udHJhY3QmYWN0aW9uPWdldGFiaScsXG4gICAgfSxcbn07XG5leHBvcnRzLk5FVFdPUktTX0JZX0NIQUlOX0lEID0gTkVUV09SS1NfQllfQ0hBSU5fSUQ7XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkVNUFRZX1dBTExFVF9VSUQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5ERUZBVUxUX0FDVElWRV9XQUxMRVRTID0ge1xuICAgIGludGVybmFsOiB7XG4gICAgICAgIHVpZDogZXhwb3J0cy5FTVBUWV9XQUxMRVRfVUlELFxuICAgICAgICBleHRlcm5hbDogZmFsc2UsXG4gICAgICAgIG5hbWU6IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgY2FwYWJpbGl0aWVzOiAwLFxuICAgIH0sXG4gICAgZXh0ZXJuYWw6IHtcbiAgICAgICAgdWlkOiBleHBvcnRzLkVNUFRZX1dBTExFVF9VSUQsXG4gICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICBuYW1lOiBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGNhcGFiaWxpdGllczogMCxcbiAgICB9LFxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMuREVGQVVMVF9FVEhfREVSSVZBVElPTiA9IFtcbiAgICBIQVJERU5FRF9PRkZTRVQgKyA0NCxcbiAgICBIQVJERU5FRF9PRkZTRVQgKyA2MCxcbiAgICBIQVJERU5FRF9PRkZTRVQsXG4gICAgMCxcbiAgICAwLFxuXTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMuQlRDX0xFR0FDWV9ERVJJVkFUSU9OID0gW1xuICAgIEhBUkRFTkVEX09GRlNFVCArIDQ0LFxuICAgIEhBUkRFTkVEX09GRlNFVCArIDAsXG4gICAgSEFSREVORURfT0ZGU0VULFxuICAgIDAsXG4gICAgMCxcbl07XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkJUQ19TRUdXSVRfREVSSVZBVElPTiA9IFtcbiAgICBIQVJERU5FRF9PRkZTRVQgKyA4NCxcbiAgICBIQVJERU5FRF9PRkZTRVQsXG4gICAgSEFSREVORURfT0ZGU0VULFxuICAgIDAsXG4gICAgMCxcbl07XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkJUQ19XUkFQUEVEX1NFR1dJVF9ERVJJVkFUSU9OID0gW1xuICAgIEhBUkRFTkVEX09GRlNFVCArIDQ5LFxuICAgIEhBUkRFTkVEX09GRlNFVCxcbiAgICBIQVJERU5FRF9PRkZTRVQsXG4gICAgMCxcbiAgICAwLFxuXTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMuU09MQU5BX0RFUklWQVRJT04gPSBbXG4gICAgSEFSREVORURfT0ZGU0VUICsgNDQsXG4gICAgSEFSREVORURfT0ZGU0VUICsgNTAxLFxuICAgIEhBUkRFTkVEX09GRlNFVCxcbl07XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkxFREdFUl9MSVZFX0RFUklWQVRJT04gPSBbXG4gICAgSEFSREVORURfT0ZGU0VUICsgNDksXG4gICAgSEFSREVORURfT0ZGU0VUICsgNjAsXG4gICAgSEFSREVORURfT0ZGU0VULFxuICAgIDAsXG4gICAgMCxcbl07XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkxFREdFUl9MRUdBQ1lfREVSSVZBVElPTiA9IFtcbiAgICBIQVJERU5FRF9PRkZTRVQgKyA0OSxcbiAgICBIQVJERU5FRF9PRkZTRVQgKyA2MCxcbiAgICBIQVJERU5FRF9PRkZTRVQsXG4gICAgMCxcbl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFV0aWxzIGZvciBFdGhlcmV1bSB0cmFuc2FjdGlvbnMuIFRoaXMgaXMgZWZmZWNpdHZlbHkgYSBzaGltIG9mIGV0aGVyZXVtanMtdXRpbCwgd2hpY2hcbi8vIGRvZXMgbm90IGhhdmUgYnJvd3NlciAob3IsIGJ5IHByb3h5LCBSZWFjdC1OYXRpdmUpIHN1cHBvcnQuXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvY29tbW9uXCIpO1xudmFyIHR4XzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdHhcIik7XG52YXIgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG52YXIgYm9yY18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJib3JjXCIpKTtcbi8vQHRzLWV4cGVjdC1lcnJvciAtIFRoaXMgdGhpcmQtcGFydHkgcGFja2FnZSBpcyBub3QgdHlwZWQgcHJvcGVybHlcbnZhciBldGhfZWlwNzEyX3V0aWxfYnJvd3Nlcl8xID0gcmVxdWlyZShcImV0aC1laXA3MTItdXRpbC1icm93c2VyXCIpO1xudmFyIGpzX3NoYTNfMSA9IHJlcXVpcmUoXCJqcy1zaGEzXCIpO1xudmFyIHJscF8xID0gcmVxdWlyZShcInJscFwiKTtcbnZhciBzZWNwMjU2azFfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic2VjcDI1NmsxXCIpKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4vcHJvdG9jb2xcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBidWlsZEV0aGVyZXVtTXNnUmVxdWVzdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghaW5wdXQucGF5bG9hZCB8fCAhaW5wdXQucHJvdG9jb2wgfHwgIWlucHV0LnNpZ25lclBhdGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBgcGF5bG9hZGAsIGBzaWduZXJQYXRoYCwgYW5kIGBwcm90b2NvbGAgYXJndW1lbnRzIGluIHRoZSBtZXNzc2FnZSByZXF1ZXN0Jyk7XG4gICAgaWYgKGlucHV0LnNpZ25lclBhdGgubGVuZ3RoID4gNSB8fCBpbnB1dC5zaWduZXJQYXRoLmxlbmd0aCA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBzaWduZXIgcGF0aCB3aXRoIDItNSBpbmRpY2VzJyk7XG4gICAgdmFyIHJlcSA9IHtcbiAgICAgICAgc2NoZW1hOiBwcm90b2NvbF8xLkxhdHRpY2VTaWduU2NoZW1hLmV0aGVyZXVtTXNnLFxuICAgICAgICBwYXlsb2FkOiBudWxsLFxuICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgIG1zZzogbnVsbCwgLy8gU2F2ZSB0aGUgYnVmZmVyZWQgbWVzc2FnZSBmb3IgbGF0ZXJcbiAgICB9O1xuICAgIHN3aXRjaCAoaW5wdXQucHJvdG9jb2wpIHtcbiAgICAgICAgY2FzZSAnc2lnblBlcnNvbmFsJzpcbiAgICAgICAgICAgIHJldHVybiBidWlsZFBlcnNvbmFsU2lnblJlcXVlc3QocmVxLCBpbnB1dCk7XG4gICAgICAgIGNhc2UgJ2VpcDcxMic6XG4gICAgICAgICAgICBpZiAoIWlucHV0LmZ3Q29uc3RhbnRzLmVpcDcxMlN1cHBvcnRlZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VJUDcxMiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgTGF0dGljZSBmaXJtd2FyZSB2ZXJzaW9uLiBQbGVhc2UgdXBncmFkZS4nKTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZEVJUDcxMlJlcXVlc3QocmVxLCBpbnB1dCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sJyk7XG4gICAgfVxufTtcbnZhciB2YWxpZGF0ZUV0aGVyZXVtTXNnUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzLCByZXEpIHtcbiAgICB2YXIgc2lnbmVyID0gcmVzLnNpZ25lciwgc2lnID0gcmVzLnNpZztcbiAgICB2YXIgaW5wdXQgPSByZXEuaW5wdXQsIG1zZyA9IHJlcS5tc2csIF9hID0gcmVxLnByZWhhc2gsIHByZWhhc2ggPSBfYSA9PT0gdm9pZCAwID8gbnVsbCA6IF9hO1xuICAgIGlmIChpbnB1dC5wcm90b2NvbCA9PT0gJ3NpZ25QZXJzb25hbCcpIHtcbiAgICAgICAgLy8gTk9URTogV2UgYXJlIGN1cnJlbnRseSBoYXJkY29kaW5nIG5ldHdvcmtJRD0xIGFuZCB1c2VFSVAxNTU9ZmFsc2UgYnV0IHRoZXNlXG4gICAgICAgIC8vICAgICAgIG1heSBiZSBjb25maWd1cmFibGUgaW4gZnV0dXJlIHZlcnNpb25zXG4gICAgICAgIHZhciBoYXNoXzEgPSBwcmVoYXNoXG4gICAgICAgICAgICA/IHByZWhhc2hcbiAgICAgICAgICAgIDogQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKEJ1ZmZlci5jb25jYXQoW2dldF9wZXJzb25hbF9zaWduX3ByZWZpeChtc2cubGVuZ3RoKSwgbXNnXSkpLCAnaGV4Jyk7XG4gICAgICAgIC8vIEdldCByZWNvdmVyeSBwYXJhbSB3aXRoIGEgYHZgIHZhbHVlIG9mIFsyNywyOF0gYnkgc2V0dGluZyBgdXNlRUlQMTU1PWZhbHNlYFxuICAgICAgICByZXR1cm4gYWRkUmVjb3ZlcnlQYXJhbShoYXNoXzEsIHNpZywgc2lnbmVyLCB7XG4gICAgICAgICAgICBjaGFpbklkOiAxLFxuICAgICAgICAgICAgdXNlRUlQMTU1OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0LnByb3RvY29sID09PSAnZWlwNzEyJykge1xuICAgICAgICB2YXIgZW5jb2RlZCA9IGV0aF9laXA3MTJfdXRpbF9icm93c2VyXzEuVHlwZWREYXRhVXRpbHMuaGFzaChyZXEuaW5wdXQucGF5bG9hZCk7XG4gICAgICAgIHZhciBkaWdlc3QgPSBwcmVoYXNoID8gcHJlaGFzaCA6IGVuY29kZWQ7XG4gICAgICAgIC8vIEdldCByZWNvdmVyeSBwYXJhbSB3aXRoIGEgYHZgIHZhbHVlIG9mIFsyNywyOF0gYnkgc2V0dGluZyBgdXNlRUlQMTU1PWZhbHNlYFxuICAgICAgICByZXR1cm4gYWRkUmVjb3ZlcnlQYXJhbShkaWdlc3QsIHNpZywgc2lnbmVyLCB7IHVzZUVJUDE1NTogZmFsc2UgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sJyk7XG4gICAgfVxufTtcbnZhciBidWlsZEV0aGVyZXVtVHhSZXF1ZXN0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgX2EgPSBkYXRhLmNoYWluSWQsIGNoYWluSWQgPSBfYSA9PT0gdm9pZCAwID8gMSA6IF9hO1xuICAgICAgICB2YXIgc2lnbmVyUGF0aCA9IGRhdGEuc2lnbmVyUGF0aCwgX2IgPSBkYXRhLmVpcDE1NSwgZWlwMTU1ID0gX2IgPT09IHZvaWQgMCA/IG51bGwgOiBfYiwgZndDb25zdGFudHMgPSBkYXRhLmZ3Q29uc3RhbnRzLCBfYyA9IGRhdGEudHlwZSwgdHlwZSA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2M7XG4gICAgICAgIHZhciBjb250cmFjdERlcGxveUtleSA9IGZ3Q29uc3RhbnRzLmNvbnRyYWN0RGVwbG95S2V5LCBleHRyYURhdGFGcmFtZVN6ID0gZndDb25zdGFudHMuZXh0cmFEYXRhRnJhbWVTeiwgZXh0cmFEYXRhTWF4RnJhbWVzID0gZndDb25zdGFudHMuZXh0cmFEYXRhTWF4RnJhbWVzLCBwcmVoYXNoQWxsb3dlZCA9IGZ3Q29uc3RhbnRzLnByZWhhc2hBbGxvd2VkO1xuICAgICAgICB2YXIgRVhUUkFfREFUQV9BTExPV0VEID0gZXh0cmFEYXRhRnJhbWVTeiA+IDAgJiYgZXh0cmFEYXRhTWF4RnJhbWVzID4gMDtcbiAgICAgICAgdmFyIE1BWF9CQVNFX0RBVEFfU1ogPSBmd0NvbnN0YW50cy5ldGhNYXhEYXRhU3o7XG4gICAgICAgIHZhciBWQVJfUEFUSF9TWiA9IGZ3Q29uc3RhbnRzLnZhckFkZHJQYXRoU3pBbGxvd2VkO1xuICAgICAgICAvLyBTYW5pdHkgY2hlY2tzOlxuICAgICAgICAvLyBUaGVyZSBhcmUgYSBoYW5kZnVsIG9mIG5hbWVkIGNoYWlucyB3ZSBhbGxvdyB0aGUgdXNlciB0byByZWZlcmVuY2UgKGBjaGFpbklkc2ApXG4gICAgICAgIC8vIEN1c3RvbSBjaGFpbklEcyBzaG91bGQgYmUgZWl0aGVyIG51bWVyaWNhbCBvciBoZXggc3RyaW5nc1xuICAgICAgICBpZiAodHlwZW9mIGNoYWluSWQgIT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBpc1ZhbGlkQ2hhaW5JZEhleE51bVN0cihjaGFpbklkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBjaGFpbklkc1tjaGFpbklkXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHdhcyBub3QgYSBjdXN0b20gY2hhaW5JRCBhbmQgd2UgY2Fubm90IGZpbmQgdGhlIG5hbWUgb2YgaXQsIGV4aXRcbiAgICAgICAgaWYgKCFjaGFpbklkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjaGFpbiBJRCBvciBuYW1lJyk7XG4gICAgICAgIC8vIFNhbml0eSBjaGVjayBvbiBzaWduZVBhdGhcbiAgICAgICAgaWYgKCFzaWduZXJQYXRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgc2lnbmVyUGF0aGAgbm90IHByb3ZpZGVkJyk7XG4gICAgICAgIC8vIElzIHRoaXMgYSBjb250cmFjdCBkZXBsb3ltZW50P1xuICAgICAgICBpZiAoZGF0YS50byA9PT0gbnVsbCAmJiAhY29udHJhY3REZXBsb3lLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3QgZGVwbG95bWVudCBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHlvdXIgTGF0dGljZSBmaXJtd2FyZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNEZXBsb3ltZW50ID0gZGF0YS50byA9PT0gbnVsbCAmJiBjb250cmFjdERlcGxveUtleTtcbiAgICAgICAgLy8gV2Ugc3VwcG9ydCBlaXAxNTU5IGFuZCBlaXAyOTMwIHR5cGVzIChhcyB3ZWxsIGFzIGxlZ2FjeSlcbiAgICAgICAgdmFyIGVpcDE1NTlJc0FsbG93ZWQgPSBmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlcyAmJlxuICAgICAgICAgICAgZndDb25zdGFudHMuYWxsb3dlZEV0aFR4VHlwZXMuaW5kZXhPZigyKSA+IC0xO1xuICAgICAgICB2YXIgZWlwMjkzMElzQWxsb3dlZCA9IGZ3Q29uc3RhbnRzLmFsbG93ZWRFdGhUeFR5cGVzICYmXG4gICAgICAgICAgICBmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlcy5pbmRleE9mKDEpID4gLTE7XG4gICAgICAgIHZhciBpc0VpcDE1NTkgPSBlaXAxNTU5SXNBbGxvd2VkICYmICh0eXBlID09PSAyIHx8IHR5cGUgPT09ICdlaXAxNTU5Jyk7XG4gICAgICAgIHZhciBpc0VpcDI5MzAgPSBlaXAyOTMwSXNBbGxvd2VkICYmICh0eXBlID09PSAxIHx8IHR5cGUgPT09ICdlaXAyOTMwJyk7XG4gICAgICAgIGlmICh0eXBlICE9PSBudWxsICYmICFpc0VpcDE1NTkgJiYgIWlzRWlwMjkzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRXRoZXJldW0gdHJhbnNhY3Rpb24gdHlwZScpO1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHVzZSBFSVAxNTUgZ2l2ZW4gdGhlIGNoYWluSUQuXG4gICAgICAgIC8vIElmIHdlIGFyZSBleHBsaWNpdGx5IHRvbGQgdG8gdXNlIGVpcDE1NSwgd2Ugd2lsbCB1c2UgaXQuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gd2Ugd2lsbCBsb29rIHVwIGlmIHRoZSBzcGVjaWZpZWQgY2hhaW5JZCBpcyBhc3NvY2lhdGVkIHdpdGggYSBjaGFpblxuICAgICAgICAvLyB0aGF0IGRvZXMgbm90IHVzZSBFSVAxNTUgYnkgZGVmYXVsdC4gTm90ZSB0aGF0IG1vc3QgZG8gdXNlIEVJUDE1NS5cbiAgICAgICAgdmFyIHVzZUVJUDE1NSA9IGNoYWluVXNlc0VJUDE1NShjaGFpbklkKTtcbiAgICAgICAgaWYgKGVpcDE1NSAhPT0gbnVsbCAmJiB0eXBlb2YgZWlwMTU1ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHVzZUVJUDE1NSA9IGVpcDE1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VpcDE1NTkgfHwgaXNFaXAyOTMwKSB7XG4gICAgICAgICAgICAvLyBOZXdlciB0cmFuc2FjdGlvbiB0eXBlcyBkbyBub3QgdXNlIEVJUDE1NSBzaW5jZSB0aGUgY2hhaW5JZCBpcyBzZXJpYWxpemVkXG4gICAgICAgICAgICB1c2VFSVAxNTUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYWNrIGZvciBtZXRhbWFzaywgd2hpY2ggc2VuZHMgdmFsdWU9bnVsbCBmb3IgMCBFVEggdHJhbnNhY3Rpb25zXG4gICAgICAgIGlmICghZGF0YS52YWx1ZSlcbiAgICAgICAgICAgIGRhdGEudmFsdWUgPSAwO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDEuIEJVSUxEIFRIRSBSQVcgVFggRk9SIEZVVFVSRSBSTFAgRU5DT0RJTkdcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBFbnN1cmUgYWxsIGZpZWxkcyBhcmUgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3NcbiAgICAgICAgdmFyIHJhd1R4ID0gW107XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvbiBidWZmZXIgYXJyYXlcbiAgICAgICAgdmFyIGNoYWluSWRCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShjaGFpbklkKTtcbiAgICAgICAgdmFyIG5vbmNlQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS5ub25jZSk7XG4gICAgICAgIHZhciBnYXNQcmljZUJ5dGVzID0gdm9pZCAwO1xuICAgICAgICB2YXIgZ2FzTGltaXRCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLmdhc0xpbWl0KTtcbiAgICAgICAgLy8gSGFuZGxlIGNvbnRyYWN0IGRlcGxveW1lbnQgKGluZGljYXRlZCBieSBgdG9gIGJlaW5nIGBudWxsYClcbiAgICAgICAgLy8gRm9yIGNvbnRyYWN0IGRlcGxveW1lbnQgd2Ugd3JpdGUgYSAyMC1ieXRlIGtleSB0byB0aGUgcmVxdWVzdFxuICAgICAgICAvLyBidWZmZXIsIHdoaWNoIGdldHMgc3dhcHBlZCBmb3IgYW4gZW1wdHkgYnVmZmVyIGluIGZpcm13YXJlLlxuICAgICAgICB2YXIgdG9SbHBFbGVtID0gdm9pZCAwLCB0b0J5dGVzID0gdm9pZCAwO1xuICAgICAgICBpZiAoaXNEZXBsb3ltZW50KSB7XG4gICAgICAgICAgICB0b1JscEVsZW0gPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgICAgICB0b0J5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGNvbnRyYWN0RGVwbG95S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvUmxwRWxlbSA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLnRvKTtcbiAgICAgICAgICAgIHRvQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS50byk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS52YWx1ZSk7XG4gICAgICAgIHZhciBkYXRhQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS5kYXRhKTtcbiAgICAgICAgaWYgKGlzRWlwMTU1OSB8fCBpc0VpcDI5MzApIHtcbiAgICAgICAgICAgIC8vIEVJUDE1NTkgYW5kIEVJUDI5MzAgdHJhbnNhY3Rpb25zIGhhdmUgYSBjaGFpbklEIGZpZWxkXG4gICAgICAgICAgICByYXdUeC5wdXNoKGNoYWluSWRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmF3VHgucHVzaChub25jZUJ5dGVzKTtcbiAgICAgICAgdmFyIG1heFByaW9yaXR5RmVlUGVyR2FzQnl0ZXMgPSB2b2lkIDAsIG1heEZlZVBlckdhc0J5dGVzID0gdm9pZCAwO1xuICAgICAgICBpZiAoaXNFaXAxNTU5KSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFSVAxNTU5IHRyYW5zYWN0aW9ucyBtdXN0IGluY2x1ZGUgYG1heFByaW9yaXR5RmVlUGVyR2FzYCcpO1xuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIHJhd1R4LnB1c2gobWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcyk7XG4gICAgICAgICAgICBtYXhGZWVQZXJHYXNCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLm1heEZlZVBlckdhcyk7XG4gICAgICAgICAgICByYXdUeC5wdXNoKG1heEZlZVBlckdhc0J5dGVzKTtcbiAgICAgICAgICAgIC8vIEVJUDE1NTkgcmVuYW1lZCBcImdhc1ByaWNlXCIgdG8gXCJtYXhGZWVQZXJHYXNcIiwgYnV0IGZpcm13YXJlIHN0aWxsXG4gICAgICAgICAgICAvLyB1c2VzIGBnYXNQcmljZWAgaW4gdGhlIHN0cnVjdCwgc28gdXBkYXRlIHRoYXQgdmFsdWUgaGVyZS5cbiAgICAgICAgICAgIGdhc1ByaWNlQnl0ZXMgPSBtYXhGZWVQZXJHYXNCeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVJUDE1NTkgdHJhbnNhY3Rpb25zIGRvIG5vdCBoYXZlIHRoZSBnYXNQcmljZSBmaWVsZFxuICAgICAgICAgICAgZ2FzUHJpY2VCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLmdhc1ByaWNlKTtcbiAgICAgICAgICAgIHJhd1R4LnB1c2goZ2FzUHJpY2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmF3VHgucHVzaChnYXNMaW1pdEJ5dGVzKTtcbiAgICAgICAgcmF3VHgucHVzaCh0b1JscEVsZW0pO1xuICAgICAgICByYXdUeC5wdXNoKHZhbHVlQnl0ZXMpO1xuICAgICAgICByYXdUeC5wdXNoKGRhdGFCeXRlcyk7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NMaXN0IGluIGZpcm13YXJlIHNvIHdlIG5lZWQgdG8gcHJlaGFzaCBpZlxuICAgICAgICAvLyB0aGUgbGlzdCBpcyBub24tbnVsbFxuICAgICAgICB2YXIgUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUXzEgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzRWlwMTU1OSB8fCBpc0VpcDI5MzApIHtcbiAgICAgICAgICAgIHZhciBhY2Nlc3NMaXN0XzEgPSBbXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuYWNjZXNzTGlzdCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmFjY2Vzc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW0uc3RvcmFnZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzTGlzdF8xLnB1c2goWygwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShsaXN0SXRlbS5hZGRyZXNzKSwga2V5c10pO1xuICAgICAgICAgICAgICAgICAgICBQUkVIQVNIX0ZST01fQUNDRVNTX0xJU1RfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYXdUeC5wdXNoKGFjY2Vzc0xpc3RfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXNlRUlQMTU1ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBBZGQgZW1wdHkgdixyLHMgdmFsdWVzIGZvciBFSVAxNTUgbGVnYWN5IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgcmF3VHgucHVzaChjaGFpbklkQnl0ZXMpOyAvLyB2ICh3aGljaCBpcyB0aGUgc2FtZSBhcyBjaGFpbklkIGluIEVJUDE1NSB0eHMpXG4gICAgICAgICAgICByYXdUeC5wdXNoKCgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShudWxsKSk7IC8vIHJcbiAgICAgICAgICAgIHJhd1R4LnB1c2goKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKG51bGwpKTsgLy8gc1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gMi4gQlVJTEQgVEhFIExBVFRJQ0UgUkVRVUVTVCBQQVlMT0FEXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdmFyIEVUSF9UWF9OT05fREFUQV9TWiA9IDEyMjsgLy8gQWNjb3VudHMgZm9yIG1ldGFkYXRhIGFuZCBub24tZGF0YSBwYXJhbXNcbiAgICAgICAgdmFyIHR4UmVxUGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhNQVhfQkFTRV9EQVRBX1NaICsgRVRIX1RYX05PTl9EQVRBX1NaKTtcbiAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgIC8vIDEuIEVJUDE1NSBzd2l0Y2ggYW5kIGNoYWluSURcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdHhSZXFQYXlsb2FkLndyaXRlVUludDgoTnVtYmVyKHVzZUVJUDE1NSksIG9mZik7XG4gICAgICAgIG9mZisrO1xuICAgICAgICAvLyBOT1RFOiBPcmlnaW5hbGx5IHdlIGRlc2lnbmVkIGZvciBhIDEtYnl0ZSBjaGFpbklELCBidXQgbW9kZXJuIHJvbGx1cCBjaGFpbnMgdXNlIG11Y2ggbGFyZ2VyXG4gICAgICAgIC8vIGNoYWluSUQgdmFsdWVzLiBUbyBhY2NvdW50IGZvciB0aGVzZSwgd2Ugd2lsbCBwdXQgdGhlIGNoYWluSUQgaW50byB0aGUgYGRhdGFgIGJ1ZmZlciBpZiBpdFxuICAgICAgICAvLyBpcyA+PTI1NS4gVmFsdWVzIHVwIHRvIFVJTlQ2NF9NQVggd2lsbCBiZSBhbGxvd2VkLlxuICAgICAgICB2YXIgY2hhaW5JZEJ1ZiA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGNoYWluSWRCdWZTeiA9IDA7XG4gICAgICAgIGlmICh1c2VDaGFpbklkQnVmZmVyKGNoYWluSWQpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjaGFpbklkQnVmID0gZ2V0Q2hhaW5JZEJ1ZihjaGFpbklkKTtcbiAgICAgICAgICAgIGNoYWluSWRCdWZTeiA9IGNoYWluSWRCdWYubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNoYWluSWRCdWZTeiA+IGNvbnN0YW50c18xLk1BWF9DSEFJTl9JRF9CWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYWluSUQgcHJvdmlkZWQgaXMgdG9vIGxhcmdlLicpO1xuICAgICAgICAgICAgLy8gU2lnbmFsIHRvIExhdHRpY2UgZmlybXdhcmUgdGhhdCBpdCBuZWVkcyB0byByZWFkIHRoZSBjaGFpbklkIGZyb20gdGhlIHR4LmRhdGEgYnVmZmVyXG4gICAgICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OChjb25zdGFudHNfMS5IQU5ETEVfTEFSR0VSX0NIQUlOX0lELCBvZmYpO1xuICAgICAgICAgICAgb2ZmKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgY2hhaW5JRHMgPDI1NSwgd3JpdGUgaXQgdG8gdGhlIGNoYWluSWQgdTggc2xvdCBpbiB0aGUgbWFpbiB0eCBidWZmZXJcbiAgICAgICAgICAgIGNoYWluSWRCdWYgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoY2hhaW5JZEJ1Zi5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIGNoYWluSUQnKTtcbiAgICAgICAgICAgIGNoYWluSWRCdWYuY29weSh0eFJlcVBheWxvYWQsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gY2hhaW5JZEJ1Zi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gU2lnbmVyIFBhdGhcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdmFyIHNpZ25lclBhdGhCdWYgPSAoMCwgdXRpbF8xLmJ1aWxkU2lnbmVyUGF0aEJ1Zikoc2lnbmVyUGF0aCwgVkFSX1BBVEhfU1opO1xuICAgICAgICBzaWduZXJQYXRoQnVmLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpO1xuICAgICAgICBvZmYgKz0gc2lnbmVyUGF0aEJ1Zi5sZW5ndGg7XG4gICAgICAgIC8vIDMuIEVUSCBUWCByZXF1ZXN0IGRhdGFcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgaWYgKG5vbmNlQnl0ZXMubGVuZ3RoID4gNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uY2UgdG9vIGxhcmdlJyk7XG4gICAgICAgIG5vbmNlQnl0ZXMuY29weSh0eFJlcVBheWxvYWQsIG9mZiArICg0IC0gbm9uY2VCeXRlcy5sZW5ndGgpKTtcbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIGlmIChnYXNQcmljZUJ5dGVzLmxlbmd0aCA+IDgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhcyBwcmljZSB0b28gbGFyZ2UnKTtcbiAgICAgICAgZ2FzUHJpY2VCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDggLSBnYXNQcmljZUJ5dGVzLmxlbmd0aCkpO1xuICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgaWYgKGdhc0xpbWl0Qnl0ZXMubGVuZ3RoID4gNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2FzIGxpbWl0IHRvbyBsYXJnZScpO1xuICAgICAgICBnYXNMaW1pdEJ5dGVzLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYgKyAoNCAtIGdhc0xpbWl0Qnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICBpZiAodG9CeXRlcy5sZW5ndGggIT09IDIwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGB0b2AgYWRkcmVzcycpO1xuICAgICAgICB0b0J5dGVzLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMjA7XG4gICAgICAgIGlmICh2YWx1ZUJ5dGVzLmxlbmd0aCA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSB0b28gbGFyZ2UnKTtcbiAgICAgICAgdmFsdWVCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDMyIC0gdmFsdWVCeXRlcy5sZW5ndGgpKTtcbiAgICAgICAgb2ZmICs9IDMyO1xuICAgICAgICAvLyBFeHRyYSBUeCBkYXRhIGNvbWVzIGJlZm9yZSBgZGF0YWAgaW4gdGhlIHN0cnVjdFxuICAgICAgICB2YXIgUFJFSEFTSF9VTlNVUFBPUlRFRCA9IGZhbHNlO1xuICAgICAgICBpZiAoZndDb25zdGFudHMuYWxsb3dlZEV0aFR4VHlwZXMpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgdHlwZXMgbWF5IG5vdCBiZSBzdXBwb3J0ZWQgYnkgZmlybXdhcmUsIHNvIHdlIHdpbGwgbmVlZCB0byBwcmVoYXNoXG4gICAgICAgICAgICBpZiAoUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUXzEpIHtcbiAgICAgICAgICAgICAgICBQUkVIQVNIX1VOU1VQUE9SVEVEID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQ4KFBSRUhBU0hfVU5TVVBQT1JURUQgPyAxIDogMCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgLy8gRUlQMTU1OSAmIEVJUDI5MzAgc3RydWN0IHZlcnNpb25cbiAgICAgICAgICAgIGlmIChpc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OCgyLCBvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSAxOyAvLyBFaXAxNTU5IHR5cGUgZW51bSB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzLmxlbmd0aCA+IDgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYgKyAoOCAtIG1heFByaW9yaXR5RmVlUGVyR2FzQnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgb2ZmICs9IDg7IC8vIFNraXAgRUlQMTU1OSBwYXJhbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRWlwMjkzMCkge1xuICAgICAgICAgICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQ4KDEsIG9mZik7XG4gICAgICAgICAgICAgICAgb2ZmICs9IDE7IC8vIEVpcDI5MzAgdHlwZSBlbnVtIHZhbHVlXG4gICAgICAgICAgICAgICAgb2ZmICs9IDg7IC8vIFNraXAgRUlQMTU1OSBwYXJhbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZiArPSA5OyAvLyBTa2lwIEVJUDE1NTkgYW5kIEVJUDI5MzAgcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxvdyBkYXRhIGludG8gZXh0cmFEYXRhIHJlcXVlc3RzLCB3aGljaCB3aWxsIGZvbGxvdy11cCB0cmFuc2FjdGlvbiByZXF1ZXN0cywgaWYgc3VwcG9ydGVkL2FwcGxpY2FibGVcbiAgICAgICAgdmFyIGV4dHJhRGF0YVBheWxvYWRzXzEgPSBbXTtcbiAgICAgICAgdmFyIHByZWhhc2ggPSBudWxsO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGJ1ZmZlciwgcHJlZml4IHdpdGggY2hhaW5JZCAoaWYgbmVlZGVkKSBhbmQgYWRkIGRhdGEgc2xpY2VcbiAgICAgICAgdmFyIGRhdGFTeiA9IGRhdGFCeXRlcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdmFyIGNoYWluSWRFeHRyYVN6ID0gY2hhaW5JZEJ1ZlN6ID4gMCA/IGNoYWluSWRCdWZTeiArIDEgOiAwO1xuICAgICAgICB2YXIgZGF0YVRvQ29weSA9IEJ1ZmZlci5hbGxvYyhkYXRhU3ogKyBjaGFpbklkRXh0cmFTeik7XG4gICAgICAgIGlmIChjaGFpbklkRXh0cmFTeiA+IDApIHtcbiAgICAgICAgICAgIGRhdGFUb0NvcHkud3JpdGVVSW50OChjaGFpbklkQnVmU3osIDApO1xuICAgICAgICAgICAgY2hhaW5JZEJ1Zi5jb3B5KGRhdGFUb0NvcHksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFCeXRlcy5jb3B5KGRhdGFUb0NvcHksIGNoYWluSWRFeHRyYVN6KTtcbiAgICAgICAgaWYgKGRhdGFTeiA+IE1BWF9CQVNFX0RBVEFfU1opIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBzaXplcyBhbmQgcnVuIHRocm91Z2ggc2FuaXR5IGNoZWNrc1xuICAgICAgICAgICAgdmFyIHRvdGFsU3ogPSBkYXRhU3ogKyBjaGFpbklkRXh0cmFTejtcbiAgICAgICAgICAgIHZhciBtYXhTekFsbG93ZWQgPSBNQVhfQkFTRV9EQVRBX1NaICsgZXh0cmFEYXRhTWF4RnJhbWVzICogZXh0cmFEYXRhRnJhbWVTejtcbiAgICAgICAgICAgIGlmIChwcmVoYXNoQWxsb3dlZCAmJiB0b3RhbFN6ID4gbWF4U3pBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBzZW5kLCBidXQgdGhlIExhdHRpY2UgYWxsb3dzIGEgcHJlaGFzaGVkIG1lc3NhZ2UsIGRvIHRoYXRcbiAgICAgICAgICAgICAgICBwcmVoYXNoID0gQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGdldF9ybHBfZW5jb2RlZF9wcmVpbWFnZShyYXdUeCwgdHlwZSkpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIUVYVFJBX0RBVEFfQUxMT1dFRCB8fFxuICAgICAgICAgICAgICAgICAgICAoRVhUUkFfREFUQV9BTExPV0VEICYmIHRvdGFsU3ogPiBtYXhTekFsbG93ZWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGZpZWxkIHRvbyBsYXJnZSAoZ290IFwiLmNvbmNhdChkYXRhQnl0ZXMubGVuZ3RoLCBcIjsgbXVzdCBiZSA8PVwiKS5jb25jYXQobWF4U3pBbGxvd2VkIC0gY2hhaW5JZEV4dHJhU3osIFwiIGJ5dGVzKVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgb3ZlcmZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSBmcmFtZXNcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzXzEgPSAoMCwgdXRpbF8xLnNwbGl0RnJhbWVzKShkYXRhVG9Db3B5LnNsaWNlKE1BWF9CQVNFX0RBVEFfU1opLCBleHRyYURhdGFGcmFtZVN6KTtcbiAgICAgICAgICAgICAgICBmcmFtZXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3pMRSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgICAgICAgICAgc3pMRS53cml0ZVVJbnQzMkxFKGZyYW1lLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRGF0YVBheWxvYWRzXzEucHVzaChCdWZmZXIuY29uY2F0KFtzekxFLCBmcmFtZV0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQUkVIQVNIX1VOU1VQUE9SVEVEKSB7XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5zdXBwb3J0ZWQgaW4gZmlybXdhcmUgYnV0IHdlIHdhbnQgdG8gYWxsb3cgc3VjaCB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICAvLyB3ZSBwcmVoYXNoIHRoZSBtZXNzYWdlIGhlcmUuXG4gICAgICAgICAgICBwcmVoYXNoID0gQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGdldF9ybHBfZW5jb2RlZF9wcmVpbWFnZShyYXdUeCwgdHlwZSkpLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgdGhlIGRhdGEgc2l6ZSAoZG9lcyAqTk9UKiBpbmNsdWRlIHRoZSBjaGFpbklkIGJ1ZmZlciwgaWYgdGhhdCBleGlzdHMpXG4gICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQxNkJFKGRhdGFCeXRlcy5sZW5ndGgsIG9mZik7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICAvLyBDb3B5IGluIHRoZSBjaGFpbklkIGJ1ZmZlciBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGNoYWluSWRCdWZTeiA+IDApIHtcbiAgICAgICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQ4KGNoYWluSWRCdWZTeiwgb2ZmKTtcbiAgICAgICAgICAgIG9mZisrO1xuICAgICAgICAgICAgY2hhaW5JZEJ1Zi5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSBjaGFpbklkQnVmU3o7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29weSB0aGUgZmlyc3Qgc2xpY2Ugb2YgdGhlIGRhdGEgaXRzZWxmLiBJZiB0aGlzIHBheWxvYWQgaGFzIGJlZW4gcHJlLWhhc2hlZCwgaW5jbHVkZSBpdFxuICAgICAgICAvLyBpbiB0aGUgYGRhdGFgIGZpZWxkLiBUaGlzIHdpbGwgcmVzdWx0IGluIGEgZGlmZmVyZW50IExhdHRpY2Ugc2NyZWVuIGJlaW5nIGRyYXduLlxuICAgICAgICBpZiAocHJlaGFzaCkge1xuICAgICAgICAgICAgcHJlaGFzaC5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSBNQVhfQkFTRV9EQVRBX1NaO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YUJ5dGVzLnNsaWNlKDAsIE1BWF9CQVNFX0RBVEFfU1opLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IE1BWF9CQVNFX0RBVEFfU1o7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd1R4OiByYXdUeCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkOiB0eFJlcVBheWxvYWQuc2xpY2UoMCwgb2ZmKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YVBheWxvYWRzOiBleHRyYURhdGFQYXlsb2Fkc18xLFxuICAgICAgICAgICAgc2NoZW1hOiBwcm90b2NvbF8xLkxhdHRpY2VTaWduU2NoZW1hLmV0aGVyZXVtLFxuICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgIHVzZUVJUDE1NTogdXNlRUlQMTU1LFxuICAgICAgICAgICAgc2lnbmVyUGF0aDogc2lnbmVyUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4geyBlcnI6IGVyci5tZXNzYWdlIH07XG4gICAgfVxufTtcbi8vIEZyb20gZXRoZXJldW1qcy11dGlsXG5mdW5jdGlvbiBzdHJpcFplcm9zKGEpIHtcbiAgICB2YXIgZmlyc3QgPSBhWzBdO1xuICAgIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgICAgICBmaXJzdCA9IGFbMF07XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuLy8gR2l2ZW4gYSA2NC1ieXRlIHNpZ25hdHVyZSBbcixzXSB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIHYgdmFsdWVcbi8vIGFuZCBhdHRhaCB0aGUgZnVsbCBzaWduYXR1cmUgdG8gdGhlIGVuZCBvZiB0aGUgdHJhbnNhY3Rpb24gcGF5bG9hZFxudmFyIGJ1aWxkRXRoUmF3VHggPSBmdW5jdGlvbiAodHgsIHNpZywgYWRkcmVzcykge1xuICAgIC8vIFJMUC1lbmNvZGUgdGhlIGRhdGEgd2Ugc2VudCB0byB0aGUgbGF0dGljZVxuICAgIHZhciBoYXNoID0gQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGdldF9ybHBfZW5jb2RlZF9wcmVpbWFnZSh0eC5yYXdUeCwgdHgudHlwZSkpLCAnaGV4Jyk7XG4gICAgdmFyIG5ld1NpZyA9IGFkZFJlY292ZXJ5UGFyYW0oaGFzaCwgc2lnLCBhZGRyZXNzLCB0eCk7XG4gICAgLy8gVXNlIHRoZSBzaWduYXR1cmUgdG8gZ2VuZXJhdGUgYSBuZXcgcmF3IHRyYW5zYWN0aW9uIHBheWxvYWRcbiAgICAvLyBTdHJpcCB0aGUgbGFzdCAzIGl0ZW1zIGFuZCByZXBsYWNlIHRoZW0gd2l0aCBzaWduYXR1cmUgY29tcG9uZW50c1xuICAgIHZhciBuZXdSYXdUeCA9IHR4LnVzZUVJUDE1NSA/IHR4LnJhd1R4LnNsaWNlKDAsIC0zKSA6IHR4LnJhd1R4O1xuICAgIG5ld1Jhd1R4LnB1c2gobmV3U2lnLnYpO1xuICAgIC8vIFBlciBgZXRoZXJldW1qcy10eGAsIFJMUCBlbmNvZGluZyBzaG91bGQgaW5jbHVkZSBzaWduYXR1cmUgY29tcG9uZW50cyB3LyBzdHJpcHBlZCB6ZXJvc1xuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvZXRoZXJldW1qcy10eC9ibG9iL21hc3Rlci9zcmMvdHJhbnNhY3Rpb24udHMjTDE4N1xuICAgIG5ld1Jhd1R4LnB1c2goc3RyaXBaZXJvcyhuZXdTaWcucikpO1xuICAgIG5ld1Jhd1R4LnB1c2goc3RyaXBaZXJvcyhuZXdTaWcucykpO1xuICAgIHZhciBybHBFbmNvZGVkV2l0aFNpZyA9IEJ1ZmZlci5mcm9tKCgwLCBybHBfMS5lbmNvZGUpKG5ld1Jhd1R4KSk7XG4gICAgaWYgKHR4LnR5cGUpIHtcbiAgICAgICAgcmxwRW5jb2RlZFdpdGhTaWcgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFt0eC50eXBlXSksXG4gICAgICAgICAgICBybHBFbmNvZGVkV2l0aFNpZyxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiB7IHJhd1R4OiBybHBFbmNvZGVkV2l0aFNpZy50b1N0cmluZygnaGV4JyksIHNpZ1dpdGhWOiBuZXdTaWcgfTtcbn07XG4vLyBBdHRhY2ggYSByZWNvdmVyeSBwYXJhbWV0ZXIgdG8gYSBzaWduYXR1cmUgYnkgYnJ1dGUtZm9yY2luZyBFQ1JlY292ZXJcbmZ1bmN0aW9uIGFkZFJlY292ZXJ5UGFyYW0oaGFzaEJ1Ziwgc2lnLCBhZGRyZXNzLCB0eERhdGEpIHtcbiAgICBpZiAodHhEYXRhID09PSB2b2lkIDApIHsgdHhEYXRhID0ge307IH1cbiAgICB0cnkge1xuICAgICAgICAvLyBSZWJ1aWxkIHRoZSBrZWNjYWsyNTYgaGFzaCBoZXJlIHNvIHdlIGNhbiBgZWNyZWNvdmVyYFxuICAgICAgICB2YXIgaGFzaF8yID0gbmV3IFVpbnQ4QXJyYXkoaGFzaEJ1Zik7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgLy8gRml4IHNpZ25hdHVyZSBjb21wb25lbmV0IGxlbmd0aHMgdG8gMzIgYnl0ZXMgZWFjaFxuICAgICAgICB2YXIgciA9ICgwLCB1dGlsXzEuZml4TGVuKShzaWcuciwgMzIpO1xuICAgICAgICBzaWcuciA9IHI7XG4gICAgICAgIHZhciBzID0gKDAsIHV0aWxfMS5maXhMZW4pKHNpZy5zLCAzMik7XG4gICAgICAgIHNpZy5zID0gcztcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZWNvdmVyeSBwYXJhbVxuICAgICAgICB2YXIgcnMgPSBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KFtyLCBzXSkpO1xuICAgICAgICB2YXIgcHVia2V5ID0gc2VjcDI1NmsxXzEuZGVmYXVsdC5lY2RzYVJlY292ZXIocnMsIHYsIGhhc2hfMiwgZmFsc2UpLnNsaWNlKDEpO1xuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgYHZgIHZhbHVlIGlzIGEgbWF0Y2gsIHJldHVybiB0aGUgc2lnIVxuICAgICAgICBpZiAocHViVG9BZGRyU3RyKHB1YmtleSkgPT09IGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICAgICAgICBzaWcudiA9IGdldFJlY292ZXJ5UGFyYW0odiwgdHhEYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cnkgdGhlIG90aGVyIGB2YCB2YWx1ZVxuICAgICAgICB2ID0gMTtcbiAgICAgICAgcHVia2V5ID0gc2VjcDI1NmsxXzEuZGVmYXVsdC5lY2RzYVJlY292ZXIocnMsIHYsIGhhc2hfMiwgZmFsc2UpLnNsaWNlKDEpO1xuICAgICAgICBpZiAocHViVG9BZGRyU3RyKHB1YmtleSkgPT09IGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICAgICAgICBzaWcudiA9IGdldFJlY292ZXJ5UGFyYW0odiwgdHhEYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBuZWl0aGVyIGlzIGEgbWF0Y2gsIHdlIHNob3VsZCByZXR1cm4gYW4gZXJyb3JcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFdGhlcmV1bSBzaWduYXR1cmUgcmV0dXJuZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0IGFuIFJMUC1zZXJpYWxpemVkIHRyYW5zYWN0aW9uIChwbHVzIHNpZ25hdHVyZSkgaW50byBhIHRyYW5zYWN0aW9uIGhhc2hcbnZhciBoYXNoVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoc2VyaWFsaXplZFR4KSB7XG4gICAgcmV0dXJuICgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShCdWZmZXIuZnJvbShzZXJpYWxpemVkVHgsICdoZXgnKSk7XG59O1xuLy8gUmV0dXJucyBhZGRyZXNzIHN0cmluZyBnaXZlbiBwdWJsaWMga2V5IGJ1ZmZlclxuZnVuY3Rpb24gcHViVG9BZGRyU3RyKHB1Yikge1xuICAgIHJldHVybiAoMCwganNfc2hhM18xLmtlY2NhazI1NikocHViKS5zbGljZSgtNDApO1xufVxuLy8gQ29udmVydCBhIDAvMSBgdmAgaW50byBhIHJlY292ZXJ5IHBhcmFtOlxuLy8gKiBGb3Igbm9uLUVJUDE1NSB0cmFuc2FjdGlvbnMsIHJldHVybiBgMjcgKyB2YFxuLy8gKiBGb3IgRUlQMTU1IHRyYW5zYWN0aW9ucywgcmV0dXJuIGAoQ0hBSU5fSUQqMikgKyAzNSArIHZgXG5mdW5jdGlvbiBnZXRSZWNvdmVyeVBhcmFtKHYsIHR4RGF0YSkge1xuICAgIGlmICh0eERhdGEgPT09IHZvaWQgMCkgeyB0eERhdGEgPSB7fTsgfVxuICAgIHZhciBjaGFpbklkID0gdHhEYXRhLmNoYWluSWQsIHVzZUVJUDE1NSA9IHR4RGF0YS51c2VFSVAxNTUsIHR5cGUgPSB0eERhdGEudHlwZTtcbiAgICAvLyBGb3IgRUlQMTU1OSBhbmQgRUlQMjkzMCB0cmFuc2FjdGlvbnMsIHdlIHdhbnQgdGhlIHJlY292ZXJ5UGFyYW0gKDAgb3IgMSlcbiAgICAvLyByYXRoZXIgdGhhbiB0aGUgYHZgIHZhbHVlIGJlY2F1c2UgdGhlIGBjaGFpbklkYCBpcyBhbHJlYWR5IGluY2x1ZGVkIGluIHRoZVxuICAgIC8vIHRyYW5zYWN0aW9uIHBheWxvYWQuXG4gICAgaWYgKHR5cGUgPT09IDEgfHwgdHlwZSA9PT0gMikge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKHYsIHRydWUpOyAvLyAwIG9yIDEsIHdpdGggMCBleHBlY3RlZCBhcyBhbiBlbXB0eSBidWZmZXJcbiAgICB9XG4gICAgZWxzZSBpZiAoZmFsc2UgPT09IHVzZUVJUDE1NSB8fCBjaGFpbklkID09PSBudWxsKSB7XG4gICAgICAgIC8vIEZvciBFVEggbWVzc2FnZXMgYW5kIG5vbi1FSVAxNTUgY2hhaW5zIHRoZSBzZXQgc2hvdWxkIGJlIFsyNywgMjhdIGZvciBgdmBcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHYpLnBsdXMoMjcpLnRvU3RyaW5nKDE2KSwgJ2hleCcpO1xuICAgIH1cbiAgICAvLyBXZSB3aWxsIHVzZSBFSVAxNTUgaW4gbW9zdCBjYXNlcy4gQ29udmVydCB2IHRvIGEgYmlnbnVtIGFuZCBvcGVyYXRlIG9uIGl0LlxuICAgIC8vIE5vdGUgdGhhdCB0aGUgcHJvdG9jb2wgY2FsbHMgZm9yIHYgPSAoQ0hBSU5fSUQqMikgKyAzNS8zNiwgd2hlcmUgMzUgb3IgMzZcbiAgICAvLyBpcyBkZWNpZGVkIG9uIGJhc2VkIG9uIHRoZSBlY3JlY292ZXIgcmVzdWx0LiBgdmAgaXMgcGFzc2VkIGluIGFzIGVpdGhlciAwIG9yIDFcbiAgICAvLyBzbyB3ZSBhZGQgMzUgdG8gdGhhdC5cbiAgICB2YXIgY2hhaW5JZEJ1ZiA9IGdldENoYWluSWRCdWYoY2hhaW5JZCk7XG4gICAgdmFyIGNoYWluSWRCTiA9IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGNoYWluSWRCdWYudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShcIjB4XCIuY29uY2F0KGNoYWluSWRCTi50aW1lcygyKS5wbHVzKDM1KS5wbHVzKHYpLnRvU3RyaW5nKDE2KSkpO1xufVxudmFyIGNoYWluSWRzID0ge1xuICAgIG1haW5uZXQ6IDEsXG4gICAgcm9wdHN0ZW46IDMsXG4gICAgcmlua2VieTogNCxcbiAgICBrb3ZhbjogNDIsXG4gICAgZ29lcmxpOiA1LFxufTtcbi8vIEdldCBhIGJ1ZmZlciBjb250YWluaW5nIHRoZSBjaGFpbklkIHZhbHVlLlxuLy8gUmV0dXJucyBhIDEsIDIsIDQsIG9yIDggYnl0ZSBidWZmZXIgd2l0aCB0aGUgY2hhaW5JZCBlbmNvZGVkIGluIGJpZyBlbmRpYW5cbmZ1bmN0aW9uIGdldENoYWluSWRCdWYoY2hhaW5JZCkge1xuICAgIHZhciBiO1xuICAgIC8vIElmIG91ciBjaGFpbklEIGlzIGEgaGV4IHN0cmluZywgd2UgY2FuIGNvbnZlcnQgaXQgdG8gYSBoZXhcbiAgICAvLyBidWZmZXIgZGlyZWN0bHlcbiAgICBpZiAodHJ1ZSA9PT0gaXNWYWxpZENoYWluSWRIZXhOdW1TdHIoY2hhaW5JZCkpXG4gICAgICAgIGIgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoY2hhaW5JZCk7XG4gICAgLy8gSWYgb3VyIGNoYWluSUQgaXMgYSBiYXNlLTEwIG51bWJlciwgcGFyc2Ugd2l0aCBiaWdudW1iZXIuanMgYW5kIGNvbnZlcnQgdG8gaGV4IGJ1ZmZlclxuICAgIGVsc2VcbiAgICAgICAgYiA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShcIjB4XCIuY29uY2F0KG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGNoYWluSWQpLnRvU3RyaW5nKDE2KSkpO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGlzIGFuIGFsbG93ZWQgc2l6ZVxuICAgIGlmIChiLmxlbmd0aCA+IDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhaW5JRCBwcm92aWRlZCBpcyB0b28gbGFyZ2UuJyk7XG4gICAgLy8gSWYgdGhpcyBtYXRjaGVzIGEgdTE2LCB1MzIsIG9yIHU2NCBzaXplLCByZXR1cm4gaXQgbm93XG4gICAgaWYgKGIubGVuZ3RoIDw9IDIgfHwgYi5sZW5ndGggPT09IDQgfHwgYi5sZW5ndGggPT09IDgpXG4gICAgICAgIHJldHVybiBiO1xuICAgIC8vIEZvciBvdGhlciBzaXplIGJ1ZmZlcnMsIHdlIG5lZWQgdG8gcGFjayBpbnRvIHUzMiBvciB1NjQgYmVmb3JlIHJldHVybmluZztcbiAgICB2YXIgYnVmO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBidWYgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGNoYWluSWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChiLmxlbmd0aCA8PSA4KSB7XG4gICAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICAgICAgYi5jb3B5KGJ1ZiwgOCAtIGIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbi8vIERldGVybWluZSBpZiB0aGUgY2hhaW4gdXNlcyBFSVAxNTUgYnkgZGVmYXVsdCwgYmFzZWQgb24gdGhlIGNoYWluSURcbmZ1bmN0aW9uIGNoYWluVXNlc0VJUDE1NShjaGFpbklEKSB7XG4gICAgc3dpdGNoIChjaGFpbklEKSB7XG4gICAgICAgIGNhc2UgMzogLy8gcm9wc3RlblxuICAgICAgICBjYXNlIDQ6IC8vIHJpbmtlYnlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAxOiAvLyBtYWlubmV0XG4gICAgICAgIGNhc2UgNDI6IC8vIGtvdmFuXG4gICAgICAgIGNhc2UgNTogLy8gZ29lcmxpXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBhbGwgb3RoZXJzIHNob3VsZCB1c2UgZWlwMTU1XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyBEZXRlcm1pbmUgaWYgYSB2YWxpZCBudW1iZXIgd2FzIHBhc3NlZCBpbiBhcyBhIGhleCBzdHJpbmdcbmZ1bmN0aW9uIGlzVmFsaWRDaGFpbklkSGV4TnVtU3RyKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHMuc2xpY2UoMCwgMikgIT09ICcweCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgYiA9IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHMsIDE2KTtcbiAgICAgICAgcmV0dXJuIGIuaXNOYU4oKSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIElmIHRoaXMgaXMgYSBudWJtZXIgdGhhdCBmaXRzIGluIG9uZSBieXRlLCB3ZSBkb24ndCBuZWVkIHRvIGFkZCBpdFxuLy8gdG8gdGhlIGBkYXRhYCBidWZmZXIgb2YgdGhlIG1haW4gdHJhbnNhY3Rpb24uXG4vLyBOb3RlIHRoZSBvbmUgZWRnZSBjYXNlOiB3ZSBzdGlsbCBuZWVkIHRvIHVzZSB0aGUgYGRhdGFgIGZpZWxkIGZvciBjaGFpbklEPTI1NS5cbmZ1bmN0aW9uIHVzZUNoYWluSWRCdWZmZXIoaWQpIHtcbiAgICB2YXIgYnVmID0gZ2V0Q2hhaW5JZEJ1ZihpZCk7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQ4KDApID09PSAyNTU7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBidWlsZFBlcnNvbmFsU2lnblJlcXVlc3QocmVxLCBpbnB1dCkge1xuICAgIHZhciBNQVhfQkFTRV9NU0dfU1ogPSBpbnB1dC5md0NvbnN0YW50cy5ldGhNYXhNc2dTejtcbiAgICB2YXIgVkFSX1BBVEhfU1ogPSBpbnB1dC5md0NvbnN0YW50cy52YXJBZGRyUGF0aFN6QWxsb3dlZDtcbiAgICB2YXIgTCA9IDI0ICsgTUFYX0JBU0VfTVNHX1NaICsgNDtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICByZXEucGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhMKTtcbiAgICByZXEucGF5bG9hZC53cml0ZVVJbnQ4KGNvbnN0YW50c18xLmV0aE1zZ1Byb3RvY29sLlNJR05fUEVSU09OQUwsIDApO1xuICAgIG9mZiArPSAxO1xuICAgIC8vIFdyaXRlIHRoZSBzaWduZXIgcGF0aCBpbnRvIHRoZSBidWZmZXJcbiAgICB2YXIgc2lnbmVyUGF0aEJ1ZiA9ICgwLCB1dGlsXzEuYnVpbGRTaWduZXJQYXRoQnVmKShpbnB1dC5zaWduZXJQYXRoLCBWQVJfUEFUSF9TWik7XG4gICAgc2lnbmVyUGF0aEJ1Zi5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgIG9mZiArPSBzaWduZXJQYXRoQnVmLmxlbmd0aDtcbiAgICAvLyBXcml0ZSB0aGUgcGF5bG9hZCBidWZmZXIuIFRoZSBwYXlsb2FkIGNhbiBjb21lIGluIGVpdGhlciBhcyBhIGJ1ZmZlciBvciBhcyBhIHN0cmluZ1xuICAgIHZhciBwYXlsb2FkID0gaW5wdXQucGF5bG9hZDtcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIGhleCBzdHJpbmdcbiAgICB2YXIgZGlzcGxheUhleCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgaW5wdXQucGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlucHV0LnBheWxvYWQuc2xpY2UoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoaW5wdXQucGF5bG9hZCk7XG4gICAgICAgICAgICBkaXNwbGF5SGV4ID1cbiAgICAgICAgICAgICAgICBmYWxzZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuQVNDSUlfUkVHRVgudGVzdChCdWZmZXIuZnJvbShpbnB1dC5wYXlsb2FkLnNsaWNlKDIpLCAnaGV4JykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmFsc2UgPT09ICgwLCB1dGlsXzEuaXNBc2NpaVN0cikoaW5wdXQucGF5bG9hZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHksIHRoZSBMYXR0aWNlIGNhbiBvbmx5IGRpc3BsYXkgQVNDSUkgc3RyaW5ncy4nKTtcbiAgICAgICAgICAgIHBheWxvYWQgPSBCdWZmZXIuZnJvbShpbnB1dC5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQuZGlzcGxheUhleCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBidWZmZXIgYW5kIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgd2hldGhlciBvciBub3QgdGhpc1xuICAgICAgICAvLyBpcyBhIGhleCBidWZmZXIgd2l0aCB0aGUgb3B0aW9uYWwgYXJndW1lbnQsIHdyaXRlIHRoYXRcbiAgICAgICAgZGlzcGxheUhleCA9IGlucHV0LmRpc3BsYXlIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGRldGVybWluZSBpZiB0aGlzIGJ1ZmZlciBpcyBhbiBBU0NJSSBzdHJpbmcuIElmIGl0IGlzLCBzZXQgYGRpc3BsYXlIZXhgIGFjY29yZGluZ2x5LlxuICAgICAgICAvLyBOT1RFOiBUSElTIE1FQU5TIFRIQVQgTk9OLUFTQ0lJIFNUUklOR1MgV0lMTCBESVNQTEFZIEFTIEhFWCBTSU5DRSBXRSBDQU5OT1QgS05PVyBJRiBUSEUgUkVRVUVTVEVSXG4gICAgICAgIC8vICAgICAgICBFWFBFQ1RFRCBOT04tQVNDSUkgQ0hBUkFDVEVSUyBUTyBESVNQTEFZIElOIEEgU1RSSU5HXG4gICAgICAgIC8vIFRPRE86IERldmVsb3AgYSBtb3JlIGVsZWdhbnQgc29sdXRpb24gZm9yIHRoaXNcbiAgICAgICAgaWYgKCFpbnB1dC5wYXlsb2FkLnRvU3RyaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBpbnB1dCBkYXRhIHR5cGUnKTtcbiAgICAgICAgZGlzcGxheUhleCA9IGZhbHNlID09PSBjb25zdGFudHNfMS5BU0NJSV9SRUdFWC50ZXN0KGlucHV0LnBheWxvYWQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHZhciBmd0NvbnN0ID0gaW5wdXQuZndDb25zdGFudHM7XG4gICAgdmFyIG1heFN6QWxsb3dlZCA9IE1BWF9CQVNFX01TR19TWiArIGZ3Q29uc3QuZXh0cmFEYXRhTWF4RnJhbWVzICogZndDb25zdC5leHRyYURhdGFGcmFtZVN6O1xuICAgIGlmIChmd0NvbnN0LnBlcnNvbmFsU2lnbkhlYWRlclN6KSB7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHRoZSBwZXJzb25hbF9zaWduIGhlYWRlciBzdHJpbmdcbiAgICAgICAgbWF4U3pBbGxvd2VkIC09IGZ3Q29uc3QucGVyc29uYWxTaWduSGVhZGVyU3o7XG4gICAgfVxuICAgIGlmIChmd0NvbnN0LmV0aE1zZ1ByZUhhc2hBbGxvd2VkICYmIHBheWxvYWQubGVuZ3RoID4gbWF4U3pBbGxvd2VkKSB7XG4gICAgICAgIC8vIElmIHRoaXMgbWVzc2FnZSB3aWxsIG5vdCBmaXQgYW5kIHByZS1oYXNoaW5nIGlzIGFsbG93ZWQsIGRvIHRoYXRcbiAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50OChkaXNwbGF5SGV4LCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50MTZMRShwYXlsb2FkLmxlbmd0aCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIHZhciBwcmVoYXNoID0gQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKEJ1ZmZlci5jb25jYXQoW2dldF9wZXJzb25hbF9zaWduX3ByZWZpeChwYXlsb2FkLmxlbmd0aCksIHBheWxvYWRdKSksICdoZXgnKTtcbiAgICAgICAgcHJlaGFzaC5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgICAgICByZXEucHJlaGFzaCA9IHByZWhhc2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY2FuIGZpdCB0aGUgcGF5bG9hZC5cbiAgICAgICAgLy8gRmxvdyBkYXRhIGludG8gZXh0cmFEYXRhIHJlcXVlc3RzLCB3aGljaCB3aWxsIGZvbGxvdy11cCB0cmFuc2FjdGlvbiByZXF1ZXN0cywgaWYgc3VwcG9ydGVkL2FwcGxpY2FibGVcbiAgICAgICAgdmFyIGV4dHJhRGF0YVBheWxvYWRzID0gZ2V0RXh0cmFEYXRhKHBheWxvYWQsIGlucHV0KTtcbiAgICAgICAgLy8gV3JpdGUgdGhlIHBheWxvYWQgYW5kIG1ldGFkYXRhIGludG8gb3VyIGJ1ZmZlclxuICAgICAgICByZXEuZXh0cmFEYXRhUGF5bG9hZHMgPSBleHRyYURhdGFQYXlsb2FkcztcbiAgICAgICAgcmVxLm1zZyA9IHBheWxvYWQ7XG4gICAgICAgIHJlcS5wYXlsb2FkLndyaXRlVUludDgoZGlzcGxheUhleCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgIHJlcS5wYXlsb2FkLndyaXRlVUludDE2TEUocGF5bG9hZC5sZW5ndGgsIG9mZik7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBwYXlsb2FkLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG59XG5mdW5jdGlvbiBidWlsZEVJUDcxMlJlcXVlc3QocmVxLCBpbnB1dCkge1xuICAgIHZhciBfYSA9IGlucHV0LmZ3Q29uc3RhbnRzLCBldGhNYXhNc2dTeiA9IF9hLmV0aE1heE1zZ1N6LCB2YXJBZGRyUGF0aFN6QWxsb3dlZCA9IF9hLnZhckFkZHJQYXRoU3pBbGxvd2VkLCBlaXA3MTJNYXhUeXBlUGFyYW1zID0gX2EuZWlwNzEyTWF4VHlwZVBhcmFtcztcbiAgICB2YXIgVFlQRURfREFUQSA9IGNvbnN0YW50c18xLmV0aE1zZ1Byb3RvY29sLlRZUEVEX0RBVEE7XG4gICAgdmFyIEwgPSAyNCArIGV0aE1heE1zZ1N6ICsgNDtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICByZXEucGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhMKTtcbiAgICByZXEucGF5bG9hZC53cml0ZVVJbnQ4KFRZUEVEX0RBVEEuZW51bUlkeCwgMCk7XG4gICAgb2ZmICs9IDE7XG4gICAgLy8gV3JpdGUgdGhlIHNpZ25lciBwYXRoXG4gICAgdmFyIHNpZ25lclBhdGhCdWYgPSAoMCwgdXRpbF8xLmJ1aWxkU2lnbmVyUGF0aEJ1ZikoaW5wdXQuc2lnbmVyUGF0aCwgdmFyQWRkclBhdGhTekFsbG93ZWQpO1xuICAgIHNpZ25lclBhdGhCdWYuY29weShyZXEucGF5bG9hZCwgb2ZmKTtcbiAgICBvZmYgKz0gc2lnbmVyUGF0aEJ1Zi5sZW5ndGg7XG4gICAgLy8gUGFyc2UvY2xlYW4gdGhlIEVJUDcxMiBwYXlsb2FkLCBzZXJpYWxpemUgd2l0aCBDQk9SLCBhbmQgd3JpdGUgdG8gdGhlIHBheWxvYWRcbiAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXQucGF5bG9hZCkpO1xuICAgIGlmICghZGF0YS5wcmltYXJ5VHlwZSB8fCAhZGF0YS50eXBlc1tkYXRhLnByaW1hcnlUeXBlXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmltYXJ5VHlwZSBtdXN0IGJlIHNwZWNpZmllZCBhbmQgdGhlIHR5cGUgbXVzdCBiZSBpbmNsdWRlZC4nKTtcbiAgICBpZiAoIWRhdGEubWVzc2FnZSB8fCAhZGF0YS5kb21haW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSBhbmQgZG9tYWluIG11c3QgYmUgc3BlY2lmaWVkLicpO1xuICAgIGlmICgwID4gT2JqZWN0LmtleXMoZGF0YS50eXBlcykuaW5kZXhPZignRUlQNzEyRG9tYWluJykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQNzEyRG9tYWluIHR5cGUgbXVzdCBiZSBkZWZpbmVkLicpO1xuICAgIC8vIFBhcnNlIHRoZSBwYXlsb2FkIHRvIGVuc3VyZSB3ZSBoYXZlIHZhbGlkIEVJUDcxMiBkYXRhIHR5cGVzIGFuZCB0aGF0XG4gICAgLy8gdGhleSBhcmUgZW5jb2RlZCBzdWNoIHRoYXQgTGF0dGljZSBmaXJtd2FyZSBjYW4gcGFyc2UgdGhlbS5cbiAgICAvLyBXZSBuZWVkIHR3byBkaWZmZXJlbnQgZW5jb2RpbmdzOiBvbmUgdG8gc2VuZCB0byB0aGUgTGF0dGljZSBpbiBhIGZvcm1hdCB0aGF0IHBsYXlzXG4gICAgLy8gbmljZWx5IHdpdGggb3VyIGZpcm13YXJlIENCT1IgZGVjb2Rlci4gVGhlIG90aGVyIGlzIGZvcm1hdHRlZCB0byBiZSBjb25zdW1hYmxlIGJ5XG4gICAgLy8gb3VyIEVJUDcxMiB2YWxpZGF0aW9uIG1vZHVsZS5cbiAgICBpbnB1dC5wYXlsb2FkLm1lc3NhZ2UgPSBwYXJzZUVJUDcxMk1zZyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEubWVzc2FnZSkpLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEucHJpbWFyeVR5cGUpKSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLnR5cGVzKSksIHRydWUpO1xuICAgIGlucHV0LnBheWxvYWQuZG9tYWluID0gcGFyc2VFSVA3MTJNc2coSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLmRvbWFpbikpLCAnRUlQNzEyRG9tYWluJywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLnR5cGVzKSksIHRydWUpO1xuICAgIGRhdGEuZG9tYWluID0gcGFyc2VFSVA3MTJNc2coZGF0YS5kb21haW4sICdFSVA3MTJEb21haW4nLCBkYXRhLnR5cGVzLCBmYWxzZSk7XG4gICAgZGF0YS5tZXNzYWdlID0gcGFyc2VFSVA3MTJNc2coZGF0YS5tZXNzYWdlLCBkYXRhLnByaW1hcnlUeXBlLCBkYXRhLnR5cGVzLCBmYWxzZSk7XG4gICAgLy8gTm93IGJ1aWxkIHRoZSBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gdGhlIExhdHRpY2VcbiAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5mcm9tKGJvcmNfMS5kZWZhdWx0LmVuY29kZShkYXRhKSk7XG4gICAgdmFyIGZ3Q29uc3QgPSBpbnB1dC5md0NvbnN0YW50cztcbiAgICB2YXIgbWF4U3pBbGxvd2VkID0gZXRoTWF4TXNnU3ogKyBmd0NvbnN0LmV4dHJhRGF0YU1heEZyYW1lcyAqIGZ3Q29uc3QuZXh0cmFEYXRhRnJhbWVTejtcbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBwcmVoYXNoXG4gICAgdmFyIHNob3VsZFByZWhhc2ggPSBwYXlsb2FkLmxlbmd0aCA+IG1heFN6QWxsb3dlZDtcbiAgICBPYmplY3Qua2V5cyhkYXRhLnR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChkYXRhLnR5cGVzW2tdLmxlbmd0aCA+IGVpcDcxMk1heFR5cGVQYXJhbXMpIHtcbiAgICAgICAgICAgIHNob3VsZFByZWhhc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZ3Q29uc3QuZXRoTXNnUHJlSGFzaEFsbG93ZWQgJiYgc2hvdWxkUHJlaGFzaCkge1xuICAgICAgICAvLyBJZiB0aGlzIHBheWxvYWQgaXMgdG9vIGxhcmdlIHRvIHNlbmQsIGJ1dCB0aGUgTGF0dGljZSBhbGxvd3MgYSBwcmVoYXNoZWQgbWVzc2FnZSwgZG8gdGhhdFxuICAgICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQxNkxFKHBheWxvYWQubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgdmFyIHByZWhhc2ggPSBldGhfZWlwNzEyX3V0aWxfYnJvd3Nlcl8xLlR5cGVkRGF0YVV0aWxzLmhhc2gocmVxLmlucHV0LnBheWxvYWQpO1xuICAgICAgICB2YXIgcHJlaGFzaEJ1ZiA9IEJ1ZmZlci5mcm9tKHByZWhhc2gpO1xuICAgICAgICBwcmVoYXNoQnVmLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gICAgICAgIHJlcS5wcmVoYXNoID0gcHJlaGFzaDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBleHRyYURhdGFQYXlsb2FkcyA9IGdldEV4dHJhRGF0YShwYXlsb2FkLCBpbnB1dCk7XG4gICAgICAgIHJlcS5leHRyYURhdGFQYXlsb2FkcyA9IGV4dHJhRGF0YVBheWxvYWRzO1xuICAgICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQxNkxFKHBheWxvYWQubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgcGF5bG9hZC5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgICAgICBvZmYgKz0gcGF5bG9hZC5sZW5ndGg7XG4gICAgICAgIC8vIFNsaWNlIG91dCB0aGUgcGFydCBvZiB0aGUgYnVmZmVyIHRoYXQgd2UgZGlkbid0IHVzZS5cbiAgICAgICAgcmVxLnBheWxvYWQgPSByZXEucGF5bG9hZC5zbGljZSgwLCBvZmYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xufVxuZnVuY3Rpb24gZ2V0RXh0cmFEYXRhKHBheWxvYWQsIGlucHV0KSB7XG4gICAgdmFyIF9hID0gaW5wdXQuZndDb25zdGFudHMsIGV0aE1heE1zZ1N6ID0gX2EuZXRoTWF4TXNnU3osIGV4dHJhRGF0YUZyYW1lU3ogPSBfYS5leHRyYURhdGFGcmFtZVN6LCBleHRyYURhdGFNYXhGcmFtZXMgPSBfYS5leHRyYURhdGFNYXhGcmFtZXM7XG4gICAgdmFyIE1BWF9CQVNFX01TR19TWiA9IGV0aE1heE1zZ1N6O1xuICAgIHZhciBFWFRSQV9EQVRBX0FMTE9XRUQgPSBleHRyYURhdGFGcmFtZVN6ID4gMCAmJiBleHRyYURhdGFNYXhGcmFtZXMgPiAwO1xuICAgIHZhciBleHRyYURhdGFQYXlsb2FkcyA9IFtdO1xuICAgIGlmIChwYXlsb2FkLmxlbmd0aCA+IE1BWF9CQVNFX01TR19TWikge1xuICAgICAgICAvLyBEZXRlcm1pbmUgc2l6ZXMgYW5kIHJ1biB0aHJvdWdoIHNhbml0eSBjaGVja3NcbiAgICAgICAgdmFyIG1heFN6QWxsb3dlZCA9IE1BWF9CQVNFX01TR19TWiArIGV4dHJhRGF0YU1heEZyYW1lcyAqIGV4dHJhRGF0YUZyYW1lU3o7XG4gICAgICAgIGlmICghRVhUUkFfREFUQV9BTExPV0VEKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBtZXNzYWdlIGlzIFwiLmNvbmNhdChwYXlsb2FkLmxlbmd0aCwgXCIgYnl0ZXMsIGJ1dCBjYW4gb25seSBiZSBhIG1heGltdW0gb2YgXCIpLmNvbmNhdChNQVhfQkFTRV9NU0dfU1opKTtcbiAgICAgICAgZWxzZSBpZiAoRVhUUkFfREFUQV9BTExPV0VEICYmIHBheWxvYWQubGVuZ3RoID4gbWF4U3pBbGxvd2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBtZXNzYWdlIGlzIFwiLmNvbmNhdChwYXlsb2FkLmxlbmd0aCwgXCIgYnl0ZXMsIGJ1dCBjYW4gb25seSBiZSBhIG1heGltdW0gb2YgXCIpLmNvbmNhdChtYXhTekFsbG93ZWQpKTtcbiAgICAgICAgLy8gU3BsaXQgb3ZlcmZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSBmcmFtZXNcbiAgICAgICAgdmFyIGZyYW1lc18yID0gKDAsIHV0aWxfMS5zcGxpdEZyYW1lcykocGF5bG9hZC5zbGljZShNQVhfQkFTRV9NU0dfU1opLCBleHRyYURhdGFGcmFtZVN6KTtcbiAgICAgICAgZnJhbWVzXzIuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBzekxFID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgICAgc3pMRS53cml0ZVVJbnQzMkxFKGZyYW1lLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICBleHRyYURhdGFQYXlsb2Fkcy5wdXNoKEJ1ZmZlci5jb25jYXQoW3N6TEUsIGZyYW1lXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhRGF0YVBheWxvYWRzO1xufVxuZnVuY3Rpb24gcGFyc2VFSVA3MTJNc2cobXNnLCB0eXBlTmFtZSwgdHlwZXMsIGZvckpTUGFyc2VyKSB7XG4gICAgaWYgKGZvckpTUGFyc2VyID09PSB2b2lkIDApIHsgZm9ySlNQYXJzZXIgPSBmYWxzZTsgfVxuICAgIHZhciB0eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgIHR5cGUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaXNBcnJheVR5cGUgPSBpdGVtLnR5cGUuaW5kZXhPZignWycpID4gLTE7XG4gICAgICAgIHZhciBzaW5ndWxhclR5cGUgPSBpc0FycmF5VHlwZVxuICAgICAgICAgICAgPyBpdGVtLnR5cGUuc2xpY2UoMCwgaXRlbS50eXBlLmluZGV4T2YoJ1snKSlcbiAgICAgICAgICAgIDogaXRlbS50eXBlO1xuICAgICAgICB2YXIgaXNDdXN0b21UeXBlID0gT2JqZWN0LmtleXModHlwZXMpLmluZGV4T2Yoc2luZ3VsYXJUeXBlKSA+IC0xO1xuICAgICAgICBpZiAoaXNDdXN0b21UeXBlICYmIEFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgICAgICAgICAgLy8gRm9yIGN1c3RvbSB0eXBlcyB3ZSBuZWVkIHRvIGp1bXAgaW50byB0aGUgYG1zZ2AgdXNpbmcgdGhlIGtleSAobmFtZSBvZiB0eXBlKSBhbmRcbiAgICAgICAgICAgIC8vIHBhcnNlIHRoYXQgZW50aXJlIHN1Yi1zdHJ1Y3QgYXMgaWYgaXQgd2VyZSBhIG1lc3NhZ2UuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHJlY3Vyc2UgaW50byBzdWItc3RydWN0cyB1bnRpbCB3ZSByZWFjaCBhIGxldmVsIHdoZXJlIGV2ZXJ5IGl0ZW0gaXMgYW5cbiAgICAgICAgICAgIC8vIGVsZW1lbnRhcnkgKGkuZS4gbm9uLWN1c3RvbSkgdHlwZS5cbiAgICAgICAgICAgIC8vIEZvciBhcnJheXMsIHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGVhY2ggbWVzc2FnZSBpdGVtLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtc2dbaV1baXRlbS5uYW1lXSA9IHBhcnNlRUlQNzEyTXNnKG1zZ1tpXVtpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIHR5cGVzLCBmb3JKU1BhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDdXN0b21UeXBlKSB7XG4gICAgICAgICAgICAvLyBOb3QgYW4gYXJyYXkgbWVhbnMgd2UgY2FuIGp1bXAgZGlyZWN0bHkgaW50byB0aGUgc3ViLXN0cnVjdCB0byBjb252ZXJ0XG4gICAgICAgICAgICBtc2dbaXRlbS5uYW1lXSA9IHBhcnNlRUlQNzEyTXNnKG1zZ1tpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIHR5cGVzLCBmb3JKU1BhcnNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtc2cpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFycmF5IGZvciB0aGlzIHBhcnRpY3VsYXIgdHlwZSBhbmQgdGhlIHR5cGUgd2UgYXJlIHBhcnNpbmdcbiAgICAgICAgICAgIC8vIGlzICpub3QqIGEgY3VzdG9tIHR5cGUsIGxvb3AgdGhyb3VnaCB0aGUgYXJyYXkgZWxlbWVudHMgYW5kIGNvbnZlcnQgdGhlIHR5cGVzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyB0eXBlIGlzIGl0c2VsZiBhbiBhcnJheSwgbG9vcCB0aHJvdWdoIHRob3NlIGVsZW1lbnRzIGFuZCBwYXJzZSBpbmRpdmlkdWFsbHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSBpcyBub3QgcmVhY2hhYmxlIGZvciBjdXN0b20gdHlwZXMgc28gd2UgYXNzdW1lIHRoZXNlIGFyZSBhcnJheXMgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudGFyeSB0eXBlcy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtc2dbaV1baXRlbS5uYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ldW2l0ZW0ubmFtZV1bal0gPSBwYXJzZUVJUDcxMkl0ZW0obXNnW2ldW2l0ZW0ubmFtZV1bal0sIHNpbmd1bGFyVHlwZSwgZm9ySlNQYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb24tYXJyYXlzIHBhcnNlICsgcmVwbGFjZSBvbmUgdmFsdWUgZm9yIHRoZSBlbGVtZW50YXJ5IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgbXNnW2ldW2l0ZW0ubmFtZV0gPSBwYXJzZUVJUDcxMkl0ZW0obXNnW2ldW2l0ZW0ubmFtZV0sIHNpbmd1bGFyVHlwZSwgZm9ySlNQYXJzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FycmF5VHlwZSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBlbGVtZW50YXJ5IGFycmF5IHR5cGUgYW5kIGEgbm9uLWFycmF5IG1lc3NhZ2UgbGV2ZWwsXG4gICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCB0aGUgYXJyYXkgYW5kIHBhcnNlICsgcmVwbGFjZSAgZWFjaCBpdGVtIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnW2l0ZW0ubmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtc2dbaXRlbS5uYW1lXVtpXSA9IHBhcnNlRUlQNzEySXRlbShtc2dbaXRlbS5uYW1lXVtpXSwgc2luZ3VsYXJUeXBlLCBmb3JKU1BhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc2luZ3VsYXIgZWxlbWVudGFyeSB0eXBlLCBzaW1wbHkgcGFyc2UgKyByZXBsYWNlLlxuICAgICAgICAgICAgbXNnW2l0ZW0ubmFtZV0gPSBwYXJzZUVJUDcxMkl0ZW0obXNnW2l0ZW0ubmFtZV0sIHNpbmd1bGFyVHlwZSwgZm9ySlNQYXJzZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1zZztcbn1cbmZ1bmN0aW9uIHBhcnNlRUlQNzEySXRlbShkYXRhLCB0eXBlLCBmb3JKU1BhcnNlcikge1xuICAgIGlmIChmb3JKU1BhcnNlciA9PT0gdm9pZCAwKSB7IGZvckpTUGFyc2VyID0gZmFsc2U7IH1cbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAvLyBWYXJpYWJsZSBzaXplZCBieXRlcyBuZWVkIHRvIGJlIGJ1ZmZlciB0eXBlXG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YSk7XG4gICAgICAgIGlmIChmb3JKU1BhcnNlcikge1xuICAgICAgICAgICAgLy8gRm9yIEVJUDcxMiBlbmNvZGluZyBtb2R1bGUgaXQncyBlYXNpZXIgdG8gZW5jb2RlIGhleCBzdHJpbmdzXG4gICAgICAgICAgICBkYXRhID0gXCIweFwiLmNvbmNhdChkYXRhLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zbGljZSgwLCA1KSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAvLyBGaXhlZCBzaXplcyBieXRlcyBuZWVkIHRvIGJlIGJ1ZmZlciB0eXBlLiBXZSBhbHNvIGFkZCBzb21lIHNhbml0eSBjaGVja3MuXG4gICAgICAgIHZhciBuQnl0ZXMgPSBwYXJzZUludCh0eXBlLnNsaWNlKDUpKTtcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBuQnl0ZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQodHlwZSwgXCIgdHlwZSwgYnV0IGdvdCBcIikuY29uY2F0KGRhdGEubGVuZ3RoLCBcIiBieXRlc1wiKSk7XG4gICAgICAgIGlmIChmb3JKU1BhcnNlcikge1xuICAgICAgICAgICAgLy8gRm9yIEVJUDcxMiBlbmNvZGluZyBtb2R1bGUgaXQncyBlYXNpZXIgdG8gZW5jb2RlIGhleCBzdHJpbmdzXG4gICAgICAgICAgICBkYXRhID0gXCIweFwiLmNvbmNhdChkYXRhLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIC8vIEFkZHJlc3MgbXVzdCBiZSBhIDIwIGJ5dGUgYnVmZmVyXG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YSk7XG4gICAgICAgIC8vIEVkZ2UgY2FzZSB0byBoYW5kbGUgdGhlIDAtYWRkcmVzc1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuYWxsb2MoMjApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMjApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzIHR5cGUgbXVzdCBiZSAyMCBieXRlcywgYnV0IGdvdCBcIi5jb25jYXQoZGF0YS5sZW5ndGgsIFwiIGJ5dGVzXCIpKTtcbiAgICAgICAgLy8gRm9yIEVJUDcxMiBlbmNvZGluZyBtb2R1bGUgaXQncyBlYXNpZXIgdG8gZW5jb2RlIGhleCBzdHJpbmdzXG4gICAgICAgIGlmIChmb3JKU1BhcnNlcikge1xuICAgICAgICAgICAgZGF0YSA9IFwiMHhcIi5jb25jYXQoZGF0YS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnN0YW50c18xLmV0aE1zZ1Byb3RvY29sLlRZUEVEX0RBVEEudHlwZUNvZGVzW3R5cGVdICYmXG4gICAgICAgICh0eXBlLmluZGV4T2YoJ3VpbnQnKSA+IC0xIHx8IHR5cGUuaW5kZXhPZignaW50JykgPiAtMSkpIHtcbiAgICAgICAgdmFyIGIgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YSk7XG4gICAgICAgIC8vIEVkZ2UgY2FzZSB0byBoYW5kbGUgMC12YWx1ZSBiaWdudW1zXG4gICAgICAgIGlmIChiLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYiA9IEJ1ZmZlci5mcm9tKCcwMCcsICdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVaW50MjU2cyBzaG91bGQgYmUgZW5jb2RlZCBhcyBiaWdudW1zLlxuICAgICAgICBpZiAoZm9ySlNQYXJzZXIpIHtcbiAgICAgICAgICAgIC8vIEZvciBFSVA3MTIgZW5jb2RpbmcgaW4gdGhpcyBtb2R1bGUgd2UgbmVlZCBzdHJpbmdzIHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyc1xuICAgICAgICAgICAgZGF0YSA9IFwiMHhcIi5jb25jYXQoYi50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYGJpZ251bWJlci5qc2AgaXMgbmVlZGVkIGZvciBgY2JvcmAgZW5jb2RpbmcsIHdoaWNoIGdldHMgc2VudCB0byB0aGUgTGF0dGljZSBhbmQgcGxheXNcbiAgICAgICAgICAgIC8vIG5pY2VseSB3aXRoIGl0cyBmaXJtd2FyZSBjYm9yIGxpYi5cbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHdlIGluc3RhbnRpYXRlIGEgYGJpZ251bWJlci5qc2Agb2JqZWN0LCBpdCB3aWxsIG5vdCBtYXRjaCB3aGF0IGBib3JjYCBjcmVhdGVzXG4gICAgICAgICAgICAvLyB3aGVuIHJ1biBpbnNpZGUgb2YgdGhlIGJyb3dzZXIgKGkuZS4gTWV0YU1hc2spLiBUaHVzIHdlIGludHJvZHVjZSB0aGlzIGhhY2sgdG8gbWFrZSBzdXJlXG4gICAgICAgICAgICAvLyB3ZSBhcmUgY3JlYXRpbmcgYSBjb21wYXRpYmxlIHR5cGUuXG4gICAgICAgICAgICAvLyBUT0RPOiBGaW5kIGFub3RoZXIgY2JvciBsaWIgdGhhdCBpcyBjb21wYXRhaWJsZSB3aXRoIHRoZSBmaXJtd2FyZSdzIGxpYiBpbiBhIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIGNvbnRleHQuIFRoaXMgaXMgc3VycHJpc2luZ2x5IGRpZmZpY3VsdCAtIEkgdHJpZWQgc2V2ZXJhbCBsaWJzIGFuZCBvbmx5IGNib3IvYm9yYyBoYXZlXG4gICAgICAgICAgICAvLyB3b3JrZWQgKGJvcmMgaXMgYSBzdXBwb3NlZGx5IFwiYnJvd3NlciBjb21wYXRpYmxlXCIgdmVyc2lvbiBvZiBjYm9yKVxuICAgICAgICAgICAgZGF0YSA9IG5ldyBib3JjXzEuZGVmYXVsdC5FbmNvZGVyKCkuc2VtYW50aWNUeXBlc1sxXVswXShiLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAvLyBCb29sZWFucyBuZWVkIHRvIGJlIGNhc3QgdG8gYSB1OFxuICAgICAgICBkYXRhID0gZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwO1xuICAgIH1cbiAgICAvLyBPdGhlciB0eXBlcyBkb24ndCBuZWVkIHRvIGJlIG1vZGlmaWVkXG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBnZXRfcGVyc29uYWxfc2lnbl9wcmVmaXgoTCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcIlxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIi5jb25jYXQoTC50b1N0cmluZygpKSwgJ3V0Zi04Jyk7XG59XG5mdW5jdGlvbiBnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UocmF3VHgsIHR4VHlwZSkge1xuICAgIGlmICh0eFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFt0eFR5cGVdKSwgQnVmZmVyLmZyb20oKDAsIHJscF8xLmVuY29kZSkocmF3VHgpKV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBybHBfMS5lbmNvZGUpKHJhd1R4KSk7XG4gICAgfVxufVxuLy8gPT09PT09XG4vLyBURU1QT1JBUlkgQlJJREdFXG4vLyBXZSBhcmUgbWlncmF0aW5nIGZyb20gYWxsIGxlZ2FjeSBzaWduaW5nIHBhdGhzIHRvIGEgc2luZ2xlIGdlbmVyaWNcbi8vIHNpZ25pbmcgcm91dGUuIElmIHVzZXJzIGFyZSBhdHRlbXB0aW5nIGEgbGVnYWN5IHRyYW5zYWN0aW9uIHJlcXVlc3Rcbi8vIGFnYWluc3QgYSBMYXR0aWNlIG9uIGZpcm13YXJlIHYwLjE1LjAgYW5kIGFib3ZlLCB3ZSBuZWVkIHRvIGNvbnZlcnRcbi8vIHRoYXQgdG8gYSBnZW5lcmljIHNpZ25pbmcgcmVxdWVzdC5cbi8vXG4vLyBOT1RFOiBPbmNlIHdlIGRlcHJlY2F0ZSwgd2Ugd2lsbCByZW1vdmUgdGhpcyBlbnRpcmUgZmlsZVxuLy8gPT09PT09XG52YXIgZXRoQ29udmVydExlZ2FjeVRvR2VuZXJpY1JlcSA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICB2YXIgY29tbW9uO1xuICAgIGlmICghcmVxLmNoYWluSWQgfHwgKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKHJlcS5jaGFpbklkKS50b1N0cmluZygnaGV4JykgPT09ICcwMScpIHtcbiAgICAgICAgY29tbW9uID0gbmV3IGNvbW1vbl8xLkNvbW1vbih7IGNoYWluOiBjb21tb25fMS5DaGFpbi5NYWlubmV0LCBoYXJkZm9yazogY29tbW9uXzEuSGFyZGZvcmsuTG9uZG9uIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm90IGV2ZXJ5IG5ldHdvcmsgd2lsbCBzdXBwb3J0IHRoZXNlIEVJUHMgYnV0IHdlIHdpbGwgYWxsb3dcbiAgICAgICAgLy8gc2lnbmluZyBvZiB0cmFuc2FjdGlvbnMgdXNpbmcgdGhlbVxuICAgICAgICBjb21tb24gPSBjb21tb25fMS5Db21tb24uY3VzdG9tKHsgY2hhaW5JZDogTnVtYmVyKHJlcS5jaGFpbklkKSB9LCB7IGhhcmRmb3JrOiBjb21tb25fMS5IYXJkZm9yay5Mb25kb24sIGVpcHM6IFsxNTU5LCAyOTMwXSB9KTtcbiAgICB9XG4gICAgdmFyIHR4ID0gdHhfMS5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YShyZXEsIHsgY29tbW9uOiBjb21tb24gfSk7XG4gICAgLy8gR2V0IHRoZSByYXcgdHJhbnNhY3Rpb24gcGF5bG9hZCB0byBiZSBoYXNoZWQgYW5kIHNpZ25lZC5cbiAgICAvLyBEaWZmZXJlbnQgYEBldGhlcmV1bWpzL3R4YCBUcmFuc2FjdGlvbiBvYmplY3QgdHlwZXMgaGF2ZVxuICAgIC8vIHNsaWdodGx5IGRpZmZlcmVudCBBUElzIGFyb3VuZCB0aGlzLlxuICAgIGlmIChyZXEudHlwZSkge1xuICAgICAgICAvLyBOZXdlciB0cmFuc2FjdGlvbiB0eXBlc1xuICAgICAgICByZXR1cm4gdHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBMZWdhY3kgdHJhbnNhY3Rpb24gdHlwZVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHJscF8xLmVuY29kZSkodHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSkpKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGJ1aWxkRXRoZXJldW1Nc2dSZXF1ZXN0OiBidWlsZEV0aGVyZXVtTXNnUmVxdWVzdCxcbiAgICB2YWxpZGF0ZUV0aGVyZXVtTXNnUmVzcG9uc2U6IHZhbGlkYXRlRXRoZXJldW1Nc2dSZXNwb25zZSxcbiAgICBidWlsZEV0aGVyZXVtVHhSZXF1ZXN0OiBidWlsZEV0aGVyZXVtVHhSZXF1ZXN0LFxuICAgIGJ1aWxkRXRoUmF3VHg6IGJ1aWxkRXRoUmF3VHgsXG4gICAgaGFzaFRyYW5zYWN0aW9uOiBoYXNoVHJhbnNhY3Rpb24sXG4gICAgY2hhaW5JZHM6IGNoYWluSWRzLFxuICAgIGVuc3VyZUhleEJ1ZmZlcjogdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcixcbiAgICBldGhDb252ZXJ0TGVnYWN5VG9HZW5lcmljUmVxOiBldGhDb252ZXJ0TGVnYWN5VG9HZW5lcmljUmVxLFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlQWRkS3ZSZWNvcmRzUmVxdWVzdCA9IGV4cG9ydHMudmFsaWRhdGVBZGRLdlJlcXVlc3QgPSBleHBvcnRzLmFkZEt2UmVjb3JkcyA9IHZvaWQgMDtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4uL3Byb3RvY29sXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbi8qKlxuICogYGFkZEt2UmVjb3Jkc2AgdGFrZXMgaW4gYSBzZXQgb2Yga2V5LXZhbHVlIHJlY29yZHMgYW5kIHNlbmRzIGEgcmVxdWVzdCB0byBhZGQgdGhlbSB0byB0aGVcbiAqIExhdHRpY2UuXG4gKiBAY2F0ZWdvcnkgTGF0dGljZVxuICogQHJldHVybnMgQSBjYWxsYmFjayB3aXRoIGFuIGVycm9yIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGFkZEt2UmVjb3JkcyhfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQsIHJlY29yZHMgPSBfYS5yZWNvcmRzLCB0eXBlID0gX2EudHlwZSwgY2FzZVNlbnNpdGl2ZSA9IF9hLmNhc2VTZW5zaXRpdmU7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2IsIHVybCwgc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIsIGZ3Q29uc3RhbnRzLCBkYXRhLCBfYywgZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYiA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVDb25uZWN0ZWRDbGllbnQpKGNsaWVudCksIHVybCA9IF9iLnVybCwgc2hhcmVkU2VjcmV0ID0gX2Iuc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIgPSBfYi5lcGhlbWVyYWxQdWIsIGZ3Q29uc3RhbnRzID0gX2IuZndDb25zdGFudHM7XG4gICAgICAgICAgICAgICAgICAgICgwLCBleHBvcnRzLnZhbGlkYXRlQWRkS3ZSZXF1ZXN0KSh7IHJlY29yZHM6IHJlY29yZHMsIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICgwLCBleHBvcnRzLmVuY29kZUFkZEt2UmVjb3Jkc1JlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHM6IHJlY29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm90b2NvbF8xLmVuY3J5cHRlZFNlY3VyZVJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBwcm90b2NvbF8xLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5hZGRLdlJlY29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYyA9IF9kLnNlbnQoKSwgZGVjcnlwdGVkRGF0YSA9IF9jLmRlY3J5cHRlZERhdGEsIG5ld0VwaGVtZXJhbFB1YiA9IF9jLm5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IG5ld0VwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkZWNyeXB0ZWREYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmFkZEt2UmVjb3JkcyA9IGFkZEt2UmVjb3JkcztcbnZhciB2YWxpZGF0ZUFkZEt2UmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciByZWNvcmRzID0gX2EucmVjb3JkcywgZndDb25zdGFudHMgPSBfYS5md0NvbnN0YW50cztcbiAgICAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlS3ZSZWNvcmRzKShyZWNvcmRzLCBmd0NvbnN0YW50cyk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZUFkZEt2UmVxdWVzdCA9IHZhbGlkYXRlQWRkS3ZSZXF1ZXN0O1xudmFyIGVuY29kZUFkZEt2UmVjb3Jkc1JlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcmVjb3JkcyA9IF9hLnJlY29yZHMsIHR5cGUgPSBfYS50eXBlLCBjYXNlU2Vuc2l0aXZlID0gX2EuY2FzZVNlbnNpdGl2ZSwgZndDb25zdGFudHMgPSBfYS5md0NvbnN0YW50cztcbiAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYygxICsgMTM5ICogZndDb25zdGFudHMua3ZBY3Rpb25NYXhOdW0pO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChPYmplY3Qua2V5cyhyZWNvcmRzKS5sZW5ndGgsIDApO1xuICAgIHZhciBvZmYgPSAxO1xuICAgIE9iamVjdC5lbnRyaWVzKHJlY29yZHMpLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfa2V5ID0gX2FbMF0sIF92YWwgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZUt2UmVjb3JkKSh7IGtleTogX2tleSwgdmFsOiBfdmFsIH0sIGZ3Q29uc3RhbnRzKSwga2V5ID0gX2Iua2V5LCB2YWwgPSBfYi52YWw7XG4gICAgICAgIC8vIFNraXAgdGhlIElEIHBvcnRpb24uIFRoaXMgd2lsbCBnZXQgYWRkZWQgYnkgZmlybXdhcmUuXG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRSgwLCBvZmYpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHR5cGUsIG9mZik7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDgoY2FzZVNlbnNpdGl2ZSA/IDEgOiAwLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KFN0cmluZyhrZXkpLmxlbmd0aCArIDEsIG9mZik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICBCdWZmZXIuZnJvbShTdHJpbmcoa2V5KSkuY29weShwYXlsb2FkLCBvZmYpO1xuICAgICAgICBvZmYgKz0gZndDb25zdGFudHMua3ZLZXlNYXhTdHJTeiArIDE7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50OChTdHJpbmcodmFsKS5sZW5ndGggKyAxLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgQnVmZmVyLmZyb20oU3RyaW5nKHZhbCkpLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IGZ3Q29uc3RhbnRzLmt2VmFsTWF4U3RyU3ogKyAxO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcbmV4cG9ydHMuZW5jb2RlQWRkS3ZSZWNvcmRzUmVxdWVzdCA9IGVuY29kZUFkZEt2UmVjb3Jkc1JlcXVlc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUNvbm5lY3RSZXNwb25zZSA9IGV4cG9ydHMudmFsaWRhdGVDb25uZWN0UmVxdWVzdCA9IGV4cG9ydHMuY29ubmVjdCA9IHZvaWQgMDtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4uL3Byb3RvY29sXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvcHJlZGljYXRlc1wiKTtcbnZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdXRpbGl0aWVzXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGNvbm5lY3QoX2EpIHtcbiAgICB2YXIgY2xpZW50ID0gX2EuY2xpZW50LCBpZCA9IF9hLmlkO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCBkZXZpY2VJZCwga2V5LCBiYXNlVXJsLCB1cmwsIHJlc3BQYXlsb2FkRGF0YSwgX2MsIGlzUGFpcmVkLCBmd1ZlcnNpb24sIGFjdGl2ZVdhbGxldHMsIGVwaGVtZXJhbFB1YjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoMCwgZXhwb3J0cy52YWxpZGF0ZUNvbm5lY3RSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGNsaWVudC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiBjbGllbnQuYmFzZVVybCxcbiAgICAgICAgICAgICAgICAgICAgfSksIGRldmljZUlkID0gX2IuZGV2aWNlSWQsIGtleSA9IF9iLmtleSwgYmFzZVVybCA9IF9iLmJhc2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL1wiKS5jb25jYXQoZGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvdG9jb2xfMS5jb25uZWN0U2VjdXJlUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogY2xpZW50LnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BQYXlsb2FkRGF0YSA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGV4cG9ydHMuZGVjb2RlQ29ubmVjdFJlc3BvbnNlKShyZXNwUGF5bG9hZERhdGEsIGtleSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBfZC5zZW50KCksIGlzUGFpcmVkID0gX2MuaXNQYWlyZWQsIGZ3VmVyc2lvbiA9IF9jLmZ3VmVyc2lvbiwgYWN0aXZlV2FsbGV0cyA9IF9jLmFjdGl2ZVdhbGxldHMsIGVwaGVtZXJhbFB1YiA9IF9jLmVwaGVtZXJhbFB1YjtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNsaWVudCBzdGF0ZSB3aXRoIHJlc3BvbnNlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IGVwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYWlyZWQ6IGlzUGFpcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZndWZXJzaW9uOiBmd1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVXYWxsZXRzOiBhY3RpdmVXYWxsZXRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNQYWlyZWQgJiYgISgwLCBwcmVkaWNhdGVzXzEuZG9lc0ZldGNoV2FsbGV0c09uTG9hZCkoY2xpZW50LmdldEZ3VmVyc2lvbigpKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGllbnQuZmV0Y2hBY3RpdmVXYWxsZXQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IFxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBmbGFnIGluZGljYXRpbmcgd2hldGhlciB3ZSBhcmUgcGFpcmVkIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgKm5vdCogYWxyZWFkeSBwYWlyZWQsIHRoZSBMYXR0aWNlIGlzIG5vdyBpblxuICAgICAgICAgICAgICAgIC8vIHBhaXJpbmcgbW9kZSBhbmQgZXhwZWN0cyBhIGBmaW5hbGl6ZVBhaXJpbmdgIGVuY3J5cHRlZFxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgYXMgYSBmb2xsb3cgdXAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGlzUGFpcmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0O1xudmFyIHZhbGlkYXRlQ29ubmVjdFJlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGV2aWNlSWQgPSBfYS5kZXZpY2VJZCwga2V5ID0gX2Eua2V5LCBiYXNlVXJsID0gX2EuYmFzZVVybDtcbiAgICB2YXIgdmFsaWREZXZpY2VJZCA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVEZXZpY2VJZCkoZGV2aWNlSWQpO1xuICAgIHZhciB2YWxpZEtleSA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVLZXkpKGtleSk7XG4gICAgdmFyIHZhbGlkQmFzZVVybCA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVCYXNlVXJsKShiYXNlVXJsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXZpY2VJZDogdmFsaWREZXZpY2VJZCxcbiAgICAgICAga2V5OiB2YWxpZEtleSxcbiAgICAgICAgYmFzZVVybDogdmFsaWRCYXNlVXJsLFxuICAgIH07XG59O1xuZXhwb3J0cy52YWxpZGF0ZUNvbm5lY3RSZXF1ZXN0ID0gdmFsaWRhdGVDb25uZWN0UmVxdWVzdDtcbi8qKlxuICogYGRlY29kZUNvbm5lY3RSZXNwb25zZWAgd2lsbCBjYWxsIGBTdGFydFBhaXJpbmdNb2RlYCBvbiB0aGUgZGV2aWNlLCB3aGljaCBnaXZlcyB0aGUgdXNlciA2MCBzZWNvbmRzIHRvXG4gKiBmaW5hbGl6ZSB0aGUgcGFpcmluZy4gVGhpcyB3aWxsIHJldHVybiBhbiBlcGhlbWVyYWwgcHVibGljIGtleSwgd2hpY2ggaXMgbmVlZGVkIGZvciB0aGUgbmV4dFxuICogcmVxdWVzdC5cbiAqIC0gSWYgdGhlIGRldmljZSBpcyBhbHJlYWR5IHBhaXJlZCwgdGhpcyBlcGhlbVB1YiBpcyBzaW1wbHkgdXNlZCB0byBlbmNyeXB0IHRoZSBuZXh0IHJlcXVlc3QuXG4gKiAtIElmIHRoZSBkZXZpY2UgaXMgbm90IHBhaXJlZCwgaXQgaXMgbmVlZGVkIHRvIHBhaXIgdGhlIGRldmljZSB3aXRoaW4gNjAgc2Vjb25kcy5cbiAqIEBjYXRlZ29yeSBEZXZpY2UgUmVzcG9uc2VcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcGFpcmVkIHRvIHRoZSBkZXZpY2UgYWxyZWFkeVxuICovXG52YXIgZGVjb2RlQ29ubmVjdFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBrZXkpIHtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaXNQYWlyZWQgPSByZXNwb25zZS5yZWFkVUludDgob2ZmKSA9PT0gcHJvdG9jb2xfMS5Qcm90b2NvbENvbnN0YW50cy5wYWlyaW5nU3RhdHVzLnBhaXJlZDtcbiAgICBvZmYrKztcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBwYWlyZWQsIHdlIGdldCB0aGUgbmV4dCBlcGhlbWVyYWwga2V5XG4gICAgdmFyIHB1YiA9IHJlc3BvbnNlLnNsaWNlKG9mZiwgb2ZmICsgNjUpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBvZmYgKz0gNjU7IC8vIFNldCB0aGUgcHVibGljIGtleVxuICAgIHZhciBlcGhlbWVyYWxQdWIgPSAoMCwgdXRpbF8xLmdldFAyNTZLZXlQYWlyRnJvbVB1YikocHViKTtcbiAgICAvLyBHcmFiIHRoZSBmaXJtd2FyZSB2ZXJzaW9uICh3aWxsIGJlIDAtbGVuZ3RoIGZvciBvbGRlciBmdyB2ZXJzaW9ucykgSXQgaXMgb2YgZm9ybWF0XG4gICAgLy8gfGZpeHxtaW5vcnxtYWpvcnxyZXNlcnZlZHxcbiAgICB2YXIgZndWZXJzaW9uID0gcmVzcG9uc2Uuc2xpY2Uob2ZmLCBvZmYgKyA0KTtcbiAgICBvZmYgKz0gNDtcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBwYWlyZWQsIHRoZSByZXNwb25zZSB3aWxsIGluY2x1ZGUgc29tZSBlbmNyeXB0ZWQgZGF0YSBhYm91dCB0aGUgY3VycmVudFxuICAgIC8vIHdhbGxldHMgVGhpcyBkYXRhIHdhcyBhZGRlZCBpbiBMYXR0aWNlIGZpcm13YXJlIHYwLjE0LjFcbiAgICBpZiAoaXNQYWlyZWQpIHtcbiAgICAgICAgLy9UT0RPICYmIHRoaXMuX2Z3VmVyc2lvbkdURSgwLCAxNCwgMSkpIHtcbiAgICAgICAgLy8gTGF0ZXIgdmVyc2lvbnMgb2YgZmlybXdhcmUgYWRkZWQgd2FsbGV0IGluZm9cbiAgICAgICAgdmFyIGVuY1dhbGxldERhdGEgPSByZXNwb25zZS5zbGljZShvZmYsIG9mZiArIDE2MCk7XG4gICAgICAgIG9mZiArPSAxNjA7XG4gICAgICAgIHZhciBzaGFyZWRTZWNyZXQgPSAoMCwgdXRpbGl0aWVzXzEuZ2V0U2hhcmVkU2VjcmV0KShrZXksIGVwaGVtZXJhbFB1Yik7XG4gICAgICAgIHZhciBkZWNXYWxsZXREYXRhID0gKDAsIHV0aWxfMS5hZXMyNTZfZGVjcnlwdCkoZW5jV2FsbGV0RGF0YSwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBkZWNyeXB0ZWQgZGF0YSBpcyBlbXB0eS4gVGhlIGxhc3QgMiBieXRlc1xuICAgICAgICAvLyBhcmUgQUVTIHBhZGRpbmdcbiAgICAgICAgaWYgKGRlY1dhbGxldERhdGFbZGVjV2FsbGV0RGF0YS5sZW5ndGggLSAyXSAhPT0gMCB8fFxuICAgICAgICAgICAgZGVjV2FsbGV0RGF0YVtkZWNXYWxsZXREYXRhLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHRvIExhdHRpY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2ZVdhbGxldHMgPSAoMCwgdXRpbGl0aWVzXzEucGFyc2VXYWxsZXRzKShkZWNXYWxsZXREYXRhKTtcbiAgICAgICAgcmV0dXJuIHsgaXNQYWlyZWQ6IGlzUGFpcmVkLCBmd1ZlcnNpb246IGZ3VmVyc2lvbiwgYWN0aXZlV2FsbGV0czogYWN0aXZlV2FsbGV0cywgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIgfTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHRoZSBzdGF0ZSBvZiBvdXIgcGFpcmluZ1xuICAgIHJldHVybiB7IGlzUGFpcmVkOiBpc1BhaXJlZCwgZndWZXJzaW9uOiBmd1ZlcnNpb24sIGFjdGl2ZVdhbGxldHM6IHVuZGVmaW5lZCwgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIgfTtcbn07XG5leHBvcnRzLmRlY29kZUNvbm5lY3RSZXNwb25zZSA9IGRlY29kZUNvbm5lY3RSZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlRmV0Y2hBY3RpdmVXYWxsZXRSZXNwb25zZSA9IGV4cG9ydHMuZmV0Y2hBY3RpdmVXYWxsZXQgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi4vcHJvdG9jb2xcIik7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC92YWxpZGF0b3JzXCIpO1xuLyoqXG4gKiBGZXRjaCB0aGUgYWN0aXZlIHdhbGxldCBpbiB0aGUgZGV2aWNlLlxuICpcbiAqIFRoZSBMYXR0aWNlIGhhcyB0d28gd2FsbGV0IGludGVyZmFjZXM6IGludGVybmFsIGFuZCBleHRlcm5hbC4gSWYgYSBTYWZlQ2FyZCBpcyBpbnNlcnRlZCBhbmRcbiAqIHVubG9ja2VkLCB0aGUgZXh0ZXJuYWwgaW50ZXJmYWNlIGlzIGNvbnNpZGVyZWQgXCJhY3RpdmVcIiBhbmQgdGhpcyB3aWxsIHJldHVybiBpdHMge0BsaW5rIFdhbGxldH1cbiAqIGRhdGEuIE90aGVyd2lzZSBpdCB3aWxsIHJldHVybiB0aGUgaW5mbyBmb3IgdGhlIGludGVybmFsIExhdHRpY2Ugd2FsbGV0LlxuICovXG5mdW5jdGlvbiBmZXRjaEFjdGl2ZVdhbGxldChfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2IsIHVybCwgc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIsIF9jLCBkZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIsIGFjdGl2ZVdhbGxldHMsIHZhbGlkQWN0aXZlV2FsbGV0cztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50KShjbGllbnQpLCB1cmwgPSBfYi51cmwsIHNoYXJlZFNlY3JldCA9IF9iLnNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViID0gX2IuZXBoZW1lcmFsUHViO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvdG9jb2xfMS5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBwcm90b2NvbF8xLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5nZXRXYWxsZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBfZC5zZW50KCksIGRlY3J5cHRlZERhdGEgPSBfYy5kZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIgPSBfYy5uZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVdhbGxldHMgPSAoMCwgZXhwb3J0cy5kZWNvZGVGZXRjaEFjdGl2ZVdhbGxldFJlc3BvbnNlKShkZWNyeXB0ZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRBY3RpdmVXYWxsZXRzID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZUFjdGl2ZVdhbGxldHMpKGFjdGl2ZVdhbGxldHMpO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogbmV3RXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlV2FsbGV0czogdmFsaWRBY3RpdmVXYWxsZXRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbGlkQWN0aXZlV2FsbGV0c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEFjdGl2ZVdhbGxldCA9IGZldGNoQWN0aXZlV2FsbGV0O1xudmFyIGRlY29kZUZldGNoQWN0aXZlV2FsbGV0UmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIFJlYWQgdGhlIGV4dGVybmFsIHdhbGxldCBkYXRhIGZpcnN0LiBJZiBpdCBpcyBub24tbnVsbCwgdGhlIGV4dGVybmFsIHdhbGxldCB3aWxsIGJlIHRoZVxuICAgIC8vIGFjdGl2ZSB3YWxsZXQgb2YgdGhlIGRldmljZSBhbmQgd2Ugc2hvdWxkIHNhdmUgaXQuIElmIHRoZSBleHRlcm5hbCB3YWxsZXQgaXMgYmxhbmssIGl0IG1lYW5zXG4gICAgLy8gdGhlcmUgaXMgbm8gY2FyZCBwcmVzZW50IGFuZCB3ZSBzaG91bGQgc2F2ZSBhbmQgdXNlIHRoZSBpbnRlcmFsIHdhbGxldC4gSWYgYm90aCB3YWxsZXRzIGFyZVxuICAgIC8vIGVtcHR5LCBpdCBtZWFucyB0aGUgZGV2aWNlIHN0aWxsIG5lZWRzIHRvIGJlIHNldCB1cC5cbiAgICB2YXIgd2FsbGV0RGVzY3JpcHRvckxlbiA9IDcxO1xuICAgIC8vIEludGVybmFsIGZpcnN0XG4gICAgdmFyIGFjdGl2ZVdhbGxldHMgPSB7XG4gICAgICAgIGludGVybmFsOiB7XG4gICAgICAgICAgICB1aWQ6IGNvbnN0YW50c18xLkVNUFRZX1dBTExFVF9VSUQsXG4gICAgICAgICAgICBleHRlcm5hbDogZmFsc2UsXG4gICAgICAgICAgICBuYW1lOiBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVybmFsOiB7XG4gICAgICAgICAgICB1aWQ6IGNvbnN0YW50c18xLkVNUFRZX1dBTExFVF9VSUQsXG4gICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIG5hbWU6IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczogMCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGFjdGl2ZVdhbGxldHMuaW50ZXJuYWwudWlkID0gZGF0YS5zbGljZShvZmYsIG9mZiArIDMyKTtcbiAgICBhY3RpdmVXYWxsZXRzLmludGVybmFsLmNhcGFiaWxpdGllcyA9IGRhdGEucmVhZFVJbnQzMkJFKG9mZiArIDMyKTtcbiAgICBhY3RpdmVXYWxsZXRzLmludGVybmFsLm5hbWUgPSBkYXRhLnNsaWNlKG9mZiArIDM2LCBvZmYgKyB3YWxsZXREZXNjcmlwdG9yTGVuKTtcbiAgICAvLyBPZmZzZXQgdGhlIGZpcnN0IGl0ZW1cbiAgICBvZmYgKz0gd2FsbGV0RGVzY3JpcHRvckxlbjtcbiAgICAvLyBFeHRlcm5hbFxuICAgIGFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwudWlkID0gZGF0YS5zbGljZShvZmYsIG9mZiArIDMyKTtcbiAgICBhY3RpdmVXYWxsZXRzLmV4dGVybmFsLmNhcGFiaWxpdGllcyA9IGRhdGEucmVhZFVJbnQzMkJFKG9mZiArIDMyKTtcbiAgICBhY3RpdmVXYWxsZXRzLmV4dGVybmFsLm5hbWUgPSBkYXRhLnNsaWNlKG9mZiArIDM2LCBvZmYgKyB3YWxsZXREZXNjcmlwdG9yTGVuKTtcbiAgICByZXR1cm4gYWN0aXZlV2FsbGV0cztcbn07XG5leHBvcnRzLmRlY29kZUZldGNoQWN0aXZlV2FsbGV0UmVzcG9uc2UgPSBkZWNvZGVGZXRjaEFjdGl2ZVdhbGxldFJlc3BvbnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVGZXRjaEVuY0RhdGEgPSBleHBvcnRzLmVuY29kZUZldGNoRW5jRGF0YVJlcXVlc3QgPSBleHBvcnRzLnZhbGlkYXRlRmV0Y2hFbmNEYXRhUmVxdWVzdCA9IGV4cG9ydHMuZmV0Y2hFbmNEYXRhID0gdm9pZCAwO1xuLyoqXG4gKiBFeHBvcnQgZW5jcnlwdGVkIGRhdGEgZnJvbSB0aGUgTGF0dGljZS4gRGF0YSBtdXN0IGNvbmZvcm1cbiAqIHRvIGtub3duIHNjaGVtYSwgZS5nLiBFSVAyMzM1IGRlcml2ZWQgcHJpdmtleSBleHBvcnQuXG4gKi9cbnZhciB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdXRpbGl0aWVzXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbnZhciBFTkNfREFUQSA9IGNvbnN0YW50c18xLkVYVEVSTkFMLkVOQ19EQVRBO1xudmFyIEVOQ19EQVRBX0VSUl9TVFIgPSAnVW5rbm93biBlbmNyeXB0ZWQgZGF0YSBleHBvcnQgdHlwZSByZXF1ZXN0ZWQuIEV4aXRpbmcuJztcbnZhciBFTkNfREFUQV9SRVFfREFUQV9TWiA9IDEwMjU7XG52YXIgRU5DX0RBVEFfUkVTUF9TWiA9IHtcbiAgICBFSVAyMzM1OiB7XG4gICAgICAgIENJUEhFUlRFWFQ6IDMyLFxuICAgICAgICBTQUxUOiAzMixcbiAgICAgICAgQ0hFQ0tTVU06IDMyLFxuICAgICAgICBJVjogMTYsXG4gICAgICAgIFBVQktFWTogNDgsXG4gICAgfSxcbn07XG5mdW5jdGlvbiBmZXRjaEVuY0RhdGEoX2EpIHtcbiAgICB2YXIgY2xpZW50ID0gX2EuY2xpZW50LCBzY2hlbWEgPSBfYS5zY2hlbWEsIHBhcmFtcyA9IF9hLnBhcmFtcztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYiwgdXJsLCBzaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiwgZndWZXJzaW9uLCBhY3RpdmVXYWxsZXQsIGRhdGEsIF9jLCBkZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9iID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZUNvbm5lY3RlZENsaWVudCkoY2xpZW50KSwgdXJsID0gX2IudXJsLCBzaGFyZWRTZWNyZXQgPSBfYi5zaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiA9IF9iLmVwaGVtZXJhbFB1YiwgZndWZXJzaW9uID0gX2IuZndWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVXYWxsZXQgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlV2FsbGV0KShjbGllbnQuZ2V0QWN0aXZlV2FsbGV0KCkpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgZXhwb3J0cy52YWxpZGF0ZUZldGNoRW5jRGF0YVJlcXVlc3QpKHsgcGFyYW1zOiBwYXJhbXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoMCwgZXhwb3J0cy5lbmNvZGVGZXRjaEVuY0RhdGFSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZndWZXJzaW9uOiBmd1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVXYWxsZXQ6IGFjdGl2ZVdhbGxldCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm90b2NvbF8xLmVuY3J5cHRlZFNlY3VyZVJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBwcm90b2NvbF8xLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5mZXRjaEVuY3J5cHRlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYyA9IF9kLnNlbnQoKSwgZGVjcnlwdGVkRGF0YSA9IF9jLmRlY3J5cHRlZERhdGEsIG5ld0VwaGVtZXJhbFB1YiA9IF9jLm5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IG5ld0VwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgZXhwb3J0cy5kZWNvZGVGZXRjaEVuY0RhdGEpKHsgZGF0YTogZGVjcnlwdGVkRGF0YSwgc2NoZW1hOiBzY2hlbWEsIHBhcmFtczogcGFyYW1zIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoRW5jRGF0YSA9IGZldGNoRW5jRGF0YTtcbnZhciB2YWxpZGF0ZUZldGNoRW5jRGF0YVJlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcGFyYW1zID0gX2EucGFyYW1zO1xuICAgIC8vIFZhbGlkYXRlIGRlcml2YXRpb24gcGF0aFxuICAgICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVTdGFydFBhdGgpKHBhcmFtcy5wYXRoKTtcbn07XG5leHBvcnRzLnZhbGlkYXRlRmV0Y2hFbmNEYXRhUmVxdWVzdCA9IHZhbGlkYXRlRmV0Y2hFbmNEYXRhUmVxdWVzdDtcbnZhciBlbmNvZGVGZXRjaEVuY0RhdGFSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNjaGVtYSA9IF9hLnNjaGVtYSwgcGFyYW1zID0gX2EucGFyYW1zLCBmd1ZlcnNpb24gPSBfYS5md1ZlcnNpb24sIGFjdGl2ZVdhbGxldCA9IF9hLmFjdGl2ZVdhbGxldDtcbiAgICAvLyBDaGVjayBmaXJtd2FyZSB2ZXJzaW9uXG4gICAgaWYgKGZ3VmVyc2lvbi5tYWpvciA8IDEgJiYgZndWZXJzaW9uLm1pbm9yIDwgMTcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJtd2FyZSB2ZXJzaW9uID49djAuMTcuMCBpcyByZXF1aXJlZCBmb3IgZW5jcnlwdGVkIGRhdGEgZXhwb3J0LicpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgcGFyYW1zIGRlcGVuZGluZyBvbiB3aGF0IHR5cGUgb2YgZGF0YSBpcyBiZWluZyBleHBvcnRlZFxuICAgIGlmIChzY2hlbWEgPT09IEVOQ19EQVRBLlNDSEVNQVMuQkxTX0tFWVNUT1JFX0VJUDIzMzVfUEJLREZfVjQpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB3YWxsZXQgVUlEIHRvIHRoZSBjbGllbnQncyBjdXJyZW50IGFjdGl2ZSB3YWxsZXRcbiAgICAgICAgcGFyYW1zLndhbGxldFVJRCA9IGFjdGl2ZVdhbGxldC51aWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRU5DX0RBVEFfRVJSX1NUUik7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHRoZSBwYXlsb2FkIGRhdGFcbiAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhFTkNfREFUQV9SRVFfREFUQV9TWik7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KHNjaGVtYSwgb2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICBpZiAoc2NoZW1hID09PSBFTkNfREFUQS5TQ0hFTUFTLkJMU19LRVlTVE9SRV9FSVAyMzM1X1BCS0RGX1Y0KSB7XG4gICAgICAgIHBhcmFtcy53YWxsZXRVSUQuY29weShwYXlsb2FkLCBvZmYpO1xuICAgICAgICBvZmYgKz0gcGFyYW1zLndhbGxldFVJRC5sZW5ndGg7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50OChwYXJhbXMucGF0aC5sZW5ndGgsIG9mZik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPD0gcGFyYW1zLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHBhcmFtcy5wYXRoW2ldLCBvZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5jKSB7XG4gICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUocGFyYW1zLmMsIG9mZik7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVOQ19EQVRBX0VSUl9TVFIpO1xuICAgIH1cbn07XG5leHBvcnRzLmVuY29kZUZldGNoRW5jRGF0YVJlcXVlc3QgPSBlbmNvZGVGZXRjaEVuY0RhdGFSZXF1ZXN0O1xudmFyIGRlY29kZUZldGNoRW5jRGF0YSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBkYXRhID0gX2EuZGF0YSwgc2NoZW1hID0gX2Euc2NoZW1hLCBwYXJhbXMgPSBfYS5wYXJhbXM7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKHNjaGVtYSA9PT0gRU5DX0RBVEEuU0NIRU1BUy5CTFNfS0VZU1RPUkVfRUlQMjMzNV9QQktERl9WNCkge1xuICAgICAgICB2YXIgcmVzcERhdGEgPSB7fTtcbiAgICAgICAgdmFyIF9iID0gRU5DX0RBVEFfUkVTUF9TWi5FSVAyMzM1LCBDSVBIRVJURVhUID0gX2IuQ0lQSEVSVEVYVCwgU0FMVCA9IF9iLlNBTFQsIENIRUNLU1VNID0gX2IuQ0hFQ0tTVU0sIElWID0gX2IuSVYsIFBVQktFWSA9IF9iLlBVQktFWTtcbiAgICAgICAgdmFyIGV4cGVjdGVkU3ogPSA0ICsgLy8gaXRlcmF0aW9ucyA9IHUzMlxuICAgICAgICAgICAgQ0lQSEVSVEVYVCArXG4gICAgICAgICAgICBTQUxUICtcbiAgICAgICAgICAgIENIRUNLU1VNICtcbiAgICAgICAgICAgIElWICtcbiAgICAgICAgICAgIFBVQktFWTtcbiAgICAgICAgdmFyIGRhdGFTeiA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZik7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICBpZiAoZGF0YVN6ICE9PSBleHBlY3RlZFN6KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSByZXR1cm5lZCBmcm9tIExhdHRpY2UuIEV4cGVjdGVkIEVJUDIzMzUgZGF0YS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXNwRGF0YS5pdGVyYXRpb25zID0gZGF0YS5yZWFkVUludDMyTEUob2ZmKTtcbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIHJlc3BEYXRhLmNpcGhlclRleHQgPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgQ0lQSEVSVEVYVCk7XG4gICAgICAgIG9mZiArPSBDSVBIRVJURVhUO1xuICAgICAgICByZXNwRGF0YS5zYWx0ID0gZGF0YS5zbGljZShvZmYsIG9mZiArIFNBTFQpO1xuICAgICAgICBvZmYgKz0gU0FMVDtcbiAgICAgICAgcmVzcERhdGEuY2hlY2tzdW0gPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgQ0hFQ0tTVU0pO1xuICAgICAgICBvZmYgKz0gQ0hFQ0tTVU07XG4gICAgICAgIHJlc3BEYXRhLml2ID0gZGF0YS5zbGljZShvZmYsIG9mZiArIElWKTtcbiAgICAgICAgb2ZmICs9IElWO1xuICAgICAgICByZXNwRGF0YS5wdWJrZXkgPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgUFVCS0VZKTtcbiAgICAgICAgb2ZmICs9IFBVQktFWTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdEVJUDIzMzVFeHBvcnREYXRhKHJlc3BEYXRhLCBwYXJhbXMucGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRU5DX0RBVEFfRVJSX1NUUik7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVjb2RlRmV0Y2hFbmNEYXRhID0gZGVjb2RlRmV0Y2hFbmNEYXRhO1xudmFyIGZvcm1hdEVJUDIzMzVFeHBvcnREYXRhID0gZnVuY3Rpb24gKHJlc3AsIHBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IHJlc3AuaXRlcmF0aW9ucywgc2FsdCA9IHJlc3Auc2FsdCwgY2hlY2tzdW0gPSByZXNwLmNoZWNrc3VtLCBpdiA9IHJlc3AuaXYsIGNpcGhlclRleHQgPSByZXNwLmNpcGhlclRleHQsIHB1YmtleSA9IHJlc3AucHVia2V5O1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgJ3ZlcnNpb24nOiA0LFxuICAgICAgICAgICAgJ3V1aWQnOiAoMCwgdXVpZF8xLnY0KSgpLFxuICAgICAgICAgICAgJ3BhdGgnOiAoMCwgdXRpbGl0aWVzXzEuZ2V0UGF0aFN0cikocGF0aCksXG4gICAgICAgICAgICAncHVia2V5JzogcHVia2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICdjcnlwdG8nOiB7XG4gICAgICAgICAgICAgICAgJ2tkZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJzogJ3Bia2RmMicsXG4gICAgICAgICAgICAgICAgICAgICdwYXJhbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGtsZW4nOiAzMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdjJzogaXRlcmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcmYnOiAnaG1hYy1zaGEyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NhbHQnOiBzYWx0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiAnJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2NoZWNrc3VtJzoge1xuICAgICAgICAgICAgICAgICAgICAnZnVuY3Rpb24nOiAnc2hhMjU2JyxcbiAgICAgICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHt9LFxuICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZSc6IGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdjaXBoZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICdmdW5jdGlvbic6ICdhZXMtMTI4LWN0cicsXG4gICAgICAgICAgICAgICAgICAgICdwYXJhbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaXYnOiBpdi50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdtZXNzYWdlJzogY2lwaGVyVGV4dC50b1N0cmluZygnaGV4JylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkZhaWxlZCB0byBmb3JtYXQgRUlQMjMzNSByZXR1cm4gZGF0YTogXCIuY29uY2F0KGVyci50b1N0cmluZygpKSk7XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlR2V0QWRkcmVzc2VzUmVzcG9uc2UgPSBleHBvcnRzLmVuY29kZUdldEFkZHJlc3Nlc1JlcXVlc3QgPSBleHBvcnRzLnZhbGlkYXRlR2V0QWRkcmVzc2VzUmVxdWVzdCA9IGV4cG9ydHMuZ2V0QWRkcmVzc2VzID0gdm9pZCAwO1xudmFyIGJpdHdpc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYml0d2lzZVwiKSk7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ZhbGlkYXRvcnNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIGBnZXRBZGRyZXNzZXNgIHRha2VzIGEgc3RhcnRpbmcgcGF0aCBhbmQgYSBudW1iZXIgdG8gZ2V0IHRoZSBhZGRyZXNzZXMgb3IgcHVibGljIGtleXMgYXNzb2NpYXRlZFxuICogd2l0aCB0aGUgYWN0aXZlIHdhbGxldC5cbiAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhZGRyZXNzZXMgb3IgcHVibGljIGtleXMuXG4gKi9cbmZ1bmN0aW9uIGdldEFkZHJlc3NlcyhfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQsIF9zdGFydFBhdGggPSBfYS5zdGFydFBhdGgsIF9uID0gX2EubiwgX2ZsYWcgPSBfYS5mbGFnO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCB1cmwsIHNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cywgYWN0aXZlV2FsbGV0LCBfYywgc3RhcnRQYXRoLCBuLCBmbGFnLCBkYXRhLCBfZCwgZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYiA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVDb25uZWN0ZWRDbGllbnQpKGNsaWVudCksIHVybCA9IF9iLnVybCwgc2hhcmVkU2VjcmV0ID0gX2Iuc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIgPSBfYi5lcGhlbWVyYWxQdWIsIGZ3Q29uc3RhbnRzID0gX2IuZndDb25zdGFudHM7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVdhbGxldCA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVXYWxsZXQpKGNsaWVudC5nZXRBY3RpdmVXYWxsZXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gKDAsIGV4cG9ydHMudmFsaWRhdGVHZXRBZGRyZXNzZXNSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBhdGg6IF9zdGFydFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuOiBfbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWc6IF9mbGFnLFxuICAgICAgICAgICAgICAgICAgICB9KSwgc3RhcnRQYXRoID0gX2Muc3RhcnRQYXRoLCBuID0gX2MubiwgZmxhZyA9IF9jLmZsYWc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoMCwgZXhwb3J0cy5lbmNvZGVHZXRBZGRyZXNzZXNSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBhdGg6IHN0YXJ0UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnOiBmbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0OiBhY3RpdmVXYWxsZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvdG9jb2xfMS5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcHJvdG9jb2xfMS5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0QWRkcmVzc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBfZS5zZW50KCksIGRlY3J5cHRlZERhdGEgPSBfZC5kZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIgPSBfZC5uZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBuZXdFcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGV4cG9ydHMuZGVjb2RlR2V0QWRkcmVzc2VzUmVzcG9uc2UpKGRlY3J5cHRlZERhdGEsIGZsYWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldEFkZHJlc3NlcyA9IGdldEFkZHJlc3NlcztcbnZhciB2YWxpZGF0ZUdldEFkZHJlc3Nlc1JlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgc3RhcnRQYXRoID0gX2Euc3RhcnRQYXRoLCBuID0gX2EubiwgZmxhZyA9IF9hLmZsYWc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRQYXRoOiAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlU3RhcnRQYXRoKShzdGFydFBhdGgpLFxuICAgICAgICBuOiAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlTkFkZHJlc3NlcykobiksXG4gICAgICAgIGZsYWc6ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVJc1VJbnQ0KShmbGFnKSxcbiAgICB9O1xufTtcbmV4cG9ydHMudmFsaWRhdGVHZXRBZGRyZXNzZXNSZXF1ZXN0ID0gdmFsaWRhdGVHZXRBZGRyZXNzZXNSZXF1ZXN0O1xudmFyIGVuY29kZUdldEFkZHJlc3Nlc1JlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHN0YXJ0UGF0aCA9IF9hLnN0YXJ0UGF0aCwgbiA9IF9hLm4sIGZsYWcgPSBfYS5mbGFnLCBmd0NvbnN0YW50cyA9IF9hLmZ3Q29uc3RhbnRzLCB3YWxsZXQgPSBfYS53YWxsZXQ7XG4gICAgdmFyIGZsYWdzID0gZndDb25zdGFudHMuZ2V0QWRkcmVzc0ZsYWdzIHx8IFtdO1xuICAgIHZhciBpc1B1YmtleU9ubHkgPSBmbGFncy5pbmRleE9mKGZsYWcpID4gLTEgJiZcbiAgICAgICAgKGZsYWcgPT09IHByb3RvY29sXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuZWQyNTUxOVB1YmtleSB8fFxuICAgICAgICAgICAgZmxhZyA9PT0gcHJvdG9jb2xfMS5MYXR0aWNlR2V0QWRkcmVzc2VzRmxhZy5zZWNwMjU2azFQdWJrZXkgfHxcbiAgICAgICAgICAgIGZsYWcgPT09IHByb3RvY29sXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuYmxzMTJfMzgxUHVia2V5KTtcbiAgICBpZiAoIWlzUHVia2V5T25seSAmJiAhKDAsIHV0aWxfMS5pc1ZhbGlkQXNzZXRQYXRoKShzdGFydFBhdGgsIGZ3Q29uc3RhbnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rlcml2YXRpb24gcGF0aCBvciBmbGFnIGlzIG5vdCBzdXBwb3J0ZWQuIFRyeSB1cGRhdGluZyBMYXR0aWNlIGZpcm13YXJlLicpO1xuICAgIH1cbiAgICB2YXIgc3ogPSAzMiArIDIwICsgMTsgLy8gd2FsbGV0VUlEICsgNSB1MzIgaW5kaWNlcyArIGNvdW50L2ZsYWdcbiAgICBpZiAoZndDb25zdGFudHMudmFyQWRkclBhdGhTekFsbG93ZWQpIHtcbiAgICAgICAgc3ogKz0gMTsgLy8gcGF0aERlcHRoXG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0UGF0aC5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIExhdHRpY2UgZmlybXdhcmUgb25seSBzdXBwb3J0cyBkZXJpdmF0aW9uIHBhdGhzIHdpdGggNSBpbmRpY2VzLiBQbGVhc2UgdXBncmFkZS4nKTtcbiAgICB9XG4gICAgdmFyIHBheWxvYWQgPSBCdWZmZXIuYWxsb2Moc3opO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHdhbGxldC51aWQuY29weShwYXlsb2FkLCBvZmYpO1xuICAgIG9mZiArPSAzMjtcbiAgICAvLyBCdWlsZCB0aGUgc3RhcnQgcGF0aCAoNXggdTMyIGluZGljZXMpXG4gICAgaWYgKGZ3Q29uc3RhbnRzLnZhckFkZHJQYXRoU3pBbGxvd2VkKSB7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50OChzdGFydFBhdGgubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPD0gc3RhcnRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbF8xID0gKF9iID0gc3RhcnRQYXRoW2ldKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkJFKHZhbF8xLCBvZmYpO1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSA0O1xuICAgIH1cbiAgICAvLyBTcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3Vic2VxdWVudCBhZGRyZXNzZXMgdG8gcmVxdWVzdC4gV2UgYWxzbyBhbGxvdyB0aGUgdXNlciB0byBza2lwIHRoZVxuICAgIC8vIGNhY2hlIGFuZCByZXF1ZXN0IGFueSBhZGRyZXNzIHJlbGF0ZWQgdG8gdGhlIGFzc2V0IGluIHRoZSB3YWxsZXQuXG4gICAgdmFyIHZhbCwgZmxhZ1ZhbCA9IDA7XG4gICAgaWYgKGZ3Q29uc3RhbnRzLmFkZHJGbGFnc0FsbG93ZWQpIHtcbiAgICAgICAgLy8gQSA0LWJpdCBmbGFnIGNhbiBiZSB1c2VkIGZvciBub24tc3RhbmRhcmQgYWRkcmVzcyByZXF1ZXN0cyBDbGllbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aFxuICAgICAgICAvLyBgbmAgYXMgYSA0IGJpdCB2YWx1ZVxuICAgICAgICBmbGFnVmFsID1cbiAgICAgICAgICAgIGZ3Q29uc3RhbnRzLmdldEFkZHJlc3NGbGFncyAmJlxuICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzLmdldEFkZHJlc3NGbGFncy5pbmRleE9mKGZsYWcpID4gLTFcbiAgICAgICAgICAgICAgICA/IGZsYWdcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIHZhciBmbGFnQml0cyA9IGJpdHdpc2VfMS5kZWZhdWx0Lm5pYmJsZS5yZWFkKGZsYWdWYWwpO1xuICAgICAgICB2YXIgY291bnRCaXRzID0gYml0d2lzZV8xLmRlZmF1bHQubmliYmxlLnJlYWQobik7XG4gICAgICAgIHZhbCA9IGJpdHdpc2VfMS5kZWZhdWx0LmJ5dGUud3JpdGUoZmxhZ0JpdHMuY29uY2F0KGNvdW50Qml0cykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVmVyeSBvbGQgZmlybXdhcmUgZG9lcyBub3Qgc3VwcG9ydCBjbGllbnQgZmxhZy4gV2UgY2FuIGRlcHJlY2F0ZSBjbGllbnQgc29vbi5cbiAgICAgICAgdmFsID0gbjtcbiAgICB9XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KHZhbCwgb2ZmKTtcbiAgICBvZmYrKztcbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5leHBvcnRzLmVuY29kZUdldEFkZHJlc3Nlc1JlcXVlc3QgPSBlbmNvZGVHZXRBZGRyZXNzZXNSZXF1ZXN0O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWRkcmVzcyBzdHJpbmdzIG9yIHB1YmtleSBidWZmZXJzXG4gKi9cbnZhciBkZWNvZGVHZXRBZGRyZXNzZXNSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhLCBmbGFnKSB7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgLy8gTG9vayBmb3IgYWRkcmVzc2VzIHVudGlsIHdlIHJlYWNoIHRoZSBlbmQgKGEgNCBieXRlIGNoZWNrc3VtKVxuICAgIHZhciBhZGRycyA9IFtdO1xuICAgIC8vIFB1YmtleXMgYXJlIGZvcm1hdHRlZCBkaWZmZXJlbnRseSBpbiB0aGUgcmVzcG9uc2VcbiAgICB2YXIgYXJlUHVia2V5cyA9IGZsYWcgPT09IHByb3RvY29sXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuc2VjcDI1NmsxUHVia2V5IHx8XG4gICAgICAgIGZsYWcgPT09IHByb3RvY29sXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuZWQyNTUxOVB1YmtleSB8fFxuICAgICAgICBmbGFnID09PSBwcm90b2NvbF8xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLmJsczEyXzM4MVB1YmtleTtcbiAgICBpZiAoYXJlUHVia2V5cykge1xuICAgICAgICBvZmYgKz0gMTsgLy8gc2tpcCB1aW50OCByZXByZXNlbnRpbmcgcHVia2V5IHR5cGVcbiAgICB9XG4gICAgdmFyIHJlc3BEYXRhTGVuZ3RoID0gcHJvdG9jb2xfMS5Qcm90b2NvbENvbnN0YW50cy5tc2dTaXplcy5zZWN1cmUuZGF0YS5yZXNwb25zZS5lbmNyeXB0ZWRbcHJvdG9jb2xfMS5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0QWRkcmVzc2VzXTtcbiAgICB3aGlsZSAob2ZmIDwgcmVzcERhdGFMZW5ndGgpIHtcbiAgICAgICAgaWYgKGFyZVB1YmtleXMpIHtcbiAgICAgICAgICAgIC8vIFB1YmtleXMgYXJlIHNob3J0ZXIgYW5kIGFyZSByZXR1cm5lZCBhcyBidWZmZXJzXG4gICAgICAgICAgICB2YXIgcHViQnl0ZXMgPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgNjUpO1xuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSBwdWJCeXRlcy5ldmVyeShmdW5jdGlvbiAoYnl0ZSkgeyByZXR1cm4gYnl0ZSA9PT0gMHgwMDsgfSk7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkgJiYgZmxhZyA9PT0gcHJvdG9jb2xfMS5MYXR0aWNlR2V0QWRkcmVzc2VzRmxhZy5lZDI1NTE5UHVia2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gRUQyNTUxOSBwdWJrZXlzIGFyZSAzMiBieXRlc1xuICAgICAgICAgICAgICAgIGFkZHJzLnB1c2gocHViQnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtcHR5ICYmIGZsYWcgPT09IHByb3RvY29sXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuYmxzMTJfMzgxUHVia2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gQkxTMTJfMzgxX0cxIGtleXMgYXJlIDQ4IGJ5dGVzXG4gICAgICAgICAgICAgICAgYWRkcnMucHVzaChwdWJCeXRlcy5zbGljZSgwLCA0OCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IG90aGVyIHJldHVybmVkIHB1YmtleXMgYXJlIEVDQywgb3IgNjUgYnl0ZXMgTm90ZSB0aGF0IHdlIHJldHVybiBmdWxsXG4gICAgICAgICAgICAgICAgLy8gKHVuY29tcHJlc3NlZCkgRUNDIHB1YmtleXNcbiAgICAgICAgICAgICAgICBhZGRycy5wdXNoKHB1YkJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSA2NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBhcmUgZGVhbGluZyB3aXRoIGFkZHJlc3Mgc3RyaW5nc1xuICAgICAgICAgICAgdmFyIGFkZHJCeXRlcyA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBwcm90b2NvbF8xLlByb3RvY29sQ29uc3RhbnRzLmFkZHJTdHJMZW4pO1xuICAgICAgICAgICAgb2ZmICs9IHByb3RvY29sXzEuUHJvdG9jb2xDb25zdGFudHMuYWRkclN0ckxlbjtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgVVRGLTggcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIHZhciBsZW4gPSBhZGRyQnl0ZXMuaW5kZXhPZigwKTsgLy8gRmlyc3QgMCBpcyB0aGUgbnVsbCB0ZXJtaW5hdG9yXG4gICAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgICAgIGFkZHJzLnB1c2goYWRkckJ5dGVzLnNsaWNlKDAsIGxlbikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkZHJzO1xufTtcbmV4cG9ydHMuZGVjb2RlR2V0QWRkcmVzc2VzUmVzcG9uc2UgPSBkZWNvZGVHZXRBZGRyZXNzZXNSZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlR2V0S3ZSZWNvcmRzUmVzcG9uc2UgPSBleHBvcnRzLmVuY29kZUdldEt2UmVjb3Jkc1JlcXVlc3QgPSBleHBvcnRzLnZhbGlkYXRlR2V0S3ZSZXF1ZXN0ID0gZXhwb3J0cy5nZXRLdlJlY29yZHMgPSB2b2lkIDA7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ZhbGlkYXRvcnNcIik7XG5mdW5jdGlvbiBnZXRLdlJlY29yZHMoX2EpIHtcbiAgICB2YXIgY2xpZW50ID0gX2EuY2xpZW50LCBfdHlwZSA9IF9hLnR5cGUsIF9uID0gX2EubiwgX3N0YXJ0ID0gX2Euc3RhcnQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2IsIHVybCwgc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIsIGZ3Q29uc3RhbnRzLCBfYywgdHlwZSwgbiwgc3RhcnQsIGRhdGEsIF9kLCBkZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9iID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZUNvbm5lY3RlZENsaWVudCkoY2xpZW50KSwgdXJsID0gX2IudXJsLCBzaGFyZWRTZWNyZXQgPSBfYi5zaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiA9IF9iLmVwaGVtZXJhbFB1YiwgZndDb25zdGFudHMgPSBfYi5md0NvbnN0YW50cztcbiAgICAgICAgICAgICAgICAgICAgX2MgPSAoMCwgZXhwb3J0cy52YWxpZGF0ZUdldEt2UmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuOiBfbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmd0NvbnN0YW50czogZndDb25zdGFudHMsXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0eXBlID0gX2MudHlwZSwgbiA9IF9jLm4sIHN0YXJ0ID0gX2Muc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoMCwgZXhwb3J0cy5lbmNvZGVHZXRLdlJlY29yZHNSZXF1ZXN0KSh7IHR5cGU6IHR5cGUsIG46IG4sIHN0YXJ0OiBzdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3RvY29sXzEuZW5jcnlwdGVkU2VjdXJlUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFR5cGU6IHByb3RvY29sXzEuTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmdldEt2UmVjb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTZWNyZXQ6IHNoYXJlZFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IGVwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9kID0gX2Uuc2VudCgpLCBkZWNyeXB0ZWREYXRhID0gX2QuZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViID0gX2QubmV3RXBoZW1lcmFsUHViO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogbmV3RXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCBleHBvcnRzLmRlY29kZUdldEt2UmVjb3Jkc1Jlc3BvbnNlKShkZWNyeXB0ZWREYXRhLCBmd0NvbnN0YW50cyldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0S3ZSZWNvcmRzID0gZ2V0S3ZSZWNvcmRzO1xudmFyIHZhbGlkYXRlR2V0S3ZSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZ3Q29uc3RhbnRzID0gX2EuZndDb25zdGFudHMsIG4gPSBfYS5uLCB0eXBlID0gX2EudHlwZSwgc3RhcnQgPSBfYS5zdGFydDtcbiAgICBpZiAoIWZ3Q29uc3RhbnRzLmt2QWN0aW9uc0FsbG93ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSBmaXJtd2FyZS4nKTtcbiAgICB9XG4gICAgaWYgKCFuIHx8IG4gPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcmVxdWVzdCBhdCBsZWFzdCBvbmUgcmVjb3JkLicpO1xuICAgIH1cbiAgICBpZiAobiA+IGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtYXkgb25seSByZXF1ZXN0IHVwIHRvIFwiLmNvbmNhdChmd0NvbnN0YW50cy5rdkFjdGlvbk1heE51bSwgXCIgcmVjb3JkcyBhdCBvbmNlLlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlICE9PSAwICYmICF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIHR5cGUuJyk7XG4gICAgfVxuICAgIGlmIChzdGFydCAhPT0gMCAmJiAhc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgdHlwZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzLCBuOiBuLCB0eXBlOiB0eXBlLCBzdGFydDogc3RhcnQgfTtcbn07XG5leHBvcnRzLnZhbGlkYXRlR2V0S3ZSZXF1ZXN0ID0gdmFsaWRhdGVHZXRLdlJlcXVlc3Q7XG52YXIgZW5jb2RlR2V0S3ZSZWNvcmRzUmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZSwgbiA9IF9hLm4sIHN0YXJ0ID0gX2Euc3RhcnQ7XG4gICAgdmFyIHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoOSk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHR5cGUsIDApO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChuLCA0KTtcbiAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoc3RhcnQsIDUpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcbmV4cG9ydHMuZW5jb2RlR2V0S3ZSZWNvcmRzUmVxdWVzdCA9IGVuY29kZUdldEt2UmVjb3Jkc1JlcXVlc3Q7XG52YXIgZGVjb2RlR2V0S3ZSZWNvcmRzUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSwgZndDb25zdGFudHMpIHtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgblRvdGFsID0gZGF0YS5yZWFkVUludDMyQkUob2ZmKTtcbiAgICBvZmYgKz0gNDtcbiAgICB2YXIgbkZldGNoZWQgPSBwYXJzZUludChkYXRhLnNsaWNlKG9mZiwgb2ZmICsgMSkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgb2ZmICs9IDE7XG4gICAgaWYgKG5GZXRjaGVkID4gZndDb25zdGFudHMua3ZBY3Rpb25NYXhOdW0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmVjb3JkcyBmZXRjaGVkLiBGaXJtd2FyZSBlcnJvci4nKTtcbiAgICB2YXIgcmVjb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkZldGNoZWQ7IGkrKykge1xuICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICByLmlkID0gZGF0YS5yZWFkVUludDMyQkUob2ZmKTtcbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIHIudHlwZSA9IGRhdGEucmVhZFVJbnQzMkJFKG9mZik7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICByLmNhc2VTZW5zaXRpdmUgPVxuICAgICAgICAgICAgcGFyc2VJbnQoZGF0YS5zbGljZShvZmYsIG9mZiArIDEpLnRvU3RyaW5nKCdoZXgnKSwgMTYpID09PSAxXG4gICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgIHZhciBrZXlTeiA9IHBhcnNlSW50KGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAxKS50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgIHIua2V5ID0gZGF0YS5zbGljZShvZmYsIG9mZiArIGtleVN6IC0gMSkudG9TdHJpbmcoKTtcbiAgICAgICAgb2ZmICs9IGZ3Q29uc3RhbnRzLmt2S2V5TWF4U3RyU3ogKyAxO1xuICAgICAgICB2YXIgdmFsU3ogPSBwYXJzZUludChkYXRhLnNsaWNlKG9mZiwgb2ZmICsgMSkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICByLnZhbCA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyB2YWxTeiAtIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgIG9mZiArPSBmd0NvbnN0YW50cy5rdlZhbE1heFN0clN6ICsgMTtcbiAgICAgICAgcmVjb3Jkcy5wdXNoKHIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWNvcmRzOiByZWNvcmRzLFxuICAgICAgICB0b3RhbDogblRvdGFsLFxuICAgICAgICBmZXRjaGVkOiBuRmV0Y2hlZCxcbiAgICB9O1xufTtcbmV4cG9ydHMuZGVjb2RlR2V0S3ZSZWNvcmRzUmVzcG9uc2UgPSBkZWNvZGVHZXRLdlJlY29yZHNSZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWRkS3ZSZWNvcmRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25uZWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZXRjaEVuY0RhdGFcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZldGNoQWN0aXZlV2FsbGV0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nZXRBZGRyZXNzZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dldEt2UmVjb3Jkc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFpclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVtb3ZlS3ZSZWNvcmRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlUGFpclJlcXVlc3QgPSBleHBvcnRzLnBhaXIgPSB2b2lkIDA7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdXRpbGl0aWVzXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogSWYgYSBwYWlyaW5nIHNlY3JldCBpcyBwcm92aWRlZCwgYHBhaXJgIHVzZXMgaXQgdG8gc2lnbiBhIGhhc2ggb2YgdGhlIHB1YmxpYyBrZXksIG5hbWUsIGFuZFxuICogcGFpcmluZyBzZWNyZXQuIEl0IHRoZW4gc2VuZHMgdGhlIG5hbWUgYW5kIHNpZ25hdHVyZSB0byB0aGUgZGV2aWNlLiBJZiBubyBwYWlyaW5nIHNlY3JldCBpc1xuICogcHJvdmlkZWQsIGBwYWlyYCBzZW5kcyBhIHplcm8tbGVuZ3RoIG5hbWUgYnVmZmVyIHRvIHRoZSBkZXZpY2UuXG4gKiBAY2F0ZWdvcnkgTGF0dGljZVxuICogQHJldHVybnMgVGhlIGFjdGl2ZSB3YWxsZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBwYWlyKF9hKSB7XG4gICAgdmFyIGNsaWVudCA9IF9hLmNsaWVudCwgcGFpcmluZ1NlY3JldCA9IF9hLnBhaXJpbmdTZWNyZXQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2IsIHVybCwgc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIsIGFwcE5hbWUsIGtleSwgZGF0YSwgbmV3RXBoZW1lcmFsUHViO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYiA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVDb25uZWN0ZWRDbGllbnQpKGNsaWVudCksIHVybCA9IF9iLnVybCwgc2hhcmVkU2VjcmV0ID0gX2Iuc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIgPSBfYi5lcGhlbWVyYWxQdWIsIGFwcE5hbWUgPSBfYi5hcHBOYW1lLCBrZXkgPSBfYi5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoMCwgZXhwb3J0cy5lbmNvZGVQYWlyUmVxdWVzdCkoeyBwYWlyaW5nU2VjcmV0OiBwYWlyaW5nU2VjcmV0LCBrZXk6IGtleSwgYXBwTmFtZTogYXBwTmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3RvY29sXzEuZW5jcnlwdGVkU2VjdXJlUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFR5cGU6IHByb3RvY29sXzEuTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmZpbmFsaXplUGFpcmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTZWNyZXQ6IHNoYXJlZFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IGVwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG5ld0VwaGVtZXJhbFB1YiA9IChfYy5zZW50KCkpLm5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IG5ld0VwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY2xpZW50LmZldGNoQWN0aXZlV2FsbGV0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2xpZW50Lmhhc0FjdGl2ZVdhbGxldCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhaXIgPSBwYWlyO1xudmFyIGVuY29kZVBhaXJSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGtleSA9IF9hLmtleSwgcGFpcmluZ1NlY3JldCA9IF9hLnBhaXJpbmdTZWNyZXQsIGFwcE5hbWUgPSBfYS5hcHBOYW1lO1xuICAgIC8vIEJ1aWxkIHRoZSBwYXlsb2FkIGRhdGFcbiAgICB2YXIgcHViS2V5Qnl0ZXMgPSAoMCwgdXRpbGl0aWVzXzEuZ2V0UHViS2V5Qnl0ZXMpKGtleSk7XG4gICAgdmFyIG5hbWVCdWYgPSBCdWZmZXIuYWxsb2MoMjUpO1xuICAgIGlmIChwYWlyaW5nU2VjcmV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gSWYgYSBwYWlyaW5nIHNlY3JldCBvZiB6ZXJvIGxlbmd0aCBpcyBwYXNzZWQgaW4sIGl0IHVzdWFsbHkgaW5kaWNhdGVzIHdlIHdhbnQgdG8gY2FuY2VsXG4gICAgICAgIC8vIHRoZSBwYWlyaW5nIGF0dGVtcHQuIEluIHRoaXMgY2FzZSB3ZSBwYXNzIGEgemVyby1sZW5ndGggbmFtZSBidWZmZXIgc28gdGhlIGZpcm13YXJlIGNhblxuICAgICAgICAvLyBrbm93IG5vdCB0byBkcmF3IHRoZSBlcnJvciBzY3JlZW4uIE5vdGUgdGhhdCB3ZSBzdGlsbCBleHBlY3QgYW4gZXJyb3IgdG8gY29tZSBiYWNrXG4gICAgICAgIC8vIChSRVNQX0VSUl9QQUlSX0ZBSUwpXG4gICAgICAgIG5hbWVCdWYud3JpdGUoYXBwTmFtZSk7XG4gICAgfVxuICAgIHZhciBoYXNoID0gKDAsIHV0aWxfMS5nZW5lcmF0ZUFwcFNlY3JldCkocHViS2V5Qnl0ZXMsIG5hbWVCdWYsIEJ1ZmZlci5mcm9tKHBhaXJpbmdTZWNyZXQpKTtcbiAgICB2YXIgc2lnID0ga2V5LnNpZ24oaGFzaCk7IC8vIHJldHVybnMgYW4gYXJyYXksIG5vdCBhIGJ1ZmZlclxuICAgIHZhciBkZXJTaWcgPSAoMCwgdXRpbF8xLnRvUGFkZGVkREVSKShzaWcpO1xuICAgIHZhciBwYXlsb2FkID0gQnVmZmVyLmNvbmNhdChbbmFtZUJ1ZiwgZGVyU2lnXSk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuZXhwb3J0cy5lbmNvZGVQYWlyUmVxdWVzdCA9IGVuY29kZVBhaXJSZXF1ZXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVSZW1vdmVLdlJlY29yZHNSZXF1ZXN0ID0gZXhwb3J0cy52YWxpZGF0ZVJlbW92ZUt2UmVxdWVzdCA9IGV4cG9ydHMucmVtb3ZlS3ZSZWNvcmRzID0gdm9pZCAwO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi4vcHJvdG9jb2xcIik7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC92YWxpZGF0b3JzXCIpO1xuLyoqXG4gKiBgcmVtb3ZlS3ZSZWNvcmRzYCB0YWtlcyBpbiBhbiBhcnJheSBvZiBpZHMgYW5kIHNlbmRzIGEgcmVxdWVzdCB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBMYXR0aWNlLlxuICogQGNhdGVnb3J5IExhdHRpY2VcbiAqIEByZXR1cm5zIEEgY2FsbGJhY2sgd2l0aCBhbiBlcnJvciBvciBudWxsLlxuICovXG5mdW5jdGlvbiByZW1vdmVLdlJlY29yZHMoX2EpIHtcbiAgICB2YXIgY2xpZW50ID0gX2EuY2xpZW50LCBfdHlwZSA9IF9hLnR5cGUsIF9pZHMgPSBfYS5pZHM7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2IsIHVybCwgc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIsIGZ3Q29uc3RhbnRzLCBfYywgdHlwZSwgaWRzLCBkYXRhLCBfZCwgZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYiA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVDb25uZWN0ZWRDbGllbnQpKGNsaWVudCksIHVybCA9IF9iLnVybCwgc2hhcmVkU2VjcmV0ID0gX2Iuc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIgPSBfYi5lcGhlbWVyYWxQdWIsIGZ3Q29uc3RhbnRzID0gX2IuZndDb25zdGFudHM7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gKDAsIGV4cG9ydHMudmFsaWRhdGVSZW1vdmVLdlJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRzOiBfaWRzLFxuICAgICAgICAgICAgICAgICAgICB9KSwgdHlwZSA9IF9jLnR5cGUsIGlkcyA9IF9jLmlkcztcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICgwLCBleHBvcnRzLmVuY29kZVJlbW92ZUt2UmVjb3Jkc1JlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHM6IGlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm90b2NvbF8xLmVuY3J5cHRlZFNlY3VyZVJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBwcm90b2NvbF8xLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5yZW1vdmVLdlJlY29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfZCA9IF9lLnNlbnQoKSwgZGVjcnlwdGVkRGF0YSA9IF9kLmRlY3J5cHRlZERhdGEsIG5ld0VwaGVtZXJhbFB1YiA9IF9kLm5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IG5ld0VwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkZWNyeXB0ZWREYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlbW92ZUt2UmVjb3JkcyA9IHJlbW92ZUt2UmVjb3JkcztcbnZhciB2YWxpZGF0ZVJlbW92ZUt2UmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBmd0NvbnN0YW50cyA9IF9hLmZ3Q29uc3RhbnRzLCB0eXBlID0gX2EudHlwZSwgaWRzID0gX2EuaWRzO1xuICAgIGlmICghZndDb25zdGFudHMua3ZBY3Rpb25zQWxsb3dlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIGZpcm13YXJlLicpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaWRzKSB8fCBpZHMubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGluY2x1ZGUgb25lIG9yIG1vcmUgYGlkc2AgdG8gcmVtb3ZlZC4nKTtcbiAgICB9XG4gICAgaWYgKGlkcy5sZW5ndGggPiBmd0NvbnN0YW50cy5rdlJlbW92ZU1heE51bSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHVwIHRvIFwiLmNvbmNhdChmd0NvbnN0YW50cy5rdlJlbW92ZU1heE51bSwgXCIgcmVjb3JkcyBtYXkgYmUgcmVtb3ZlZCBhdCBvbmNlLlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlICE9PSAwICYmICF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIHR5cGUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGlkczogaWRzIH07XG59O1xuZXhwb3J0cy52YWxpZGF0ZVJlbW92ZUt2UmVxdWVzdCA9IHZhbGlkYXRlUmVtb3ZlS3ZSZXF1ZXN0O1xudmFyIGVuY29kZVJlbW92ZUt2UmVjb3Jkc1JlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZndDb25zdGFudHMgPSBfYS5md0NvbnN0YW50cywgdHlwZSA9IF9hLnR5cGUsIGlkcyA9IF9hLmlkcztcbiAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyg1ICsgNCAqIGZ3Q29uc3RhbnRzLmt2UmVtb3ZlTWF4TnVtKTtcbiAgICBwYXlsb2FkLndyaXRlVUludDMyTEUodHlwZSwgMCk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KGlkcy5sZW5ndGgsIDQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSW50KGlkc1tpXSk7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRShpZCwgNSArIDQgKiBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuZXhwb3J0cy5lbmNvZGVSZW1vdmVLdlJlY29yZHNSZXF1ZXN0ID0gZW5jb2RlUmVtb3ZlS3ZSZWNvcmRzUmVxdWVzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlU2lnblJlc3BvbnNlID0gZXhwb3J0cy5lbmNvZGVTaWduUmVxdWVzdCA9IGV4cG9ydHMuc2lnbiA9IHZvaWQgMDtcbnZhciBoYXNoX2pzXzEgPSByZXF1aXJlKFwiaGFzaC5qc1wiKTtcbnZhciBiaXRjb2luXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2JpdGNvaW5cIikpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBldGhlcmV1bV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldGhlcmV1bVwiKSk7XG52YXIgZ2VuZXJpY1NpZ25pbmdfMSA9IHJlcXVpcmUoXCIuLi9nZW5lcmljU2lnbmluZ1wiKTtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4uL3Byb3RvY29sXCIpO1xudmFyIGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9mdW5jdGlvbnNcIik7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC92YWxpZGF0b3JzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBgc2lnbmAgYnVpbGRzIGFuZCBzZW5kcyBhIHJlcXVlc3QgZm9yIHNpZ25pbmcgdG8gdGhlIGRldmljZS5cbiAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgZGV2aWNlLlxuICovXG5mdW5jdGlvbiBzaWduKF9hKSB7XG4gICAgdmFyIGNsaWVudCA9IF9hLmNsaWVudCwgZGF0YSA9IF9hLmRhdGEsIGN1cnJlbmN5ID0gX2EuY3VycmVuY3ksIGNhY2hlZERhdGEgPSBfYS5jYWNoZWREYXRhLCBuZXh0Q29kZSA9IF9hLm5leHRDb2RlO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCB1cmwsIHNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cywgd2FsbGV0LCBfYywgcmVxdWVzdERhdGEsIGlzR2VuZXJpYywgX2QsIHBheWxvYWQsIGhhc0V4dHJhUGF5bG9hZHMsIF9lLCBkZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIsIGRlY29kZWRSZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICAgICAgc3dpdGNoIChfZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50KShjbGllbnQpLCB1cmwgPSBfYi51cmwsIHNoYXJlZFNlY3JldCA9IF9iLnNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViID0gX2IuZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cyA9IF9iLmZ3Q29uc3RhbnRzO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlV2FsbGV0KShjbGllbnQuZ2V0QWN0aXZlV2FsbGV0KCkpO1xuICAgICAgICAgICAgICAgICAgICBfYyA9ICgwLCBmdW5jdGlvbnNfMS5idWlsZFRyYW5zYWN0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzLFxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVxdWVzdERhdGEgPSBfYy5yZXF1ZXN0RGF0YSwgaXNHZW5lcmljID0gX2MuaXNHZW5lcmljO1xuICAgICAgICAgICAgICAgICAgICBfZCA9ICgwLCBleHBvcnRzLmVuY29kZVNpZ25SZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmd0NvbnN0YW50czogZndDb25zdGFudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQ6IHdhbGxldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhOiByZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZERhdGE6IGNhY2hlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29kZTogbmV4dENvZGUsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBwYXlsb2FkID0gX2QucGF5bG9hZCwgaGFzRXh0cmFQYXlsb2FkcyA9IF9kLmhhc0V4dHJhUGF5bG9hZHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm90b2NvbF8xLmVuY3J5cHRlZFNlY3VyZVJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBwcm90b2NvbF8xLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5zaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2UgPSBfZi5zZW50KCksIGRlY3J5cHRlZERhdGEgPSBfZS5kZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIgPSBfZS5uZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBuZXdFcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHJlcXVlc3QgaGFzIG11bHRpcGxlIHBheWxvYWRzLCB3ZSBuZWVkIHRvIHJlY3Vyc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gbWFrZSB0aGUgbmV4dCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBjaGFpbmVkIHRvIHRoZSBmaXJzdCByZXF1ZXN0IHVzaW5nIGBuZXh0Q29kZWBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0V4dHJhUGF5bG9hZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjbGllbnQuc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkRGF0YTogcmVxdWVzdERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb2RlOiBkZWNyeXB0ZWREYXRhLnNsaWNlKDAsIDgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkUmVzcG9uc2UgPSAoMCwgZXhwb3J0cy5kZWNvZGVTaWduUmVzcG9uc2UpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzR2VuZXJpYzogaXNHZW5lcmljLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRlY29kZWRSZXNwb25zZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zaWduID0gc2lnbjtcbnZhciBlbmNvZGVTaWduUmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiwgX2MsIF9kO1xuICAgIHZhciBmd0NvbnN0YW50cyA9IF9hLmZ3Q29uc3RhbnRzLCB3YWxsZXQgPSBfYS53YWxsZXQsIHJlcXVlc3REYXRhID0gX2EucmVxdWVzdERhdGEsIGNhY2hlZERhdGEgPSBfYS5jYWNoZWREYXRhLCBuZXh0Q29kZSA9IF9hLm5leHRDb2RlO1xuICAgIHZhciByZXFQYXlsb2FkLCBzY2hlbWE7XG4gICAgaWYgKGNhY2hlZERhdGEgJiYgbmV4dENvZGUpIHtcbiAgICAgICAgcmVxdWVzdERhdGEgPSBjYWNoZWREYXRhO1xuICAgICAgICByZXFQYXlsb2FkID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBuZXh0Q29kZSxcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLmV4dHJhRGF0YVBheWxvYWRzLnNoaWZ0KCksXG4gICAgICAgIF0pO1xuICAgICAgICBzY2hlbWEgPSBwcm90b2NvbF8xLkxhdHRpY2VTaWduU2NoZW1hLmV4dHJhRGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcVBheWxvYWQgPSByZXF1ZXN0RGF0YS5wYXlsb2FkO1xuICAgICAgICBzY2hlbWEgPSByZXF1ZXN0RGF0YS5zY2hlbWE7XG4gICAgfVxuICAgIHZhciBwYXlsb2FkID0gQnVmZmVyLmFsbG9jKDIgKyBmd0NvbnN0YW50cy5yZXFNYXhEYXRhU3opO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBoYXNFeHRyYVBheWxvYWRzID0gcmVxdWVzdERhdGEuZXh0cmFEYXRhUGF5bG9hZHMgJiZcbiAgICAgICAgTnVtYmVyKHJlcXVlc3REYXRhLmV4dHJhRGF0YVBheWxvYWRzLmxlbmd0aCA+IDApO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChoYXNFeHRyYVBheWxvYWRzLCBvZmYpO1xuICAgIG9mZiArPSAxO1xuICAgIC8vIENvcHkgcmVxdWVzdCBzY2hlbWEgKGUuZy4gRVRIIG9yIEJUQyB0cmFuc2ZlcilcbiAgICBwYXlsb2FkLndyaXRlVUludDgoc2NoZW1hLCBvZmYpO1xuICAgIG9mZiArPSAxO1xuICAgIC8vIENvcHkgdGhlIHdhbGxldCBVSURcbiAgICAoX2IgPSB3YWxsZXQudWlkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29weShwYXlsb2FkLCBvZmYpO1xuICAgIG9mZiArPSAoX2QgPSAoX2MgPSB3YWxsZXQudWlkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwO1xuICAgIC8vIEJ1aWxkIGRhdGEgYmFzZWQgb24gdGhlIHR5cGUgb2YgcmVxdWVzdFxuICAgIHJlcVBheWxvYWQuY29weShwYXlsb2FkLCBvZmYpO1xuICAgIHJldHVybiB7IHBheWxvYWQ6IHBheWxvYWQsIGhhc0V4dHJhUGF5bG9hZHM6IGhhc0V4dHJhUGF5bG9hZHMgfTtcbn07XG5leHBvcnRzLmVuY29kZVNpZ25SZXF1ZXN0ID0gZW5jb2RlU2lnblJlcXVlc3Q7XG52YXIgZGVjb2RlU2lnblJlc3BvbnNlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciBkYXRhID0gX2EuZGF0YSwgcmVxdWVzdCA9IF9hLnJlcXVlc3QsIGlzR2VuZXJpYyA9IF9hLmlzR2VuZXJpYywgY3VycmVuY3kgPSBfYS5jdXJyZW5jeTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgZGVyU2lnTGVuID0gNzQ7IC8vIERFUiBzaWduYXR1cmVzIGFyZSA3NCBieXRlc1xuICAgIGlmIChjdXJyZW5jeSA9PT0gY29uc3RhbnRzXzEuQ1VSUkVOQ0lFUy5CVEMpIHtcbiAgICAgICAgdmFyIGJ0Y1JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB2YXIgcGtoTGVuID0gMjA7IC8vIFB1YmtleWhhc2hlcyBhcmUgMjAgYnl0ZXNcbiAgICAgICAgdmFyIHNpZ3NMZW4gPSA3NDA7IC8vIFVwIHRvIDEweCBERVIgc2lnbmF0dXJlc1xuICAgICAgICB2YXIgY2hhbmdlVmVyc2lvbiA9IGJpdGNvaW5fMS5kZWZhdWx0LmdldEFkZHJlc3NGb3JtYXQoYnRjUmVxdWVzdC5vcmlnRGF0YS5jaGFuZ2VQYXRoKTtcbiAgICAgICAgdmFyIGNoYW5nZVB1YktleUhhc2ggPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgcGtoTGVuKTtcbiAgICAgICAgb2ZmICs9IHBraExlbjtcbiAgICAgICAgdmFyIGNoYW5nZVJlY2lwaWVudCA9IGJpdGNvaW5fMS5kZWZhdWx0LmdldEJpdGNvaW5BZGRyZXNzKGNoYW5nZVB1YktleUhhc2gsIGNoYW5nZVZlcnNpb24pO1xuICAgICAgICB2YXIgY29tcHJlc3NlZFB1Ykxlbmd0aCA9IDMzOyAvLyBTaXplIG9mIGNvbXByZXNzZWQgcHVibGljIGtleVxuICAgICAgICB2YXIgcHVia2V5cyA9IFtdO1xuICAgICAgICB2YXIgc2lncyA9IFtdO1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBzaWduYXR1cmUgZm9yIGVhY2ggb3V0cHV0IC0tIHRoZXkgYXJlIHJldHVybmVkIGluIHRoZSBzZXJpYWxpemVkIHBheWxvYWQgaW4gZm9ybVxuICAgICAgICAvLyBbcHVia2V5LCBzaWddIFRoZXJlIGlzIG9uZSBzaWduYXR1cmUgcGVyIG91dHB1dFxuICAgICAgICB3aGlsZSAob2ZmIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgb3V0IGlmIHdlIGhhdmUgc2VlbiBhbGwgdGhlIHJldHVybmVkIHNpZ3MgYW5kIHB1YmtleXNcbiAgICAgICAgICAgIGlmIChkYXRhW29mZl0gIT09IDB4MzApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgZ3JhYiBhbm90aGVyIHNldCBOb3RlIHRoYXQgYWxsIERFUiBzaWdzIHJldHVybmVkIGZpbGwgdGhlIG1heGltdW0gNzQgYnl0ZVxuICAgICAgICAgICAgLy8gYnVmZmVyLCBidXQgYWxzbyBjb250YWluIGEgbGVuZ3RoIGF0IG9mZisxLCB3aGljaCB3ZSB1c2UgdG8gcGFyc2UgdGhlIG5vbi16ZXJvIGRhdGEuXG4gICAgICAgICAgICAvLyBGaXJzdCBnZXQgdGhlIHNpZ25hdHVyZSBmcm9tIGl0cyBzbG90XG4gICAgICAgICAgICB2YXIgc2lnU3RhcnQgPSBvZmY7XG4gICAgICAgICAgICB2YXIgc2lnRW5kID0gb2ZmICsgMiArIGRhdGFbb2ZmICsgMV07XG4gICAgICAgICAgICBzaWdzLnB1c2goZGF0YS5zbGljZShzaWdTdGFydCwgc2lnRW5kKSk7XG4gICAgICAgICAgICBvZmYgKz0gZGVyU2lnTGVuO1xuICAgICAgICAgICAgLy8gTmV4dCwgc2hpZnQgYnkgdGhlIGZ1bGwgc2V0IG9mIHNpZ25hdHVyZXMgdG8gaGl0IHRoZSByZXNwZWN0aXZlIHB1YmtleSBOT1RFOiBUaGUgZGF0YVxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgaXM6IFs8c2lnMD4sIDxzaWcxPiwgLi4uIDxzaWc5Pl1bPHB1YmtleTA+LCA8cHVia2V5MT4sIC4uLiA8cHVia2V5OT5dXG4gICAgICAgICAgICB2YXIgcHViU3RhcnQgPSBuICogY29tcHJlc3NlZFB1Ykxlbmd0aCArIHNpZ3NMZW47XG4gICAgICAgICAgICB2YXIgcHViRW5kID0gKG4gKyAxKSAqIGNvbXByZXNzZWRQdWJMZW5ndGggKyBzaWdzTGVuO1xuICAgICAgICAgICAgcHVia2V5cy5wdXNoKGRhdGEuc2xpY2UocHViU3RhcnQsIHB1YkVuZCkpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIG9mZnNldCB0byBoaXQgdGhlIG5leHQgc2lnbmF0dXJlIHNsb3RcbiAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb24gZGF0YSB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgIHZhciBwcmVTZXJpYWxpemVkRGF0YSA9IHtcbiAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRmlyc3Qgb3V0cHV0IGNvbWVzIGZyb20gcmVxdWVzdCBkdGFcbiAgICAgICAgcHJlU2VyaWFsaXplZERhdGEub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBidGNSZXF1ZXN0Lm9yaWdEYXRhLnZhbHVlLFxuICAgICAgICAgICAgcmVjaXBpZW50OiBidGNSZXF1ZXN0Lm9yaWdEYXRhLnJlY2lwaWVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoKF9iID0gYnRjUmVxdWVzdC5jaGFuZ2VEYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsdWUpICYmIGJ0Y1JlcXVlc3QuY2hhbmdlRGF0YS52YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIC8vIFNlY29uZCBvdXRwdXQgY29tZXMgZnJvbSBjaGFuZ2UgZGF0YVxuICAgICAgICAgICAgcHJlU2VyaWFsaXplZERhdGEub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnRjUmVxdWVzdC5jaGFuZ2VEYXRhLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogY2hhbmdlUmVjaXBpZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBpbnB1dHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmVTZXJpYWxpemVkRGF0YS5pbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaGFzaDogYnRjUmVxdWVzdC5vcmlnRGF0YS5wcmV2T3V0c1tpXS50eEhhc2gsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGJ0Y1JlcXVlc3Qub3JpZ0RhdGEucHJldk91dHNbaV0uaW5kZXgsXG4gICAgICAgICAgICAgICAgc2lnOiBzaWdzW2ldLFxuICAgICAgICAgICAgICAgIHB1YmtleTogcHVia2V5c1tpXSxcbiAgICAgICAgICAgICAgICBzaWduZXJQYXRoOiBidGNSZXF1ZXN0Lm9yaWdEYXRhLnByZXZPdXRzW2ldLnNpZ25lclBhdGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBzZXJpYWxpemUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIHZhciBzZXJpYWxpemVkVHggPSBiaXRjb2luXzEuZGVmYXVsdC5zZXJpYWxpemVUeChwcmVTZXJpYWxpemVkRGF0YSk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSB0cmFuc2FjdGlvbiBoYXNoIHNvIHRoZSB1c2VyIGNhbiBsb29rIHRoaXMgdHJhbnNhY3Rpb24gdXAgbGF0ZXJcbiAgICAgICAgdmFyIHByZUltYWdlVHhIYXNoID0gc2VyaWFsaXplZFR4O1xuICAgICAgICB2YXIgdHhIYXNoUHJlID0gQnVmZmVyLmZyb20oKDAsIGhhc2hfanNfMS5zaGEyNTYpKCkudXBkYXRlKEJ1ZmZlci5mcm9tKHByZUltYWdlVHhIYXNoLCAnaGV4JykpLmRpZ2VzdCgnaGV4JyksICdoZXgnKTtcbiAgICAgICAgLy8gQWRkIGV4dHJhIGRhdGEgZm9yIGRlYnVnZ2luZy9sb29rdXAgcHVycG9zZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4OiBzZXJpYWxpemVkVHgsXG4gICAgICAgICAgICB0eEhhc2g6ICgwLCBoYXNoX2pzXzEuc2hhMjU2KSgpLnVwZGF0ZSh0eEhhc2hQcmUpLmRpZ2VzdCgnaGV4JyksXG4gICAgICAgICAgICBjaGFuZ2VSZWNpcGllbnQ6IGNoYW5nZVJlY2lwaWVudCxcbiAgICAgICAgICAgIHNpZ3M6IHNpZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbmN5ID09PSBjb25zdGFudHNfMS5DVVJSRU5DSUVTLkVUSCAmJiAhaXNHZW5lcmljKSB7XG4gICAgICAgIHZhciBzaWcgPSAoMCwgdXRpbF8xLnBhcnNlREVSKShkYXRhLnNsaWNlKG9mZiwgb2ZmICsgMiArIGRhdGFbb2ZmICsgMV0pKTtcbiAgICAgICAgb2ZmICs9IGRlclNpZ0xlbjtcbiAgICAgICAgdmFyIGV0aEFkZHIgPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgMjApO1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGB2YCBwYXJhbSBhbmQgYWRkIGl0IHRvIHRoZSBzaWcgYmVmb3JlIHJldHVybmluZ1xuICAgICAgICB2YXIgX2MgPSBldGhlcmV1bV8xLmRlZmF1bHQuYnVpbGRFdGhSYXdUeChyZXF1ZXN0LCBzaWcsIGV0aEFkZHIpLCByYXdUeCA9IF9jLnJhd1R4LCBzaWdXaXRoViA9IF9jLnNpZ1dpdGhWO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHg6IFwiMHhcIi5jb25jYXQocmF3VHgpLFxuICAgICAgICAgICAgdHhIYXNoOiBcIjB4XCIuY29uY2F0KGV0aGVyZXVtXzEuZGVmYXVsdC5oYXNoVHJhbnNhY3Rpb24ocmF3VHgpKSxcbiAgICAgICAgICAgIHNpZzoge1xuICAgICAgICAgICAgICAgIHY6IHNpZ1dpdGhWLnYsXG4gICAgICAgICAgICAgICAgcjogc2lnV2l0aFYuci50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgczogc2lnV2l0aFYucy50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmVyOiBldGhBZGRyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW5jeSA9PT0gY29uc3RhbnRzXzEuQ1VSUkVOQ0lFUy5FVEhfTVNHKSB7XG4gICAgICAgIHZhciBzaWcgPSAoMCwgdXRpbF8xLnBhcnNlREVSKShkYXRhLnNsaWNlKG9mZiwgb2ZmICsgMiArIGRhdGFbb2ZmICsgMV0pKTtcbiAgICAgICAgb2ZmICs9IGRlclNpZ0xlbjtcbiAgICAgICAgdmFyIHNpZ25lciA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAyMCk7XG4gICAgICAgIHZhciB2YWxpZGF0ZWRTaWcgPSBldGhlcmV1bV8xLmRlZmF1bHQudmFsaWRhdGVFdGhlcmV1bU1zZ1Jlc3BvbnNlKHsgc2lnbmVyOiBzaWduZXIsIHNpZzogc2lnIH0sIHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lnOiB7XG4gICAgICAgICAgICAgICAgdjogdmFsaWRhdGVkU2lnLnYsXG4gICAgICAgICAgICAgICAgcjogdmFsaWRhdGVkU2lnLnIudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIHM6IHZhbGlkYXRlZFNpZy5zLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduZXI6IHNpZ25lcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdlbmVyaWMgc2lnbmluZyByZXF1ZXN0XG4gICAgICAgIHJldHVybiAoMCwgZ2VuZXJpY1NpZ25pbmdfMS5wYXJzZUdlbmVyaWNTaWduaW5nUmVzcG9uc2UpKGRhdGEsIG9mZiwgcmVxdWVzdCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVjb2RlU2lnblJlc3BvbnNlID0gZGVjb2RlU2lnblJlc3BvbnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVuY29kZWRQYXlsb2FkID0gZXhwb3J0cy5wYXJzZUdlbmVyaWNTaWduaW5nUmVzcG9uc2UgPSBleHBvcnRzLmJ1aWxkR2VuZXJpY1NpZ25pbmdNc2dSZXF1ZXN0ID0gdm9pZCAwO1xuLyoqXG5HZW5lcmljIHNpZ25pbmcgbW9kdWxlLiBBbnkgcGF5bG9hZCBjYW4gYmUgc2VudCB0byB0aGUgTGF0dGljZSBhbmRcbndpbGwgYmUgZGlzcGxheWVkIGluIGZ1bGwgKG5vdGUgdGhhdCBcXG4gYW5kIFxcdCBjaGFyYWN0ZXJzIHdpbGwgYmVcbmRpc3BsYXllZCBhcyBsaW5lIGJyZWFrcyBhbmQgdGFicyBvbiB0aGUgc2NyZWVuKS5cblxuVGhpcyBwYXlsb2FkIHNob3VsZCBiZSBjb3VwbGVkIHdpdGg6XG4qIFNpZ25lcidzIEJJUDQ0IHBhdGhcbiogQ3VydmUgb24gd2hpY2ggdG8gZGVyaXZlIHRoZSBzaWduaW5nIGtleVxuKiBIYXNoIGZ1bmN0aW9uIHRvIHVzZSBvbiB0aGUgbWVzc2FnZVxuKi9cbnZhciBzaGFfMSA9IHJlcXVpcmUoXCJoYXNoLmpzL2xpYi9oYXNoL3NoYVwiKTtcbnZhciBqc19zaGEzXzEgPSByZXF1aXJlKFwianMtc2hhM1wiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3QgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgdmFyIHNpZ25lclBhdGggPSByZXEuc2lnbmVyUGF0aCwgY3VydmVUeXBlID0gcmVxLmN1cnZlVHlwZSwgaGFzaFR5cGUgPSByZXEuaGFzaFR5cGUsIF9hID0gcmVxLmVuY29kaW5nVHlwZSwgZW5jb2RpbmdUeXBlID0gX2EgPT09IHZvaWQgMCA/IG51bGwgOiBfYSwgX2IgPSByZXEuZGVjb2RlciwgZGVjb2RlciA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2IsIF9jID0gcmVxLm9taXRQdWJrZXksIG9taXRQdWJrZXkgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgZndDb25zdGFudHMgPSByZXEuZndDb25zdGFudHMsIF9kID0gcmVxLmJsc0RzdCwgYmxzRHN0ID0gX2QgPT09IHZvaWQgMCA/IGluZGV4XzEuQ29uc3RhbnRzLlNJR05JTkcuQkxTX0RTVC5CTFNfRFNUX05VTCA6IF9kO1xuICAgIHZhciBleHRyYURhdGFGcmFtZVN6ID0gZndDb25zdGFudHMuZXh0cmFEYXRhRnJhbWVTeiwgZXh0cmFEYXRhTWF4RnJhbWVzID0gZndDb25zdGFudHMuZXh0cmFEYXRhTWF4RnJhbWVzLCBwcmVoYXNoQWxsb3dlZCA9IGZ3Q29uc3RhbnRzLnByZWhhc2hBbGxvd2VkLCBnZW5lcmljU2lnbmluZyA9IGZ3Q29uc3RhbnRzLmdlbmVyaWNTaWduaW5nLCB2YXJBZGRyUGF0aFN6QWxsb3dlZCA9IGZ3Q29uc3RhbnRzLnZhckFkZHJQYXRoU3pBbGxvd2VkO1xuICAgIHZhciBjdXJ2ZVR5cGVzID0gZ2VuZXJpY1NpZ25pbmcuY3VydmVUeXBlcywgZW5jb2RpbmdUeXBlcyA9IGdlbmVyaWNTaWduaW5nLmVuY29kaW5nVHlwZXMsIGhhc2hUeXBlcyA9IGdlbmVyaWNTaWduaW5nLmhhc2hUeXBlcywgYmFzZURhdGFTeiA9IGdlbmVyaWNTaWduaW5nLmJhc2VEYXRhU3osIGJhc2VSZXFTeiA9IGdlbmVyaWNTaWduaW5nLmJhc2VSZXFTeiwgY2FsbGRhdGFEZWNvZGluZyA9IGdlbmVyaWNTaWduaW5nLmNhbGxkYXRhRGVjb2Rpbmc7XG4gICAgdmFyIGVuY29kZWRQYXlsb2FkID0gKDAsIGV4cG9ydHMuZ2V0RW5jb2RlZFBheWxvYWQpKHJlcS5wYXlsb2FkLCBlbmNvZGluZ1R5cGUsIGVuY29kaW5nVHlwZXMpO1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZWRQYXlsb2FkLmVuY29kaW5nO1xuICAgIHZhciBwYXlsb2FkQnVmID0gZW5jb2RlZFBheWxvYWQucGF5bG9hZEJ1ZjtcbiAgICB2YXIgb3JpZ1BheWxvYWRCdWYgPSBwYXlsb2FkQnVmO1xuICAgIHZhciBwYXlsb2FkRGF0YVN6ID0gcGF5bG9hZEJ1Zi5sZW5ndGg7XG4gICAgLy8gU2l6ZSBvZiBkYXRhIHBheWxvYWQgdGhhdCBjYW4gYmUgaW5jbHVkZWQgaW4gdGhlIGZpcnN0L2Jhc2UgcmVxdWVzdFxuICAgIHZhciBtYXhFeHBhbmRlZFN6ID0gYmFzZURhdGFTeiArIGV4dHJhRGF0YU1heEZyYW1lcyAqIGV4dHJhRGF0YUZyYW1lU3o7XG4gICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgIGlmICghcGF5bG9hZERhdGFTeikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheWxvYWQgY291bGQgbm90IGJlIGhhbmRsZWQuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFnZW5lcmljU2lnbmluZyB8fFxuICAgICAgICAhZXh0cmFEYXRhRnJhbWVTeiB8fFxuICAgICAgICAhZXh0cmFEYXRhTWF4RnJhbWVzIHx8XG4gICAgICAgICFwcmVoYXNoQWxsb3dlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHlvdXIgTGF0dGljZSBmaXJtd2FyZS4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoISgwLCB1dGlsXzEuZXhpc3RzSW4pKGN1cnZlVHlwZSwgY3VydmVUeXBlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjdXJ2ZSB0eXBlLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICghKDAsIHV0aWxfMS5leGlzdHNJbikoaGFzaFR5cGUsIGhhc2hUeXBlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBoYXNoIHR5cGUuJyk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIGEgZGVjb2RlciBhdHRhY2hlZCB0byBvdXIgcGF5bG9hZCwgYWRkIGl0IHRvXG4gICAgLy8gdGhlIGRhdGEgZmllbGQgb2YgdGhlIHJlcXVlc3QuXG4gICAgdmFyIGhhc0RlY29kZXIgPSAoZGVjb2RlciAmJiBjYWxsZGF0YURlY29kaW5nICYmIGRlY29kZXIubGVuZ3RoIDw9IGNhbGxkYXRhRGVjb2RpbmcubWF4U3opO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGF5bG9hZCBBTkQgZGVjb2RlciBkYXRhIGZpdHMgaW4gdGhlIGZpcm13YXJlIGJ1ZmZlci5cbiAgICAvLyBJZiBpdCBkb2Vzbid0LCB3ZSBjYW4ndCBpbmNsdWRlIHRoZSBkZWNvZGVyIGJlY2F1c2UgdGhlIHBheWxvYWQgd2lsbCBsaWtlbHlcbiAgICAvLyBiZSBwcmUtaGFzaGVkIGFuZCB0aGUgZGVjb2RlciBkYXRhIGlzbid0IHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gc2lnbi5cbiAgICB2YXIgZGVjb2RlckZpdHMgPSAoaGFzRGVjb2RlciAmJiBwYXlsb2FkQnVmLmxlbmd0aCArIGRlY29kZXIubGVuZ3RoIDw9IG1heEV4cGFuZGVkU3opO1xuICAgIGlmIChoYXNEZWNvZGVyICYmIGRlY29kZXJGaXRzKSB7XG4gICAgICAgIHZhciBkZWNvZGVyQnVmID0gQnVmZmVyLmFsbG9jKDggKyBkZWNvZGVyLmxlbmd0aCk7XG4gICAgICAgIC8vIEZpcnN0IHdyaXRlIHRoIHJlc2VydmVkIHdvcmRcbiAgICAgICAgZGVjb2RlckJ1Zi53cml0ZVVJbnQzMkxFKGNhbGxkYXRhRGVjb2RpbmcucmVzZXJ2ZWQsIDApO1xuICAgICAgICAvLyBUaGVuIHdyaXRlIHNpemUsIHRoZW4gdGhlIGRhdGFcbiAgICAgICAgZGVjb2RlckJ1Zi53cml0ZVVJbnQzMkxFKGRlY29kZXIubGVuZ3RoLCA0KTtcbiAgICAgICAgQnVmZmVyLmZyb20oZGVjb2RlcikuY29weShkZWNvZGVyQnVmLCA4KTtcbiAgICAgICAgcGF5bG9hZEJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3BheWxvYWRCdWYsIGRlY29kZXJCdWZdKTtcbiAgICB9XG4gICAgLy8gRWQyNTUxOSBzcGVjaWZpYyBzYW5pdHkgY2hlY2tzXG4gICAgaWYgKGN1cnZlVHlwZSA9PT0gY3VydmVUeXBlcy5FRDI1NTE5KSB7XG4gICAgICAgIGlmIChoYXNoVHlwZSAhPT0gaGFzaFR5cGVzLk5PTkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmluZyBvbiBlZDI1NTE5IHJlcXVpcmVzIHVuaGFzaGVkIG1lc3NhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduZXJQYXRoLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgaWYgKGlkeCA8IGNvbnN0YW50c18xLkhBUkRFTkVEX09GRlNFVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmluZyBvbiBlZDI1NTE5IHJlcXVpcmVzIGFsbCBzaWduZXIgcGF0aCBpbmRpY2VzIGJlIGhhcmRlbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQkxTMTJfMzgxIHNwZWNpZmljIHByb2Nlc3NpbmdcbiAgICBlbHNlIGlmIChjdXJ2ZVR5cGUgPT09IGN1cnZlVHlwZXMuQkxTMTJfMzgxX0cyKSB7XG4gICAgICAgIC8vIEZvciBCTFMgc2lnbmluZyB3ZSBuZWVkIHRvIHByZWZpeCA0IGJ5dGVzIHRvIHJlcHJlc2VudCB0aGVcbiAgICAgICAgLy8gZG9tYWluIHNlcGFyYXRvciAoRFNUKS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgd2UgdXNlIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIHZhbHVlIG9mIERTVF9OVUwuXG4gICAgICAgIHZhciBibHNEc3RCdWYgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIGJsc0RzdEJ1Zi53cml0ZVVJbnQzMkxFKGJsc0RzdCk7XG4gICAgICAgIHBheWxvYWRCdWYgPSBCdWZmZXIuY29uY2F0KFtibHNEc3RCdWYsIHBheWxvYWRCdWZdKTtcbiAgICAgICAgcGF5bG9hZERhdGFTeiArPSBibHNEc3RCdWYubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBCdWlsZCB0aGUgcmVxdWVzdCBidWZmZXIgd2l0aCBtZXRhZGF0YSBhbmQgdGhlbiB0aGUgcGF5bG9hZCB0byBzaWduLlxuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoYmFzZVJlcVN6KTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBidWYud3JpdGVVSW50MzJMRShlbmNvZGluZywgb2ZmKTtcbiAgICBvZmYgKz0gNDtcbiAgICBidWYud3JpdGVVSW50OChoYXNoVHlwZSwgb2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICBidWYud3JpdGVVSW50OChjdXJ2ZVR5cGUsIG9mZik7XG4gICAgb2ZmICs9IDE7XG4gICAgdmFyIHNpZ25lclBhdGhCdWYgPSAoMCwgdXRpbF8xLmJ1aWxkU2lnbmVyUGF0aEJ1Zikoc2lnbmVyUGF0aCwgdmFyQWRkclBhdGhTekFsbG93ZWQpO1xuICAgIHNpZ25lclBhdGhCdWYuY29weShidWYsIG9mZik7XG4gICAgb2ZmICs9IHNpZ25lclBhdGhCdWYubGVuZ3RoO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KG9taXRQdWJrZXkgPyAxIDogMCwgb2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICAvLyBGbG93IGRhdGEgaW50byBleHRyYURhdGEgcmVxdWVzdHMgaWYgYXBwbGljYWJsZVxuICAgIHZhciBleHRyYURhdGFQYXlsb2FkcyA9IFtdO1xuICAgIHZhciBwcmVoYXNoID0gbnVsbDtcbiAgICB2YXIgZGlkUHJlaGFzaCA9IGZhbHNlO1xuICAgIGlmIChwYXlsb2FkQnVmLmxlbmd0aCA+IGJhc2VEYXRhU3opIHtcbiAgICAgICAgaWYgKHByZWhhc2hBbGxvd2VkICYmIHBheWxvYWRCdWYubGVuZ3RoID4gbWF4RXhwYW5kZWRTeikge1xuICAgICAgICAgICAgLy8gSWYgd2UgcHJlaGFzaCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBmdWxsIHBheWxvYWQgc2l6ZVxuICAgICAgICAgICAgYnVmLndyaXRlVUludDE2TEUocGF5bG9hZEJ1Zi5sZW5ndGgsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgICAgIGRpZFByZWhhc2ggPSB0cnVlO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSB0byBwcmVoYXNoLCBvbmx5IGhhc2ggdGhlIGFjdHVhbCBwYXlsb2FkIGRhdGEsIGkuZS4gZXhjbHVkZVxuICAgICAgICAgICAgLy8gYW55IG9wdGlvbmFsIGNhbGxkYXRhIGRlY29kZXIgZGF0YS5cbiAgICAgICAgICAgIHZhciBwYXlsb2FkRGF0YSA9IHBheWxvYWRCdWYuc2xpY2UoMCwgcGF5bG9hZERhdGFTeik7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHBheWxvYWQgaXMgdG9vIGxhcmdlIHRvIHNlbmQsIGJ1dCB0aGUgTGF0dGljZSBhbGxvd3MgYSBwcmVoYXNoZWQgbWVzc2FnZSwgZG8gdGhhdFxuICAgICAgICAgICAgaWYgKGhhc2hUeXBlID09PSBoYXNoVHlwZXMuTk9ORSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIGRvbmUgZm9yIEVEMjU1MTkgc2lnbmluZywgd2hpY2ggbXVzdCBzaWduIHRoZSBmdWxsIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIHRvIHNlbmQgYW5kIGNvdWxkIG5vdCBiZSBwcmVoYXNoZWQgKGhhc2hUeXBlPU5PTkUpLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzaFR5cGUgPT09IGhhc2hUeXBlcy5LRUNDQUsyNTYpIHtcbiAgICAgICAgICAgICAgICBwcmVoYXNoID0gQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKHBheWxvYWREYXRhKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzaFR5cGUgPT09IGhhc2hUeXBlcy5TSEEyNTYpIHtcbiAgICAgICAgICAgICAgICBwcmVoYXNoID0gQnVmZmVyLmZyb20oKDAsIHNoYV8xLnNoYTI1NikoKS51cGRhdGUocGF5bG9hZERhdGEpLmRpZ2VzdCgnaGV4JyksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaGFzaCB0eXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3BsaXQgb3ZlcmZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSBmcmFtZXNcbiAgICAgICAgICAgIHZhciBmcmFtZXNfMSA9ICgwLCB1dGlsXzEuc3BsaXRGcmFtZXMpKHBheWxvYWRCdWYuc2xpY2UoYmFzZURhdGFTeiksIGV4dHJhRGF0YUZyYW1lU3opO1xuICAgICAgICAgICAgZnJhbWVzXzEuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3pMRSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgICAgICBzekxFLndyaXRlVUludDMyTEUoZnJhbWUubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICBleHRyYURhdGFQYXlsb2Fkcy5wdXNoKEJ1ZmZlci5jb25jYXQoW3N6TEUsIGZyYW1lXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgZGlkbid0IHByZWhhc2gsIHdlIGtub3cgdGhlIGZ1bGwgcmVxdWVzdCAoaW5jbHVkaW5nIGNhbGxkYXRhIGluZm8pIGZpdHMuXG4gICAgLy8gU2V0IHRoZSBwYXlsb2FkIHNpemUgdG8gb25seSBpbmNsdWRlIG1lc3NhZ2UgZGF0YS4gVGhpcyB3aWxsIGluZm9ybSBmaXJtd2FyZVxuICAgIC8vIHdoZXJlIHRvIHNsaWNlIG9mZiBjYWxsZGF0YSBpbmZvLlxuICAgIGlmICghZGlkUHJlaGFzaCkge1xuICAgICAgICBidWYud3JpdGVVSW50MTZMRShwYXlsb2FkRGF0YVN6LCBvZmYpO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIG1lc3NhZ2UgaGFkIHRvIGJlIHByZWhhc2hlZCwgd2Ugd2lsbCBvbmx5IGNvcHkgdGhlIGhhc2ggZGF0YSBpbnRvIHRoZSByZXF1ZXN0LlxuICAgIC8vIE90aGVyd2lzZSBjb3B5IGFzIG1hbnkgcGF5bG9hZCBieXRlcyBpbnRvIHRoZSByZXF1ZXN0IGFzIHBvc3NpYmxlLiBGb2xsb3cgdXAgZGF0YVxuICAgIC8vIGZyb20gYGZyYW1lc2Agd2lsbCBjb21lIGluIGZvbGxvdyB1cCByZXF1ZXN0cy5cbiAgICB2YXIgdG9Db3B5ID0gcHJlaGFzaCA/IHByZWhhc2ggOiBwYXlsb2FkQnVmO1xuICAgIHRvQ29weS5jb3B5KGJ1Ziwgb2ZmKTtcbiAgICAvLyBSZXR1cm4gYWxsIHRoZSBuZWNlc3NhcnkgZGF0YVxuICAgIHJldHVybiB7XG4gICAgICAgIHBheWxvYWQ6IGJ1ZixcbiAgICAgICAgZXh0cmFEYXRhUGF5bG9hZHM6IGV4dHJhRGF0YVBheWxvYWRzLFxuICAgICAgICBzY2hlbWE6IHByb3RvY29sXzEuTGF0dGljZVNpZ25TY2hlbWEuZ2VuZXJpYyxcbiAgICAgICAgY3VydmVUeXBlOiBjdXJ2ZVR5cGUsXG4gICAgICAgIGVuY29kaW5nVHlwZTogZW5jb2RpbmdUeXBlLFxuICAgICAgICBoYXNoVHlwZTogaGFzaFR5cGUsXG4gICAgICAgIG9taXRQdWJrZXk6IG9taXRQdWJrZXksXG4gICAgICAgIG9yaWdQYXlsb2FkQnVmOiBvcmlnUGF5bG9hZEJ1ZixcbiAgICB9O1xufTtcbmV4cG9ydHMuYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3QgPSBidWlsZEdlbmVyaWNTaWduaW5nTXNnUmVxdWVzdDtcbnZhciBwYXJzZUdlbmVyaWNTaWduaW5nUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzLCBvZmYsIHJlcSkge1xuICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgIHB1YmtleTogbnVsbCxcbiAgICAgICAgc2lnOiBudWxsLFxuICAgIH07XG4gICAgLy8gUGFyc2UgQklQNDQgcGF0aFxuICAgIC8vIFBhcnNlIHB1YmtleSBhbmQgdGhlbiBzaWdcbiAgICBpZiAocmVxLmN1cnZlVHlwZSA9PT0gaW5kZXhfMS5Db25zdGFudHMuU0lHTklORy5DVVJWRVMuU0VDUDI1NksxKSB7XG4gICAgICAgIC8vIEhhbmRsZSBgR3BFY2NQdWJrZXkyNTZfdGBcbiAgICAgICAgaWYgKCFyZXEub21pdFB1YmtleSkge1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcmVzLnJlYWRVSW50OChvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IDB4MDIgfHwgY29tcHJlc3Npb24gPT09IDB4MDMpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21wcmVzc2VkIGtleSAtIG9ubHkgY29weSB4XG4gICAgICAgICAgICAgICAgcGFyc2VkLnB1YmtleSA9IEJ1ZmZlci5hbGxvYygzMyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnB1YmtleS53cml0ZVVJbnQ4KGNvbXByZXNzaW9uLCAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2xpY2Uob2ZmLCBvZmYgKyAzMikuY29weShwYXJzZWQucHVia2V5LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXByZXNzaW9uID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgLy8gVW5jb21wcmVzc2VkIGtleVxuICAgICAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkgPSBCdWZmZXIuYWxsb2MoNjUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkud3JpdGVVSW50OChjb21wcmVzc2lvbiwgMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNsaWNlKG9mZikuY29weShwYXJzZWQucHVia2V5LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIGNvbXByZXNzaW9uIGJ5dGUgaW4gc2lnbmluZyByZXNwb25zZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSA2NDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNraXAgcHVia2V5IHNlY3Rpb25cbiAgICAgICAgICAgIG9mZiArPSA2NTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYEdwRUNEU0FTaWdfdGBcbiAgICAgICAgcGFyc2VkLnNpZyA9ICgwLCB1dGlsXzEucGFyc2VERVIpKHJlcy5zbGljZShvZmYsIG9mZiArIDIgKyByZXNbb2ZmICsgMV0pKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBsZWFkaW5nIHplcm9zIGluIHNpZ25hdHVyZSBjb21wb25lbnRzIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgcmVzdWx0IGlzIGEgNjQgYnl0ZSBzaWdcbiAgICAgICAgcGFyc2VkLnNpZy5yID0gKDAsIHV0aWxfMS5maXhMZW4pKHBhcnNlZC5zaWcuciwgMzIpO1xuICAgICAgICBwYXJzZWQuc2lnLnMgPSAoMCwgdXRpbF8xLmZpeExlbikocGFyc2VkLnNpZy5zLCAzMik7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYW4gRVZNIHJlcXVlc3QsIHdlIHdhbnQgdG8gYWRkIGEgYHZgLiBPdGhlciByZXF1ZXN0XG4gICAgICAgIC8vIHR5cGVzIGRvIG5vdCByZXF1aXJlIHRoaXMgYWRkaXRpb25hbCBzaWduYXR1cmUgcGFyYW0uXG4gICAgICAgIGlmIChyZXEuZW5jb2RpbmdUeXBlID09PSBpbmRleF8xLkNvbnN0YW50cy5TSUdOSU5HLkVOQ09ESU5HUy5FVk0pIHtcbiAgICAgICAgICAgIHZhciB2Qm4gPSAoMCwgdXRpbF8xLmdldFYpKHJlcS5vcmlnUGF5bG9hZEJ1ZiwgcGFyc2VkKTtcbiAgICAgICAgICAgIC8vIE5PVEU6IEZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5IHJlYXNvbnMgd2UgYXJlIHJldHVybmluZ1xuICAgICAgICAgICAgLy8gYSBCdWZmZXIgZm9yIGB2YCBoZXJlLiBJbiB0aGUgZnV0dXJlLCB3ZSB3aWxsIHN3aXRjaCB0b1xuICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGB2YCBhcyBhIEJOIGFuZCBgcmAsYHNgIGFzIEJ1ZmZlcnMgKHRoZXkgYXJlIGhleFxuICAgICAgICAgICAgLy8gc3RyaW5ncyByaWdodCBub3cpLlxuICAgICAgICAgICAgcGFyc2VkLnNpZy52ID0gdkJuLnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVxLmN1cnZlVHlwZSA9PT0gaW5kZXhfMS5Db25zdGFudHMuU0lHTklORy5DVVJWRVMuRUQyNTUxOSkge1xuICAgICAgICBpZiAoIXJlcS5vbWl0UHVia2V5KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYEdwRWREU0FQdWJrZXlfdGBcbiAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICAgICAgICAgICAgcmVzLnNsaWNlKG9mZiwgb2ZmICsgMzIpLmNvcHkocGFyc2VkLnB1YmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDMyO1xuICAgICAgICAvLyBIYW5kbGUgYEdwRWREU0FTaWdfdGBcbiAgICAgICAgcGFyc2VkLnNpZyA9IHtcbiAgICAgICAgICAgIHI6IHJlcy5zbGljZShvZmYsIG9mZiArIDMyKSxcbiAgICAgICAgICAgIHM6IHJlcy5zbGljZShvZmYgKyAzMiwgb2ZmICsgNjQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXEuY3VydmVUeXBlID09PSBpbmRleF8xLkNvbnN0YW50cy5TSUdOSU5HLkNVUlZFUy5CTFMxMl8zODFfRzIpIHtcbiAgICAgICAgaWYgKCFyZXEub21pdFB1YmtleSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGBHcEJMUzEyXzM4MV9HMVB1Yl90YFxuICAgICAgICAgICAgcGFyc2VkLnB1YmtleSA9IEJ1ZmZlci5hbGxvYyg0OCk7XG4gICAgICAgICAgICByZXMuc2xpY2Uob2ZmLCBvZmYgKyA0OCkuY29weShwYXJzZWQucHVia2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gNDg7XG4gICAgICAgIC8vIEhhbmRsZSBgR3BCTFMxMl8zODFfRzJTaWdfdGBcbiAgICAgICAgcGFyc2VkLnNpZyA9IEJ1ZmZlci5hbGxvYyg5Nik7XG4gICAgICAgIHJlcy5zbGljZShvZmYsIG9mZiArIDk2KS5jb3B5KHBhcnNlZC5zaWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjdXJ2ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5leHBvcnRzLnBhcnNlR2VuZXJpY1NpZ25pbmdSZXNwb25zZSA9IHBhcnNlR2VuZXJpY1NpZ25pbmdSZXNwb25zZTtcbnZhciBnZXRFbmNvZGVkUGF5bG9hZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBlbmNvZGluZywgYWxsb3dlZEVuY29kaW5ncykge1xuICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBpbmRleF8xLkNvbnN0YW50cy5TSUdOSU5HLkVOQ09ESU5HUy5OT05FO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGVuY29kaW5nIHR5cGUgc3BlY2lmaWVkIGlzIHN1cHBvcnRlZCBieSBmaXJtd2FyZVxuICAgIGlmICghKDAsIHV0aWxfMS5leGlzdHNJbikoZW5jb2RpbmcsIGFsbG93ZWRFbmNvZGluZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2Rpbmcgbm90IHN1cHBvcnRlZCBieSBMYXR0aWNlIGZpcm13YXJlLiBZb3UgbWF5IHdhbnQgdG8gdXBkYXRlLicpO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZEJ1ZjtcbiAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXlsb2FkIGluY2x1ZGVkJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycgJiYgcGF5bG9hZC5zbGljZSgwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICBwYXlsb2FkQnVmID0gQnVmZmVyLmZyb20ocGF5bG9hZC5zbGljZSgyKSwgJ2hleCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGF5bG9hZEJ1ZiA9IEJ1ZmZlci5mcm9tKHBheWxvYWQpO1xuICAgIH1cbiAgICAvLyBCdWlsZCB0aGUgcmVxdWVzdCB3aXRoIHRoZSBzcGVjaWZpZWQgZW5jb2RpbmcgdHlwZVxuICAgIHJldHVybiB7XG4gICAgICAgIHBheWxvYWRCdWY6IHBheWxvYWRCdWYsXG4gICAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICB9O1xufTtcbmV4cG9ydHMuZ2V0RW5jb2RlZFBheWxvYWQgPSBnZXRFbmNvZGVkUGF5bG9hZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlV0aWxzID0gZXhwb3J0cy5Db25zdGFudHMgPSBleHBvcnRzLkNsaWVudCA9IGV4cG9ydHMuQ2FsbGRhdGEgPSB2b2lkIDA7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2NhbGxkYXRhL2luZGV4XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbGRhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4XzEuQ0FMTERBVEE7IH0gfSk7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLkNsaWVudDsgfSB9KTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnN0YW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuRVhURVJOQUw7IH0gfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0aWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsXzEuRVhURVJOQUw7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGF0dGljZUNvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VjdXJlTWVzc2FnZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2EsIF9iLCBfYztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvdG9jb2xDb25zdGFudHMgPSBleHBvcnRzLkxhdHRpY2VFbmNEYXRhU2NoZW1hID0gZXhwb3J0cy5MYXR0aWNlU2lnbkJsc0RzdCA9IGV4cG9ydHMuTGF0dGljZVNpZ25FbmNvZGluZyA9IGV4cG9ydHMuTGF0dGljZVNpZ25DdXJ2ZSA9IGV4cG9ydHMuTGF0dGljZVNpZ25IYXNoID0gZXhwb3J0cy5MYXR0aWNlU2lnblNjaGVtYSA9IGV4cG9ydHMuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcgPSBleHBvcnRzLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTGF0dGljZU1zZ1R5cGUgPSBleHBvcnRzLkxhdHRpY2VQcm90b2NvbFZlcnNpb24gPSBleHBvcnRzLkxhdHRpY2VTZWN1cmVNc2dUeXBlID0gZXhwb3J0cy5MYXR0aWNlUmVzcG9uc2VDb2RlID0gdm9pZCAwO1xudmFyIExhdHRpY2VSZXNwb25zZUNvZGU7XG4oZnVuY3Rpb24gKExhdHRpY2VSZXNwb25zZUNvZGUpIHtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJzdWNjZXNzXCJdID0gMF0gPSBcInN1Y2Nlc3NcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJpbnZhbGlkTXNnXCJdID0gMTI4XSA9IFwiaW52YWxpZE1zZ1wiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcInVuc3VwcG9ydGVkVmVyc2lvblwiXSA9IDEyOV0gPSBcInVuc3VwcG9ydGVkVmVyc2lvblwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcImRldmljZUJ1c3lcIl0gPSAxMzBdID0gXCJkZXZpY2VCdXN5XCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1widXNlclRpbWVvdXRcIl0gPSAxMzFdID0gXCJ1c2VyVGltZW91dFwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcInVzZXJEZWNsaW5lZFwiXSA9IDEzMl0gPSBcInVzZXJEZWNsaW5lZFwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcInBhaXJGYWlsZWRcIl0gPSAxMzNdID0gXCJwYWlyRmFpbGVkXCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wicGFpckRpc2FibGVkXCJdID0gMTM0XSA9IFwicGFpckRpc2FibGVkXCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wicGVybWlzc2lvbkRpc2FibGVkXCJdID0gMTM1XSA9IFwicGVybWlzc2lvbkRpc2FibGVkXCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wiaW50ZXJuYWxFcnJvclwiXSA9IDEzNl0gPSBcImludGVybmFsRXJyb3JcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJnY2VUaW1lb3V0XCJdID0gMTM3XSA9IFwiZ2NlVGltZW91dFwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcIndyb25nV2FsbGV0XCJdID0gMTM4XSA9IFwid3JvbmdXYWxsZXRcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJkZXZpY2VMb2NrZWRcIl0gPSAxMzldID0gXCJkZXZpY2VMb2NrZWRcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJkaXNhYmxlZFwiXSA9IDE0MF0gPSBcImRpc2FibGVkXCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wiYWxyZWFkeVwiXSA9IDE0MV0gPSBcImFscmVhZHlcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJpbnZhbGlkRXBoZW1JZFwiXSA9IDE0Ml0gPSBcImludmFsaWRFcGhlbUlkXCI7XG59KShMYXR0aWNlUmVzcG9uc2VDb2RlID0gZXhwb3J0cy5MYXR0aWNlUmVzcG9uc2VDb2RlIHx8IChleHBvcnRzLkxhdHRpY2VSZXNwb25zZUNvZGUgPSB7fSkpO1xudmFyIExhdHRpY2VTZWN1cmVNc2dUeXBlO1xuKGZ1bmN0aW9uIChMYXR0aWNlU2VjdXJlTXNnVHlwZSkge1xuICAgIExhdHRpY2VTZWN1cmVNc2dUeXBlW0xhdHRpY2VTZWN1cmVNc2dUeXBlW1wiY29ubmVjdFwiXSA9IDFdID0gXCJjb25uZWN0XCI7XG4gICAgTGF0dGljZVNlY3VyZU1zZ1R5cGVbTGF0dGljZVNlY3VyZU1zZ1R5cGVbXCJlbmNyeXB0ZWRcIl0gPSAyXSA9IFwiZW5jcnlwdGVkXCI7XG59KShMYXR0aWNlU2VjdXJlTXNnVHlwZSA9IGV4cG9ydHMuTGF0dGljZVNlY3VyZU1zZ1R5cGUgfHwgKGV4cG9ydHMuTGF0dGljZVNlY3VyZU1zZ1R5cGUgPSB7fSkpO1xudmFyIExhdHRpY2VQcm90b2NvbFZlcnNpb247XG4oZnVuY3Rpb24gKExhdHRpY2VQcm90b2NvbFZlcnNpb24pIHtcbiAgICBMYXR0aWNlUHJvdG9jb2xWZXJzaW9uW0xhdHRpY2VQcm90b2NvbFZlcnNpb25bXCJ2MVwiXSA9IDFdID0gXCJ2MVwiO1xufSkoTGF0dGljZVByb3RvY29sVmVyc2lvbiA9IGV4cG9ydHMuTGF0dGljZVByb3RvY29sVmVyc2lvbiB8fCAoZXhwb3J0cy5MYXR0aWNlUHJvdG9jb2xWZXJzaW9uID0ge30pKTtcbnZhciBMYXR0aWNlTXNnVHlwZTtcbihmdW5jdGlvbiAoTGF0dGljZU1zZ1R5cGUpIHtcbiAgICBMYXR0aWNlTXNnVHlwZVtMYXR0aWNlTXNnVHlwZVtcInJlc3BvbnNlXCJdID0gMF0gPSBcInJlc3BvbnNlXCI7XG4gICAgTGF0dGljZU1zZ1R5cGVbTGF0dGljZU1zZ1R5cGVbXCJzZWN1cmVcIl0gPSAyXSA9IFwic2VjdXJlXCI7XG59KShMYXR0aWNlTXNnVHlwZSA9IGV4cG9ydHMuTGF0dGljZU1zZ1R5cGUgfHwgKGV4cG9ydHMuTGF0dGljZU1zZ1R5cGUgPSB7fSkpO1xudmFyIExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZTtcbihmdW5jdGlvbiAoTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlKSB7XG4gICAgTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtcImZpbmFsaXplUGFpcmluZ1wiXSA9IDBdID0gXCJmaW5hbGl6ZVBhaXJpbmdcIjtcbiAgICBMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW1wiZ2V0QWRkcmVzc2VzXCJdID0gMV0gPSBcImdldEFkZHJlc3Nlc1wiO1xuICAgIExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbXCJzaWduXCJdID0gM10gPSBcInNpZ25cIjtcbiAgICBMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW1wiZ2V0V2FsbGV0c1wiXSA9IDRdID0gXCJnZXRXYWxsZXRzXCI7XG4gICAgTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtcImdldEt2UmVjb3Jkc1wiXSA9IDddID0gXCJnZXRLdlJlY29yZHNcIjtcbiAgICBMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW1wiYWRkS3ZSZWNvcmRzXCJdID0gOF0gPSBcImFkZEt2UmVjb3Jkc1wiO1xuICAgIExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbXCJyZW1vdmVLdlJlY29yZHNcIl0gPSA5XSA9IFwicmVtb3ZlS3ZSZWNvcmRzXCI7XG4gICAgTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtcImZldGNoRW5jcnlwdGVkRGF0YVwiXSA9IDEyXSA9IFwiZmV0Y2hFbmNyeXB0ZWREYXRhXCI7XG4gICAgTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtcInRlc3RcIl0gPSAxM10gPSBcInRlc3RcIjtcbn0pKExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlIHx8IChleHBvcnRzLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZSA9IHt9KSk7XG52YXIgTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWc7XG4oZnVuY3Rpb24gKExhdHRpY2VHZXRBZGRyZXNzZXNGbGFnKSB7XG4gICAgTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWdbTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWdbXCJub25lXCJdID0gMF0gPSBcIm5vbmVcIjtcbiAgICBMYXR0aWNlR2V0QWRkcmVzc2VzRmxhZ1tMYXR0aWNlR2V0QWRkcmVzc2VzRmxhZ1tcInNlY3AyNTZrMVB1YmtleVwiXSA9IDNdID0gXCJzZWNwMjU2azFQdWJrZXlcIjtcbiAgICBMYXR0aWNlR2V0QWRkcmVzc2VzRmxhZ1tMYXR0aWNlR2V0QWRkcmVzc2VzRmxhZ1tcImVkMjU1MTlQdWJrZXlcIl0gPSA0XSA9IFwiZWQyNTUxOVB1YmtleVwiO1xuICAgIExhdHRpY2VHZXRBZGRyZXNzZXNGbGFnW0xhdHRpY2VHZXRBZGRyZXNzZXNGbGFnW1wiYmxzMTJfMzgxUHVia2V5XCJdID0gNV0gPSBcImJsczEyXzM4MVB1YmtleVwiO1xufSkoTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcgPSBleHBvcnRzLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnIHx8IChleHBvcnRzLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnID0ge30pKTtcbnZhciBMYXR0aWNlU2lnblNjaGVtYTtcbihmdW5jdGlvbiAoTGF0dGljZVNpZ25TY2hlbWEpIHtcbiAgICBMYXR0aWNlU2lnblNjaGVtYVtMYXR0aWNlU2lnblNjaGVtYVtcImJpdGNvaW5cIl0gPSAwXSA9IFwiYml0Y29pblwiO1xuICAgIExhdHRpY2VTaWduU2NoZW1hW0xhdHRpY2VTaWduU2NoZW1hW1wiZXRoZXJldW1cIl0gPSAxXSA9IFwiZXRoZXJldW1cIjtcbiAgICBMYXR0aWNlU2lnblNjaGVtYVtMYXR0aWNlU2lnblNjaGVtYVtcImV0aGVyZXVtTXNnXCJdID0gM10gPSBcImV0aGVyZXVtTXNnXCI7XG4gICAgTGF0dGljZVNpZ25TY2hlbWFbTGF0dGljZVNpZ25TY2hlbWFbXCJleHRyYURhdGFcIl0gPSA0XSA9IFwiZXh0cmFEYXRhXCI7XG4gICAgTGF0dGljZVNpZ25TY2hlbWFbTGF0dGljZVNpZ25TY2hlbWFbXCJnZW5lcmljXCJdID0gNV0gPSBcImdlbmVyaWNcIjtcbn0pKExhdHRpY2VTaWduU2NoZW1hID0gZXhwb3J0cy5MYXR0aWNlU2lnblNjaGVtYSB8fCAoZXhwb3J0cy5MYXR0aWNlU2lnblNjaGVtYSA9IHt9KSk7XG52YXIgTGF0dGljZVNpZ25IYXNoO1xuKGZ1bmN0aW9uIChMYXR0aWNlU2lnbkhhc2gpIHtcbiAgICBMYXR0aWNlU2lnbkhhc2hbTGF0dGljZVNpZ25IYXNoW1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgTGF0dGljZVNpZ25IYXNoW0xhdHRpY2VTaWduSGFzaFtcImtlY2NhazI1NlwiXSA9IDFdID0gXCJrZWNjYWsyNTZcIjtcbiAgICBMYXR0aWNlU2lnbkhhc2hbTGF0dGljZVNpZ25IYXNoW1wic2hhMjU2XCJdID0gMl0gPSBcInNoYTI1NlwiO1xufSkoTGF0dGljZVNpZ25IYXNoID0gZXhwb3J0cy5MYXR0aWNlU2lnbkhhc2ggfHwgKGV4cG9ydHMuTGF0dGljZVNpZ25IYXNoID0ge30pKTtcbnZhciBMYXR0aWNlU2lnbkN1cnZlO1xuKGZ1bmN0aW9uIChMYXR0aWNlU2lnbkN1cnZlKSB7XG4gICAgTGF0dGljZVNpZ25DdXJ2ZVtMYXR0aWNlU2lnbkN1cnZlW1wic2VjcDI1NmsxXCJdID0gMF0gPSBcInNlY3AyNTZrMVwiO1xuICAgIExhdHRpY2VTaWduQ3VydmVbTGF0dGljZVNpZ25DdXJ2ZVtcImVkMjU1MTlcIl0gPSAxXSA9IFwiZWQyNTUxOVwiO1xuICAgIExhdHRpY2VTaWduQ3VydmVbTGF0dGljZVNpZ25DdXJ2ZVtcImJsczEyXzM4MVwiXSA9IDJdID0gXCJibHMxMl8zODFcIjtcbn0pKExhdHRpY2VTaWduQ3VydmUgPSBleHBvcnRzLkxhdHRpY2VTaWduQ3VydmUgfHwgKGV4cG9ydHMuTGF0dGljZVNpZ25DdXJ2ZSA9IHt9KSk7XG52YXIgTGF0dGljZVNpZ25FbmNvZGluZztcbihmdW5jdGlvbiAoTGF0dGljZVNpZ25FbmNvZGluZykge1xuICAgIExhdHRpY2VTaWduRW5jb2RpbmdbTGF0dGljZVNpZ25FbmNvZGluZ1tcIm5vbmVcIl0gPSAxXSA9IFwibm9uZVwiO1xuICAgIExhdHRpY2VTaWduRW5jb2RpbmdbTGF0dGljZVNpZ25FbmNvZGluZ1tcInNvbGFuYVwiXSA9IDJdID0gXCJzb2xhbmFcIjtcbiAgICBMYXR0aWNlU2lnbkVuY29kaW5nW0xhdHRpY2VTaWduRW5jb2RpbmdbXCJldm1cIl0gPSA0XSA9IFwiZXZtXCI7XG4gICAgTGF0dGljZVNpZ25FbmNvZGluZ1tMYXR0aWNlU2lnbkVuY29kaW5nW1wiZXRoX2RlcG9zaXRcIl0gPSA1XSA9IFwiZXRoX2RlcG9zaXRcIjtcbn0pKExhdHRpY2VTaWduRW5jb2RpbmcgPSBleHBvcnRzLkxhdHRpY2VTaWduRW5jb2RpbmcgfHwgKGV4cG9ydHMuTGF0dGljZVNpZ25FbmNvZGluZyA9IHt9KSk7XG52YXIgTGF0dGljZVNpZ25CbHNEc3Q7XG4oZnVuY3Rpb24gKExhdHRpY2VTaWduQmxzRHN0KSB7XG4gICAgTGF0dGljZVNpZ25CbHNEc3RbTGF0dGljZVNpZ25CbHNEc3RbXCJOVUxcIl0gPSAxXSA9IFwiTlVMXCI7XG4gICAgTGF0dGljZVNpZ25CbHNEc3RbTGF0dGljZVNpZ25CbHNEc3RbXCJQT1BcIl0gPSAyXSA9IFwiUE9QXCI7XG59KShMYXR0aWNlU2lnbkJsc0RzdCA9IGV4cG9ydHMuTGF0dGljZVNpZ25CbHNEc3QgfHwgKGV4cG9ydHMuTGF0dGljZVNpZ25CbHNEc3QgPSB7fSkpO1xudmFyIExhdHRpY2VFbmNEYXRhU2NoZW1hO1xuKGZ1bmN0aW9uIChMYXR0aWNlRW5jRGF0YVNjaGVtYSkge1xuICAgIExhdHRpY2VFbmNEYXRhU2NoZW1hW0xhdHRpY2VFbmNEYXRhU2NoZW1hW1wiZWlwMjMzNVwiXSA9IDBdID0gXCJlaXAyMzM1XCI7XG59KShMYXR0aWNlRW5jRGF0YVNjaGVtYSA9IGV4cG9ydHMuTGF0dGljZUVuY0RhdGFTY2hlbWEgfHwgKGV4cG9ydHMuTGF0dGljZUVuY0RhdGFTY2hlbWEgPSB7fSkpO1xuZXhwb3J0cy5Qcm90b2NvbENvbnN0YW50cyA9IHtcbiAgICAvLyBMYXR0aWNlIGZpcm13YXJlIHVzZXMgYSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gdmVjdG9yIGZvclxuICAgIC8vIG1lc3NhZ2UgZW5jcnlwdGlvbi9kZWNyeXB0aW9uLiBUaGlzIGlzIGdlbmVyYWxseSBjb25zaWRlcmVkXG4gICAgLy8gZmluZSBiZWNhdXNlIGVhY2ggZW5jcnlwdGlvbi9kZWNyeXB0aW9uIHVzZXMgYSB1bmlxdWUgZW5jcnlwdGlvblxuICAgIC8vIHNlY3JldCAoZGVyaXZlZCBmcm9tIHRoZSBwZXItbWVzc2FnZSBlcGhlbWVyYWwga2V5IHBhaXIpLlxuICAgIGFlc0l2OiBbXG4gICAgICAgIDB4NmQsIDB4NzksIDB4NzMsIDB4NjUsIDB4NjMsIDB4NzIsIDB4NjUsIDB4NzQsIDB4NzAsIDB4NjEsIDB4NzMsIDB4NzMsXG4gICAgICAgIDB4NzcsIDB4NmYsIDB4NzIsIDB4NjQsXG4gICAgXSxcbiAgICAvLyBDb25zdGFudCBzaXplIG9mIGFkZHJlc3MgYnVmZmVycyBmcm9tIHRoZSBMYXR0aWNlLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHNpemUgYWxzbyBjYXB0dXJlcyBwdWJsaWMga2V5cyByZXR1cm5lZFxuICAgIC8vIGJ5IHRoZSBMYXR0aWNlIChhZGRyZXNzZXMgPSBzdHJpbmdzLCBwdWJrZXlzID0gYnVmZmVycylcbiAgICBhZGRyU3RyTGVuOiAxMjksXG4gICAgLy8gU3RhdHVzIG9mIHRoZSBjbGllbnQncyBwYWlyaW5nIHdpdGggdGhlIHRhcmdldCBMYXR0aWNlXG4gICAgcGFpcmluZ1N0YXR1czoge1xuICAgICAgICBub3RQYWlyZWQ6IDB4MDAsXG4gICAgICAgIHBhaXJlZDogMHgwMSxcbiAgICB9LFxuICAgIC8vIFJlc3BvbnNlIHR5cGVzLCBjb2RlcywgYW5kIGVycm9yIG1lc3NhZ2VzXG4gICAgcmVzcG9uc2VNc2c6IChfYSA9IHt9LFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLnN1Y2Nlc3NdID0gJycsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUuaW52YWxpZE1zZ10gPSAnSW52YWxpZCBSZXF1ZXN0JyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS51bnN1cHBvcnRlZFZlcnNpb25dID0gJ1Vuc3VwcG9ydGVkIFZlcnNpb24nLFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLmRldmljZUJ1c3ldID0gJ0RldmljZSBCdXN5JyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS51c2VyVGltZW91dF0gPSAnVGltZW91dCB3YWl0aW5nIGZvciB1c2VyJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS51c2VyRGVjbGluZWRdID0gJ1JlcXVlc3QgZGVjbGluZWQgYnkgdXNlcicsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUucGFpckZhaWxlZF0gPSAnUGFpcmluZyBmYWlsZWQnLFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLnBhaXJEaXNhYmxlZF0gPSAnUGFpcmluZyBpcyBjdXJyZW50bHkgZGlzYWJsZWQnLFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLnBlcm1pc3Npb25EaXNhYmxlZF0gPSAnQXV0b21hdGVkIHNpZ25pbmcgaXMgY3VycmVudGx5IGRpc2FibGVkJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5pbnRlcm5hbEVycm9yXSA9ICdEZXZpY2UgRXJyb3InLFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLmdjZVRpbWVvdXRdID0gJ0RldmljZSBUaW1lb3V0JyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS53cm9uZ1dhbGxldF0gPSAnQWN0aXZlIHdhbGxldCBkb2VzIG5vdCBtYXRjaCByZXF1ZXN0JyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5kZXZpY2VMb2NrZWRdID0gJ0RldmljZSBMb2NrZWQnLFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLmRpc2FibGVkXSA9ICdGZWF0dXJlIERpc2FibGVkJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5hbHJlYWR5XSA9ICdSZWNvcmQgYWxyZWFkeSBleGlzdHMgb24gZGV2aWNlJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5pbnZhbGlkRXBoZW1JZF0gPSAnUmVxdWVzdCBmYWlsZWQgLSBuZWVkcyByZXN5bmMnLFxuICAgICAgICBfYSksXG4gICAgbXNnU2l6ZXM6IHtcbiAgICAgICAgLy8gR2VuZXJhbCBtZXNzYWdlIGhlYWRlciBzaXplLiBWYWxpZCBmb3IgYWxsIExhdHRpY2UgbWVzc2FnZXNcbiAgICAgICAgaGVhZGVyOiA4LFxuICAgICAgICAvLyBDaGVja3N1bSBtdXN0IGJlIGFwcGVuZGVkIHRvIGVhY2ggbWVzc2FnZVxuICAgICAgICBjaGVja3N1bTogNCxcbiAgICAgICAgLy8gTGF0dGljZSBzZWN1cmUgbWVzc2FnZSBjb25zdGFudHMuIEFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgU0RLXG4gICAgICAgIC8vIGFyZSBzZWN1cmUgbWVzc2FnZXMuXG4gICAgICAgIHNlY3VyZToge1xuICAgICAgICAgICAgLy8gU2l6ZXMgb2YgZnVsbCBwYXlsb2FkcyBmb3Igc2VjdXJlIG1lc3NhZ2VzXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBbIHJlcXVlc3RUeXBlICgxIGJ5dGUpIHwgcHVia2V5ICg2NSBieXRlcykgXVxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiA2NixcbiAgICAgICAgICAgICAgICAgICAgLy8gWyByZXF1ZXN0VHlwZSAoMSBieXRlKSB8IGVwaGVtZXJhbElkICg0IGJ5dGVzKSB8IGVuY3J5cHRlZERhdGEgKDE3MjggYnl0ZXMpIF1cbiAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkOiAxNzMzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSByZXNwb25zZSBwYXlsb2FkIGFsd2F5cyBoYXMgc3RhdHVzIGNvZGUgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgYnl0ZS4gVGhpcyBieXRlIGlzIHJlbW92ZWQgYXMgcGFydCBvZiBgcmVxdWVzdGAsIGluc2lkZVxuICAgICAgICAgICAgICAgIC8vIGBwYXJzZUxhdHRpY2UxUmVzcG9uc2VgLiBUaGVzZSBjb25zdGFudHMgaW5jbHVkZSB0aGUgc3RhdHVzXG4gICAgICAgICAgICAgICAgLy8gY29kZSBieXRlLlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Q6IDIxNSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jcnlwdGVkIHJlc3BvbnNlcyBhcmUgYXMgZm9sbG93czpcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5jcnlwdGVkRGF0YSAoMTcyOCkgfCBlbXB0eSAoMTcyOClcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxhdHRlciBoYWxmIGlzIGVtcHR5IGR1ZSB0byBhbiBpbnZhbGlkIHR5cGUgZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBMYXR0aWNlIGZpcm13YXJlLiAoU29tZW9uZSBtYWRlIGEgQyBgc3RydWN0YCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgYHVuaW9uYCwgb29wcykuXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZDogMzQ1NyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFNpemVzIGZvciBkYXRhIGluc2lkZSBzZWN1cmUgbWVzc2FnZSBwYXlsb2Fkc1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIC8vIEFsbCByZXF1ZXN0cyBhbHNvIGhhdmUgYSBgcmVxdWVzdENvZGVgLCB3aGljaCBpcyBvbWl0dGVkXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGVzZSBjb25zdGFudHMuXG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiA2NSxcbiAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkOiAoX2IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGVuY3J5cHRlZCByZXF1ZXN0cyBhcmUgZW5jcnlwdGVkIGludG8gYSAxNzI4IGJ5dGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkRGF0YTogMTcyOFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluZGl2aWR1YWwgcmVxdWVzdCB0eXBlcyBoYXZlIGRpZmZlcmVudCBkYXRhIHNpemVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgX2JbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmZpbmFsaXplUGFpcmluZ10gPSA5OSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5nZXRBZGRyZXNzZXNdID0gNTQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYltMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuc2lnbl0gPSAxNjgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2JbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmdldFdhbGxldHNdID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5nZXRLdlJlY29yZHNdID0gOSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5hZGRLdlJlY29yZHNdID0gMTM5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5yZW1vdmVLdlJlY29yZHNdID0gNDA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2JbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmZldGNoRW5jcnlwdGVkRGF0YV0gPSAxMDI1LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2JbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLnRlc3RdID0gNTA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2IpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gQWxsIHJlc3BvbnNlcyBhbHNvIGhhdmUgYSBgcmVzcG9uc2VDb2RlYCwgd2hpY2ggaXMgb21pdHRlZFxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlc2UgY29uc3RhbnRzLlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZDogKF9jID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZERhdGE6IDE3MjhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGRlY3J5cHRlZCwgdGhlIGRhdGEgc2l6ZSBvZiB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSByZXF1ZXN0IHR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBBbGwgcmVxdWVzdHMgYWxzbyBoYXZlIGVwaGVtZXJhbFB1YmxpY0tleSAoNjUgYnl0ZXMpIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tzdW0gKDQgYnl0ZXMpLCB3aGljaCBhcmUgZXhjbHVkZWQgZnJvbSB0aGVzZSBzaXplcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5maW5hbGl6ZVBhaXJpbmddID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5nZXRBZGRyZXNzZXNdID0gMTI5MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5zaWduXSA9IDEwOTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0V2FsbGV0c10gPSAxNDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0S3ZSZWNvcmRzXSA9IDEzOTUsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuYWRkS3ZSZWNvcmRzXSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUucmVtb3ZlS3ZSZWNvcmRzXSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZmV0Y2hFbmNyeXB0ZWREYXRhXSA9IDE2MDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUudGVzdF0gPSAxNjQ2LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2MpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0ID0gZXhwb3J0cy5jb25uZWN0U2VjdXJlUmVxdWVzdCA9IHZvaWQgMDtcbi8qKlxuICogQWxsIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIExhdHRpY2UgZnJvbSB0aGlzIFNESyB3aWxsIGJlXG4gKiBcInNlY3VyZSBtZXNzYWdlc1wiLCBvZiB3aGljaCB0aGVyZSBhcmUgdHdvIHR5cGVzOlxuICpcbiAqIDEuIENvbm5lY3QgcmVxdWVzdHMgYXJlICp1bmVuY3J5cHRlZCogYW5kIHNlcnZlIHRvIGVzdGFibGlzaFxuICogICAgYSBjb25uZWN0aW9uIGJldHdlZW4gdGhlIFNESyBDbGllbnQgaW5zdGFuY2UgYW5kIHRoZSB0YXJnZXRcbiAqICAgIExhdHRpY2UuIElmIHRoZSBjbGllbnQgaXMgYWxyZWFkeSBwYWlyZWQgdG8gdGhlIHRhcmdldCBMYXR0aWNlLFxuICogICAgdGhlIHJlc3BvbnNlIHdpbGwgaW5kaWNhdGUgdGhhdC4gSWYgdGhlIGNsaWVudCBoYXMgbmV2ZXIgcGFpcmVkXG4gKiAgICB3aXRoIHRoaXMgTGF0dGljZSwgdGhlIExhdHRpY2Ugd2lsbCBnbyBpbnRvIFwicGFpcmluZyBtb2RlXCIgYW5kXG4gKiAgICB3aWxsIGV4cGVjdCBhIGZvbGxvdyB1cCBgZmluYWxpemVQYWlyaW5nYCByZXF1ZXN0LCB3aGljaCBpc1xuICogICAgYW4gZW5jcnlwdGVkIHJlcXVlc3QuIFRoaXMgd2lsbCByZXR1cm4gYW4gZXBoZW1lcmFsIHB1YmxpYyBrZXksXG4gKiAgICB3aGljaCBpcyB1c2VkIHRvIGVuY3J5cHQgdGhlIG5leHQgcmVxdWVzdC5cbiAqIDIuIEVuY3J5cHRlZCByZXF1ZXN0cyBhcmUgKmVuY3J5cHRlZCogKG9idmlvdXNseSkgYW5kIGZyb20gYSBMYXR0aWNlXG4gKiAgICBwcm90b2NvbCBwZXJzcGVjdGl2ZSB0aGV5IGFyZSBhbGwgY29uc3RydWN0ZWQgdGhlIHNhbWUgd2F5OlxuICogICAgY3JlYXRlIGEgYnVmZmVyIG9mIGBwYXlsb2FkYCBsZW5ndGggYW5kIGZpbGwgaXQgd2l0aCB1bmVuY3J5cHRlZFxuICogICAgZGF0YSwgdGhlbiBlbmNyeXB0IHRoZSBlbnRpcmUgcGF5bG9hZCAobm90IGp1c3QgdGhlIGRhdGEgeW91IGZpbGxlZClcbiAqICAgIHdpdGggdGhlIEVDREggc2VjcmV0IGZvcm1lZCBmcm9tIHRoZSBsYXN0IGVwaGVtZXJhbCBwdWJsaWMga2V5LlxuICogICAgVGhlIHJlc3BvbnNlIHRvIHRoaXMgcmVxdWVzdCB3aWxsIGNvbnRhaW4gYSBuZXcgZXBoZW1yYWwgcHVibGljXG4gKiAgICBrZXksIHdoaWNoIHlvdSB3aWxsIG5lZWQgZm9yIHRoZSBuZXh0IGVuY3J5cHRlZCByZXF1ZXN0LlxuICovXG52YXIgbGF0dGljZUNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vbGF0dGljZUNvbnN0YW50c1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvZnVuY3Rpb25zXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbnZhciBtc2dTaXplcyA9IGxhdHRpY2VDb25zdGFudHNfMS5Qcm90b2NvbENvbnN0YW50cy5tc2dTaXplcztcbnZhciBzenMgPSBtc2dTaXplcy5zZWN1cmU7XG4vKipcbiAqIEJ1aWxkIGFuZCBtYWtlIGEgcmVxdWVzdCB0byBjb25uZWN0IHRvIGEgc3BlY2lmaWMgTGF0dGljZVxuICogYmFzZWQgb24gaXRzIGBkZXZpY2VJZGAuXG4gKiBAcGFyYW0gZGV2aWNlSWQgLSBEZXZpY2UgSUQgZm9yIHRoZSB0YXJnZXQgTGF0dGljZS4gTXVzdCBiZSBpblxuICogICAgICAgICAgICAgICAgICAgdGhlIHNhbWUgYGNsaWVudC5iYXNlVXJsYCBkb21haW4gdG8gYmUgZm91bmQuXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IC0gQ29ubmVjdGlvbiByZXNwb25zZSBwYXlsb2FkIGRhdGEsIHdoaWNoIGNvbnRhaW5zXG4gKiAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbm5lY3RlZCBMYXR0aWNlLlxuICovXG5mdW5jdGlvbiBjb25uZWN0U2VjdXJlUmVxdWVzdChfYSkge1xuICAgIHZhciB1cmwgPSBfYS51cmwsIHB1YmtleSA9IF9hLnB1YmtleTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXlsb2FkRGF0YSwgbXNnSWQsIG1zZywgcmVzcDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZERhdGEgPSBzZXJpYWxpemVTZWN1cmVSZXF1ZXN0Q29ubmVjdFBheWxvYWREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogcHVia2V5LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbXNnSWQgPSAoMCwgdXRpbF8xLnJhbmRvbUJ5dGVzKSg0KTtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gc2VyaWFsaXplU2VjdXJlUmVxdWVzdE1zZyhtc2dJZCwgbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTZWN1cmVNc2dUeXBlLmNvbm5lY3QsIHBheWxvYWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGZ1bmN0aW9uc18xLnJlcXVlc3QpKHsgdXJsOiB1cmwsIHBheWxvYWQ6IG1zZyB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcC5sZW5ndGggIT09IHN6cy5wYXlsb2FkLnJlc3BvbnNlLmNvbm5lY3QgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIExhdHRpY2UgcmVzcG9uc2UgbWVzc2FnZSBzaXplLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbm5lY3RTZWN1cmVSZXF1ZXN0ID0gY29ubmVjdFNlY3VyZVJlcXVlc3Q7XG4vKipcbiAqIEJ1aWxkIGFuIGVuY3J5cHRlZCBzZWN1cmUgcmVxdWVzdCB1c2luZyByYXcgZGF0YSxcbiAqIHRoZW4gc2VuZCB0aGF0IHJlcXVlc3QgdG8gdGhlIHRhcmdldCBMYXR0aWNlLCBoYW5kbGVcbiAqIHRoZSByZXNwb25zZSwgYW5kIHJldHVybiB0aGUgKmRlY3J5cHRlZCogcmVzcG9uc2VcbiAqIHBheWxvYWQgZGF0YS5cbiAqIEFsc28gdXBkYXRlcyBlcGhlbWVyYWwgcHVibGljIGtleSBpbiB0aGUgY2xpZW50LlxuICogVGhpcyBpcyBhIHdyYXBwZXIgYXJvdW5kIHNldmVyYWwgbG9jYWwgdXRpbCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gZGF0YSAtIFVuZW5jcnlwdGVkIHJhdyBjYWxsZGF0YSBmb3IgZnVuY3Rpb25cbiAqIEBwYXJhbSByZXF1ZXN0VHlwZSAtIFR5cGUgb2YgZW5jcnlwdGVkIHJlcXVlcyB0byBtYWtlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IERlY3J5cHRlZCByZXNwb25zZSBkYXRhIChleGNsdWRpbmcgbWV0YWRhdGEpXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHRlZFNlY3VyZVJlcXVlc3QoX2EpIHtcbiAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIHJlcXVlc3RUeXBlID0gX2EucmVxdWVzdFR5cGUsIHNoYXJlZFNlY3JldCA9IF9hLnNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViID0gX2EuZXBoZW1lcmFsUHViLCB1cmwgPSBfYS51cmw7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbXNnSWQsIHBheWxvYWREYXRhLCBtc2csIHJlc3AsIGVuY1BheWxvYWREYXRhO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBtc2dJZCA9ICgwLCB1dGlsXzEucmFuZG9tQnl0ZXMpKDQpO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkRGF0YSA9IHNlcmlhbGl6ZVNlY3VyZVJlcXVlc3RFbmNyeXB0ZWRQYXlsb2FkRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFR5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTZWNyZXQ6IHNoYXJlZFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IHNlcmlhbGl6ZVNlY3VyZVJlcXVlc3RNc2cobXNnSWQsIGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2VjdXJlTXNnVHlwZS5lbmNyeXB0ZWQsIHBheWxvYWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGZ1bmN0aW9uc18xLnJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZXNlcmlhbGl6ZSB0aGUgcmVzcG9uc2UgcGF5bG9hZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwLmxlbmd0aCAhPT0gc3pzLnBheWxvYWQucmVzcG9uc2UuZW5jcnlwdGVkIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBMYXR0aWNlIHJlc3BvbnNlIG1lc3NhZ2Ugc2l6ZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmNQYXlsb2FkRGF0YSA9IHJlc3Auc2xpY2UoMCwgc3pzLmRhdGEucmVzcG9uc2UuZW5jcnlwdGVkLmVuY3J5cHRlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZGVjcnlwdGVkIHJlc3BvbnNlIHBheWxvYWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGVjcnlwdEVuY3J5cHRlZExhdHRpY2VSZXNwb25zZURhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY1BheWxvYWREYXRhOiBlbmNQYXlsb2FkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcmVxdWVzdFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0ID0gZW5jcnlwdGVkU2VjdXJlUmVxdWVzdDtcbi8qKlxuICogQGludGVybmFsXG4gKiBTZXJpYWxpemUgYSBTZWN1cmUgUmVxdWVzdCBtZXNzYWdlIGZvciB0aGUgTGF0dGljZS5cbiAqIEFsbCBvdXRnb2luZyBTREsgcmVxdWVzdHMgYXJlIG9mIHRoaXMgZm9ybS5cbiAqIEBwYXJhbSBtc2dJZCAtIFJhbmRvbSA0IGJ5dGVzIG9mIGRhdGEgZm9yIGludGVybmFsbHkgdHJhY2tpbmcgdGhpcyBtZXNzYWdlXG4gKiBAcGFyYW0gc2VjdXJlUmVxdWVzdFR5cGUgLSAweDAxIGZvciBjb25uZWN0LCAweDAyIGZvciBlbmNyeXB0ZWRcbiAqIEBwYXJhbSBwYXlsb2FkRGF0YSAtIFJlcXVlc3QgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfSBTZXJpYWxpemVkIG1lc3NhZ2UgdG8gYmUgc2VudCB0byBMYXR0aWNlXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNlY3VyZVJlcXVlc3RNc2cobXNnSWQsIHNlY3VyZVJlcXVlc3RUeXBlLCBwYXlsb2FkRGF0YSkge1xuICAgIC8vIFNhbml0eSBjaGVjayByZXF1ZXN0IGRhdGFcbiAgICBpZiAobXNnSWQubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXNnSWQgbXVzdCBiZSBmb3VyIGJ5dGVzJyk7XG4gICAgfVxuICAgIGlmIChzZWN1cmVSZXF1ZXN0VHlwZSAhPT0gbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTZWN1cmVNc2dUeXBlLmNvbm5lY3QgJiZcbiAgICAgICAgc2VjdXJlUmVxdWVzdFR5cGUgIT09IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2VjdXJlTXNnVHlwZS5lbmNyeXB0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdHRpY2Ugc2VjdXJlIHJlcXVlc3QgdHlwZScpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGUgaW5jb21pbmcgcGF5bG9hZCBkYXRhIHNpemUuIE5vdGUgdGhhdCB0aGUgcGF5bG9hZFxuICAgIC8vIGRhdGEgaXMgcHJlcGVuZGVkIHdpdGggYSBzZWN1cmUgcmVxdWVzdCB0eXBlIGJ5dGUsIHNvIHRoZVxuICAgIC8vIHBheWxvYWQgZGF0YSBzaXplIGlzIG9uZSBsZXNzIHRoYW4gdGhlIGV4cGVjdGVkIHNpemUuXG4gICAgdmFyIGlzVmFsaWRDb25uZWN0UGF5bG9hZERhdGFTeiA9IHNlY3VyZVJlcXVlc3RUeXBlID09PSBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNlY3VyZU1zZ1R5cGUuY29ubmVjdCAmJlxuICAgICAgICBwYXlsb2FkRGF0YS5sZW5ndGggPT09IHN6cy5wYXlsb2FkLnJlcXVlc3QuY29ubmVjdCAtIDE7XG4gICAgdmFyIGlzVmFsaWRFbmNyeXB0ZWRQYXlsb2FkRGF0YVN6ID0gc2VjdXJlUmVxdWVzdFR5cGUgPT09IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2VjdXJlTXNnVHlwZS5lbmNyeXB0ZWQgJiZcbiAgICAgICAgcGF5bG9hZERhdGEubGVuZ3RoID09PSBzenMucGF5bG9hZC5yZXF1ZXN0LmVuY3J5cHRlZCAtIDE7XG4gICAgLy8gQnVpbGQgcGF5bG9hZCBhbmQgc2l6ZVxuICAgIHZhciBtc2dTeiA9IG1zZ1NpemVzLmhlYWRlciArIG1zZ1NpemVzLmNoZWNrc3VtO1xuICAgIHZhciBwYXlsb2FkTGVuO1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICByZXF1ZXN0VHlwZTogc2VjdXJlUmVxdWVzdFR5cGUsXG4gICAgICAgIGRhdGE6IHBheWxvYWREYXRhLFxuICAgIH07XG4gICAgaWYgKGlzVmFsaWRDb25uZWN0UGF5bG9hZERhdGFTeikge1xuICAgICAgICBwYXlsb2FkTGVuID0gc3pzLnBheWxvYWQucmVxdWVzdC5jb25uZWN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZhbGlkRW5jcnlwdGVkUGF5bG9hZERhdGFTeikge1xuICAgICAgICBwYXlsb2FkTGVuID0gc3pzLnBheWxvYWQucmVxdWVzdC5lbmNyeXB0ZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0dGljZSBzZWN1cmUgcmVxdWVzdCBwYXlsb2FkIHNpemUnKTtcbiAgICB9XG4gICAgbXNnU3ogKz0gcGF5bG9hZExlbjtcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIHJlcXVlc3QgaW4gb2JqZWN0IGZvcm1cbiAgICB2YXIgaGVhZGVyID0ge1xuICAgICAgICB2ZXJzaW9uOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVByb3RvY29sVmVyc2lvbi52MSxcbiAgICAgICAgdHlwZTogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VNc2dUeXBlLnNlY3VyZSxcbiAgICAgICAgaWQ6IG1zZ0lkLFxuICAgICAgICBsZW46IHBheWxvYWRMZW4sXG4gICAgfTtcbiAgICB2YXIgcmVxID0ge1xuICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICB9O1xuICAgIC8vIE5vdyBzZXJpYWxpemUgdGhlIHdob2xlIG1lc3NhZ2VcbiAgICAvLyBIZWFkZXIgfCByZXF1ZXN0VHlwZSB8IHBheWxvYWREYXRhIHwgY2hlY2tzdW1cbiAgICB2YXIgbXNnID0gQnVmZmVyLmFsbG9jKG1zZ1N6KTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICAvLyBIZWFkZXJcbiAgICBtc2cud3JpdGVVSW50OChyZXEuaGVhZGVyLnZlcnNpb24sIG9mZik7XG4gICAgb2ZmICs9IDE7XG4gICAgbXNnLndyaXRlVUludDgocmVxLmhlYWRlci50eXBlLCBvZmYpO1xuICAgIG9mZiArPSAxO1xuICAgIHJlcS5oZWFkZXIuaWQuY29weShtc2csIG9mZik7XG4gICAgb2ZmICs9IHJlcS5oZWFkZXIuaWQubGVuZ3RoO1xuICAgIG1zZy53cml0ZVVJbnQxNkJFKHJlcS5oZWFkZXIubGVuLCBvZmYpO1xuICAgIG9mZiArPSAyO1xuICAgIC8vIFBheWxvYWRcbiAgICBtc2cud3JpdGVVSW50OChyZXEucGF5bG9hZC5yZXF1ZXN0VHlwZSwgb2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICByZXEucGF5bG9hZC5kYXRhLmNvcHkobXNnLCBvZmYpO1xuICAgIG9mZiArPSByZXEucGF5bG9hZC5kYXRhLmxlbmd0aDtcbiAgICAvLyBDaGVja3N1bVxuICAgIG1zZy53cml0ZVVJbnQzMkJFKCgwLCB1dGlsXzEuY2hlY2tzdW0pKG1zZy5zbGljZSgwLCBvZmYpKSwgb2ZmKTtcbiAgICBvZmYgKz0gNDtcbiAgICBpZiAob2ZmICE9PSBtc2dTeikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBidWlsZCByZXF1ZXN0IG1lc3NhZ2UnKTtcbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBvdXIgc2VyaWFsaXplZCBzZWN1cmUgbWVzc2FnZSFcbiAgICByZXR1cm4gbXNnO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFNlcmlhbGl6ZSBwYXlsb2FkIGRhdGEgZm9yIGEgTGF0dGljZSBzZWN1cmUgcmVxdWVzdDogY29ubmVjdFxuICogQHJldHVybiB7QnVmZmVyfSAtIDE3MDAgYnl0ZXMsIG9mIHdoaWNoIG9ubHkgNjUgYXJlIHVzZWRcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplU2VjdXJlUmVxdWVzdENvbm5lY3RQYXlsb2FkRGF0YShwYXlsb2FkRGF0YSkge1xuICAgIHZhciBzZXJQYXlsb2FkRGF0YSA9IEJ1ZmZlci5hbGxvYyhzenMuZGF0YS5yZXF1ZXN0LmNvbm5lY3QpO1xuICAgIHBheWxvYWREYXRhLnB1YmtleS5jb3B5KHNlclBheWxvYWREYXRhLCAwKTtcbiAgICByZXR1cm4gc2VyUGF5bG9hZERhdGE7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogU2VyaWFsaXplIHBheWxvYWQgZGF0YSBmb3IgTGF0dGljZSBzZWN1cmUgcmVxdWVzdDogZW5jcnlwdGVkXG4gKiBAcGFyYW0gZGF0YSAtIFJhdyAodW5lbmNyeXB0ZWQpIHJlcXVlc3QgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfSAtIDE3MDAgYnl0ZXMsIGFsbCBvZiB3aGljaCBzaG91bGQgYmUgdXNlZFxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVTZWN1cmVSZXF1ZXN0RW5jcnlwdGVkUGF5bG9hZERhdGEoX2EpIHtcbiAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIHJlcXVlc3RUeXBlID0gX2EucmVxdWVzdFR5cGUsIGVwaGVtZXJhbFB1YiA9IF9hLmVwaGVtZXJhbFB1Yiwgc2hhcmVkU2VjcmV0ID0gX2Euc2hhcmVkU2VjcmV0O1xuICAgIC8vIFNhbml0eSBjaGVja3MgcmVxdWVzdCBzaXplXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gc3pzLmRhdGEucmVxdWVzdC5lbmNyeXB0ZWQuZW5jcnlwdGVkRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCByZXF1ZXN0IGRhdGEgdG9vIGxhcmdlJyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc2hhcmVkIHNlY3JldC4gQW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBlcGhlbWVyYWwgcHViLCBpbmRpY2F0aW5nIHdlIG5lZWQgdG8gcmVjb25uZWN0LlxuICAgICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVFcGhlbWVyYWxQdWIpKGVwaGVtZXJhbFB1Yik7XG4gICAgLy8gVmFsaWRhdGUgdGhlIHJlcXVlc3QgZGF0YSBzaXplIG1hdGNoZXMgdGhlIGRlc2lyZWQgcmVxdWVzdFxuICAgIHZhciByZXF1ZXN0RGF0YVNpemUgPSBzenMuZGF0YS5yZXF1ZXN0LmVuY3J5cHRlZFtyZXF1ZXN0VHlwZV07XG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSByZXF1ZXN0RGF0YVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXF1ZXN0IGRhdGFzaXplICh3YW50ZWQgXCIuY29uY2F0KHJlcXVlc3REYXRhU2l6ZSwgXCIsIGdvdCBcIikuY29uY2F0KGRhdGEubGVuZ3RoLCBcIilcIikpO1xuICAgIH1cbiAgICAvLyBCdWlsZCB0aGUgcHJlLWVuY3J5cHRlZCBkYXRhIHBheWxvYWQsIHdoaWNoIHZhcmlhYmxlIHNpemVkIGFuZCBvZiBmb3JtOlxuICAgIC8vIGVuY3J5cHRlZFJlcXVlc3RUeXBlIHwgZGF0YSB8IGNoZWNrc3VtXG4gICAgdmFyIHByZUVuY3J5cHRlZERhdGEgPSBCdWZmZXIuYWxsb2MoMSArIHJlcXVlc3REYXRhU2l6ZSk7XG4gICAgcHJlRW5jcnlwdGVkRGF0YVswXSA9IHJlcXVlc3RUeXBlO1xuICAgIGRhdGEuY29weShwcmVFbmNyeXB0ZWREYXRhLCAxKTtcbiAgICB2YXIgcHJlRW5jcnlwdGVkRGF0YUNoZWNrc3VtID0gKDAsIHV0aWxfMS5jaGVja3N1bSkocHJlRW5jcnlwdGVkRGF0YSk7XG4gICAgLy8gRW5jcnlwdCB0aGUgZGF0YSBpbnRvIGEgZml4ZWQgc2l6ZSBidWZmZXIuIFRoZSBidWZmZXIgc2l6ZSBzaG91bGRcbiAgICAvLyBlcXVhbCB0byB0aGUgZnVsbCBtZXNzYWdlIHJlcXVlc3QgbGVzcyB0aGUgNC1ieXRlIGVwaGVtZXJhbCBpZC5cbiAgICB2YXIgX2VuY3J5cHRlZERhdGEgPSBCdWZmZXIuYWxsb2Moc3pzLmRhdGEucmVxdWVzdC5lbmNyeXB0ZWQuZW5jcnlwdGVkRGF0YSk7XG4gICAgcHJlRW5jcnlwdGVkRGF0YS5jb3B5KF9lbmNyeXB0ZWREYXRhLCAwKTtcbiAgICBfZW5jcnlwdGVkRGF0YS53cml0ZVVJbnQzMkxFKHByZUVuY3J5cHRlZERhdGFDaGVja3N1bSwgcHJlRW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuICAgIHZhciBlbmNyeXB0ZWREYXRhID0gKDAsIHV0aWxfMS5hZXMyNTZfZW5jcnlwdCkoX2VuY3J5cHRlZERhdGEsIHNoYXJlZFNlY3JldCk7XG4gICAgLy8gQ2FsY3VsYXRlIGVwaGVtZXJhbCBJRFxuICAgIHZhciBlcGhlbWVyYWxJZCA9ICgwLCBmdW5jdGlvbnNfMS5nZXRFcGhlbWVyYWxJZCkoc2hhcmVkU2VjcmV0KTtcbiAgICAvLyBOb3cgd2Ugd2lsbCBzZXJpYWxpemUgdGhlIHBheWxvYWQgZGF0YS5cbiAgICB2YXIgc2VyUGF5bG9hZERhdGEgPSBCdWZmZXIuYWxsb2Moc3pzLnBheWxvYWQucmVxdWVzdC5lbmNyeXB0ZWQgLSAxKTtcbiAgICBzZXJQYXlsb2FkRGF0YS53cml0ZVVJbnQzMkxFKGVwaGVtZXJhbElkKTtcbiAgICBlbmNyeXB0ZWREYXRhLmNvcHkoc2VyUGF5bG9hZERhdGEsIDQpO1xuICAgIHJldHVybiBzZXJQYXlsb2FkRGF0YTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBEZWNyeXB0IHRoZSByZXNwb25zZSBkYXRhIGZyb20gYW4gZW5jcnlwdGVkIHJlcXVlc3QuXG4gKiBAcGFyYW0gZW5jUGF5bG9hZERhdGEgLSBFbmNyeXB0ZWQgcGF5bG9hZCBkYXRhIGluIHJlc3BvbnNlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IERlY3J5cHRlZCByZXNwb25zZSBkYXRhIChleGNsdWRpbmcgbWV0YWRhdGEpXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHRFbmNyeXB0ZWRMYXR0aWNlUmVzcG9uc2VEYXRhKF9hKSB7XG4gICAgdmFyIGVuY1BheWxvYWREYXRhID0gX2EuZW5jUGF5bG9hZERhdGEsIHJlcXVlc3RUeXBlID0gX2EucmVxdWVzdFR5cGUsIHNoYXJlZFNlY3JldCA9IF9hLnNoYXJlZFNlY3JldDtcbiAgICAvLyBEZWNyeXB0IGRhdGEgdXNpbmcgdGhlICpjdXJyZW50KiBzaGFyZWQgc2VjcmV0XG4gICAgdmFyIGRlY0RhdGEgPSAoMCwgdXRpbF8xLmFlczI1Nl9kZWNyeXB0KShlbmNQYXlsb2FkRGF0YSwgc2hhcmVkU2VjcmV0KTtcbiAgICAvLyBCdWxpZCB0aGUgb2JqZWN0XG4gICAgdmFyIGVwaGVtZXJhbFB1YlN6ID0gNjU7IC8vIHNlY3AyNTZyMSBwdWJrZXlcbiAgICB2YXIgY2hlY2tzdW1PZmZzZXQgPSBlcGhlbWVyYWxQdWJTeiArIHN6cy5kYXRhLnJlc3BvbnNlLmVuY3J5cHRlZFtyZXF1ZXN0VHlwZV07XG4gICAgdmFyIHJlc3BEYXRhID0ge1xuICAgICAgICBlcGhlbWVyYWxQdWI6IGRlY0RhdGEuc2xpY2UoMCwgZXBoZW1lcmFsUHViU3opLFxuICAgICAgICBkYXRhOiBkZWNEYXRhLnNsaWNlKGVwaGVtZXJhbFB1YlN6LCBjaGVja3N1bU9mZnNldCksXG4gICAgICAgIGNoZWNrc3VtOiBkZWNEYXRhLnJlYWRVSW50MzJCRShjaGVja3N1bU9mZnNldCksXG4gICAgfTtcbiAgICAvLyBWYWxpZGF0ZSB0aGUgY2hlY2tzdW1cbiAgICB2YXIgdmFsaWRDaGVja3N1bSA9ICgwLCB1dGlsXzEuY2hlY2tzdW0pKGRlY0RhdGEuc2xpY2UoMCwgY2hlY2tzdW1PZmZzZXQpKTtcbiAgICBpZiAocmVzcERhdGEuY2hlY2tzdW0gIT09IHZhbGlkQ2hlY2tzdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGVja3N1bSBtaXNtYXRjaCBpbiBkZWNyeXB0ZWQgTGF0dGljZSBkYXRhJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoZSByZXNwb25zZSBkYXRhIHNpemVcbiAgICB2YXIgdmFsaWRTeiA9IHN6cy5kYXRhLnJlc3BvbnNlLmVuY3J5cHRlZFtyZXF1ZXN0VHlwZV07XG4gICAgaWYgKHJlc3BEYXRhLmRhdGEubGVuZ3RoICE9PSB2YWxpZFN6KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHJlc3BvbnNlIGRhdGEgcmV0dXJuZWQgZnJvbSBMYXR0aWNlJyk7XG4gICAgfVxuICAgIHZhciBuZXdFcGhlbWVyYWxQdWIgPSAoMCwgdXRpbF8xLmdldFAyNTZLZXlQYWlyRnJvbVB1YikocmVzcERhdGEuZXBoZW1lcmFsUHViKTtcbiAgICAvLyBSZXR1cm5lZCB0aGUgZGVjcnlwdGVkIGRhdGFcbiAgICByZXR1cm4geyBkZWNyeXB0ZWREYXRhOiByZXNwRGF0YS5kYXRhLCBuZXdFcGhlbWVyYWxQdWI6IG5ld0VwaGVtZXJhbFB1YiB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYXR0aWNlUmVzcG9uc2VFcnJvciA9IHZvaWQgMDtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4uL3Byb3RvY29sXCIpO1xudmFyIGJ1aWxkTGF0dGljZVJlc3BvbnNlRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHJlc3BvbnNlQ29kZSA9IF9hLnJlc3BvbnNlQ29kZSwgZXJyb3JNZXNzYWdlID0gX2EuZXJyb3JNZXNzYWdlO1xuICAgIHZhciBtc2cgPSBbXTtcbiAgICBpZiAocmVzcG9uc2VDb2RlKSB7XG4gICAgICAgIG1zZy5wdXNoKFwiXCIuY29uY2F0KHByb3RvY29sXzEuUHJvdG9jb2xDb25zdGFudHMucmVzcG9uc2VNc2dbcmVzcG9uc2VDb2RlXSkpO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIG1zZy5wdXNoKCdFcnJvciBNZXNzYWdlOiAnKTtcbiAgICAgICAgbXNnLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5qb2luKCdcXG4nKTtcbn07XG52YXIgTGF0dGljZVJlc3BvbnNlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExhdHRpY2VSZXNwb25zZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExhdHRpY2VSZXNwb25zZUVycm9yKHJlc3BvbnNlQ29kZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gYnVpbGRMYXR0aWNlUmVzcG9uc2VFcnJvck1lc3NhZ2Uoe1xuICAgICAgICAgICAgcmVzcG9uc2VDb2RlOiByZXNwb25zZUNvZGUsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVzcG9uc2VDb2RlID0gcmVzcG9uc2VDb2RlO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnTGF0dGljZVJlc3BvbnNlRXJyb3InO1xuICAgICAgICBfdGhpcy5yZXNwb25zZUNvZGUgPSByZXNwb25zZUNvZGU7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGF0dGljZVJlc3BvbnNlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkxhdHRpY2VSZXNwb25zZUVycm9yID0gTGF0dGljZVJlc3BvbnNlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFcGhlbWVyYWxJZCA9IGV4cG9ydHMucmV0cnlXcmFwcGVyID0gZXhwb3J0cy5idWlsZFJldHJ5V3JhcHBlciA9IGV4cG9ydHMucmVxdWVzdCA9IGV4cG9ydHMuYnVpbGRUcmFuc2FjdGlvbiA9IHZvaWQgMDtcbnZhciBzaGFfMSA9IHJlcXVpcmUoXCJoYXNoLmpzL2xpYi9oYXNoL3NoYVwiKTtcbnZhciBiaXRjb2luXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2JpdGNvaW5cIikpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBldGhlcmV1bV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldGhlcmV1bVwiKSk7XG52YXIgZ2VuZXJpY1NpZ25pbmdfMSA9IHJlcXVpcmUoXCIuLi9nZW5lcmljU2lnbmluZ1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnNcIik7XG52YXIgYnVpbGRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgIC8vIEFsbCB0cmFuc2FjdGlvbiByZXF1ZXN0cyBtdXN0IGJlIHB1dCBpbnRvIHRoZSBzYW1lIHNpemVkIGJ1ZmZlci4gVGhpcyBjb21lcyBmcm9tXG4gICAgLy8gc2l6ZW9mKEdwVHJhbnNhY3Rpb25SZXF1ZXN0X3QpLCBidXQgbm90ZSB3ZSByZW1vdmUgdGhlIDItYnl0ZSBzY2hlbWFJZCBzaW5jZSBpdCBpcyBub3RcbiAgICAvLyByZXR1cm5lZCBmcm9tIG91ciByZXNvbHZlci4gTm90ZSB0aGF0IGRpZmZlcmVudCBmaXJtd2FyZSB2ZXJzaW9ucyBtYXkgaGF2ZSBkaWZmZXJlbnQgZGF0YVxuICAgIC8vIHNpemVzLlxuICAgIHZhciBkYXRhID0gX2EuZGF0YSwgY3VycmVuY3kgPSBfYS5jdXJyZW5jeSwgZndDb25zdGFudHMgPSBfYS5md0NvbnN0YW50cztcbiAgICAvLyBURU1QT1JBUlkgQlJJREdFIC0tIERFUFJFQ0FURSBNRSBJbiB2MC4xNS4wIExhdHRpY2UgZmlybXdhcmUgcmVtb3ZlZCB0aGUgbGVnYWN5IEVUSFxuICAgIC8vIHNpZ25pbmcgcGF0aCwgc28gd2UgbmVlZCB0byBjb252ZXJ0IHN1Y2ggcmVxdWVzdHMgdG8gZ2VuZXJhbCBzaWduaW5nIHJlcXVlc3RzIHVzaW5nIHRoZVxuICAgIC8vIEVWTSBkZWNvZGVyLiBOT1RFOiBOb3QgZXZlcnkgcmVxdWVzdCBjYW4gYmUgY29udmVydGVkLCBzbyB1c2VycyBzaG91bGQgc3dpdGNoIHRvIHVzaW5nXG4gICAgLy8gZ2VuZXJhbCBzaWduaW5nIHJlcXVlc3RzIGZvciBuZXdlciBmaXJtd2FyZSB2ZXJzaW9ucy4gRUlQMTU1OSBhbmQgRUlQMTU1IGxlZ2FjeVxuICAgIC8vIHJlcXVlc3RzIHdpbGwgY29udmVydCwgYnV0IG90aGVycyBtYXkgbm90LlxuICAgIGlmIChjdXJyZW5jeSA9PT0gJ0VUSCcgJiYgKDAsIHByZWRpY2F0ZXNfMS5zaG91bGRVc2VFVk1MZWdhY3lDb252ZXJ0ZXIpKGZ3Q29uc3RhbnRzKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgdGhlIGxlZ2FjeSBFVEggc2lnbmluZyBwYXRoLiBUaGlzIHdpbGwgc29vbiBiZSBkZXByZWNhdGVkLiAnICtcbiAgICAgICAgICAgICdQbGVhc2Ugc3dpdGNoIHRvIGdlbmVyYWwgc2lnbmluZyByZXF1ZXN0LicpO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBldGhlcmV1bV8xLmRlZmF1bHQuZXRoQ29udmVydExlZ2FjeVRvR2VuZXJpY1JlcShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGxlZ2FjeSByZXF1ZXN0LiBQbGVhc2Ugc3dpdGNoIHRvIGEgZ2VuZXJhbCBzaWduaW5nICcgK1xuICAgICAgICAgICAgICAgICdyZXF1ZXN0LiBTZWUgZ3JpZHBsdXMtc2RrIGRvY3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyxcbiAgICAgICAgICAgIGVuY29kaW5nVHlwZTogY29uc3RhbnRzXzEuRVhURVJOQUwuU0lHTklORy5FTkNPRElOR1MuRVZNLFxuICAgICAgICAgICAgY3VydmVUeXBlOiBjb25zdGFudHNfMS5FWFRFUk5BTC5TSUdOSU5HLkNVUlZFUy5TRUNQMjU2SzEsXG4gICAgICAgICAgICBoYXNoVHlwZTogY29uc3RhbnRzXzEuRVhURVJOQUwuU0lHTklORy5IQVNIRVMuS0VDQ0FLMjU2LFxuICAgICAgICAgICAgc2lnbmVyUGF0aDogZGF0YS5zaWduZXJQYXRoLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiAoMCwgZ2VuZXJpY1NpZ25pbmdfMS5idWlsZEdlbmVyaWNTaWduaW5nTXNnUmVxdWVzdCkoX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyB9KSksXG4gICAgICAgICAgICBpc0dlbmVyaWM6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbmN5ID09PSAnRVRIJykge1xuICAgICAgICAvLyBMZWdhY3kgc2lnbmluZyBwYXRod2F5IC0tIHNob3VsZCBkZXByZWNhdGUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdERhdGE6IGV0aGVyZXVtXzEuZGVmYXVsdC5idWlsZEV0aGVyZXVtVHhSZXF1ZXN0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyBmd0NvbnN0YW50czogZndDb25zdGFudHMgfSkpLFxuICAgICAgICAgICAgaXNHZW5lcmljOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VycmVuY3kgPT09ICdFVEhfTVNHJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdERhdGE6IGV0aGVyZXVtXzEuZGVmYXVsdC5idWlsZEV0aGVyZXVtTXNnUmVxdWVzdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzIH0pKSxcbiAgICAgICAgICAgIGlzR2VuZXJpYzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbmN5ID09PSAnQlRDJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdERhdGE6IGJpdGNvaW5fMS5kZWZhdWx0LmJ1aWxkQml0Y29pblR4UmVxdWVzdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzIH0pKSxcbiAgICAgICAgICAgIGlzR2VuZXJpYzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3REYXRhOiAoMCwgZ2VuZXJpY1NpZ25pbmdfMS5idWlsZEdlbmVyaWNTaWduaW5nTXNnUmVxdWVzdCkoX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyB9KSksXG4gICAgICAgIGlzR2VuZXJpYzogdHJ1ZSxcbiAgICB9O1xufTtcbmV4cG9ydHMuYnVpbGRUcmFuc2FjdGlvbiA9IGJ1aWxkVHJhbnNhY3Rpb247XG52YXIgcmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB1cmwgPSBfYS51cmwsIHBheWxvYWQgPSBfYS5wYXlsb2FkLCBfYiA9IF9hLnRpbWVvdXQsIHRpbWVvdXQgPSBfYiA9PT0gdm9pZCAwID8gNjAwMDAgOiBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB1dGlsXzEuZmV0Y2hXaXRoVGltZW91dCkodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGRhdGE6IHBheWxvYWQgfSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHZhbGlkYXRvcnNfMS52YWxpZGF0ZVJlcXVlc3RFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmpzb24oKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZvcm1hdHRpbmcgb3IgZ2VuZXJpYyBIVFRQIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZHkgfHwgIWJvZHkubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY29kZSBcIi5jb25jYXQoYm9keS5zdGF0dXMsIFwiOiBcIikuY29uY2F0KGJvZHkubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9ICgwLCB1dGlsXzEucGFyc2VMYXR0aWNlMVJlc3BvbnNlKShib2R5Lm1lc3NhZ2UpLCBkYXRhID0gX2EuZGF0YSwgZXJyb3JNZXNzYWdlID0gX2EuZXJyb3JNZXNzYWdlLCByZXNwb25zZUNvZGUgPSBfYS5yZXNwb25zZUNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UgfHwgcmVzcG9uc2VDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTGF0dGljZVJlc3BvbnNlRXJyb3IocmVzcG9uc2VDb2RlLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWVzdDtcbi8qKlxuICogYHNsZWVwKClgIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgYSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBzbGVlcChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBtcyk7IH0pO1xufVxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCBhIHNldCBvZiBwYXJhbWV0ZXJzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXRyeSB0aGUgb3JpZ2luYWxcbiAqIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMgYSBudW1iZXIgb2YgdGltZXNcbiAqXG4gKiBAcGFyYW0gY2xpZW50IC0gYSB7QGxpbmsgQ2xpZW50fSBpbnN0YW5jZSB0aGF0IGlzIHBhc3NlZCB0byB0aGUge0BsaW5rIHJldHJ5V3JhcHBlcn1cbiAqIEBwYXJhbSByZXRyaWVzIC0gdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSB0aGUgZnVuY3Rpb24gYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybnMgYSB7QGxpbmsgcmV0cnlXcmFwcGVyfSBmdW5jdGlvbiBmb3IgaGFuZGluZyByZXRyeSBsb2dpY1xuICovXG52YXIgYnVpbGRSZXRyeVdyYXBwZXIgPSBmdW5jdGlvbiAoY2xpZW50LCByZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5yZXRyeVdyYXBwZXIpKHtcbiAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgIHBhcmFtczogX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtcyksIHsgY2xpZW50OiBjbGllbnQgfSksXG4gICAgICAgICAgICByZXRyaWVzOiByZXRyaWVzLFxuICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuZXhwb3J0cy5idWlsZFJldHJ5V3JhcHBlciA9IGJ1aWxkUmV0cnlXcmFwcGVyO1xuLyoqXG4gKiBSZXRyaWVzIGEgZnVuY3Rpb24gY2FsbCBpZiB0aGUgZXJyb3IgbWVzc2FnZSBvciByZXNwb25zZSBjb2RlIGlzIHByZXNlbnQgYW5kIHRoZSBudW1iZXIgb2ZcbiAqIHJldHJpZXMgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIHJldHJ5XG4gKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSByZXRyaWVzIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSBjbGllbnQgLSBUaGUge0BsaW5rIENsaWVudH0gdG8gdXNlIGZvciBzaWRlLWVmZmVjdHNcbiAqL1xudmFyIHJldHJ5V3JhcHBlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBmbiA9IF9hLmZuLCBwYXJhbXMgPSBfYS5wYXJhbXMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCBjbGllbnQgPSBfYS5jbGllbnQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmbihfX2Fzc2lnbih7fSwgcGFyYW1zKSkuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSwgcmVzcG9uc2VDb2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnIuZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvZGUgPSBlcnIucmVzcG9uc2VDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoZXJyb3JNZXNzYWdlIHx8IHJlc3BvbnNlQ29kZSkgJiYgcmV0cmllcykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBwcmVkaWNhdGVzXzEuaXNEZXZpY2VCdXN5KShyZXNwb25zZUNvZGUpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2xlZXAoMzAwMCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCgwLCBwcmVkaWNhdGVzXzEuaXNXcm9uZ1dhbGxldCkocmVzcG9uc2VDb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNsaWVudC5za2lwUmV0cnlPbldyb25nV2FsbGV0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNsaWVudC5mZXRjaEFjdGl2ZVdhbGxldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBwcmVkaWNhdGVzXzEuaXNJbnZhbGlkRXBoZW1lcmFsSWQpKHJlc3BvbnNlQ29kZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGllbnQuY29ubmVjdChjbGllbnQuZGV2aWNlSWQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGV4cG9ydHMucmV0cnlXcmFwcGVyKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogZm4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXM6IHJldHJpZXMgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5yZXRyeVdyYXBwZXIgPSByZXRyeVdyYXBwZXI7XG4vKipcbiAqIEdldCB0aGUgZXBoZW1lcmFsIGlkLCB3aGljaCBpcyB0aGUgZmlyc3QgNCBieXRlcyBvZiB0aGUgc2hhcmVkIHNlY3JldCBnZW5lcmF0ZWQgZnJvbSB0aGUgbG9jYWxcbiAqIHByaXZhdGUga2V5IGFuZCB0aGUgZXBoZW1lcmFsIHB1YmxpYyBrZXkgZnJvbSB0aGUgZGV2aWNlLlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBCdWZmZXJcbiAqL1xudmFyIGdldEVwaGVtZXJhbElkID0gZnVuY3Rpb24gKHNoYXJlZFNlY3JldCkge1xuICAgIC8vIEVwaGVtSWQgaXMgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIGhhc2ggb2YgdGhlIHNoYXJlZCBzZWNyZXRcbiAgICB2YXIgaGFzaCA9IEJ1ZmZlci5mcm9tKCgwLCBzaGFfMS5zaGEyNTYpKCkudXBkYXRlKHNoYXJlZFNlY3JldCkuZGlnZXN0KCdoZXgnKSwgJ2hleCcpO1xuICAgIHJldHVybiBwYXJzZUludChoYXNoLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xufTtcbmV4cG9ydHMuZ2V0RXBoZW1lcmFsSWQgPSBnZXRFcGhlbWVyYWxJZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG91bGRVc2VFVk1MZWdhY3lDb252ZXJ0ZXIgPSBleHBvcnRzLmRvZXNGZXRjaFdhbGxldHNPbkxvYWQgPSBleHBvcnRzLmlzSW52YWxpZEVwaGVtZXJhbElkID0gZXhwb3J0cy5pc1dyb25nV2FsbGV0ID0gZXhwb3J0cy5pc0RldmljZUJ1c3kgPSB2b2lkIDA7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxpdGllc1wiKTtcbnZhciBpc0RldmljZUJ1c3kgPSBmdW5jdGlvbiAocmVzcG9uc2VDb2RlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlQ29kZSA9PT0gcHJvdG9jb2xfMS5MYXR0aWNlUmVzcG9uc2VDb2RlLmRldmljZUJ1c3kgfHxcbiAgICAgICAgcmVzcG9uc2VDb2RlID09PSBwcm90b2NvbF8xLkxhdHRpY2VSZXNwb25zZUNvZGUuZ2NlVGltZW91dDtcbn07XG5leHBvcnRzLmlzRGV2aWNlQnVzeSA9IGlzRGV2aWNlQnVzeTtcbnZhciBpc1dyb25nV2FsbGV0ID0gZnVuY3Rpb24gKHJlc3BvbnNlQ29kZSkge1xuICAgIHJldHVybiByZXNwb25zZUNvZGUgPT09IHByb3RvY29sXzEuTGF0dGljZVJlc3BvbnNlQ29kZS53cm9uZ1dhbGxldDtcbn07XG5leHBvcnRzLmlzV3JvbmdXYWxsZXQgPSBpc1dyb25nV2FsbGV0O1xudmFyIGlzSW52YWxpZEVwaGVtZXJhbElkID0gZnVuY3Rpb24gKHJlc3BvbnNlQ29kZSkge1xuICAgIHJldHVybiByZXNwb25zZUNvZGUgPT09IHByb3RvY29sXzEuTGF0dGljZVJlc3BvbnNlQ29kZS5pbnZhbGlkRXBoZW1JZDtcbn07XG5leHBvcnRzLmlzSW52YWxpZEVwaGVtZXJhbElkID0gaXNJbnZhbGlkRXBoZW1lcmFsSWQ7XG52YXIgZG9lc0ZldGNoV2FsbGV0c09uTG9hZCA9IGZ1bmN0aW9uIChmd1ZlcnNpb24pIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc18xLmlzRldTdXBwb3J0ZWQpKGZ3VmVyc2lvbiwgeyBtYWpvcjogMCwgbWlub3I6IDE0LCBmaXg6IDEgfSk7XG59O1xuZXhwb3J0cy5kb2VzRmV0Y2hXYWxsZXRzT25Mb2FkID0gZG9lc0ZldGNoV2FsbGV0c09uTG9hZDtcbnZhciBzaG91bGRVc2VFVk1MZWdhY3lDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoZndDb25zdGFudHMpIHtcbiAgICByZXR1cm4gZndDb25zdGFudHMuZ2VuZXJpY1NpZ25pbmcgJiZcbiAgICAgICAgZndDb25zdGFudHMuZ2VuZXJpY1NpZ25pbmcuZW5jb2RpbmdUeXBlcyAmJlxuICAgICAgICBmd0NvbnN0YW50cy5nZW5lcmljU2lnbmluZy5lbmNvZGluZ1R5cGVzLkVWTTtcbn07XG5leHBvcnRzLnNob3VsZFVzZUVWTUxlZ2FjeUNvbnZlcnRlciA9IHNob3VsZFVzZUVWTUxlZ2FjeUNvbnZlcnRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQYXRoU3RyID0gZXhwb3J0cy5pc0ZXU3VwcG9ydGVkID0gZXhwb3J0cy5wYXJzZVdhbGxldHMgPSBleHBvcnRzLmdldFNoYXJlZFNlY3JldCA9IGV4cG9ydHMuZ2V0UHViS2V5Qnl0ZXMgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBHZXQgNjQgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBwdWJsaWMga2V5IFRoaXMgaXMgdGhlIHVuY29tcHJlc3NlZCBrZXkgd2l0aG91dCB0aGUgbGVhZGluZyAwNFxuICogYnl0ZVxuICogQHBhcmFtIEtleVBhaXIgLSAvL1RPRE8gRGVzY3JpYmUgdGhlIGtleXBhaXJcbiAqIEBwYXJhbSBMRSAtIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwdWJsaWMga2V5IGluIGxpdHRsZSBlbmRpYW4gZm9ybWF0LlxuICogQHJldHVybnMgQSBCdWZmZXIgY29udGFpbmluZyB0aGUgcHVibGljIGtleS5cbiAqL1xudmFyIGdldFB1YktleUJ5dGVzID0gZnVuY3Rpb24gKGtleSwgTEUpIHtcbiAgICBpZiAoTEUgPT09IHZvaWQgMCkgeyBMRSA9IGZhbHNlOyB9XG4gICAgdmFyIGsgPSBrZXkuZ2V0UHVibGljKCk7XG4gICAgdmFyIHAgPSBrLmVuY29kZSgnaGV4Jyk7XG4gICAgdmFyIHBiID0gQnVmZmVyLmZyb20ocCwgJ2hleCcpO1xuICAgIGlmIChMRSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBOZWVkIHRvIGZsaXAgWCBhbmQgWSBjb21wb25lbnRzIHRvIGxpdHRsZSBlbmRpYW5cbiAgICAgICAgdmFyIHggPSBwYi5zbGljZSgxLCAzMykucmV2ZXJzZSgpO1xuICAgICAgICB2YXIgeSA9IHBiLnNsaWNlKDMzLCA2NSkucmV2ZXJzZSgpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVE9ETzogRmluZCBvdXQgd2h5IEJ1ZmZlciB3b24ndCBhY2NlcHQgcGJbMF1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3BiWzBdLCB4LCB5XSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGI7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0UHViS2V5Qnl0ZXMgPSBnZXRQdWJLZXlCeXRlcztcbi8qKlxuICogR2V0IHRoZSBzaGFyZWQgc2VjcmV0LCBkZXJpdmVkIHZpYSBFQ0RIIGZyb20gdGhlIGxvY2FsIHByaXZhdGUga2V5IGFuZCB0aGUgZXBoZW1lcmFsIHB1YmxpYyBrZXlcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbnZhciBnZXRTaGFyZWRTZWNyZXQgPSBmdW5jdGlvbiAoa2V5LCBlcGhlbWVyYWxQdWIpIHtcbiAgICAvLyBPbmNlIGV2ZXJ5IH4yNTYgYXR0ZW1wdHMsIHdlIHdpbGwgZ2V0IGEga2V5IHRoYXQgc3RhcnRzIHdpdGggYSBgMDBgIGJ5dGUsIHdoaWNoIGNhbiBsZWFkIHRvXG4gICAgLy8gcHJvYmxlbXMgaW5pdGlhbGl6aW5nIEFFUyBpZiB3ZSBkb24ndCBmb3JjZSBhIDMyIGJ5dGUgQkUgYnVmZmVyLlxuICAgIHJldHVybiBCdWZmZXIuZnJvbShrZXkuZGVyaXZlKGVwaGVtZXJhbFB1Yi5nZXRQdWJsaWMoKSkudG9BcnJheSgnYmUnLCAzMikpO1xufTtcbmV4cG9ydHMuZ2V0U2hhcmVkU2VjcmV0ID0gZ2V0U2hhcmVkU2VjcmV0O1xuLy8gR2l2ZW4gYSBzZXQgb2Ygd2FsbGV0IGRhdGEsIHdoaWNoIGNvbnRhaW5zIHR3byB3YWxsZXQgZGVzY3JpcHRvcnMsIHBhcnNlIHRoZSBkYXRhIGFuZCBzYXZlIGl0XG4vLyB0byBtZW1vcnlcbnZhciBwYXJzZVdhbGxldHMgPSBmdW5jdGlvbiAod2FsbGV0RGF0YSkge1xuICAgIC8vIFJlYWQgdGhlIGV4dGVybmFsIHdhbGxldCBkYXRhIGZpcnN0LiBJZiBpdCBpcyBub24tbnVsbCwgdGhlIGV4dGVybmFsIHdhbGxldCB3aWxsIGJlIHRoZVxuICAgIC8vIGFjdGl2ZSB3YWxsZXQgb2YgdGhlIGRldmljZSBhbmQgd2Ugc2hvdWxkIHNhdmUgaXQuIElmIHRoZSBleHRlcm5hbCB3YWxsZXQgaXMgYmxhbmssIGl0IG1lYW5zXG4gICAgLy8gdGhlcmUgaXMgbm8gY2FyZCBwcmVzZW50IGFuZCB3ZSBzaG91bGQgc2F2ZSBhbmQgdXNlIHRoZSBpbnRlcmFsIHdhbGxldC4gSWYgYm90aCB3YWxsZXRzIGFyZVxuICAgIC8vIGVtcHR5LCBpdCBtZWFucyB0aGUgZGV2aWNlIHN0aWxsIG5lZWRzIHRvIGJlIHNldCB1cC5cbiAgICB2YXIgd2FsbGV0RGVzY3JpcHRvckxlbiA9IDcxO1xuICAgIC8vIEludGVybmFsIGZpcnN0XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGFjdGl2ZVdhbGxldHMgPSB7XG4gICAgICAgIGludGVybmFsOiB7XG4gICAgICAgICAgICB1aWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXh0ZXJuYWw6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBleHRlcm5hbDoge1xuICAgICAgICAgICAgdWlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC51aWQgPSB3YWxsZXREYXRhLnNsaWNlKG9mZiwgb2ZmICsgMzIpO1xuICAgIC8vIE5PVEU6IGBjYXBhYmlsaXRpZXNgIGFuZCBgbmFtZWAgd2VyZSBkZXByZWNhdGVkIGluIExhdHRpY2UgZmlybXdhcmUuXG4gICAgLy8gVGhleSBuZXZlciBwcm92aWRlZCBhbnkgcmVhbCBpbmZvcm1hdGlvbiwgYnV0IGhhdmUgYmVlbiBhcmNoaXZlZCBoZXJlXG4gICAgLy8gc2luY2UgdGhlIHJlc3BvbnNlIHNpemUgaGFzIGJlZW4gcHJlc2VydmVkIGFuZCB3ZSBtYXkgYnJpbmcgdGhlbSBiYWNrXG4gICAgLy8gaW4gYSBkaWZmZXJlbnQgZm9ybS5cbiAgICAvLyBhY3RpdmVXYWxsZXRzLmludGVybmFsLmNhcGFiaWxpdGllcyA9IHdhbGxldERhdGEucmVhZFVJbnQzMkJFKG9mZiArIDMyKTtcbiAgICAvLyBhY3RpdmVXYWxsZXRzLmludGVybmFsLm5hbWUgPSB3YWxsZXREYXRhLnNsaWNlKFxuICAgIC8vIG9mZiArIDM2LFxuICAgIC8vIG9mZiArIHdhbGxldERlc2NyaXB0b3JMZW4sXG4gICAgLy8gKTtcbiAgICAvLyBPZmZzZXQgdGhlIGZpcnN0IGl0ZW1cbiAgICBvZmYgKz0gd2FsbGV0RGVzY3JpcHRvckxlbjtcbiAgICAvLyBFeHRlcm5hbFxuICAgIGFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwudWlkID0gd2FsbGV0RGF0YS5zbGljZShvZmYsIG9mZiArIDMyKTtcbiAgICAvLyBhY3RpdmVXYWxsZXRzLmV4dGVybmFsLmNhcGFiaWxpdGllcyA9IHdhbGxldERhdGEucmVhZFVJbnQzMkJFKG9mZiArIDMyKTtcbiAgICAvLyBhY3RpdmVXYWxsZXRzLmV4dGVybmFsLm5hbWUgPSB3YWxsZXREYXRhLnNsaWNlKFxuICAgIC8vIG9mZiArIDM2LFxuICAgIC8vIG9mZiArIHdhbGxldERlc2NyaXB0b3JMZW4sXG4gICAgLy8gKTtcbiAgICByZXR1cm4gYWN0aXZlV2FsbGV0cztcbn07XG5leHBvcnRzLnBhcnNlV2FsbGV0cyA9IHBhcnNlV2FsbGV0cztcbi8vIERldGVybWluZSBpZiBhIHByb3ZpZGVkIGZpcm13YXJlIHZlcnNpb24gbWF0Y2hlcyBvciBleGNlZWRzIHRoZSBjdXJyZW50IGZpcm13YXJlIHZlcnNpb25cbnZhciBpc0ZXU3VwcG9ydGVkID0gZnVuY3Rpb24gKGZ3VmVyc2lvbiwgdmVyc2lvblN1cHBvcnRlZCkge1xuICAgIHZhciBtYWpvciA9IGZ3VmVyc2lvbi5tYWpvciwgbWlub3IgPSBmd1ZlcnNpb24ubWlub3IsIGZpeCA9IGZ3VmVyc2lvbi5maXg7XG4gICAgdmFyIF9tYWpvciA9IHZlcnNpb25TdXBwb3J0ZWQubWFqb3IsIF9taW5vciA9IHZlcnNpb25TdXBwb3J0ZWQubWlub3IsIF9maXggPSB2ZXJzaW9uU3VwcG9ydGVkLmZpeDtcbiAgICByZXR1cm4gKG1ham9yID4gX21ham9yIHx8XG4gICAgICAgIChtYWpvciA+PSBfbWFqb3IgJiYgbWlub3IgPiBfbWlub3IpIHx8XG4gICAgICAgIChtYWpvciA+PSBfbWFqb3IgJiYgbWlub3IgPj0gX21pbm9yICYmIGZpeCA+PSBfZml4KSk7XG59O1xuZXhwb3J0cy5pc0ZXU3VwcG9ydGVkID0gaXNGV1N1cHBvcnRlZDtcbi8qKlxuICogQ29udmVydCBhIHNldCBvZiBCSVAzOSBwYXRoIGluZGljZXMgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSBwYXRoIC0gU2V0IG9mIGluZGljZXNcbiAqL1xudmFyIGdldFBhdGhTdHIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBwYXRoU3RyID0gJ20nO1xuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPj0gY29uc3RhbnRzXzEuSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICBwYXRoU3RyICs9IFwiL1wiLmNvbmNhdChpZHggLSBjb25zdGFudHNfMS5IQVJERU5FRF9PRkZTRVQsIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGhTdHIgKz0gXCIvXCIuY29uY2F0KGlkeCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aFN0cjtcbn07XG5leHBvcnRzLmdldFBhdGhTdHIgPSBnZXRQYXRoU3RyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVmFsaWQ0Qnl0ZVJlc3BvbnNlID0gZXhwb3J0cy5pc1ZhbGlkQmxvY2tFeHBsb3JlclJlc3BvbnNlID0gZXhwb3J0cy52YWxpZGF0ZUt2UmVjb3JkID0gZXhwb3J0cy52YWxpZGF0ZUt2UmVjb3JkcyA9IGV4cG9ydHMudmFsaWRhdGVBY3RpdmVXYWxsZXRzID0gZXhwb3J0cy52YWxpZGF0ZUtleSA9IGV4cG9ydHMudmFsaWRhdGVTaGFyZWRTZWNyZXQgPSBleHBvcnRzLnZhbGlkYXRlRXBoZW1lcmFsUHViID0gZXhwb3J0cy52YWxpZGF0ZUNvbm5lY3RlZENsaWVudCA9IGV4cG9ydHMudmFsaWRhdGVXYWxsZXQgPSBleHBvcnRzLnZhbGlkYXRlUmVxdWVzdEVycm9yID0gZXhwb3J0cy52YWxpZGF0ZUZ3VmVyc2lvbiA9IGV4cG9ydHMudmFsaWRhdGVGd0NvbnN0YW50cyA9IGV4cG9ydHMudmFsaWRhdGVCYXNlVXJsID0gZXhwb3J0cy52YWxpZGF0ZVVybCA9IGV4cG9ydHMudmFsaWRhdGVBcHBOYW1lID0gZXhwb3J0cy52YWxpZGF0ZURldmljZUlkID0gZXhwb3J0cy52YWxpZGF0ZVN0YXJ0UGF0aCA9IGV4cG9ydHMudmFsaWRhdGVOQWRkcmVzc2VzID0gZXhwb3J0cy52YWxpZGF0ZUlzVUludDQgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGlzRW1wdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIHZhbGlkYXRlSXNVSW50NCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCAhKDAsIHV0aWxfMS5pc1VJbnQ0KShuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDE1IGluY2x1c2l2ZScpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5leHBvcnRzLnZhbGlkYXRlSXNVSW50NCA9IHZhbGlkYXRlSXNVSW50NDtcbnZhciB2YWxpZGF0ZU5BZGRyZXNzZXMgPSBmdW5jdGlvbiAobikge1xuICAgIGlmICghbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBudW1iZXIgb2YgYWRkcmVzc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBpZiAobiA+IGNvbnN0YW50c18xLk1BWF9BRERSKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtYXkgb25seSByZXF1ZXN0IFwiLmNvbmNhdChjb25zdGFudHNfMS5NQVhfQUREUiwgXCIgYWRkcmVzc2VzIGF0IG9uY2UuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuZXhwb3J0cy52YWxpZGF0ZU5BZGRyZXNzZXMgPSB2YWxpZGF0ZU5BZGRyZXNzZXM7XG52YXIgdmFsaWRhdGVTdGFydFBhdGggPSBmdW5jdGlvbiAoc3RhcnRQYXRoKSB7XG4gICAgaWYgKCFzdGFydFBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGFydCBwYXRoIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChzdGFydFBhdGgubGVuZ3RoIDwgMSB8fCBzdGFydFBhdGgubGVuZ3RoID4gNSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3QgaW5jbHVkZSBiZXR3ZWVuIDEgYW5kIDUgaW5kaWNlcycpO1xuICAgIHJldHVybiBzdGFydFBhdGg7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVN0YXJ0UGF0aCA9IHZhbGlkYXRlU3RhcnRQYXRoO1xudmFyIHZhbGlkYXRlRGV2aWNlSWQgPSBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgICBpZiAoIWRldmljZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGV2aWNlIElEIGhhcyBiZWVuIHN0b3JlZC4gUGxlYXNlIGNvbm5lY3Qgd2l0aCB5b3VyIGRldmljZSBJRCBmaXJzdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldmljZUlkO1xufTtcbmV4cG9ydHMudmFsaWRhdGVEZXZpY2VJZCA9IHZhbGlkYXRlRGV2aWNlSWQ7XG52YXIgdmFsaWRhdGVBcHBOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBpZiAobmFtZS5sZW5ndGggPCA1IHx8IG5hbWUubGVuZ3RoID4gMjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCBmb3IgbmFtZSBwcm92aWRlZC4gTXVzdCBiZSA1LTI0IGNoYXJhY3RlcnMuJyk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcbmV4cG9ydHMudmFsaWRhdGVBcHBOYW1lID0gdmFsaWRhdGVBcHBOYW1lO1xudmFyIHZhbGlkYXRlVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgcmVjb25uZWN0LicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBuZXcgVVJMKHVybCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVSTCBwcm92aWRlZC4gUGxlYXNlIHVzZSBhIHZhbGlkIFVSTC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn07XG5leHBvcnRzLnZhbGlkYXRlVXJsID0gdmFsaWRhdGVVcmw7XG52YXIgdmFsaWRhdGVCYXNlVXJsID0gZnVuY3Rpb24gKGJhc2VVcmwpIHtcbiAgICBpZiAoIWJhc2VVcmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIFVSTCBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFVSTChiYXNlVXJsKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQmFzZSBVUkwgcHJvdmlkZWQuIFBsZWFzZSB1c2UgYSB2YWxpZCBVUkwuJyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlVXJsO1xufTtcbmV4cG9ydHMudmFsaWRhdGVCYXNlVXJsID0gdmFsaWRhdGVCYXNlVXJsO1xudmFyIHZhbGlkYXRlRndDb25zdGFudHMgPSBmdW5jdGlvbiAoZndDb25zdGFudHMpIHtcbiAgICBpZiAoIWZ3Q29uc3RhbnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlybXdhcmUgY29uc3RhbnRzIGRvIG5vdCBleGlzdC4gUGxlYXNlIHJlY29ubmVjdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ3Q29uc3RhbnRzO1xufTtcbmV4cG9ydHMudmFsaWRhdGVGd0NvbnN0YW50cyA9IHZhbGlkYXRlRndDb25zdGFudHM7XG52YXIgdmFsaWRhdGVGd1ZlcnNpb24gPSBmdW5jdGlvbiAoZndWZXJzaW9uKSB7XG4gICAgaWYgKCFmd1ZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJtd2FyZSB2ZXJzaW9uIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgcmVjb25uZWN0LicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZ3VmVyc2lvbi5maXggIT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiBmd1ZlcnNpb24ubWlub3IgIT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiBmd1ZlcnNpb24ubWFqb3IgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlybXdhcmUgdmVyc2lvbiBpbXByb3Blcmx5IGZvcm1hdHRlZC4gUGxlYXNlIHJlY29ubmVjdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ3VmVyc2lvbjtcbn07XG5leHBvcnRzLnZhbGlkYXRlRndWZXJzaW9uID0gdmFsaWRhdGVGd1ZlcnNpb247XG52YXIgdmFsaWRhdGVSZXF1ZXN0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGlzVGltZW91dCA9IGVyci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJyAmJiBlcnIuZXJybm8gPT09ICdFVElNRSc7XG4gICAgaWYgKGlzVGltZW91dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVvdXQgd2FpdGluZyBmb3IgZGV2aWNlLiBQbGVhc2UgZW5zdXJlIGl0IGlzIGNvbm5lY3RlZCB0byB0aGUgaW50ZXJuZXQgYW5kIHRyeSBhZ2FpbiBpbiBhIG1pbnV0ZS4nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIG1ha2UgcmVxdWVzdCB0byBkZXZpY2U6XFxuXCIuY29uY2F0KGVyci5tZXNzYWdlKSk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVJlcXVlc3RFcnJvciA9IHZhbGlkYXRlUmVxdWVzdEVycm9yO1xudmFyIHZhbGlkYXRlV2FsbGV0ID0gZnVuY3Rpb24gKHdhbGxldCkge1xuICAgIGlmICghd2FsbGV0IHx8IHdhbGxldCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSB3YWxsZXQuJyk7XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXQ7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVdhbGxldCA9IHZhbGlkYXRlV2FsbGV0O1xudmFyIHZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50ID0gZnVuY3Rpb24gKGNsaWVudCkge1xuICAgIHZhciBhcHBOYW1lID0gKDAsIGV4cG9ydHMudmFsaWRhdGVBcHBOYW1lKShjbGllbnQuZ2V0QXBwTmFtZSgpKTtcbiAgICB2YXIgZXBoZW1lcmFsUHViID0gKDAsIGV4cG9ydHMudmFsaWRhdGVFcGhlbWVyYWxQdWIpKGNsaWVudC5lcGhlbWVyYWxQdWIpO1xuICAgIHZhciBzaGFyZWRTZWNyZXQgPSAoMCwgZXhwb3J0cy52YWxpZGF0ZVNoYXJlZFNlY3JldCkoY2xpZW50LnNoYXJlZFNlY3JldCk7XG4gICAgdmFyIHVybCA9ICgwLCBleHBvcnRzLnZhbGlkYXRlVXJsKShjbGllbnQudXJsKTtcbiAgICB2YXIgZndDb25zdGFudHMgPSAoMCwgZXhwb3J0cy52YWxpZGF0ZUZ3Q29uc3RhbnRzKShjbGllbnQuZ2V0RndDb25zdGFudHMoKSk7XG4gICAgdmFyIGZ3VmVyc2lvbiA9ICgwLCBleHBvcnRzLnZhbGlkYXRlRndWZXJzaW9uKShjbGllbnQuZ2V0RndWZXJzaW9uKCkpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBLZXkgaXMgcHJpdmF0ZVxuICAgIHZhciBrZXkgPSAoMCwgZXhwb3J0cy52YWxpZGF0ZUtleSkoY2xpZW50LmtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXBwTmFtZTogYXBwTmFtZSxcbiAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzLFxuICAgICAgICBmd1ZlcnNpb246IGZ3VmVyc2lvbixcbiAgICAgICAga2V5OiBrZXksXG4gICAgfTtcbn07XG5leHBvcnRzLnZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50ID0gdmFsaWRhdGVDb25uZWN0ZWRDbGllbnQ7XG52YXIgdmFsaWRhdGVFcGhlbWVyYWxQdWIgPSBmdW5jdGlvbiAoZXBoZW1lcmFsUHViKSB7XG4gICAgaWYgKCFlcGhlbWVyYWxQdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZXBoZW1lcmFsUHViYCAoZXBoZW1lcmFsIHB1YmxpYyBrZXkpIGlzIHJlcXVpcmVkLiBQbGVhc2UgcmVjb25uZWN0LicpO1xuICAgIH1cbiAgICByZXR1cm4gZXBoZW1lcmFsUHViO1xufTtcbmV4cG9ydHMudmFsaWRhdGVFcGhlbWVyYWxQdWIgPSB2YWxpZGF0ZUVwaGVtZXJhbFB1YjtcbnZhciB2YWxpZGF0ZVNoYXJlZFNlY3JldCA9IGZ1bmN0aW9uIChzaGFyZWRTZWNyZXQpIHtcbiAgICBpZiAoIXNoYXJlZFNlY3JldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXJlZCBzZWNyZXQgcmVxdWlyZWQuIFBsZWFzZSByZWNvbm5lY3QuJyk7XG4gICAgfVxuICAgIHJldHVybiBzaGFyZWRTZWNyZXQ7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVNoYXJlZFNlY3JldCA9IHZhbGlkYXRlU2hhcmVkU2VjcmV0O1xudmFyIHZhbGlkYXRlS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5IGlzIHJlcXVpcmVkLiBQbGVhc2UgcmVjb25uZWN0LicpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufTtcbmV4cG9ydHMudmFsaWRhdGVLZXkgPSB2YWxpZGF0ZUtleTtcbnZhciB2YWxpZGF0ZUFjdGl2ZVdhbGxldHMgPSBmdW5jdGlvbiAoYWN0aXZlV2FsbGV0cykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAoIWFjdGl2ZVdhbGxldHMgfHxcbiAgICAgICAgKCgoX2IgPSAoX2EgPSBhY3RpdmVXYWxsZXRzID09PSBudWxsIHx8IGFjdGl2ZVdhbGxldHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZVdhbGxldHMuaW50ZXJuYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51aWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lcXVhbHMoY29uc3RhbnRzXzEuRU1QVFlfV0FMTEVUX1VJRCkpICYmXG4gICAgICAgICAgICAoKF9kID0gKF9jID0gYWN0aXZlV2FsbGV0cyA9PT0gbnVsbCB8fCBhY3RpdmVXYWxsZXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVXYWxsZXRzLmV4dGVybmFsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudWlkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZXF1YWxzKGNvbnN0YW50c18xLkVNUFRZX1dBTExFVF9VSUQpKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgd2FsbGV0LicpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlV2FsbGV0cztcbn07XG5leHBvcnRzLnZhbGlkYXRlQWN0aXZlV2FsbGV0cyA9IHZhbGlkYXRlQWN0aXZlV2FsbGV0cztcbnZhciB2YWxpZGF0ZUt2UmVjb3JkcyA9IGZ1bmN0aW9uIChyZWNvcmRzLCBmd0NvbnN0YW50cykge1xuICAgIGlmICghZndDb25zdGFudHMgfHwgIWZ3Q29uc3RhbnRzLmt2QWN0aW9uc0FsbG93ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSBmaXJtd2FyZS4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlY29yZHMgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKHJlY29yZHMpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb3IgbW9yZSBrZXktdmFsdWUgbWFwcGluZyBtdXN0IGJlIHByb3ZpZGVkIGluIGByZWNvcmRzYCBwYXJhbS4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoT2JqZWN0LmtleXMocmVjb3JkcykubGVuZ3RoID4gZndDb25zdGFudHMua3ZBY3Rpb25NYXhOdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIG1hbnkga2V5cyBwcm92aWRlZC4gUGxlYXNlIG9ubHkgcHJvdmlkZSB1cCB0byBcIi5jb25jYXQoZndDb25zdGFudHMua3ZBY3Rpb25NYXhOdW0sIFwiLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xufTtcbmV4cG9ydHMudmFsaWRhdGVLdlJlY29yZHMgPSB2YWxpZGF0ZUt2UmVjb3JkcztcbnZhciB2YWxpZGF0ZUt2UmVjb3JkID0gZnVuY3Rpb24gKF9hLCBmd0NvbnN0YW50cykge1xuICAgIHZhciBrZXkgPSBfYS5rZXksIHZhbCA9IF9hLnZhbDtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgU3RyaW5nKGtleSkubGVuZ3RoID4gZndDb25zdGFudHMua3ZLZXlNYXhTdHJTeikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgXCIuY29uY2F0KGtleSwgXCIgdG9vIGxhcmdlLiBNdXN0IGJlIDw9XCIpLmNvbmNhdChmd0NvbnN0YW50cy5rdktleU1heFN0clN6LCBcIiBjaGFyYWN0ZXJzLlwiKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIFN0cmluZyh2YWwpLmxlbmd0aCA+IGZ3Q29uc3RhbnRzLmt2VmFsTWF4U3RyU3opIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgXCIuY29uY2F0KHZhbCwgXCIgdG9vIGxhcmdlLiBNdXN0IGJlIDw9XCIpLmNvbmNhdChmd0NvbnN0YW50cy5rdlZhbE1heFN0clN6LCBcIiBjaGFyYWN0ZXJzLlwiKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFN0cmluZyhrZXkpLmxlbmd0aCA9PT0gMCB8fCBTdHJpbmcodmFsKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzIGFuZCB2YWx1ZXMgbXVzdCBiZSA+MCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICghY29uc3RhbnRzXzEuQVNDSUlfUkVHRVgudGVzdChrZXkpIHx8ICFjb25zdGFudHNfMS5BU0NJSV9SRUdFWC50ZXN0KHZhbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmljb2RlIGNoYXJhY3RlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IGtleToga2V5LCB2YWw6IHZhbCB9O1xufTtcbmV4cG9ydHMudmFsaWRhdGVLdlJlY29yZCA9IHZhbGlkYXRlS3ZSZWNvcmQ7XG52YXIgaXNWYWxpZEJsb2NrRXhwbG9yZXJSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICByZXR1cm4gISgwLCBpc0VtcHR5XzEuZGVmYXVsdCkocmVzdWx0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNWYWxpZEJsb2NrRXhwbG9yZXJSZXNwb25zZSA9IGlzVmFsaWRCbG9ja0V4cGxvcmVyUmVzcG9uc2U7XG52YXIgaXNWYWxpZDRCeXRlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhKDAsIGlzRW1wdHlfMS5kZWZhdWx0KShkYXRhLnJlc3VsdHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5pc1ZhbGlkNEJ5dGVSZXNwb25zZSA9IGlzVmFsaWQ0Qnl0ZVJlc3BvbnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVYVEVSTkFMID0gZXhwb3J0cy5nZXRWID0gZXhwb3J0cy5nZW5lcmF0ZUFwcFNlY3JldCA9IGV4cG9ydHMuZmV0Y2hDYWxsZGF0YURlY29kZXIgPSBleHBvcnRzLmZldGNoV2l0aFRpbWVvdXQgPSBleHBvcnRzLnNlbGVjdERlZkZyb200Ynl0ZUFCSSA9IGV4cG9ydHMuaXNVSW50NCA9IGV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLmV4aXN0c0luID0gZXhwb3J0cy5pc0FzY2lpU3RyID0gZXhwb3J0cy5idWlsZFNpZ25lclBhdGhCdWYgPSBleHBvcnRzLmdldFAyNTZLZXlQYWlyRnJvbVB1YiA9IGV4cG9ydHMuZ2V0UDI1NktleVBhaXIgPSBleHBvcnRzLnBhcnNlREVSID0gZXhwb3J0cy5hZXMyNTZfZGVjcnlwdCA9IGV4cG9ydHMuYWVzMjU2X2VuY3J5cHQgPSBleHBvcnRzLmZpeExlbiA9IGV4cG9ydHMuZW5zdXJlSGV4QnVmZmVyID0gZXhwb3J0cy5zcGxpdEZyYW1lcyA9IGV4cG9ydHMuaXNWYWxpZEFzc2V0UGF0aCA9IGV4cG9ydHMudG9QYWRkZWRERVIgPSBleHBvcnRzLmNoZWNrc3VtID0gZXhwb3J0cy5wYXJzZUxhdHRpY2UxUmVzcG9uc2UgPSB2b2lkIDA7XG4vLyBTdGF0aWMgdXRpbGl0eSBmdW5jdGlvbnNcbnZhciB0eF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpO1xudmFyIGFlc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhZXMtanNcIikpO1xudmFyIGJpZ251bWJlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIikpO1xudmFyIGJuX2pzXzEgPSByZXF1aXJlKFwiYm4uanNcIik7XG52YXIgY3JjXzMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNyYy0zMlwiKSk7XG52YXIgZWxsaXB0aWNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZWxsaXB0aWNcIikpO1xudmFyIHNoYV8xID0gcmVxdWlyZShcImhhc2guanMvbGliL2hhc2gvc2hhXCIpO1xudmFyIGpzX3NoYTNfMSA9IHJlcXVpcmUoXCJqcy1zaGEzXCIpO1xudmFyIGluUmFuZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2luUmFuZ2VcIikpO1xudmFyIGlzSW50ZWdlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNJbnRlZ2VyXCIpKTtcbnZhciBybHBfMSA9IHJlcXVpcmUoXCJybHBcIik7XG52YXIgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwic2VjcDI1NmsxXCIpO1xudmFyIF8xID0gcmVxdWlyZShcIi5cIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuL3NoYXJlZC92YWxpZGF0b3JzXCIpO1xudmFyIENPSU5TID0gY29uc3RhbnRzXzEuQklQX0NPTlNUQU5UUy5DT0lOUywgUFVSUE9TRVMgPSBjb25zdGFudHNfMS5CSVBfQ09OU1RBTlRTLlBVUlBPU0VTO1xudmFyIEVDID0gZWxsaXB0aWNfMS5kZWZhdWx0LmVjO1xudmFyIGVjO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTEFUVElDRSBVVElMU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqIEBpbnRlcm5hbCBQYXJzZSBhIHJlc3BvbnNlIGZyb20gdGhlIExhdHRpY2UxICovXG52YXIgcGFyc2VMYXR0aWNlMVJlc3BvbnNlID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2YXIgcGFyc2VkID0ge1xuICAgICAgICBlcnJvck1lc3NhZ2U6IG51bGwsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgfTtcbiAgICB2YXIgYiA9IEJ1ZmZlci5mcm9tKHIsICdoZXgnKTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICAvLyBHZXQgcHJvdG9jb2wgdmVyc2lvblxuICAgIHZhciBwcm90b1ZlciA9IGIucmVhZFVJbnQ4KG9mZik7XG4gICAgb2ZmKys7XG4gICAgaWYgKHByb3RvVmVyICE9PSBjb25zdGFudHNfMS5WRVJTSU9OX0JZVEUpIHtcbiAgICAgICAgcGFyc2VkLmVycm9yTWVzc2FnZSA9ICdJbmNvcnJlY3QgcHJvdG9jb2wgdmVyc2lvbi4gUGxlYXNlIHVwZGF0ZSB5b3VyIFNESyc7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgdHlwZSBvZiByZXNwb25zZVxuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgMHgwMFxuICAgIHZhciBtc2dUeXBlID0gYi5yZWFkVUludDgob2ZmKTtcbiAgICBvZmYrKztcbiAgICBpZiAobXNnVHlwZSAhPT0gMHgwMCkge1xuICAgICAgICBwYXJzZWQuZXJyb3JNZXNzYWdlID0gJ0luY29ycmVjdCByZXNwb25zZSBmcm9tIExhdHRpY2UxJztcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBwYXlsb2FkXG4gICAgYi5yZWFkVUludDMyQkUob2ZmKTtcbiAgICBvZmYgKz0gNDsgLy8gRmlyc3QgNCBieXRlcyBpcyB0aGUgaWQsIGJ1dCB3ZSBkb24ndCBuZWVkIHRoYXQgYW55bW9yZVxuICAgIHZhciBsZW4gPSBiLnJlYWRVSW50MTZCRShvZmYpO1xuICAgIG9mZiArPSAyO1xuICAgIHZhciBwYXlsb2FkID0gYi5zbGljZShvZmYsIG9mZiArIGxlbik7XG4gICAgb2ZmICs9IGxlbjtcbiAgICAvLyBHZXQgcmVzcG9uc2UgY29kZVxuICAgIHZhciByZXNwb25zZUNvZGUgPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgICBpZiAocmVzcG9uc2VDb2RlICE9PSBwcm90b2NvbF8xLkxhdHRpY2VSZXNwb25zZUNvZGUuc3VjY2Vzcykge1xuICAgICAgICB2YXIgZXJyTXNnID0gcHJvdG9jb2xfMS5Qcm90b2NvbENvbnN0YW50cy5yZXNwb25zZU1zZ1tyZXNwb25zZUNvZGVdO1xuICAgICAgICBwYXJzZWQuZXJyb3JNZXNzYWdlID0gXCJbTGF0dGljZV0gXCIuY29uY2F0KGVyck1zZyA/IGVyck1zZyA6ICdVbmtub3duIEVycm9yJyk7XG4gICAgICAgIHBhcnNlZC5yZXNwb25zZUNvZGUgPSByZXNwb25zZUNvZGU7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJzZWQuZGF0YSA9IHBheWxvYWQuc2xpY2UoMSwgcGF5bG9hZC5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBWZXJpZnkgY2hlY2tzdW1cbiAgICB2YXIgY3MgPSBiLnJlYWRVSW50MzJCRShvZmYpO1xuICAgIHZhciBleHBlY3RlZENzID0gKDAsIGV4cG9ydHMuY2hlY2tzdW0pKGIuc2xpY2UoMCwgYi5sZW5ndGggLSA0KSk7XG4gICAgaWYgKGNzICE9PSBleHBlY3RlZENzKSB7XG4gICAgICAgIHBhcnNlZC5lcnJvck1lc3NhZ2UgPSAnSW52YWxpZCBjaGVja3N1bSBmcm9tIGRldmljZSByZXNwb25zZSc7XG4gICAgICAgIHBhcnNlZC5kYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5leHBvcnRzLnBhcnNlTGF0dGljZTFSZXNwb25zZSA9IHBhcnNlTGF0dGljZTFSZXNwb25zZTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBjaGVja3N1bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgLy8gY3JjMzIgcmV0dXJucyBhIHNpZ25lZCBpbnRlZ2VyIC0gbmVlZCB0byBjYXN0IGl0IHRvIHVuc2lnbmVkXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgdXNlcyB0aGUgZGVmYXVsdCAweGVkYjg4MzIwIHBvbHlub21pYWxcbiAgICByZXR1cm4gY3JjXzMyXzEuZGVmYXVsdC5idWYoeCkgPj4+IDA7IC8vIE5lZWQgdGhpcyB0byBiZSBhIHVpbnQsIGhlbmNlIHRoZSBiaXQgc2hpZnRcbn07XG5leHBvcnRzLmNoZWNrc3VtID0gY2hlY2tzdW07XG4vLyBHZXQgYSA3NC1ieXRlIHBhZGRlZCBERVItZW5jb2RlZCBzaWduYXR1cmUgYnVmZmVyXG4vLyBgc2lnYCBtdXN0IGJlIHRoZSBzaWduYXR1cmUgb3V0cHV0IGZyb20gZWxsaXB0aWMuanNcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciB0b1BhZGRlZERFUiA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICAvLyBXZSB1c2UgNzQgYXMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIGEgREVSIHNpZ25hdHVyZS4gQWxsIHNpZ3MgbXVzdFxuICAgIC8vIGJlIHJpZ2h0LXBhZGRlZCB3aXRoIHplcm9zIHNvIHRoYXQgdGhpcyBjYW4gYmUgYSBmaXhlZCBzaXplIGZpZWxkXG4gICAgdmFyIGIgPSBCdWZmZXIuYWxsb2MoNzQpO1xuICAgIHZhciBkcyA9IEJ1ZmZlci5mcm9tKHNpZy50b0RFUigpKTtcbiAgICBkcy5jb3B5KGIpO1xuICAgIHJldHVybiBiO1xufTtcbmV4cG9ydHMudG9QYWRkZWRERVIgPSB0b1BhZGRlZERFUjtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRSQU5TQUNUSU9OIFVUSUxTXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogQGludGVybmFsICovXG52YXIgaXNWYWxpZEFzc2V0UGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBmd0NvbnN0YW50cykge1xuICAgIHZhciBhbGxvd2VkUHVycG9zZXMgPSBbXG4gICAgICAgIFBVUlBPU0VTLkVUSCxcbiAgICAgICAgUFVSUE9TRVMuQlRDX0xFR0FDWSxcbiAgICAgICAgUFVSUE9TRVMuQlRDX1dSQVBQRURfU0VHV0lULFxuICAgICAgICBQVVJQT1NFUy5CVENfU0VHV0lULFxuICAgIF07XG4gICAgdmFyIGFsbG93ZWRDb2lucyA9IFtDT0lOUy5FVEgsIENPSU5TLkJUQywgQ09JTlMuQlRDX1RFU1RORVRdO1xuICAgIC8vIFRoZXNlIGNvaW4gdHlwZXMgd2VyZSBnaXZlbiB0byB1cyBieSBNeUNyeXB0by4gVGhleSBzaG91bGQgYmUgYWxsb3dlZCwgYnV0IHdlIGV4cGVjdFxuICAgIC8vIGFuIEV0aGVyZXVtLXR5cGUgYWRkcmVzcyB3aXRoIHRoZXNlIGNvaW4gdHlwZXMuXG4gICAgLy8gVGhlc2UgYWxsIHVzZSBTTElQNDQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iL21hc3Rlci9zbGlwLTAwNDQubWRcbiAgICB2YXIgYWxsb3dlZE15Q3J5cHRvQ29pbnMgPSBbXG4gICAgICAgIDYwLCA2MSwgOTY2LCA3MDAsIDkwMDYsIDkwMDAsIDEwMDcsIDU1MywgMTc4LCAxMzcsIDM3MzEwLCAxMDgsIDQwLCA4ODksXG4gICAgICAgIDE5ODcsIDgyMCwgNjA2MCwgMTYyMCwgMTMxMzExNCwgNzYsIDI0NjUyOSwgMjQ2Nzg1LCAxMDAxLCAyMjcsIDkxNiwgNDY0LFxuICAgICAgICAyMjIxLCAzNDQsIDczNzk5LCAyNDYsXG4gICAgXTtcbiAgICAvLyBNYWtlIHN1cmUgZmlybXdhcmUgc3VwcG9ydHMgdGhpcyBCaXRjb2luIHBhdGhcbiAgICB2YXIgaXNCaXRjb2luID0gcGF0aFsxXSA9PT0gQ09JTlMuQlRDIHx8IHBhdGhbMV0gPT09IENPSU5TLkJUQ19URVNUTkVUO1xuICAgIHZhciBpc0JpdGNvaW5Ob25XcmFwcGVkU2Vnd2l0ID0gaXNCaXRjb2luICYmIHBhdGhbMF0gIT09IFBVUlBPU0VTLkJUQ19XUkFQUEVEX1NFR1dJVDtcbiAgICBpZiAoaXNCaXRjb2luTm9uV3JhcHBlZFNlZ3dpdCAmJiAhZndDb25zdGFudHMuYWxsb3dCdGNMZWdhY3lBbmRTZWd3aXRBZGRycylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBhdGggaXMgb3RoZXJ3aXNlIHZhbGlkXG4gICAgcmV0dXJuIChhbGxvd2VkUHVycG9zZXMuaW5kZXhPZihwYXRoWzBdKSA+PSAwICYmXG4gICAgICAgIChhbGxvd2VkQ29pbnMuaW5kZXhPZihwYXRoWzFdKSA+PSAwIHx8XG4gICAgICAgICAgICBhbGxvd2VkTXlDcnlwdG9Db2lucy5pbmRleE9mKHBhdGhbMV0gLSBjb25zdGFudHNfMS5IQVJERU5FRF9PRkZTRVQpID4gMCkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZEFzc2V0UGF0aCA9IGlzVmFsaWRBc3NldFBhdGg7XG4vKiogQGludGVybmFsICovXG52YXIgc3BsaXRGcmFtZXMgPSBmdW5jdGlvbiAoZGF0YSwgZnJhbWVTeikge1xuICAgIHZhciBmcmFtZXMgPSBbXTtcbiAgICB2YXIgbiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIGZyYW1lU3opO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZyYW1lcy5wdXNoKGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBmcmFtZVN6KSk7XG4gICAgICAgIG9mZiArPSBmcmFtZVN6O1xuICAgIH1cbiAgICByZXR1cm4gZnJhbWVzO1xufTtcbmV4cG9ydHMuc3BsaXRGcmFtZXMgPSBzcGxpdEZyYW1lcztcbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGlzQmFzZTEwTnVtU3RyKHgpIHtcbiAgICB2YXIgYm4gPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh4KS50b0ZpeGVkKCkuc3BsaXQoJy4nKS5qb2luKCcnKTtcbiAgICB2YXIgcyA9IG5ldyBTdHJpbmcoeCk7XG4gICAgLy8gTm90ZSB0aGF0IHRoZSBKUyBuYXRpdmUgYFN0cmluZygpYCBsb3NlcyBwcmVjaXNpb24gZm9yIGxhcmdlIG51bWJlcnMsIGJ1dCB3ZSBvbmx5XG4gICAgLy8gd2FudCB0byB2YWxpZGF0ZSB0aGUgYmFzZSBvZiB0aGUgbnVtYmVyIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgZmFyIG91dCBwcmVjaXNpb24uXG4gICAgcmV0dXJuIGJuLnNsaWNlKDAsIDgpID09PSBzLnNsaWNlKDAsIDgpO1xufVxuLyoqIEBpbnRlcm5hbCBFbnN1cmUgYSBwYXJhbSBpcyByZXByZXNlbnRlZCBieSBhIGJ1ZmZlciAqL1xudmFyIGVuc3VyZUhleEJ1ZmZlciA9IGZ1bmN0aW9uICh4LCB6ZXJvSXNOdWxsKSB7XG4gICAgaWYgKHplcm9Jc051bGwgPT09IHZvaWQgMCkgeyB6ZXJvSXNOdWxsID0gdHJ1ZTsgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIEZvciBudWxsIHZhbHVlcywgcmV0dXJuIGEgMC1zaXplZCBidWZmZXIuIEZvciBtb3N0IHNpdHVhdGlvbnMgd2UgYXNzdW1lXG4gICAgICAgIC8vIDAgc2hvdWxkIGJlIHJlcHJlc2VudGVkIHdpdGggYSB6ZXJvLWxlbmd0aCBidWZmZXIgKGUuZy4gZm9yIFJMUC1idWlsZGluZ1xuICAgICAgICAvLyB0eHMpLCBidXQgaXQgY2FuIGFsc28gYmUgdHJlYXRlZCBhcyBhIDEtYnl0ZSBidWZmZXIgKGAwMGApIGlmIG5lZWRlZFxuICAgICAgICBpZiAoeCA9PT0gbnVsbCB8fCAoeCA9PT0gMCAmJiB6ZXJvSXNOdWxsID09PSB0cnVlKSlcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHZhciBpc051bWJlciA9IHR5cGVvZiB4ID09PSAnbnVtYmVyJyB8fCBpc0Jhc2UxME51bVN0cih4KTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRyeSB0byBnZXQgdGhpcyBjb252ZXJ0ZWQgdG8gYSBoZXggc3RyaW5nXG4gICAgICAgIGlmIChpc051bWJlcikge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG51bWJlciBvciBhIGJhc2UtMTAgbnVtYmVyIHN0cmluZywgY29udmVydCBpdCB0byBoZXhcbiAgICAgICAgICAgIHggPSBcIlwiLmNvbmNhdChuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh4KS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiB4LnNsaWNlKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICB4ID0geC5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSB4LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5sZW5ndGggJSAyID4gMClcbiAgICAgICAgICAgIHggPSBcIjBcIi5jb25jYXQoeCk7XG4gICAgICAgIGlmICh4ID09PSAnMDAnICYmICFpc051bWJlcilcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh4LCAnaGV4Jyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgXCIuY29uY2F0KHgudG9TdHJpbmcoKSwgXCIgdG8gaGV4IGJ1ZmZlciAoXCIpLmNvbmNhdChlcnIudG9TdHJpbmcoKSwgXCIpXCIpKTtcbiAgICB9XG59O1xuZXhwb3J0cy5lbnN1cmVIZXhCdWZmZXIgPSBlbnN1cmVIZXhCdWZmZXI7XG4vKiogQGludGVybmFsICovXG52YXIgZml4TGVuID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG59O1xuZXhwb3J0cy5maXhMZW4gPSBmaXhMZW47XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUllQVE8gVVRJTFNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBhZXMyNTZfZW5jcnlwdCA9IGZ1bmN0aW9uIChkYXRhLCBrZXkpIHtcbiAgICB2YXIgaXYgPSBCdWZmZXIuZnJvbShwcm90b2NvbF8xLlByb3RvY29sQ29uc3RhbnRzLmFlc0l2KTtcbiAgICB2YXIgYWVzQ2JjID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksIGl2KTtcbiAgICB2YXIgcGFkZGVkRGF0YSA9IGRhdGEubGVuZ3RoICUgMTYgPT09IDAgPyBkYXRhIDogYWVzX2pzXzEuZGVmYXVsdC5wYWRkaW5nLnBrY3M3LnBhZChkYXRhKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYWVzQ2JjLmVuY3J5cHQocGFkZGVkRGF0YSkpO1xufTtcbmV4cG9ydHMuYWVzMjU2X2VuY3J5cHQgPSBhZXMyNTZfZW5jcnlwdDtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBhZXMyNTZfZGVjcnlwdCA9IGZ1bmN0aW9uIChkYXRhLCBrZXkpIHtcbiAgICB2YXIgaXYgPSBCdWZmZXIuZnJvbShwcm90b2NvbF8xLlByb3RvY29sQ29uc3RhbnRzLmFlc0l2KTtcbiAgICB2YXIgYWVzQ2JjID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksIGl2KTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYWVzQ2JjLmRlY3J5cHQoZGF0YSkpO1xufTtcbmV4cG9ydHMuYWVzMjU2X2RlY3J5cHQgPSBhZXMyNTZfZGVjcnlwdDtcbi8vIERlY29kZSBhIERFUiBzaWduYXR1cmUuIFJldHVybnMgc2lnbmF0dXJlIG9iamVjdCB7ciwgcyB9IG9yIG51bGwgaWYgdGhlcmUgaXMgYW4gZXJyb3Jcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBwYXJzZURFUiA9IGZ1bmN0aW9uIChzaWdCdWYpIHtcbiAgICBpZiAoc2lnQnVmWzBdICE9PSAweDMwIHx8IHNpZ0J1ZlsyXSAhPT0gMHgwMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjb2RlIERFUiBzaWduYXR1cmUnKTtcbiAgICB2YXIgb2ZmID0gMztcbiAgICB2YXIgckxlbiA9IHNpZ0J1ZltvZmZdO1xuICAgIG9mZisrO1xuICAgIHZhciByID0gc2lnQnVmLnNsaWNlKG9mZiwgb2ZmICsgckxlbik7XG4gICAgb2ZmICs9IHJMZW47XG4gICAgaWYgKHNpZ0J1ZltvZmZdICE9PSAweDAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgREVSIHNpZ25hdHVyZScpO1xuICAgIG9mZisrO1xuICAgIHZhciBzTGVuID0gc2lnQnVmW29mZl07XG4gICAgb2ZmKys7XG4gICAgdmFyIHMgPSBzaWdCdWYuc2xpY2Uob2ZmLCBvZmYgKyBzTGVuKTtcbiAgICByZXR1cm4geyByOiByLCBzOiBzIH07XG59O1xuZXhwb3J0cy5wYXJzZURFUiA9IHBhcnNlREVSO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGdldFAyNTZLZXlQYWlyID0gZnVuY3Rpb24gKHByaXYpIHtcbiAgICBpZiAoZWMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgZWMgPSBuZXcgRUMoJ3AyNTYnKTtcbiAgICByZXR1cm4gZWMua2V5RnJvbVByaXZhdGUocHJpdiwgJ2hleCcpO1xufTtcbmV4cG9ydHMuZ2V0UDI1NktleVBhaXIgPSBnZXRQMjU2S2V5UGFpcjtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBnZXRQMjU2S2V5UGFpckZyb21QdWIgPSBmdW5jdGlvbiAocHViKSB7XG4gICAgaWYgKGVjID09PSB1bmRlZmluZWQpXG4gICAgICAgIGVjID0gbmV3IEVDKCdwMjU2Jyk7XG4gICAgcmV0dXJuIGVjLmtleUZyb21QdWJsaWMocHViLCAnaGV4Jyk7XG59O1xuZXhwb3J0cy5nZXRQMjU2S2V5UGFpckZyb21QdWIgPSBnZXRQMjU2S2V5UGFpckZyb21QdWI7XG4vKiogQGludGVybmFsICovXG52YXIgYnVpbGRTaWduZXJQYXRoQnVmID0gZnVuY3Rpb24gKHNpZ25lclBhdGgsIHZhckFkZHJQYXRoU3pBbGxvd2VkKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygyNCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKHZhckFkZHJQYXRoU3pBbGxvd2VkICYmIHNpZ25lclBhdGgubGVuZ3RoID4gNSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduZXIgcGF0aCBtdXN0IGJlIDw9NSBpbmRpY2VzLicpO1xuICAgIGlmICghdmFyQWRkclBhdGhTekFsbG93ZWQgJiYgc2lnbmVyUGF0aC5sZW5ndGggIT09IDUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBMYXR0aWNlIGZpcm13YXJlIG9ubHkgc3VwcG9ydHMgNS1pbmRleCBkZXJpdmF0aW9uIHBhdGhzLiBQbGVhc2UgdXBncmFkZS4nKTtcbiAgICBidWYud3JpdGVVSW50MzJMRShzaWduZXJQYXRoLmxlbmd0aCwgb2ZmKTtcbiAgICBvZmYgKz0gNDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBpZiAoaSA8IHNpZ25lclBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgYnVmLndyaXRlVUludDMyTEUoc2lnbmVyUGF0aFtpXSwgb2ZmKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnVmLndyaXRlVUludDMyTEUoMCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuZXhwb3J0cy5idWlsZFNpZ25lclBhdGhCdWYgPSBidWlsZFNpZ25lclBhdGhCdWY7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPVEhFUiBVVElMU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGlzQXNjaWlTdHIgPSBmdW5jdGlvbiAoc3RyLCBhbGxvd0Zvcm1hdENoYXJzKSB7XG4gICAgaWYgKGFsbG93Rm9ybWF0Q2hhcnMgPT09IHZvaWQgMCkgeyBhbGxvd0Zvcm1hdENoYXJzID0gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZXh0cmFDaGFycyA9IGFsbG93Rm9ybWF0Q2hhcnMgP1xuICAgICAgICBbXG4gICAgICAgICAgICAweDAwMjAsXG4gICAgICAgICAgICAweDAwMGEsIC8vIE5ldyBsaW5lXG4gICAgICAgIF0gOiBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoZXh0cmFDaGFycy5pbmRleE9mKGMpIDwgMCAmJiAoYyA8IDB4MDAyMCB8fCBjID4gMHgwMDdmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmV4cG9ydHMuaXNBc2NpaVN0ciA9IGlzQXNjaWlTdHI7XG4vKiogQGludGVybmFsIENoZWNrIGlmIGEgdmFsdWUgZXhpc3RzIGluIGFuIG9iamVjdC4gT25seSBjaGVja3MgZmlyc3QgbGV2ZWwgb2Yga2V5cy4gKi9cbnZhciBleGlzdHNJbiA9IGZ1bmN0aW9uICh2YWwsIG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb2JqW2tleV0gPT09IHZhbDsgfSk7XG59O1xuZXhwb3J0cy5leGlzdHNJbiA9IGV4aXN0c0luO1xuLyoqIEBpbnRlcm5hbCBDcmVhdGUgYSBidWZmZXIgb2Ygc2l6ZSBgbmAgYW5kIGZpbGwgaXQgd2l0aCByYW5kb20gZGF0YSAqL1xudmFyIHJhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKG4pIHtcbiAgICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGJ1ZltpXSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLyoqIEBpbnRlcm5hbCBgaXNVSW50NGAgYWNjZXB0cyBhIG51bWJlciBhbmQgcmV0dXJucyB0cnVlIGlmIGl0IGlzIGEgVUludDQgKi9cbnZhciBpc1VJbnQ0ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuICgwLCBpc0ludGVnZXJfMS5kZWZhdWx0KShuKSAmJiAoMCwgaW5SYW5nZV8xLmRlZmF1bHQpKG4sIDAsIDE2KTsgfTtcbmV4cG9ydHMuaXNVSW50NCA9IGlzVUludDQ7XG4vKipcbiAqIEZldGNoZXMgYW4gZXh0ZXJuYWwgSlNPTiBmaWxlIGNvbnRhaW5pbmcgbmV0d29ya3MgaW5kZXhlZCBieSBjaGFpbiBpZCBmcm9tIGEgR3JpZFBsdXMgcmVwbywgYW5kXG4gKiByZXR1cm5zIHRoZSBwYXJzZWQgSlNPTi5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hFeHRlcm5hbE5ldHdvcmtGb3JDaGFpbklkKGNoYWluSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib2R5LCBlcnJfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2goY29uc3RhbnRzXzEuRVhURVJOQUxfTkVUV09SS1NfQllfQ0hBSU5fSURfVVJMKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5qc29uKCk7IH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYm9keVtjaGFpbklkXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZldGNoaW5nIGV4dGVybmFsIG5ldHdvcmtzIGZhaWxlZC5cXG4nLCBlcnJfMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogQnVpbGRzIGEgVVJMIGZvciBmZXRjaGluZyBjYWxsZGF0YSBmcm9tIGJsb2NrIGV4cGxvcmVycyBmb3IgYW55IHN1cHBvcnRlZCBjaGFpbnNcbiAqICovXG5mdW5jdGlvbiBidWlsZFVybEZvclN1cHBvcnRlZENoYWluQW5kQWRkcmVzcyhfYSkge1xuICAgIHZhciBzdXBwb3J0ZWRDaGFpbiA9IF9hLnN1cHBvcnRlZENoYWluLCBhZGRyZXNzID0gX2EuYWRkcmVzcztcbiAgICB2YXIgYmFzZVVybCA9IHN1cHBvcnRlZENoYWluLmJhc2VVcmw7XG4gICAgdmFyIGFwaVJvdXRlID0gc3VwcG9ydGVkQ2hhaW4uYXBpUm91dGU7XG4gICAgdmFyIHVybFdpdGhSb3V0ZSA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL1wiKS5jb25jYXQoYXBpUm91dGUsIFwiJmFkZHJlc3M9XCIpLmNvbmNhdChhZGRyZXNzKTtcbiAgICB2YXIgYXBpS2V5ID0gbnVsbDtcbiAgICB2YXIgYXBpS2V5UGFyYW0gPSBhcGlLZXkgPyBcIiZhcGlLZXk9XCIuY29uY2F0KG51bGwpIDogJyc7XG4gICAgcmV0dXJuIHVybFdpdGhSb3V0ZSArIGFwaUtleVBhcmFtO1xufVxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgQUJJIGRhdGEgb2JqZWN0cyBhbmQgYSBzZWxlY3RvciwgYW5kIHJldHVybnMgdGhlIGVhcmxpZXN0IEFCSSBkYXRhIG9iamVjdCB0aGF0XG4gKiBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0RGVmRnJvbTRieXRlQUJJKGFiaURhdGEsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGFiaURhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IFRoZXJlIGFyZSBtdWx0aXBsZSByZXN1bHRzLiBVc2luZyB0aGUgZmlyc3Qgb25lLicpO1xuICAgIH1cbiAgICB2YXIgZGVmO1xuICAgIGFiaURhdGFcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGFUaW1lID0gbmV3IERhdGUoYS5jcmVhdGVkX2F0KS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBiVGltZSA9IG5ldyBEYXRlKGIuY3JlYXRlZF9hdCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gYVRpbWUgLSBiVGltZTtcbiAgICB9KVxuICAgICAgICAuZmluZChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWYgPSBfMS5DYWxsZGF0YS5FVk0ucGFyc2Vycy5wYXJzZUNhbm9uaWNhbE5hbWUoc2VsZWN0b3IsIHJlc3VsdC50ZXh0X3NpZ25hdHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gISFkZWY7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRlZikge1xuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBkZWZpbml0aW9uIGZvciBzZWxlY3RvcicpO1xuICAgIH1cbn1cbmV4cG9ydHMuc2VsZWN0RGVmRnJvbTRieXRlQUJJID0gc2VsZWN0RGVmRnJvbTRieXRlQUJJO1xuZnVuY3Rpb24gZmV0Y2hXaXRoVGltZW91dCh1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgdGltZW91dCwgY29udHJvbGxlciwgdGltZW91dElkLCByZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBvcHRpb25zLnRpbWVvdXQsIHRpbWVvdXQgPSBfYSA9PT0gdm9pZCAwID8gODAwMCA6IF9hO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xsZXIuYWJvcnQoKTsgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwgX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSkpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoV2l0aFRpbWVvdXQgPSBmZXRjaFdpdGhUaW1lb3V0O1xuZnVuY3Rpb24gZmV0Y2hBbmRDYWNoZSh1cmwsIG9wdHMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgcmVxdWVzdCwgbWF0Y2gsIHJlc3BvbnNlLCByZXNwb25zZUNsb25lLCBkYXRhLCBlcnJfMjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAxMSwgLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShnbG9iYWxUaGlzLmNhY2hlcyAmJiBnbG9iYWxUaGlzLlJlcXVlc3QpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY2FjaGVzLm9wZW4oJ2dwLWNhbGxkYXRhJyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjYWNoZS5tYXRjaChyZXF1ZXN0KV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBtYXRjaF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaChyZXF1ZXN0LCBvcHRzKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5vayAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCgwLCB2YWxpZGF0b3JzXzEuaXNWYWxpZEJsb2NrRXhwbG9yZXJSZXNwb25zZSkoZGF0YSkgfHwgKDAsIHZhbGlkYXRvcnNfMS5pc1ZhbGlkNEJ5dGVSZXNwb25zZSkoZGF0YSkpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNhY2hlLnB1dChyZXF1ZXN0LCByZXNwb25zZUNsb25lKV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjYWNoZS5tYXRjaChyZXF1ZXN0LCBvcHRzKV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VdO1xuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZldGNoKHVybCwgb3B0cyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBlcnJfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJfMik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycl8yO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmZXRjaFN1cHBvcnRlZENoYWluRGF0YShhZGRyZXNzLCBzdXBwb3J0ZWRDaGFpbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdXJsID0gYnVpbGRVcmxGb3JTdXBwb3J0ZWRDaGFpbkFuZEFkZHJlc3MoeyBhZGRyZXNzOiBhZGRyZXNzLCBzdXBwb3J0ZWRDaGFpbjogc3VwcG9ydGVkQ2hhaW4gfSk7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmV0Y2hBbmRDYWNoZSh1cmwpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5qc29uKCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5ICYmIGJvZHkucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciByZXNwb25zZSB3YXMgbWFsZm9ybWVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZldGNoaW5nIGRhdGEgZnJvbSBleHRlcm5hbCBuZXR3b3JrIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmZXRjaDRieXRlRGF0YShzZWxlY3Rvcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJodHRwczovL3d3dy40Ynl0ZS5kaXJlY3RvcnkvYXBpL3YxL3NpZ25hdHVyZXMvP2hleF9zaWduYXR1cmU9MHhcIi5jb25jYXQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaCh1cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmpzb24oKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5ICYmIGJvZHkucmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9keS5yZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXN1bHRzIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZldGNoaW5nIGRhdGEgZnJvbSA0Ynl0ZSBmYWlsZWQ6IFwiLmNvbmNhdChlcnIubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW5jb2RlRGVmKGRlZikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgcmxwXzEuZW5jb2RlKShkZWYpKTtcbn1cbi8qKlxuICogUG9zdC1wcm9jZXNzIGZldGNoZWQgQUJJIGRlZmluaXRpb24uXG4gKiBAcGFyYW0gZGVmIC0gQ2FsbGRhdGEgZGVjb2RlciBkYXRhIGRlZmluaXRpb24gZm9yIGNhbGxpbmcgZnVuY3Rpb25cbiAqIEBwYXJhbSBjYWxsZGF0YSAtIFJhdyB0cmFuc2FjdGlvbiBjYWxsZGF0YVxuICogQHJldHVybiAtIFVwZGF0ZWQgYGRlZmBcbiAqL1xuZnVuY3Rpb24gcG9zdFByb2Nlc3NEZWYoZGVmLCBjYWxsZGF0YSkge1xuICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5lc3RlZENhbGxkYXRhLCBuZXN0ZWREZWZzLCBfYywgX2UsIGksIF9mLCBfZywgaiwgX2gsIF9qLCBlXzJfMSwgX2ssIF9sLCBlXzFfMSwgbmV3RGVmO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9tKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9tLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRDYWxsZGF0YSA9IF8xLkNhbGxkYXRhLkVWTS5wcm9jZXNzb3JzLmdldE5lc3RlZENhbGxkYXRhKGRlZiwgY2FsbGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXBsYWNlTmVzdGVkRGVmcyhuZXN0ZWRDYWxsZGF0YSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmcyA9IF9tLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX20ubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX20udHJ5cy5wdXNoKFsyLCAyMiwgMjMsIDI4XSk7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX19hc3luY1ZhbHVlcyhuZXN0ZWREZWZzLmVudHJpZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIF9tLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfZSA9IF9tLnNlbnQoKSwgIV9lLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAyMV07XG4gICAgICAgICAgICAgICAgICAgIGkgPSBfZS52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShuZXN0ZWREZWZzW2ldKSAmJiB0eXBlb2YgbmVzdGVkRGVmc1tpXVswXSAhPT0gJ3N0cmluZycpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgIF9tLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF9tLnRyeXMucHVzaChbNSwgMTEsIDEyLCAxN10pO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IChlXzIgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMobmVzdGVkRGVmc1tpXS5lbnRyaWVzKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgX20ubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFs0IC8qeWllbGQqLywgX2YubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF9nID0gX20uc2VudCgpLCAhX2cuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgaiA9IF9nLnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShuZXN0ZWREZWZzW2ldW2pdICE9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIF9oID0gbmVzdGVkRGVmc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgX2ogPSBqO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3N0UHJvY2Vzc0RlZihuZXN0ZWREZWZzW2ldW2pdLCBCdWZmZXIuZnJvbShuZXN0ZWRDYWxsZGF0YVtpXVtqXS5zbGljZSgyKSwgJ2hleCcpKV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfaFtfal0gPSBfbS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9tLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9tLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIF9tLnRyeXMucHVzaChbMTIsICwgMTUsIDE2XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF9nICYmICFfZy5kb25lICYmIChfYiA9IF9mLnJldHVybikpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLmNhbGwoX2YpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBfbS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9tLmxhYmVsID0gMTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDIwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShuZXN0ZWREZWZzW2ldICE9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjBdO1xuICAgICAgICAgICAgICAgICAgICBfayA9IG5lc3RlZERlZnM7XG4gICAgICAgICAgICAgICAgICAgIF9sID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9zdFByb2Nlc3NEZWYobmVzdGVkRGVmc1tpXSwgQnVmZmVyLmZyb20obmVzdGVkQ2FsbGRhdGFbaV0uc2xpY2UoMiksICdoZXgnKSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgIF9rW19sXSA9IF9tLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX20ubGFiZWwgPSAyMDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIxOiByZXR1cm4gWzMgLypicmVhayovLCAyOF07XG4gICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfbS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDI4XTtcbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICBfbS50cnlzLnB1c2goWzIzLCAsIDI2LCAyN10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfZSAmJiAhX2UuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKF9jKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgX20uc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfbS5sYWJlbCA9IDI1O1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI3XTtcbiAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAyNzogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICAgICAgICBuZXdEZWYgPSBfMS5DYWxsZGF0YS5FVk0ucHJvY2Vzc29ycy5yZXBsYWNlTmVzdGVkRGVmcyhkZWYsIG5lc3RlZERlZnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3RGVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEdpdmVuIGEgc2V0IG9mIHBvc3NpYmxlIG5lc3RlZCBkZWZzLCBzbGljZSBvdXQgc2VsZWN0b3JzIGFuZCBsb29rIHVwXG4gKiBkZWZpbml0aW9ucyBvbiA0Ynl0ZS5cbiAqIEBwYXJhbSBwb3NzTmVzdGVkRGVmcyAtIHJlc3VsdCBvZiBgZ2V0UG9zc2libGVOZXN0ZWREZWZzYCBwcm9jZXNzb3JcbiAqIEByZXR1cm4gQXJyYXkgY29udGFpbmluZyBjYWxsZGF0YSBkZWNvZGluZyBkYXRhIGZvciBlYWNoIHBhcmFtZXRlclxuICogICAgICAgICAgdGhhdCBoYWQgYSBwb3NzaWJsZSBuZXN0ZWQgZGVmLiBJZiB0aGVyZSB3YXMgbm8gcG9zc2libGVcbiAqICAgICAgICAgIG5lc3RlZCBkZWYgb3IgaWYgYSBkZWYgY291bGQgbm90IGJlIGZldGNoZWQgZnJvbSA0Ynl0ZSwgdGhlXG4gKiAgICAgICAgICBhcnJheSBpdGVtIHdpbGwgYmUgYG51bGxgLiBJbiB0aGUgY2FzZSBvZiBtdWx0aXBsZSBwb3NzaWJsZVxuICogICAgICAgICAgZGVmcyBiZWhpbmQgb25lIHBhcmFtIChlLmcuIG11bHRpY2FsbCBwYXR0ZXJuKSwgQUxMIG5lc3RlZFxuICogICAgICAgICAgaXRlbXMgbXVzdCBoYXZlIGRlZnMgYXNzb2NpYXRlZCBvciB0aGUgaXRlbSB3aWxsIG1hcCB0byBhXG4gKiAgICAgICAgICBzaW5nbGUgYG51bGxgIHZhbHVlIGluIHRoZSByZXR1cm4gYXJyYXkuXG4gKlxuICovXG5mdW5jdGlvbiByZXBsYWNlTmVzdGVkRGVmcyhwb3NzTmVzdGVkRGVmcykge1xuICAgIHZhciBwb3NzTmVzdGVkRGVmc18xLCBwb3NzTmVzdGVkRGVmc18xXzE7XG4gICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmVzdGVkRGVmcywgZCwgX25lc3RlZERlZnMsIHNob3VsZEluY2x1ZGUsIGRfMSwgZF8xXzEsIF9kLCBfbmVzdGVkU2VsZWN0b3IsIF9uZXN0ZWRBYmksIF9uZXN0ZWREZWYsIGVycl8zLCBlXzRfMSwgbmVzdGVkU2VsZWN0b3IsIG5lc3RlZEFiaSwgbmVzdGVkRGVmLCBlcnJfNCwgZV8zXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZERlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAyNiwgMjcsIDMyXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvc3NOZXN0ZWREZWZzXzEgPSBfX2FzeW5jVmFsdWVzKHBvc3NOZXN0ZWREZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgcG9zc05lc3RlZERlZnNfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocG9zc05lc3RlZERlZnNfMV8xID0gX2Muc2VudCgpLCAhcG9zc05lc3RlZERlZnNfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAyNV07XG4gICAgICAgICAgICAgICAgICAgIGQgPSBwb3NzTmVzdGVkRGVmc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGQgIT09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyM107XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgICAgICBfbmVzdGVkRGVmcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRJbmNsdWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFs0LCAxMiwgMTMsIDE4XSk7XG4gICAgICAgICAgICAgICAgICAgIGRfMSA9IChlXzQgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMoZCkpO1xuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBkXzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRfMV8xID0gX2Muc2VudCgpLCAhZF8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBkXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFs3LCA5LCAsIDEwXSk7XG4gICAgICAgICAgICAgICAgICAgIF9uZXN0ZWRTZWxlY3RvciA9IF9kLnNsaWNlKDIsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2g0Ynl0ZURhdGEoX25lc3RlZFNlbGVjdG9yKV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfbmVzdGVkQWJpID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfbmVzdGVkRGVmID0gc2VsZWN0RGVmRnJvbTRieXRlQUJJKF9uZXN0ZWRBYmksIF9uZXN0ZWRTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIF9uZXN0ZWREZWZzLnB1c2goX25lc3RlZERlZik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGVycl8zID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRJbmNsdWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF9uZXN0ZWREZWZzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgZV80XzEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEzLCAsIDE2LCAxN10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkXzFfMSAmJiAhZF8xXzEuZG9uZSAmJiAoX2IgPSBkXzEucmV0dXJuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2IuY2FsbChkXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTU7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWREZWZzLnB1c2goX25lc3RlZERlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDIyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzE5LCAyMSwgLCAyMl0pO1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRTZWxlY3RvciA9IGQuc2xpY2UoMiwgMTApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaDRieXRlRGF0YShuZXN0ZWRTZWxlY3RvcildO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZEFiaSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmID0gc2VsZWN0RGVmRnJvbTRieXRlQUJJKG5lc3RlZEFiaSwgbmVzdGVkU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWREZWZzLnB1c2gobmVzdGVkRGVmKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgIGVycl80ID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWREZWZzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDIyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIyOiByZXR1cm4gWzMgLypicmVhayovLCAyNF07XG4gICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI0O1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDMyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICBlXzNfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8zID0geyBlcnJvcjogZV8zXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMzJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMjcsICwgMzAsIDMxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBvc3NOZXN0ZWREZWZzXzFfMSAmJiAhcG9zc05lc3RlZERlZnNfMV8xLmRvbmUgJiYgKF9hID0gcG9zc05lc3RlZERlZnNfMS5yZXR1cm4pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKHBvc3NOZXN0ZWREZWZzXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMzFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDMxOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMzI6IFxuICAgICAgICAgICAgICAgIC8vIEZvciBhbGwgbmVzdGVkIGRlZnMsIHJlcGxhY2UgdGhlIFxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXN0ZWREZWZzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFWFRFUk5BTCBVVElMU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiAgRmV0Y2hlcyBjYWxsZGF0YSBmcm9tIGEgcmVtb3RlIHNjYW5uZXIgYmFzZWQgb24gdGhlIHRyYW5zYWN0aW9uJ3MgYGNoYWluSWRgXG4gKi9cbmZ1bmN0aW9uIGZldGNoQ2FsbGRhdGFEZWNvZGVyKF9kYXRhLCB0bywgX2NoYWluSWQsIHJlY3Vyc2UpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNIZXhTdHJpbmcsIGRhdGEsIHNlbGVjdG9yLCBjaGFpbklkLCBjYWNoZWROZXR3b3JrLCBzdXBwb3J0ZWRDaGFpbiwgX2EsIGFiaV8xLCBwYXJzZWRBYmksIGRlZl8xLCBlcnJfNSwgYWJpLCBkZWYsIGVycl82O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzAsIDE1LCAsIDE2XSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4aXQgaWYgdGhlcmUgaXMgbm8gZGF0YS4gVGhlIDIgY29tZXMgZnJvbSB0aGUgMHggcHJlZml4LCBidXQgYSBsYXRlclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aWxsIGNvbmZpcm0gdGhhdCB0aGVyZSBhcmUgYXQgbGVhc3QgNCBieXRlcyBvZiBkYXRhIGluIHRoZSBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmICghX2RhdGEgfHwgX2RhdGEubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIGVpdGhlciB1bmRlZmluZWQgb3IgbGVzcyB0aGFuIHR3byBieXRlcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzSGV4U3RyaW5nID0gdHlwZW9mIF9kYXRhID09PSAnc3RyaW5nJyAmJiBfZGF0YS5zbGljZSgwLCAyKSA9PT0gJzB4JztcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGlzSGV4U3RyaW5nID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKF9kYXRhLnNsaWNlKDIpLCAnaGV4JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yIC0gQnVmZmVyIGRvZXNuJ3QgcmVjb2duaXplIFVpbnQ4QXJyYXkgdHlwZSBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oX2RhdGEsICdoZXgnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBhdCBsZWFzdCA0IGJ5dGVzIG9mIGRhdGEgdG8gZGVmaW5lIHRoZSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gQnVmZmVyLmZyb20oZGF0YS5zbGljZSgwLCA0KSkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gTnVtYmVyKF9jaGFpbklkKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkTmV0d29yayA9IGNvbnN0YW50c18xLk5FVFdPUktTX0JZX0NIQUlOX0lEW2NoYWluSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZE5ldHdvcmspIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBfYSA9IGNhY2hlZE5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hFeHRlcm5hbE5ldHdvcmtGb3JDaGFpbklkKGNoYWluSWQpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRDaGFpbiA9IF9hO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzQsIDEwLCAsIDExXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydGVkQ2hhaW4pIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaFN1cHBvcnRlZENoYWluRGF0YSh0bywgc3VwcG9ydGVkQ2hhaW4pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGFiaV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBYmkgPSBfMS5DYWxsZGF0YS5FVk0ucGFyc2Vycy5wYXJzZVNvbGlkaXR5SlNPTkFCSShzZWxlY3RvciwgYWJpXzEpO1xuICAgICAgICAgICAgICAgICAgICBkZWZfMSA9IHBhcnNlZEFiaS5kZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjdXJzZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHBvc3RQcm9jZXNzRGVmKGRlZl8xLCBkYXRhKV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBkZWZfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgYWJpOiBhYmlfMSwgZGVmOiBlbmNvZGVEZWYoZGVmXzEpIH1dO1xuICAgICAgICAgICAgICAgIGNhc2UgODogdGhyb3cgbmV3IEVycm9yKFwiQ2hhaW4gKGlkOiBcIi5jb25jYXQoY2hhaW5JZCwgXCIpIGlzIG5vdCBzdXBwb3J0ZWRcIikpO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGVycl81ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyXzUubWVzc2FnZSwgJ1xcbicsICdGYWxsaW5nIGJhY2sgdG8gNGJ5dGUnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoNGJ5dGVEYXRhKHNlbGVjdG9yKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgYWJpID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBkZWYgPSBzZWxlY3REZWZGcm9tNGJ5dGVBQkkoYWJpLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjdXJzZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3N0UHJvY2Vzc0RlZihkZWYsIGRhdGEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBkZWYgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgYWJpOiBhYmksIGRlZjogZW5jb2RlRGVmKGRlZikgfV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgZXJyXzYgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZldGNoaW5nIGNhbGxkYXRhIGZhaWxlZDogXCIuY29uY2F0KGVycl82Lm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6IHJldHVybiBbMiAvKnJldHVybiovLCB7IGRlZjogbnVsbCwgYWJpOiBudWxsIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hDYWxsZGF0YURlY29kZXIgPSBmZXRjaENhbGxkYXRhRGVjb2Rlcjtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFwcGxpY2F0aW9uIHNlY3JldCBmb3IgdXNlIGluIG1haW50YWluaW5nIGNvbm5lY3Rpb24gdG8gZGV2aWNlLlxuICogQHBhcmFtIGRldmljZUlkIC0gVGhlIGRldmljZSBJRCBvZiB0aGUgZGV2aWNlIHlvdSB3YW50IHRvIGdlbmVyYXRlIGEgdG9rZW4gZm9yLlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIGVudGVyZWQgd2hlbiBjb25uZWN0aW5nIHRvIHRoZSBkZXZpY2UuXG4gKiBAcGFyYW0gYXBwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEByZXR1cm5zIGFuIGFwcGxpY2F0aW9uIHNlY3JldCBhcyBhIEJ1ZmZlclxuICogQHB1YmxpY1xuICovXG52YXIgZ2VuZXJhdGVBcHBTZWNyZXQgPSBmdW5jdGlvbiAoZGV2aWNlSWQsIHBhc3N3b3JkLCBhcHBOYW1lKSB7XG4gICAgdmFyIGRldmljZUlkQnVmZmVyID0gdHlwZW9mIGRldmljZUlkID09PSAnc3RyaW5nJyA/IEJ1ZmZlci5mcm9tKGRldmljZUlkKSA6IGRldmljZUlkO1xuICAgIHZhciBwYXNzd29yZEJ1ZmZlciA9IHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycgPyBCdWZmZXIuZnJvbShwYXNzd29yZCkgOiBwYXNzd29yZDtcbiAgICB2YXIgYXBwTmFtZUJ1ZmZlciA9IHR5cGVvZiBhcHBOYW1lID09PSAnc3RyaW5nJyA/IEJ1ZmZlci5mcm9tKGFwcE5hbWUpIDogYXBwTmFtZTtcbiAgICB2YXIgcHJlSW1hZ2UgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgZGV2aWNlSWRCdWZmZXIsXG4gICAgICAgIHBhc3N3b3JkQnVmZmVyLFxuICAgICAgICBhcHBOYW1lQnVmZmVyLFxuICAgIF0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2hhXzEuc2hhMjU2KSgpLnVwZGF0ZShwcmVJbWFnZSkuZGlnZXN0KCdoZXgnKSwgJ2hleCcpO1xufTtcbmV4cG9ydHMuZ2VuZXJhdGVBcHBTZWNyZXQgPSBnZW5lcmF0ZUFwcFNlY3JldDtcbi8qKlxuICogR2VuZXJpYyBzaWduaW5nIGRvZXMgbm90IHJldHVybiBhIGB2YCB2YWx1ZSBsaWtlIGxlZ2FjeSBFVEggc2lnbmluZyByZXF1ZXN0cyBkaWQuXG4gKiBHZXQgdGhlIGB2YCBjb21wb25lbnQgb2YgdGhlIHNpZ25hdHVyZSBhcyB3ZWxsIGFzIGFuIGBpbml0VmBcbiAqIHBhcmFtZXRlciwgd2hpY2ggaXMgd2hhdCB5b3UgbmVlZCB0byB1c2UgdG8gcmUtY3JlYXRlIGFuIGBAZXRoZXJldW1qcy90eGBcbiAqIG9iamVjdC4gVGhlcmUgaXMgYSBsb3Qgb2YgdGVjaCBkZWJ0IGluIGBAZXRoZXJldW1qcy90eGAgd2hpY2ggYWxzb1xuICogaW5oZXJpdHMgdGhlIHRlY2ggZGVidCBvZiBldGhlcmV1bWpzLXV0aWwuXG4gKiAxLiAgVGhlIGxlZ2FjeSBgVHJhbnNhY3Rpb25gIHR5cGUgY2FuIGNhbGwgYF9wcm9jZXNzU2lnbmF0dXJlYCB3aXRoIHRoZSByZWd1bGFyXG4gKiAgICAgYHZgIHZhbHVlLlxuICogMi4gIE5ld2VyIHRyYW5zYWN0aW9uIHR5cGVzIHN1Y2ggYXMgYEZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbmAgd2lsbCBzdWJ0cmFjdFxuICogICAgIDI3IGZyb20gdGhlIGB2YCB0aGF0IGdldHMgcGFzc2VkIGluLCBzbyB3ZSBuZWVkIHRvIGFkZCBgMjdgIHRvIGNyZWF0ZSBgaW5pdFZgXG4gKiBAcGFyYW0gdHggLSBBbiBAZXRoZXJldW1qcy90eCBUcmFuc2FjdGlvbiBvYmplY3Qgb3IgQnVmZmVyIChzZXJpYWxpemVkIHR4KVxuICogQHBhcmFtIHJlc3AgLSByZXNwb25zZSBmcm9tIExhdHRpY2UuIENhbiBiZSBlaXRoZXIgbGVnYWN5IG9yIGdlbmVyaWMgc2lnbmluZyB2YXJpZXR5XG4gKiBAcmV0dXJucyBibi5qcyBCTiBvYmplY3QgY29udGFpbmluZyB0aGUgYHZgIHBhcmFtXG4gKi9cbnZhciBnZXRWID0gZnVuY3Rpb24gKHR4LCByZXNwKSB7XG4gICAgdmFyIGNoYWluSWQsIGhhc2gsIHR5cGU7XG4gICAgdmFyIHR4SXNCdWYgPSBCdWZmZXIuaXNCdWZmZXIodHgpO1xuICAgIGlmICh0eElzQnVmKSB7XG4gICAgICAgIGhhc2ggPSBCdWZmZXIuZnJvbSgoMCwganNfc2hhM18xLmtlY2NhazI1NikodHgpLCAnaGV4Jyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbGVnYWN5VHhBcnJheSA9ICgwLCBybHBfMS5kZWNvZGUpKHR4KTtcbiAgICAgICAgICAgIGlmIChsZWdhY3lUeEFycmF5Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgICAgICAgIC8vIFNpeCBpdGVtIGFycmF5IG1lYW5zIHRoaXMgaXMgYSBwcmUtRUlQMTU1IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGB2YCBwYXJhbSBpcyB0aGUgYGNoYWluSWRgXG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IG5ldyBibl9qc18xLkJOKGxlZ2FjeVR4QXJyYXlbNl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGVnYWN5IHR4ID0gdHlwZSAwXG4gICAgICAgICAgICB0eXBlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxpa2VseSBhIHR5cGVkIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB0eE9iaiA9IHR4XzEuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21TZXJpYWxpemVkRGF0YSh0eCk7XG4gICAgICAgICAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yIC0tIEFjY2Vzc2luZyBwcml2YXRlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR4T2JqLl90eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IFJMUCBkZWNvZGUgYW5kIGNhbid0IGh5ZHJhdGUgYW4gQGV0aGVyZXVtanMvdHggb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hhdCB0aGlzIGlzIGFuZCBzaG91bGQgYWJvcnQuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVjb3ZlciBWLiBCYWQgdHJhbnNhY3Rpb24gZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQGV0aGVyZXVtanMvdHggb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICB0eXBlID0gdHguX3R5cGU7XG4gICAgICAgIGhhc2ggPSB0eXBlID9cbiAgICAgICAgICAgIHR4LmdldE1lc3NhZ2VUb1NpZ24odHJ1ZSkgOiAvLyBuZXdlciB0eCB0eXBlc1xuICAgICAgICAgICAgKDAsIHJscF8xLmVuY29kZSkodHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSkpOyAvLyBsZWdhY3kgdHhcbiAgICAgICAgaWYgKHR4LnN1cHBvcnRzKHR4XzEuQ2FwYWJpbGl0eS5FSVAxNTVSZXBsYXlQcm90ZWN0aW9uKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHR4LmNvbW1vbi5jaGFpbklkQk4oKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBycyA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQoW3Jlc3Auc2lnLnIsIHJlc3Auc2lnLnNdKSk7XG4gICAgdmFyIHB1YmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3AucHVia2V5KTtcbiAgICB2YXIgcmVjb3ZlcnkwID0gKDAsIHNlY3AyNTZrMV8xLmVjZHNhUmVjb3ZlcikocnMsIDAsIGhhc2gsIGZhbHNlKTtcbiAgICB2YXIgcmVjb3ZlcnkxID0gKDAsIHNlY3AyNTZrMV8xLmVjZHNhUmVjb3ZlcikocnMsIDEsIGhhc2gsIGZhbHNlKTtcbiAgICB2YXIgcHVia2V5U3RyID0gQnVmZmVyLmZyb20ocHVia2V5KS50b1N0cmluZygnaGV4Jyk7XG4gICAgdmFyIHJlY292ZXJ5MFN0ciA9IEJ1ZmZlci5mcm9tKHJlY292ZXJ5MCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHZhciByZWNvdmVyeTFTdHIgPSBCdWZmZXIuZnJvbShyZWNvdmVyeTEpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB2YXIgcmVjb3Zlcnk7XG4gICAgaWYgKHB1YmtleVN0ciA9PT0gcmVjb3ZlcnkwU3RyKSB7XG4gICAgICAgIHJlY292ZXJ5ID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAocHVia2V5U3RyID09PSByZWNvdmVyeTFTdHIpIHtcbiAgICAgICAgcmVjb3ZlcnkgPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgd2UgZmFpbCBhIHNlY29uZCB0aW1lLCBleGl0IGhlcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlY292ZXIgViBwYXJhbWV0ZXIuIEJhZCBzaWduYXR1cmUgb3IgdHJhbnNhY3Rpb24gZGF0YS4nKTtcbiAgICB9XG4gICAgLy8gTmV3ZXIgdHJhbnNhY3Rpb24gdHlwZXMganVzdCB1c2UgdGhlIFswLCAxXSB2YWx1ZVxuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5CTihyZWNvdmVyeSk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGNoYWluIElELCB0aGlzIGlzIGEgcHJlLUVJUDE1NSB0eFxuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuQk4ocmVjb3ZlcnkpLmFkZG4oMjcpO1xuICAgIH1cbiAgICAvLyBFSVAxNTUgcmVwbGF5IHByb3RlY3Rpb24gaXMgaW5jbHVkZWQgaW4gdGhlIGB2YCBwYXJhbVxuICAgIC8vIGFuZCB1c2VzIHRoZSBjaGFpbklkIHZhbHVlLlxuICAgIHJldHVybiBjaGFpbklkLm11bG4oMikuYWRkbigzNSkuYWRkbihyZWNvdmVyeSk7XG59O1xuZXhwb3J0cy5nZXRWID0gZ2V0Vjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMuRVhURVJOQUwgPSB7XG4gICAgZmV0Y2hDYWxsZGF0YURlY29kZXI6IGZldGNoQ2FsbGRhdGFEZWNvZGVyLFxuICAgIGdlbmVyYXRlQXBwU2VjcmV0OiBleHBvcnRzLmdlbmVyYXRlQXBwU2VjcmV0LFxuICAgIGdldFY6IGV4cG9ydHMuZ2V0Vixcbn07XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9sbGluZ0Jsb2NrVHJhY2tlci5qcy5tYXAifQ==
