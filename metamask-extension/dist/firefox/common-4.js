LavaPack.loadBundle([
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\rlp\\node_modules\\bn.js\\lib\\bn.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Crlp%5Cnode_modules%5Cbn.js%5Clib%5Cbn.js
      return function (require, module, exports) {
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

      };
    };
  }
  }
}, {package:"ethereumjs-util>rlp>bn.js",file:"node_modules\\rlp\\node_modules\\bn.js\\lib\\bn.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js", {"buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csafe-buffer%5Cindex.js
      return function (require, module, exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>safe-buffer",file:"node_modules\\safe-buffer\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-event-emitter\\index.js", {"events/":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\events\\events.js","util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csafe-event-emitter%5Cindex.js
      return function (require, module, exports) {
const util = require('util')
const EventEmitter = require('events/')

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
}

module.exports = SafeEventEmitter


function SafeEventEmitter() {
  EventEmitter.call(this)
}

util.inherits(SafeEventEmitter, EventEmitter)

SafeEventEmitter.prototype.emit = function (type) {
  // copied from https://github.com/Gozala/events/blob/master/events.js
  // modified lines are commented with "edited:"
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    // edited: using safeApply
    safeApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      // edited: using safeApply
      safeApply(listeners[i], this, args);
  }

  return true;
}

function safeApply(handler, context, args) {
  try {
    ReflectApply(handler, context, args)
  } catch (err) {
    // throw error after timeout so as not to interupt the stack
    setTimeout(() => {
      throw err
    })
  }
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

      };
    };
  }
  }
}, {package:"@metamask/eth-token-tracker>safe-event-emitter",file:"node_modules\\safe-event-emitter\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\secp256k1\\elliptic.js", {"./lib":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\secp256k1\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csecp256k1%5Celliptic.js
      return function (require, module, exports) {
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
  }
}, {package:"ethereumjs-util>ethereum-cryptography>secp256k1",file:"node_modules\\secp256k1\\elliptic.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\secp256k1\\lib\\elliptic.js", {"elliptic":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csecp256k1%5Clib%5Celliptic.js
      return function (require, module, exports) {
const EC = require('elliptic').ec

const ec = new EC('secp256k1')
const ecparams = ec.curve

// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
const BN = ecparams.n.constructor

function loadCompressedPublicKey (first, xbuf) {
  let x = new BN(xbuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xbuf, ybuf) {
  let x = new BN(xbuf)
  let y = new BN(ybuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  const x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (pubkey) {
  // length should be validated in interface
  const first = pubkey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (pubkey.length !== 33) return null
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (pubkey.length !== 65) return null
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
    default:
      return null
  }
}

function savePublicKey (output, point) {
  const pubkey = point.encode(null, output.length === 33)
  // Loop should be faster because we do not need create extra Uint8Array
  // output.set(new Uint8Array(pubkey))
  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]
}

module.exports = {
  contextRandomize () {
    return 0
  },

  privateKeyVerify (seckey) {
    const bn = new BN(seckey)
    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
  },

  privateKeyNegate (seckey) {
    const bn = new BN(seckey)
    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)
    seckey.set(negate)
    return 0
  },

  privateKeyTweakAdd (seckey, tweak) {
    const bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0) return 1

    bn.iadd(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
    if (bn.isZero()) return 1

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  privateKeyTweakMul (seckey, tweak) {
    let bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    bn.imul(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  publicKeyVerify (pubkey) {
    const pair = loadPublicKey(pubkey)
    return pair === null ? 1 : 0
  },

  publicKeyCreate (output, seckey) {
    const bn = new BN(seckey)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    const point = ec.keyFromPrivate(seckey).getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyConvert (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyNegate (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    point.y = point.y.redNeg()
    savePublicKey(output, point)

    return 0
  },

  publicKeyCombine (output, pubkeys) {
    const pairs = new Array(pubkeys.length)
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i])
      if (pairs[i] === null) return 1
    }

    let point = pairs[0].getPublic()
    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakAdd (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0) return 2

    const point = pair.getPublic().add(ecparams.g.mul(tweak))
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakMul (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

    const point = pair.getPublic().mul(tweak)
    savePublicKey(output, point)

    return 0
  },

  signatureNormalize (sig) {
    const r = new BN(sig.subarray(0, 32))
    const s = new BN(sig.subarray(32, 64))
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)
    }

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport (obj, sig) {
    const sigR = sig.subarray(0, 32)
    const sigS = sig.subarray(32, 64)
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

    const { output } = obj

    // Prepare R
    let r = output.subarray(4, 4 + 33)
    r[0] = 0x00
    r.set(sigR, 1)

    let lenR = 33
    let posR = 0
    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

    r = r.subarray(posR)
    if (r[0] & 0x80) return 1
    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

    // Prepare S
    let s = output.subarray(6 + 33, 6 + 33 + 33)
    s[0] = 0x00
    s.set(sigS, 1)

    let lenS = 33
    let posS = 0
    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

    s = s.subarray(posS)
    if (s[0] & 0x80) return 1
    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

    // Set output length for return
    obj.outputlen = 6 + lenR + lenS

    // Output in specified format
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    output[0] = 0x30
    output[1] = obj.outputlen - 2
    output[2] = 0x02
    output[3] = r.length
    output.set(r, 4)
    output[4 + lenR] = 0x02
    output[5 + lenR] = s.length
    output.set(s, 6 + lenR)

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport (output, sig) {
    if (sig.length < 8) return 1
    if (sig.length > 72) return 1
    if (sig[0] !== 0x30) return 1
    if (sig[1] !== sig.length - 2) return 1
    if (sig[2] !== 0x02) return 1

    const lenR = sig[3]
    if (lenR === 0) return 1
    if (5 + lenR >= sig.length) return 1
    if (sig[4 + lenR] !== 0x02) return 1

    const lenS = sig[5 + lenR]
    if (lenS === 0) return 1
    if ((6 + lenR + lenS) !== sig.length) return 1

    if (sig[4] & 0x80) return 1
    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

    if (sig[lenR + 6] & 0x80) return 1
    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

    let sigR = sig.subarray(4, 4 + lenR)
    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)
    if (sigR.length > 32) return 1

    let sigS = sig.subarray(6 + lenR)
    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)
    if (sigS.length > 32) throw new Error('S length is too long')

    let r = new BN(sigR)
    if (r.cmp(ecparams.n) >= 0) r = new BN(0)

    let s = new BN(sig.subarray(6 + lenR))
    if (s.cmp(ecparams.n) >= 0) s = new BN(0)

    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)
    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)

    return 0
  },

  ecdsaSign (obj, message, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data, counter)

        const isValid = nonce instanceof Uint8Array && nonce.length === 32
        if (!isValid) throw new Error('This is the way')

        return new BN(nonce)
      }
    }

    const d = new BN(seckey)
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

    let sig
    try {
      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })
    } catch (err) {
      return 1
    }

    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)
    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)
    obj.recid = sig.recoveryParam

    return 0
  },

  ecdsaVerify (sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

    const pair = loadPublicKey(pubkey)
    if (pair === null) return 2

    const point = pair.getPublic()
    const isValid = ec.verify(msg32, sigObj, point)
    return isValid ? 0 : 3
  },

  ecdsaRecover (output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

    if (sigr.isZero() || sigs.isZero()) return 2

    // Can throw `throw new Error('Unable to find sencond key candinate');`
    let point
    try {
      point = ec.recoverPubKey(msg32, sigObj, recid)
    } catch (err) {
      return 2
    }

    savePublicKey(output, point)

    return 0
  },

  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const scalar = new BN(seckey)
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

    const point = pair.getPublic().mul(scalar)

    if (hashfn === undefined) {
      const data = point.encode(null, true)
      const sha256 = ec.hash().update(data).digest()
      for (let i = 0; i < 32; ++i) output[i] = sha256[i]
    } else {
      if (!xbuf) xbuf = new Uint8Array(32)
      const x = point.getX().toArray('be', 32)
      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]

      if (!ybuf) ybuf = new Uint8Array(32)
      const y = point.getY().toArray('be', 32)
      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]

      const hash = hashfn(xbuf, ybuf, data)

      const isValid = hash instanceof Uint8Array && hash.length === output.length
      if (!isValid) return 2

      output.set(hash)
    }

    return 0
  }
}

      };
    };
  }
  }
}, {package:"ethereumjs-util>ethereum-cryptography>secp256k1",file:"node_modules\\secp256k1\\lib\\elliptic.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\secp256k1\\lib\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csecp256k1%5Clib%5Cindex.js
      return function (require, module, exports) {
const errors = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD:
    'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)'
}

function assert (cond, msg) {
  if (!cond) throw new Error(msg)
}

function isUint8Array (name, value, length) {
  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)

  if (length !== undefined) {
    if (Array.isArray(length)) {
      const numbers = length.join(', ')
      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`
      assert(length.includes(value.length), msg)
    } else {
      const msg = `Expected ${name} to be an Uint8Array with length ${length}`
      assert(value.length === length, msg)
    }
  }
}

function isCompressed (value) {
  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')
}

function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
  if (typeof output === 'function') output = output(length)
  isUint8Array('output', output, length)
  return output
}

function toTypeString (value) {
  return Object.prototype.toString.call(value).slice(8, -1)
}

module.exports = (secp256k1) => {
  return {
    contextRandomize (seed) {
      assert(
        seed === null || seed instanceof Uint8Array,
        'Expected seed to be an Uint8Array or null'
      )
      if (seed !== null) isUint8Array('seed', seed, 32)

      switch (secp256k1.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
      }
    },

    privateKeyVerify (seckey) {
      isUint8Array('private key', seckey, 32)

      return secp256k1.privateKeyVerify(seckey) === 0
    },

    privateKeyNegate (seckey) {
      isUint8Array('private key', seckey, 32)

      switch (secp256k1.privateKeyNegate(seckey)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    privateKeyTweakAdd (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    privateKeyTweakMul (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    publicKeyVerify (pubkey) {
      isUint8Array('public key', pubkey, [33, 65])

      return secp256k1.publicKeyVerify(pubkey) === 0
    },

    publicKeyCreate (seckey, compressed = true, output) {
      isUint8Array('private key', seckey, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCreate(output, seckey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SECKEY_INVALID)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyConvert (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyConvert(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyNegate (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyNegate(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyCombine (pubkeys, compressed = true, output) {
      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')
      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')
      for (const pubkey of pubkeys) {
        isUint8Array('public key', pubkey, [33, 65])
      }
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_COMBINE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    signatureNormalize (sig) {
      isUint8Array('signature', sig, 64)

      switch (secp256k1.signatureNormalize(sig)) {
        case 0:
          return sig
        case 1:
          throw new Error(errors.SIG_PARSE)
      }
    },

    signatureExport (sig, output) {
      isUint8Array('signature', sig, 64)
      output = getAssertedOutput(output, 72)

      const obj = { output, outputlen: 72 }
      switch (secp256k1.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen)
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    signatureImport (sig, output) {
      isUint8Array('signature', sig)
      output = getAssertedOutput(output, 64)

      switch (secp256k1.signatureImport(output, sig)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaSign (msg32, seckey, options = {}, output) {
      isUint8Array('message', msg32, 32)
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')
      output = getAssertedOutput(output, 64)

      const obj = { signature: output, recid: null }
      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj
        case 1:
          throw new Error(errors.SIGN)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaVerify (sig, msg32, pubkey) {
      isUint8Array('signature', sig, 64)
      isUint8Array('message', msg32, 32)
      isUint8Array('public key', pubkey, [33, 65])

      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true
        case 3:
          return false
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_PARSE)
      }
    },

    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
      isUint8Array('signature', sig, 64)
      assert(
        toTypeString(recid) === 'Number' &&
          recid >= 0 &&
          recid <= 3,
        'Expected recovery id to be a Number within interval [0, 3]'
      )
      isUint8Array('message', msg32, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.RECOVER)
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdh (pubkey, seckey, options = {}, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.hashfn !== undefined) {
        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')
        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)
        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)
        isUint8Array('output', output)
      } else {
        output = getAssertedOutput(output, 32)
      }

      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.ECDH)
      }
    }
  }
}

      };
    };
  }
  }
}, {package:"ethereumjs-util>ethereum-cryptography>secp256k1",file:"node_modules\\secp256k1\\lib\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\comparator.js", {"../functions/cmp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\cmp.js","../internal/debug":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\debug.js","../internal/parse-options":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\re.js","./range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js","./semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cclasses%5Ccomparator.js
      return function (require, module, exports) {
const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = require('../internal/parse-options')
const { re, t } = require('../internal/re')
const cmp = require('../functions/cmp')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const Range = require('./range')

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\comparator.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js", {"../internal/constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\constants.js","../internal/debug":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\debug.js","../internal/parse-options":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\re.js","./comparator":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","./semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js","lru-cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\node_modules\\lru-cache\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cclasses%5Crange.js
      return function (require, module, exports) {
// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = require('lru-cache')
const cache = new LRU({ max: 1000 })

const parseOptions = require('../internal/parse-options')
const Comparator = require('./comparator')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = require('../internal/re')
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> -- > * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x -- > >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x -- > >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x -- > >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 -- > >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 -- > >=1.2.0 <1.3.0-0
// ~0.0.1 -- > >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceTilde(c, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ -- > * (any, kinda silly)
// ^2, ^2.x, ^2.x.x -- > >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x -- > >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x -- > >=1.2.0 <2.0.0-0
// ^1.2.3 -- > >=1.2.3 <2.0.0-0
// ^1.2.0 -- > >=1.2.0 <2.0.0-0
// ^0.0.1 -- > >=0.0.1 <0.0.2-0
// ^0.1.0 -- > >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceCaret(c, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((c) => {
    return replaceXRange(c, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\range.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js", {"../internal/constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\constants.js","../internal/debug":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\debug.js","../internal/identifiers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\identifiers.js","../internal/parse-options":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\re.js","util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cclasses%5Csemver.js
      return function (require, module, exports) {
const debug = require('../internal/debug')
const { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')
const { re, t } = require('../internal/re')

const parseOptions = require('../internal/parse-options')
const { compareIdentifiers } = require('../internal/identifiers')
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${require('util').inspect(version)}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\semver.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\clean.js", {"./parse":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cclean.js
      return function (require, module, exports) {
const parse = require('./parse')
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\clean.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\cmp.js", {"./eq":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\eq.js","./gt":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gt.js","./gte":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gte.js","./lt":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lt.js","./lte":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lte.js","./neq":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\neq.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccmp.js
      return function (require, module, exports) {
const eq = require('./eq')
const neq = require('./neq')
const gt = require('./gt')
const gte = require('./gte')
const lt = require('./lt')
const lte = require('./lte')

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\cmp.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\coerce.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js","../internal/re":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\re.js","./parse":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccoerce.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const parse = require('./parse')
const { re, t } = require('../internal/re')

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\coerce.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare-build.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare-build.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare-loose.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare-loose.js
      return function (require, module, exports) {
const compare = require('./compare')
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare-loose.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\diff.js", {"./parse.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cdiff.js
      return function (require, module, exports) {
const parse = require('./parse.js')

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // at this point we know stable versions match but overall versions are not equal,
  // so either they are both prereleases, or the lower version is a prerelease

  if (highHasPre) {
    // high and low are preleases
    return 'prerelease'
  }

  if (lowVersion.patch) {
    // anything higher than a patch bump would result in the wrong version
    return 'patch'
  }

  if (lowVersion.minor) {
    // anything higher than a minor bump would result in the wrong version
    return 'minor'
  }

  // bumping major/minor/patch all have same result
  return 'major'
}

module.exports = diff

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\diff.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\eq.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ceq.js
      return function (require, module, exports) {
const compare = require('./compare')
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\eq.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gt.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cgt.js
      return function (require, module, exports) {
const compare = require('./compare')
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\gt.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gte.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cgte.js
      return function (require, module, exports) {
const compare = require('./compare')
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\gte.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\inc.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cinc.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\inc.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lt.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Clt.js
      return function (require, module, exports) {
const compare = require('./compare')
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\lt.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lte.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Clte.js
      return function (require, module, exports) {
const compare = require('./compare')
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\lte.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\major.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cmajor.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\major.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\minor.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cminor.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\minor.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\neq.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cneq.js
      return function (require, module, exports) {
const compare = require('./compare')
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\neq.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\parse.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cparse.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\parse.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\patch.js", {"../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cpatch.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\patch.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\prerelease.js", {"./parse":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cprerelease.js
      return function (require, module, exports) {
const parse = require('./parse')
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\prerelease.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\rcompare.js", {"./compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Crcompare.js
      return function (require, module, exports) {
const compare = require('./compare')
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\rcompare.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\rsort.js", {"./compare-build":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Crsort.js
      return function (require, module, exports) {
const compareBuild = require('./compare-build')
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\rsort.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js", {"../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Csatisfies.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\satisfies.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\sort.js", {"./compare-build":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Csort.js
      return function (require, module, exports) {
const compareBuild = require('./compare-build')
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\sort.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\valid.js", {"./parse":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cvalid.js
      return function (require, module, exports) {
const parse = require('./parse')
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\valid.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\index.js", {"./classes/comparator":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","./classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js","./classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js","./functions/clean":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\clean.js","./functions/cmp":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\cmp.js","./functions/coerce":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\coerce.js","./functions/compare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js","./functions/compare-build":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js","./functions/compare-loose":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare-loose.js","./functions/diff":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\diff.js","./functions/eq":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\eq.js","./functions/gt":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gt.js","./functions/gte":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gte.js","./functions/inc":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\inc.js","./functions/lt":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lt.js","./functions/lte":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lte.js","./functions/major":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\major.js","./functions/minor":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\minor.js","./functions/neq":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\neq.js","./functions/parse":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\parse.js","./functions/patch":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\patch.js","./functions/prerelease":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\prerelease.js","./functions/rcompare":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\rcompare.js","./functions/rsort":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\rsort.js","./functions/satisfies":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js","./functions/sort":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\sort.js","./functions/valid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\valid.js","./internal/constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\constants.js","./internal/identifiers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\identifiers.js","./internal/re":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\re.js","./ranges/gtr":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\gtr.js","./ranges/intersects":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\intersects.js","./ranges/ltr":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\ltr.js","./ranges/max-satisfying":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\max-satisfying.js","./ranges/min-satisfying":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\min-satisfying.js","./ranges/min-version":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\min-version.js","./ranges/outside":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\outside.js","./ranges/simplify":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\simplify.js","./ranges/subset":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\subset.js","./ranges/to-comparators":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\to-comparators.js","./ranges/valid":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\valid.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cindex.js
      return function (require, module, exports) {
// just pre-load all the stuff that index.js lazily exports
const internalRe = require('./internal/re')
const constants = require('./internal/constants')
const SemVer = require('./classes/semver')
const identifiers = require('./internal/identifiers')
const parse = require('./functions/parse')
const valid = require('./functions/valid')
const clean = require('./functions/clean')
const inc = require('./functions/inc')
const diff = require('./functions/diff')
const major = require('./functions/major')
const minor = require('./functions/minor')
const patch = require('./functions/patch')
const prerelease = require('./functions/prerelease')
const compare = require('./functions/compare')
const rcompare = require('./functions/rcompare')
const compareLoose = require('./functions/compare-loose')
const compareBuild = require('./functions/compare-build')
const sort = require('./functions/sort')
const rsort = require('./functions/rsort')
const gt = require('./functions/gt')
const lt = require('./functions/lt')
const eq = require('./functions/eq')
const neq = require('./functions/neq')
const gte = require('./functions/gte')
const lte = require('./functions/lte')
const cmp = require('./functions/cmp')
const coerce = require('./functions/coerce')
const Comparator = require('./classes/comparator')
const Range = require('./classes/range')
const satisfies = require('./functions/satisfies')
const toComparators = require('./ranges/to-comparators')
const maxSatisfying = require('./ranges/max-satisfying')
const minSatisfying = require('./ranges/min-satisfying')
const minVersion = require('./ranges/min-version')
const validRange = require('./ranges/valid')
const outside = require('./ranges/outside')
const gtr = require('./ranges/gtr')
const ltr = require('./ranges/ltr')
const intersects = require('./ranges/intersects')
const simplifyRange = require('./ranges/simplify')
const subset = require('./ranges/subset')
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cconstants.js
      return function (require, module, exports) {
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\constants.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\debug.js", {"_process":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\process\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cdebug.js
      return function (require, module, exports) {
(function (process){(function (){
const debug = (
  typeof process === 'object' &&
  process.env &&
  "" &&
  /\bsemver\b/i.test("")
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\debug.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\identifiers.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cidentifiers.js
      return function (require, module, exports) {
const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\identifiers.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\parse-options.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cparse-options.js
      return function (require, module, exports) {
// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\parse-options.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\re.js", {"./constants":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\constants.js","./debug":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\internal\\debug.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cre.js
      return function (require, module, exports) {
const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')
const debug = require('./debug')
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\re.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\node_modules\\lru-cache\\index.js", {"yallist":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\yallist\\yallist.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cnode_modules%5Clru-cache%5Cindex.js
      return function (require, module, exports) {
'use strict'

// A linked list to keep track of recently-used-ness
const Yallist = require('yallist')

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache

      };
    };
  }
  }
}, {package:"semver>lru-cache",file:"node_modules\\semver\\node_modules\\lru-cache\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\gtr.js", {"./outside":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\outside.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cgtr.js
      return function (require, module, exports) {
// Determine if version is greater than all the versions possible in the range.
const outside = require('./outside')
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\gtr.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\intersects.js", {"../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cintersects.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\intersects.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\ltr.js", {"./outside":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\outside.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cltr.js
      return function (require, module, exports) {
const outside = require('./outside')
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\ltr.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\max-satisfying.js", {"../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cmax-satisfying.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\max-satisfying.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\min-satisfying.js", {"../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cmin-satisfying.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\min-satisfying.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\min-version.js", {"../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js","../functions/gt":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gt.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cmin-version.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const gt = require('../functions/gt')

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\min-version.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\outside.js", {"../classes/comparator":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\semver.js","../functions/gt":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gt.js","../functions/gte":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\gte.js","../functions/lt":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lt.js","../functions/lte":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\lte.js","../functions/satisfies":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Coutside.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Comparator = require('../classes/comparator')
const { ANY } = Comparator
const Range = require('../classes/range')
const satisfies = require('../functions/satisfies')
const gt = require('../functions/gt')
const lt = require('../functions/lt')
const lte = require('../functions/lte')
const gte = require('../functions/gte')

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\outside.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\simplify.js", {"../functions/compare.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js","../functions/satisfies.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Csimplify.js
      return function (require, module, exports) {
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\simplify.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\subset.js", {"../classes/comparator.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","../classes/range.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js","../functions/compare.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\compare.js","../functions/satisfies.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Csubset.js
      return function (require, module, exports) {
const Range = require('../classes/range.js')
const Comparator = require('../classes/comparator.js')
const { ANY } = Comparator
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\subset.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\to-comparators.js", {"../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cto-comparators.js
      return function (require, module, exports) {
const Range = require('../classes/range')

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\to-comparators.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\ranges\\valid.js", {"../classes/range":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cvalid.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\valid.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\set-immediate-shim\\index.js", {"timers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cset-immediate-shim%5Cindex.js
      return function (require, module, exports) {
(function (setImmediate){(function (){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

}).call(this)}).call(this,require("timers").setImmediate)

      };
    };
  }
  }
}, {package:"promise-to-callback>set-immediate-shim",file:"node_modules\\set-immediate-shim\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\hash.js", {"safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Chash.js
      return function (require, module, exports) {
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\hash.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\index.js", {"./sha":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha.js","./sha1":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha1.js","./sha224":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha224.js","./sha256":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha256.js","./sha384":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha384.js","./sha512":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha512.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Cindex.js
      return function (require, module, exports) {
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha.js", {"./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha.js
      return function (require, module, exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha1.js", {"./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha1.js
      return function (require, module, exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha1.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha224.js", {"./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\hash.js","./sha256":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha256.js","inherits":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha224.js
      return function (require, module, exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha224.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha256.js", {"./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha256.js
      return function (require, module, exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha256.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha384.js", {"./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\hash.js","./sha512":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha512.js","inherits":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha384.js
      return function (require, module, exports) {
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha384.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\sha512.js", {"./hash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha512.js
      return function (require, module, exports) {
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha512.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\single-call-balance-checker-abi\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csingle-call-balance-checker-abi%5Cindex.js
      return function (require, module, exports) {

module.exports = [
    {
     "payable": true,
     "stateMutability": "payable",
     "type": "fallback"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "user",
       "type": "address"
      },
      {
       "name": "token",
       "type": "address"
      }
     ],
     "name": "tokenBalance",
     "outputs": [
      {
       "name": "",
       "type": "uint256"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "users",
       "type": "address[]"
      },
      {
       "name": "tokens",
       "type": "address[]"
      }
     ],
     "name": "balances",
     "outputs": [
      {
       "name": "",
       "type": "uint256[]"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    }
   ]

      };
    };
  }
  }
}, {package:"single-call-balance-checker-abi",file:"node_modules\\single-call-balance-checker-abi\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\string_decoder\\lib\\string_decoder.js", {"safe-buffer":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cstring_decoder%5Clib%5Cstring_decoder.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
      };
    };
  }
  }
}, {package:"browserify>string_decoder",file:"node_modules\\string_decoder\\lib\\string_decoder.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js", {"is-hex-prefixed":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cstrip-hex-prefix%5Csrc%5Cindex.js
      return function (require, module, exports) {
var isHexPrefixed = require('is-hex-prefixed');

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}

      };
    };
  }
  }
}, {package:"ethjs>ethjs-util>strip-hex-prefix",file:"node_modules\\strip-hex-prefix\\src\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Csuperstruct%5Cdist%5Cindex.cjs
      return function (require, module, exports) {
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Superstruct = {}));
})(this, (function (exports) { 'use strict';

    /**
     * A `StructFailure` represents a single specific failure in validation.
     */
    /**
     * `StructError` objects are thrown (or returned) when validation fails.
     *
     * Validation logic is design to exit early for maximum performance. The error
     * represents the first error encountered during validation. For more detail,
     * the `error.failures` property is a generator function that can be run to
     * continue validation and receive all the failures in the data.
     */
    class StructError extends TypeError {
        constructor(failure, failures) {
            let cached;
            const { message, explanation, ...rest } = failure;
            const { path } = failure;
            const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
            super(explanation ?? msg);
            if (explanation != null)
                this.cause = msg;
            Object.assign(this, rest);
            this.name = this.constructor.name;
            this.failures = () => {
                return (cached ?? (cached = [failure, ...failures()]));
            };
        }
    }

    /**
     * Check if a value is an iterator.
     */
    function isIterable(x) {
        return isObject(x) && typeof x[Symbol.iterator] === 'function';
    }
    /**
     * Check if a value is a plain object.
     */
    function isObject(x) {
        return typeof x === 'object' && x != null;
    }
    /**
     * Check if a value is a plain object.
     */
    function isPlainObject(x) {
        if (Object.prototype.toString.call(x) !== '[object Object]') {
            return false;
        }
        const prototype = Object.getPrototypeOf(x);
        return prototype === null || prototype === Object.prototype;
    }
    /**
     * Return a value as a printable string.
     */
    function print(value) {
        if (typeof value === 'symbol') {
            return value.toString();
        }
        return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
    }
    /**
     * Shifts (removes and returns) the first value from the `input` iterator.
     * Like `Array.prototype.shift()` but for an `Iterator`.
     */
    function shiftIterator(input) {
        const { done, value } = input.next();
        return done ? undefined : value;
    }
    /**
     * Convert a single validation result to a failure.
     */
    function toFailure(result, context, struct, value) {
        if (result === true) {
            return;
        }
        else if (result === false) {
            result = {};
        }
        else if (typeof result === 'string') {
            result = { message: result };
        }
        const { path, branch } = context;
        const { type } = struct;
        const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``, } = result;
        return {
            value,
            type,
            refinement,
            key: path[path.length - 1],
            path,
            branch,
            ...result,
            message,
        };
    }
    /**
     * Convert a validation result to an iterable of failures.
     */
    function* toFailures(result, context, struct, value) {
        if (!isIterable(result)) {
            result = [result];
        }
        for (const r of result) {
            const failure = toFailure(r, context, struct, value);
            if (failure) {
                yield failure;
            }
        }
    }
    /**
     * Check a value against a struct, traversing deeply into nested values, and
     * returning an iterator of failures or success.
     */
    function* run(value, struct, options = {}) {
        const { path = [], branch = [value], coerce = false, mask = false } = options;
        const ctx = { path, branch };
        if (coerce) {
            value = struct.coercer(value, ctx);
            if (mask &&
                struct.type !== 'type' &&
                isObject(struct.schema) &&
                isObject(value) &&
                !Array.isArray(value)) {
                for (const key in value) {
                    if (struct.schema[key] === undefined) {
                        delete value[key];
                    }
                }
            }
        }
        let status = 'valid';
        for (const failure of struct.validator(value, ctx)) {
            failure.explanation = options.message;
            status = 'not_valid';
            yield [failure, undefined];
        }
        for (let [k, v, s] of struct.entries(value, ctx)) {
            const ts = run(v, s, {
                path: k === undefined ? path : [...path, k],
                branch: k === undefined ? branch : [...branch, v],
                coerce,
                mask,
                message: options.message,
            });
            for (const t of ts) {
                if (t[0]) {
                    status = t[0].refinement != null ? 'not_refined' : 'not_valid';
                    yield [t[0], undefined];
                }
                else if (coerce) {
                    v = t[1];
                    if (k === undefined) {
                        value = v;
                    }
                    else if (value instanceof Map) {
                        value.set(k, v);
                    }
                    else if (value instanceof Set) {
                        value.add(v);
                    }
                    else if (isObject(value)) {
                        if (v !== undefined || k in value)
                            value[k] = v;
                    }
                }
            }
        }
        if (status !== 'not_valid') {
            for (const failure of struct.refiner(value, ctx)) {
                failure.explanation = options.message;
                status = 'not_refined';
                yield [failure, undefined];
            }
        }
        if (status === 'valid') {
            yield [undefined, value];
        }
    }

    /**
     * `Struct` objects encapsulate the validation logic for a specific type of
     * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
     * validate unknown input data against the struct.
     */
    class Struct {
        constructor(props) {
            const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;
            this.type = type;
            this.schema = schema;
            this.entries = entries;
            this.coercer = coercer;
            if (validator) {
                this.validator = (value, context) => {
                    const result = validator(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.validator = () => [];
            }
            if (refiner) {
                this.refiner = (value, context) => {
                    const result = refiner(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.refiner = () => [];
            }
        }
        /**
         * Assert that a value passes the struct's validation, throwing if it doesn't.
         */
        assert(value, message) {
            return assert(value, this, message);
        }
        /**
         * Create a value with the struct's coercion logic, then validate it.
         */
        create(value, message) {
            return create(value, this, message);
        }
        /**
         * Check if a value passes the struct's validation.
         */
        is(value) {
            return is(value, this);
        }
        /**
         * Mask a value, coercing and validating it, but returning only the subset of
         * properties defined by the struct's schema.
         */
        mask(value, message) {
            return mask(value, this, message);
        }
        /**
         * Validate a value with the struct's validation logic, returning a tuple
         * representing the result.
         *
         * You may optionally pass `true` for the `withCoercion` argument to coerce
         * the value before attempting to validate it. If you do, the result will
         * contain the coerced result when successful.
         */
        validate(value, options = {}) {
            return validate(value, this, options);
        }
    }
    /**
     * Assert that a value passes a struct, throwing if it doesn't.
     */
    function assert(value, struct, message) {
        const result = validate(value, struct, { message });
        if (result[0]) {
            throw result[0];
        }
    }
    /**
     * Create a value with the coercion logic of struct and validate it.
     */
    function create(value, struct, message) {
        const result = validate(value, struct, { coerce: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Mask a value, returning only the subset of properties defined by a struct.
     */
    function mask(value, struct, message) {
        const result = validate(value, struct, { coerce: true, mask: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Check if a value passes a struct.
     */
    function is(value, struct) {
        const result = validate(value, struct);
        return !result[0];
    }
    /**
     * Validate a value against a struct, returning an error if invalid, or the
     * value (with potential coercion) if valid.
     */
    function validate(value, struct, options = {}) {
        const tuples = run(value, struct, options);
        const tuple = shiftIterator(tuples);
        if (tuple[0]) {
            const error = new StructError(tuple[0], function* () {
                for (const t of tuples) {
                    if (t[0]) {
                        yield t[0];
                    }
                }
            });
            return [error, undefined];
        }
        else {
            const v = tuple[1];
            return [undefined, v];
        }
    }

    function assign(...Structs) {
        const isType = Structs[0].type === 'type';
        const schemas = Structs.map((s) => s.schema);
        const schema = Object.assign({}, ...schemas);
        return isType ? type(schema) : object(schema);
    }
    /**
     * Define a new struct type with a custom validation function.
     */
    function define(name, validator) {
        return new Struct({ type: name, schema: null, validator });
    }
    /**
     * Create a new struct based on an existing struct, but the value is allowed to
     * be `undefined`. `log` will be called if the value is not `undefined`.
     */
    function deprecated(struct, log) {
        return new Struct({
            ...struct,
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
            validator(value, ctx) {
                if (value === undefined) {
                    return true;
                }
                else {
                    log(value, ctx);
                    return struct.validator(value, ctx);
                }
            },
        });
    }
    /**
     * Create a struct with dynamic validation logic.
     *
     * The callback will receive the value currently being validated, and must
     * return a struct object to validate it with. This can be useful to model
     * validation logic that changes based on its input.
     */
    function dynamic(fn) {
        return new Struct({
            type: 'dynamic',
            schema: null,
            *entries(value, ctx) {
                const struct = fn(value, ctx);
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                const struct = fn(value, ctx);
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                const struct = fn(value, ctx);
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                const struct = fn(value, ctx);
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a struct with lazily evaluated validation logic.
     *
     * The first time validation is run with the struct, the callback will be called
     * and must return a struct object to use. This is useful for cases where you
     * want to have self-referential structs for nested data structures to avoid a
     * circular definition problem.
     */
    function lazy(fn) {
        let struct;
        return new Struct({
            type: 'lazy',
            schema: null,
            *entries(value, ctx) {
                struct ?? (struct = fn());
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                struct ?? (struct = fn());
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                struct ?? (struct = fn());
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                struct ?? (struct = fn());
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a new struct based on an existing object struct, but excluding
     * specific properties.
     *
     * Like TypeScript's `Omit` utility.
     */
    function omit(struct, keys) {
        const { schema } = struct;
        const subschema = { ...schema };
        for (const key of keys) {
            delete subschema[key];
        }
        switch (struct.type) {
            case 'type':
                return type(subschema);
            default:
                return object(subschema);
        }
    }
    /**
     * Create a new struct based on an existing object struct, but with all of its
     * properties allowed to be `undefined`.
     *
     * Like TypeScript's `Partial` utility.
     */
    function partial(struct) {
        const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };
        for (const key in schema) {
            schema[key] = optional(schema[key]);
        }
        return object(schema);
    }
    /**
     * Create a new struct based on an existing object struct, but only including
     * specific properties.
     *
     * Like TypeScript's `Pick` utility.
     */
    function pick(struct, keys) {
        const { schema } = struct;
        const subschema = {};
        for (const key of keys) {
            subschema[key] = schema[key];
        }
        return object(subschema);
    }
    /**
     * Define a new struct type with a custom validation function.
     *
     * @deprecated This function has been renamed to `define`.
     */
    function struct(name, validator) {
        console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
        return define(name, validator);
    }

    /**
     * Ensure that any value passes validation.
     */
    function any() {
        return define('any', () => true);
    }
    function array(Element) {
        return new Struct({
            type: 'array',
            schema: Element,
            *entries(value) {
                if (Element && Array.isArray(value)) {
                    for (const [i, v] of value.entries()) {
                        yield [i, v, Element];
                    }
                }
            },
            coercer(value) {
                return Array.isArray(value) ? value.slice() : value;
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array value, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a bigint.
     */
    function bigint() {
        return define('bigint', (value) => {
            return typeof value === 'bigint';
        });
    }
    /**
     * Ensure that a value is a boolean.
     */
    function boolean() {
        return define('boolean', (value) => {
            return typeof value === 'boolean';
        });
    }
    /**
     * Ensure that a value is a valid `Date`.
     *
     * Note: this also ensures that the value is *not* an invalid `Date` object,
     * which can occur when parsing a date fails but still returns a `Date`.
     */
    function date() {
        return define('date', (value) => {
            return ((value instanceof Date && !isNaN(value.getTime())) ||
                `Expected a valid \`Date\` object, but received: ${print(value)}`);
        });
    }
    function enums(values) {
        const schema = {};
        const description = values.map((v) => print(v)).join();
        for (const key of values) {
            schema[key] = key;
        }
        return new Struct({
            type: 'enums',
            schema,
            validator(value) {
                return (values.includes(value) ||
                    `Expected one of \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a function.
     */
    function func() {
        return define('func', (value) => {
            return (typeof value === 'function' ||
                `Expected a function, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an instance of a specific class.
     */
    function instance(Class) {
        return define('instance', (value) => {
            return (value instanceof Class ||
                `Expected a \`${Class.name}\` instance, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an integer.
     */
    function integer() {
        return define('integer', (value) => {
            return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||
                `Expected an integer, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value matches all of a set of types.
     */
    function intersection(Structs) {
        return new Struct({
            type: 'intersection',
            schema: null,
            *entries(value, ctx) {
                for (const S of Structs) {
                    yield* S.entries(value, ctx);
                }
            },
            *validator(value, ctx) {
                for (const S of Structs) {
                    yield* S.validator(value, ctx);
                }
            },
            *refiner(value, ctx) {
                for (const S of Structs) {
                    yield* S.refiner(value, ctx);
                }
            },
        });
    }
    function literal(constant) {
        const description = print(constant);
        const t = typeof constant;
        return new Struct({
            type: 'literal',
            schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
            validator(value) {
                return (value === constant ||
                    `Expected the literal \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    function map(Key, Value) {
        return new Struct({
            type: 'map',
            schema: null,
            *entries(value) {
                if (Key && Value && value instanceof Map) {
                    for (const [k, v] of value.entries()) {
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            coercer(value) {
                return value instanceof Map ? new Map(value) : value;
            },
            validator(value) {
                return (value instanceof Map ||
                    `Expected a \`Map\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that no value ever passes validation.
     */
    function never() {
        return define('never', () => false);
    }
    /**
     * Augment an existing struct to allow `null` values.
     */
    function nullable(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === null || struct.validator(value, ctx),
            refiner: (value, ctx) => value === null || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is a number.
     */
    function number() {
        return define('number', (value) => {
            return ((typeof value === 'number' && !isNaN(value)) ||
                `Expected a number, but received: ${print(value)}`);
        });
    }
    function object(schema) {
        const knowns = schema ? Object.keys(schema) : [];
        const Never = never();
        return new Struct({
            type: 'object',
            schema: schema ? schema : null,
            *entries(value) {
                if (schema && isObject(value)) {
                    const unknowns = new Set(Object.keys(value));
                    for (const key of knowns) {
                        unknowns.delete(key);
                        yield [key, value[key], schema[key]];
                    }
                    for (const key of unknowns) {
                        yield [key, value[key], Never];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Augment a struct to allow `undefined` values.
     */
    function optional(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is an object with keys and values of specific types, but
     * without ensuring any specific shape of properties.
     *
     * Like TypeScript's `Record` utility.
     */
    function record(Key, Value) {
        return new Struct({
            type: 'record',
            schema: null,
            *entries(value) {
                if (isObject(value)) {
                    for (const k in value) {
                        const v = value[k];
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a `RegExp`.
     *
     * Note: this does not test the value against the regular expression! For that
     * you need to use the `pattern()` refinement.
     */
    function regexp() {
        return define('regexp', (value) => {
            return value instanceof RegExp;
        });
    }
    function set(Element) {
        return new Struct({
            type: 'set',
            schema: null,
            *entries(value) {
                if (Element && value instanceof Set) {
                    for (const v of value) {
                        yield [v, v, Element];
                    }
                }
            },
            coercer(value) {
                return value instanceof Set ? new Set(value) : value;
            },
            validator(value) {
                return (value instanceof Set ||
                    `Expected a \`Set\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a string.
     */
    function string() {
        return define('string', (value) => {
            return (typeof value === 'string' ||
                `Expected a string, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is a tuple of a specific length, and that each of its
     * elements is of a specific type.
     */
    function tuple(Structs) {
        const Never = never();
        return new Struct({
            type: 'tuple',
            schema: null,
            *entries(value) {
                if (Array.isArray(value)) {
                    const length = Math.max(Structs.length, value.length);
                    for (let i = 0; i < length; i++) {
                        yield [i, value[i], Structs[i] || Never];
                    }
                }
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value has a set of known properties of specific types.
     *
     * Note: Unrecognized properties are allowed and untouched. This is similar to
     * how TypeScript's structural typing works.
     */
    function type(schema) {
        const keys = Object.keys(schema);
        return new Struct({
            type: 'type',
            schema,
            *entries(value) {
                if (isObject(value)) {
                    for (const k of keys) {
                        yield [k, value[k], schema[k]];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Ensure that a value matches one of a set of types.
     */
    function union(Structs) {
        const description = Structs.map((s) => s.type).join(' | ');
        return new Struct({
            type: 'union',
            schema: null,
            coercer(value) {
                for (const S of Structs) {
                    const [error, coerced] = S.validate(value, { coerce: true });
                    if (!error) {
                        return coerced;
                    }
                }
                return value;
            },
            validator(value, ctx) {
                const failures = [];
                for (const S of Structs) {
                    const [...tuples] = run(value, S, ctx);
                    const [first] = tuples;
                    if (!first[0]) {
                        return [];
                    }
                    else {
                        for (const [failure] of tuples) {
                            if (failure) {
                                failures.push(failure);
                            }
                        }
                    }
                }
                return [
                    `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
                    ...failures,
                ];
            },
        });
    }
    /**
     * Ensure that any value passes validation, without widening its type to `any`.
     */
    function unknown() {
        return define('unknown', () => true);
    }

    /**
     * Augment a `Struct` to add an additional coercion step to its input.
     *
     * This allows you to transform input data before validating it, to increase the
     * likelihood that it passes validationfor example for default values, parsing
     * different formats, etc.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function coerce(struct, condition, coercer) {
        return new Struct({
            ...struct,
            coercer: (value, ctx) => {
                return is(value, condition)
                    ? struct.coercer(coercer(value, ctx), ctx)
                    : struct.coercer(value, ctx);
            },
        });
    }
    /**
     * Augment a struct to replace `undefined` values with a default.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function defaulted(struct, fallback, options = {}) {
        return coerce(struct, unknown(), (x) => {
            const f = typeof fallback === 'function' ? fallback() : fallback;
            if (x === undefined) {
                return f;
            }
            if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
                const ret = { ...x };
                let changed = false;
                for (const key in f) {
                    if (ret[key] === undefined) {
                        ret[key] = f[key];
                        changed = true;
                    }
                }
                if (changed) {
                    return ret;
                }
            }
            return x;
        });
    }
    /**
     * Augment a struct to trim string inputs.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function trimmed(struct) {
        return coerce(struct, string(), (x) => x.trim());
    }

    /**
     * Ensure that a string, array, map, or set is empty.
     */
    function empty(struct) {
        return refine(struct, 'empty', (value) => {
            const size = getSize(value);
            return (size === 0 ||
                `Expected an empty ${struct.type} but received one with a size of \`${size}\``);
        });
    }
    function getSize(value) {
        if (value instanceof Map || value instanceof Set) {
            return value.size;
        }
        else {
            return value.length;
        }
    }
    /**
     * Ensure that a number or date is below a threshold.
     */
    function max(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'max', (value) => {
            return exclusive
                ? value < threshold
                : value <= threshold ||
                    `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a number or date is above a threshold.
     */
    function min(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'min', (value) => {
            return exclusive
                ? value > threshold
                : value >= threshold ||
                    `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a string, array, map or set is not empty.
     */
    function nonempty(struct) {
        return refine(struct, 'nonempty', (value) => {
            const size = getSize(value);
            return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);
        });
    }
    /**
     * Ensure that a string matches a regular expression.
     */
    function pattern(struct, regexp) {
        return refine(struct, 'pattern', (value) => {
            return (regexp.test(value) ||
                `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`);
        });
    }
    /**
     * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
     */
    function size(struct, min, max = min) {
        const expected = `Expected a ${struct.type}`;
        const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
        return refine(struct, 'size', (value) => {
            if (typeof value === 'number' || value instanceof Date) {
                return ((min <= value && value <= max) ||
                    `${expected} ${of} but received \`${value}\``);
            }
            else if (value instanceof Map || value instanceof Set) {
                const { size } = value;
                return ((min <= size && size <= max) ||
                    `${expected} with a size ${of} but received one with a size of \`${size}\``);
            }
            else {
                const { length } = value;
                return ((min <= length && length <= max) ||
                    `${expected} with a length ${of} but received one with a length of \`${length}\``);
            }
        });
    }
    /**
     * Augment a `Struct` to add an additional refinement to the validation.
     *
     * The refiner function is guaranteed to receive a value of the struct's type,
     * because the struct's existing validation will already have passed. This
     * allows you to layer additional validation on top of existing structs.
     */
    function refine(struct, name, refiner) {
        return new Struct({
            ...struct,
            *refiner(value, ctx) {
                yield* struct.refiner(value, ctx);
                const result = refiner(value, ctx);
                const failures = toFailures(result, ctx, struct, value);
                for (const failure of failures) {
                    yield { ...failure, refinement: name };
                }
            },
        });
    }

    exports.Struct = Struct;
    exports.StructError = StructError;
    exports.any = any;
    exports.array = array;
    exports.assert = assert;
    exports.assign = assign;
    exports.bigint = bigint;
    exports.boolean = boolean;
    exports.coerce = coerce;
    exports.create = create;
    exports.date = date;
    exports.defaulted = defaulted;
    exports.define = define;
    exports.deprecated = deprecated;
    exports.dynamic = dynamic;
    exports.empty = empty;
    exports.enums = enums;
    exports.func = func;
    exports.instance = instance;
    exports.integer = integer;
    exports.intersection = intersection;
    exports.is = is;
    exports.lazy = lazy;
    exports.literal = literal;
    exports.map = map;
    exports.mask = mask;
    exports.max = max;
    exports.min = min;
    exports.never = never;
    exports.nonempty = nonempty;
    exports.nullable = nullable;
    exports.number = number;
    exports.object = object;
    exports.omit = omit;
    exports.optional = optional;
    exports.partial = partial;
    exports.pattern = pattern;
    exports.pick = pick;
    exports.record = record;
    exports.refine = refine;
    exports.regexp = regexp;
    exports.set = set;
    exports.size = size;
    exports.string = string;
    exports.struct = struct;
    exports.trimmed = trimmed;
    exports.tuple = tuple;
    exports.type = type;
    exports.union = union;
    exports.unknown = unknown;
    exports.validate = validate;

}));
//# sourceMappingURL=index.cjs.map

      };
    };
  }
  }
}, {package:"superstruct",file:"node_modules\\superstruct\\dist\\index.cjs",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\timers-browserify\\main.js", {"process/browser.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\process\\browser.js","timers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ctimers-browserify%5Cmain.js
      return function (require, module, exports) {
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

      };
    };
  }
  }
}, {package:"browserify>timers-browserify",file:"node_modules\\timers-browserify\\main.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\tslib\\tslib.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Ctslib%5Ctslib.js
      return function (require, module, exports) {
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __esDecorate;
var __runInitializers;
var __propKey;
var __setFunctionName;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __esDecorate = function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access) context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.push(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field") initializers.push(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    };

    __runInitializers = function (thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    };

    __propKey = function (x) {
        return typeof x === "symbol" ? x : "".concat(x);
    };

    __setFunctionName = function (f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
});

      };
    };
  }
  }
}, {package:"wait-on>rxjs>tslib",file:"node_modules\\tslib\\tslib.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\url\\url.js", {"./util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\url\\util.js","punycode":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\browserify\\node_modules\\punycode\\punycode.js","querystring":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\querystring-es3\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Curl%5Curl.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

      };
    };
  }
  }
}, {package:"browserify>url",file:"node_modules\\url\\url.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\url\\util.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Curl%5Cutil.js
      return function (require, module, exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

      };
    };
  }
  }
}, {package:"browserify>url",file:"node_modules\\url\\util.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\utf8\\utf8.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cutf8%5Cutf8.js
      return function (require, module, exports) {
/*! https://mths.be/utf8js v3.0.0 by @mathias */
;(function(root) {

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	root.version = '3.0.0';
	root.encode = utf8encode;
	root.decode = utf8decode;

}(typeof exports === 'undefined' ? this.utf8 = {} : exports));

      };
    };
  }
  }
}, {package:"@truffle/codec>utf8",file:"node_modules\\utf8\\utf8.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\util-deprecate\\browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cutil-deprecate%5Cbrowser.js
      return function (require, module, exports) {

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

      };
    };
  }
  }
}, {package:"@storybook/api>util-deprecate",file:"node_modules\\util-deprecate\\browser.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\index.js", {"./nil.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\nil.js","./parse.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js","./v1.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v1.js","./v3.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v3.js","./v4.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v4.js","./v5.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v5.js","./validate.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\validate.js","./version.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\version.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\md5-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cmd5-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\md5-browser.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\nil.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cnil.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\nil.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\parse.js", {"./validate.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cparse.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\parse.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\regex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cregex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\regex.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\rng-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Crng-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\rng-browser.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\sha1-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Csha1-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\sha1-browser.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js", {"./validate.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cstringify.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\stringify.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v1.js", {"./rng.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv1.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v1.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v3.js", {"./md5.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\md5-browser.js","./v35.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv3.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v3.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v35.js", {"./parse.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv35.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v35.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v4.js", {"./rng.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv4.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v4.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v5.js", {"./sha1.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\sha1-browser.js","./v35.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv5.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v5.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\validate.js", {"./regex.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\regex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cvalidate.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\validate.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\version.js", {"./validate.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cversion.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\version.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\valid-url\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cvalid-url%5Cindex.js
      return function (require, module, exports) {
(function(module) {
    'use strict';

    module.exports.is_uri = is_iri;
    module.exports.is_http_uri = is_http_iri;
    module.exports.is_https_uri = is_https_iri;
    module.exports.is_web_uri = is_web_iri;
    // Create aliases
    module.exports.isUri = is_iri;
    module.exports.isHttpUri = is_http_iri;
    module.exports.isHttpsUri = is_https_iri;
    module.exports.isWebUri = is_web_iri;


    // private function
    // internal URI spitter method - direct from RFC 3986
    var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
    };

    function is_iri(value) {
        if (!value) {
            return;
        }

        // check for illegal characters
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;

        // check for hex escapes that aren't complete
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        // scheme and path are required, though the path can be empty
        if (!(scheme && scheme.length && path.length >= 0)) return;

        // if authority is present, the path must be empty or begin with a /
        if (authority && authority.length) {
            if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
            // if authority is not present, the path must not start with //
            if (/^\/\//.test(path)) return;
        }

        // scheme must begin with a letter, then consist of letters, digits, +, ., or -
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))  return;

        // re-assemble the URL per section 5.3 in RFC 3986
        out += scheme + ':';
        if (authority && authority.length) {
            out += '//' + authority;
        }

        out += path;

        if (query && query.length) {
            out += '?' + query;
        }

        if (fragment && fragment.length) {
            out += '#' + fragment;
        }

        return out;
    }

    function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
            return;
        }

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var port = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        if (!scheme)  return;

        if(allowHttps) {
            if (scheme.toLowerCase() != 'https') return;
        } else {
            if (scheme.toLowerCase() != 'http') return;
        }

        // fully-qualified URIs must have an authority section that is
        // a valid host
        if (!authority) {
            return;
        }

        // enable port component
        if (/:(\d+)$/.test(authority)) {
            port = authority.match(/:(\d+)$/)[0];
            authority = authority.replace(/:\d+$/, '');
        }

        out += scheme + ':';
        out += '//' + authority;
        
        if (port) {
            out += port;
        }
        
        out += path;
        
        if(query && query.length){
            out += '?' + query;
        }

        if(fragment && fragment.length){
            out += '#' + fragment;
        }
        
        return out;
    }

    function is_https_iri(value) {
        return is_http_iri(value, true);
    }

    function is_web_iri(value) {
        return (is_http_iri(value) || is_https_iri(value));
    }

})(module);

      };
    };
  }
  }
}, {package:"valid-url",file:"node_modules\\valid-url\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\decode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Cdecode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\decode.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\encode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Cencode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\encode.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\index.js", {"./decode.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\decode.js","./encode.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\encode.js","./length.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\length.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Cindex.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\varint\\length.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Clength.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\length.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\vm-browserify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cvm-browserify%5Cindex.js
      return function (require, module, exports) {
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.(0,eval)() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return (0,eval)(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

      };
    };
  }
  }
}, {package:"browserify>vm-browserify",file:"node_modules\\vm-browserify\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cwebextension-polyfill%5Cdist%5Cbrowser-polyfill.js
      return function (require, module, exports) {
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("webextension-polyfill", ["module"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.browser = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.8.0 - Tue Apr 20 2021 11:27:38 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (typeof browser === "undefined" || Object.getPrototypeOf(browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
    const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      }); // Keep track if the deprecation warning has been logged at least once.

      let loggedSendResponseDeprecationWarning = false;
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              if (!loggedSendResponseDeprecationWarning) {
                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                loggedSendResponseDeprecationWarning = true;
              }

              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    };

    if (typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
      throw new Error("This script should only be loaded in a browser extension.");
    } // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map

      };
    };
  }
  }
}, {package:"webextension-polyfill",file:"node_modules\\webextension-polyfill\\dist\\browser-polyfill.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\wrappy\\wrappy.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cwrappy%5Cwrappy.js
      return function (require, module, exports) {
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

      };
    };
  }
  }
}, {package:"pump>once>wrappy",file:"node_modules\\wrappy\\wrappy.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\xtend\\immutable.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cxtend%5Cimmutable.js
      return function (require, module, exports) {
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

      };
    };
  }
  }
}, {package:"watchify>xtend",file:"node_modules\\xtend\\immutable.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\yallist\\iterator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cyallist%5Citerator.js
      return function (require, module, exports) {
'use strict'
module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}

      };
    };
  }
  }
}, {package:"semver>lru-cache>yallist",file:"node_modules\\yallist\\iterator.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\yallist\\yallist.js", {"./iterator.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\yallist\\iterator.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cnode_modules%5Cyallist%5Cyallist.js
      return function (require, module, exports) {
'use strict'
module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist)
} catch (er) {}

      };
    };
  }
  }
}, {package:"semver>lru-cache>yallist",file:"node_modules\\yallist\\yallist.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\alerts.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Calerts.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Web3ShimUsageAlertStates = exports.TOGGLEABLE_ALERT_TYPES = exports.AlertTypes = void 0;
let AlertTypes;
/**
 * Alerts that can be enabled or disabled by the user.
 */
exports.AlertTypes = AlertTypes;
(function (AlertTypes) {
  AlertTypes["unconnectedAccount"] = "unconnectedAccount";
  AlertTypes["web3ShimUsage"] = "web3ShimUsage";
  AlertTypes["invalidCustomNetwork"] = "invalidCustomNetwork";
})(AlertTypes || (exports.AlertTypes = AlertTypes = {}));
const TOGGLEABLE_ALERT_TYPES = [AlertTypes.unconnectedAccount, AlertTypes.web3ShimUsage];
exports.TOGGLEABLE_ALERT_TYPES = TOGGLEABLE_ALERT_TYPES;
let Web3ShimUsageAlertStates;
exports.Web3ShimUsageAlertStates = Web3ShimUsageAlertStates;
(function (Web3ShimUsageAlertStates) {
  Web3ShimUsageAlertStates[Web3ShimUsageAlertStates["recorded"] = 1] = "recorded";
  Web3ShimUsageAlertStates[Web3ShimUsageAlertStates["dismissed"] = 2] = "dismissed";
})(Web3ShimUsageAlertStates || (exports.Web3ShimUsageAlertStates = Web3ShimUsageAlertStates = {}));

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\alerts.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\app.ts", {"./permissions":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\permissions.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Capp.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNKNOWN_TICKER_SYMBOL = exports.POLLING_TOKEN_ENVIRONMENT_TYPES = exports.PLATFORM_OPERA = exports.PLATFORM_FIREFOX = exports.PLATFORM_EDGE = exports.PLATFORM_CHROME = exports.PLATFORM_BRAVE = exports.ORIGIN_METAMASK = exports.METAMASK_PROD_CHROME_ID = exports.METAMASK_MMI_PROD_CHROME_ID = exports.METAMASK_MMI_BETA_CHROME_ID = exports.METAMASK_FLASK_CHROME_ID = exports.METAMASK_BETA_CHROME_ID = exports.MESSAGE_TYPE = exports.FIREFOX_BUILD_IDS = exports.EXTENSION_MESSAGES = exports.ENVIRONMENT_TYPE_POPUP = exports.ENVIRONMENT_TYPE_NOTIFICATION = exports.ENVIRONMENT_TYPE_FULLSCREEN = exports.ENVIRONMENT_TYPE_BACKGROUND = exports.CHROME_BUILD_IDS = void 0;
var _permissions = require("./permissions");
/**
 * A string representing the type of environment the application is currently running in
 * popup - When the user click's the icon in their browser's extension bar; the default view
 * notification - When the extension opens due to interaction with a Web3 enabled website
 * fullscreen - When the user clicks 'expand view' to open the extension in a new tab
 * background - The background process that powers the extension
 */

const ENVIRONMENT_TYPE_POPUP = 'popup';
exports.ENVIRONMENT_TYPE_POPUP = ENVIRONMENT_TYPE_POPUP;
const ENVIRONMENT_TYPE_NOTIFICATION = 'notification';
exports.ENVIRONMENT_TYPE_NOTIFICATION = ENVIRONMENT_TYPE_NOTIFICATION;
const ENVIRONMENT_TYPE_FULLSCREEN = 'fullscreen';
exports.ENVIRONMENT_TYPE_FULLSCREEN = ENVIRONMENT_TYPE_FULLSCREEN;
const ENVIRONMENT_TYPE_BACKGROUND = 'background';
exports.ENVIRONMENT_TYPE_BACKGROUND = ENVIRONMENT_TYPE_BACKGROUND;
const PLATFORM_BRAVE = 'Brave';
exports.PLATFORM_BRAVE = PLATFORM_BRAVE;
const PLATFORM_CHROME = 'Chrome';
exports.PLATFORM_CHROME = PLATFORM_CHROME;
const PLATFORM_EDGE = 'Edge';
exports.PLATFORM_EDGE = PLATFORM_EDGE;
const PLATFORM_FIREFOX = 'Firefox';
exports.PLATFORM_FIREFOX = PLATFORM_FIREFOX;
const PLATFORM_OPERA = 'Opera';
exports.PLATFORM_OPERA = PLATFORM_OPERA;
const MESSAGE_TYPE = {
  ADD_ETHEREUM_CHAIN: 'wallet_addEthereumChain',
  ETH_ACCOUNTS: _permissions.RestrictedMethods.eth_accounts,
  ETH_DECRYPT: 'eth_decrypt',
  ETH_GET_ENCRYPTION_PUBLIC_KEY: 'eth_getEncryptionPublicKey',
  ETH_REQUEST_ACCOUNTS: 'eth_requestAccounts',
  ETH_SIGN: 'eth_sign',
  ETH_SIGN_TYPED_DATA: 'eth_signTypedData',
  ETH_SIGN_TYPED_DATA_V3: 'eth_signTypedData_v3',
  ETH_SIGN_TYPED_DATA_V4: 'eth_signTypedData_v4',
  GET_PROVIDER_STATE: 'metamask_getProviderState',
  LOG_WEB3_SHIM_USAGE: 'metamask_logWeb3ShimUsage',
  PERSONAL_SIGN: 'personal_sign',
  SEND_METADATA: 'metamask_sendDomainMetadata',
  SWITCH_ETHEREUM_CHAIN: 'wallet_switchEthereumChain',
  TRANSACTION: 'transaction',
  WALLET_REQUEST_PERMISSIONS: 'wallet_requestPermissions',
  WATCH_ASSET: 'wallet_watchAsset',
  WATCH_ASSET_LEGACY: 'metamask_watchAsset'
};

/**
 * Custom messages to send and be received by the extension
 */
exports.MESSAGE_TYPE = MESSAGE_TYPE;
const EXTENSION_MESSAGES = {
  CONNECTION_READY: 'CONNECTION_READY',
  READY: 'METAMASK_EXTENSION_READY'
};
exports.EXTENSION_MESSAGES = EXTENSION_MESSAGES;
const POLLING_TOKEN_ENVIRONMENT_TYPES = {
  [ENVIRONMENT_TYPE_POPUP]: 'popupGasPollTokens',
  [ENVIRONMENT_TYPE_NOTIFICATION]: 'notificationGasPollTokens',
  [ENVIRONMENT_TYPE_FULLSCREEN]: 'fullScreenGasPollTokens',
  [ENVIRONMENT_TYPE_BACKGROUND]: 'none'
};
exports.POLLING_TOKEN_ENVIRONMENT_TYPES = POLLING_TOKEN_ENVIRONMENT_TYPES;
const ORIGIN_METAMASK = 'metamask';
exports.ORIGIN_METAMASK = ORIGIN_METAMASK;
const METAMASK_BETA_CHROME_ID = 'pbbkamfgmaedccnfkmjcofcecjhfgldn';
exports.METAMASK_BETA_CHROME_ID = METAMASK_BETA_CHROME_ID;
const METAMASK_PROD_CHROME_ID = 'nkbihfbeogaeaoehlefnkodbefgpgknn';
exports.METAMASK_PROD_CHROME_ID = METAMASK_PROD_CHROME_ID;
const METAMASK_FLASK_CHROME_ID = 'ljfoeinjpaedjfecbmggjgodbgkmjkjk';
exports.METAMASK_FLASK_CHROME_ID = METAMASK_FLASK_CHROME_ID;
const METAMASK_MMI_BETA_CHROME_ID = 'kmbhbcbadohhhgdgihejcicbgcehoaeg';
exports.METAMASK_MMI_BETA_CHROME_ID = METAMASK_MMI_BETA_CHROME_ID;
const METAMASK_MMI_PROD_CHROME_ID = 'ikkihjamdhfiojpdbnfllpjigpneipbc';
exports.METAMASK_MMI_PROD_CHROME_ID = METAMASK_MMI_PROD_CHROME_ID;
const CHROME_BUILD_IDS = [METAMASK_BETA_CHROME_ID, METAMASK_PROD_CHROME_ID, METAMASK_FLASK_CHROME_ID, METAMASK_MMI_BETA_CHROME_ID, METAMASK_MMI_PROD_CHROME_ID];
exports.CHROME_BUILD_IDS = CHROME_BUILD_IDS;
const METAMASK_BETA_FIREFOX_ID = 'webextension-beta@metamask.io';
const METAMASK_PROD_FIREFOX_ID = 'webextension@metamask.io';
const METAMASK_FLASK_FIREFOX_ID = 'webextension-flask@metamask.io';
const FIREFOX_BUILD_IDS = [METAMASK_BETA_FIREFOX_ID, METAMASK_PROD_FIREFOX_ID, METAMASK_FLASK_FIREFOX_ID];
exports.FIREFOX_BUILD_IDS = FIREFOX_BUILD_IDS;
const UNKNOWN_TICKER_SYMBOL = 'UNKNOWN';
exports.UNKNOWN_TICKER_SYMBOL = UNKNOWN_TICKER_SYMBOL;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\app.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\common.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Ccommon.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EtherDenomination = void 0;
let EtherDenomination;
exports.EtherDenomination = EtherDenomination;
(function (EtherDenomination) {
  EtherDenomination["ETH"] = "ETH";
  EtherDenomination["GWEI"] = "GWEI";
  EtherDenomination["WEI"] = "WEI";
})(EtherDenomination || (exports.EtherDenomination = EtherDenomination = {}));

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\common.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\gas.ts", {"ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Cgas.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PriorityLevels = exports.NetworkCongestionThresholds = exports.MIN_GAS_LIMIT_HEX = exports.GasRecommendations = exports.GasEstimateTypes = exports.GAS_LIMITS = exports.EditGasModes = exports.CUSTOM_GAS_ESTIMATE = void 0;
var _ethereumjsUtil = require("ethereumjs-util");
const ONE_HUNDRED_THOUSAND = 100000;
const MIN_GAS_LIMIT_DEC = '21000';
const MIN_GAS_LIMIT_HEX = parseInt(MIN_GAS_LIMIT_DEC, 10).toString(16);
exports.MIN_GAS_LIMIT_HEX = MIN_GAS_LIMIT_HEX;
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: (0, _ethereumjsUtil.addHexPrefix)(MIN_GAS_LIMIT_HEX),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: (0, _ethereumjsUtil.addHexPrefix)(ONE_HUNDRED_THOUSAND.toString(16))
};

/**
 * @typedef {object} GasEstimateTypes
 * @property {'fee-market'} FEE_MARKET - A gas estimate for a fee market transaction generated by our gas estimation API.
 * @property {'legacy'} LEGACY - A gas estimate for a legacy Transaction generated by our gas estimation API.
 * @property {'eth_gasPrice'} ETH_GAS_PRICE - A gas estimate provided by the Ethereum node via eth_gasPrice.
 * @property {'none'} NONE - No gas estimate available.
 */

/**
 * These are already declared in @metamask/controllers but importing them from
 * that module and re-exporting causes the UI bundle size to expand beyond 4MB
 *
 * (TODO: This comment was added before @metamask/controllers was split up 
 * revisit now that @metamask/gas-fee-controller is available)
 *
 * @type {GasEstimateTypes}
 */
exports.GAS_LIMITS = GAS_LIMITS;
let GasEstimateTypes;
/**
 * These represent gas recommendation levels presented in the UI
 */
exports.GasEstimateTypes = GasEstimateTypes;
(function (GasEstimateTypes) {
  GasEstimateTypes["feeMarket"] = "fee-market";
  GasEstimateTypes["legacy"] = "legacy";
  GasEstimateTypes["ethGasPrice"] = "eth_gasPrice";
  GasEstimateTypes["none"] = "none";
})(GasEstimateTypes || (exports.GasEstimateTypes = GasEstimateTypes = {}));
let GasRecommendations;
/**
 * These represent types of gas estimation
 */
exports.GasRecommendations = GasRecommendations;
(function (GasRecommendations) {
  GasRecommendations["low"] = "low";
  GasRecommendations["medium"] = "medium";
  GasRecommendations["high"] = "high";
})(GasRecommendations || (exports.GasRecommendations = GasRecommendations = {}));
let PriorityLevels;
/**
 * Represents the user customizing their gas preference
 */
exports.PriorityLevels = PriorityLevels;
(function (PriorityLevels) {
  PriorityLevels["tenPercentIncreased"] = "tenPercentIncreased";
  PriorityLevels["low"] = "low";
  PriorityLevels["medium"] = "medium";
  PriorityLevels["high"] = "high";
  PriorityLevels["custom"] = "custom";
  PriorityLevels["dAppSuggested"] = "dappSuggested";
})(PriorityLevels || (exports.PriorityLevels = PriorityLevels = {}));
const CUSTOM_GAS_ESTIMATE = 'custom';

/**
 * These represent the different edit modes presented in the UI
 */
exports.CUSTOM_GAS_ESTIMATE = CUSTOM_GAS_ESTIMATE;
let EditGasModes;
/**
 * Represents levels for `networkCongestion` (calculated along with gas fee
 * estimates; represents a number between 0 and 1) that we use to render the
 * network status slider on the send transaction screen and inform users when
 * gas fees are high
 */
exports.EditGasModes = EditGasModes;
(function (EditGasModes) {
  EditGasModes["speedUp"] = "speed-up";
  EditGasModes["cancel"] = "cancel";
  EditGasModes["modifyInPlace"] = "modify-in-place";
  EditGasModes["swaps"] = "swaps";
})(EditGasModes || (exports.EditGasModes = EditGasModes = {}));
let NetworkCongestionThresholds;
exports.NetworkCongestionThresholds = NetworkCongestionThresholds;
(function (NetworkCongestionThresholds) {
  NetworkCongestionThresholds[NetworkCongestionThresholds["notBusy"] = 0] = "notBusy";
  NetworkCongestionThresholds[NetworkCongestionThresholds["stable"] = 0.33] = "stable";
  NetworkCongestionThresholds[NetworkCongestionThresholds["busy"] = 0.66] = "busy";
})(NetworkCongestionThresholds || (exports.NetworkCongestionThresholds = NetworkCongestionThresholds = {}));

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\gas.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\hardware-wallets.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Chardware-wallets.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebHIDConnectedStatuses = exports.LedgerTransportTypes = exports.LEDGER_USB_VENDOR_ID = exports.HardwareTransportStates = exports.HardwareKeyringType = exports.HardwareKeyringNames = exports.HardwareDeviceNames = exports.HardwareAffiliateTutorialLinks = exports.HardwareAffiliateLinks = void 0;
/**
 * Hardware wallets supported by MetaMask.
 */
let HardwareKeyringType;
exports.HardwareKeyringType = HardwareKeyringType;
(function (HardwareKeyringType) {
  HardwareKeyringType["ledger"] = "Ledger Hardware";
  HardwareKeyringType["trezor"] = "Trezor Hardware";
  HardwareKeyringType["lattice"] = "Lattice Hardware";
  HardwareKeyringType["qr"] = "QR Hardware Wallet Device";
})(HardwareKeyringType || (exports.HardwareKeyringType = HardwareKeyringType = {}));
let HardwareKeyringNames;
exports.HardwareKeyringNames = HardwareKeyringNames;
(function (HardwareKeyringNames) {
  HardwareKeyringNames["ledger"] = "Ledger";
  HardwareKeyringNames["trezor"] = "Trezor";
  HardwareKeyringNames["lattice"] = "Lattice1";
  HardwareKeyringNames["qr"] = "QR";
})(HardwareKeyringNames || (exports.HardwareKeyringNames = HardwareKeyringNames = {}));
let HardwareDeviceNames;
exports.HardwareDeviceNames = HardwareDeviceNames;
(function (HardwareDeviceNames) {
  HardwareDeviceNames["ledger"] = "ledger";
  HardwareDeviceNames["trezor"] = "trezor";
  HardwareDeviceNames["lattice"] = "lattice";
  HardwareDeviceNames["qr"] = "QR Hardware";
})(HardwareDeviceNames || (exports.HardwareDeviceNames = HardwareDeviceNames = {}));
let HardwareTransportStates;
exports.HardwareTransportStates = HardwareTransportStates;
(function (HardwareTransportStates) {
  HardwareTransportStates["none"] = "NONE";
  HardwareTransportStates["verified"] = "VERIFIED";
  HardwareTransportStates["deviceOpenFailure"] = "DEVICE_OPEN_FAILURE";
  HardwareTransportStates["unknownFailure"] = "UNKNOWN_FAILURE";
})(HardwareTransportStates || (exports.HardwareTransportStates = HardwareTransportStates = {}));
let HardwareAffiliateLinks;
exports.HardwareAffiliateLinks = HardwareAffiliateLinks;
(function (HardwareAffiliateLinks) {
  HardwareAffiliateLinks["ledger"] = "https://shop.ledger.com/?r=17c4991a03fa";
  HardwareAffiliateLinks["gridplus"] = "https://gridplus.io/?afmc=7p";
  HardwareAffiliateLinks["trezor"] = "https://shop.trezor.io/product/trezor-one-black?offer_id=35&aff_id=11009";
  HardwareAffiliateLinks["keystone"] = "https://keyst.one/metamask?rfsn=6088257.656b3e9&utm_source=refersion&utm_medium=affiliate&utm_campaign=6088257.656b3e9";
  HardwareAffiliateLinks["airgap"] = "https://airgap.it/";
  HardwareAffiliateLinks["coolwallet"] = "https://www.coolwallet.io/";
  HardwareAffiliateLinks["dcent"] = "https://dcentwallet.com/";
})(HardwareAffiliateLinks || (exports.HardwareAffiliateLinks = HardwareAffiliateLinks = {}));
let HardwareAffiliateTutorialLinks;
/**
 * Used for setting the users preference for ledger transport type
 */
exports.HardwareAffiliateTutorialLinks = HardwareAffiliateTutorialLinks;
(function (HardwareAffiliateTutorialLinks) {
  HardwareAffiliateTutorialLinks["ledger"] = "https://support.ledger.com/hc/en-us/articles/4404366864657-Set-up-and-use-MetaMask-to-access-your-Ledger-Ethereum-ETH-account?docs=true";
  HardwareAffiliateTutorialLinks["gridplus"] = "https://docs.gridplus.io/setup/metamask";
  HardwareAffiliateTutorialLinks["trezor"] = "https://wiki.trezor.io/Apps:MetaMask";
  HardwareAffiliateTutorialLinks["keystone"] = "https://support.keyst.one/3rd-party-wallets/eth-and-web3-wallets-keystone/bind-metamask-with-keystone";
  HardwareAffiliateTutorialLinks["airgap"] = "https://support.airgap.it/guides/metamask/";
  HardwareAffiliateTutorialLinks["coolwallet"] = "https://www.coolwallet.io/metamask-step-by-step-guides/";
  HardwareAffiliateTutorialLinks["dcent"] = "https://medium.com/dcentwallet/dcent-wallet-now-supports-qr-based-protocol-to-link-with-metamask-57555f02603f";
})(HardwareAffiliateTutorialLinks || (exports.HardwareAffiliateTutorialLinks = HardwareAffiliateTutorialLinks = {}));
let LedgerTransportTypes;
exports.LedgerTransportTypes = LedgerTransportTypes;
(function (LedgerTransportTypes) {
  LedgerTransportTypes["live"] = "ledgerLive";
  LedgerTransportTypes["webhid"] = "webhid";
  LedgerTransportTypes["u2f"] = "u2f";
})(LedgerTransportTypes || (exports.LedgerTransportTypes = LedgerTransportTypes = {}));
let WebHIDConnectedStatuses;
exports.WebHIDConnectedStatuses = WebHIDConnectedStatuses;
(function (WebHIDConnectedStatuses) {
  WebHIDConnectedStatuses["connected"] = "connected";
  WebHIDConnectedStatuses["notConnected"] = "notConnected";
  WebHIDConnectedStatuses["unknown"] = "unknown";
})(WebHIDConnectedStatuses || (exports.WebHIDConnectedStatuses = WebHIDConnectedStatuses = {}));
const LEDGER_USB_VENDOR_ID = '0x2c97';
exports.LEDGER_USB_VENDOR_ID = LEDGER_USB_VENDOR_ID;


      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\hardware-wallets.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\keyring.ts", {"./hardware-wallets":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\hardware-wallets.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Ckeyring.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyringType = exports.InternalKeyringType = void 0;
var _hardwareWallets = require("./hardware-wallets");
/**
 * These are the keyrings that are managed entirely by MetaMask.
 */
let InternalKeyringType;
/**
 * All keyrings supported by MetaMask.
 */
exports.InternalKeyringType = InternalKeyringType;
(function (InternalKeyringType) {
  InternalKeyringType["hdKeyTree"] = "HD Key Tree";
  InternalKeyringType["imported"] = "Simple Key Pair";
})(InternalKeyringType || (exports.InternalKeyringType = InternalKeyringType = {}));
const KeyringType = {
  ..._hardwareWallets.HardwareKeyringType,
  ...InternalKeyringType
};
exports.KeyringType = KeyringType;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\keyring.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\labels.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Clabels.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUNCATED_NAME_CHAR_LIMIT = exports.TRUNCATED_ADDRESS_START_CHARS = exports.TRUNCATED_ADDRESS_END_CHARS = void 0;
// The character limit on ENS names, nicknames and addresses before we truncate
const TRUNCATED_NAME_CHAR_LIMIT = 11;

// The number of characters to slice from the beginning of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`
exports.TRUNCATED_NAME_CHAR_LIMIT = TRUNCATED_NAME_CHAR_LIMIT;
const TRUNCATED_ADDRESS_START_CHARS = 5;

// The number of characters to slice from the end of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`
exports.TRUNCATED_ADDRESS_START_CHARS = TRUNCATED_ADDRESS_START_CHARS;
const TRUNCATED_ADDRESS_END_CHARS = 4;
exports.TRUNCATED_ADDRESS_END_CHARS = TRUNCATED_ADDRESS_END_CHARS;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\labels.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\metametrics.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Cmetametrics.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REJECT_NOTIFICATION_CLOSE_SIG = exports.REJECT_NOTIFICATION_CLOSE = exports.MetaMetricsUserTrait = exports.MetaMetricsTransactionEventSource = exports.MetaMetricsTokenEventSource = exports.MetaMetricsSwapsEventSource = exports.MetaMetricsNetworkEventSource = exports.MetaMetricsEventUiCustomization = exports.MetaMetricsEventOnrampProviderType = exports.MetaMetricsEventName = exports.MetaMetricsEventLocation = exports.MetaMetricsEventLinkType = exports.MetaMetricsEventKeyType = exports.MetaMetricsEventCategory = exports.MetaMetricsEventAccountType = exports.MetaMetricsEventAccountImportType = exports.MetaMetricsContextProp = exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = exports.METAMETRICS_ANONYMOUS_ID = void 0;
/**
 * Used to attach context of where the user was at in the application when the
 * event was triggered. Also included as full details of the current page in
 * page events.
 */
/**
 * The dapp that triggered an interaction (MetaMask only).
 */
/**
 * We attach context to every meta metrics event that help to qualify our
 * analytics. This type has all optional values because it represents a
 * returned object from a method call. Ideally app and userAgent are
 * defined on every event. This is confirmed in the getTrackMetaMetricsEvent
 * function, but still provides the consumer a way to override these values if
 * necessary.
 */
/**
 * Data sent to the `segment.track` method.
 */
/**
 * Data sent to MetaMetrics for page views.
 */
/**
 * Data sent to MetaMetrics for user traits.
 */
let MetaMetricsUserTrait;
/**
 * Mixpanel converts the zero address value to a truly anonymous event, which
 * speeds up reporting
 */
exports.MetaMetricsUserTrait = MetaMetricsUserTrait;
(function (MetaMetricsUserTrait) {
  MetaMetricsUserTrait["AddressBookEntries"] = "address_book_entries";
  MetaMetricsUserTrait["InstallDateExt"] = "install_date_ext";
  MetaMetricsUserTrait["LedgerConnectionType"] = "ledger_connection_type";
  MetaMetricsUserTrait["NetworksAdded"] = "networks_added";
  MetaMetricsUserTrait["NetworksWithoutTicker"] = "networks_without_ticker";
  MetaMetricsUserTrait["NftAutodetectionEnabled"] = "nft_autodetection_enabled";
  MetaMetricsUserTrait["NumberOfAccounts"] = "number_of_accounts";
  MetaMetricsUserTrait["NumberOfNftCollections"] = "number_of_nft_collections";
  MetaMetricsUserTrait["NumberOfNfts"] = "number_of_nfts";
  MetaMetricsUserTrait["NumberOfTokens"] = "number_of_tokens";
  MetaMetricsUserTrait["OpenSeaApiEnabled"] = "opensea_api_enabled";
  MetaMetricsUserTrait["Theme"] = "theme";
  MetaMetricsUserTrait["ThreeBoxEnabled"] = "three_box_enabled";
  MetaMetricsUserTrait["TokenDetectionEnabled"] = "token_detection_enabled";
  MetaMetricsUserTrait["DesktopEnabled"] = "desktop_enabled";
  MetaMetricsUserTrait["SecurityProviders"] = "security_providers";
})(MetaMetricsUserTrait || (exports.MetaMetricsUserTrait = MetaMetricsUserTrait = {}));
const METAMETRICS_ANONYMOUS_ID = '0x0000000000000000';

/**
 * Used to identify events that are triggered by the background process.
 */
exports.METAMETRICS_ANONYMOUS_ID = METAMETRICS_ANONYMOUS_ID;
const METAMETRICS_BACKGROUND_PAGE_OBJECT = {
  path: '/background-process',
  title: 'Background Process',
  url: '/background-process'
};
exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = METAMETRICS_BACKGROUND_PAGE_OBJECT;
const REJECT_NOTIFICATION_CLOSE = 'Cancel Via Notification Close';
exports.REJECT_NOTIFICATION_CLOSE = REJECT_NOTIFICATION_CLOSE;
const REJECT_NOTIFICATION_CLOSE_SIG = 'Cancel Sig Request Via Notification Close';
exports.REJECT_NOTIFICATION_CLOSE_SIG = REJECT_NOTIFICATION_CLOSE_SIG;
let MetaMetricsEventName;
exports.MetaMetricsEventName = MetaMetricsEventName;
(function (MetaMetricsEventName) {
  MetaMetricsEventName["AccountAdded"] = "Account Added";
  MetaMetricsEventName["AccountAddSelected"] = "Account Add Selected";
  MetaMetricsEventName["AccountAddFailed"] = "Account Add Failed";
  MetaMetricsEventName["AccountPasswordCreated"] = "Account Password Created";
  MetaMetricsEventName["AccountReset"] = "Account Reset";
  MetaMetricsEventName["AccountRenamed"] = "Account Renamed";
  MetaMetricsEventName["AppInstalled"] = "App Installed";
  MetaMetricsEventName["AppUnlocked"] = "App Unlocked";
  MetaMetricsEventName["AppUnlockedFailed"] = "App Unlocked Failed";
  MetaMetricsEventName["AppLocked"] = "App Locked";
  MetaMetricsEventName["AppWindowExpanded"] = "App Window Expanded";
  MetaMetricsEventName["BridgeLinkClicked"] = "Bridge Link Clicked";
  MetaMetricsEventName["DecryptionApproved"] = "Decryption Approved";
  MetaMetricsEventName["DecryptionRejected"] = "Decryption Rejected";
  MetaMetricsEventName["DecryptionRequested"] = "Decryption Requested";
  MetaMetricsEventName["EncryptionPublicKeyApproved"] = "Encryption Approved";
  MetaMetricsEventName["EncryptionPublicKeyRejected"] = "Encryption Rejected";
  MetaMetricsEventName["EncryptionPublicKeyRequested"] = "Encryption Requested";
  MetaMetricsEventName["ExternalLinkClicked"] = "External Link Clicked";
  MetaMetricsEventName["KeyExportSelected"] = "Key Export Selected";
  MetaMetricsEventName["KeyExportRequested"] = "Key Export Requested";
  MetaMetricsEventName["KeyExportFailed"] = "Key Export Failed";
  MetaMetricsEventName["KeyExportCanceled"] = "Key Export Canceled";
  MetaMetricsEventName["KeyExportRevealed"] = "Key Material Revealed";
  MetaMetricsEventName["KeyExportCopied"] = "Key Material Copied";
  MetaMetricsEventName["KeyTokenDetectionSelected"] = "Key Token Detection Selected";
  MetaMetricsEventName["KeyGlobalSecurityToggleSelected"] = "Key Global Security/Privacy Settings";
  MetaMetricsEventName["KeyBalanceTokenPriceChecker"] = "Key Show Balance and Token Price Checker Settings";
  MetaMetricsEventName["KeyGasFeeEstimationBuySwapTokens"] = "Key Show Gas Fee Estimation, Buy Crypto and Swap Tokens";
  MetaMetricsEventName["KeyAutoDetectTokens"] = "Key Autodetect tokens";
  MetaMetricsEventName["KeyBatchAccountBalanceRequests"] = "Key Batch account balance requests";
  MetaMetricsEventName["MetricsOptIn"] = "Metrics Opt In";
  MetaMetricsEventName["MetricsOptOut"] = "Metrics Opt Out";
  MetaMetricsEventName["NavAccountMenuOpened"] = "Account Menu Opened";
  MetaMetricsEventName["NavAccountDetailsOpened"] = "Account Details Opened";
  MetaMetricsEventName["NavConnectedSitesOpened"] = "Connected Sites Opened";
  MetaMetricsEventName["NavMainMenuOpened"] = "Main Menu Opened";
  MetaMetricsEventName["NavNetworkMenuOpened"] = "Network Menu Opened";
  MetaMetricsEventName["NavSettingsOpened"] = "Settings Opened";
  MetaMetricsEventName["NavAccountSwitched"] = "Account Switched";
  MetaMetricsEventName["NavNetworkSwitched"] = "Network Switched";
  MetaMetricsEventName["NavBuyButtonClicked"] = "Buy Button Clicked";
  MetaMetricsEventName["NavSendButtonClicked"] = "Send Button Clicked";
  MetaMetricsEventName["NavSwapButtonClicked"] = "Swap Button Clicked";
  MetaMetricsEventName["NftAdded"] = "NFT Added";
  MetaMetricsEventName["OnboardingWelcome"] = "App Installed";
  MetaMetricsEventName["OnboardingWalletCreationStarted"] = "Wallet Setup Selected";
  MetaMetricsEventName["OnboardingWalletImportStarted"] = "Wallet Import Started";
  MetaMetricsEventName["OnboardingWalletCreationAttempted"] = "Wallet Password Created";
  MetaMetricsEventName["OnboardingWalletSecurityStarted"] = "SRP Backup Selected";
  MetaMetricsEventName["OnboardingWalletSecuritySkipInitiated"] = "SRP Skip Backup Selected";
  MetaMetricsEventName["OnboardingWalletSecuritySkipConfirmed"] = "SRP Backup Skipped";
  MetaMetricsEventName["OnboardingWalletSecuritySkipCanceled"] = "SRP Skip Backup Canceled";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseRevealed"] = "SRP Revealed";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseWrittenDown"] = "SRP Backup Confirm Display";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseConfirmed"] = "SRP Backup Confirmed";
  MetaMetricsEventName["OnboardingWalletCreationComplete"] = "Wallet Created";
  MetaMetricsEventName["OnboardingWalletSetupComplete"] = "Application Opened";
  MetaMetricsEventName["OnboardingWalletAdvancedSettings"] = "Settings Updated";
  MetaMetricsEventName["OnboardingWalletImportAttempted"] = "Wallet Import Attempted";
  MetaMetricsEventName["OnboardingWalletVideoPlay"] = "SRP Intro Video Played";
  MetaMetricsEventName["OnboardingTwitterClick"] = "External Link Clicked";
  MetaMetricsEventName["OnrampProviderSelected"] = "On-ramp Provider Selected";
  MetaMetricsEventName["PermissionsApproved"] = "Permissions Approved";
  MetaMetricsEventName["PermissionsRejected"] = "Permissions Rejected";
  MetaMetricsEventName["PermissionsRequested"] = "Permissions Requested";
  MetaMetricsEventName["PhishingPageDisplayed"] = "Phishing Page Displayed";
  MetaMetricsEventName["PortfolioLinkClicked"] = "Portfolio Link Clicked";
  MetaMetricsEventName["ProviderMethodCalled"] = "Provider Method Called";
  MetaMetricsEventName["PublicAddressCopied"] = "Public Address Copied";
  MetaMetricsEventName["ServiceWorkerRestarted"] = "Service Worker Restarted";
  MetaMetricsEventName["SignatureApproved"] = "Signature Approved";
  MetaMetricsEventName["SignatureFailed"] = "Signature Failed";
  MetaMetricsEventName["SignatureRejected"] = "Signature Rejected";
  MetaMetricsEventName["SignatureRequested"] = "Signature Requested";
  MetaMetricsEventName["SrpRevealStarted"] = "Reveal SRP Initiated";
  MetaMetricsEventName["SrpRevealClicked"] = "Clicked Reveal Secret Recovery";
  MetaMetricsEventName["SrpRevealViewed"] = "Views Reveal Secret Recovery";
  MetaMetricsEventName["SrpRevealBackButtonClicked"] = "Clicked Back on Reveal SRP Password Page";
  MetaMetricsEventName["SrpRevealCancelled"] = "Reveal SRP Cancelled";
  MetaMetricsEventName["SrpRevealCancelButtonClicked"] = "Clicks Cancel on Reveal Secret Recovery Phrase Page";
  MetaMetricsEventName["SrpRevealCloseClicked"] = "Clicks CLOSE with SRP";
  MetaMetricsEventName["SrpRevealNextClicked"] = "Clicks Next on Reveal Secret Recovery Phrase";
  MetaMetricsEventName["SrpHoldToRevealClickStarted"] = "Reveal SRP Click Started";
  MetaMetricsEventName["SrpHoldToRevealCloseClicked"] = "Closes Hold To Reveal SRP";
  MetaMetricsEventName["SrpHoldToRevealCompleted"] = "Reveal SRP Completed";
  MetaMetricsEventName["SrpViewsSrpQR"] = "Views SRP QR Code";
  MetaMetricsEventName["SrpViewSrpText"] = "Views SRP";
  MetaMetricsEventName["SrpCopiedToClipboard"] = "Copies SRP to clipboard";
  MetaMetricsEventName["SrpToConfirmBackup"] = "SRP Backup Confirm Displayed";
  MetaMetricsEventName["SupportLinkClicked"] = "Support Link Clicked";
  MetaMetricsEventName["TermsOfUseShown"] = "Terms of Use Shown";
  MetaMetricsEventName["TermsOfUseAccepted"] = "Terms of Use Accepted";
  MetaMetricsEventName["TokenImportButtonClicked"] = "Import Token Button Clicked";
  MetaMetricsEventName["TokenScreenOpened"] = "Token Screen Opened";
  MetaMetricsEventName["TokenAdded"] = "Token Added";
  MetaMetricsEventName["TokenDetected"] = "Token Detected";
  MetaMetricsEventName["TokenHidden"] = "Token Hidden";
  MetaMetricsEventName["TokenImportCanceled"] = "Token Import Canceled";
  MetaMetricsEventName["TokenImportClicked"] = "Token Import Clicked";
  MetaMetricsEventName["WalletSetupStarted"] = "Wallet Setup Selected";
  MetaMetricsEventName["WalletSetupCanceled"] = "Wallet Setup Canceled";
  MetaMetricsEventName["WalletSetupFailed"] = "Wallet Setup Failed";
  MetaMetricsEventName["WalletCreated"] = "Wallet Created";
  MetaMetricsEventName["AccountDetailMenuOpened"] = "Account Details Menu Opened";
  MetaMetricsEventName["BlockExplorerLinkClicked"] = "Block Explorer Clicked";
  MetaMetricsEventName["AccountRemoved"] = "Account Removed";
  MetaMetricsEventName["TestNetworksDisplayed"] = "Test Networks Displayed";
  MetaMetricsEventName["AddNetworkButtonClick"] = "Add Network Button Clicked";
  MetaMetricsEventName["CustomNetworkAdded"] = "Custom Network Added";
  MetaMetricsEventName["TokenDetailsOpened"] = "Token Details Opened";
  MetaMetricsEventName["NftScreenOpened"] = "NFT Screen Opened";
  MetaMetricsEventName["ActivityScreenOpened"] = "Activity Screen Opened";
  MetaMetricsEventName["WhatsNewViewed"] = "What's New Viewed";
  MetaMetricsEventName["WhatsNewClicked"] = "What's New Link Clicked";
})(MetaMetricsEventName || (exports.MetaMetricsEventName = MetaMetricsEventName = {}));
let MetaMetricsEventAccountType;
exports.MetaMetricsEventAccountType = MetaMetricsEventAccountType;
(function (MetaMetricsEventAccountType) {
  MetaMetricsEventAccountType["Default"] = "metamask";
  MetaMetricsEventAccountType["Hardware"] = "hardware";
  MetaMetricsEventAccountType["Imported"] = "imported";
})(MetaMetricsEventAccountType || (exports.MetaMetricsEventAccountType = MetaMetricsEventAccountType = {}));
let MetaMetricsEventAccountImportType;
exports.MetaMetricsEventAccountImportType = MetaMetricsEventAccountImportType;
(function (MetaMetricsEventAccountImportType) {
  MetaMetricsEventAccountImportType["Json"] = "json";
  MetaMetricsEventAccountImportType["PrivateKey"] = "private_key";
  MetaMetricsEventAccountImportType["Srp"] = "srp";
})(MetaMetricsEventAccountImportType || (exports.MetaMetricsEventAccountImportType = MetaMetricsEventAccountImportType = {}));
let MetaMetricsEventCategory;
exports.MetaMetricsEventCategory = MetaMetricsEventCategory;
(function (MetaMetricsEventCategory) {
  MetaMetricsEventCategory["Accounts"] = "Accounts";
  MetaMetricsEventCategory["App"] = "App";
  MetaMetricsEventCategory["Auth"] = "Auth";
  MetaMetricsEventCategory["Background"] = "Background";
  MetaMetricsEventCategory["Desktop"] = "Desktop";
  MetaMetricsEventCategory["Error"] = "Error";
  MetaMetricsEventCategory["Footer"] = "Footer";
  MetaMetricsEventCategory["Home"] = "Home";
  MetaMetricsEventCategory["InpageProvider"] = "inpage_provider";
  MetaMetricsEventCategory["Keys"] = "Keys";
  MetaMetricsEventCategory["Messages"] = "Messages";
  MetaMetricsEventCategory["Navigation"] = "Navigation";
  MetaMetricsEventCategory["Network"] = "Network";
  MetaMetricsEventCategory["Onboarding"] = "Onboarding";
  MetaMetricsEventCategory["Phishing"] = "Phishing";
  MetaMetricsEventCategory["Retention"] = "Retention";
  MetaMetricsEventCategory["ServiceWorkers"] = "service_workers";
  MetaMetricsEventCategory["Settings"] = "Settings";
  MetaMetricsEventCategory["Snaps"] = "Snaps";
  MetaMetricsEventCategory["Swaps"] = "Swaps";
  MetaMetricsEventCategory["Transactions"] = "Transactions";
  MetaMetricsEventCategory["Wallet"] = "Wallet";
  MetaMetricsEventCategory["Tokens"] = "Tokens";
})(MetaMetricsEventCategory || (exports.MetaMetricsEventCategory = MetaMetricsEventCategory = {}));
let MetaMetricsEventLinkType;
exports.MetaMetricsEventLinkType = MetaMetricsEventLinkType;
(function (MetaMetricsEventLinkType) {
  MetaMetricsEventLinkType["AccountTracker"] = "Account Tracker";
  MetaMetricsEventLinkType["BlockExplorer"] = "Block Explorer";
  MetaMetricsEventLinkType["TokenTracker"] = "Token Tracker";
  MetaMetricsEventLinkType["TransactionBlockExplorer"] = "Transaction Block Explorer";
})(MetaMetricsEventLinkType || (exports.MetaMetricsEventLinkType = MetaMetricsEventLinkType = {}));
let MetaMetricsEventKeyType; // NOTE: This doesn't seem to be used at all
exports.MetaMetricsEventKeyType = MetaMetricsEventKeyType;
(function (MetaMetricsEventKeyType) {
  MetaMetricsEventKeyType["Pkey"] = "private_key";
  MetaMetricsEventKeyType["Srp"] = "srp";
})(MetaMetricsEventKeyType || (exports.MetaMetricsEventKeyType = MetaMetricsEventKeyType = {}));
let MetaMetricsEventOnrampProviderType;
exports.MetaMetricsEventOnrampProviderType = MetaMetricsEventOnrampProviderType;
(function (MetaMetricsEventOnrampProviderType) {
  MetaMetricsEventOnrampProviderType["Coinbase"] = "coinbase";
  MetaMetricsEventOnrampProviderType["Moonpay"] = "moonpay";
  MetaMetricsEventOnrampProviderType["SelfDeposit"] = "direct_deposit";
  MetaMetricsEventOnrampProviderType["Transak"] = "transak";
  MetaMetricsEventOnrampProviderType["Wyre"] = "wyre";
})(MetaMetricsEventOnrampProviderType || (exports.MetaMetricsEventOnrampProviderType = MetaMetricsEventOnrampProviderType = {}));
let MetaMetricsNetworkEventSource;
exports.MetaMetricsNetworkEventSource = MetaMetricsNetworkEventSource;
(function (MetaMetricsNetworkEventSource) {
  MetaMetricsNetworkEventSource["CustomNetworkForm"] = "custom_network_form";
  MetaMetricsNetworkEventSource["PopularNetworkList"] = "popular_network_list";
  MetaMetricsNetworkEventSource["Dapp"] = "dapp";
})(MetaMetricsNetworkEventSource || (exports.MetaMetricsNetworkEventSource = MetaMetricsNetworkEventSource = {}));
let MetaMetricsSwapsEventSource;
exports.MetaMetricsSwapsEventSource = MetaMetricsSwapsEventSource;
(function (MetaMetricsSwapsEventSource) {
  MetaMetricsSwapsEventSource["MainView"] = "Main View";
  MetaMetricsSwapsEventSource["TokenView"] = "Token View";
})(MetaMetricsSwapsEventSource || (exports.MetaMetricsSwapsEventSource = MetaMetricsSwapsEventSource = {}));
let MetaMetricsTokenEventSource;
exports.MetaMetricsTokenEventSource = MetaMetricsTokenEventSource;
(function (MetaMetricsTokenEventSource) {
  MetaMetricsTokenEventSource["Custom"] = "custom";
  MetaMetricsTokenEventSource["Dapp"] = "dapp";
  MetaMetricsTokenEventSource["Detected"] = "detected";
  MetaMetricsTokenEventSource["List"] = "list";
})(MetaMetricsTokenEventSource || (exports.MetaMetricsTokenEventSource = MetaMetricsTokenEventSource = {}));
let MetaMetricsTransactionEventSource;
exports.MetaMetricsTransactionEventSource = MetaMetricsTransactionEventSource;
(function (MetaMetricsTransactionEventSource) {
  MetaMetricsTransactionEventSource["Dapp"] = "dapp";
  MetaMetricsTransactionEventSource["User"] = "user";
})(MetaMetricsTransactionEventSource || (exports.MetaMetricsTransactionEventSource = MetaMetricsTransactionEventSource = {}));
let MetaMetricsEventLocation;
exports.MetaMetricsEventLocation = MetaMetricsEventLocation;
(function (MetaMetricsEventLocation) {
  MetaMetricsEventLocation["TokenDetails"] = "token_details";
  MetaMetricsEventLocation["TokenDetection"] = "token_detection";
  MetaMetricsEventLocation["TokenMenu"] = "token_menu";
})(MetaMetricsEventLocation || (exports.MetaMetricsEventLocation = MetaMetricsEventLocation = {}));
let MetaMetricsEventUiCustomization;
/**
 * Values that can used in the "properties" tracking object as keys, e.g. `{
 * location: 'Home' }`.
 */
exports.MetaMetricsEventUiCustomization = MetaMetricsEventUiCustomization;
(function (MetaMetricsEventUiCustomization) {
  MetaMetricsEventUiCustomization["FlaggedAsMalicious"] = "flagged_as_malicious";
  MetaMetricsEventUiCustomization["FlaggedAsSafetyUnknown"] = "flagged_as_safety_unknown";
  MetaMetricsEventUiCustomization["Siwe"] = "sign_in_with_ethereum";
})(MetaMetricsEventUiCustomization || (exports.MetaMetricsEventUiCustomization = MetaMetricsEventUiCustomization = {}));
let MetaMetricsContextProp;
exports.MetaMetricsContextProp = MetaMetricsContextProp;
(function (MetaMetricsContextProp) {
  MetaMetricsContextProp["PageTitle"] = "location";
})(MetaMetricsContextProp || (exports.MetaMetricsContextProp = MetaMetricsContextProp = {}));

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\metametrics.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts", {"lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Cnetwork.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.infuraProjectId = exports.getRpcUrl = exports.UNSUPPORTED_RPC_METHODS = exports.TEST_NETWORK_TICKER_MAP = exports.TEST_ETH_TOKEN_IMAGE_URL = exports.TEST_CHAINS = exports.SHOULD_SHOW_LINEA_TESTNET_NETWORK = exports.SEPOLIA_RPC_URL = exports.SEPOLIA_DISPLAY_NAME = exports.POLYGON_DISPLAY_NAME = exports.PALM_TOKEN_IMAGE_URL = exports.PALM_DISPLAY_NAME = exports.OPTIMISM_TOKEN_IMAGE_URL = exports.OPTIMISM_DISPLAY_NAME = exports.NetworkStatus = exports.NETWORK_TYPES = exports.NETWORK_TO_NAME_MAP = exports.NETWORK_NAMES = exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = exports.NETWORK_IDS = exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = exports.MAX_SAFE_CHAIN_ID = exports.MATIC_TOKEN_IMAGE_URL = exports.MAINNET_RPC_URL = exports.MAINNET_DISPLAY_NAME = exports.LOCALHOST_RPC_URL = exports.LOCALHOST_DISPLAY_NAME = exports.LINEA_TESTNET_RPC_URL = exports.LINEA_TESTNET_DISPLAY_NAME = exports.IPFS_DEFAULT_GATEWAY_URL = exports.INFURA_PROVIDER_TYPES = exports.INFURA_BLOCKED_KEY = exports.HARMONY_ONE_TOKEN_IMAGE_URL = exports.HARMONY_DISPLAY_NAME = exports.GOERLI_RPC_URL = exports.GOERLI_DISPLAY_NAME = exports.FTM_TOKEN_IMAGE_URL = exports.FEATURED_RPCS = exports.FANTOM_DISPLAY_NAME = exports.ETH_TOKEN_IMAGE_URL = exports.ETHERSCAN_SUPPORTED_NETWORKS = exports.CURRENCY_SYMBOLS = exports.CHAIN_ID_TO_TYPE_MAP = exports.CHAIN_ID_TO_RPC_URL_MAP = exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = exports.CHAIN_ID_TO_NETWORK_ID_MAP = exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = exports.CHAIN_IDS = exports.CELO_TOKEN_IMAGE_URL = exports.CELO_DISPLAY_NAME = exports.BUYABLE_CHAINS_MAP = exports.BUILT_IN_NETWORKS = exports.BUILT_IN_INFURA_NETWORKS = exports.BSC_DISPLAY_NAME = exports.BNB_TOKEN_IMAGE_URL = exports.BNB_DISPLAY_NAME = exports.AVAX_TOKEN_IMAGE_URL = exports.AVALANCHE_DISPLAY_NAME = exports.AURORA_TOKEN_IMAGE_URL = exports.AURORA_DISPLAY_NAME = exports.ARBITRUM_DISPLAY_NAME = exports.AETH_TOKEN_IMAGE_URL = void 0;
var _lodash = require("lodash");
/**
 * A type representing any valid value for 'type' for setProviderType and other
 * methods that add or manipulate networks in MetaMask state.
 */

/**
 * A union type of all possible hard-coded chain ids. This type is not
 * exhaustive and cannot be used for typing chainId in areas where the user or
 * dapp may specify any chainId.
 */

/**
 * A type that is a union type of all possible hardcoded currency symbols.
 * This type is non-exhaustive, and cannot be used for areas where the user
 * or dapp may supply their own symbol.
 */

/**
 * Test networks have special symbols that combine the network name and 'ETH'
 * so that they are distinct from mainnet and other networks that use 'ETH'.
 */

/**
 * An object containing preferences for an RPC definition
 */

/**
 * An object that describes a network to be used inside of MetaMask
 */

/**
 * For each chain that we support fiat onramps for, we provide a set of
 * configuration options that help for initializing the connectiong to the
 * onramp providers.
 */

/**
 * Throughout the extension we set the current provider by referencing its
 * "type", which can be any of the values in the below object. These values
 * represent the built-in networks of MetaMask, including test nets, as well
 * as "rpc" which is the "type" of a custom network added by the user or via
 * wallet_addEthereumChain.
 */
const NETWORK_TYPES = {
  GOERLI: 'goerli',
  LOCALHOST: 'localhost',
  MAINNET: 'mainnet',
  RPC: 'rpc',
  SEPOLIA: 'sepolia',
  LINEA_TESTNET: 'lineatestnet'
};

/**
 * An object containing shortcut names for any non-builtin network. We need
 * this to be able to differentiate between networks that require custom
 * sections of code for our various features, such as swaps or token lists.
 */
exports.NETWORK_TYPES = NETWORK_TYPES;
const NETWORK_NAMES = {
  HOMESTEAD: 'homestead'
};

/**
 * The Network ID for our builtin networks. This is the decimal equivalent of
 * the chain id for the network, but is expresssed as a string. Many moons ago
 * the decision was made on the extension team to expressly use chainId with
 * hex encoding over network id. Consider that when accessing this object. Note
 * for cross product purposes: alignment with mobile on this matter has not
 * been fully achieved, thus it is possible for some dependencies to still
 * ask for or require network id.
 */
exports.NETWORK_NAMES = NETWORK_NAMES;
const NETWORK_IDS = {
  MAINNET: '1',
  GOERLI: '5',
  LOCALHOST: '1337',
  SEPOLIA: '11155111',
  LINEA_TESTNET: '59140'
};

/**
 * An object containing all of the chain ids for networks both built in and
 * those that we have added custom code to support our feature set.
 */
exports.NETWORK_IDS = NETWORK_IDS;
const CHAIN_IDS = {
  MAINNET: '0x1',
  GOERLI: '0x5',
  LOCALHOST: '0x539',
  BSC: '0x38',
  BSC_TESTNET: '0x61',
  OPTIMISM: '0xa',
  OPTIMISM_TESTNET: '0x1a4',
  POLYGON: '0x89',
  POLYGON_TESTNET: '0x13881',
  AVALANCHE: '0xa86a',
  AVALANCHE_TESTNET: '0xa869',
  FANTOM: '0xfa',
  FANTOM_TESTNET: '0xfa2',
  CELO: '0xa4ec',
  ARBITRUM: '0xa4b1',
  HARMONY: '0x63564c40',
  PALM: '0x2a15c308d',
  SEPOLIA: '0xaa36a7',
  LINEA_TESTNET: '0xe704',
  AURORA: '0x4e454152',
  MOONBEAM: '0x504',
  MOONBEAM_TESTNET: '0x507',
  MOONRIVER: '0x505'
};

/**
 * The largest possible chain ID we can handle.
 * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553
 */
exports.CHAIN_IDS = CHAIN_IDS;
const MAX_SAFE_CHAIN_ID = 4503599627370476;
exports.MAX_SAFE_CHAIN_ID = MAX_SAFE_CHAIN_ID;
const MAINNET_DISPLAY_NAME = 'Ethereum Mainnet';
exports.MAINNET_DISPLAY_NAME = MAINNET_DISPLAY_NAME;
const GOERLI_DISPLAY_NAME = 'Goerli';
exports.GOERLI_DISPLAY_NAME = GOERLI_DISPLAY_NAME;
const SEPOLIA_DISPLAY_NAME = 'Sepolia';
exports.SEPOLIA_DISPLAY_NAME = SEPOLIA_DISPLAY_NAME;
const LINEA_TESTNET_DISPLAY_NAME = 'Linea Goerli test network';
exports.LINEA_TESTNET_DISPLAY_NAME = LINEA_TESTNET_DISPLAY_NAME;
const LOCALHOST_DISPLAY_NAME = 'Localhost 8545';
exports.LOCALHOST_DISPLAY_NAME = LOCALHOST_DISPLAY_NAME;
const BSC_DISPLAY_NAME = 'Binance Smart Chain';
exports.BSC_DISPLAY_NAME = BSC_DISPLAY_NAME;
const POLYGON_DISPLAY_NAME = 'Polygon';
exports.POLYGON_DISPLAY_NAME = POLYGON_DISPLAY_NAME;
const AVALANCHE_DISPLAY_NAME = 'Avalanche Network C-Chain';
exports.AVALANCHE_DISPLAY_NAME = AVALANCHE_DISPLAY_NAME;
const ARBITRUM_DISPLAY_NAME = 'Arbitrum One';
exports.ARBITRUM_DISPLAY_NAME = ARBITRUM_DISPLAY_NAME;
const BNB_DISPLAY_NAME = 'BNB Smart Chain (previously Binance Smart Chain Mainnet)';
exports.BNB_DISPLAY_NAME = BNB_DISPLAY_NAME;
const OPTIMISM_DISPLAY_NAME = 'Optimism';
exports.OPTIMISM_DISPLAY_NAME = OPTIMISM_DISPLAY_NAME;
const FANTOM_DISPLAY_NAME = 'Fantom Opera';
exports.FANTOM_DISPLAY_NAME = FANTOM_DISPLAY_NAME;
const HARMONY_DISPLAY_NAME = 'Harmony Mainnet Shard 0';
exports.HARMONY_DISPLAY_NAME = HARMONY_DISPLAY_NAME;
const PALM_DISPLAY_NAME = 'Palm';
exports.PALM_DISPLAY_NAME = PALM_DISPLAY_NAME;
const AURORA_DISPLAY_NAME = 'Aurora Mainnet';
exports.AURORA_DISPLAY_NAME = AURORA_DISPLAY_NAME;
const CELO_DISPLAY_NAME = 'Celo Mainnet';
exports.CELO_DISPLAY_NAME = CELO_DISPLAY_NAME;
const infuraProjectId = "8065dfb8bdac45eb91bb7e12ccd58f1c";
exports.infuraProjectId = infuraProjectId;
const getRpcUrl = ({
  network,
  excludeProjectId = false
}) => `https://${network}.infura.io/v3/${excludeProjectId ? '' : infuraProjectId}`;
exports.getRpcUrl = getRpcUrl;
const MAINNET_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.MAINNET
});
exports.MAINNET_RPC_URL = MAINNET_RPC_URL;
const GOERLI_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.GOERLI
});
exports.GOERLI_RPC_URL = GOERLI_RPC_URL;
const SEPOLIA_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.SEPOLIA
});
exports.SEPOLIA_RPC_URL = SEPOLIA_RPC_URL;
const LINEA_TESTNET_RPC_URL = 'https://rpc.goerli.linea.build';
exports.LINEA_TESTNET_RPC_URL = LINEA_TESTNET_RPC_URL;
const LOCALHOST_RPC_URL = 'http://localhost:8545';

/**
 * An object containing the token symbols for various tokens that are either
 * native currencies or those that have been special cased by the extension
 * for supporting our feature set.
 */
exports.LOCALHOST_RPC_URL = LOCALHOST_RPC_URL;
const CURRENCY_SYMBOLS = {
  ARBITRUM: 'ETH',
  AURORA: 'Aurora ETH',
  AVALANCHE: 'AVAX',
  BNB: 'BNB',
  BUSD: 'BUSD',
  CELO: 'CELO',
  DAI: 'DAI',
  ETH: 'ETH',
  FANTOM: 'FTM',
  HARMONY: 'ONE',
  PALM: 'PALM',
  MATIC: 'MATIC',
  TEST_ETH: 'TESTETH',
  USDC: 'USDC',
  USDT: 'USDT',
  WETH: 'WETH',
  OPTIMISM: 'OP'
};
exports.CURRENCY_SYMBOLS = CURRENCY_SYMBOLS;
const ETH_TOKEN_IMAGE_URL = './images/eth_logo.png';
exports.ETH_TOKEN_IMAGE_URL = ETH_TOKEN_IMAGE_URL;
const TEST_ETH_TOKEN_IMAGE_URL = './images/black-eth-logo.svg';
exports.TEST_ETH_TOKEN_IMAGE_URL = TEST_ETH_TOKEN_IMAGE_URL;
const BNB_TOKEN_IMAGE_URL = './images/bnb.png';
exports.BNB_TOKEN_IMAGE_URL = BNB_TOKEN_IMAGE_URL;
const MATIC_TOKEN_IMAGE_URL = './images/matic-token.png';
exports.MATIC_TOKEN_IMAGE_URL = MATIC_TOKEN_IMAGE_URL;
const AVAX_TOKEN_IMAGE_URL = './images/avax-token.png';
exports.AVAX_TOKEN_IMAGE_URL = AVAX_TOKEN_IMAGE_URL;
const AETH_TOKEN_IMAGE_URL = './images/arbitrum.svg';
exports.AETH_TOKEN_IMAGE_URL = AETH_TOKEN_IMAGE_URL;
const FTM_TOKEN_IMAGE_URL = './images/fantom-opera.svg';
exports.FTM_TOKEN_IMAGE_URL = FTM_TOKEN_IMAGE_URL;
const HARMONY_ONE_TOKEN_IMAGE_URL = './images/harmony-one.svg';
exports.HARMONY_ONE_TOKEN_IMAGE_URL = HARMONY_ONE_TOKEN_IMAGE_URL;
const OPTIMISM_TOKEN_IMAGE_URL = './images/optimism.svg';
exports.OPTIMISM_TOKEN_IMAGE_URL = OPTIMISM_TOKEN_IMAGE_URL;
const PALM_TOKEN_IMAGE_URL = './images/palm.svg';
exports.PALM_TOKEN_IMAGE_URL = PALM_TOKEN_IMAGE_URL;
const AURORA_TOKEN_IMAGE_URL = './images/aurora.png';
exports.AURORA_TOKEN_IMAGE_URL = AURORA_TOKEN_IMAGE_URL;
const CELO_TOKEN_IMAGE_URL = './images/celo.svg';
exports.CELO_TOKEN_IMAGE_URL = CELO_TOKEN_IMAGE_URL;
const INFURA_PROVIDER_TYPES = [NETWORK_TYPES.MAINNET, NETWORK_TYPES.GOERLI, NETWORK_TYPES.SEPOLIA];
exports.INFURA_PROVIDER_TYPES = INFURA_PROVIDER_TYPES;
const TEST_CHAINS = [CHAIN_IDS.GOERLI, CHAIN_IDS.SEPOLIA, CHAIN_IDS.LINEA_TESTNET, CHAIN_IDS.LOCALHOST];
exports.TEST_CHAINS = TEST_CHAINS;
const typedCapitalize = k => (0, _lodash.capitalize)(k);
const TEST_NETWORK_TICKER_MAP = {
  [NETWORK_TYPES.GOERLI]: `${typedCapitalize(NETWORK_TYPES.GOERLI)}${CURRENCY_SYMBOLS.ETH}`,
  [NETWORK_TYPES.SEPOLIA]: `${typedCapitalize(NETWORK_TYPES.SEPOLIA)}${CURRENCY_SYMBOLS.ETH}`,
  [NETWORK_TYPES.LINEA_TESTNET]: `Linea${CURRENCY_SYMBOLS.ETH}`
};

/**
 * Map of all build-in Infura networks to their network, ticker and chain IDs.
 */
exports.TEST_NETWORK_TICKER_MAP = TEST_NETWORK_TICKER_MAP;
const BUILT_IN_NETWORKS = {
  [NETWORK_TYPES.GOERLI]: {
    networkId: NETWORK_IDS.GOERLI,
    chainId: CHAIN_IDS.GOERLI,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.GOERLI],
    blockExplorerUrl: `https://${NETWORK_TYPES.GOERLI}.etherscan.io`
  },
  [NETWORK_TYPES.SEPOLIA]: {
    networkId: NETWORK_IDS.SEPOLIA,
    chainId: CHAIN_IDS.SEPOLIA,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
    blockExplorerUrl: `https://${NETWORK_TYPES.SEPOLIA}.etherscan.io`
  },
  [NETWORK_TYPES.LINEA_TESTNET]: {
    networkId: NETWORK_IDS.LINEA_TESTNET,
    chainId: CHAIN_IDS.LINEA_TESTNET,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.LINEA_TESTNET],
    blockExplorerUrl: 'https://explorer.goerli.linea.build'
  },
  [NETWORK_TYPES.MAINNET]: {
    networkId: NETWORK_IDS.MAINNET,
    chainId: CHAIN_IDS.MAINNET,
    blockExplorerUrl: `https://etherscan.io`
  },
  [NETWORK_TYPES.LOCALHOST]: {
    networkId: NETWORK_IDS.LOCALHOST,
    chainId: CHAIN_IDS.LOCALHOST
  }
};
exports.BUILT_IN_NETWORKS = BUILT_IN_NETWORKS;
const BUILT_IN_INFURA_NETWORKS = (0, _lodash.pick)(BUILT_IN_NETWORKS, INFURA_PROVIDER_TYPES);
exports.BUILT_IN_INFURA_NETWORKS = BUILT_IN_INFURA_NETWORKS;
const NETWORK_TO_NAME_MAP = {
  [NETWORK_TYPES.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_TYPES.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_TYPES.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_TYPES.LINEA_TESTNET]: LINEA_TESTNET_DISPLAY_NAME,
  [NETWORK_TYPES.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [NETWORK_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_IDS.LINEA_TESTNET]: LINEA_TESTNET_DISPLAY_NAME,
  [NETWORK_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [CHAIN_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [CHAIN_IDS.LINEA_TESTNET]: LINEA_TESTNET_DISPLAY_NAME,
  [CHAIN_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME
};
exports.NETWORK_TO_NAME_MAP = NETWORK_TO_NAME_MAP;
const CHAIN_ID_TO_TYPE_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_TYPES.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [CHAIN_IDS.LINEA_TESTNET]: NETWORK_TYPES.LINEA_TESTNET,
  [CHAIN_IDS.LOCALHOST]: NETWORK_TYPES.LOCALHOST
};
exports.CHAIN_ID_TO_TYPE_MAP = CHAIN_ID_TO_TYPE_MAP;
const CHAIN_ID_TO_RPC_URL_MAP = {
  [CHAIN_IDS.GOERLI]: GOERLI_RPC_URL,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_RPC_URL,
  [CHAIN_IDS.LINEA_TESTNET]: LINEA_TESTNET_RPC_URL,
  [CHAIN_IDS.MAINNET]: MAINNET_RPC_URL,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_RPC_URL
};
exports.CHAIN_ID_TO_RPC_URL_MAP = CHAIN_ID_TO_RPC_URL_MAP;
const CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = {
  [CHAIN_IDS.MAINNET]: ETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
  [CHAIN_IDS.BSC]: BNB_TOKEN_IMAGE_URL,
  [CHAIN_IDS.POLYGON]: MATIC_TOKEN_IMAGE_URL,
  [CHAIN_IDS.ARBITRUM]: AETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.FANTOM]: FTM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.HARMONY]: HARMONY_ONE_TOKEN_IMAGE_URL,
  [CHAIN_IDS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.PALM]: PALM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AURORA]: AURORA_TOKEN_IMAGE_URL,
  [CHAIN_IDS.CELO]: CELO_TOKEN_IMAGE_URL
};
exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP;
const NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = {
  [NETWORK_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [NETWORK_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [NETWORK_IDS.LINEA_TESTNET]: NETWORK_TYPES.LINEA_TESTNET,
  [NETWORK_IDS.MAINNET]: NETWORK_NAMES.HOMESTEAD
};
exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP;
const CHAIN_ID_TO_NETWORK_ID_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_IDS.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_IDS.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_IDS.SEPOLIA,
  [CHAIN_IDS.LINEA_TESTNET]: NETWORK_IDS.LINEA_TESTNET,
  [CHAIN_IDS.LOCALHOST]: NETWORK_IDS.LOCALHOST
};
exports.CHAIN_ID_TO_NETWORK_ID_MAP = CHAIN_ID_TO_NETWORK_ID_MAP;
const NATIVE_CURRENCY_TOKEN_IMAGE_MAP = {
  [CURRENCY_SYMBOLS.ETH]: ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.TEST_ETH]: TEST_ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.BNB]: BNB_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.MATIC]: MATIC_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.CELO]: CELO_TOKEN_IMAGE_URL
};
exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = NATIVE_CURRENCY_TOKEN_IMAGE_MAP;
const INFURA_BLOCKED_KEY = 'countryBlocked';
exports.INFURA_BLOCKED_KEY = INFURA_BLOCKED_KEY;
const defaultEtherscanDomain = 'etherscan.io';
const defaultEtherscanSubdomainPrefix = 'api';
/**
 * Map of all Etherscan supported networks.
 */
const ETHERSCAN_SUPPORTED_NETWORKS = {
  [CHAIN_IDS.GOERLI]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-${CHAIN_ID_TO_TYPE_MAP[CHAIN_IDS.GOERLI]}`,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.GOERLI]
  },
  [CHAIN_IDS.MAINNET]: {
    domain: defaultEtherscanDomain,
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.MAINNET]
  },
  [CHAIN_IDS.SEPOLIA]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-${CHAIN_ID_TO_TYPE_MAP[CHAIN_IDS.SEPOLIA]}`,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.SEPOLIA]
  },
  [CHAIN_IDS.LINEA_TESTNET]: {
    domain: 'linea.build',
    subdomain: 'explorer.goerli',
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.LINEA_TESTNET]
  },
  [CHAIN_IDS.BSC]: {
    domain: 'bscscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.BSC, 16).toString()
  },
  [CHAIN_IDS.BSC_TESTNET]: {
    domain: 'bscscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.BSC_TESTNET, 16).toString()
  },
  [CHAIN_IDS.OPTIMISM]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-optimistic`,
    networkId: parseInt(CHAIN_IDS.OPTIMISM, 16).toString()
  },
  [CHAIN_IDS.OPTIMISM_TESTNET]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-goerli-optimistic`,
    networkId: parseInt(CHAIN_IDS.OPTIMISM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.POLYGON]: {
    domain: 'polygonscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.POLYGON, 16).toString()
  },
  [CHAIN_IDS.POLYGON_TESTNET]: {
    domain: 'polygonscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-mumbai`,
    networkId: parseInt(CHAIN_IDS.POLYGON_TESTNET, 16).toString()
  },
  [CHAIN_IDS.AVALANCHE]: {
    domain: 'snowtrace.io',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.AVALANCHE, 16).toString()
  },
  [CHAIN_IDS.AVALANCHE_TESTNET]: {
    domain: 'snowtrace.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.AVALANCHE_TESTNET, 16).toString()
  },
  [CHAIN_IDS.FANTOM]: {
    domain: 'ftmscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.FANTOM, 16).toString()
  },
  [CHAIN_IDS.FANTOM_TESTNET]: {
    domain: 'ftmscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.FANTOM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.MOONBEAM]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonbeam`,
    networkId: parseInt(CHAIN_IDS.MOONBEAM, 16).toString()
  },
  [CHAIN_IDS.MOONBEAM_TESTNET]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonbase`,
    networkId: parseInt(CHAIN_IDS.MOONBEAM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.MOONRIVER]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonriver`,
    networkId: parseInt(CHAIN_IDS.MOONRIVER, 16).toString()
  }
};
exports.ETHERSCAN_SUPPORTED_NETWORKS = ETHERSCAN_SUPPORTED_NETWORKS;
const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
  [CHAIN_IDS.OPTIMISM]: 1,
  [CHAIN_IDS.OPTIMISM_TESTNET]: 1
};

/**
 * Ethereum JSON-RPC methods that are known to exist but that we intentionally
 * do not support.
 */
exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP;
const UNSUPPORTED_RPC_METHODS = new Set([
// This is implemented later in our middleware stack  specifically, in
// eth-json-rpc-middleware  but our UI does not support it.
'eth_signTransaction']);
exports.UNSUPPORTED_RPC_METHODS = UNSUPPORTED_RPC_METHODS;
const IPFS_DEFAULT_GATEWAY_URL = 'dweb.link';

// The first item in transakCurrencies must be the
// default crypto currency for the network
exports.IPFS_DEFAULT_GATEWAY_URL = IPFS_DEFAULT_GATEWAY_URL;
const BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME = 'ethereum';
const BUYABLE_CHAINS_MAP = {
  [CHAIN_IDS.MAINNET]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.SEPOLIA]: {
    nativeCurrency: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.BSC]: {
    nativeCurrency: CURRENCY_SYMBOLS.BNB,
    network: 'bsc'
  },
  [CHAIN_IDS.POLYGON]: {
    nativeCurrency: CURRENCY_SYMBOLS.MATIC,
    network: 'polygon'
  },
  [CHAIN_IDS.AVALANCHE]: {
    nativeCurrency: CURRENCY_SYMBOLS.AVALANCHE,
    network: 'avaxcchain'
  },
  [CHAIN_IDS.FANTOM]: {
    nativeCurrency: CURRENCY_SYMBOLS.FANTOM,
    network: 'fantom'
  },
  [CHAIN_IDS.CELO]: {
    nativeCurrency: CURRENCY_SYMBOLS.CELO,
    network: 'celo'
  },
  [CHAIN_IDS.OPTIMISM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: 'optimism'
  },
  [CHAIN_IDS.ARBITRUM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ARBITRUM,
    network: 'arbitrum'
  }
};
exports.BUYABLE_CHAINS_MAP = BUYABLE_CHAINS_MAP;
const FEATURED_RPCS = [{
  chainId: CHAIN_IDS.ARBITRUM,
  nickname: ARBITRUM_DISPLAY_NAME,
  rpcUrl: `https://arbitrum-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ARBITRUM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.arbitrum.io',
    imageUrl: AETH_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AURORA,
  nickname: AURORA_DISPLAY_NAME,
  rpcUrl: `https://aurora-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AURORA,
  rpcPrefs: {
    blockExplorerUrl: 'https://aurorascan.dev/',
    imageUrl: AURORA_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AVALANCHE,
  nickname: AVALANCHE_DISPLAY_NAME,
  rpcUrl: `https://avalanche-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AVALANCHE,
  rpcPrefs: {
    blockExplorerUrl: 'https://snowtrace.io/',
    imageUrl: AVAX_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.BSC,
  nickname: BNB_DISPLAY_NAME,
  rpcUrl: 'https://bsc-dataseed.binance.org/',
  ticker: CURRENCY_SYMBOLS.BNB,
  rpcPrefs: {
    blockExplorerUrl: 'https://bscscan.com/',
    imageUrl: BNB_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.FANTOM,
  nickname: FANTOM_DISPLAY_NAME,
  rpcUrl: 'https://rpc.ftm.tools/',
  ticker: CURRENCY_SYMBOLS.FANTOM,
  rpcPrefs: {
    blockExplorerUrl: 'https://ftmscan.com/',
    imageUrl: FTM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.HARMONY,
  nickname: HARMONY_DISPLAY_NAME,
  rpcUrl: 'https://api.harmony.one/',
  ticker: CURRENCY_SYMBOLS.HARMONY,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.harmony.one/',
    imageUrl: HARMONY_ONE_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.OPTIMISM,
  nickname: OPTIMISM_DISPLAY_NAME,
  rpcUrl: `https://optimism-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ETH,
  rpcPrefs: {
    blockExplorerUrl: 'https://optimistic.etherscan.io/',
    imageUrl: OPTIMISM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.PALM,
  nickname: PALM_DISPLAY_NAME,
  rpcUrl: `https://palm-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.PALM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.palm.io/',
    imageUrl: PALM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.POLYGON,
  nickname: `${POLYGON_DISPLAY_NAME} ${(0, _lodash.capitalize)(NETWORK_TYPES.MAINNET)}`,
  rpcUrl: `https://polygon-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.MATIC,
  rpcPrefs: {
    blockExplorerUrl: 'https://polygonscan.com/',
    imageUrl: MATIC_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.CELO,
  nickname: CELO_DISPLAY_NAME,
  rpcUrl: `https://celo-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.CELO,
  rpcPrefs: {
    blockExplorerUrl: 'https://celoscan.io',
    imageUrl: CELO_TOKEN_IMAGE_URL
  }
}];
exports.FEATURED_RPCS = FEATURED_RPCS;
const SHOULD_SHOW_LINEA_TESTNET_NETWORK = new Date().getTime() > Date.UTC(2023, 2, 28, 8);

/**
 * Represents the availability state of the currently selected network.
 */
exports.SHOULD_SHOW_LINEA_TESTNET_NETWORK = SHOULD_SHOW_LINEA_TESTNET_NETWORK;
let NetworkStatus;
exports.NetworkStatus = NetworkStatus;
(function (NetworkStatus) {
  NetworkStatus["Unknown"] = "unknown";
  NetworkStatus["Available"] = "available";
  NetworkStatus["Unavailable"] = "unavailable";
  NetworkStatus["Blocked"] = "blocked";
})(NetworkStatus || (exports.NetworkStatus = NetworkStatus = {}));


      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\network.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\permissions.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Cpermissions.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestrictedMethods = exports.CaveatTypes = void 0;
const CaveatTypes = Object.freeze({
  restrictReturnedAccounts: 'restrictReturnedAccounts'
});
exports.CaveatTypes = CaveatTypes;
const RestrictedMethods = Object.freeze({
  eth_accounts: 'eth_accounts'
});
exports.RestrictedMethods = RestrictedMethods;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\permissions.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\preferences.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Cpreferences.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeType = void 0;
let ThemeType;
exports.ThemeType = ThemeType;
(function (ThemeType) {
  ThemeType["light"] = "light";
  ThemeType["dark"] = "dark";
  ThemeType["os"] = "os";
})(ThemeType || (exports.ThemeType = ThemeType = {}));

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\preferences.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\swaps.ts", {"./network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Cswaps.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WMATIC_CONTRACT_ADDRESS = exports.WETH_OPTIMISM_CONTRACT_ADDRESS = exports.WETH_GOERLI_CONTRACT_ADDRESS = exports.WETH_CONTRACT_ADDRESS = exports.WETH_ARBITRUM_CONTRACT_ADDRESS = exports.WBNB_CONTRACT_ADDRESS = exports.WAVAX_CONTRACT_ADDRESS = exports.TokenBucketPriority = exports.TEST_ETH_SWAPS_TOKEN_OBJECT = exports.Slippage = exports.SWAP_FAILED_ERROR = exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = exports.SWAPS_FETCH_ORDER_CONFLICT = exports.SWAPS_DEV_API_V2_BASE_URL = exports.SWAPS_CLIENT_ID = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = exports.SWAPS_API_V2_BASE_URL = exports.QUOTES_NOT_AVAILABLE_ERROR = exports.QUOTES_EXPIRED_ERROR = exports.POLYGON = exports.OPTIMISM_SWAPS_TOKEN_OBJECT = exports.OPTIMISM = exports.OFFLINE_FOR_MAINTENANCE = exports.MATIC_SWAPS_TOKEN_OBJECT = exports.GOERLI_SWAPS_TOKEN_OBJECT = exports.GOERLI = exports.GAS_DEV_API_BASE_URL = exports.GAS_API_BASE_URL = exports.ETH_SWAPS_TOKEN_OBJECT = exports.ETHEREUM = exports.ERROR_FETCHING_QUOTES = exports.DEFAULT_ERC20_APPROVE_GAS = exports.CONTRACT_DATA_DISABLED_ERROR = exports.BSC = exports.BNB_SWAPS_TOKEN_OBJECT = exports.AVAX_SWAPS_TOKEN_OBJECT = exports.AVALANCHE = exports.ARBITRUM_SWAPS_TOKEN_OBJECT = exports.ARBITRUM = exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = exports.ALLOWED_CONTRACT_ADDRESSES = void 0;
var _network = require("./network");
const QUOTES_EXPIRED_ERROR = 'quotes-expired';
exports.QUOTES_EXPIRED_ERROR = QUOTES_EXPIRED_ERROR;
const SWAP_FAILED_ERROR = 'swap-failed-error';
exports.SWAP_FAILED_ERROR = SWAP_FAILED_ERROR;
const ERROR_FETCHING_QUOTES = 'error-fetching-quotes';
exports.ERROR_FETCHING_QUOTES = ERROR_FETCHING_QUOTES;
const QUOTES_NOT_AVAILABLE_ERROR = 'quotes-not-avilable';
exports.QUOTES_NOT_AVAILABLE_ERROR = QUOTES_NOT_AVAILABLE_ERROR;
const CONTRACT_DATA_DISABLED_ERROR = 'contract-data-disabled';
exports.CONTRACT_DATA_DISABLED_ERROR = CONTRACT_DATA_DISABLED_ERROR;
const OFFLINE_FOR_MAINTENANCE = 'offline-for-maintenance';
exports.OFFLINE_FOR_MAINTENANCE = OFFLINE_FOR_MAINTENANCE;
const SWAPS_FETCH_ORDER_CONFLICT = 'swaps-fetch-order-conflict';

// An address that the metaswap-api recognizes as the default token for the current network,
// in place of the token address that ERC-20 tokens have
exports.SWAPS_FETCH_ORDER_CONFLICT = SWAPS_FETCH_ORDER_CONFLICT;
const DEFAULT_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000';
const ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.ETH_TOKEN_IMAGE_URL
};
exports.ETH_SWAPS_TOKEN_OBJECT = ETH_SWAPS_TOKEN_OBJECT;
const BNB_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.BNB,
  name: 'Binance Coin',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.BNB_TOKEN_IMAGE_URL
};
exports.BNB_SWAPS_TOKEN_OBJECT = BNB_SWAPS_TOKEN_OBJECT;
const MATIC_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.MATIC,
  name: 'Matic',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.MATIC_TOKEN_IMAGE_URL
};
exports.MATIC_SWAPS_TOKEN_OBJECT = MATIC_SWAPS_TOKEN_OBJECT;
const AVAX_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.AVALANCHE,
  name: 'Avalanche',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.AVAX_TOKEN_IMAGE_URL
};
exports.AVAX_SWAPS_TOKEN_OBJECT = AVAX_SWAPS_TOKEN_OBJECT;
const TEST_ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.TEST_ETH,
  name: 'Test Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
};
exports.TEST_ETH_SWAPS_TOKEN_OBJECT = TEST_ETH_SWAPS_TOKEN_OBJECT;
const GOERLI_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
};
exports.GOERLI_SWAPS_TOKEN_OBJECT = GOERLI_SWAPS_TOKEN_OBJECT;
const ARBITRUM_SWAPS_TOKEN_OBJECT = {
  ...ETH_SWAPS_TOKEN_OBJECT
};
exports.ARBITRUM_SWAPS_TOKEN_OBJECT = ARBITRUM_SWAPS_TOKEN_OBJECT;
const OPTIMISM_SWAPS_TOKEN_OBJECT = {
  ...ETH_SWAPS_TOKEN_OBJECT
};

// A gas value for ERC20 approve calls that should be sufficient for all ERC20 approve implementations
exports.OPTIMISM_SWAPS_TOKEN_OBJECT = OPTIMISM_SWAPS_TOKEN_OBJECT;
const DEFAULT_ERC20_APPROVE_GAS = '0x1d4c0';

// Contract addresses below should be in lowercase.
exports.DEFAULT_ERC20_APPROVE_GAS = DEFAULT_ERC20_APPROVE_GAS;
const MAINNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const TESTNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const BSC_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const POLYGON_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const AVALANCHE_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const OPTIMISM_CONTRACT_ADDRESS = '0x9dda6ef3d919c9bc8885d5560999a3640431e8e6';
const ARBITRUM_CONTRACT_ADDRESS = '0x9dda6ef3d919c9bc8885d5560999a3640431e8e6';
const WETH_CONTRACT_ADDRESS = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';
exports.WETH_CONTRACT_ADDRESS = WETH_CONTRACT_ADDRESS;
const WETH_GOERLI_CONTRACT_ADDRESS = '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6';
exports.WETH_GOERLI_CONTRACT_ADDRESS = WETH_GOERLI_CONTRACT_ADDRESS;
const WBNB_CONTRACT_ADDRESS = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c';
exports.WBNB_CONTRACT_ADDRESS = WBNB_CONTRACT_ADDRESS;
const WMATIC_CONTRACT_ADDRESS = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';
exports.WMATIC_CONTRACT_ADDRESS = WMATIC_CONTRACT_ADDRESS;
const WAVAX_CONTRACT_ADDRESS = '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7';
exports.WAVAX_CONTRACT_ADDRESS = WAVAX_CONTRACT_ADDRESS;
const WETH_OPTIMISM_CONTRACT_ADDRESS = '0x4200000000000000000000000000000000000006';
exports.WETH_OPTIMISM_CONTRACT_ADDRESS = WETH_OPTIMISM_CONTRACT_ADDRESS;
const WETH_ARBITRUM_CONTRACT_ADDRESS = '0x82af49447d8a07e3bd95bd0d56f35241523fbab1';
exports.WETH_ARBITRUM_CONTRACT_ADDRESS = WETH_ARBITRUM_CONTRACT_ADDRESS;
const SWAPS_TESTNET_CHAIN_ID = '0x539';
const SWAPS_API_V2_BASE_URL = 'https://swap.metaswap.codefi.network';
exports.SWAPS_API_V2_BASE_URL = SWAPS_API_V2_BASE_URL;
const SWAPS_DEV_API_V2_BASE_URL = 'https://swap.metaswap-dev.codefi.network';
exports.SWAPS_DEV_API_V2_BASE_URL = SWAPS_DEV_API_V2_BASE_URL;
const GAS_API_BASE_URL = 'https://gas-api.metaswap.codefi.network';
exports.GAS_API_BASE_URL = GAS_API_BASE_URL;
const GAS_DEV_API_BASE_URL = 'https://gas-api.metaswap-dev.codefi.network';
exports.GAS_DEV_API_BASE_URL = GAS_DEV_API_BASE_URL;
const BSC_DEFAULT_BLOCK_EXPLORER_URL = 'https://bscscan.com/';
const MAINNET_DEFAULT_BLOCK_EXPLORER_URL = 'https://etherscan.io/';
const GOERLI_DEFAULT_BLOCK_EXPLORER_URL = 'https://goerli.etherscan.io/';
const POLYGON_DEFAULT_BLOCK_EXPLORER_URL = 'https://polygonscan.com/';
const AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL = 'https://snowtrace.io/';
const OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL = 'https://optimistic.etherscan.io/';
const ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL = 'https://arbiscan.io/';
const ALLOWED_PROD_SWAPS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, SWAPS_TESTNET_CHAIN_ID, _network.CHAIN_IDS.BSC, _network.CHAIN_IDS.POLYGON, _network.CHAIN_IDS.AVALANCHE, _network.CHAIN_IDS.OPTIMISM, _network.CHAIN_IDS.ARBITRUM];
exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = ALLOWED_PROD_SWAPS_CHAIN_IDS;
const ALLOWED_DEV_SWAPS_CHAIN_IDS = [...ALLOWED_PROD_SWAPS_CHAIN_IDS, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = ALLOWED_DEV_SWAPS_CHAIN_IDS;
const ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS;
const SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = {
  [_network.CHAIN_IDS.MAINNET]: MAINNET_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: BSC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_CONTRACT_ADDRESS
};
exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = SWAPS_CHAINID_CONTRACT_ADDRESS_MAP;
const SWAPS_WRAPPED_TOKENS_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: WETH_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: WETH_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: WBNB_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: WMATIC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: WETH_GOERLI_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: WAVAX_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.OPTIMISM]: WETH_OPTIMISM_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.ARBITRUM]: WETH_ARBITRUM_CONTRACT_ADDRESS
};
exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = SWAPS_WRAPPED_TOKENS_ADDRESSES;
const ALLOWED_CONTRACT_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.MAINNET], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.MAINNET]],
  [SWAPS_TESTNET_CHAIN_ID]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[SWAPS_TESTNET_CHAIN_ID], SWAPS_WRAPPED_TOKENS_ADDRESSES[SWAPS_TESTNET_CHAIN_ID]],
  [_network.CHAIN_IDS.GOERLI]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.GOERLI], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.GOERLI]],
  [_network.CHAIN_IDS.BSC]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.BSC], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.BSC]],
  [_network.CHAIN_IDS.POLYGON]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.POLYGON], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.POLYGON]],
  [_network.CHAIN_IDS.AVALANCHE]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.AVALANCHE], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.AVALANCHE]],
  [_network.CHAIN_IDS.OPTIMISM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.OPTIMISM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.OPTIMISM]],
  [_network.CHAIN_IDS.ARBITRUM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.ARBITRUM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.ARBITRUM]]
};
exports.ALLOWED_CONTRACT_ADDRESSES = ALLOWED_CONTRACT_ADDRESSES;
const SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
  [_network.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
  [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT
};
exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = SWAPS_CHAINID_DEFAULT_TOKEN_MAP;
const SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = {
  [_network.CHAIN_IDS.BSC]: BSC_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.MAINNET]: MAINNET_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL
};
exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP;
const ETHEREUM = 'ethereum';
exports.ETHEREUM = ETHEREUM;
const POLYGON = 'polygon';
exports.POLYGON = POLYGON;
const BSC = 'bsc';
exports.BSC = BSC;
const GOERLI = 'goerli';
exports.GOERLI = GOERLI;
const AVALANCHE = 'avalanche';
exports.AVALANCHE = AVALANCHE;
const OPTIMISM = 'optimism';
exports.OPTIMISM = OPTIMISM;
const ARBITRUM = 'arbitrum';
exports.ARBITRUM = ARBITRUM;
const SWAPS_CLIENT_ID = 'extension';
exports.SWAPS_CLIENT_ID = SWAPS_CLIENT_ID;
let TokenBucketPriority;
exports.TokenBucketPriority = TokenBucketPriority;
(function (TokenBucketPriority) {
  TokenBucketPriority["owned"] = "owned";
  TokenBucketPriority["top"] = "top";
})(TokenBucketPriority || (exports.TokenBucketPriority = TokenBucketPriority = {}));
let Slippage;
exports.Slippage = Slippage;
(function (Slippage) {
  Slippage[Slippage["default"] = 2] = "default";
  Slippage[Slippage["high"] = 3] = "high";
})(Slippage || (exports.Slippage = Slippage = {}));

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\swaps.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\time.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Ctime.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECOND = exports.MINUTE = exports.MILLISECOND = exports.HOUR = exports.DAY = void 0;
const MILLISECOND = 1;
exports.MILLISECOND = MILLISECOND;
const SECOND = MILLISECOND * 1000;
exports.SECOND = SECOND;
const MINUTE = SECOND * 60;
exports.MINUTE = MINUTE;
const HOUR = MINUTE * 60;
exports.HOUR = HOUR;
const DAY = HOUR * 24;
exports.DAY = DAY;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\time.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\tokens.js", {"@metamask/contract-metadata":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\contract-metadata\\index.js","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Ctokens.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOKEN_API_METASWAP_CODEFI_URL = exports.STATIC_MAINNET_TOKEN_LIST = exports.NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = exports.MAX_TOKEN_ALLOWANCE_AMOUNT = exports.LISTED_CONTRACT_ADDRESSES = exports.DECIMAL_REGEX = void 0;
var _contractMetadata = _interopRequireDefault(require("@metamask/contract-metadata"));
var _bignumber = _interopRequireDefault(require("bignumber.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * A normalized list of addresses exported as part of the contractMap in
 * `@metamask/contract-metadata`. Used primarily to validate if manually entered
 * contract addresses do not match one of our listed tokens
 */
const LISTED_CONTRACT_ADDRESSES = Object.keys(_contractMetadata.default).map(address => address.toLowerCase());

/**
 * @typedef {object} TokenDetails
 * @property {string} address - The address of the selected 'TOKEN' or
 *  'NFT' contract.
 * @property {string} [symbol] - The symbol of the token.
 * @property {number} [decimals] - The number of decimals of the selected
 *  'ERC20' asset.
 * @property {number} [tokenId] - The id of the selected 'NFT' asset.
 * @property {TokenStandardStrings} [standard] - The standard of the selected
 *  asset.
 * @property {boolean} [isERC721] - True when the asset is a ERC721 token.
 */
exports.LISTED_CONTRACT_ADDRESSES = LISTED_CONTRACT_ADDRESSES;
const STATIC_MAINNET_TOKEN_LIST = Object.keys(_contractMetadata.default).reduce((acc, base) => {
  const {
    logo,
    ...tokenMetadata
  } = _contractMetadata.default[base];
  return {
    ...acc,
    [base.toLowerCase()]: {
      ...tokenMetadata,
      address: base.toLowerCase(),
      iconUrl: `images/contract/${logo}`,
      aggregators: []
    }
  };
}, {});
exports.STATIC_MAINNET_TOKEN_LIST = STATIC_MAINNET_TOKEN_LIST;
const TOKEN_API_METASWAP_CODEFI_URL = 'https://token-api.metaswap.codefi.network/tokens/';
exports.TOKEN_API_METASWAP_CODEFI_URL = TOKEN_API_METASWAP_CODEFI_URL;
const MAX_TOKEN_ALLOWANCE_AMOUNT = new _bignumber.default(2).pow(256).minus(1).toString(10);
// number with optional decimal point using a comma or dot
exports.MAX_TOKEN_ALLOWANCE_AMOUNT = MAX_TOKEN_ALLOWANCE_AMOUNT;
const NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = /^[0-9]{1,}([,.][0-9]{1,})?$/u;
exports.NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX;
const DECIMAL_REGEX = /\.(\d*)/u;
exports.DECIMAL_REGEX = DECIMAL_REGEX;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\tokens.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cconstants%5Ctransaction.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionType = exports.TransactionStatus = exports.TransactionMetaMetricsEvent = exports.TransactionGroupStatus = exports.TransactionGroupCategory = exports.TransactionEnvelopeType = exports.TransactionApprovalAmountType = exports.TokenStandard = exports.SmartTransactionStatus = exports.IN_PROGRESS_TRANSACTION_STATUSES = exports.AssetType = void 0;
let TransactionType;
/**
 * In EIP-2718 typed transaction envelopes were specified, with the very first
 * typed envelope being 'legacy' and describing the shape of the base
 * transaction params that were hitherto the only transaction type sent on
 * Ethereum.
 */
exports.TransactionType = TransactionType;
(function (TransactionType) {
  TransactionType["cancel"] = "cancel";
  TransactionType["contractInteraction"] = "contractInteraction";
  TransactionType["deployContract"] = "contractDeployment";
  TransactionType["ethDecrypt"] = "eth_decrypt";
  TransactionType["ethGetEncryptionPublicKey"] = "eth_getEncryptionPublicKey";
  TransactionType["incoming"] = "incoming";
  TransactionType["personalSign"] = "personal_sign";
  TransactionType["retry"] = "retry";
  TransactionType["sign"] = "eth_sign";
  TransactionType["signTypedData"] = "eth_signTypedData";
  TransactionType["simpleSend"] = "simpleSend";
  TransactionType["smart"] = "smart";
  TransactionType["swap"] = "swap";
  TransactionType["swapApproval"] = "swapApproval";
  TransactionType["tokenMethodApprove"] = "approve";
  TransactionType["tokenMethodSafeTransferFrom"] = "safetransferfrom";
  TransactionType["tokenMethodTransfer"] = "transfer";
  TransactionType["tokenMethodTransferFrom"] = "transferfrom";
  TransactionType["tokenMethodSetApprovalForAll"] = "setapprovalforall";
})(TransactionType || (exports.TransactionType = TransactionType = {}));
let TransactionEnvelopeType;
/**
 * Transaction Status is a mix of Ethereum and MetaMask terminology, used internally
 * for transaction processing.
 */
exports.TransactionEnvelopeType = TransactionEnvelopeType;
(function (TransactionEnvelopeType) {
  TransactionEnvelopeType["legacy"] = "0x0";
  TransactionEnvelopeType["accessList"] = "0x1";
  TransactionEnvelopeType["feeMarket"] = "0x2";
})(TransactionEnvelopeType || (exports.TransactionEnvelopeType = TransactionEnvelopeType = {}));
let TransactionStatus;
/**
 * With this list we can detect if a transaction is still in progress.
 */
exports.TransactionStatus = TransactionStatus;
(function (TransactionStatus) {
  TransactionStatus["unapproved"] = "unapproved";
  TransactionStatus["approved"] = "approved";
  TransactionStatus["rejected"] = "rejected";
  TransactionStatus["signed"] = "signed";
  TransactionStatus["submitted"] = "submitted";
  TransactionStatus["failed"] = "failed";
  TransactionStatus["dropped"] = "dropped";
  TransactionStatus["confirmed"] = "confirmed";
  TransactionStatus["pending"] = "pending";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
const IN_PROGRESS_TRANSACTION_STATUSES = [TransactionStatus.unapproved, TransactionStatus.approved, TransactionStatus.signed, TransactionStatus.submitted, TransactionStatus.pending];

/**
 * Transaction Group Status is a MetaMask construct to track the status of groups
 * of transactions.
 */
exports.IN_PROGRESS_TRANSACTION_STATUSES = IN_PROGRESS_TRANSACTION_STATUSES;
let TransactionGroupStatus;
/**
 * Statuses that are specific to Smart Transactions.
 */
exports.TransactionGroupStatus = TransactionGroupStatus;
(function (TransactionGroupStatus) {
  TransactionGroupStatus["cancelled"] = "cancelled";
  TransactionGroupStatus["pending"] = "pending";
})(TransactionGroupStatus || (exports.TransactionGroupStatus = TransactionGroupStatus = {}));
let SmartTransactionStatus;
/**
 * Types that are specific to the transaction approval amount.
 */
exports.SmartTransactionStatus = SmartTransactionStatus;
(function (SmartTransactionStatus) {
  SmartTransactionStatus["cancelled"] = "cancelled";
  SmartTransactionStatus["pending"] = "pending";
  SmartTransactionStatus["success"] = "success";
})(SmartTransactionStatus || (exports.SmartTransactionStatus = SmartTransactionStatus = {}));
let TransactionApprovalAmountType;
/**
 * Transaction Group Category is a MetaMask construct to categorize the intent
 * of a group of transactions for purposes of displaying in the UI
 */
exports.TransactionApprovalAmountType = TransactionApprovalAmountType;
(function (TransactionApprovalAmountType) {
  TransactionApprovalAmountType["custom"] = "custom";
  TransactionApprovalAmountType["revoke"] = "revoke";
  TransactionApprovalAmountType["dappProposed"] = "dapp_proposed";
})(TransactionApprovalAmountType || (exports.TransactionApprovalAmountType = TransactionApprovalAmountType = {}));
let TransactionGroupCategory;
/**
 * An object representing parameters of a transaction to submit to the network
 */
exports.TransactionGroupCategory = TransactionGroupCategory;
(function (TransactionGroupCategory) {
  TransactionGroupCategory["approval"] = "approval";
  TransactionGroupCategory["interaction"] = "interaction";
  TransactionGroupCategory["receive"] = "receive";
  TransactionGroupCategory["send"] = "send";
  TransactionGroupCategory["signatureRequest"] = "signature-request";
  TransactionGroupCategory["swap"] = "swap";
})(TransactionGroupCategory || (exports.TransactionGroupCategory = TransactionGroupCategory = {}));
/**
 * We attach an object to transactions proposed by dapps to show the values
 * that the dapp suggested for gas fees. This is used to compare to what our
 * internal gas price logic would have the transaction priced at for metrics
 * with the aim of improving our suggestions as well as giving the user the
 * option to return to the defaults suggested by the dapp if they have edited
 * the gas fees on the confirmation screen.
 */
/**
 * An object representing a transaction, in whatever state it is in.
 */
/**
 * Defines the possible types
 */
let TransactionMetaMetricsEvent;
/**
 * The types of assets that a user can send
 *
 * @type {AssetTypes}
 */
exports.TransactionMetaMetricsEvent = TransactionMetaMetricsEvent;
(function (TransactionMetaMetricsEvent) {
  TransactionMetaMetricsEvent["added"] = "Transaction Added";
  TransactionMetaMetricsEvent["approved"] = "Transaction Approved";
  TransactionMetaMetricsEvent["finalized"] = "Transaction Finalized";
  TransactionMetaMetricsEvent["rejected"] = "Transaction Rejected";
  TransactionMetaMetricsEvent["submitted"] = "Transaction Submitted";
})(TransactionMetaMetricsEvent || (exports.TransactionMetaMetricsEvent = TransactionMetaMetricsEvent = {}));
let AssetType;
/**
 * Describes the standard which a token conforms to.
 */
exports.AssetType = AssetType;
(function (AssetType) {
  AssetType["native"] = "NATIVE";
  AssetType["token"] = "TOKEN";
  AssetType["NFT"] = "NFT";
  AssetType["unknown"] = "UNKNOWN";
})(AssetType || (exports.AssetType = AssetType = {}));
let TokenStandard;
exports.TokenStandard = TokenStandard;
(function (TokenStandard) {
  TokenStandard["ERC20"] = "ERC20";
  TokenStandard["ERC721"] = "ERC721";
  TokenStandard["ERC1155"] = "ERC1155";
  TokenStandard["none"] = "NONE";
})(TokenStandard || (exports.TokenStandard = TokenStandard = {}));

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\transaction.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\fetch-with-cache.js", {"../constants/time":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\time.ts","../modules/fetch-with-timeout":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\fetch-with-timeout.ts","./storage-helpers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\storage-helpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Clib%5Cfetch-with-cache.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _time = require("../constants/time");
var _fetchWithTimeout = _interopRequireDefault(require("../modules/fetch-with-timeout"));
var _storageHelpers = require("./storage-helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const fetchWithCache = async (url, fetchOptions = {}, {
  cacheRefreshTime = _time.MINUTE * 6,
  timeout = _time.SECOND * 30
} = {}) => {
  if (fetchOptions.body || fetchOptions.method && fetchOptions.method !== 'GET') {
    throw new Error('fetchWithCache only supports GET requests');
  }
  if (!(fetchOptions.headers instanceof window.Headers)) {
    fetchOptions.headers = new window.Headers(fetchOptions.headers);
  }
  if (fetchOptions.headers.has('Content-Type') && fetchOptions.headers.get('Content-Type') !== 'application/json') {
    throw new Error('fetchWithCache only supports JSON responses');
  }
  const currentTime = Date.now();
  const cacheKey = `cachedFetch:${url}`;
  const {
    cachedResponse,
    cachedTime
  } = (await (0, _storageHelpers.getStorageItem)(cacheKey)) || {};
  if (cachedResponse && currentTime - cachedTime < cacheRefreshTime) {
    return cachedResponse;
  }
  fetchOptions.headers.set('Content-Type', 'application/json');
  const fetchWithTimeout = (0, _fetchWithTimeout.default)(timeout);
  const response = await fetchWithTimeout(url, {
    referrerPolicy: 'no-referrer-when-downgrade',
    body: null,
    method: 'GET',
    mode: 'cors',
    ...fetchOptions
  });
  if (!response.ok) {
    throw new Error(`Fetch failed with status '${response.status}': '${response.statusText}'`);
  }
  const responseJson = await response.json();
  const cacheEntry = {
    cachedResponse: responseJson,
    cachedTime: currentTime
  };
  await (0, _storageHelpers.setStorageItem)(cacheKey, cacheEntry);
  return responseJson;
};
var _default = fetchWithCache;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\fetch-with-cache.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\metamask-controller-utils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Clib%5Cmetamask-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTokenValueParam = getTokenValueParam;
function getTokenValueParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args$_valu;
  return tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_valu = _tokenData$args._value) === null || _tokenData$args$_valu === void 0 ? void 0 : _tokenData$args$_valu.toString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\metamask-controller-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\storage-helpers.js", {"localforage":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\localforage\\dist\\localforage.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Clib%5Cstorage-helpers.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStorageItem = getStorageItem;
exports.setStorageItem = setStorageItem;
var _localforage = _interopRequireDefault(require("localforage"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function getStorageItem(key) {
  try {
    const serializedData = await _localforage.default.getItem(key);
    if (serializedData === null) {
      return undefined;
    }
    return JSON.parse(serializedData);
  } catch (err) {
    return undefined;
  }
}
async function setStorageItem(key, value) {
  try {
    const serializedData = JSON.stringify(value);
    await _localforage.default.setItem(key, serializedData);
  } catch (err) {
    console.warn(err);
  }
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\storage-helpers.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\swaps-utils.js", {"../../app/scripts/lib/util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\app\\scripts\\lib\\util.ts","../constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","../constants/swaps":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\swaps.ts","../constants/time":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\time.ts","../modules/conversion.utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\conversion.utils.ts","../modules/hexstring-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\hexstring-utils.ts","../modules/string-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\string-utils.ts","./fetch-with-cache":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\fetch-with-cache.js","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","loglevel":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Clib%5Cswaps-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QUOTE_VALIDATORS = void 0;
exports.addHexPrefixToObjectValues = addHexPrefixToObjectValues;
exports.calcTokenValue = calcTokenValue;
exports.constructTxParams = constructTxParams;
exports.fetchTradesInfo = fetchTradesInfo;
exports.validHex = exports.truthyString = exports.truthyDigitString = exports.shouldEnableDirectWrapping = exports.getBaseApi = void 0;
exports.validateData = validateData;
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _loglevel = _interopRequireDefault(require("loglevel"));
var _network = require("../constants/network");
var _swaps = require("../constants/swaps");
var _time = require("../constants/time");
var _hexstringUtils = require("../modules/hexstring-utils");
var _stringUtils = require("../modules/string-utils");
var _util = require("../../app/scripts/lib/util");
var _conversion = require("../modules/conversion.utils");
var _fetchWithCache = _interopRequireDefault(require("./fetch-with-cache"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TEST_CHAIN_IDS = [_network.CHAIN_IDS.GOERLI, _network.CHAIN_IDS.LOCALHOST];
const clientIdHeader = {
  'X-Client-Id': _swaps.SWAPS_CLIENT_ID
};
const validHex = string => Boolean(string === null || string === void 0 ? void 0 : string.match(/^0x[a-f0-9]+$/u));
exports.validHex = validHex;
const truthyString = string => Boolean(string === null || string === void 0 ? void 0 : string.length);
exports.truthyString = truthyString;
const truthyDigitString = string => truthyString(string) && Boolean(string.match(/^\d+$/u));
exports.truthyDigitString = truthyDigitString;
function validateData(validators, object, urlUsed, logError = true) {
  return validators.every(({
    property,
    type,
    validator
  }) => {
    const types = type.split('|');
    const valid = types.some(_type => typeof object[property] === _type) && (!validator || validator(object[property]));
    if (!valid && logError) {
      _loglevel.default.error(`response to GET ${urlUsed} invalid for property ${property}; value was:`, object[property], '| type was: ', typeof object[property]);
    }
    return valid;
  });
}
const QUOTE_VALIDATORS = [{
  property: 'trade',
  type: 'object',
  validator: trade => trade && validHex(trade.data) && (0, _hexstringUtils.isValidHexAddress)(trade.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(trade.from, {
    allowNonPrefixed: false
  }) && truthyString(trade.value)
}, {
  property: 'approvalNeeded',
  type: 'object',
  validator: approvalTx => approvalTx === null || approvalTx && validHex(approvalTx.data) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.from, {
    allowNonPrefixed: false
  })
}, {
  property: 'sourceAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'destinationAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'sourceToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'destinationToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'aggregator',
  type: 'string',
  validator: truthyString
}, {
  property: 'aggType',
  type: 'string',
  validator: truthyString
}, {
  property: 'error',
  type: 'object',
  validator: error => error === null || typeof error === 'object'
}, {
  property: 'averageGas',
  type: 'number'
}, {
  property: 'maxGas',
  type: 'number'
}, {
  property: 'gasEstimate',
  type: 'number|undefined',
  validator: gasEstimate => gasEstimate === undefined || gasEstimate > 0
}, {
  property: 'fee',
  type: 'number'
}];

/**
 * @param {string} type - Type of an API call, e.g. "tokens"
 * @param {string} chainId
 * @returns string
 */
exports.QUOTE_VALIDATORS = QUOTE_VALIDATORS;
const getBaseUrlForNewSwapsApi = (type, chainId) => {
  const useDevApis = false;
  const v2ApiBaseUrl = useDevApis ? _swaps.SWAPS_DEV_API_V2_BASE_URL : _swaps.SWAPS_API_V2_BASE_URL;
  const gasApiBaseUrl = useDevApis ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
  const noNetworkSpecificTypes = ['refreshTime']; // These types don't need network info in the URL.
  if (noNetworkSpecificTypes.includes(type)) {
    return v2ApiBaseUrl;
  }
  const chainIdDecimal = chainId && parseInt(chainId, 16);
  const gasApiTypes = ['gasPrices'];
  if (gasApiTypes.includes(type)) {
    return `${gasApiBaseUrl}/networks/${chainIdDecimal}`; // Gas calculations are in its own repo.
  }

  return `${v2ApiBaseUrl}/networks/${chainIdDecimal}`;
};
const getBaseApi = function (type, chainId) {
  const _chainId = TEST_CHAIN_IDS.includes(chainId) ? _network.CHAIN_IDS.MAINNET : chainId;
  const baseUrl = getBaseUrlForNewSwapsApi(type, _chainId);
  if (!baseUrl) {
    throw new Error(`Swaps API calls are disabled for chainId: ${_chainId}`);
  }
  switch (type) {
    case 'trade':
      return `${baseUrl}/trades?`;
    case 'tokens':
      return `${baseUrl}/tokens`;
    case 'token':
      return `${baseUrl}/token`;
    case 'topAssets':
      return `${baseUrl}/topAssets`;
    case 'aggregatorMetadata':
      return `${baseUrl}/aggregatorMetadata`;
    case 'gasPrices':
      return `${baseUrl}/gasPrices`;
    case 'network':
      return baseUrl;
    default:
      throw new Error('getBaseApi requires an api call type');
  }
};
exports.getBaseApi = getBaseApi;
function calcTokenValue(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).times(multiplier);
}
const shouldEnableDirectWrapping = (chainId, sourceToken, destinationToken) => {
  var _SWAPS_CHAINID_DEFAUL;
  if (!sourceToken || !destinationToken) {
    return false;
  }
  const wrappedToken = _swaps.SWAPS_WRAPPED_TOKENS_ADDRESSES[chainId];
  const nativeToken = (_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address;
  return (0, _stringUtils.isEqualCaseInsensitive)(sourceToken, wrappedToken) && (0, _stringUtils.isEqualCaseInsensitive)(destinationToken, nativeToken) || (0, _stringUtils.isEqualCaseInsensitive)(sourceToken, nativeToken) && (0, _stringUtils.isEqualCaseInsensitive)(destinationToken, wrappedToken);
};

/**
 * Given and object where all values are strings, returns the same object with all values
 * now prefixed with '0x'
 *
 * @param obj
 */
exports.shouldEnableDirectWrapping = shouldEnableDirectWrapping;
function addHexPrefixToObjectValues(obj) {
  return Object.keys(obj).reduce((newObj, key) => {
    return {
      ...newObj,
      [key]: (0, _util.addHexPrefix)(obj[key])
    };
  }, {});
}

/**
 * Given the standard set of information about a transaction, returns a transaction properly formatted for
 * publishing via JSON RPC and web3
 *
 * @param {object} options
 * @param {boolean} [options.sendToken] - Indicates whether or not the transaciton is a token transaction
 * @param {string} options.data - A hex string containing the data to include in the transaction
 * @param {string} options.to - A hex address of the tx recipient address
 * @param options.amount
 * @param {string} options.from - A hex address of the tx sender address
 * @param {string} options.gas - A hex representation of the gas value for the transaction
 * @param {string} options.gasPrice - A hex representation of the gas price for the transaction
 * @returns {object} An object ready for submission to the blockchain, with all values appropriately hex prefixed
 */
function constructTxParams({
  sendToken,
  data,
  to,
  amount,
  from,
  gas,
  gasPrice
}) {
  const txParams = {
    data,
    from,
    value: '0',
    gas,
    gasPrice
  };
  if (!sendToken) {
    txParams.value = amount;
    txParams.to = to;
  }
  return addHexPrefixToObjectValues(txParams);
}
async function fetchTradesInfo({
  slippage,
  sourceToken,
  sourceDecimals,
  destinationToken,
  value,
  fromAddress,
  exchangeList
}, {
  chainId
}) {
  const urlParams = {
    destinationToken,
    sourceToken,
    sourceAmount: calcTokenValue(value, sourceDecimals).toString(10),
    slippage,
    timeout: _time.SECOND * 10,
    walletAddress: fromAddress
  };
  if (exchangeList) {
    urlParams.exchangeList = exchangeList;
  }
  if (shouldEnableDirectWrapping(chainId, sourceToken, destinationToken)) {
    urlParams.enableDirectWrapping = true;
  }
  const queryString = new URLSearchParams(urlParams).toString();
  const tradeURL = `${getBaseApi('trade', chainId)}${queryString}`;
  const tradesResponse = await (0, _fetchWithCache.default)(tradeURL, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: 0,
    timeout: _time.SECOND * 15
  });
  const newQuotes = tradesResponse.reduce((aggIdTradeMap, quote) => {
    if (quote.trade && !quote.error && validateData(QUOTE_VALIDATORS, quote, tradeURL)) {
      const constructedTrade = constructTxParams({
        to: quote.trade.to,
        from: quote.trade.from,
        data: quote.trade.data,
        amount: (0, _conversion.decimalToHex)(quote.trade.value),
        gas: (0, _conversion.decimalToHex)(quote.maxGas)
      });
      let {
        approvalNeeded
      } = quote;
      if (approvalNeeded) {
        approvalNeeded = constructTxParams({
          ...approvalNeeded
        });
      }
      return {
        ...aggIdTradeMap,
        [quote.aggregator]: {
          ...quote,
          slippage,
          trade: constructedTrade,
          approvalNeeded
        }
      };
    }
    return aggIdTradeMap;
  }, {});
  return newQuotes;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\swaps-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\token-util.ts", {"@ethersproject/contracts":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethersproject\\contracts\\lib\\index.js","@ethersproject/providers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethersproject\\providers\\lib\\index.js","@metamask/metamask-eth-abis":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Clib%5Ctoken-util.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchTokenBalance = fetchTokenBalance;
exports.getTokenIdParam = getTokenIdParam;
var _metamaskEthAbis = require("@metamask/metamask-eth-abis");
var _contracts = require("@ethersproject/contracts");
var _providers = require("@ethersproject/providers");
/**
 * Gets the '_value' parameter of the given token transaction data
 * (i.e function call) per the Human Standard Token ABI, if present.
 *
 * @param {object} tokenData - ethers Interface token data.
 * @returns {string | undefined} A decimal string value.
 */
/**
 * Gets either the '_tokenId' parameter or the 'id' param of the passed token transaction data.,
 * These are the parsed tokenId values returned by `parseStandardTokenTransactionData` as defined
 * in the ERC721 and ERC1155 ABIs from metamask-eth-abis (https://github.com/MetaMask/metamask-eth-abis/tree/main/src/abis)
 *
 * @param tokenData - ethers Interface token data.
 * @returns A decimal string value.
 */
function getTokenIdParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args$_toke, _tokenData$args2, _tokenData$args2$id;
  return (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_toke = _tokenData$args._tokenId) === null || _tokenData$args$_toke === void 0 ? void 0 : _tokenData$args$_toke.toString()) ?? (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args2 = tokenData.args) === null || _tokenData$args2 === void 0 ? void 0 : (_tokenData$args2$id = _tokenData$args2.id) === null || _tokenData$args2$id === void 0 ? void 0 : _tokenData$args2$id.toString());
}
async function fetchTokenBalance(address, userAddress, provider) {
  const ethersProvider = new _providers.Web3Provider(provider);
  const tokenContract = new _contracts.Contract(address, _metamaskEthAbis.abiERC20, ethersProvider);
  const tokenBalancePromise = tokenContract ? tokenContract.balanceOf(userAddress) : Promise.resolve();
  return await tokenBalancePromise;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\token-util.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", {"../constants/common":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\common.ts","../constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","../modules/Numeric":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\Numeric.ts","../modules/swaps.utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\swaps.utils.js","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Clib%5Ctransactions-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = exports.TRANSACTION_ENVELOPE_TYPE_NAMES = exports.TOKEN_TRANSFER_LOG_TOPIC_HASH = exports.TEN_SECONDS_IN_MILLISECONDS = void 0;
exports.calcGasTotal = calcGasTotal;
exports.calcTokenAmount = calcTokenAmount;
exports.getSwapsTokensReceivedFromTxMeta = getSwapsTokensReceivedFromTxMeta;
exports.toPrecisionWithoutTrailingZeros = toPrecisionWithoutTrailingZeros;
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _common = require("../constants/common");
var _transaction = require("../constants/transaction");
var _Numeric = require("../modules/Numeric");
var _swaps = require("../modules/swaps.utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TOKEN_TRANSFER_LOG_TOPIC_HASH = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
exports.TOKEN_TRANSFER_LOG_TOPIC_HASH = TOKEN_TRANSFER_LOG_TOPIC_HASH;
const TRANSACTION_NO_CONTRACT_ERROR_KEY = 'transactionErrorNoContract';
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = TRANSACTION_NO_CONTRACT_ERROR_KEY;
const TEN_SECONDS_IN_MILLISECONDS = 10_000;
exports.TEN_SECONDS_IN_MILLISECONDS = TEN_SECONDS_IN_MILLISECONDS;
function calcGasTotal(gasLimit = '0', gasPrice = '0') {
  return new _Numeric.Numeric(gasLimit, 16).times(new _Numeric.Numeric(gasPrice, 16)).toString();
}

/**
 * Given a number and specified precision, returns that number in base 10 with a maximum of precision
 * significant digits, but without any trailing zeros after the decimal point To be used when wishing
 * to display only as much digits to the user as necessary
 *
 * @param {string | number | BigNumber} n - The number to format
 * @param {number} precision - The maximum number of significant digits in the return value
 * @returns {string} The number in decimal form, with <= precision significant digits and no decimal trailing zeros
 */
function toPrecisionWithoutTrailingZeros(n, precision) {
  return new _bignumber.default(n).toPrecision(precision).replace(/(\.[0-9]*[1-9])0*|(\.0*)/u, '$1');
}
function calcTokenAmount(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).div(multiplier);
}
function getSwapsTokensReceivedFromTxMeta(tokenSymbol, txMeta, tokenAddress, accountAddress, tokenDecimals, approvalTxMeta, chainId) {
  var _txMeta$txReceipt;
  const txReceipt = txMeta === null || txMeta === void 0 ? void 0 : txMeta.txReceipt;
  const networkAndAccountSupports1559 = (txMeta === null || txMeta === void 0 ? void 0 : (_txMeta$txReceipt = txMeta.txReceipt) === null || _txMeta$txReceipt === void 0 ? void 0 : _txMeta$txReceipt.type) === _transaction.TransactionEnvelopeType.feeMarket;
  if ((0, _swaps.isSwapsDefaultTokenSymbol)(tokenSymbol, chainId)) {
    if (!txReceipt || !txMeta || !txMeta.postTxBalance || !txMeta.preTxBalance) {
      return null;
    }
    if (txMeta.swapMetaData && txMeta.preTxBalance === txMeta.postTxBalance) {
      // If preTxBalance and postTxBalance are equal, postTxBalance hasn't been updated on time
      // because of the RPC provider delay, so we return an estimated receiving amount instead.
      return txMeta.swapMetaData.token_to_amount;
    }
    let approvalTxGasCost = new _Numeric.Numeric('0x0', 16);
    if (approvalTxMeta && approvalTxMeta.txReceipt) {
      approvalTxGasCost = new _Numeric.Numeric(calcGasTotal(approvalTxMeta.txReceipt.gasUsed, networkAndAccountSupports1559 ? approvalTxMeta.txReceipt.effectiveGasPrice // Base fee + priority fee.
      : approvalTxMeta.txParams.gasPrice), 16);
    }
    const gasCost = calcGasTotal(txReceipt.gasUsed, networkAndAccountSupports1559 ? txReceipt.effectiveGasPrice : txMeta.txParams.gasPrice);
    const totalGasCost = new _Numeric.Numeric(gasCost, 16).add(approvalTxGasCost);
    const preTxBalanceLessGasCost = new _Numeric.Numeric(txMeta.preTxBalance, 16).minus(totalGasCost);
    const ethReceived = new _Numeric.Numeric(txMeta.postTxBalance, 16, _common.EtherDenomination.WEI).minus(preTxBalanceLessGasCost).toDenomination(_common.EtherDenomination.ETH).toBase(10).round(6);
    return ethReceived.toString();
  }
  const txReceiptLogs = txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.logs;
  if (txReceiptLogs && (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) !== '0x0') {
    const tokenTransferLog = txReceiptLogs.find(txReceiptLog => {
      const isTokenTransfer = txReceiptLog.topics && txReceiptLog.topics[0] === TOKEN_TRANSFER_LOG_TOPIC_HASH;
      const isTransferFromGivenToken = txReceiptLog.address === tokenAddress;
      const isTransferFromGivenAddress = txReceiptLog.topics && txReceiptLog.topics[2] && txReceiptLog.topics[2].match(accountAddress.slice(2));
      return isTokenTransfer && isTransferFromGivenToken && isTransferFromGivenAddress;
    });
    return tokenTransferLog ? toPrecisionWithoutTrailingZeros(calcTokenAmount(tokenTransferLog.data, tokenDecimals).toString(10), 6) : '';
  }
  return null;
}
const TRANSACTION_ENVELOPE_TYPE_NAMES = {
  FEE_MARKET: 'fee-market',
  LEGACY: 'legacy'
};
exports.TRANSACTION_ENVELOPE_TYPE_NAMES = TRANSACTION_ENVELOPE_TYPE_NAMES;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\transactions-controller-utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\Numeric.ts", {"../constants/common":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\common.ts","./hexstring-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\hexstring-utils.ts","@metamask/utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","bn.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5CNumeric.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Numeric = void 0;
var _bignumber = require("bignumber.js");
var _bn = _interopRequireDefault(require("bn.js"));
var _utils = require("@metamask/utils");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("../constants/common");
var _hexstringUtils = require("./hexstring-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * All variations of isHexString from our own utilities and etherumjs-utils
 * return false for a '-' prefixed hex string. This utility method strips the
 * possible '-' from the string before testing its validity so that negative
 * hex values can be properly handled.
 *
 * @param value - The string to check
 * @returns true if the value is a hex string (negative or otherwise)
 */
function isHexStringOrNegatedHexString(value) {
  return (0, _utils.isHexString)(value.replace('-', '')) || (0, _utils.isHexString)(value);
}

/**
 * BigNumber supports hex strings with '.' (aka decimals) in the string.
 * No version of isHexString returs true if the string contains a decimal so
 * this method is used to check if both parts of the string split by the
 * decimal are hex strings. If so we can feed this value into BigNumber to get
 * a valid Numeric.
 *
 * @param value - The string to check
 * @returns true if the string is a hexadecimal split by '.'
 */
function isDecimalHex(value) {
  const parts = value.split('.');
  if (parts.length === 1) {
    return false;
  }
  return parts.every(part => isHexStringOrNegatedHexString(part));
}

/**
 * Converts a hexadecimal in string or number format to a BigNumber.
 * Note that in many places in our codebase we call 'addHexPrefix' on a negated
 * hexadecimal string resulting in '0x-a' which will fail checks for
 * isHexString. Sometimes we DO not add the 0x so we have to check for '-a'
 * as well.
 *
 * @param value - hexadecimal value in string or number format.
 * @returns A BigNumber representation of the value
 */
function hexadecimalToBigNumber(value) {
  const stringified = typeof value === 'number' ? `${value}` : value;
  const isNegative = (0, _hexstringUtils.stripHexPrefix)(stringified)[0] === '-';
  const valueWithoutNegation = stringified.replace('-', '');
  const valueAsBigNumber = new _bignumber.BigNumber((0, _hexstringUtils.stripHexPrefix)(valueWithoutNegation), 16);
  return isNegative ? valueAsBigNumber.negated() : valueAsBigNumber;
}

/**
 * Converts a decimal in string or number format to a BigNumber.
 *
 * @param value - decimal value in string or number format.
 * @returns A BigNumber representation of the value
 */
function decimalToBigNumber(value) {
  return new _bignumber.BigNumber(String(value), 10);
}

/**
 * This method is used to safely convert a string type value to a BigNumber.
 * The only valid strings for this method are those that are either hexadecimal
 * numeric values OR numeric strings that can be converted to BigNumbers. It is
 * impossible to tell the difference between a hex value of 100000 vs a decimal
 * value of 100000 so a second parameter indicating the numeric base of the
 * string value must be provided.
 *
 * @param value - A hexadecimal or decimal string
 * @param numericBase - Either 16 for a hexadeciaml or 10 for a decimal
 * @returns A BigNumber representation of the value
 */
function stringToBigNumber(value, numericBase) {
  if (typeof value !== 'string') {
    throw new Error(`Value of type ${typeof value} passed to stringToBigNumber`);
  }
  if (numericBase === 16 && (isHexStringOrNegatedHexString(value) || isDecimalHex(value))) {
    return hexadecimalToBigNumber(value);
  } else if (numericBase === 10 && (
  // check if we have a finite integer or float
  isFinite(parseInt(value, 10)) || isFinite(parseFloat(value)))) {
    return decimalToBigNumber(value);
  }
  throw new Error(`String provided to stringToBigNumber is not a hexadecimal or decimal string: ${value}, ${numericBase}`);
}

/**
 * This method will convert a hexadecimal or deciaml number into a BigNumber.
 * The second parameter must be supplied and determines whether to treat the
 * value as a hexadecimal or decimal value.
 *
 * @param value - hexadecimal or decimal number[]
 * @param numericBase - 10 for decimal, 16 for hexadecimal
 * @returns BigNumber representation of the value
 */
function numberToBigNumber(value, numericBase) {
  if (typeof value !== 'number') {
    throw new Error(`Value of type ${typeof value} passed to numberToBigNumber`);
  }
  if (numericBase === 16 && (0, _utils.isHexString)(`${value}`)) {
    return new _bignumber.BigNumber(`${value}`, 16);
  }
  return new _bignumber.BigNumber(value, 10);
}

/**
 * Method to convert a BN to a BigNumber
 *
 * @param value - A BN representation of a value
 * @returns A BigNumber representation of the BN's underlying value
 */
function bnToBigNumber(value) {
  if (value instanceof _bn.default === false) {
    throw new Error(`value passed to bnToBigNumber is not a BN. Received type ${typeof value}`);
  }
  return new _bignumber.BigNumber(value.toString(16), 16);
}

/**
 * Converts a value of the supported types (string, number, BN) to a BigNumber.
 *
 * @param value - The value to convert to a BigNumber
 * @param numericBase - The numeric base of the underlying value
 * @returns A BigNumber representation of the value
 */
function valueToBigNumber(value, numericBase) {
  if (typeof value === 'string') {
    return stringToBigNumber(value, numericBase);
  } else if (typeof value === 'number' && isNaN(value) === false) {
    return numberToBigNumber(value, numericBase);
  }
  throw new Error(`Value: ${value} is not a string, number, BigNumber or BN. Type is: ${typeof value}.`);
}

// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new _bignumber.BigNumber('1000000000000000000');
const BIG_NUMBER_GWEI_MULTIPLIER = new _bignumber.BigNumber('1000000000');
const BIG_NUMBER_ETH_MULTIPLIER = new _bignumber.BigNumber('1');
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).round(),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).round(9),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).round(9)
};

/**
 * Gets the value in ETH of the numeric supplied, used in this file only to
 * convert to ETH prior to converting to another denomination. The following
 * quirks were programmed into this method to replicate behavior of the
 * predecessor to Numeric, which was 'conversionUtil'. If a denomination is
 * not supplied, and toDenomination is called, then we assume the denomination
 * was originally ETH, otherwise we convert it to ETH.
 *
 * @param numeric
 * @returns value in ETH
 */
function getValueInETH(numeric) {
  if (numeric.denomination === _common.EtherDenomination.ETH || typeof numeric.denomination === 'undefined') {
    return numeric.value;
  }
  return toNormalizedDenomination[numeric.denomination](numeric.value);
}

/**
 * When applying operands to Numerics that have a specified Denomination then
 * we should first convert the provided inputNumeric to the same Denomination
 * as the baseNumeric. There are cases where this doesn't apply:
 *
 * 1. If the denominations are already the same. No conversion is necessary.
 * 2. If the inputNumeric does not have a denomination set. We assume in this
 * case that the value is already in the appropriate denomination.
 *
 * @param baseNumeric
 * @param inputNumeric
 * @returns
 */
function alignOperandDenominations(baseNumeric, inputNumeric) {
  if (typeof inputNumeric.denomination !== 'undefined' && baseNumeric.denomination !== inputNumeric.denomination) {
    return inputNumeric.toDenomination(baseNumeric.denomination);
  }
  return inputNumeric;
}

/**
 * Numeric is a class whose methods will always return a new, not mutated,
 * value. This allows for chaining of non-terminating methods. Previously we
 * had near a hundred helper methods that composed one-another, making tracking
 * through the chain near impossible. This API is designed such that no helper
 * methods should be needed. Take the case of hexWEIToDecGWEI, a helper method
 * for taking a hex string representing a value in WEI and converting that to a
 * decimal of GWEI. Prior to this class the method would call into our root
 * level 'conversionUtil' which was the proverbial kitchen sink doing
 * everything from denomination conversion, currency conversion (with provided
 * conversionRate prop) and more. The same opeartion can now be expressed as:
 * new Numeric(hexString, 16, EtherDenomination.WEI)
 * .toDenomination(EtherDenomination.GWEI)
 * .toBase(10)
 * .toString();
 * This has the benefit of being fairly transparent as you can read each step
 * in the chain and have a good sense of what is being done. It also is highly
 * composable so that we shouldn't need tons of helper methods for shortcuts.
 */
class Numeric {
  /**
   * The underlying value of the Numeric, always in BigNumber form
   */

  /**
   * The numeric base for this Numeric, either 10 for decimal or 16 for Hex
   */

  /**
   * The current denomination, if any. The only supported denominations are
   * ETH, GWEI, WEI.
   */

  constructor(value, base, denomination) {
    _defineProperty(this, "value", void 0);
    _defineProperty(this, "base", void 0);
    _defineProperty(this, "denomination", void 0);
    this.base = base;
    this.denomination = denomination;
    if (value instanceof _bignumber.BigNumber) {
      this.value = value;
    } else if (value instanceof _bn.default) {
      this.value = bnToBigNumber(value);
    } else if ((0, _utils.isNullOrUndefined)(value) || typeof value === 'number' && isNaN(value) || typeof value === 'string' && value === '') {
      // There are parts of the codebase that call this method without a value,
      // or with a 'NaN' (which is probably a bug somewhere in our tests?).
      // Over time of converting to TypeScript we will eradicate those, but the
      // helper methods that those instances employ would default the value to
      // 0. This block keeps that intact.
      this.value = new _bignumber.BigNumber('0', 10);
      this.base = 10;
    } else if (base) {
      this.value = valueToBigNumber(value, base);
    } else {
      throw new Error(`You must specify the base of the provided number if the value is not already a BigNumber`);
    }
  }

  /**
   * This is a tool used internally to check if a value is already a Numeric
   * and return it if it is, otherwise it uses the other provided arguments to
   * create a new Numeric.
   *
   * @param value - The value of the Numeric
   * @param base - Either undefined, 10 for decimal or 16 for hexadecimal
   * @param denomination - The Ether denomination to set, if any
   */
  static from(value, base, denomination) {
    if (value instanceof Numeric) {
      if (base || denomination) {
        throw new Error(`Numeric.from was called with a value (${value.toString()}) that is already a Numeric but a base and/or denomination was provided. Only supply base or denomination when creating a new Numeric`);
      }
      return value;
    }
    return new Numeric(value, base, denomination);
  }

  /** Conversions */

  /**
   * Returns a new Numeric with the base value changed to the provided base,
   * or the original Numeric if the base provided is the same as the current
   * base. No computation or conversion happens here but rather the result of
   * toString will be changed depending on the value of this.base when that
   * method is invoked.
   *
   * @param base - The numeric base to change the Numeric to, either 10 or 16
   * @returns A new Numeric with the base updated
   */
  toBase(base) {
    if (this.base !== base) {
      return new Numeric(this.value, base, this.denomination);
    }
    return this;
  }

  /**
   * Converts the value to the specified denomination. The following quirks of
   * the predecessor to Numeric, 'conversionUtil', were programmed into this
   * method:
   * 1. You may supply a denomination that is undefined, which will result in
   * nothing happening. Coincidently this is also useful due to the nature of
   * chaining operations on Numeric. You may pass an undefined value in this
   * method without breaking the chain to conditionally apply a operator.
   * 2. If the numeric that .toDenomination is called on does not have a
   * denomination set, that is it was constructed without the third parameter,
   * then it is assumed to be in ETH. Otherwise we convert it to ETH prior to
   * attempting to convert it to another denomination because all of the
   * toSpecifiedDenomination methods assume a value in ETH is passed.
   *
   * @param denomination - The denomination to convert to
   * @returns A new numeric with the same base as the previous, but the
   * value and denomination changed accordingly
   */
  toDenomination(denomination) {
    if (denomination && this.denomination !== denomination) {
      const result = new Numeric(toSpecifiedDenomination[denomination](getValueInETH(this)), this.base, denomination);
      return result;
    }
    return this;
  }

  /**
   * Replicates a method of BigNumber that is not in the version of BigNumber
   * that we use currently. Essentially shifting the decimal point backwards by
   * an amount equal to the positive number supplied to the decimals operator.
   * For example, calling shiftedBy(10) on the value 10000000000 will result in
   * a value of 1.0000000000. If passing a negative number, then the decimal
   * position will move forward. 1.0000000000 shiftedBy(-10) yields 10000000000
   *
   * @param decimals - The number of decimal places to move. Positive moves
   * decimal backwards, creating a smaller number. Negative values move the
   * decimal forwards, creating a larger number.
   * @returns A new numeric with the same base and denomination as the current
   * but with a new value.
   */
  shiftedBy(decimals) {
    const powerOf = new Numeric(Math.pow(10, decimals), 10);
    return this.divide(powerOf);
  }

  /**
   * Applies a conversion rate to the Numeric. If rate is undefined returns the
   * same instance that was operated on. Allowing an undefined value makes
   * chaining this operator feasible with undefined values from the user or
   * state without manipulating the number. For example:
   *
   * new Numeric(5, 10)
   * .applyConversionRate(possiblyUndefinedRate)
   * .toBase(16)
   * .toString();
   *
   * Will return a valid result as long as possiblyUndefinedRate is undefined,
   * a BigNumber or a number. In some areas of the codebase we check to see if
   * the target currency is different from the current currency before applying
   * a conversionRate. This functionality is not built into Numeric and will
   * require breaking the chain before calling this method:
   * let value = new Numeric(5, 10);
   *
   * if (fromCurrency !== toCurrency) {
   * value = value.applyConversionRate(possiblyUndefinedRate);
   * }
   *
   * return value.toBase(16).toString();
   *
   * @param rate - The multiplier to apply
   * @param invert - if true, inverts the rate
   * @returns New Numeric value with conversion rate applied.
   */
  applyConversionRate(rate, invert) {
    if (typeof rate === 'undefined') {
      return this;
    }
    let conversionRate = new Numeric(rate, 10);
    if (invert) {
      conversionRate = new Numeric(new _bignumber.BigNumber(1.0)).divide(conversionRate);
    }
    return this.times(conversionRate);
  }
  round(numberOfDecimals, roundingMode = _bignumber.BigNumber.ROUND_HALF_DOWN) {
    if (typeof numberOfDecimals === 'number') {
      return new Numeric(this.value.round(numberOfDecimals, roundingMode), this.base, this.denomination);
    }
    return this;
  }

  /**
   * TODO: make it possible to add ETH + GWEI value. So if you have
   * Numeric 1 with denomination ETH and Numeric 2 with Denomination WEI,
   * first convert Numeric 2 to ETH then add the amount to Numeric 1.
   *
   * @param value
   * @param base
   * @param denomination
   */
  add(value, base, denomination) {
    const numeric = Numeric.from(value, base, denomination);
    return new Numeric(this.value.add(alignOperandDenominations(this, numeric).value), this.base, this.denomination);
  }

  /**
   * TODO: make it possible to subtract ETH - GWEI value. So if you have
   * Numeric 1 with denomination ETH and Numeric 2 with Denomination WEI,
   * first convert Numeric 2 to ETH then subtract the amount from Numeric 1.
   *
   * @param value
   * @param base
   * @param denomination
   */
  minus(value, base, denomination) {
    const numeric = Numeric.from(value, base, denomination);
    return new Numeric(this.value.minus(alignOperandDenominations(this, numeric).value), this.base, this.denomination);
  }
  times(multiplier, base, denomination) {
    const multiplierNumeric = Numeric.from(multiplier, base, denomination);
    return new Numeric(this.value.times(alignOperandDenominations(this, multiplierNumeric).value), this.base, this.denomination);
  }

  /**
   * Divides the Numeric by another supplied Numeric, carrying over the base
   * and denomination from the current Numeric.
   *
   * @param divisor - The Numeric to divide this Numeric by
   * @param base
   * @param denomination
   * @returns A new Numeric that contains the result of the division
   */
  divide(divisor, base, denomination) {
    return new Numeric(this.value.div(alignOperandDenominations(this, Numeric.from(divisor, base, denomination)).value), this.base, this.denomination);
  }
  greaterThan(comparator, base, denomination) {
    return this.value.greaterThan(Numeric.from(comparator, base, denomination).value);
  }
  greaterThanOrEqualTo(comparator, base, denomination) {
    return this.value.greaterThanOrEqualTo(Numeric.from(comparator, base, denomination).value);
  }
  lessThan(comparator, base, denomination) {
    return this.value.lessThan(Numeric.from(comparator, base, denomination).value);
  }
  lessThanOrEqualTo(comparator, base, denomination) {
    return this.value.lessThanOrEqualTo(Numeric.from(comparator, base, denomination).value);
  }
  isNegative() {
    return this.value.isNegative();
  }
  isPositive() {
    return this.isNegative() === false;
  }

  /**
   * Get a base 16 hexadecimal string representation of the Numeric that is
   * 0x prefixed. This operation bypasses the currently set base of the
   * Numeric.
   *
   * @returns 0x prefixed hexstring.
   */
  toPrefixedHexString() {
    return (0, _ethereumjsUtil.addHexPrefix)(this.value.toString(16));
  }

  /**
   * Gets the string representation of the Numeric, using the current value of
   * this.base to determine if it should be a decimal or hexadecimal string.
   *
   * @returns the string representation of the Numeric
   */
  toString() {
    return this.value.toString(this.base);
  }

  /**
   * Returns a fixed-point decimal string representation of the Numeric
   *
   * @param decimals - the amount of decimal precision to use when rounding
   * @returns A fixed point decimal string represenation of the Numeric
   */
  toFixed(decimals) {
    return this.value.toFixed(decimals);
  }

  /**
   * Converts the value to a JavaScript Number, with all of the inaccuracy that
   * could come with that.
   *
   * @returns The value as a JS Number
   */
  toNumber() {
    return this.value.toNumber();
  }
}
exports.Numeric = Numeric;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\Numeric.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\browser-runtime.utils.js", {"loglevel":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js","webextension-polyfill":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cbrowser-runtime.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkForLastError = checkForLastError;
exports.checkForLastErrorAndLog = checkForLastErrorAndLog;
exports.checkForLastErrorAndWarn = checkForLastErrorAndWarn;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _loglevel = _interopRequireDefault(require("loglevel"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Utility Functions to support browser.runtime JavaScript API
 */

/**
 * Returns an Error if extension.runtime.lastError is present
 * this is a workaround for the non-standard error object that's used
 *
 * According to the docs, we are expected to check lastError in runtime API callbacks:
 * "
 * If you call an asynchronous function that may set lastError, you are expected to
 * check for the error when you handle the result of the function. If lastError has been
 * set and you don't check it within the callback function, then an error will be raised.
 * "
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/lastError}
 * @returns {Error|undefined}
 */
function checkForLastError() {
  const {
    lastError
  } = _webextensionPolyfill.default.runtime;
  if (!lastError) {
    return undefined;
  }
  // if it quacks like an Error, its an Error
  if (lastError.stack && lastError.message) {
    return lastError;
  }
  // repair incomplete error object (eg chromium v77)
  return new Error(lastError.message);
}

/** @returns {Error|undefined} */
function checkForLastErrorAndLog() {
  const error = checkForLastError();
  if (error) {
    _loglevel.default.error(error);
  }
  return error;
}

/** @returns {Error|undefined} */
function checkForLastErrorAndWarn() {
  const error = checkForLastError();
  if (error) {
    console.warn(error);
  }
  return error;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\browser-runtime.utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\contract-utils.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Ccontract-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readAddressAsContract = void 0;
const readAddressAsContract = async (ethQuery, address) => {
  let contractCode;
  try {
    contractCode = await ethQuery.getCode(address);
  } catch (e) {
    contractCode = null;
  }
  const isContractAddress = contractCode ? contractCode !== '0x' && contractCode !== '0x0' : false;
  return {
    contractCode,
    isContractAddress
  };
};
exports.readAddressAsContract = readAddressAsContract;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\contract-utils.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\conversion.utils.ts", {"../constants/common":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\common.ts","./Numeric":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\Numeric.ts","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cconversion.utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addHexes = addHexes;
exports.bnToHex = bnToHex;
exports.decEthToConvertedCurrency = decEthToConvertedCurrency;
exports.decGWEIToHexWEI = decGWEIToHexWEI;
exports.decWEIToDecETH = decWEIToDecETH;
exports.decimalToHex = decimalToHex;
exports.getEthConversionFromWeiHex = getEthConversionFromWeiHex;
exports.getValueFromWeiHex = getValueFromWeiHex;
exports.getWeiHexFromDecimalValue = getWeiHexFromDecimalValue;
exports.hexToDecimal = hexToDecimal;
exports.hexWEIToDecETH = hexWEIToDecETH;
exports.hexWEIToDecGWEI = hexWEIToDecGWEI;
exports.subtractHexes = subtractHexes;
exports.sumHexes = sumHexes;
var _bignumber = require("bignumber.js");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("../constants/common");
var _Numeric = require("./Numeric");
function decGWEIToHexWEI(decGWEI) {
  return new _Numeric.Numeric(decGWEI, 10, _common.EtherDenomination.GWEI).toBase(16).toDenomination(_common.EtherDenomination.WEI).toString();
}
function subtractHexes(aHexWEI, bHexWEI) {
  return new _Numeric.Numeric(aHexWEI, 16).minus(new _Numeric.Numeric(bHexWEI, 16)).round(6, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function addHexes(aHexWEI, bHexWEI) {
  return new _Numeric.Numeric(aHexWEI, 16).add(new _Numeric.Numeric(bHexWEI, 16)).round(6, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function decWEIToDecETH(decWEI) {
  return new _Numeric.Numeric(decWEI, 10, _common.EtherDenomination.WEI).toDenomination(_common.EtherDenomination.ETH).toString();
}
function hexWEIToDecETH(hexWEI) {
  return new _Numeric.Numeric(hexWEI, 16, _common.EtherDenomination.WEI).toDenomination(_common.EtherDenomination.ETH).toBase(10).toString();
}
function decEthToConvertedCurrency(ethTotal, convertedCurrency, conversionRate) {
  let numeric = new _Numeric.Numeric(ethTotal, 10, _common.EtherDenomination.ETH);
  if (convertedCurrency !== _common.EtherDenomination.ETH) {
    numeric = numeric.applyConversionRate(conversionRate);
  }
  return numeric.round(2);
}
function getWeiHexFromDecimalValue({
  value,
  conversionRate = 1,
  fromDenomination,
  fromCurrency,
  invertConversionRate = false
}) {
  let numeric = new _Numeric.Numeric(value, 10, fromDenomination);
  if (fromCurrency !== _common.EtherDenomination.ETH) {
    numeric = numeric.applyConversionRate(conversionRate, invertConversionRate);
  }
  return numeric.toBase(16).toDenomination(_common.EtherDenomination.WEI).toString();
}

/**
 * Converts a BN object to a hex string with a '0x' prefix
 *
 * @param inputBn - The BN to convert to a hex string
 * @returns A '0x' prefixed hex string
 */
function bnToHex(inputBn) {
  return (0, _ethereumjsUtil.addHexPrefix)(inputBn.toString(16));
}
function getEthConversionFromWeiHex({
  value,
  fromCurrency = _common.EtherDenomination.ETH,
  conversionRate,
  numberOfDecimals = 6
}) {
  const denominations = [_common.EtherDenomination.ETH, _common.EtherDenomination.GWEI, _common.EtherDenomination.WEI];
  let nonZeroDenomination;
  for (let i = 0; i < denominations.length; i++) {
    const convertedValue = getValueFromWeiHex({
      value,
      conversionRate,
      fromCurrency,
      toCurrency: fromCurrency,
      numberOfDecimals,
      toDenomination: denominations[i]
    });
    if (convertedValue !== '0' || i === denominations.length - 1) {
      nonZeroDenomination = `${convertedValue} ${denominations[i]}`;
      break;
    }
  }
  return nonZeroDenomination;
}
function getValueFromWeiHex({
  value,
  fromCurrency = _common.EtherDenomination.ETH,
  toCurrency,
  conversionRate,
  numberOfDecimals,
  toDenomination = _common.EtherDenomination.ETH
}) {
  let numeric = new _Numeric.Numeric(value, 16, _common.EtherDenomination.WEI);
  if (fromCurrency !== toCurrency) {
    numeric = numeric.applyConversionRate(conversionRate);
  }
  return numeric.toBase(10).toDenomination(toDenomination).round(numberOfDecimals, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function sumHexes(first, ...args) {
  const firstValue = new _Numeric.Numeric(first, 16);
  const total = args.reduce((acc, hexAmount) => acc.add(new _Numeric.Numeric(hexAmount, 16)), firstValue);
  return total.toPrefixedHexString();
}
function hexWEIToDecGWEI(value) {
  return new _Numeric.Numeric(value, 16, _common.EtherDenomination.WEI).toBase(10).toDenomination(_common.EtherDenomination.GWEI).toString();
}
function decimalToHex(decimal) {
  return new _Numeric.Numeric(decimal, 10).toBase(16).toString();
}
function hexToDecimal(hexValue) {
  return new _Numeric.Numeric(hexValue, 16).toBase(10).toString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\conversion.utils.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\error.ts", {"loglevel":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cerror.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isErrorWithMessage = isErrorWithMessage;
exports.logErrorWithMessage = logErrorWithMessage;
var _loglevel = _interopRequireDefault(require("loglevel"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * TODO: Remove once this becomes available at @metamask/utils
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
  return typeof error === 'object' && error !== null && 'message' in error;
}
function logErrorWithMessage(error) {
  if (isErrorWithMessage(error)) {
    _loglevel.default.error(error.message);
  } else {
    _loglevel.default.error(error);
  }
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\error.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\fetch-with-timeout.ts", {"../constants/time":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\time.ts","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cfetch-with-timeout.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _time = require("../constants/time");
/**
 * Returns a function that can be used to make an HTTP request but timing out
 * automatically after a desired amount of time.
 *
 * @param timeout - The number of milliseconds to wait until the request times
 * out.
 * @returns A function that, when called, returns a promise that either resolves
 * to the HTTP response object or is rejected if a network error is encountered
 * or the request times out.
 */
const getFetchWithTimeout = (0, _lodash.memoize)((timeout = _time.SECOND * 30) => {
  if (!Number.isInteger(timeout) || timeout < 1) {
    throw new Error('Must specify positive integer timeout.');
  }
  return async function fetchWithTimeout(url, opts) {
    const abortController = new window.AbortController();
    const {
      signal
    } = abortController;
    const f = window.fetch(url, {
      ...opts,
      signal
    });
    const timer = setTimeout(() => abortController.abort(), timeout);
    try {
      return await f;
    } finally {
      clearTimeout(timer);
    }
  };
});
var _default = getFetchWithTimeout;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\fetch-with-timeout.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\hexstring-utils.ts", {"ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Chexstring-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BURN_ADDRESS = void 0;
exports.isBurnAddress = isBurnAddress;
exports.isValidHexAddress = isValidHexAddress;
exports.stripHexPrefix = stripHexPrefix;
exports.toChecksumHexAddress = toChecksumHexAddress;
var _ethereumjsUtil = require("ethereumjs-util");
const BURN_ADDRESS = (0, _ethereumjsUtil.zeroAddress)();
exports.BURN_ADDRESS = BURN_ADDRESS;
function isBurnAddress(address) {
  return address === BURN_ADDRESS;
}

/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 *
 * @param possibleAddress - Input parameter to check against
 * @param [options] - options bag
 * @param [options.allowNonPrefixed] - If true will first ensure '0x'
 * is prepended to the string
 * @param [options.mixedCaseUseChecksum] - If true will treat mixed
 * case addresses as checksum addresses and validate that proper checksum
 * format is used
 * @returns whether or not the input is a valid hex address
 */
function isValidHexAddress(possibleAddress, {
  allowNonPrefixed = true,
  mixedCaseUseChecksum = false
} = {}) {
  const addressToCheck = allowNonPrefixed ? (0, _ethereumjsUtil.addHexPrefix)(possibleAddress) : possibleAddress;
  if (!(0, _ethereumjsUtil.isHexString)(addressToCheck)) {
    return false;
  }
  if (mixedCaseUseChecksum) {
    const prefixRemoved = addressToCheck.slice(2);
    const lower = prefixRemoved.toLowerCase();
    const upper = prefixRemoved.toUpperCase();
    const allOneCase = prefixRemoved === lower || prefixRemoved === upper;
    if (!allOneCase) {
      return (0, _ethereumjsUtil.isValidChecksumAddress)(addressToCheck);
    }
  }
  return (0, _ethereumjsUtil.isValidAddress)(addressToCheck);
}
function toChecksumHexAddress(address) {
  if (!address) {
    // our internal checksumAddress function that this method replaces would
    // return an empty string for nullish input. If any direct usages of
    // ethereumjs-util.toChecksumAddress were called with nullish input it
    // would have resulted in an error on version 5.1.
    return '';
  }
  const hexPrefixed = (0, _ethereumjsUtil.addHexPrefix)(address);
  if (!(0, _ethereumjsUtil.isHexString)(hexPrefixed)) {
    // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
    // but we shouldn't waste effort trying to change case on a clearly invalid
    // string. Instead just return the hex prefixed original string which most
    // closely mimics the original behavior.
    return hexPrefixed;
  }
  return (0, _ethereumjsUtil.toChecksumAddress)(hexPrefixed);
}
function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }
  return (0, _ethereumjsUtil.isHexPrefixed)(str) ? str.slice(2) : str;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\hexstring-utils.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\mv3.utils.js", {"webextension-polyfill":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cmv3.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isManifestV3 = void 0;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const isManifestV3 = _webextensionPolyfill.default.runtime.getManifest().manifest_version === 3;
exports.isManifestV3 = isManifestV3;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\mv3.utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\network.utils.ts", {"../constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cnetwork.utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPrefixedFormattedHexString = isPrefixedFormattedHexString;
exports.isSafeChainId = isSafeChainId;
exports.isTokenDetectionEnabledForNetwork = isTokenDetectionEnabledForNetwork;
var _network = require("../constants/network");
/**
 * Checks whether the given number primitive chain ID is safe.
 * Because some cryptographic libraries we use expect the chain ID to be a
 * number primitive, it must not exceed a certain size.
 *
 * @param chainId - The chain ID to check for safety.
 * @returns Whether the given chain ID is safe.
 */
function isSafeChainId(chainId) {
  return isSafeInteger(chainId) && chainId > 0 && chainId <= _network.MAX_SAFE_CHAIN_ID;
}

/**
 * Checks whether the given value is a 0x-prefixed, non-zero, non-zero-padded,
 * hexadecimal string.
 *
 * @param value - The value to check.
 * @returns True if the value is a correctly formatted hex string,
 * false otherwise.
 */
function isPrefixedFormattedHexString(value) {
  if (typeof value !== 'string') {
    return false;
  }
  return /^0x[1-9a-f]+[0-9a-f]*$/iu.test(value);
}

/**
 * Check if token detection is enabled for certain networks
 *
 * @param chainId - ChainID of network
 * @returns Whether the current network supports token detection
 */
function isTokenDetectionEnabledForNetwork(chainId) {
  switch (chainId) {
    case _network.CHAIN_IDS.MAINNET:
    case _network.CHAIN_IDS.BSC:
    case _network.CHAIN_IDS.POLYGON:
    case _network.CHAIN_IDS.AVALANCHE:
      return true;
    default:
      return false;
  }
}

/**
 * Like {@link Number.isSafeInteger}, but types the input as a `number` if it is
 * indeed a safe integer.
 *
 * @param value - The value to check.
 * @returns True if the value is a safe integer, false otherwise.
 */
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\network.utils.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\object.utils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cobject.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maskObject = maskObject;
/**
 * Return a "masked" copy of the given object.
 *
 * The returned object includes only the properties present in the mask. The
 * mask is an object that mirrors the structure of the given object, except
 * the only values are `true` or a sub-mask. `true` implies the property
 * should be included, and a sub-mask implies the property should be further
 * masked according to that sub-mask.
 *
 * @param {object} object - The object to mask
 * @param {Object<object | boolean>} mask - The mask to apply to the object
 */
function maskObject(object, mask) {
  return Object.keys(object).reduce((state, key) => {
    if (mask[key] === true) {
      state[key] = object[key];
    } else if (mask[key]) {
      state[key] = maskObject(object[key], mask[key]);
    }
    return state;
  }, {});
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\object.utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\random-id.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Crandom-id.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRandomId;
const MAX = Number.MAX_SAFE_INTEGER;
let idCounter = Math.round(Math.random() * MAX);
function createRandomId() {
  idCounter %= MAX;
  // eslint-disable-next-line no-plusplus
  return idCounter++;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\random-id.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\string-utils.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cstring-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEqualCaseInsensitive = isEqualCaseInsensitive;
exports.prependZero = prependZero;
/**
 * Compare 2 given strings and return boolean
 * eg: "foo" and "FOO" => true
 * eg: "foo" and "bar" => false
 * eg: "foo" and 123 => false
 *
 * @param value1 - first string to compare
 * @param value2 - first string to compare
 * @returns true if 2 strings are identical when they are lowercase
 */
function isEqualCaseInsensitive(value1, value2) {
  if (typeof value1 !== 'string' || typeof value2 !== 'string') {
    return false;
  }
  return value1.toLowerCase() === value2.toLowerCase();
}

/**
 * Takes a number with max length until the resulting string reaches the given length
 *
 * @param num
 * @param maxLength
 */
function prependZero(num, maxLength) {
  return num.toString().padStart(maxLength, '0');
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\string-utils.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\swaps.utils.js", {"../constants/swaps":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\swaps.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Cswaps.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwapsDefaultTokenAddress = isSwapsDefaultTokenAddress;
exports.isSwapsDefaultTokenSymbol = isSwapsDefaultTokenSymbol;
var _swaps = require("../constants/swaps");
/**
 * Checks whether the provided address is strictly equal to the address for
 * the default swaps token of the provided chain.
 *
 * @param {string} address - The string to compare to the default token address
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the address is the provided chain's default token address
 */
function isSwapsDefaultTokenAddress(address, chainId) {
  var _SWAPS_CHAINID_DEFAUL;
  if (!address || !chainId) {
    return false;
  }
  return address === ((_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address);
}

/**
 * Checks whether the provided symbol is strictly equal to the symbol for
 * the default swaps token of the provided chain.
 *
 * @param {string} symbol - The string to compare to the default token symbol
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the symbl is the provided chain's default token symbol
 */
function isSwapsDefaultTokenSymbol(symbol, chainId) {
  var _SWAPS_CHAINID_DEFAUL2;
  if (!symbol || !chainId) {
    return false;
  }
  return symbol === ((_SWAPS_CHAINID_DEFAUL2 = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL2 === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL2.symbol);
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\swaps.utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\transaction.utils.js", {"../constants/transaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\transaction.ts","./contract-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\contract-utils.ts","./string-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\string-utils.ts","@ethersproject/abi":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethersproject\\abi\\lib\\index.js","@metamask/metamask-eth-abis":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","loglevel":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cmodules%5Ctransaction.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.determineTransactionAssetType = determineTransactionAssetType;
exports.determineTransactionContractCode = determineTransactionContractCode;
exports.determineTransactionType = determineTransactionType;
exports.isEIP1559Transaction = isEIP1559Transaction;
exports.isLegacyTransaction = isLegacyTransaction;
exports.parseStandardTokenTransactionData = parseStandardTokenTransactionData;
exports.transactionMatchesNetwork = transactionMatchesNetwork;
exports.txParamsAreDappSuggested = txParamsAreDappSuggested;
var _ethereumjsUtil = require("ethereumjs-util");
var _abi = require("@ethersproject/abi");
var _metamaskEthAbis = require("@metamask/metamask-eth-abis");
var _loglevel = _interopRequireDefault(require("loglevel"));
var _transaction = require("../constants/transaction");
var _contractUtils = require("./contract-utils");
var _stringUtils = require("./string-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @typedef { 'transfer' | 'approve' | 'setapprovalforall' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes
 */

/**
 * @typedef {object} InferTransactionTypeResult
 * @property {InferrableTransactionTypes} type - The type of transaction
 * @property {string} getCodeResponse - The contract code, in hex format if
 *  it exists. '0x0' or '0x' are also indicators of non-existent contract
 *  code
 */
/**
 * @typedef EthersContractCall
 * @type object
 * @property {any[]} args - The args/params to the function call.
 * An array-like object with numerical and string indices.
 * @property {string} name - The name of the function.
 * @property {string} signature - The function signature.
 * @property {string} sighash - The function signature hash.
 * @property {EthersBigNumber} value - The ETH value associated with the call.
 * @property {FunctionFragment} functionFragment - The Ethers function fragment
 * representation of the function.
 */
const erc20Interface = new _abi.Interface(_metamaskEthAbis.abiERC20);
const erc721Interface = new _abi.Interface(_metamaskEthAbis.abiERC721);
const erc1155Interface = new _abi.Interface(_metamaskEthAbis.abiERC1155);
function transactionMatchesNetwork(transaction, chainId, networkId) {
  if (typeof transaction.chainId !== 'undefined') {
    return transaction.chainId === chainId;
  }
  return transaction.metamaskNetworkId === networkId;
}

/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid EIP1559 fields
 */
function isEIP1559Transaction(transaction) {
  var _transaction$txParams, _transaction$txParams2;
  return (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams = transaction.txParams) === null || _transaction$txParams === void 0 ? void 0 : _transaction$txParams.maxFeePerGas) && (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams2 = transaction.txParams) === null || _transaction$txParams2 === void 0 ? void 0 : _transaction$txParams2.maxPriorityFeePerGas);
}

/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */
function isLegacyTransaction(transaction) {
  return typeof transaction.txParams.maxFeePerGas === 'undefined' && typeof transaction.txParams.maxPriorityFeePerGas === 'undefined' && (typeof transaction.txParams.gasPrice === 'undefined' || (0, _ethereumjsUtil.isHexString)(transaction.txParams.gasPrice));
}

/**
 * Determine if a transactions gas fees in txParams match those in its dappSuggestedGasFees property
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if both the txParams and dappSuggestedGasFees are objects with truthy gas fee properties,
 *   and those properties are strictly equal
 */
function txParamsAreDappSuggested(transaction) {
  var _transaction$dappSugg, _transaction$dappSugg2, _transaction$dappSugg3;
  const {
    gasPrice,
    maxPriorityFeePerGas,
    maxFeePerGas
  } = (transaction === null || transaction === void 0 ? void 0 : transaction.txParams) || {};
  return gasPrice && gasPrice === (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg === void 0 ? void 0 : _transaction$dappSugg.gasPrice) || maxPriorityFeePerGas && maxFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg2 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg2 === void 0 ? void 0 : _transaction$dappSugg2.maxPriorityFeePerGas) === maxPriorityFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg3 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg3 === void 0 ? void 0 : _transaction$dappSugg3.maxFeePerGas) === maxFeePerGas;
}

/**
 * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.
 * The data will decode correctly if the transaction is an interaction with a contract that matches one of these
 * contract standards
 *
 * @param data - encoded transaction data
 * @returns {EthersContractCall | undefined}
 */
function parseStandardTokenTransactionData(data) {
  try {
    return erc20Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and next try to parse with erc721 ABI
  }
  try {
    return erc721Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and next try to parse with erc1155 ABI
  }
  try {
    return erc1155Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and return undefined
  }
  return undefined;
}

/**
 * Determines the contractCode of the transaction by analyzing the txParams.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */
async function determineTransactionContractCode(txParams, query) {
  const {
    to
  } = txParams;
  const {
    contractCode
  } = await (0, _contractUtils.readAddressAsContract)(query, to);
  return contractCode;
}

/**
 * Determines the type of the transaction by analyzing the txParams.
 * This method will return one of the types defined in shared/constants/transactions
 * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
 * represent specific events that we control from the extension and are added manually
 * at transaction creation.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */
async function determineTransactionType(txParams, query) {
  const {
    data,
    to
  } = txParams;
  let name;
  try {
    ({
      name
    } = data && parseStandardTokenTransactionData(data));
  } catch (error) {
    _loglevel.default.debug('Failed to parse transaction data.', error, data);
  }
  let result;
  let contractCode;
  if (data && !to) {
    result = _transaction.TransactionType.deployContract;
  } else {
    const {
      contractCode: resultCode,
      isContractAddress
    } = await (0, _contractUtils.readAddressAsContract)(query, to);
    contractCode = resultCode;
    if (isContractAddress) {
      const hasValue = txParams.value && txParams.value !== '0x0';
      const tokenMethodName = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom, _transaction.TransactionType.tokenMethodSafeTransferFrom].find(methodName => (0, _stringUtils.isEqualCaseInsensitive)(methodName, name));
      result = data && tokenMethodName && !hasValue ? tokenMethodName : _transaction.TransactionType.contractInteraction;
    } else {
      result = _transaction.TransactionType.simpleSend;
    }
  }
  return {
    type: result,
    getCodeResponse: contractCode
  };
}
const INFERRABLE_TRANSACTION_TYPES = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom, _transaction.TransactionType.contractInteraction, _transaction.TransactionType.simpleSend];

/**
 * Given a transaction meta object, determine the asset type that the
 * transaction is dealing with, as well as the standard for the token if it
 * is a token transaction.
 *
 * @param {__import__('../constants/transaction').TransactionMeta} txMeta -
 *  transaction meta object
 * @param {EthQuery} query - EthQuery instance
 * @param {Function} getTokenStandardAndDetails - function to get token
 *  standards and details.
 * @returns {{ assetType: string, tokenStandard: string}}
 */
async function determineTransactionAssetType(txMeta, query, getTokenStandardAndDetails) {
  // If the transaction type is already one of the inferrable types, then we do
  // not need to re-establish the type.
  let inferrableType = txMeta.type;
  if (INFERRABLE_TRANSACTION_TYPES.includes(txMeta.type) === false) {
    // Because we will deal with all types of transactions (including swaps)
    // we want to get an inferrable type of transaction that isn't special cased
    // that way we can narrow the number of logic gates required.
    const result = await determineTransactionType(txMeta.txParams, query);
    inferrableType = result.type;
  }

  // If the inferred type of the transaction is one of those that are part of
  // the token contract standards, we can use the getTokenStandardAndDetails
  // method to get the asset type.
  const isTokenMethod = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom].find(methodName => methodName === inferrableType);
  if (isTokenMethod ||
  // We can also check any contract interaction type to see if the to address
  // is a token contract. If it isn't, then the method will throw and we can
  // fall through to the other checks.
  inferrableType === _transaction.TransactionType.contractInteraction) {
    try {
      // We don't need a balance check, so the second parameter to
      // getTokenStandardAndDetails is omitted.
      const details = await getTokenStandardAndDetails(txMeta.txParams.to);
      if (details.standard) {
        return {
          assetType: details.standard === _transaction.TokenStandard.ERC20 ? _transaction.AssetType.token : _transaction.AssetType.NFT,
          tokenStandard: details.standard
        };
      }
    } catch {
      // noop, We expect errors here but we don't need to report them or do
      // anything in response.
    }
  }

  // If the transaction is interacting with a contract but isn't a token method
  // we use the 'UNKNOWN' value to show that it isn't a transaction sending any
  // particular asset.
  if (inferrableType === _transaction.TransactionType.contractInteraction) {
    return {
      assetType: _transaction.AssetType.unknown,
      tokenStandard: _transaction.TokenStandard.none
    };
  }
  return {
    assetType: _transaction.AssetType.native,
    tokenStandard: _transaction.TokenStandard.none
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\transaction.utils.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\notifications\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cshared%5Cnotifications%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTranslatedUINotifications = exports.UI_NOTIFICATIONS = void 0;
// Messages and descriptions for these locale keys are in app/_locales/en/messages.json
const UI_NOTIFICATIONS = {
  1: {
    id: 1,
    date: '2021-03-17',
    image: {
      src: 'images/mobile-link-qr.svg',
      height: '230px',
      width: '230px',
      placeImageBelowDescription: true
    }
  },
  3: {
    id: 3,
    date: '2021-03-08'
  },
  4: {
    id: 4,
    date: '2021-05-11',
    image: {
      src: 'images/source-logos-bsc.svg',
      width: '100%'
    }
  },
  5: {
    id: 5,
    date: '2021-06-09'
  },
  6: {
    id: 6,
    date: '2021-05-26'
  },
  7: {
    id: 7,
    date: '2021-09-17'
  },
  8: {
    id: 8,
    date: '2021-11-01'
  },
  9: {
    id: 9,
    date: '2021-12-07',
    image: {
      src: 'images/txinsights.png',
      width: '80%'
    }
  },
  10: {
    id: 10,
    date: '2022-09-15',
    image: {
      src: 'images/token-detection.svg',
      width: '100%'
    }
  },
  11: {
    id: 11,
    date: '2022-09-15'
  },
  12: {
    id: 12,
    date: '2022-05-18',
    image: {
      src: 'images/darkmode-banner.png',
      width: '100%'
    }
  },
  13: {
    id: 13,
    date: '2022-09-15'
  },
  14: {
    id: 14,
    date: '2022-09-15'
  },
  15: {
    id: 15,
    date: '2022-09-15'
  },
  16: {
    id: 16,
    date: null
  },
  17: {
    id: 17,
    date: null
  },
  18: {
    id: 18,
    date: null,
    image: {
      src: 'images/open-sea-security-provider.svg',
      width: '100%'
    }
  },
  19: {
    id: 19,
    date: null,
    image: {
      src: 'images/nfts.svg',
      width: '100%'
    }
  },
  20: {
    id: 20,
    date: null
  }
};
exports.UI_NOTIFICATIONS = UI_NOTIFICATIONS;
const getTranslatedUINotifications = (t, locale) => {
  const formattedLocale = locale.replace('_', '-');
  return {
    1: {
      ...UI_NOTIFICATIONS[1],
      title: t('notifications1Title'),
      description: t('notifications1Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[1].date))
    },
    3: {
      ...UI_NOTIFICATIONS[3],
      title: t('notifications3Title'),
      description: t('notifications3Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[3].date))
    },
    4: {
      ...UI_NOTIFICATIONS[4],
      title: t('notifications4Title'),
      description: t('notifications4Description'),
      actionText: t('notifications4ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[4].date))
    },
    5: {
      ...UI_NOTIFICATIONS[5],
      title: t('secretRecoveryPhrase'),
      description: t('notifications5Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[5].date))
    },
    6: {
      ...UI_NOTIFICATIONS[6],
      title: t('notifications6Title'),
      description: [t('notifications6DescriptionOne'), t('notifications6DescriptionTwo'), t('notifications6DescriptionThree')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[6].date))
    },
    7: {
      ...UI_NOTIFICATIONS[7],
      title: t('notifications7Title'),
      description: [t('notifications7DescriptionOne'), t('notifications7DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[7].date))
    },
    8: {
      ...UI_NOTIFICATIONS[8],
      title: t('notifications8Title'),
      description: [t('notifications8DescriptionOne'), t('notifications8DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[8].date)),
      actionText: t('notifications8ActionText')
    },
    9: {
      ...UI_NOTIFICATIONS[9],
      title: t('notifications9Title'),
      description: [t('notifications9DescriptionOne'), t('notifications9DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[9].date))
    },
    10: {
      ...UI_NOTIFICATIONS[10],
      title: t('notifications10Title'),
      description: [t('notifications10DescriptionOne'), t('notifications10DescriptionTwo'), t('notifications10DescriptionThree')],
      actionText: t('notifications10ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[10].date))
    },
    11: {
      ...UI_NOTIFICATIONS[11],
      title: t('notifications11Title'),
      description: t('notifications11Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[11].date))
    },
    12: {
      ...UI_NOTIFICATIONS[12],
      title: t('notifications12Title'),
      description: t('notifications12Description'),
      actionText: t('notifications12ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[12].date))
    },
    13: {
      ...UI_NOTIFICATIONS[13],
      title: t('notifications13Title'),
      description: t('notifications13Description'),
      actionText: t('notifications13ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[13].date))
    },
    14: {
      ...UI_NOTIFICATIONS[14],
      title: t('notifications14Title'),
      description: t('notifications14Description'),
      actionText: t('notifications14ActionText'),
      date: UI_NOTIFICATIONS[14].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[14].date)) : ''
    },
    15: {
      ...UI_NOTIFICATIONS[15],
      title: t('notifications15Title'),
      description: t('notifications15Description'),
      date: UI_NOTIFICATIONS[15].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[15].date)) : ''
    },
    18: {
      ...UI_NOTIFICATIONS[18],
      title: t('notifications18Title'),
      description: [t('notifications18DescriptionOne'), t('notifications18DescriptionTwo'), t('notifications18DescriptionThree')],
      actionText: t('notifications18ActionText'),
      date: UI_NOTIFICATIONS[18].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[18].date)) : ''
    },
    19: {
      ...UI_NOTIFICATIONS[19],
      title: t('notifications19Title'),
      description: [t('notifications19DescriptionOne'), t('notifications19DescriptionTwo'), t('notifications19DescriptionThree')],
      actionText: t('notifications19ActionText'),
      date: UI_NOTIFICATIONS[19].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[19].date)) : ''
    },
    20: {
      ...UI_NOTIFICATIONS[20],
      title: t('notifications20Title'),
      description: [t('notifications20Description')],
      actionText: t('notifications20ActionText'),
      date: UI_NOTIFICATIONS[20].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[20].date)) : ''
    }
  };
};
exports.getTranslatedUINotifications = getTranslatedUINotifications;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\notifications\\index.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\ui\\helpers\\constants\\common.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cui%5Chelpers%5Cconstants%5Ccommon.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SUPPORT_REQUEST_LINK = exports.SECONDARY = exports.PRIMARY = exports.PASSWORD_MIN_LENGTH = exports.OUTDATED_BROWSER_VERSIONS = exports.CONTRACT_ADDRESS_LINK = void 0;
const PRIMARY = 'PRIMARY';
exports.PRIMARY = PRIMARY;
const SECONDARY = 'SECONDARY';
exports.SECONDARY = SECONDARY;
const _contractAddressLink = 'https://metamask.zendesk.com/hc/en-us/articles/360020028092-What-is-the-known-contract-address-warning-';

// eslint-disable-next-line prefer-destructuring
const SUPPORT_REQUEST_LINK = "https://metamask.zendesk.com/hc/en-us";
exports.SUPPORT_REQUEST_LINK = SUPPORT_REQUEST_LINK;
const CONTRACT_ADDRESS_LINK = _contractAddressLink;
exports.CONTRACT_ADDRESS_LINK = CONTRACT_ADDRESS_LINK;
const PASSWORD_MIN_LENGTH = 8;
exports.PASSWORD_MIN_LENGTH = PASSWORD_MIN_LENGTH;
const OUTDATED_BROWSER_VERSIONS = {
  // Chrome and Edge should match the latest Chrome version released ~2 years ago
  chrome: '<90',
  edge: '<90',
  // Firefox should match the most recent end-of-life extended support release
  firefox: '<91',
  // Opera should be set to the equivalent of the Chrome version set
  // See https://en.wikipedia.org/wiki/History_of_the_Opera_web_browser
  opera: '<76'
};
exports.OUTDATED_BROWSER_VERSIONS = OUTDATED_BROWSER_VERSIONS;

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\constants\\common.ts",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\ui\\helpers\\utils\\build-types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Cbuild-types.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuildSpecificAsset = getBuildSpecificAsset;
exports.isBeta = isBeta;
const assetList = {
  main: {
    // Will use default provided by the @metamask/logo library
    foxMeshJson: undefined
  }
};
function isBeta() {
  return "main" === 'beta';
}

// Returns a specific version of an asset based on
// the current metamask version (i.e. main, beta, etc.)
function getBuildSpecificAsset(assetName) {
  const buildType = "main";
  if (!assetList[buildType] || !Object.keys(assetList[buildType]).includes(assetName)) {
    console.error(`Cannot find asset "${assetName}" for build "${buildType}", returning main build asset.`);
    return assetList.main[assetName];
  }
  return assetList[buildType][assetName];
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\build-types.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js", {"../../../../shared/modules/hexstring-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\hexstring-utils.ts","@ethereumjs/common":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\common\\dist\\index.js","@ethereumjs/tx":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Coptimism%5CbuildUnserializedTransaction.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildUnserializedTransaction;
var _lodash = require("lodash");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("@ethereumjs/common");
var _tx = require("@ethereumjs/tx");
var _hexstringUtils = require("../../../../shared/modules/hexstring-utils");
function buildTxParams(txMeta) {
  return {
    ...(0, _lodash.omit)(txMeta.txParams, 'gas'),
    gasLimit: txMeta.txParams.gas
  };
}
function buildTransactionCommon(txMeta) {
  // This produces a transaction whose information does not completely match an
  // Optimism transaction  for instance, DEFAULT_CHAIN is still 'mainnet' and
  // genesis points to the mainnet genesis, not the Optimism genesis  but
  // considering that all we want to do is serialize a transaction, this works
  // fine for our use case.
  return _common.Common.custom({
    chainId: new _ethereumjsUtil.BN((0, _hexstringUtils.stripHexPrefix)(txMeta.chainId), 16),
    networkId: new _ethereumjsUtil.BN(txMeta.metamaskNetworkId, 10),
    // Optimism only supports type-0 transactions; it does not support any of
    // the newer EIPs since EIP-155. Source:
    // <https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md>
    defaultHardfork: _common.Hardfork.SpuriousDragon
  });
}
function buildUnserializedTransaction(txMeta) {
  const txParams = buildTxParams(txMeta);
  const common = buildTransactionCommon(txMeta);
  return _tx.TransactionFactory.fromTxData(txParams, {
    common
  });
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js", {"./buildUnserializedTransaction":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js","@ethersproject/contracts":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethersproject\\contracts\\lib\\index.js","@ethersproject/providers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@ethersproject\\providers\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Coptimism%5CfetchEstimatedL1Fee.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchEstimatedL1Fee;
var _contracts = require("@ethersproject/contracts");
var _providers = require("@ethersproject/providers");
var _buildUnserializedTransaction = _interopRequireDefault(require("./buildUnserializedTransaction"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Snippet of the ABI that we need
// Should we need more of it at some point, the full ABI can be found here:
// https://github.com/ethereum-optimism/optimism/blob/develop/gas-oracle/abis/OVM_GasPriceOracle.json
const OPTIMISM_GAS_PRICE_ORACLE_ABI = [{
  inputs: [{
    internalType: 'bytes',
    name: '_data',
    type: 'bytes'
  }],
  name: 'getL1Fee',
  outputs: [{
    internalType: 'uint256',
    name: '',
    type: 'uint256'
  }],
  stateMutability: 'view',
  type: 'function'
}];

// BlockExplorer link: https://optimistic.etherscan.io/address/0x420000000000000000000000000000000000000f#code
const OPTIMISM_GAS_PRICE_ORACLE_ADDRESS = '0x420000000000000000000000000000000000000F';
async function fetchEstimatedL1Fee(chainId, txMeta, ethersProvider) {
  const networkId = Number(chainId);
  const provider = global.ethereumProvider ? new _providers.Web3Provider(global.ethereumProvider, networkId) : ethersProvider;
  if (false) {
    provider.detectNetwork = async () => ({
      name: 'optimism',
      chainId: networkId
    });
  }
  const contract = new _contracts.Contract(OPTIMISM_GAS_PRICE_ORACLE_ADDRESS, OPTIMISM_GAS_PRICE_ORACLE_ABI, provider);
  const serializedTransaction = (0, _buildUnserializedTransaction.default)(txMeta).serialize();
  const result = await contract.getL1Fee(serializedTransaction);
  return result === null || result === void 0 ? void 0 : result.toHexString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js",}],
["D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\ui\\helpers\\utils\\util.js", {"../../../shared/constants/labels":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\labels.ts","../../../shared/constants/network":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\constants\\network.ts","../../../shared/modules/Numeric":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\Numeric.ts","../../../shared/modules/hexstring-utils":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\shared\\modules\\hexstring-utils.ts","../constants/common":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\ui\\helpers\\constants\\common.ts","@metamask/assets-controllers":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\assets-controllers\\dist\\index.js","@metamask/slip44":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\@metamask\\slip44\\slip44.json","bignumber.js":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","bowser":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\bowser\\es5.js","ethereumjs-util":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","human-standard-token-abi":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\human-standard-token-abi\\index.js","lodash":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\lodash\\lodash.js","luxon":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\luxon\\build\\cjs-browser\\luxon.js","punycode/punycode":"D:\\onedrive\\sdu\\Research\\Web3 Signature Authentication\\demo\\metamask-extension\\node_modules\\punycode\\punycode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: D:%5Conedrive%5Csdu%5CResearch%5CWeb3%20Signature%20Authentication%5Cdemo%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Cutil.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addressSummary = addressSummary;
exports.bnGreaterThan = bnGreaterThan;
exports.bnGreaterThanEqualTo = bnGreaterThanEqualTo;
exports.bnLessThan = bnLessThan;
exports.bnLessThanEqualTo = bnLessThanEqualTo;
exports.checkExistingAddresses = checkExistingAddresses;
exports.clearClipboard = clearClipboard;
exports.coinTypeToProtocolName = coinTypeToProtocolName;
exports.formatBalance = formatBalance;
exports.formatDate = formatDate;
exports.formatDateWithYearContext = formatDateWithYearContext;
exports.getAccountByAddress = getAccountByAddress;
exports.getAssetImageURL = getAssetImageURL;
exports.getContractAtAddress = getContractAtAddress;
exports.getIsBrowserDeprecated = getIsBrowserDeprecated;
exports.getRandomFileName = getRandomFileName;
exports.getURL = getURL;
exports.getURLHost = getURLHost;
exports.getURLHostName = getURLHostName;
exports.isDefaultMetaMaskChain = isDefaultMetaMaskChain;
exports.isExtensionUrl = isExtensionUrl;
exports.isNullish = isNullish;
exports.isOriginContractAddress = isOriginContractAddress;
exports.isValidDomainName = isValidDomainName;
exports.numericBalance = numericBalance;
exports.parseBalance = parseBalance;
exports.roundToDecimalPlacesRemovingExtraZeroes = roundToDecimalPlacesRemovingExtraZeroes;
exports.sanitizeString = exports.sanitizeMessage = void 0;
exports.shortenAddress = shortenAddress;
exports.stripHttpSchemes = stripHttpSchemes;
exports.stripHttpsScheme = stripHttpsScheme;
exports.stripHttpsSchemeWithoutPort = stripHttpsSchemeWithoutPort;
exports.toHumanReadableTime = void 0;
exports.valuesFor = valuesFor;
var _punycode = _interopRequireDefault(require("punycode/punycode"));
var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var ethUtil = _interopRequireWildcard(require("ethereumjs-util"));
var _luxon = require("luxon");
var _assetsControllers = require("@metamask/assets-controllers");
var _slip = _interopRequireDefault(require("@metamask/slip44"));
var lodash = _interopRequireWildcard(require("lodash"));
var _bowser = _interopRequireDefault(require("bowser"));
var _network = require("../../../shared/constants/network");
var _hexstringUtils = require("../../../shared/modules/hexstring-utils");
var _labels = require("../../../shared/constants/labels");
var _Numeric = require("../../../shared/modules/Numeric");
var _common = require("../constants/common");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// formatData :: ( date: <Unix Timestamp> ) -> String
function formatDate(date, format = "M/d/y 'at' T") {
  if (!date) {
    return '';
  }
  return _luxon.DateTime.fromMillis(date).toFormat(format);
}
function formatDateWithYearContext(date, formatThisYear = 'MMM d', fallback = 'MMM d, y') {
  if (!date) {
    return '';
  }
  const dateTime = _luxon.DateTime.fromMillis(date);
  const now = _luxon.DateTime.local();
  return dateTime.toFormat(now.year === dateTime.year ? formatThisYear : fallback);
}
/**
 * Determines if the provided chainId is a default MetaMask chain
 *
 * @param {string} chainId - chainId to check
 */
function isDefaultMetaMaskChain(chainId) {
  if (!chainId || chainId === _network.CHAIN_IDS.MAINNET || chainId === _network.CHAIN_IDS.GOERLI || chainId === _network.CHAIN_IDS.SEPOLIA || chainId === _network.CHAIN_IDS.LINEA_TESTNET || chainId === _network.CHAIN_IDS.LOCALHOST) {
    return true;
  }
  return false;
}
function valuesFor(obj) {
  if (!obj) {
    return [];
  }
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}
function addressSummary(address, firstSegLength = 10, lastSegLength = 4, includeHex = true) {
  if (!address) {
    return '';
  }
  let checked = (0, _hexstringUtils.toChecksumHexAddress)(address);
  if (!includeHex) {
    checked = (0, _hexstringUtils.stripHexPrefix)(checked);
  }
  return checked ? `${checked.slice(0, firstSegLength)}...${checked.slice(checked.length - lastSegLength)}` : '...';
}
function isValidDomainName(address) {
  const match = _punycode.default.toASCII(address).toLowerCase()
  // Checks that the domain consists of at least one valid domain pieces separated by periods, followed by a tld
  // Each piece of domain name has only the characters a-z, 0-9, and a hyphen (but not at the start or end of chunk)
  // A chunk has minimum length of 1, but minimum tld is set to 2 for now (no 1-character tlds exist yet)
  .match(/^(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z0-9][-a-z0-9]*[a-z0-9]$/u);
  return match !== null;
}
function isOriginContractAddress(to, sendTokenAddress) {
  if (!to || !sendTokenAddress) {
    return false;
  }
  return to.toLowerCase() === sendTokenAddress.toLowerCase();
}

// Takes wei Hex, returns wei BN, even if input is null
function numericBalance(balance) {
  if (!balance) {
    return new ethUtil.BN(0, 16);
  }
  const stripped = (0, _hexstringUtils.stripHexPrefix)(balance);
  return new ethUtil.BN(stripped, 16);
}

// Takes  hex, returns [beforeDecimal, afterDecimal]
function parseBalance(balance) {
  let afterDecimal;
  const wei = numericBalance(balance);
  const weiString = wei.toString();
  const trailingZeros = /0+$/u;
  const beforeDecimal = weiString.length > 18 ? weiString.slice(0, weiString.length - 18) : '0';
  afterDecimal = `000000000000000000${wei}`.slice(-18).replace(trailingZeros, '');
  if (afterDecimal === '') {
    afterDecimal = '0';
  }
  return [beforeDecimal, afterDecimal];
}

// Takes wei hex, returns an object with three properties.
// Its "formatted" property is what we generally use to render values.
function formatBalance(balance, decimalsToKeep, needsParse = true, ticker = 'ETH') {
  const parsed = needsParse ? parseBalance(balance) : balance.split('.');
  const beforeDecimal = parsed[0];
  let afterDecimal = parsed[1];
  let formatted = 'None';
  if (decimalsToKeep === undefined) {
    if (beforeDecimal === '0') {
      if (afterDecimal !== '0') {
        const sigFigs = afterDecimal.match(/^0*(.{2})/u); // default: grabs 2 most significant digits
        if (sigFigs) {
          afterDecimal = sigFigs[0];
        }
        formatted = `0.${afterDecimal} ${ticker}`;
      }
    } else {
      formatted = `${beforeDecimal}.${afterDecimal.slice(0, 3)} ${ticker}`;
    }
  } else {
    afterDecimal += Array(decimalsToKeep).join('0');
    formatted = `${beforeDecimal}.${afterDecimal.slice(0, decimalsToKeep)} ${ticker}`;
  }
  return formatted;
}
function getContractAtAddress(tokenAddress) {
  return global.eth.contract(_humanStandardTokenAbi.default).at(tokenAddress);
}
function getRandomFileName() {
  let fileName = '';
  const charBank = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'];
  const fileNameLength = Math.floor(Math.random() * 7 + 6);
  for (let i = 0; i < fileNameLength; i++) {
    fileName += charBank[Math.floor(Math.random() * charBank.length)];
  }
  return fileName;
}

/**
 * Shortens an Ethereum address for display, preserving the beginning and end.
 * Returns the given address if it is no longer than 10 characters.
 * Shortened addresses are 13 characters long.
 *
 * Example output: 0xabcd...1234
 *
 * @param {string} address - The address to shorten.
 * @returns {string} The shortened address, or the original if it was no longer
 * than 10 characters.
 */
function shortenAddress(address = '') {
  if (address.length < _labels.TRUNCATED_NAME_CHAR_LIMIT) {
    return address;
  }
  return `${address.slice(0, _labels.TRUNCATED_ADDRESS_START_CHARS)}...${address.slice(-_labels.TRUNCATED_ADDRESS_END_CHARS)}`;
}
function getAccountByAddress(accounts = [], targetAddress) {
  return accounts.find(({
    address
  }) => address === targetAddress);
}

/**
 * Strips the following schemes from URL strings:
 * - http
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpSchemes(urlString) {
  return urlString.replace(/^https?:\/\//u, '');
}

/**
 * Strips the following schemes from URL strings:
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpsScheme(urlString) {
  return urlString.replace(/^https:\/\//u, '');
}

/**
 * Strips `https` schemes from URL strings, if the URL does not have a port.
 * This is useful
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpsSchemeWithoutPort(urlString) {
  if (getURL(urlString).port) {
    return urlString;
  }
  return stripHttpsScheme(urlString);
}

/**
 * Checks whether a URL-like value (object or string) is an extension URL.
 *
 * @param {string | URL | object} urlLike - The URL-like value to test.
 * @returns {boolean} Whether the URL-like value is an extension URL.
 */
function isExtensionUrl(urlLike) {
  const EXT_PROTOCOLS = ['chrome-extension:', 'moz-extension:'];
  if (typeof urlLike === 'string') {
    for (const protocol of EXT_PROTOCOLS) {
      if (urlLike.startsWith(protocol)) {
        return true;
      }
    }
  }
  if (urlLike !== null && urlLike !== void 0 && urlLike.protocol) {
    return EXT_PROTOCOLS.includes(urlLike.protocol);
  }
  return false;
}

/**
 * Checks whether an address is in a passed list of objects with address properties. The check is performed on the
 * lowercased version of the addresses.
 *
 * @param {string} address - The hex address to check
 * @param {Array} list - The array of objects to check
 * @returns {boolean} Whether or not the address is in the list
 */
function checkExistingAddresses(address, list = []) {
  if (!address) {
    return false;
  }
  const matchesAddress = obj => {
    return obj.address.toLowerCase() === address.toLowerCase();
  };
  return list.some(matchesAddress);
}
function bnGreaterThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).gt(b, 10);
}
function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).lt(b, 10);
}
function bnGreaterThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).gte(b, 10);
}
function bnLessThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).lte(b, 10);
}
function getURL(url) {
  try {
    return new URL(url);
  } catch (err) {
    return '';
  }
}
function getIsBrowserDeprecated(browser = _bowser.default.getParser(window.navigator.userAgent)) {
  return browser.satisfies(_common.OUTDATED_BROWSER_VERSIONS) ?? false;
}
function getURLHost(url) {
  var _getURL;
  return ((_getURL = getURL(url)) === null || _getURL === void 0 ? void 0 : _getURL.host) || '';
}
function getURLHostName(url) {
  var _getURL2;
  return ((_getURL2 = getURL(url)) === null || _getURL2 === void 0 ? void 0 : _getURL2.hostname) || '';
}

// Once we reach this threshold, we switch to higher unit
const MINUTE_CUTOFF = 90 * 60;
const SECOND_CUTOFF = 90;
const toHumanReadableTime = (t, milliseconds) => {
  if (milliseconds === undefined || milliseconds === null) {
    return '';
  }
  const seconds = Math.ceil(milliseconds / 1000);
  if (seconds <= SECOND_CUTOFF) {
    return t('gasTimingSecondsShort', [seconds]);
  }
  if (seconds <= MINUTE_CUTOFF) {
    return t('gasTimingMinutesShort', [Math.ceil(seconds / 60)]);
  }
  return t('gasTimingHoursShort', [Math.ceil(seconds / 3600)]);
};
exports.toHumanReadableTime = toHumanReadableTime;
function clearClipboard() {
  window.navigator.clipboard.writeText('');
}
const solidityTypes = () => {
  const types = ['bool', 'address', 'string', 'bytes', 'int', 'uint', 'fixed', 'ufixed'];
  const ints = Array.from(new Array(32)).map((_, index) => `int${(index + 1) * 8}`);
  const uints = Array.from(new Array(32)).map((_, index) => `uint${(index + 1) * 8}`);
  const bytes = Array.from(new Array(32)).map((_, index) => `bytes${index + 1}`);

  /**
   * fixed and ufixed
   * This value type also can be declared keywords such as ufixedMxN and fixedMxN.
   * The M represents the amount of bits that the type takes,
   * with N representing the number of decimal points that are available.
   *  M has to be divisible by 8, and a number from 8 to 256.
   * N has to be a value between 0 and 80, also being inclusive.
   */
  const fixedM = Array.from(new Array(32)).map((_, index) => `fixed${(index + 1) * 8}`);
  const ufixedM = Array.from(new Array(32)).map((_, index) => `ufixed${(index + 1) * 8}`);
  const fixed = Array.from(new Array(80)).map((_, index) => fixedM.map(aFixedM => `${aFixedM}x${index + 1}`));
  const ufixed = Array.from(new Array(80)).map((_, index) => ufixedM.map(auFixedM => `${auFixedM}x${index + 1}`));
  return [...types, ...ints, ...uints, ...bytes, ...fixed.flat(), ...ufixed.flat()];
};
const SOLIDITY_TYPES = solidityTypes();
const stripArrayType = potentialArrayType => potentialArrayType.replace(/\[[[0-9]*\]*/gu, '');
const stripOneLayerofNesting = potentialArrayType => potentialArrayType.replace(/\[[[0-9]*\]/u, '');
const isArrayType = potentialArrayType => potentialArrayType.match(/\[[[0-9]*\]*/u) !== null;
const isSolidityType = type => SOLIDITY_TYPES.includes(type);
const sanitizeMessage = (msg, primaryType, types) => {
  if (!types) {
    throw new Error(`Invalid types definition`);
  }

  // Primary type can be an array.
  const isArray = primaryType && isArrayType(primaryType);
  if (isArray) {
    return {
      value: msg.map(value => sanitizeMessage(value, stripOneLayerofNesting(primaryType), types)),
      type: primaryType
    };
  } else if (isSolidityType(primaryType)) {
    return {
      value: msg,
      type: primaryType
    };
  }

  // If not, assume to be struct
  const baseType = isArray ? stripArrayType(primaryType) : primaryType;
  const baseTypeDefinitions = types[baseType];
  if (!baseTypeDefinitions) {
    throw new Error(`Invalid primary type definition`);
  }
  const sanitizedStruct = {};
  const msgKeys = Object.keys(msg);
  msgKeys.forEach(msgKey => {
    const definedType = Object.values(baseTypeDefinitions).find(baseTypeDefinition => baseTypeDefinition.name === msgKey);
    if (!definedType) {
      return;
    }
    sanitizedStruct[msgKey] = sanitizeMessage(msg[msgKey], definedType.type, types);
  });
  return {
    value: sanitizedStruct,
    type: primaryType
  };
};
exports.sanitizeMessage = sanitizeMessage;
function getAssetImageURL(image, ipfsGateway) {
  if (!image || !ipfsGateway || typeof image !== 'string') {
    return '';
  }
  if (image.startsWith('ipfs://')) {
    return (0, _assetsControllers.getFormattedIpfsUrl)(ipfsGateway, image, true);
  }
  return image;
}
function roundToDecimalPlacesRemovingExtraZeroes(numberish, numberOfDecimalPlaces) {
  if (numberish === undefined || numberish === null) {
    return '';
  }
  return new _Numeric.Numeric(new _Numeric.Numeric(numberish, 10).toFixed(numberOfDecimalPlaces), 10).toNumber();
}

/**
 * Gets the name of the SLIP-44 protocol corresponding to the specified
 * `coin_type`.
 *
 * @param {string | number} coinType - The SLIP-44 `coin_type` value whose name
 * to retrieve.
 * @returns {string | undefined} The name of the protocol if found.
 */
function coinTypeToProtocolName(coinType) {
  var _slip44$coinType;
  if (String(coinType) === '1') {
    return 'Test Networks';
  }
  return ((_slip44$coinType = _slip.default[coinType]) === null || _slip44$coinType === void 0 ? void 0 : _slip44$coinType.name) || undefined;
}

/**
 * Tests "nullishness". Used to guard a section of a component from being
 * rendered based on a value.
 *
 * @param {any} value - A value (literally anything).
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullish(value) {
  return value === null || value === undefined;
}

/**
 * The method escape RTL character in string
 *
 * @param {*} value
 * @returns {(string|*)} escaped string or original param value
 */
const sanitizeString = value => {
  if (!value) {
    return value;
  }
  if (!lodash.isString(value)) {
    return value;
  }
  const regex = /\u202E/giu;
  return value.replace(regex, '\\u202E');
};
exports.sanitizeString = sanitizeString;


      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\util.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ybHAvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWV2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2VsbGlwdGljLmpzIiwibm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvZWxsaXB0aWMuanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9jb21wYXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NsZWFuLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1idWlsZC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZGlmZi5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2VxLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3QuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndGUuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21ham9yLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWlub3IuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9uZXEuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvdmFsaWQuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcGFyc2Utb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbHRyLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWF4LXNhdGlzZnlpbmcuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi12ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3NpbXBsaWZ5LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc3Vic2V0LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIm5vZGVfbW9kdWxlcy9zZXQtaW1tZWRpYXRlLXNoaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTIyNC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy9zaW5nbGUtY2FsbC1iYWxhbmNlLWNoZWNrZXItYWJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpcC1oZXgtcHJlZml4L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9tZDUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbmlsLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvcmVnZXguanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjEuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92MzUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y0LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvdmFsaWQtdXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy92bS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMiLCJzaGFyZWQvY29uc3RhbnRzL2FsZXJ0cy50cyIsInNoYXJlZC9jb25zdGFudHMvYXBwLnRzIiwic2hhcmVkL2NvbnN0YW50cy9jb21tb24udHMiLCJzaGFyZWQvY29uc3RhbnRzL2dhcy50cyIsInNoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cy50cyIsInNoYXJlZC9jb25zdGFudHMva2V5cmluZy50cyIsInNoYXJlZC9jb25zdGFudHMvbGFiZWxzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcy50cyIsInNoYXJlZC9jb25zdGFudHMvbmV0d29yay50cyIsInNoYXJlZC9jb25zdGFudHMvcGVybWlzc2lvbnMudHMiLCJzaGFyZWQvY29uc3RhbnRzL3ByZWZlcmVuY2VzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9zd2Fwcy50cyIsInNoYXJlZC9jb25zdGFudHMvdGltZS50cyIsInNoYXJlZC9jb25zdGFudHMvdG9rZW5zLmpzIiwic2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbi50cyIsInNoYXJlZC9saWIvZmV0Y2gtd2l0aC1jYWNoZS5qcyIsInNoYXJlZC9saWIvbWV0YW1hc2stY29udHJvbGxlci11dGlscy5qcyIsInNoYXJlZC9saWIvc3RvcmFnZS1oZWxwZXJzLmpzIiwic2hhcmVkL2xpYi9zd2Fwcy11dGlscy5qcyIsInNoYXJlZC9saWIvdG9rZW4tdXRpbC50cyIsInNoYXJlZC9saWIvdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9OdW1lcmljLnRzIiwic2hhcmVkL21vZHVsZXMvYnJvd3Nlci1ydW50aW1lLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvY29udHJhY3QtdXRpbHMudHMiLCJzaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzLnRzIiwic2hhcmVkL21vZHVsZXMvZXJyb3IudHMiLCJzaGFyZWQvbW9kdWxlcy9mZXRjaC13aXRoLXRpbWVvdXQudHMiLCJzaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMudHMiLCJzaGFyZWQvbW9kdWxlcy9tdjMudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzLnRzIiwic2hhcmVkL21vZHVsZXMvb2JqZWN0LnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkLmpzIiwic2hhcmVkL21vZHVsZXMvc3RyaW5nLXV0aWxzLnRzIiwic2hhcmVkL21vZHVsZXMvc3dhcHMudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscy5qcyIsInNoYXJlZC9ub3RpZmljYXRpb25zL2luZGV4LmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvY29tbW9uLnRzIiwidWkvaGVscGVycy91dGlscy9idWlsZC10eXBlcy5qcyIsInVpL2hlbHBlcnMvdXRpbHMvb3B0aW1pc20vYnVpbGRVbnNlcmlhbGl6ZWRUcmFuc2FjdGlvbi5qcyIsInVpL2hlbHBlcnMvdXRpbHMvb3B0aW1pc20vZmV0Y2hFc3RpbWF0ZWRMMUZlZS5qcyIsInVpL2hlbHBlcnMvdXRpbHMvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzVoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzd2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFv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QUEsU0FBQSxPQUFBLENBQUEsT0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLHFCQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFFBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsa0JBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFNBQUEsdUJBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsVUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQSxDQUFBO0FBRUEsSUFBQSxXQUFBLE9BQUEsQ0FBQSxtQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGtCQUFBLE9BQUEsQ0FBQSx5Q0FBQSxDQUFBLENBQUE7QUFJQSxJQUFBLFVBQUEsT0FBQSxDQUFBLGtDQUFBLENBQUEsQ0FBQTtBQUtBLElBQUEsV0FBQSxPQUFBLENBQUEsaUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUE7QUFBZ0UsK0NBQUEsRUFBQSxJQUFBLE9BQUEsT0FBQSxLQUFBLFVBQUEsRUFBQSxPQUFBLElBQUEsQ0FBQSxDQUFBLElBQUEsb0JBQUEsSUFBQSxPQUFBLEVBQUEsQ0FBQSxDQUFBLElBQUEsbUJBQUEsSUFBQSxPQUFBLEVBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSwyQkFBQSx1QkFBQSxFQUFBLE9BQUEsV0FBQSxHQUFBLGdCQUFBLEdBQUEsaUJBQUEsQ0FBQSxFQUFBLEVBQUEsV0FBQSxDQUFBLENBQUEsRUFBQTtBQUFBLG1EQUFBLEVBQUEsSUFBQSxDQUFBLFdBQUEsSUFBQSxHQUFBLElBQUEsR0FBQSxXQUFBLEVBQUEsRUFBQSxPQUFBLEdBQUEsQ0FBQSxFQUFBLENBQUEsSUFBQSxHQUFBLEtBQUEsSUFBQSxJQUFBLE9BQUEsR0FBQSxLQUFBLFFBQUEsSUFBQSxPQUFBLEdBQUEsS0FBQSxVQUFBLEVBQUEsRUFBQSxPQUFBLEVBQUEsU0FBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBLENBQUEsSUFBQSxR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Q0FBQSxtQkFBQSxLQUFBLFFBQU0sQ0FBQyxRQUFRLENBQUMsTUFBQSxJQUFBLElBQUEsZ0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBaEIsZ0JBQUEsS0FBc0IsS0FBSSxTQUFTLENBQUE7Q0FDNUM7Ozs7Ozs7OztBQVNPLDBCQUEwQjtFQUMvQixPQUFPLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsQ0FBQTtDQUM5Qzs7Ozs7Ozs7QUFVTyxNQUFNLGlCQUFrQixTQUFVO0VBQ3ZDLElBQUksQ0FBQyxLQUFLLEVBQUU7SUFDVixPQUFPLEtBQUssQ0FBQTtHQUNkO0VBQ0EsSUFBSSxDQUFDLE1BQU0sU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQzNCLE9BQU8sS0FBSyxDQUFBO0dBQ2Q7RUFDQSxNQUFNLFFBQVEsV0FBVyxDQUFBO0VBQ3pCLE9BQU8sS0FBSyxRQUFRLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFBO0NBQ3ZDLENBQUE7QUFBQyxPQUFBLGVBQUEsR0FBQSxjQUFBLENBQUEiLCJmaWxlIjoiY29tbW9uLTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIEJ1ZmZlciA9IHdpbmRvdy5CdWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPCBudW1iZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgZW5kaWFuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW251bWJlciAmIDB4M2ZmZmZmZl07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4NEJpdHMgKHN0cmluZywgaW5kZXgpIHtcbiAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAvLyAnMCcgLSAnOSdcbiAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICByZXR1cm4gYyAtIDQ4O1xuICAgIC8vICdBJyAtICdGJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA2NSAmJiBjIDw9IDcwKSB7XG4gICAgICByZXR1cm4gYyAtIDU1O1xuICAgIC8vICdhJyAtICdmJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA5NyAmJiBjIDw9IDEwMikge1xuICAgICAgcmV0dXJuIGMgLSA4NztcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gJyArIHN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXhCeXRlIChzdHJpbmcsIGxvd2VyQm91bmQsIGluZGV4KSB7XG4gICAgdmFyIHIgPSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAtIDEgPj0gbG93ZXJCb3VuZCkge1xuICAgICAgciB8PSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXggLSAxKSA8PCA0O1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQsIGVuZGlhbikge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDI0LWJpdHMgY2h1bmtzXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZUxlbmd0aCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIGIgPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIGIgPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IGM7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYyA+PSAwICYmIGIgPCBtdWwsICdJbnZhbGlkIGNoYXJhY3RlcicpO1xuICAgICAgciArPSBiO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBmdW5jdGlvbiBtb3ZlIChkZXN0LCBzcmMpIHtcbiAgICBkZXN0LndvcmRzID0gc3JjLndvcmRzO1xuICAgIGRlc3QubGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gc3JjLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gc3JjLnJlZDtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uIF9tb3ZlIChkZXN0KSB7XG4gICAgbW92ZShkZXN0LCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLl9zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBDaGVjayBTeW1ib2wuZm9yIGJlY2F1c2Ugbm90IGV2ZXJ5d2hlcmUgd2hlcmUgU3ltYm9sIGRlZmluZWRcbiAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bWJvbCNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIEJOLnByb3RvdHlwZVtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGluc3BlY3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfVxuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZHJuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcbiAgfTtcblxuICBpZiAoQnVmZmVyKSB7XG4gICAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUgKEFycmF5VHlwZSwgc2l6ZSkge1xuICAgIGlmIChBcnJheVR5cGUuYWxsb2NVbnNhZmUpIHtcbiAgICAgIHJldHVybiBBcnJheVR5cGUuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHNpemUpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHZhciByZXMgPSBhbGxvY2F0ZShBcnJheVR5cGUsIHJlcUxlbmd0aCk7XG4gICAgdmFyIHBvc3RmaXggPSBlbmRpYW4gPT09ICdsZScgPyAnTEUnIDogJ0JFJztcbiAgICB0aGlzWydfdG9BcnJheUxpa2UnICsgcG9zdGZpeF0ocmVzLCBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VMRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUxFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICByZXNbcG9zaXRpb24rK10gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlQkUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VCRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24tLV0gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICByZXNbcG9zaXRpb24tLV0gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdID4+PiB3Yml0KSAmIDB4MDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgLy8gVGVtcG9yYXJ5IGRpc2FibGUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy9pc3N1ZXMvMjExXG4gICAgLy8gdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIC8vIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICAgIHJldHVybiBiaWdNdWxUbyhzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8PSBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLl9zdHJpcCgpO1xuICAgIH1cbiAgICBhLl9zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCAocjIgPT09IDEgJiYgY21wID09PSAwKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kcm4gPSBmdW5jdGlvbiBtb2RybiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyAtYWNjIDogYWNjO1xuICB9O1xuXG4gIC8vIFdBUk5JTkc6IERFUFJFQ0FURURcbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5tb2RybihudW0pO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY0IGluc3RhbmNlXG4gICAgICAgIHIuc3RyaXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NSBpbnN0YW5jZVxuICAgICAgICByLl9zdHJpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgbW92ZShhLCBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcykpO1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cy8nKVxuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTYWZlRXZlbnRFbWl0dGVyXG5cblxuZnVuY3Rpb24gU2FmZUV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbn1cblxudXRpbC5pbmhlcml0cyhTYWZlRXZlbnRFbWl0dGVyLCBFdmVudEVtaXR0ZXIpXG5cblNhZmVFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAvLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR296YWxhL2V2ZW50cy9ibG9iL21hc3Rlci9ldmVudHMuanNcbiAgLy8gbW9kaWZpZWQgbGluZXMgYXJlIGNvbW1lbnRlZCB3aXRoIFwiZWRpdGVkOlwiXG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlZGl0ZWQ6IHVzaW5nIHNhZmVBcHBseVxuICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgLy8gZWRpdGVkOiB1c2luZyBzYWZlQXBwbHlcbiAgICAgIHNhZmVBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHRocm93IGVycm9yIGFmdGVyIHRpbWVvdXQgc28gYXMgbm90IHRvIGludGVydXB0IHRoZSBzdGFja1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiIsImNvbnN0IEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xuXG5jb25zdCBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJylcbmNvbnN0IGVjcGFyYW1zID0gZWMuY3VydmVcblxuLy8gSGFjaywgd2UgY2FuIG5vdCB1c2UgYm4uanNANSwgd2hpbGUgZWxsaXB0aWMgdXNlcyBibi5qc0A0XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMvaXNzdWVzLzE5MSNpc3N1ZWNvbW1lbnQtNTY5ODg4NzU4XG5jb25zdCBCTiA9IGVjcGFyYW1zLm4uY29uc3RydWN0b3JcblxuZnVuY3Rpb24gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4YnVmKSB7XG4gIGxldCB4ID0gbmV3IEJOKHhidWYpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBjb21wdXRlIGNvcnJlc3BvbmRpbmcgWVxuICBsZXQgeSA9IHgucmVkU3FyKCkucmVkSU11bCh4KS5yZWRJQWRkKGVjcGFyYW1zLmIpLnJlZFNxcnQoKVxuICBpZiAoKGZpcnN0ID09PSAweDAzKSAhPT0geS5pc09kZCgpKSB5ID0geS5yZWROZWcoKVxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeGJ1ZiwgeWJ1Zikge1xuICBsZXQgeCA9IG5ldyBCTih4YnVmKVxuICBsZXQgeSA9IG5ldyBCTih5YnVmKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwIHx8IHkuY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG5cbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuICB5ID0geS50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gaXMgb2RkIGZsYWdcbiAgaWYgKChmaXJzdCA9PT0gMHgwNiB8fCBmaXJzdCA9PT0gMHgwNykgJiYgeS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKSByZXR1cm4gbnVsbFxuXG4gIC8vIHgqeCp4ICsgYiA9IHkqeVxuICBjb25zdCB4MyA9IHgucmVkU3FyKCkucmVkSU11bCh4KVxuICBpZiAoIXkucmVkU3FyKCkucmVkSVN1Yih4My5yZWRJQWRkKGVjcGFyYW1zLmIpKS5pc1plcm8oKSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFB1YmxpY0tleSAocHVia2V5KSB7XG4gIC8vIGxlbmd0aCBzaG91bGQgYmUgdmFsaWRhdGVkIGluIGludGVyZmFjZVxuICBjb25zdCBmaXJzdCA9IHB1YmtleVswXVxuICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgY2FzZSAweDAyOlxuICAgIGNhc2UgMHgwMzpcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSAzMykgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVia2V5LnN1YmFycmF5KDEsIDMzKSlcbiAgICBjYXNlIDB4MDQ6XG4gICAgY2FzZSAweDA2OlxuICAgIGNhc2UgMHgwNzpcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSA2NSkgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJrZXkuc3ViYXJyYXkoMSwgMzMpLCBwdWJrZXkuc3ViYXJyYXkoMzMsIDY1KSlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBzYXZlUHVibGljS2V5IChvdXRwdXQsIHBvaW50KSB7XG4gIGNvbnN0IHB1YmtleSA9IHBvaW50LmVuY29kZShudWxsLCBvdXRwdXQubGVuZ3RoID09PSAzMylcbiAgLy8gTG9vcCBzaG91bGQgYmUgZmFzdGVyIGJlY2F1c2Ugd2UgZG8gbm90IG5lZWQgY3JlYXRlIGV4dHJhIFVpbnQ4QXJyYXlcbiAgLy8gb3V0cHV0LnNldChuZXcgVWludDhBcnJheShwdWJrZXkpKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7ICsraSkgb3V0cHV0W2ldID0gcHVia2V5W2ldXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0UmFuZG9taXplICgpIHtcbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlWZXJpZnkgKHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICByZXR1cm4gYm4uY21wKGVjcGFyYW1zLm4pIDwgMCAmJiAhYm4uaXNaZXJvKCkgPyAwIDogMVxuICB9LFxuXG4gIHByaXZhdGVLZXlOZWdhdGUgKHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICBjb25zdCBuZWdhdGUgPSBlY3BhcmFtcy5uLnN1YihibikudW1vZChlY3BhcmFtcy5uKS50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KG5lZ2F0ZSlcbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlUd2Vha0FkZCAoc2Vja2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGJuLmlhZGQobmV3IEJOKHNlY2tleSkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibi5pc3ViKGVjcGFyYW1zLm4pXG4gICAgaWYgKGJuLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgY29uc3QgdHdlYWtlZCA9IGJuLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKVxuICAgIHNlY2tleS5zZXQodHdlYWtlZClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHJpdmF0ZUtleVR3ZWFrTXVsIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgbGV0IGJuID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGJuLmltdWwobmV3IEJOKHNlY2tleSkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibiA9IGJuLnVtb2QoZWNwYXJhbXMubilcblxuICAgIGNvbnN0IHR3ZWFrZWQgPSBibi50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KHR3ZWFrZWQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVZlcmlmeSAocHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIHJldHVybiBwYWlyID09PSBudWxsID8gMSA6IDBcbiAgfSxcblxuICBwdWJsaWNLZXlDcmVhdGUgKG91dHB1dCwgc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHBvaW50ID0gZWMua2V5RnJvbVByaXZhdGUoc2Vja2V5KS5nZXRQdWJsaWMoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q29udmVydCAob3V0cHV0LCBwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleU5lZ2F0ZSAob3V0cHV0LCBwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBwb2ludC55ID0gcG9pbnQueS5yZWROZWcoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q29tYmluZSAob3V0cHV0LCBwdWJrZXlzKSB7XG4gICAgY29uc3QgcGFpcnMgPSBuZXcgQXJyYXkocHVia2V5cy5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwYWlyc1tpXSA9IGxvYWRQdWJsaWNLZXkocHVia2V5c1tpXSlcbiAgICAgIGlmIChwYWlyc1tpXSA9PT0gbnVsbCkgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZXQgcG9pbnQgPSBwYWlyc1swXS5nZXRQdWJsaWMoKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFpcnMubGVuZ3RoOyArK2kpIHBvaW50ID0gcG9pbnQuYWRkKHBhaXJzW2ldLnB1YilcbiAgICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSByZXR1cm4gMlxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlUd2Vha0FkZCAob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLmFkZChlY3BhcmFtcy5nLm11bCh0d2VhaykpXG4gICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgcmV0dXJuIDJcblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VHdlYWtNdWwgKG91dHB1dCwgcHVia2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCB0d2Vhay5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5tdWwodHdlYWspXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBzaWduYXR1cmVOb3JtYWxpemUgKHNpZykge1xuICAgIGNvbnN0IHIgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDAsIDMyKSlcbiAgICBjb25zdCBzID0gbmV3IEJOKHNpZy5zdWJhcnJheSgzMiwgNjQpKVxuICAgIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHMuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBpZiAocy5jbXAoZWMubmgpID09PSAxKSB7XG4gICAgICBzaWcuc2V0KGVjcGFyYW1zLm4uc3ViKHMpLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG4gICAgfVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICAvLyBDb3BpZWQgMS10by0xIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXA2Ni9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAvLyBBZGFwdGVkIGZvciBVaW50OEFycmF5IGluc3RlYWQgQnVmZmVyXG4gIHNpZ25hdHVyZUV4cG9ydCAob2JqLCBzaWcpIHtcbiAgICBjb25zdCBzaWdSID0gc2lnLnN1YmFycmF5KDAsIDMyKVxuICAgIGNvbnN0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoMzIsIDY0KVxuICAgIGlmIChuZXcgQk4oc2lnUikuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG4gICAgaWYgKG5ldyBCTihzaWdTKS5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHsgb3V0cHV0IH0gPSBvYmpcblxuICAgIC8vIFByZXBhcmUgUlxuICAgIGxldCByID0gb3V0cHV0LnN1YmFycmF5KDQsIDQgKyAzMylcbiAgICByWzBdID0gMHgwMFxuICAgIHIuc2V0KHNpZ1IsIDEpXG5cbiAgICBsZXQgbGVuUiA9IDMzXG4gICAgbGV0IHBvc1IgPSAwXG4gICAgZm9yICg7IGxlblIgPiAxICYmIHJbcG9zUl0gPT09IDB4MDAgJiYgIShyW3Bvc1IgKyAxXSAmIDB4ODApOyAtLWxlblIsICsrcG9zUik7XG5cbiAgICByID0gci5zdWJhcnJheShwb3NSKVxuICAgIGlmIChyWzBdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUiA+IDEgJiYgKHJbMF0gPT09IDB4MDApICYmICEoclsxXSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgLy8gUHJlcGFyZSBTXG4gICAgbGV0IHMgPSBvdXRwdXQuc3ViYXJyYXkoNiArIDMzLCA2ICsgMzMgKyAzMylcbiAgICBzWzBdID0gMHgwMFxuICAgIHMuc2V0KHNpZ1MsIDEpXG5cbiAgICBsZXQgbGVuUyA9IDMzXG4gICAgbGV0IHBvc1MgPSAwXG4gICAgZm9yICg7IGxlblMgPiAxICYmIHNbcG9zU10gPT09IDB4MDAgJiYgIShzW3Bvc1MgKyAxXSAmIDB4ODApOyAtLWxlblMsICsrcG9zUyk7XG5cbiAgICBzID0gcy5zdWJhcnJheShwb3NTKVxuICAgIGlmIChzWzBdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUyA+IDEgJiYgKHNbMF0gPT09IDB4MDApICYmICEoc1sxXSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgLy8gU2V0IG91dHB1dCBsZW5ndGggZm9yIHJldHVyblxuICAgIG9iai5vdXRwdXRsZW4gPSA2ICsgbGVuUiArIGxlblNcblxuICAgIC8vIE91dHB1dCBpbiBzcGVjaWZpZWQgZm9ybWF0XG4gICAgLy8gMHgzMCBbdG90YWwtbGVuZ3RoXSAweDAyIFtSLWxlbmd0aF0gW1JdIDB4MDIgW1MtbGVuZ3RoXSBbU11cbiAgICBvdXRwdXRbMF0gPSAweDMwXG4gICAgb3V0cHV0WzFdID0gb2JqLm91dHB1dGxlbiAtIDJcbiAgICBvdXRwdXRbMl0gPSAweDAyXG4gICAgb3V0cHV0WzNdID0gci5sZW5ndGhcbiAgICBvdXRwdXQuc2V0KHIsIDQpXG4gICAgb3V0cHV0WzQgKyBsZW5SXSA9IDB4MDJcbiAgICBvdXRwdXRbNSArIGxlblJdID0gcy5sZW5ndGhcbiAgICBvdXRwdXQuc2V0KHMsIDYgKyBsZW5SKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICAvLyBDb3BpZWQgMS10by0xIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXA2Ni9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAvLyBBZGFwdGVkIGZvciBVaW50OEFycmF5IGluc3RlYWQgQnVmZmVyXG4gIHNpZ25hdHVyZUltcG9ydCAob3V0cHV0LCBzaWcpIHtcbiAgICBpZiAoc2lnLmxlbmd0aCA8IDgpIHJldHVybiAxXG4gICAgaWYgKHNpZy5sZW5ndGggPiA3MikgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzBdICE9PSAweDMwKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMV0gIT09IHNpZy5sZW5ndGggLSAyKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMl0gIT09IDB4MDIpIHJldHVybiAxXG5cbiAgICBjb25zdCBsZW5SID0gc2lnWzNdXG4gICAgaWYgKGxlblIgPT09IDApIHJldHVybiAxXG4gICAgaWYgKDUgKyBsZW5SID49IHNpZy5sZW5ndGgpIHJldHVybiAxXG4gICAgaWYgKHNpZ1s0ICsgbGVuUl0gIT09IDB4MDIpIHJldHVybiAxXG5cbiAgICBjb25zdCBsZW5TID0gc2lnWzUgKyBsZW5SXVxuICAgIGlmIChsZW5TID09PSAwKSByZXR1cm4gMVxuICAgIGlmICgoNiArIGxlblIgKyBsZW5TKSAhPT0gc2lnLmxlbmd0aCkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdbNF0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5SID4gMSAmJiAoc2lnWzRdID09PSAweDAwKSAmJiAhKHNpZ1s1XSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ1tsZW5SICsgNl0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5TID4gMSAmJiAoc2lnW2xlblIgKyA2XSA9PT0gMHgwMCkgJiYgIShzaWdbbGVuUiArIDddICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnUiA9IHNpZy5zdWJhcnJheSg0LCA0ICsgbGVuUilcbiAgICBpZiAoc2lnUi5sZW5ndGggPT09IDMzICYmIHNpZ1JbMF0gPT09IDB4MDApIHNpZ1IgPSBzaWdSLnN1YmFycmF5KDEpXG4gICAgaWYgKHNpZ1IubGVuZ3RoID4gMzIpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnUyA9IHNpZy5zdWJhcnJheSg2ICsgbGVuUilcbiAgICBpZiAoc2lnUy5sZW5ndGggPT09IDMzICYmIHNpZ1NbMF0gPT09IDB4MDApIHNpZ1MgPSBzaWdTLnNsaWNlKDEpXG4gICAgaWYgKHNpZ1MubGVuZ3RoID4gMzIpIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgdG9vIGxvbmcnKVxuXG4gICAgbGV0IHIgPSBuZXcgQk4oc2lnUilcbiAgICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCkgciA9IG5ldyBCTigwKVxuXG4gICAgbGV0IHMgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDYgKyBsZW5SKSlcbiAgICBpZiAocy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcyA9IG5ldyBCTigwKVxuXG4gICAgb3V0cHV0LnNldChyLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMClcbiAgICBvdXRwdXQuc2V0KHMudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMilcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkc2FTaWduIChvYmosIG1lc3NhZ2UsIHNlY2tleSwgZGF0YSwgbm9uY2Vmbikge1xuICAgIGlmIChub25jZWZuKSB7XG4gICAgICBjb25zdCBfbm9uY2VmbiA9IG5vbmNlZm5cbiAgICAgIG5vbmNlZm4gPSAoY291bnRlcikgPT4ge1xuICAgICAgICBjb25zdCBub25jZSA9IF9ub25jZWZuKG1lc3NhZ2UsIHNlY2tleSwgbnVsbCwgZGF0YSwgY291bnRlcilcblxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gbm9uY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG5vbmNlLmxlbmd0aCA9PT0gMzJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgdGhlIHdheScpXG5cbiAgICAgICAgcmV0dXJuIG5ldyBCTihub25jZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1xuICAgIHRyeSB7XG4gICAgICBzaWcgPSBlYy5zaWduKG1lc3NhZ2UsIHNlY2tleSwgeyBjYW5vbmljYWw6IHRydWUsIGs6IG5vbmNlZm4sIHBlcnM6IGRhdGEgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgb2JqLnNpZ25hdHVyZS5zZXQoc2lnLnIudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAwKVxuICAgIG9iai5zaWduYXR1cmUuc2V0KHNpZy5zLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG4gICAgb2JqLnJlY2lkID0gc2lnLnJlY292ZXJ5UGFyYW1cblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkc2FWZXJpZnkgKHNpZywgbXNnMzIsIHB1YmtleSkge1xuICAgIGNvbnN0IHNpZ09iaiA9IHsgcjogc2lnLnN1YmFycmF5KDAsIDMyKSwgczogc2lnLnN1YmFycmF5KDMyLCA2NCkgfVxuXG4gICAgY29uc3Qgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgICBjb25zdCBzaWdzID0gbmV3IEJOKHNpZ09iai5zKVxuICAgIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG4gICAgaWYgKHNpZ3MuY21wKGVjLm5oKSA9PT0gMSB8fCBzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiAzXG5cbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBjb25zdCBpc1ZhbGlkID0gZWMudmVyaWZ5KG1zZzMyLCBzaWdPYmosIHBvaW50KVxuICAgIHJldHVybiBpc1ZhbGlkID8gMCA6IDNcbiAgfSxcblxuICBlY2RzYVJlY292ZXIgKG91dHB1dCwgc2lnLCByZWNpZCwgbXNnMzIpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IHNpZy5zbGljZSgwLCAzMiksIHM6IHNpZy5zbGljZSgzMiwgNjQpIH1cblxuICAgIGNvbnN0IHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gICAgY29uc3Qgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIC8vIENhbiB0aHJvdyBgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtgXG4gICAgbGV0IHBvaW50XG4gICAgdHJ5IHtcbiAgICAgIHBvaW50ID0gZWMucmVjb3ZlclB1YktleShtc2czMiwgc2lnT2JqLCByZWNpZClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBlY2RoIChvdXRwdXQsIHB1YmtleSwgc2Vja2V5LCBkYXRhLCBoYXNoZm4sIHhidWYsIHlidWYpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBzY2FsYXIgPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChzY2FsYXIuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLm11bChzY2FsYXIpXG5cbiAgICBpZiAoaGFzaGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBwb2ludC5lbmNvZGUobnVsbCwgdHJ1ZSlcbiAgICAgIGNvbnN0IHNoYTI1NiA9IGVjLmhhc2goKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgb3V0cHV0W2ldID0gc2hhMjU2W2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgheGJ1ZikgeGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgY29uc3QgeCA9IHBvaW50LmdldFgoKS50b0FycmF5KCdiZScsIDMyKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSB4YnVmW2ldID0geFtpXVxuXG4gICAgICBpZiAoIXlidWYpIHlidWYgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNvbnN0IHkgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnYmUnLCAzMilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgeWJ1ZltpXSA9IHlbaV1cblxuICAgICAgY29uc3QgaGFzaCA9IGhhc2hmbih4YnVmLCB5YnVmLCBkYXRhKVxuXG4gICAgICBjb25zdCBpc1ZhbGlkID0gaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaGFzaC5sZW5ndGggPT09IG91dHB1dC5sZW5ndGhcbiAgICAgIGlmICghaXNWYWxpZCkgcmV0dXJuIDJcblxuICAgICAgb3V0cHV0LnNldChoYXNoKVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH1cbn1cbiIsImNvbnN0IGVycm9ycyA9IHtcbiAgSU1QT1NTSUJMRV9DQVNFOiAnSW1wb3NzaWJsZSBjYXNlLiBQbGVhc2UgY3JlYXRlIGlzc3VlLicsXG4gIFRXRUFLX0FERDpcbiAgICAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgdGhlIHJlc3VsdGVkIHByaXZhdGUga2V5IGlzIGludmFsaWQnLFxuICBUV0VBS19NVUw6ICdUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciBlcXVhbCB0byB6ZXJvJyxcbiAgQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XOiAnVW5rbm93IGVycm9yIG9uIGNvbnRleHQgcmFuZG9taXphdGlvbicsXG4gIFNFQ0tFWV9JTlZBTElEOiAnUHJpdmF0ZSBLZXkgaXMgaW52YWxpZCcsXG4gIFBVQktFWV9QQVJTRTogJ1B1YmxpYyBLZXkgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFBVQktFWV9TRVJJQUxJWkU6ICdQdWJsaWMgS2V5IHNlcmlhbGl6YXRpb24gZXJyb3InLFxuICBQVUJLRVlfQ09NQklORTogJ1RoZSBzdW0gb2YgdGhlIHB1YmxpYyBrZXlzIGlzIG5vdCB2YWxpZCcsXG4gIFNJR19QQVJTRTogJ1NpZ25hdHVyZSBjb3VsZCBub3QgYmUgcGFyc2VkJyxcbiAgU0lHTjogJ1RoZSBub25jZSBnZW5lcmF0aW9uIGZ1bmN0aW9uIGZhaWxlZCwgb3IgdGhlIHByaXZhdGUga2V5IHdhcyBpbnZhbGlkJyxcbiAgUkVDT1ZFUjogJ1B1YmxpYyBrZXkgY291bGQgbm90IGJlIHJlY292ZXInLFxuICBFQ0RIOiAnU2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KSdcbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IobXNnKVxufVxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkgKG5hbWUsIHZhbHVlLCBsZW5ndGgpIHtcbiAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSwgYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheWApXG5cbiAgaWYgKGxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVuZ3RoKSkge1xuICAgICAgY29uc3QgbnVtYmVycyA9IGxlbmd0aC5qb2luKCcsICcpXG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoIFske251bWJlcnN9XWBcbiAgICAgIGFzc2VydChsZW5ndGguaW5jbHVkZXModmFsdWUubGVuZ3RoKSwgbXNnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoICR7bGVuZ3RofWBcbiAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IGxlbmd0aCwgbXNnKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbXByZXNzZWQgKHZhbHVlKSB7XG4gIGFzc2VydCh0b1R5cGVTdHJpbmcodmFsdWUpID09PSAnQm9vbGVhbicsICdFeHBlY3RlZCBjb21wcmVzc2VkIHRvIGJlIGEgQm9vbGVhbicpXG59XG5cbmZ1bmN0aW9uIGdldEFzc2VydGVkT3V0cHV0IChvdXRwdXQgPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpIG91dHB1dCA9IG91dHB1dChsZW5ndGgpXG4gIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0LCBsZW5ndGgpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gdG9UeXBlU3RyaW5nICh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc2VjcDI1NmsxKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dFJhbmRvbWl6ZSAoc2VlZCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBzZWVkID09PSBudWxsIHx8IHNlZWQgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgICAnRXhwZWN0ZWQgc2VlZCB0byBiZSBhbiBVaW50OEFycmF5IG9yIG51bGwnXG4gICAgICApXG4gICAgICBpZiAoc2VlZCAhPT0gbnVsbCkgaXNVaW50OEFycmF5KCdzZWVkJywgc2VlZCwgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmNvbnRleHRSYW5kb21pemUoc2VlZCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VmVyaWZ5IChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoc2Vja2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TmVnYXRlIChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtBZGQgKHNlY2tleSwgdHdlYWspIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHNlY2tleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrTXVsIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha011bChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVZlcmlmeSAocHVia2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJrZXkpID09PSAwXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNyZWF0ZSAoc2Vja2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKG91dHB1dCwgc2Vja2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TRUNLRVlfSU5WQUxJRClcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29udmVydCAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleU5lZ2F0ZSAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlOZWdhdGUob3V0cHV0LCBwdWJrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb21iaW5lIChwdWJrZXlzLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwdWJrZXlzKSwgJ0V4cGVjdGVkIHB1YmxpYyBrZXlzIHRvIGJlIGFuIEFycmF5JylcbiAgICAgIGFzc2VydChwdWJrZXlzLmxlbmd0aCA+IDAsICdFeHBlY3RlZCBwdWJsaWMga2V5cyBhcnJheSB3aWxsIGhhdmUgbW9yZSB0aGFuIHplcm8gaXRlbXMnKVxuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgfVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKG91dHB1dCwgcHVia2V5cykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfQ09NQklORSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtBZGQgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfQUREKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha011bCAocHVia2V5LCB0d2VhaywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKG91dHB1dCwgcHVia2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZU5vcm1hbGl6ZSAoc2lnKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3NpZ25hdHVyZScsIHNpZywgNjQpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2lnXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlRXhwb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA3MilcblxuICAgICAgY29uc3Qgb2JqID0geyBvdXRwdXQsIG91dHB1dGxlbjogNzIgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KG9iaiwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCBvYmoub3V0cHV0bGVuKVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQob3V0cHV0LCBzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RzYVNpZ24gKG1zZzMyLCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gIT09IHVuZGVmaW5lZCkgYXNzZXJ0KHRvVHlwZVN0cmluZyhvcHRpb25zLm5vbmNlZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5ub25jZWZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgY29uc3Qgb2JqID0geyBzaWduYXR1cmU6IG91dHB1dCwgcmVjaWQ6IG51bGwgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FTaWduKG9iaiwgbXNnMzIsIHNlY2tleSwgb3B0aW9ucy5kYXRhLCBvcHRpb25zLm5vbmNlZm4pKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR04pXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FWZXJpZnkgKHNpZywgbXNnMzIsIHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FWZXJpZnkoc2lnLCBtc2czMiwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FSZWNvdmVyIChzaWcsIHJlY2lkLCBtc2czMiwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgYXNzZXJ0KFxuICAgICAgICB0b1R5cGVTdHJpbmcocmVjaWQpID09PSAnTnVtYmVyJyAmJlxuICAgICAgICAgIHJlY2lkID49IDAgJiZcbiAgICAgICAgICByZWNpZCA8PSAzLFxuICAgICAgICAnRXhwZWN0ZWQgcmVjb3ZlcnkgaWQgdG8gYmUgYSBOdW1iZXIgd2l0aGluIGludGVydmFsIFswLCAzXSdcbiAgICAgIClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FSZWNvdmVyKG91dHB1dCwgc2lnLCByZWNpZCwgbXNnMzIpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUkVDT1ZFUilcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RoIChwdWJrZXksIHNlY2tleSwgb3B0aW9ucyA9IHt9LCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLmhhc2hmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5oYXNoZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5oYXNoZm4gdG8gYmUgYSBGdW5jdGlvbicpXG4gICAgICAgIGlmIChvcHRpb25zLnhidWYgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLnhidWYnLCBvcHRpb25zLnhidWYsIDMyKVxuICAgICAgICBpZiAob3B0aW9ucy55YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy55YnVmJywgb3B0aW9ucy55YnVmLCAzMilcbiAgICAgICAgaXNVaW50OEFycmF5KCdvdXRwdXQnLCBvdXRwdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDMyKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5lY2RoKG91dHB1dCwgcHVia2V5LCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5oYXNoZm4sIG9wdGlvbnMueGJ1Ziwgb3B0aW9ucy55YnVmKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkVDREgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpXG4gICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlcyB3aGVyZSBub3RoaW5nIGNhbiBwb3NzaWJseSBiZSBsb3dlclxuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZSA9PT0gJzwwLjAuMC0wJyB8fCBjb21wLnZhbHVlID09PSAnPDAuMC4wLTAnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykgfHwgY29tcC52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGluY3JlYXNpbmcgKD4gb3IgPj0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBkZWNyZWFzaW5nICg8IG9yIDw9KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gc2FtZSBTZW1WZXIgYW5kIGJvdGggc2lkZXMgYXJlIGluY2x1c2l2ZSAoPD0gb3IgPj0pXG4gICAgaWYgKFxuICAgICAgKHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb24pICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykgJiYgY29tcC5vcGVyYXRvci5pbmNsdWRlcygnPScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGxlc3MgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBncmVhdGVyIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyYXRvclxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwiLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgdGhpcy5zZXQgPSByYW5nZVxuICAgICAgLnNwbGl0KCd8fCcpXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAociA9PiB0aGlzLnBhcnNlUmFuZ2Uoci50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpXG5cbiAgICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7cmFuZ2V9YClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSBub3QgdGhlIG51bGwgc2V0LCB0aHJvdyBvdXQgbnVsbCBzZXRzLlxuICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBrZWVwIHRoZSBmaXJzdCBvbmUsIGluIGNhc2UgdGhleSdyZSBhbGwgbnVsbCBzZXRzXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2V0WzBdXG4gICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmZpbHRlcihjID0+ICFpc051bGxTZXQoY1swXSkpXG4gICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlICosIHRoZW4gdGhlIHJhbmdlIGlzIGp1c3QgKlxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gW2NdXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0XG4gICAgICAubWFwKChjb21wcykgPT4ge1xuICAgICAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKVxuICAgICAgfSlcbiAgICAgIC5qb2luKCd8fCcpXG4gICAgICAudHJpbSgpXG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgcGFyc2VSYW5nZSAocmFuZ2UpIHtcbiAgICByYW5nZSA9IHJhbmdlLnRyaW0oKVxuXG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSkgfFxuICAgICAgKHRoaXMub3B0aW9ucy5sb29zZSAmJiBGTEFHX0xPT1NFKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArICc6JyArIHJhbmdlXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gICAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJylcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGxldCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICBpZiAobG9vc2UpIHtcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICByYW5nZUxpc3QgPSByYW5nZUxpc3QuZmlsdGVyKGNvbXAgPT4ge1xuICAgICAgICBkZWJ1ZygnbG9vc2UgaW52YWxpZCBmaWx0ZXInLCBjb21wLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmVbdC5DT01QQVJBVE9STE9PU0VdKVxuICAgICAgfSlcbiAgICB9XG4gICAgZGVidWcoJ3JhbmdlIGxpc3QnLCByYW5nZUxpc3QpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlTGlzdC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wYXJhdG9ycykge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSkge1xuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICB9XG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpIHtcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVxuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKVxuY29uc3QgY2FjaGUgPSBuZXcgTFJVKHsgbWF4OiAxMDAwIH0pXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgcmUsXG4gIHQsXG4gIGNvbXBhcmF0b3JUcmltUmVwbGFjZSxcbiAgdGlsZGVUcmltUmVwbGFjZSxcbiAgY2FyZXRUcmltUmVwbGFjZSxcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCB7IEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFLCBGTEFHX0xPT1NFIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tID4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLSA+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0gPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tID4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tID4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tID4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjAuMC4xIC0tID4gPj0wLjAuMSA8MC4xLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLSA+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tID4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tID4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tID4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjEuMi4zIC0tID4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tID4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tID4gPj0wLjAuMSA8MC4wLjItMFxuLy8gXjAuMS4wIC0tID4gPj0wLjEuMCA8MC4yLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKChjKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICBwciA9ICctMCdcbiAgICAgIH1cblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7cmVxdWlyZSgndXRpbCcpLmluc3BlY3QodmVyc2lvbil9YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgZW1wdHknKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLmZvcm1hdCgpXG4gICAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiIsImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3B9YClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBjbXBcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcGFyc2UoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgJzAnfS4ke21hdGNoWzRdIHx8ICcwJ31gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xLCBudWxsLCB0cnVlKVxuICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yLCBudWxsLCB0cnVlKVxuICBjb25zdCBjb21wYXJpc29uID0gdjEuY29tcGFyZSh2MilcblxuICBpZiAoY29tcGFyaXNvbiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB2MUhpZ2hlciA9IGNvbXBhcmlzb24gPiAwXG4gIGNvbnN0IGhpZ2hWZXJzaW9uID0gdjFIaWdoZXIgPyB2MSA6IHYyXG4gIGNvbnN0IGxvd1ZlcnNpb24gPSB2MUhpZ2hlciA/IHYyIDogdjFcbiAgY29uc3QgaGlnaEhhc1ByZSA9ICEhaGlnaFZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGhcblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHdlIGtub3cgc3RhYmxlIHZlcnNpb25zIG1hdGNoIGJ1dCBvdmVyYWxsIHZlcnNpb25zIGFyZSBub3QgZXF1YWwsXG4gIC8vIHNvIGVpdGhlciB0aGV5IGFyZSBib3RoIHByZXJlbGVhc2VzLCBvciB0aGUgbG93ZXIgdmVyc2lvbiBpcyBhIHByZXJlbGVhc2VcblxuICBpZiAoaGlnaEhhc1ByZSkge1xuICAgIC8vIGhpZ2ggYW5kIGxvdyBhcmUgcHJlbGVhc2VzXG4gICAgcmV0dXJuICdwcmVyZWxlYXNlJ1xuICB9XG5cbiAgaWYgKGxvd1ZlcnNpb24ucGF0Y2gpIHtcbiAgICAvLyBhbnl0aGluZyBoaWdoZXIgdGhhbiBhIHBhdGNoIGJ1bXAgd291bGQgcmVzdWx0IGluIHRoZSB3cm9uZyB2ZXJzaW9uXG4gICAgcmV0dXJuICdwYXRjaCdcbiAgfVxuXG4gIGlmIChsb3dWZXJzaW9uLm1pbm9yKSB7XG4gICAgLy8gYW55dGhpbmcgaGlnaGVyIHRoYW4gYSBtaW5vciBidW1wIHdvdWxkIHJlc3VsdCBpbiB0aGUgd3JvbmcgdmVyc2lvblxuICAgIHJldHVybiAnbWlub3InXG4gIH1cblxuICAvLyBidW1waW5nIG1ham9yL21pbm9yL3BhdGNoIGFsbCBoYXZlIHNhbWUgcmVzdWx0XG4gIHJldHVybiAnbWFqb3InXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyQmFzZSA9IGlkZW50aWZpZXJcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIoXG4gICAgICB2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyID8gdmVyc2lvbi52ZXJzaW9uIDogdmVyc2lvbixcbiAgICAgIG9wdGlvbnNcbiAgICApLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMsIHRocm93RXJyb3JzID0gZmFsc2UpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoIXRocm93RXJyb3JzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aHJvdyBlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsIi8vIGp1c3QgcHJlLWxvYWQgYWxsIHRoZSBzdHVmZiB0aGF0IGluZGV4LmpzIGxhemlseSBleHBvcnRzXG5jb25zdCBpbnRlcm5hbFJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGlkZW50aWZpZXJzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKVxuY29uc3QgY2xlYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbGVhbicpXG5jb25zdCBpbmMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKVxuY29uc3QgZGlmZiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKVxuY29uc3QgbWFqb3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9tYWpvcicpXG5jb25zdCBtaW5vciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJylcbmNvbnN0IHBhdGNoID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKVxuY29uc3QgcHJlcmVsZWFzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ByZXJlbGVhc2UnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKVxuY29uc3QgcnNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yc29ydCcpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgY29lcmNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgdG9Db21wYXJhdG9ycyA9IHJlcXVpcmUoJy4vcmFuZ2VzL3RvLWNvbXBhcmF0b3JzJylcbmNvbnN0IG1heFNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKVxuY29uc3QgbWluVmVyc2lvbiA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi12ZXJzaW9uJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpXG5jb25zdCBndHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9ndHInKVxuY29uc3QgbHRyID0gcmVxdWlyZSgnLi9yYW5nZXMvbHRyJylcbmNvbnN0IGludGVyc2VjdHMgPSByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJylcbmNvbnN0IHNpbXBsaWZ5UmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy9zaW1wbGlmeScpXG5jb25zdCBzdWJzZXQgPSByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlLFxuICB2YWxpZCxcbiAgY2xlYW4sXG4gIGluYyxcbiAgZGlmZixcbiAgbWFqb3IsXG4gIG1pbm9yLFxuICBwYXRjaCxcbiAgcHJlcmVsZWFzZSxcbiAgY29tcGFyZSxcbiAgcmNvbXBhcmUsXG4gIGNvbXBhcmVMb29zZSxcbiAgY29tcGFyZUJ1aWxkLFxuICBzb3J0LFxuICByc29ydCxcbiAgZ3QsXG4gIGx0LFxuICBlcSxcbiAgbmVxLFxuICBndGUsXG4gIGx0ZSxcbiAgY21wLFxuICBjb2VyY2UsXG4gIENvbXBhcmF0b3IsXG4gIFJhbmdlLFxuICBzYXRpc2ZpZXMsXG4gIHRvQ29tcGFyYXRvcnMsXG4gIG1heFNhdGlzZnlpbmcsXG4gIG1pblNhdGlzZnlpbmcsXG4gIG1pblZlcnNpb24sXG4gIHZhbGlkUmFuZ2UsXG4gIG91dHNpZGUsXG4gIGd0cixcbiAgbHRyLFxuICBpbnRlcnNlY3RzLFxuICBzaW1wbGlmeVJhbmdlLFxuICBzdWJzZXQsXG4gIFNlbVZlcixcbiAgcmU6IGludGVybmFsUmUucmUsXG4gIHNyYzogaW50ZXJuYWxSZS5zcmMsXG4gIHRva2VuczogaW50ZXJuYWxSZS50LFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OOiBjb25zdGFudHMuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgUkVMRUFTRV9UWVBFUzogY29uc3RhbnRzLlJFTEVBU0VfVFlQRVMsXG4gIGNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiBpZGVudGlmaWVycy5yY29tcGFyZUlkZW50aWZpZXJzLFxufVxuIiwiLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG5jb25zdCBSRUxFQVNFX1RZUEVTID0gW1xuICAnbWFqb3InLFxuICAncHJlbWFqb3InLFxuICAnbWlub3InLFxuICAncHJlbWlub3InLFxuICAncGF0Y2gnLFxuICAncHJlcGF0Y2gnLFxuICAncHJlcmVsZWFzZScsXG5dXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBSRUxFQVNFX1RZUEVTLFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRTogMGIwMDEsXG4gIEZMQUdfTE9PU0U6IDBiMDEwLFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBcIlwiICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KFwiXCIpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsIi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXRcbmNvbnN0IGxvb3NlT3B0aW9uID0gT2JqZWN0LmZyZWV6ZSh7IGxvb3NlOiB0cnVlIH0pXG5jb25zdCBlbXB0eU9wdHMgPSBPYmplY3QuZnJlZXplKHsgfSlcbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gZW1wdHlPcHRzXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGxvb3NlT3B0aW9uXG4gIH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZU9wdGlvbnNcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKG5hbWUsIGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnWzAtOV0rJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wXFxcXHMqJCcpXG5jcmVhdGVUb2tlbignR1RFMFBSRScsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wLTBcXFxccyokJylcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbmNvbnN0IE1BWCA9IFN5bWJvbCgnbWF4JylcbmNvbnN0IExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJylcbmNvbnN0IExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbmNvbnN0IEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJylcbmNvbnN0IE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpXG5jb25zdCBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJylcbmNvbnN0IE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpXG5jb25zdCBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKVxuY29uc3QgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0JylcblxuY29uc3QgbmFpdmVMZW5ndGggPSAoKSA9PiAxXG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIGNvbnN0IG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG5cbiAgICBjb25zdCBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSA/IG5haXZlTGVuZ3RoIDogbGNcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2VcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXggKG1MKSB7XG4gICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXggKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfVxuXG4gIHNldCBhbGxvd1N0YWxlIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH1cblxuICBzZXQgbWF4QWdlIChtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4QWdlICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpXG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG5cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IgKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfVxuXG4gIGdldCBsZW5ndGggKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH1cbiAgZ2V0IGl0ZW1Db3VudCAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLmtleSlcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4gdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpKVxuICAgIH1cblxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gICAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChoaXQgPT5cbiAgICAgIGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSkudG9BcnJheSgpLmZpbHRlcihoID0+IGgpXG4gIH1cblxuICBkdW1wTHJ1ICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG5cbiAgICBjb25zdCBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICAgIGNvbnN0IGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgICBjb25zdCBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSlcbiAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaXRlbS5ub3cgPSBub3dcbiAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICAgIHRoaXMuZ2V0KGtleSlcbiAgICAgIHRyaW0odGhpcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBoYXMgKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG4gIH1cblxuICBwZWVrIChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGRlbCh0aGlzLCBub2RlKVxuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cblxuICBkZWwgKGtleSkge1xuICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgY29uc3QgaGl0ID0gYXJyW2xdXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgICBpZiAoZXhwaXJlc0F0ID09PSAwKVxuICAgICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJ1bmUgKCkge1xuICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSlcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoc2VsZiwga2V5LCBkb1VzZSkgPT4ge1xuICBjb25zdCBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBpZiAoc2VsZltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpXG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQudmFsdWVcbiAgfVxufVxuXG5jb25zdCBpc1N0YWxlID0gKHNlbGYsIGhpdCkgPT4ge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICByZXR1cm4gaGl0Lm1heEFnZSA/IGRpZmYgPiBoaXQubWF4QWdlXG4gICAgOiBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbn1cblxuY29uc3QgdHJpbSA9IHNlbGYgPT4ge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVsID0gKHNlbGYsIG5vZGUpID0+IHtcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pXG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcblxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbmNsYXNzIEVudHJ5IHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5ub3cgPSBub3dcbiAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG4gIH1cbn1cblxuY29uc3QgZm9yRWFjaFN0ZXAgPSAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSA9PiB7XG4gIGxldCBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKGhpdClcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsIi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuY29uc3QgZ3RyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGd0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsImNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5jb25zdCBsdHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gbHRyXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSkge1xuICAgICAgbWludmVyID0gc2V0TWluXG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZS5qcycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yLmpzJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5cbi8vIENvbXBsZXggcmFuZ2UgYHIxIHx8IHIyIHx8IC4uLmAgaXMgYSBzdWJzZXQgb2YgYFIxIHx8IFIyIHx8IC4uLmAgaWZmOlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCBpcyBhIG51bGwgc2V0LCBPUlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCB3aGljaCBpcyBub3QgYSBudWxsIHNldCBpcyBhIHN1YnNldCBvZlxuLy8gICBzb21lIGBSMSwgUjIsIC4uLmBcbi8vXG4vLyBTaW1wbGUgcmFuZ2UgYGMxIGMyIC4uLmAgaXMgYSBzdWJzZXQgb2Ygc2ltcGxlIHJhbmdlIGBDMSBDMiAuLi5gIGlmZjpcbi8vIC0gSWYgYyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3IsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiBmYWxzZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBjIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIHRydWVcbi8vICAgLSBlbHNlIHJlcGxhY2UgQyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIExldCBFUSBiZSB0aGUgc2V0IG9mID0gY29tcGFyYXRvcnMgaW4gY1xuLy8gLSBJZiBFUSBpcyBtb3JlIHRoYW4gb25lLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIExldCBHVCBiZSB0aGUgaGlnaGVzdCA+IG9yID49IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBMZXQgTFQgYmUgdGhlIGxvd2VzdCA8IG9yIDw9IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBJZiBHVCBhbmQgTFQsIGFuZCBHVC5zZW12ZXIgPiBMVC5zZW12ZXIsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gSWYgYW55IEMgaXMgYSA9IHJhbmdlLCBhbmQgR1Qgb3IgTFQgYXJlIHNldCwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEVRXG4vLyAgIC0gSWYgR1QsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IEdULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgTFQsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IExULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgRVEgc2F0aXNmaWVzIGV2ZXJ5IEMsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgR1Rcbi8vICAgLSBJZiBHVC5zZW12ZXIgaXMgbG93ZXIgdGhhbiBhbnkgPiBvciA+PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdUIGlzID49LCBhbmQgR1Quc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBHVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBMVFxuLy8gICAtIElmIExULnNlbXZlciBpcyBncmVhdGVyIHRoYW4gYW55IDwgb3IgPD0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBMVCBpcyA8PSwgYW5kIExULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgTFQuc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gRWxzZSByZXR1cm4gdHJ1ZVxuXG5jb25zdCBzdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgIGNvbnRpbnVlIE9VVEVSXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRoZSBudWxsIHNldCBpcyBhIHN1YnNldCBvZiBldmVyeXRoaW5nLCBidXQgbnVsbCBzaW1wbGUgcmFuZ2VzIGluXG4gICAgLy8gYSBjb21wbGV4IHJhbmdlIHNob3VsZCBiZSBpZ25vcmVkLiAgc28gaWYgd2Ugc2F3IGEgbm9uLW51bGwgcmFuZ2UsXG4gICAgLy8gdGhlbiB3ZSBrbm93IHRoaXMgaXNuJ3QgYSBzdWJzZXQsIGJ1dCBpZiBFVkVSWSBzaW1wbGUgcmFuZ2Ugd2FzIG51bGwsXG4gICAgLy8gdGhlbiBpdCBpcyBhIHN1YnNldC5cbiAgICBpZiAoc2F3Tm9uTnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IG1pbmltdW1WZXJzaW9uV2l0aFByZVJlbGVhc2UgPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpXVxuY29uc3QgbWluaW11bVZlcnNpb24gPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKV1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3ViLmxlbmd0aCA9PT0gMSAmJiBzdWJbMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YiA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbSA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXFTZXQgPSBuZXcgU2V0KClcbiAgbGV0IGd0LCBsdFxuICBmb3IgKGNvbnN0IGMgb2Ygc3ViKSB7XG4gICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICAgIH1cbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgZ3RsdENvbXBcbiAgaWYgKGd0ICYmIGx0KSB7XG4gICAgZ3RsdENvbXAgPSBjb21wYXJlKGd0LnNlbXZlciwgbHQuc2VtdmVyLCBvcHRpb25zKVxuICAgIGlmIChndGx0Q29tcCA+IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGhpZ2hlciwgbG93ZXJcbiAgbGV0IGhhc0RvbUxULCBoYXNEb21HVFxuICAvLyBpZiB0aGUgc3Vic2V0IGhhcyBhIHByZXJlbGVhc2UsIHdlIG5lZWQgYSBjb21wYXJhdG9yIGluIHRoZSBzdXBlcnNldFxuICAvLyB3aXRoIHRoZSBzYW1lIHR1cGxlIGFuZCBhIHByZXJlbGVhc2UsIG9yIGl0J3Mgbm90IGEgc3Vic2V0XG4gIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgbHQuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gbHQuc2VtdmVyIDogZmFsc2VcbiAgbGV0IG5lZWREb21HVFByZSA9IGd0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZVxuICAvLyBleGNlcHRpb246IDwxLjIuMy0wIGlzIHRoZSBzYW1lIGFzIDwxLjIuM1xuICBpZiAobmVlZERvbUxUUHJlICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbHQub3BlcmF0b3IgPT09ICc8JyAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49J1xuICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PSdcbiAgICBpZiAoZ3QpIHtcbiAgICAgIGlmIChuZWVkRG9tR1RQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tR1RQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tR1RQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChoaWdoZXIgPT09IGMgJiYgaGlnaGVyICE9PSBndCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobHQpIHtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tTFRQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tTFRQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgICAgbG93ZXIgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAobG93ZXIgPT09IGMgJiYgbG93ZXIgIT09IGx0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYy5vcGVyYXRvciAmJiAobHQgfHwgZ3QpICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgYSA8IG9yID4sIGFuZCBub3RoaW5nIGluIHRoZSBkb20sIHRoZW4gbXVzdCBiZSBmYWxzZVxuICAvLyBVTkxFU1MgaXQgd2FzIGxpbWl0ZWQgYnkgYW5vdGhlciByYW5nZSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAvLyBFZywgPjEuMC4wIDwxLjAuMSBpcyBzdGlsbCBhIHN1YnNldCBvZiA8Mi4wLjBcbiAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA+PTEuMi4zIGlzIGxvd2VyIHRoYW4gPjEuMi4zXG5jb25zdCBoaWdoZXJHVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuY29uc3QgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT5cbiAgbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXRcbiAgICAubWFwKGNvbXAgPT4gY29tcC5tYXAoYyA9PiBjLnZhbHVlKS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJykpXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Db21wYXJhdG9yc1xuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgYmxvY2tTaXplID0gdGhpcy5fYmxvY2tTaXplXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICB2YXIgYWNjdW0gPSB0aGlzLl9sZW5cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7KSB7XG4gICAgdmFyIGFzc2lnbmVkID0gYWNjdW0gJSBibG9ja1NpemVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5taW4obGVuZ3RoIC0gb2Zmc2V0LCBibG9ja1NpemUgLSBhc3NpZ25lZClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtYWluZGVyOyBpKyspIHtcbiAgICAgIGJsb2NrW2Fzc2lnbmVkICsgaV0gPSBkYXRhW29mZnNldCArIGldXG4gICAgfVxuXG4gICAgYWNjdW0gKz0gcmVtYWluZGVyXG4gICAgb2Zmc2V0ICs9IHJlbWFpbmRlclxuXG4gICAgaWYgKChhY2N1bSAlIGJsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShibG9jaylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9sZW4gKz0gbGVuZ3RoXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIHJlbSA9IHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZVxuXG4gIHRoaXMuX2Jsb2NrW3JlbV0gPSAweDgwXG5cbiAgLy8gemVybyAocmVtICsgMSkgdHJhaWxpbmcgYml0cywgd2hlcmUgKHJlbSArIDEpIGlzIHRoZSBzbWFsbGVzdFxuICAvLyBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsZW5ndGggKyAxICsgKHJlbSArIDEpKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCByZW0gKyAxKVxuXG4gIGlmIChyZW0gPj0gdGhpcy5fZmluYWxTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIHZhciBiaXRzID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIHVpbnQzMlxuICBpZiAoYml0cyA8PSAweGZmZmZmZmZmKSB7XG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShiaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIC8vIHVpbnQ2NFxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dCaXRzID0gKGJpdHMgJiAweGZmZmZmZmZmKSA+Pj4gMFxuICAgIHZhciBoaWdoQml0cyA9IChiaXRzIC0gbG93Qml0cykgLyAweDEwMDAwMDAwMFxuXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShoaWdoQml0cywgdGhpcy5fYmxvY2tTaXplIC0gOClcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGxvd0JpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG4gIH1cblxuICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcbiIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTAsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFNIQS0wIGFuZCBTSEEtMSBpcyBqdXN0IGEgYml0d2lzZSByb3RhdGUgbGVmdFxuICogb3BlcmF0aW9uIHdhcyBhZGRlZC5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMVxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4Y2JiYjlkNWRcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXG4gIHRoaXMuX2NoID0gMHg5MTU5MDE1YVxuICB0aGlzLl9kaCA9IDB4MTUyZmVjZDhcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XG4gIHRoaXMuX2ZoID0gMHg4ZWI0NGE4N1xuICB0aGlzLl9naCA9IDB4ZGIwYzJlMGRcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhNTEyICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XG4gIHRoaXMuX2NoID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kaCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXG4gIHRoaXMuX2ZoID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9naCA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XG5cbiAgdGhpcy5fYWwgPSAweGYzYmNjOTA4XG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJcbiAgdGhpcy5fZGwgPSAweDVmMWQzNmYxXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZcbiAgdGhpcy5fZ2wgPSAweGZiNDFiZDZiXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuZnVuY3Rpb24gZ2V0Q2FycnkgKGEsIGIpIHtcbiAgcmV0dXJuIChhID4+PiAwKSA8IChiID4+PiAwKSA/IDEgOiAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhaCA9IHRoaXMuX2FoIHwgMFxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcbiAgdmFyIGNoID0gdGhpcy5fY2ggfCAwXG4gIHZhciBkaCA9IHRoaXMuX2RoIHwgMFxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcbiAgdmFyIGZoID0gdGhpcy5fZmggfCAwXG4gIHZhciBnaCA9IHRoaXMuX2doIHwgMFxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcblxuICB2YXIgYWwgPSB0aGlzLl9hbCB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2NsIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kbCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXG4gIHZhciBmbCA9IHRoaXMuX2ZsIHwgMFxuICB2YXIgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gICAgV1tpICsgMV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XG4gICAgdmFyIHhoID0gV1tpIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaSAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4aClcblxuICAgIHhoID0gV1tpIC0gMiAqIDJdXG4gICAgeGwgPSBXW2kgLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcblxuICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2kgLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tpIC0gMTYgKiAyICsgMV1cblxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxuICAgIHZhciBXaWggPSAoZ2FtbWEwICsgV2k3aCArIGdldENhcnJ5KFdpbCwgZ2FtbWEwbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBnYW1tYTFsKSB8IDBcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIFdpMTZsKSB8IDBcbiAgICBXaWggPSAoV2loICsgV2kxNmggKyBnZXRDYXJyeShXaWwsIFdpMTZsKSkgfCAwXG5cbiAgICBXW2ldID0gV2loXG4gICAgV1tpICsgMV0gPSBXaWxcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTYwOyBqICs9IDIpIHtcbiAgICBXaWggPSBXW2pdXG4gICAgV2lsID0gV1tqICsgMV1cblxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXG4gICAgdmFyIG1hamwgPSBtYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IHNpZ21hMChhbCwgYWgpXG4gICAgdmFyIHNpZ21hMWggPSBzaWdtYTEoZWgsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tqXSArIFdbal1cbiAgICB2YXIgS2loID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXG4gICAgdmFyIHQxaCA9IChoaCArIHNpZ21hMWggKyBnZXRDYXJyeSh0MWwsIGhsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIGNobCkgfCAwXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIEtpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIEtpaCArIGdldENhcnJ5KHQxbCwgS2lsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIFdpaCArIGdldENhcnJ5KHQxbCwgV2lsKSkgfCAwXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSAoc2lnbWEwbCArIG1hamwpIHwgMFxuICAgIHZhciB0MmggPSAoc2lnbWEwaCArIG1hamggKyBnZXRDYXJyeSh0MmwsIHNpZ21hMGwpKSB8IDBcblxuICAgIGhoID0gZ2hcbiAgICBobCA9IGdsXG4gICAgZ2ggPSBmaFxuICAgIGdsID0gZmxcbiAgICBmaCA9IGVoXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlaCA9IChkaCArIHQxaCArIGdldENhcnJ5KGVsLCBkbCkpIHwgMFxuICAgIGRoID0gY2hcbiAgICBkbCA9IGNsXG4gICAgY2ggPSBiaFxuICAgIGNsID0gYmxcbiAgICBiaCA9IGFoXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYWggPSAodDFoICsgdDJoICsgZ2V0Q2FycnkoYWwsIHQxbCkpIHwgMFxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2FoID0gKHRoaXMuX2FoICsgYWggKyBnZXRDYXJyeSh0aGlzLl9hbCwgYWwpKSB8IDBcbiAgdGhpcy5fYmggPSAodGhpcy5fYmggKyBiaCArIGdldENhcnJ5KHRoaXMuX2JsLCBibCkpIHwgMFxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXG4gIHRoaXMuX2RoID0gKHRoaXMuX2RoICsgZGggKyBnZXRDYXJyeSh0aGlzLl9kbCwgZGwpKSB8IDBcbiAgdGhpcy5fZWggPSAodGhpcy5fZWggKyBlaCArIGdldENhcnJ5KHRoaXMuX2VsLCBlbCkpIHwgMFxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXG4gIHRoaXMuX2doID0gKHRoaXMuX2doICsgZ2ggKyBnZXRDYXJyeSh0aGlzLl9nbCwgZ2wpKSB8IDBcbiAgdGhpcy5faGggPSAodGhpcy5faGggKyBoaCArIGdldENhcnJ5KHRoaXMuX2hsLCBobCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9naCwgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faGgsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgICB7XG4gICAgIFwicGF5YWJsZVwiOiB0cnVlLFxuICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInBheWFibGVcIixcbiAgICAgXCJ0eXBlXCI6IFwiZmFsbGJhY2tcIlxuICAgIH0sXG4gICAge1xuICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJ1c2VyXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcInRva2VuXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgIF0sXG4gICAgIFwibmFtZVwiOiBcInRva2VuQmFsYW5jZVwiLFxuICAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgIFwidHlwZVwiOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgICBdLFxuICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcInVzZXJzXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1tdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgXCJuYW1lXCI6IFwidG9rZW5zXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1tdXCJcbiAgICAgIH1cbiAgICAgXSxcbiAgICAgXCJuYW1lXCI6IFwiYmFsYW5jZXNcIixcbiAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2W11cIlxuICAgICAgfVxuICAgICBdLFxuICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfVxuICAgXVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwidmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcblxuLyoqXG4gKiBSZW1vdmVzICcweCcgZnJvbSBhIGdpdmVuIGBTdHJpbmdgIGlzIHByZXNlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfE9wdGlvbmFsfSBhIHN0cmluZyBieSBwYXNzIGlmIG5lY2Vzc2FyeVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuU3VwZXJzdHJ1Y3QgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gICAgICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAgICAgKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAgICAgKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZDtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBgQXQgcGF0aDogJHtwYXRoLmpvaW4oJy4nKX0gLS0gJHttZXNzYWdlfWA7XG4gICAgICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBtc2cpO1xuICAgICAgICAgICAgaWYgKGV4cGxhbmF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG1zZztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KTtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICAgICAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICAgICAgY29uc3QgeyByZWZpbmVtZW50LCBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtyZWZpbmVtZW50ID8gYCB3aXRoIHJlZmluZW1lbnQgXFxgJHtyZWZpbmVtZW50fVxcYGAgOiAnJ30sIGJ1dCByZWNlaXZlZDogXFxgJHtwcmludCh2YWx1ZSl9XFxgYCwgfSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJlZmluZW1lbnQsXG4gICAgICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBicmFuY2gsXG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmFsaWRhdGlvbiByZXN1bHQgdG8gYW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24qIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBmYWlsdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAgICAgKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHBhdGggPSBbXSwgYnJhbmNoID0gW3ZhbHVlXSwgY29lcmNlID0gZmFsc2UsIG1hc2sgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY3R4ID0geyBwYXRoLCBicmFuY2ggfTtcbiAgICAgICAgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmXG4gICAgICAgICAgICAgICAgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHN0cnVjdC5zY2hlbWEpICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICAgICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgICAgICAgICAgIHBhdGg6IGsgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwga10sXG4gICAgICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgICAgICBjb2VyY2UsXG4gICAgICAgICAgICAgICAgbWFzayxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHRbMF0ucmVmaW5lbWVudCAhPSBudWxsID8gJ25vdF9yZWZpbmVkJyA6ICdub3RfdmFsaWQnO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29lcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNldChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCB8fCBrIGluIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzICE9PSAnbm90X3ZhbGlkJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnbm90X3JlZmluZWQnO1xuICAgICAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBTdHJ1Y3RgIG9iamVjdHMgZW5jYXBzdWxhdGUgdGhlIHZhbGlkYXRpb24gbG9naWMgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZlxuICAgICAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gICAgICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAgICAgKi9cbiAgICBjbGFzcyBTdHJ1Y3Qge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBzY2hlbWEsIHZhbGlkYXRvciwgcmVmaW5lciwgY29lcmNlciA9ICh2YWx1ZSkgPT4gdmFsdWUsIGVudHJpZXMgPSBmdW5jdGlvbiogKCkgeyB9LCB9ID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICAgICAgdGhpcy5jb2VyY2VyID0gY29lcmNlcjtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAoKSA9PiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZpbmVyID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgICAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgICAgICovXG4gICAgICAgIG1hc2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAgICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICAgICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICAgICAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgICAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgICAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgICAgIHJldHVybiAhcmVzdWx0WzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHJldHVybmluZyBhbiBlcnJvciBpZiBpbnZhbGlkLCBvciB0aGVcbiAgICAgKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgICAgICBpZiAodHVwbGVbMF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NpZ24oLi4uU3RydWN0cykge1xuICAgICAgICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdLnR5cGUgPT09ICd0eXBlJztcbiAgICAgICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICAgICAgICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7IHR5cGU6IG5hbWUsIHNjaGVtYTogbnVsbCwgdmFsaWRhdG9yIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gICAgICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZChzdHJ1Y3QsIGxvZykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2codmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gICAgICpcbiAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICAgICAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gICAgICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICAgICAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICAgICAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgICAgIGxldCBzdHJ1Y3Q7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gICAgICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQoc3RydWN0LCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgd2l0aCBhbGwgb2YgaXRzXG4gICAgICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogTGlrZSBUeXBlU2NyaXB0J3MgYFBhcnRpYWxgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RydWN0IGluc3RhbmNlb2YgU3RydWN0ID8geyAuLi5zdHJ1Y3Quc2NoZW1hIH0gOiB7IC4uLnN0cnVjdCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAgICAgKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhzdHJ1Y3QsIGtleXMpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICAgICAgICByZXR1cm4gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFueSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnYW55JywgKCkgPT4gdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaSwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJvb2xlYW4oKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBgRGF0ZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gICAgICogd2hpY2ggY2FuIG9jY3VyIHdoZW4gcGFyc2luZyBhIGRhdGUgZmFpbHMgYnV0IHN0aWxsIHJldHVybnMgYSBgRGF0ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnZGF0ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHt9O1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHYpID0+IHByaW50KHYpKS5qb2luKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2VudW1zJyxcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWVzLmluY2x1ZGVzKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdmdW5jJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIHNwZWNpZmljIGNsYXNzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2luc3RhbmNlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVnZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2ludGVnZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBhbGwgb2YgYSBzZXQgb2YgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KTtcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICAgICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlID09PSBjb25zdGFudCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IG5vIHZhbHVlIGV2ZXIgcGFzc2VzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ25ldmVyJywgKCkgPT4gZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgICAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGEgc3RydWN0IHRvIGFsbG93IGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gICAgICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3JkKEtleSwgVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAgICAgKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVnZXhwKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFt2LCB2LCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYFNldFxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICAgICAqIGVsZW1lbnRzIGlzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0dXBsZShTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFN0cnVjdHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaSwgdmFsdWVbaV0sIFN0cnVjdHNbaV0gfHwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyBhcmUgYWxsb3dlZCBhbmQgdW50b3VjaGVkLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAgICAgKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHMpID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2Vycm9yLCBjb2VyY2VkXSA9IFMudmFsaWRhdGUodmFsdWUsIHsgY29lcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmtub3duKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICAgICAqXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAgICAgKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAgICAgKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICAgICAqXG4gICAgICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICAgICAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGEgc3RydWN0IHRvIHJlcGxhY2UgYHVuZGVmaW5lZGAgdmFsdWVzIHdpdGggYSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICAgICAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHVua25vd24oKSwgKHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoeCkgJiYgaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHsgLi4ueCB9O1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gICAgICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCAoeCkgPT4geC50cmltKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gICAgICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBlbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgICAgICA/IHZhbHVlIDwgdGhyZXNob2xkXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbGVzcyB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ30ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWluJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZSA+IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKHNpemUgPiAwIHx8IGBFeHBlY3RlZCBhIG5vbmVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocmVnZXhwLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCA9IG1pbikge1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YDtcbiAgICAgICAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IGBvZiBcXGAke21pbn1cXGBgIDogYGJldHdlZW4gXFxgJHttaW59XFxgIGFuZCBcXGAke21heH1cXGBgO1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSAke29mfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBsZW5ndGggJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIFxcYCR7bGVuZ3RofVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAgICAgKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICAgICAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSwgcmVmaW5lbWVudDogbmFtZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydHMuU3RydWN0ID0gU3RydWN0O1xuICAgIGV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbiAgICBleHBvcnRzLmFueSA9IGFueTtcbiAgICBleHBvcnRzLmFycmF5ID0gYXJyYXk7XG4gICAgZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4gICAgZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG4gICAgZXhwb3J0cy5iaWdpbnQgPSBiaWdpbnQ7XG4gICAgZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbiAgICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbiAgICBleHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBleHBvcnRzLmRhdGUgPSBkYXRlO1xuICAgIGV4cG9ydHMuZGVmYXVsdGVkID0gZGVmYXVsdGVkO1xuICAgIGV4cG9ydHMuZGVmaW5lID0gZGVmaW5lO1xuICAgIGV4cG9ydHMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG4gICAgZXhwb3J0cy5keW5hbWljID0gZHluYW1pYztcbiAgICBleHBvcnRzLmVtcHR5ID0gZW1wdHk7XG4gICAgZXhwb3J0cy5lbnVtcyA9IGVudW1zO1xuICAgIGV4cG9ydHMuZnVuYyA9IGZ1bmM7XG4gICAgZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGV4cG9ydHMuaW50ZWdlciA9IGludGVnZXI7XG4gICAgZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgZXhwb3J0cy5pcyA9IGlzO1xuICAgIGV4cG9ydHMubGF6eSA9IGxhenk7XG4gICAgZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbDtcbiAgICBleHBvcnRzLm1hcCA9IG1hcDtcbiAgICBleHBvcnRzLm1hc2sgPSBtYXNrO1xuICAgIGV4cG9ydHMubWF4ID0gbWF4O1xuICAgIGV4cG9ydHMubWluID0gbWluO1xuICAgIGV4cG9ydHMubmV2ZXIgPSBuZXZlcjtcbiAgICBleHBvcnRzLm5vbmVtcHR5ID0gbm9uZW1wdHk7XG4gICAgZXhwb3J0cy5udWxsYWJsZSA9IG51bGxhYmxlO1xuICAgIGV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuICAgIGV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuICAgIGV4cG9ydHMub21pdCA9IG9taXQ7XG4gICAgZXhwb3J0cy5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIGV4cG9ydHMucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgZXhwb3J0cy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICBleHBvcnRzLnBpY2sgPSBwaWNrO1xuICAgIGV4cG9ydHMucmVjb3JkID0gcmVjb3JkO1xuICAgIGV4cG9ydHMucmVmaW5lID0gcmVmaW5lO1xuICAgIGV4cG9ydHMucmVnZXhwID0gcmVnZXhwO1xuICAgIGV4cG9ydHMuc2V0ID0gc2V0O1xuICAgIGV4cG9ydHMuc2l6ZSA9IHNpemU7XG4gICAgZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZXhwb3J0cy5zdHJ1Y3QgPSBzdHJ1Y3Q7XG4gICAgZXhwb3J0cy50cmltbWVkID0gdHJpbW1lZDtcbiAgICBleHBvcnRzLnR1cGxlID0gdHVwbGU7XG4gICAgZXhwb3J0cy50eXBlID0gdHlwZTtcbiAgICBleHBvcnRzLnVuaW9uID0gdW5pb247XG4gICAgZXhwb3J0cy51bmtub3duID0gdW5rbm93bjtcbiAgICBleHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fZXNEZWNvcmF0ZTtcclxudmFyIF9fcnVuSW5pdGlhbGl6ZXJzO1xyXG52YXIgX19wcm9wS2V5O1xyXG52YXIgX19zZXRGdW5jdGlvbk5hbWU7XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19zcHJlYWRBcnJheXM7XHJcbnZhciBfX3NwcmVhZEFycmF5O1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkSW47XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmc7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXNEZWNvcmF0ZSA9IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxyXG4gICAgICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XHJcbiAgICAgICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcclxuICAgICAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XHJcbiAgICAgICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy5wdXNoKF8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnB1c2goXyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3J1bkluaXRpYWxpemVycyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgX19wcm9wS2V5ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24gKGYsIG5hbWUsIHByZWZpeCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24obSwgbykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbiAgICB9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgb1trMl0gPSBtW2tdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXkgPSBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxuICAgIH0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4gPSBmdW5jdGlvbiAoc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19lc0RlY29yYXRlXCIsIF9fZXNEZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcnVuSW5pdGlhbGl6ZXJzXCIsIF9fcnVuSW5pdGlhbGl6ZXJzKTtcclxuICAgIGV4cG9ydGVyKFwiX19wcm9wS2V5XCIsIF9fcHJvcEtleSk7XHJcbiAgICBleHBvcnRlcihcIl9fc2V0RnVuY3Rpb25OYW1lXCIsIF9fc2V0RnVuY3Rpb25OYW1lKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG59KTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2My4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHJvb3QudmVyc2lvbiA9ICczLjAuMCc7XG5cdHJvb3QuZW5jb2RlID0gdXRmOGVuY29kZTtcblx0cm9vdC5kZWNvZGUgPSB1dGY4ZGVjb2RlO1xuXG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMudXRmOCA9IHt9IDogZXhwb3J0cykpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2MVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92Mi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92My5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY1XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92NC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5JTFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbmlsLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmVyc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0ZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3BhcnNlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YxLmpzXCIpKTtcblxudmFyIF92MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjMuanNcIikpO1xuXG52YXIgX3YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NC5qc1wiKSk7XG5cbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y1LmpzXCIpKTtcblxudmFyIF9uaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25pbC5qc1wiKSk7XG5cbnZhciBfdmVyc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKSk7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIGNvbnN0IGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICBjb25zdCB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICBjb25zdCBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIGxldCBhID0gMTczMjU4NDE5MztcbiAgbGV0IGIgPSAtMjcxNzMzODc5O1xuICBsZXQgYyA9IC0xNzMyNTg0MTk0O1xuICBsZXQgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgY29uc3Qgb2xkYSA9IGE7XG4gICAgY29uc3Qgb2xkYiA9IGI7XG4gICAgY29uc3Qgb2xkYyA9IGM7XG4gICAgY29uc3Qgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIGNvbnN0IGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgY29uc3QgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG1kNTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0ID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBfZGVmYXVsdCA9IHBhcnNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJuZztcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgY29uc3QgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgY29uc3QgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIGNvbnN0IE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgY29uc3QgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tpICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tpICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1baV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW2ldW3RdO1xuICAgIH1cblxuICAgIGZvciAobGV0IHQgPSAxNjsgdCA8IDgwOyArK3QpIHtcbiAgICAgIFdbdF0gPSBST1RMKFdbdCAtIDNdIF4gV1t0IC0gOF0gXiBXW3QgLSAxNF0gXiBXW3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIGxldCBhID0gSFswXTtcbiAgICBsZXQgYiA9IEhbMV07XG4gICAgbGV0IGMgPSBIWzJdO1xuICAgIGxldCBkID0gSFszXTtcbiAgICBsZXQgZSA9IEhbNF07XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDgwOyArK3QpIHtcbiAgICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKHQgLyAyMCk7XG4gICAgICBjb25zdCBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbdF0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxudmFyIF9kZWZhdWx0ID0gc2hhMTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIGNvbnN0IHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbnZhciBfZGVmYXVsdCA9IHN0cmluZ2lmeTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHYxO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjM1LmpzXCIpKTtcblxudmFyIF9tZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWQ1LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgdjMgPSAoMCwgX3YuZGVmYXVsdCkoJ3YzJywgMHgzMCwgX21kLmRlZmF1bHQpO1xudmFyIF9kZWZhdWx0ID0gdjM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLkROUyA9IEROUztcbmNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5VUkwgPSBVUkw7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gKDAsIF9wYXJzZS5kZWZhdWx0KShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShybmRzKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX3NoYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2hhMS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHY1ID0gKDAsIF92LmRlZmF1bHQpKCd2NScsIDB4NTAsIF9zaGEuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2NTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2V4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWdleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBfcmVnZXguZGVmYXVsdC50ZXN0KHV1aWQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2YWxpZGF0ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2ZXJzaW9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiKGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzX3VyaSA9IGlzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc19odHRwX3VyaSA9IGlzX2h0dHBfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzX2h0dHBzX3VyaSA9IGlzX2h0dHBzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc193ZWJfdXJpID0gaXNfd2ViX2lyaTtcbiAgICAvLyBDcmVhdGUgYWxpYXNlc1xuICAgIG1vZHVsZS5leHBvcnRzLmlzVXJpID0gaXNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzSHR0cFVyaSA9IGlzX2h0dHBfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzSHR0cHNVcmkgPSBpc19odHRwc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNXZWJVcmkgPSBpc193ZWJfaXJpO1xuXG5cbiAgICAvLyBwcml2YXRlIGZ1bmN0aW9uXG4gICAgLy8gaW50ZXJuYWwgVVJJIHNwaXR0ZXIgbWV0aG9kIC0gZGlyZWN0IGZyb20gUkZDIDM5ODZcbiAgICB2YXIgc3BsaXRVcmkgPSBmdW5jdGlvbih1cmkpIHtcbiAgICAgICAgdmFyIHNwbGl0dGVkID0gdXJpLm1hdGNoKC8oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oW15cXC8/I10qKSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/Lyk7XG4gICAgICAgIHJldHVybiBzcGxpdHRlZDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfaXJpKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKC9bXmEtejAtOVxcOlxcL1xcP1xcI1xcW1xcXVxcQFxcIVxcJFxcJlxcJ1xcKFxcKVxcKlxcK1xcLFxcO1xcPVxcLlxcLVxcX1xcflxcJV0vaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBoZXggZXNjYXBlcyB0aGF0IGFyZW4ndCBjb21wbGV0ZVxuICAgICAgICBpZiAoLyVbXjAtOWEtZl0vaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICBpZiAoLyVbMC05YS1mXSg6P1teMC05YS1mXXwkKS9pLnRlc3QodmFsdWUpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHNwbGl0dGVkID0gW107XG4gICAgICAgIHZhciBzY2hlbWUgPSAnJztcbiAgICAgICAgdmFyIGF1dGhvcml0eSA9ICcnO1xuICAgICAgICB2YXIgcGF0aCA9ICcnO1xuICAgICAgICB2YXIgcXVlcnkgPSAnJztcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgICAgIHZhciBvdXQgPSAnJztcblxuICAgICAgICAvLyBmcm9tIFJGQyAzOTg2XG4gICAgICAgIHNwbGl0dGVkID0gc3BsaXRVcmkodmFsdWUpO1xuICAgICAgICBzY2hlbWUgPSBzcGxpdHRlZFsxXTsgXG4gICAgICAgIGF1dGhvcml0eSA9IHNwbGl0dGVkWzJdO1xuICAgICAgICBwYXRoID0gc3BsaXR0ZWRbM107XG4gICAgICAgIHF1ZXJ5ID0gc3BsaXR0ZWRbNF07XG4gICAgICAgIGZyYWdtZW50ID0gc3BsaXR0ZWRbNV07XG5cbiAgICAgICAgLy8gc2NoZW1lIGFuZCBwYXRoIGFyZSByZXF1aXJlZCwgdGhvdWdoIHRoZSBwYXRoIGNhbiBiZSBlbXB0eVxuICAgICAgICBpZiAoIShzY2hlbWUgJiYgc2NoZW1lLmxlbmd0aCAmJiBwYXRoLmxlbmd0aCA+PSAwKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGlmIGF1dGhvcml0eSBpcyBwcmVzZW50LCB0aGUgcGF0aCBtdXN0IGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSAvXG4gICAgICAgIGlmIChhdXRob3JpdHkgJiYgYXV0aG9yaXR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aC5sZW5ndGggPT09IDAgfHwgL15cXC8vLnRlc3QocGF0aCkpKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBhdXRob3JpdHkgaXMgbm90IHByZXNlbnQsIHRoZSBwYXRoIG11c3Qgbm90IHN0YXJ0IHdpdGggLy9cbiAgICAgICAgICAgIGlmICgvXlxcL1xcLy8udGVzdChwYXRoKSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NoZW1lIG11c3QgYmVnaW4gd2l0aCBhIGxldHRlciwgdGhlbiBjb25zaXN0IG9mIGxldHRlcnMsIGRpZ2l0cywgKywgLiwgb3IgLVxuICAgICAgICBpZiAoIS9eW2Etel1bYS16MC05XFwrXFwtXFwuXSokLy50ZXN0KHNjaGVtZS50b0xvd2VyQ2FzZSgpKSkgIHJldHVybjtcblxuICAgICAgICAvLyByZS1hc3NlbWJsZSB0aGUgVVJMIHBlciBzZWN0aW9uIDUuMyBpbiBSRkMgMzk4NlxuICAgICAgICBvdXQgKz0gc2NoZW1lICsgJzonO1xuICAgICAgICBpZiAoYXV0aG9yaXR5ICYmIGF1dGhvcml0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnLy8nICsgYXV0aG9yaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IHBhdGg7XG5cbiAgICAgICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICc/JyArIHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19odHRwX2lyaSh2YWx1ZSwgYWxsb3dIdHRwcykge1xuICAgICAgICBpZiAoIWlzX2lyaSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1lID0gJyc7XG4gICAgICAgIHZhciBhdXRob3JpdHkgPSAnJztcbiAgICAgICAgdmFyIHBhdGggPSAnJztcbiAgICAgICAgdmFyIHBvcnQgPSAnJztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gJyc7XG4gICAgICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgICAgLy8gZnJvbSBSRkMgMzk4NlxuICAgICAgICBzcGxpdHRlZCA9IHNwbGl0VXJpKHZhbHVlKTtcbiAgICAgICAgc2NoZW1lID0gc3BsaXR0ZWRbMV07IFxuICAgICAgICBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgICAgICAgcGF0aCA9IHNwbGl0dGVkWzNdO1xuICAgICAgICBxdWVyeSA9IHNwbGl0dGVkWzRdO1xuICAgICAgICBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuXG4gICAgICAgIGlmICghc2NoZW1lKSAgcmV0dXJuO1xuXG4gICAgICAgIGlmKGFsbG93SHR0cHMpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWUudG9Mb3dlckNhc2UoKSAhPSAnaHR0cHMnKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2h0dHAnKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmdWxseS1xdWFsaWZpZWQgVVJJcyBtdXN0IGhhdmUgYW4gYXV0aG9yaXR5IHNlY3Rpb24gdGhhdCBpc1xuICAgICAgICAvLyBhIHZhbGlkIGhvc3RcbiAgICAgICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuYWJsZSBwb3J0IGNvbXBvbmVudFxuICAgICAgICBpZiAoLzooXFxkKykkLy50ZXN0KGF1dGhvcml0eSkpIHtcbiAgICAgICAgICAgIHBvcnQgPSBhdXRob3JpdHkubWF0Y2goLzooXFxkKykkLylbMF07XG4gICAgICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkucmVwbGFjZSgvOlxcZCskLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IHNjaGVtZSArICc6JztcbiAgICAgICAgb3V0ICs9ICcvLycgKyBhdXRob3JpdHk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9ydCkge1xuICAgICAgICAgICAgb3V0ICs9IHBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG91dCArPSBwYXRoO1xuICAgICAgICBcbiAgICAgICAgaWYocXVlcnkgJiYgcXVlcnkubGVuZ3RoKXtcbiAgICAgICAgICAgIG91dCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGZyYWdtZW50ICYmIGZyYWdtZW50Lmxlbmd0aCl7XG4gICAgICAgICAgICBvdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfaHR0cHNfaXJpKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc19odHRwX2lyaSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfd2ViX2lyaSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKGlzX2h0dHBfaXJpKHZhbHVlKSB8fCBpc19odHRwc19pcmkodmFsdWUpKTtcbiAgICB9XG5cbn0pKG1vZHVsZSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDBcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHZhcmludCcpXG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXVxuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCkgPDwgc2hpZnRcbiAgICAgIDogKGIgJiBSRVNUKSAqIE1hdGgucG93KDIsIHNoaWZ0KVxuICAgIHNoaWZ0ICs9IDdcbiAgfSB3aGlsZSAoYiA+PSBNU0IpXG5cbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXRcblxuICByZXR1cm4gcmVzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCJ2YXIgaW5kZXhPZiA9IGZ1bmN0aW9uICh4cywgaXRlbSkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZihpdGVtKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbnZhciBPYmplY3Rfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfJywge30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG52YXIgZ2xvYmFscyA9IFsnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdGdW5jdGlvbicsXG4nSW5maW5pdHknLCAnSlNPTicsICdNYXRoJywgJ05hTicsICdOdW1iZXInLCAnT2JqZWN0JywgJ1JhbmdlRXJyb3InLFxuJ1JlZmVyZW5jZUVycm9yJywgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJyxcbidkZWNvZGVVUkknLCAnZGVjb2RlVVJJQ29tcG9uZW50JywgJ2VuY29kZVVSSScsICdlbmNvZGVVUklDb21wb25lbnQnLCAnZXNjYXBlJyxcbidldmFsJywgJ2lzRmluaXRlJywgJ2lzTmFOJywgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAndW5kZWZpbmVkJywgJ3VuZXNjYXBlJ107XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuQ29udGV4dC5wcm90b3R5cGUgPSB7fTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibmVlZHMgYSAnY29udGV4dCcgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWYgKCFpZnJhbWUuc3R5bGUpIGlmcmFtZS5zdHlsZSA9IHt9O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICB2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgdmFyIHdFdmFsID0gd2luLmV2YWwsIHdFeGVjU2NyaXB0ID0gd2luLmV4ZWNTY3JpcHQ7XG5cbiAgICBpZiAoIXdFdmFsICYmIHdFeGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi4oMCxldmFsKSgpIG1hZ2ljYWxseSBhcHBlYXJzIHdoZW4gdGhpcyBpcyBjYWxsZWQgaW4gSUU6XG4gICAgICAgIHdFeGVjU2NyaXB0LmNhbGwod2luLCAnbnVsbCcpO1xuICAgICAgICB3RXZhbCA9IHdpbi5ldmFsO1xuICAgIH1cbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgIH0pO1xuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoY29udGV4dFtrZXldKSB7XG4gICAgICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHZhciB3aW5LZXlzID0gT2JqZWN0X2tleXMod2luKTtcblxuICAgIHZhciByZXMgPSB3RXZhbC5jYWxsKHdpbiwgdGhpcy5jb2RlKTtcbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKHdpbiksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gQXZvaWQgY29weWluZyBjaXJjdWxhciBvYmplY3RzIGxpa2UgYHRvcGAgYW5kIGB3aW5kb3dgIGJ5IG9ubHlcbiAgICAgICAgLy8gdXBkYXRpbmcgZXhpc3RpbmcgY29udGV4dCBwcm9wZXJ0aWVzIG9yIG5ldyBwcm9wZXJ0aWVzIGluIHRoZSBgd2luYFxuICAgICAgICAvLyB0aGF0IHdhcyBvbmx5IGludHJvZHVjZWQgYWZ0ZXIgdGhlIGV2YWwuXG4gICAgICAgIGlmIChrZXkgaW4gY29udGV4dCB8fCBpbmRleE9mKHdpbktleXMsIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSB3aW5ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcChjb250ZXh0LCBrZXksIHdpbltrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JblRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCxldmFsKSh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuaXNDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQ7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFwid2ViZXh0ZW5zaW9uLXBvbHlmaWxsXCIsIFtcIm1vZHVsZVwiXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KG1vZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZCk7XG4gICAgZ2xvYmFsLmJyb3dzZXIgPSBtb2QuZXhwb3J0cztcbiAgfVxufSkodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAvKiB3ZWJleHRlbnNpb24tcG9seWZpbGwgLSB2MC44LjAgLSBUdWUgQXByIDIwIDIwMjEgMTE6Mjc6MzggKi9cblxuICAvKiAtKi0gTW9kZTogaW5kZW50LXRhYnMtbW9kZTogbmlsOyBqcy1pbmRlbnQtbGV2ZWw6IDIgLSotICovXG5cbiAgLyogdmltOiBzZXQgc3RzPTIgc3c9MiBldCB0dz04MDogKi9cblxuICAvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gICAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAgICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBicm93c2VyID09PSBcInVuZGVmaW5lZFwiIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihicm93c2VyKSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIGNvbnN0IENIUk9NRV9TRU5EX01FU1NBR0VfQ0FMTEJBQ0tfTk9fUkVTUE9OU0VfTUVTU0FHRSA9IFwiVGhlIG1lc3NhZ2UgcG9ydCBjbG9zZWQgYmVmb3JlIGEgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkLlwiO1xuICAgIGNvbnN0IFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORyA9IFwiUmV0dXJuaW5nIGEgUHJvbWlzZSBpcyB0aGUgcHJlZmVycmVkIHdheSB0byBzZW5kIGEgcmVwbHkgZnJvbSBhbiBvbk1lc3NhZ2Uvb25NZXNzYWdlRXh0ZXJuYWwgbGlzdGVuZXIsIGFzIHRoZSBzZW5kUmVzcG9uc2Ugd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHNwZWNzIChTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9Nb3ppbGxhL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9vbk1lc3NhZ2UpXCI7IC8vIFdyYXBwaW5nIHRoZSBidWxrIG9mIHRoaXMgcG9seWZpbGwgaW4gYSBvbmUtdGltZS11c2UgZnVuY3Rpb24gaXMgYSBtaW5vclxuICAgIC8vIG9wdGltaXphdGlvbiBmb3IgRmlyZWZveC4gU2luY2UgU3BpZGVybW9ua2V5IGRvZXMgbm90IGZ1bGx5IHBhcnNlIHRoZVxuICAgIC8vIGNvbnRlbnRzIG9mIGEgZnVuY3Rpb24gdW50aWwgdGhlIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCBzaW5jZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYWN0dWFsbHkgbmVlZCB0byBiZSBjYWxsZWQsIHRoaXMgYWxsb3dzIHRoZSBwb2x5ZmlsbCB0byBiZSBpbmNsdWRlZFxuICAgIC8vIGluIEZpcmVmb3ggbmVhcmx5IGZvciBmcmVlLlxuXG4gICAgY29uc3Qgd3JhcEFQSXMgPSBleHRlbnNpb25BUElzID0+IHtcbiAgICAgIC8vIE5PVEU6IGFwaU1ldGFkYXRhIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRlbnQgb2YgdGhlIGFwaS1tZXRhZGF0YS5qc29uIGZpbGVcbiAgICAgIC8vIGF0IGJ1aWxkIHRpbWUgYnkgcmVwbGFjaW5nIHRoZSBmb2xsb3dpbmcgXCJpbmNsdWRlXCIgd2l0aCB0aGUgY29udGVudCBvZiB0aGVcbiAgICAgIC8vIEpTT04gZmlsZS5cbiAgICAgIGNvbnN0IGFwaU1ldGFkYXRhID0ge1xuICAgICAgICBcImFsYXJtc1wiOiB7XG4gICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNsZWFyQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYm9va21hcmtzXCI6IHtcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldENoaWxkcmVuXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UmVjZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0U3ViVHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlVHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJyb3dzZXJBY3Rpb25cIjoge1xuICAgICAgICAgIFwiZGlzYWJsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVuYWJsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEJhZGdlQmFja2dyb3VuZENvbG9yXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QmFkZ2VUZXh0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5Qb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEJhZGdlQmFja2dyb3VuZENvbG9yXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0QmFkZ2VUZXh0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0SWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJicm93c2luZ0RhdGFcIjoge1xuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ2FjaGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDb29raWVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRG93bmxvYWRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRm9ybURhdGFcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVIaXN0b3J5XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlTG9jYWxTdG9yYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlUGFzc3dvcmRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlUGx1Z2luRGF0YVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldHRpbmdzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29tbWFuZHNcIjoge1xuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29udGV4dE1lbnVzXCI6IHtcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvb2tpZXNcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsQ29va2llU3RvcmVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGV2dG9vbHNcIjoge1xuICAgICAgICAgIFwiaW5zcGVjdGVkV2luZG93XCI6IHtcbiAgICAgICAgICAgIFwiZXZhbFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMixcbiAgICAgICAgICAgICAgXCJzaW5nbGVDYWxsYmFja0FyZ1wiOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwYW5lbHNcIjoge1xuICAgICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMyxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDMsXG4gICAgICAgICAgICAgIFwic2luZ2xlQ2FsbGJhY2tBcmdcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1xuICAgICAgICAgICAgICBcImNyZWF0ZVNpZGViYXJQYW5lXCI6IHtcbiAgICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRvd25sb2Fkc1wiOiB7XG4gICAgICAgICAgXCJjYW5jZWxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkb3dubG9hZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVyYXNlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0RmlsZUljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicGF1c2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVGaWxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVzdW1lXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2hvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImV4dGVuc2lvblwiOiB7XG4gICAgICAgICAgXCJpc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaXNBbGxvd2VkSW5jb2duaXRvQWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaGlzdG9yeVwiOiB7XG4gICAgICAgICAgXCJhZGRVcmxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVSYW5nZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZVVybFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFZpc2l0c1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImkxOG5cIjoge1xuICAgICAgICAgIFwiZGV0ZWN0TGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBY2NlcHRMYW5ndWFnZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpZGVudGl0eVwiOiB7XG4gICAgICAgICAgXCJsYXVuY2hXZWJBdXRoRmxvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImlkbGVcIjoge1xuICAgICAgICAgIFwicXVlcnlTdGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1hbmFnZW1lbnRcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0U2VsZlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1bmluc3RhbGxTZWxmXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBlcm1pc3Npb25MZXZlbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBhZ2VBY3Rpb25cIjoge1xuICAgICAgICAgIFwiZ2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpZGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwZXJtaXNzaW9uc1wiOiB7XG4gICAgICAgICAgXCJjb250YWluc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVlc3RcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJydW50aW1lXCI6IHtcbiAgICAgICAgICBcImdldEJhY2tncm91bmRQYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UGxhdGZvcm1JbmZvXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3Blbk9wdGlvbnNQYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVxdWVzdFVwZGF0ZUNoZWNrXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogM1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTmF0aXZlTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFVuaW5zdGFsbFVSTFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNlc3Npb25zXCI6IHtcbiAgICAgICAgICBcImdldERldmljZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRSZWNlbnRseUNsb3NlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzdG9yYWdlXCI6IHtcbiAgICAgICAgICBcImxvY2FsXCI6IHtcbiAgICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibWFuYWdlZFwiOiB7XG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzeW5jXCI6IHtcbiAgICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidGFic1wiOiB7XG4gICAgICAgICAgXCJjYXB0dXJlVmlzaWJsZVRhYlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRldGVjdExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGlzY2FyZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImR1cGxpY2F0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImV4ZWN1dGVTY3JpcHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDdXJyZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Wm9vbVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFpvb21TZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdvQmFja1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdvRm9yd2FyZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpZ2hsaWdodFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImluc2VydENTU1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJxdWVyeVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbG9hZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNTU1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmRNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0Wm9vbVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFpvb21TZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRvcFNpdGVzXCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIndlYk5hdmlnYXRpb25cIjoge1xuICAgICAgICAgIFwiZ2V0QWxsRnJhbWVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0RnJhbWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3ZWJSZXF1ZXN0XCI6IHtcbiAgICAgICAgICBcImhhbmRsZXJCZWhhdmlvckNoYW5nZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3aW5kb3dzXCI6IHtcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEN1cnJlbnRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRMYXN0Rm9jdXNlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXMoYXBpTWV0YWRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcGktbWV0YWRhdGEuanNvbiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgaW4gYnJvd3Nlci1wb2x5ZmlsbFwiKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQSBXZWFrTWFwIHN1YmNsYXNzIHdoaWNoIGNyZWF0ZXMgYW5kIHN0b3JlcyBhIHZhbHVlIGZvciBhbnkga2V5IHdoaWNoIGRvZXNcbiAgICAgICAqIG5vdCBleGlzdCB3aGVuIGFjY2Vzc2VkLCBidXQgYmVoYXZlcyBleGFjdGx5IGFzIGFuIG9yZGluYXJ5IFdlYWtNYXBcbiAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjcmVhdGVJdGVtXG4gICAgICAgKiAgICAgICAgQSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBpbiBvcmRlciB0byBjcmVhdGUgdGhlIHZhbHVlIGZvciBhbnlcbiAgICAgICAqICAgICAgICBrZXkgd2hpY2ggZG9lcyBub3QgZXhpc3QsIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGFjY2Vzc2VkLiBUaGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiByZWNlaXZlcywgYXMgaXRzIG9ubHkgYXJndW1lbnQsIHRoZSBrZXkgYmVpbmcgY3JlYXRlZC5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNsYXNzIERlZmF1bHRXZWFrTWFwIGV4dGVuZHMgV2Vha01hcCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNyZWF0ZUl0ZW0sIGl0ZW1zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3VwZXIoaXRlbXMpO1xuICAgICAgICAgIHRoaXMuY3JlYXRlSXRlbSA9IGNyZWF0ZUl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHRoaXMuY3JlYXRlSXRlbShrZXkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBvYmplY3Qgd2l0aCBhIGB0aGVuYCBtZXRob2QsIGFuZCBjYW5cbiAgICAgICAqIHRoZXJlZm9yZSBiZSBhc3N1bWVkIHRvIGJlaGF2ZSBhcyBhIFByb21pc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGVuYWJsZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IGlzVGhlbmFibGUgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBjYWxsZWQsIHdpbGwgcmVzb2x2ZSBvciByZWplY3RcbiAgICAgICAqIHRoZSBnaXZlbiBwcm9taXNlIGJhc2VkIG9uIGhvdyBpdCBpcyBjYWxsZWQ6XG4gICAgICAgKlxuICAgICAgICogLSBJZiwgd2hlbiBjYWxsZWQsIGBjaHJvbWUucnVudGltZS5sYXN0RXJyb3JgIGNvbnRhaW5zIGEgbm9uLW51bGwgb2JqZWN0LFxuICAgICAgICogICB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoYXQgdmFsdWUuXG4gICAgICAgKiAtIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBleGFjdGx5IG9uZSBhcmd1bWVudCwgdGhlIHByb21pc2UgaXNcbiAgICAgICAqICAgcmVzb2x2ZWQgdG8gdGhhdCB2YWx1ZS5cbiAgICAgICAqIC0gT3RoZXJ3aXNlLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCB0byBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGVcbiAgICAgICAqICAgZnVuY3Rpb24ncyBhcmd1bWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb21pc2VcbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzb2x1dGlvbiBhbmQgcmVqZWN0aW9uIGZ1bmN0aW9ucyBvZiBhXG4gICAgICAgKiAgICAgICAgcHJvbWlzZS5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb21pc2UucmVzb2x2ZVxuICAgICAgICogICAgICAgIFRoZSBwcm9taXNlJ3MgcmVzb2x1dGlvbiBmdW5jdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb21pc2UucmVqZWN0XG4gICAgICAgKiAgICAgICAgVGhlIHByb21pc2UncyByZWplY3Rpb24gZnVuY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGFcbiAgICAgICAqICAgICAgICBNZXRhZGF0YSBhYm91dCB0aGUgd3JhcHBlZCBtZXRob2Qgd2hpY2ggaGFzIGNyZWF0ZWQgdGhlIGNhbGxiYWNrLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZ1xuICAgICAgICogICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggb25seSB0aGUgZmlyc3RcbiAgICAgICAqICAgICAgICBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2ssIGFsdGVybmF0aXZlbHkgYW4gYXJyYXkgb2YgYWxsIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGFyZ3VtZW50cyBpcyByZXNvbHZlZC4gQnkgZGVmYXVsdCwgaWYgdGhlIGNhbGxiYWNrXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIG9ubHkgYSBzaW5nbGUgYXJndW1lbnQsIHRoYXQgd2lsbCBiZVxuICAgICAgICogICAgICAgIHJlc29sdmVkIHRvIHRoZSBwcm9taXNlLCB3aGlsZSBhbGwgYXJndW1lbnRzIHdpbGwgYmUgcmVzb2x2ZWQgYXNcbiAgICAgICAqICAgICAgICBhbiBhcnJheSBpZiBtdWx0aXBsZSBhcmUgZ2l2ZW4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9ufVxuICAgICAgICogICAgICAgIFRoZSBnZW5lcmF0ZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBtYWtlQ2FsbGJhY2sgPSAocHJvbWlzZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuICguLi5jYWxsYmFja0FyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmcgfHwgY2FsbGJhY2tBcmdzLmxlbmd0aCA8PSAxICYmIG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrQXJnc1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBsdXJhbGl6ZUFyZ3VtZW50cyA9IG51bUFyZ3MgPT4gbnVtQXJncyA9PSAxID8gXCJhcmd1bWVudFwiIDogXCJhcmd1bWVudHNcIjtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB3aGljaCBpcyBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5taW5BcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbi4gSWYgY2FsbGVkIHdpdGggZmV3ZXIgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heEFyZ3NcbiAgICAgICAqICAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHdoaWNoIG1heSBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnXG4gICAgICAgKiAgICAgICAgV2hldGhlciBvciBub3QgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBvbmx5IHRoZSBmaXJzdFxuICAgICAgICogICAgICAgIGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjaywgYWx0ZXJuYXRpdmVseSBhbiBhcnJheSBvZiBhbGwgdGhlXG4gICAgICAgKiAgICAgICAgY2FsbGJhY2sgYXJndW1lbnRzIGlzIHJlc29sdmVkLiBCeSBkZWZhdWx0LCBpZiB0aGUgY2FsbGJhY2tcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggb25seSBhIHNpbmdsZSBhcmd1bWVudCwgdGhhdCB3aWxsIGJlXG4gICAgICAgKiAgICAgICAgcmVzb2x2ZWQgdG8gdGhlIHByb21pc2UsIHdoaWxlIGFsbCBhcmd1bWVudHMgd2lsbCBiZSByZXNvbHZlZCBhc1xuICAgICAgICogICAgICAgIGFuIGFycmF5IGlmIG11bHRpcGxlIGFyZSBnaXZlbi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24ob2JqZWN0LCAuLi4qKX1cbiAgICAgICAqICAgICAgIFRoZSBnZW5lcmF0ZWQgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBBc3luY0Z1bmN0aW9uID0gKG5hbWUsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhc3luY0Z1bmN0aW9uV3JhcHBlcih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBtZXRhZGF0YS5taW5BcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0ICR7bWV0YWRhdGEubWluQXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWluQXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1ldGFkYXRhLm1heEFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbW9zdCAke21ldGFkYXRhLm1heEFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1heEFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmZhbGxiYWNrVG9Ob0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgQVBJIG1ldGhvZCBoYXMgY3VycmVudGx5IG5vIGNhbGxiYWNrIG9uIENocm9tZSwgYnV0IGl0IHJldHVybiBhIHByb21pc2Ugb24gRmlyZWZveCxcbiAgICAgICAgICAgICAgLy8gYW5kIHNvIHRoZSBwb2x5ZmlsbCB3aWxsIHRyeSB0byBjYWxsIGl0IHdpdGggYSBjYWxsYmFjayBmaXJzdCwgYW5kIGl0IHdpbGwgZmFsbGJhY2tcbiAgICAgICAgICAgICAgLy8gdG8gbm90IHBhc3NpbmcgdGhlIGNhbGxiYWNrIGlmIHRoZSBmaXJzdCBjYWxsIGZhaWxzLlxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzLCBtYWtlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgIH0sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGNiRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gQVBJIG1ldGhvZCBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyLCBgICsgXCJmYWxsaW5nIGJhY2sgdG8gY2FsbCBpdCB3aXRob3V0IGEgY2FsbGJhY2s6IFwiLCBjYkVycm9yKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncyk7IC8vIFVwZGF0ZSB0aGUgQVBJIG1ldGhvZCBtZXRhZGF0YSwgc28gdGhhdCB0aGUgbmV4dCBBUEkgY2FsbHMgd2lsbCBub3QgdHJ5IHRvXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSB1bnN1cHBvcnRlZCBjYWxsYmFjayBhbnltb3JlLlxuXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuZmFsbGJhY2tUb05vQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5ub0NhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEubm9DYWxsYmFjaykge1xuICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzLCBtYWtlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgIH0sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBhbiBleGlzdGluZyBtZXRob2Qgb2YgdGhlIHRhcmdldCBvYmplY3QsIHNvIHRoYXQgY2FsbHMgdG8gaXQgYXJlXG4gICAgICAgKiBpbnRlcmNlcHRlZCBieSB0aGUgZ2l2ZW4gd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgZnVuY3Rpb24gcmVjZWl2ZXMsXG4gICAgICAgKiBhcyBpdHMgZmlyc3QgYXJndW1lbnQsIHRoZSBvcmlnaW5hbCBgdGFyZ2V0YCBvYmplY3QsIGZvbGxvd2VkIGJ5IGVhY2ggb2ZcbiAgICAgICAqIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICAgICAgICogICAgICAgIFRoZSBvcmlnaW5hbCB0YXJnZXQgb2JqZWN0IHRoYXQgdGhlIHdyYXBwZWQgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2RcbiAgICAgICAqICAgICAgICBUaGUgbWV0aG9kIGJlaW5nIHdyYXBwZWQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBQcm94eVxuICAgICAgICogICAgICAgIG9iamVjdCB3aGljaCBpcyBjcmVhdGVkIHRvIHdyYXAgdGhlIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHdyYXBwZXJcbiAgICAgICAqICAgICAgICBUaGUgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgaW4gcGxhY2Ugb2YgYSBkaXJlY3QgaW52b2NhdGlvblxuICAgICAgICogICAgICAgIG9mIHRoZSB3cmFwcGVkIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7UHJveHk8ZnVuY3Rpb24+fVxuICAgICAgICogICAgICAgIEEgUHJveHkgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLCB3aGljaCBpbnZva2VzIHRoZSBnaXZlbiB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgbWV0aG9kIGluIGl0cyBwbGFjZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBNZXRob2QgPSAodGFyZ2V0LCBtZXRob2QsIHdyYXBwZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShtZXRob2QsIHtcbiAgICAgICAgICBhcHBseSh0YXJnZXRNZXRob2QsIHRoaXNPYmosIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLmNhbGwodGhpc09iaiwgdGFyZ2V0LCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgaGFzT3duUHJvcGVydHkgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIGFuIG9iamVjdCBpbiBhIFByb3h5IHdoaWNoIGludGVyY2VwdHMgYW5kIHdyYXBzIGNlcnRhaW4gbWV0aG9kc1xuICAgICAgICogYmFzZWQgb24gdGhlIGdpdmVuIGB3cmFwcGVyc2AgYW5kIGBtZXRhZGF0YWAgb2JqZWN0cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gICAgICAgKiAgICAgICAgVGhlIHRhcmdldCBvYmplY3QgdG8gd3JhcC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW3dyYXBwZXJzID0ge31dXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IHRyZWUgY29udGFpbmluZyB3cmFwcGVyIGZ1bmN0aW9ucyBmb3Igc3BlY2lhbCBjYXNlcy4gQW55XG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gcHJlc2VudCBpbiB0aGlzIG9iamVjdCB0cmVlIGlzIGNhbGxlZCBpbiBwbGFjZSBvZiB0aGVcbiAgICAgICAqICAgICAgICBtZXRob2QgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIGB0YXJnZXRgIG9iamVjdCB0cmVlLiBUaGVzZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgbWV0aG9kcyBhcmUgaW52b2tlZCBhcyBkZXNjcmliZWQgaW4ge0BzZWUgd3JhcE1ldGhvZH0uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFttZXRhZGF0YSA9IHt9XVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCB0cmVlIGNvbnRhaW5pbmcgbWV0YWRhdGEgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlXG4gICAgICAgKiAgICAgICAgUHJvbWlzZS1iYXNlZCB3cmFwcGVyIGZ1bmN0aW9ucyBmb3IgYXN5bmNocm9ub3VzLiBBbnkgZnVuY3Rpb24gaW5cbiAgICAgICAqICAgICAgICB0aGUgYHRhcmdldGAgb2JqZWN0IHRyZWUgd2hpY2ggaGFzIGEgY29ycmVzcG9uZGluZyBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqICAgICAgICBpbiB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgYG1ldGFkYXRhYCB0cmVlIGlzIHJlcGxhY2VkIHdpdGggYW5cbiAgICAgICAqICAgICAgICBhdXRvbWF0aWNhbGx5LWdlbmVyYXRlZCB3cmFwcGVyIGZ1bmN0aW9uLCBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAqICAgICAgICB7QHNlZSB3cmFwQXN5bmNGdW5jdGlvbn1cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7UHJveHk8b2JqZWN0Pn1cbiAgICAgICAqL1xuXG4gICAgICBjb25zdCB3cmFwT2JqZWN0ID0gKHRhcmdldCwgd3JhcHBlcnMgPSB7fSwgbWV0YWRhdGEgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgaGFzKHByb3h5VGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQgfHwgcHJvcCBpbiBjYWNoZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0KHByb3h5VGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3Byb3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1ldGhvZCBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuIENoZWNrIGlmIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgICAgLy8gYW55IHdyYXBwaW5nLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdyYXBwZXJzW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc3BlY2lhbC1jYXNlIHdyYXBwZXIgZm9yIHRoaXMgbWV0aG9kLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcE1ldGhvZCh0YXJnZXQsIHRhcmdldFtwcm9wXSwgd3JhcHBlcnNbcHJvcF0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgbWV0aG9kIHRoYXQgd2UgaGF2ZSBtZXRhZGF0YSBmb3IuIENyZWF0ZSBhXG4gICAgICAgICAgICAgICAgLy8gUHJvbWlzZSB3cmFwcGVyIGZvciBpdC5cbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlciA9IHdyYXBBc3luY0Z1bmN0aW9uKHByb3AsIG1ldGFkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBNZXRob2QodGFyZ2V0LCB0YXJnZXRbcHJvcF0sIHdyYXBwZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2QgdGhhdCB3ZSBkb24ndCBrbm93IG9yIGNhcmUgYWJvdXQuIFJldHVybiB0aGVcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBtZXRob2QsIGJvdW5kIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgKGhhc093blByb3BlcnR5KHdyYXBwZXJzLCBwcm9wKSB8fCBoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgcHJvcCkpKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb2JqZWN0IHRoYXQgd2UgbmVlZCB0byBkbyBzb21lIHdyYXBwaW5nIGZvciB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgLy8gb2YuIENyZWF0ZSBhIHN1Yi1vYmplY3Qgd3JhcHBlciBmb3IgaXQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY2hpbGRcbiAgICAgICAgICAgICAgLy8gbWV0YWRhdGEuXG4gICAgICAgICAgICAgIHZhbHVlID0gd3JhcE9iamVjdCh2YWx1ZSwgd3JhcHBlcnNbcHJvcF0sIG1ldGFkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIFwiKlwiKSkge1xuICAgICAgICAgICAgICAvLyBXcmFwIGFsbCBwcm9wZXJ0aWVzIGluICogbmFtZXNwYWNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBPYmplY3QodmFsdWUsIHdyYXBwZXJzW3Byb3BdLCBtZXRhZGF0YVtcIipcIl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgd3JhcHBpbmcgZm9yIHRoaXMgcHJvcGVydHksXG4gICAgICAgICAgICAgIC8vIHNvIGp1c3QgZm9yd2FyZCBhbGwgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhY2hlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzZXQocHJveHlUYXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkocHJveHlUYXJnZXQsIHByb3AsIGRlc2MpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGNhY2hlLCBwcm9wLCBkZXNjKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVsZXRlUHJvcGVydHkocHJveHlUYXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KGNhY2hlLCBwcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTsgLy8gUGVyIGNvbnRyYWN0IG9mIHRoZSBQcm94eSBBUEksIHRoZSBcImdldFwiIHByb3h5IGhhbmRsZXIgbXVzdCByZXR1cm4gdGhlXG4gICAgICAgIC8vIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSB0YXJnZXQgaWYgdGhhdCB2YWx1ZSBpcyBkZWNsYXJlZCByZWFkLW9ubHkgYW5kXG4gICAgICAgIC8vIG5vbi1jb25maWd1cmFibGUuIEZvciB0aGlzIHJlYXNvbiwgd2UgY3JlYXRlIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAgICAvLyBwcm90b3R5cGUgc2V0IHRvIGB0YXJnZXRgIGluc3RlYWQgb2YgdXNpbmcgYHRhcmdldGAgZGlyZWN0bHkuXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW5ub3QgcmV0dXJuIGEgY3VzdG9tIG9iamVjdCBmb3IgQVBJcyB0aGF0XG4gICAgICAgIC8vIGFyZSBkZWNsYXJlZCByZWFkLW9ubHkgYW5kIG5vbi1jb25maWd1cmFibGUsIHN1Y2ggYXMgYGNocm9tZS5kZXZ0b29sc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBwcm94eSBoYW5kbGVycyB0aGVtc2VsdmVzIHdpbGwgc3RpbGwgdXNlIHRoZSBvcmlnaW5hbCBgdGFyZ2V0YFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBgcHJveHlUYXJnZXRgLCBzbyB0aGF0IHRoZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAgICAvLyBkZXJlZmVyZW5jZWQgdmlhIHRoZSBvcmlnaW5hbCB0YXJnZXRzLlxuXG4gICAgICAgIGxldCBwcm94eVRhcmdldCA9IE9iamVjdC5jcmVhdGUodGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShwcm94eVRhcmdldCwgaGFuZGxlcnMpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHNldCBvZiB3cmFwcGVyIGZ1bmN0aW9ucyBmb3IgYW4gZXZlbnQgb2JqZWN0LCB3aGljaCBoYW5kbGVzXG4gICAgICAgKiB3cmFwcGluZyBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB0aG9zZSBtZXNzYWdlcyBhcmUgcGFzc2VkLlxuICAgICAgICpcbiAgICAgICAqIEEgc2luZ2xlIHdyYXBwZXIgaXMgY3JlYXRlZCBmb3IgZWFjaCBsaXN0ZW5lciBmdW5jdGlvbiwgYW5kIHN0b3JlZCBpbiBhXG4gICAgICAgKiBtYXAuIFN1YnNlcXVlbnQgY2FsbHMgdG8gYGFkZExpc3RlbmVyYCwgYGhhc0xpc3RlbmVyYCwgb3IgYHJlbW92ZUxpc3RlbmVyYFxuICAgICAgICogcmV0cmlldmUgdGhlIG9yaWdpbmFsIHdyYXBwZXIsIHNvIHRoYXQgIGF0dGVtcHRzIHRvIHJlbW92ZSBhXG4gICAgICAgKiBwcmV2aW91c2x5LWFkZGVkIGxpc3RlbmVyIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtEZWZhdWx0V2Vha01hcDxmdW5jdGlvbiwgZnVuY3Rpb24+fSB3cmFwcGVyTWFwXG4gICAgICAgKiAgICAgICAgQSBEZWZhdWx0V2Vha01hcCBvYmplY3Qgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHdyYXBwZXJcbiAgICAgICAqICAgICAgICBmb3IgYSBnaXZlbiBsaXN0ZW5lciBmdW5jdGlvbiB3aGVuIG9uZSBkb2VzIG5vdCBleGlzdCwgYW5kIHJldHJpZXZlXG4gICAgICAgKiAgICAgICAgYW4gZXhpc3Rpbmcgb25lIHdoZW4gaXQgZG9lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICovXG5cblxuICAgICAgY29uc3Qgd3JhcEV2ZW50ID0gd3JhcHBlck1hcCA9PiAoe1xuICAgICAgICBhZGRMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyLCAuLi5hcmdzKSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZExpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSwgLi4uYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQuaGFzTGlzdGVuZXIod3JhcHBlck1hcC5nZXQobGlzdGVuZXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSk7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG9uUmVxdWVzdEZpbmlzaGVkV3JhcHBlcnMgPSBuZXcgRGVmYXVsdFdlYWtNYXAobGlzdGVuZXIgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXBzIGFuIG9uUmVxdWVzdEZpbmlzaGVkIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgd2lsbCByZXR1cm4gYVxuICAgICAgICAgKiBgZ2V0Q29udGVudCgpYCBwcm9wZXJ0eSB3aGljaCByZXR1cm5zIGEgYFByb21pc2VgIHJhdGhlciB0aGFuIHVzaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2sgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVxXG4gICAgICAgICAqICAgICAgICBUaGUgSEFSIGVudHJ5IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5ldHdvcmsgcmVxdWVzdC5cbiAgICAgICAgICovXG5cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gb25SZXF1ZXN0RmluaXNoZWQocmVxKSB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZFJlcSA9IHdyYXBPYmplY3QocmVxLCB7fVxuICAgICAgICAgIC8qIHdyYXBwZXJzICovXG4gICAgICAgICAgLCB7XG4gICAgICAgICAgICBnZXRDb250ZW50OiB7XG4gICAgICAgICAgICAgIG1pbkFyZ3M6IDAsXG4gICAgICAgICAgICAgIG1heEFyZ3M6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0ZW5lcih3cmFwcGVkUmVxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pOyAvLyBLZWVwIHRyYWNrIGlmIHRoZSBkZXByZWNhdGlvbiB3YXJuaW5nIGhhcyBiZWVuIGxvZ2dlZCBhdCBsZWFzdCBvbmNlLlxuXG4gICAgICBsZXQgbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBvbk1lc3NhZ2VXcmFwcGVycyA9IG5ldyBEZWZhdWx0V2Vha01hcChsaXN0ZW5lciA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHMgYSBtZXNzYWdlIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgbWF5IHNlbmQgcmVzcG9uc2VzIGJhc2VkIG9uXG4gICAgICAgICAqIGl0cyByZXR1cm4gdmFsdWUsIHJhdGhlciB0aGFuIGJ5IHJldHVybmluZyBhIHNlbnRpbmVsIHZhbHVlIGFuZCBjYWxsaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2suIElmIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZSwgdGhlIHJlc3BvbnNlIGlzXG4gICAgICAgICAqIHNlbnQgd2hlbiB0aGUgcHJvbWlzZSBlaXRoZXIgcmVzb2x2ZXMgb3IgcmVqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAgICAgICAqICAgICAgICBUaGUgbWVzc2FnZSBzZW50IGJ5IHRoZSBvdGhlciBlbmQgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZW5kZXJcbiAgICAgICAgICogICAgICAgIERldGFpbHMgYWJvdXQgdGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gc2VuZFJlc3BvbnNlXG4gICAgICAgICAqICAgICAgICBBIGNhbGxiYWNrIHdoaWNoLCB3aGVuIGNhbGxlZCB3aXRoIGFuIGFyYml0cmFyeSBhcmd1bWVudCwgc2VuZHNcbiAgICAgICAgICogICAgICAgIHRoYXQgdmFsdWUgYXMgYSByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqICAgICAgICBUcnVlIGlmIHRoZSB3cmFwcGVkIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBsYXRlclxuICAgICAgICAgKiAgICAgICAgeWllbGQgYSByZXNwb25zZS4gRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBvbk1lc3NhZ2UobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICBsZXQgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCB3cmFwcGVkU2VuZFJlc3BvbnNlO1xuICAgICAgICAgIGxldCBzZW5kUmVzcG9uc2VQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkU2VuZFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICghbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaWRDYWxsU2VuZFJlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIobWVzc2FnZSwgc2VuZGVyLCB3cmFwcGVkU2VuZFJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNSZXN1bHRUaGVuYWJsZSA9IHJlc3VsdCAhPT0gdHJ1ZSAmJiBpc1RoZW5hYmxlKHJlc3VsdCk7IC8vIElmIHRoZSBsaXN0ZW5lciBkaWRuJ3QgcmV0dXJuZWQgdHJ1ZSBvciBhIFByb21pc2UsIG9yIGNhbGxlZFxuICAgICAgICAgIC8vIHdyYXBwZWRTZW5kUmVzcG9uc2Ugc3luY2hyb25vdXNseSwgd2UgY2FuIGV4aXQgZWFybGllclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBubyByZXNwb25zZSBzZW50IGZyb20gdGhpcyBsaXN0ZW5lci5cblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUgJiYgIWlzUmVzdWx0VGhlbmFibGUgJiYgIWRpZENhbGxTZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIEEgc21hbGwgaGVscGVyIHRvIHNlbmQgdGhlIG1lc3NhZ2UgaWYgdGhlIHByb21pc2UgcmVzb2x2ZXNcbiAgICAgICAgICAvLyBhbmQgYW4gZXJyb3IgaWYgdGhlIHByb21pc2UgcmVqZWN0cyAoYSB3cmFwcGVkIHNlbmRNZXNzYWdlIGhhc1xuICAgICAgICAgIC8vIHRvIHRyYW5zbGF0ZSB0aGUgbWVzc2FnZSBpbnRvIGEgcmVzb2x2ZWQgcHJvbWlzZSBvciBhIHJlamVjdGVkXG4gICAgICAgICAgLy8gcHJvbWlzZSkuXG5cblxuICAgICAgICAgIGNvbnN0IHNlbmRQcm9taXNlZFJlc3VsdCA9IHByb21pc2UgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKG1zZyA9PiB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1lc3NhZ2UgdmFsdWUuXG4gICAgICAgICAgICAgIHNlbmRSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAvLyBTZW5kIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaWYgdGhlIHJlamVjdGVkIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGlzIGFuIGluc3RhbmNlIG9mIGVycm9yLCBvciB0aGUgb2JqZWN0IGl0c2VsZiBvdGhlcndpc2UuXG4gICAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuXG4gICAgICAgICAgICAgIGlmIChlcnJvciAmJiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIF9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgLy8gUHJpbnQgYW4gZXJyb3Igb24gdGhlIGNvbnNvbGUgaWYgdW5hYmxlIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgb25NZXNzYWdlIHJlamVjdGVkIHJlcGx5XCIsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJuZWQgYSBQcm9taXNlLCBzZW5kIHRoZSByZXNvbHZlZCB2YWx1ZSBhcyBhXG4gICAgICAgICAgLy8gcmVzdWx0LCBvdGhlcndpc2Ugd2FpdCB0aGUgcHJvbWlzZSByZWxhdGVkIHRvIHRoZSB3cmFwcGVkU2VuZFJlc3BvbnNlXG4gICAgICAgICAgLy8gY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbmQgc2VuZCBpdCBhcyBhIHJlc3BvbnNlLlxuXG5cbiAgICAgICAgICBpZiAoaXNSZXN1bHRUaGVuYWJsZSkge1xuICAgICAgICAgICAgc2VuZFByb21pc2VkUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChzZW5kUmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICB9IC8vIExldCBDaHJvbWUga25vdyB0aGF0IHRoZSBsaXN0ZW5lciBpcyByZXBseWluZy5cblxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2sgPSAoe1xuICAgICAgICByZWplY3QsXG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0sIHJlcGx5KSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IHdoZW4gbm9uZSBvZiB0aGUgbGlzdGVuZXJzIHJlcGxpZWQgdG8gdGhlIHNlbmRNZXNzYWdlIGNhbGwgYW5kIHJlc29sdmVcbiAgICAgICAgICAvLyB0aGUgcHJvbWlzZSB0byB1bmRlZmluZWQgYXMgaW4gRmlyZWZveC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2lzc3Vlcy8xMzBcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlID09PSBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVwbHkgJiYgcmVwbHkuX19tb3pXZWJFeHRlbnNpb25Qb2x5ZmlsbFJlamVjdF9fKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBiYWNrIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvciBpbnRvXG4gICAgICAgICAgLy8gYW4gRXJyb3IgaW5zdGFuY2UuXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXBseS5tZXNzYWdlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXBseSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRTZW5kTWVzc2FnZSA9IChuYW1lLCBtZXRhZGF0YSwgYXBpTmFtZXNwYWNlT2JqLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IG1ldGFkYXRhLm1pbkFyZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0ICR7bWV0YWRhdGEubWluQXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWluQXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gbWV0YWRhdGEubWF4QXJncykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbW9zdCAke21ldGFkYXRhLm1heEFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1heEFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZENiID0gd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2suYmluZChudWxsLCB7XG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJncy5wdXNoKHdyYXBwZWRDYik7XG4gICAgICAgICAgYXBpTmFtZXNwYWNlT2JqLnNlbmRNZXNzYWdlKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0YXRpY1dyYXBwZXJzID0ge1xuICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgIG5ldHdvcms6IHtcbiAgICAgICAgICAgIG9uUmVxdWVzdEZpbmlzaGVkOiB3cmFwRXZlbnQob25SZXF1ZXN0RmluaXNoZWRXcmFwcGVycylcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICBvbk1lc3NhZ2U6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgb25NZXNzYWdlRXh0ZXJuYWw6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB0YWJzOiB7XG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMixcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0dGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjbGVhcjoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhcGlNZXRhZGF0YS5wcml2YWN5ID0ge1xuICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgd2Vic2l0ZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gd3JhcE9iamVjdChleHRlbnNpb25BUElzLCBzdGF0aWNXcmFwcGVycywgYXBpTWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNocm9tZSAhPSBcIm9iamVjdFwiIHx8ICFjaHJvbWUgfHwgIWNocm9tZS5ydW50aW1lIHx8ICFjaHJvbWUucnVudGltZS5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY3JpcHQgc2hvdWxkIG9ubHkgYmUgbG9hZGVkIGluIGEgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgIH0gLy8gVGhlIGJ1aWxkIHByb2Nlc3MgYWRkcyBhIFVNRCB3cmFwcGVyIGFyb3VuZCB0aGlzIGZpbGUsIHdoaWNoIG1ha2VzIHRoZVxuICAgIC8vIGBtb2R1bGVgIHZhcmlhYmxlIGF2YWlsYWJsZS5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3cmFwQVBJcyhjaHJvbWUpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYnJvd3NlcjtcbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXBvbHlmaWxsLmpzLm1hcFxuIiwiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsImV4cG9ydCBlbnVtIEFsZXJ0VHlwZXMge1xyXG4gIHVuY29ubmVjdGVkQWNjb3VudCA9ICd1bmNvbm5lY3RlZEFjY291bnQnLFxyXG4gIHdlYjNTaGltVXNhZ2UgPSAnd2ViM1NoaW1Vc2FnZScsXHJcbiAgaW52YWxpZEN1c3RvbU5ldHdvcmsgPSAnaW52YWxpZEN1c3RvbU5ldHdvcmsnLFxyXG59XHJcblxyXG4vKipcclxuICogQWxlcnRzIHRoYXQgY2FuIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQgYnkgdGhlIHVzZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVE9HR0xFQUJMRV9BTEVSVF9UWVBFUyA9IFtcclxuICBBbGVydFR5cGVzLnVuY29ubmVjdGVkQWNjb3VudCxcclxuICBBbGVydFR5cGVzLndlYjNTaGltVXNhZ2UsXHJcbl07XHJcblxyXG5leHBvcnQgZW51bSBXZWIzU2hpbVVzYWdlQWxlcnRTdGF0ZXMge1xyXG4gIHJlY29yZGVkID0gMSxcclxuICBkaXNtaXNzZWQgPSAyLFxyXG59XHJcbiIsIlxuaW1wb3J0IHsgUmVzdHJpY3RlZE1ldGhvZHMgfSBmcm9tICcuL3Blcm1pc3Npb25zJztcclxuXHJcbi8qKlxyXG4gKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgZW52aXJvbm1lbnQgdGhlIGFwcGxpY2F0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nIGluXHJcbiAqIHBvcHVwIC0gV2hlbiB0aGUgdXNlciBjbGljaydzIHRoZSBpY29uIGluIHRoZWlyIGJyb3dzZXIncyBleHRlbnNpb24gYmFyOyB0aGUgZGVmYXVsdCB2aWV3XHJcbiAqIG5vdGlmaWNhdGlvbiAtIFdoZW4gdGhlIGV4dGVuc2lvbiBvcGVucyBkdWUgdG8gaW50ZXJhY3Rpb24gd2l0aCBhIFdlYjMgZW5hYmxlZCB3ZWJzaXRlXHJcbiAqIGZ1bGxzY3JlZW4gLSBXaGVuIHRoZSB1c2VyIGNsaWNrcyAnZXhwYW5kIHZpZXcnIHRvIG9wZW4gdGhlIGV4dGVuc2lvbiBpbiBhIG5ldyB0YWJcclxuICogYmFja2dyb3VuZCAtIFRoZSBiYWNrZ3JvdW5kIHByb2Nlc3MgdGhhdCBwb3dlcnMgdGhlIGV4dGVuc2lvblxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRW52aXJvbm1lbnRUeXBlID1cclxuICB8ICdwb3B1cCdcclxuICB8ICdub3RpZmljYXRpb24nXHJcbiAgfCAnZnVsbHNjcmVlbidcclxuICB8ICdiYWNrZ3JvdW5kJztcclxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfUE9QVVAgPSAncG9wdXAnO1xyXG5leHBvcnQgY29uc3QgRU5WSVJPTk1FTlRfVFlQRV9OT1RJRklDQVRJT04gPSAnbm90aWZpY2F0aW9uJztcclxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTiA9ICdmdWxsc2NyZWVuJztcclxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfQkFDS0dST1VORCA9ICdiYWNrZ3JvdW5kJztcclxuXHJcbmV4cG9ydCBjb25zdCBQTEFURk9STV9CUkFWRSA9ICdCcmF2ZSc7XHJcbmV4cG9ydCBjb25zdCBQTEFURk9STV9DSFJPTUUgPSAnQ2hyb21lJztcclxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0VER0UgPSAnRWRnZSc7XHJcbmV4cG9ydCBjb25zdCBQTEFURk9STV9GSVJFRk9YID0gJ0ZpcmVmb3gnO1xyXG5leHBvcnQgY29uc3QgUExBVEZPUk1fT1BFUkEgPSAnT3BlcmEnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1FU1NBR0VfVFlQRSA9IHtcclxuICBBRERfRVRIRVJFVU1fQ0hBSU46ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXHJcbiAgRVRIX0FDQ09VTlRTOiBSZXN0cmljdGVkTWV0aG9kcy5ldGhfYWNjb3VudHMsXHJcbiAgRVRIX0RFQ1JZUFQ6ICdldGhfZGVjcnlwdCcsXHJcbiAgRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVk6ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXHJcbiAgRVRIX1JFUVVFU1RfQUNDT1VOVFM6ICdldGhfcmVxdWVzdEFjY291bnRzJyxcclxuICBFVEhfU0lHTjogJ2V0aF9zaWduJyxcclxuICBFVEhfU0lHTl9UWVBFRF9EQVRBOiAnZXRoX3NpZ25UeXBlZERhdGEnLFxyXG4gIEVUSF9TSUdOX1RZUEVEX0RBVEFfVjM6ICdldGhfc2lnblR5cGVkRGF0YV92MycsXHJcbiAgRVRIX1NJR05fVFlQRURfREFUQV9WNDogJ2V0aF9zaWduVHlwZWREYXRhX3Y0JyxcclxuICBHRVRfUFJPVklERVJfU1RBVEU6ICdtZXRhbWFza19nZXRQcm92aWRlclN0YXRlJyxcclxuICBMT0dfV0VCM19TSElNX1VTQUdFOiAnbWV0YW1hc2tfbG9nV2ViM1NoaW1Vc2FnZScsXHJcbiAgUEVSU09OQUxfU0lHTjogJ3BlcnNvbmFsX3NpZ24nLFxyXG4gIFNFTkRfTUVUQURBVEE6ICdtZXRhbWFza19zZW5kRG9tYWluTWV0YWRhdGEnLFxyXG4gIFNXSVRDSF9FVEhFUkVVTV9DSEFJTjogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcclxuICBUUkFOU0FDVElPTjogJ3RyYW5zYWN0aW9uJyxcclxuICBXQUxMRVRfUkVRVUVTVF9QRVJNSVNTSU9OUzogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxyXG4gIFdBVENIX0FTU0VUOiAnd2FsbGV0X3dhdGNoQXNzZXQnLFxyXG4gIFdBVENIX0FTU0VUX0xFR0FDWTogJ21ldGFtYXNrX3dhdGNoQXNzZXQnLFxyXG5cblxufSBhcyBjb25zdDtcclxuXHJcblxuXHJcbi8qKlxyXG4gKiBDdXN0b20gbWVzc2FnZXMgdG8gc2VuZCBhbmQgYmUgcmVjZWl2ZWQgYnkgdGhlIGV4dGVuc2lvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEVYVEVOU0lPTl9NRVNTQUdFUyA9IHtcclxuICBDT05ORUNUSU9OX1JFQURZOiAnQ09OTkVDVElPTl9SRUFEWScsXHJcbiAgUkVBRFk6ICdNRVRBTUFTS19FWFRFTlNJT05fUkVBRFknLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFBPTExJTkdfVE9LRU5fRU5WSVJPTk1FTlRfVFlQRVMgPSB7XHJcbiAgW0VOVklST05NRU5UX1RZUEVfUE9QVVBdOiAncG9wdXBHYXNQb2xsVG9rZW5zJyxcclxuICBbRU5WSVJPTk1FTlRfVFlQRV9OT1RJRklDQVRJT05dOiAnbm90aWZpY2F0aW9uR2FzUG9sbFRva2VucycsXHJcbiAgW0VOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTl06ICdmdWxsU2NyZWVuR2FzUG9sbFRva2VucycsXHJcbiAgW0VOVklST05NRU5UX1RZUEVfQkFDS0dST1VORF06ICdub25lJyxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBPUklHSU5fTUVUQU1BU0sgPSAnbWV0YW1hc2snO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0JFVEFfQ0hST01FX0lEID0gJ3BiYmthbWZnbWFlZGNjbmZrbWpjb2ZjZWNqaGZnbGRuJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX1BST0RfQ0hST01FX0lEID0gJ25rYmloZmJlb2dhZWFvZWhsZWZua29kYmVmZ3Bna25uJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0ZMQVNLX0NIUk9NRV9JRCA9ICdsamZvZWluanBhZWRqZmVjYm1nZ2pnb2RiZ2ttamtqayc7XHJcblxyXG5leHBvcnQgY29uc3QgTUVUQU1BU0tfTU1JX0JFVEFfQ0hST01FX0lEID0gJ2ttYmhiY2JhZG9oaGhnZGdpaGVqY2ljYmdjZWhvYWVnJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX01NSV9QUk9EX0NIUk9NRV9JRCA9ICdpa2tpaGphbWRoZmlvanBkYm5mbGxwamlncG5laXBiYyc7XHJcblxyXG5leHBvcnQgY29uc3QgQ0hST01FX0JVSUxEX0lEUyA9IFtcclxuICBNRVRBTUFTS19CRVRBX0NIUk9NRV9JRCxcclxuICBNRVRBTUFTS19QUk9EX0NIUk9NRV9JRCxcclxuICBNRVRBTUFTS19GTEFTS19DSFJPTUVfSUQsXHJcbiAgTUVUQU1BU0tfTU1JX0JFVEFfQ0hST01FX0lELFxyXG4gIE1FVEFNQVNLX01NSV9QUk9EX0NIUk9NRV9JRCxcclxuXSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IE1FVEFNQVNLX0JFVEFfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb24tYmV0YUBtZXRhbWFzay5pbyc7XHJcbmNvbnN0IE1FVEFNQVNLX1BST0RfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb25AbWV0YW1hc2suaW8nO1xyXG5jb25zdCBNRVRBTUFTS19GTEFTS19GSVJFRk9YX0lEID0gJ3dlYmV4dGVuc2lvbi1mbGFza0BtZXRhbWFzay5pbyc7XHJcblxyXG5leHBvcnQgY29uc3QgRklSRUZPWF9CVUlMRF9JRFMgPSBbXHJcbiAgTUVUQU1BU0tfQkVUQV9GSVJFRk9YX0lELFxyXG4gIE1FVEFNQVNLX1BST0RfRklSRUZPWF9JRCxcclxuICBNRVRBTUFTS19GTEFTS19GSVJFRk9YX0lELFxyXG5dIGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFVOS05PV05fVElDS0VSX1NZTUJPTCA9ICdVTktOT1dOJztcclxuIiwiZXhwb3J0IGVudW0gRXRoZXJEZW5vbWluYXRpb24ge1xyXG4gIEVUSCA9ICdFVEgnLFxyXG4gIEdXRUkgPSAnR1dFSScsXHJcbiAgV0VJID0gJ1dFSScsXHJcbn1cclxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuXHJcbmNvbnN0IE9ORV9IVU5EUkVEX1RIT1VTQU5EID0gMTAwMDAwO1xyXG5jb25zdCBNSU5fR0FTX0xJTUlUX0RFQyA9ICcyMTAwMCc7XHJcblxyXG5leHBvcnQgY29uc3QgTUlOX0dBU19MSU1JVF9IRVggPSBwYXJzZUludChNSU5fR0FTX0xJTUlUX0RFQywgMTApLnRvU3RyaW5nKDE2KTtcclxuXHJcbmV4cG9ydCBjb25zdCBHQVNfTElNSVRTID0ge1xyXG4gIC8vIG1heGltdW0gZ2FzTGltaXQgb2YgYSBzaW1wbGUgc2VuZFxyXG4gIFNJTVBMRTogYWRkSGV4UHJlZml4KE1JTl9HQVNfTElNSVRfSEVYKSxcclxuICAvLyBhIGJhc2UgZXN0aW1hdGUgZm9yIHRva2VuIHRyYW5zZmVycy5cclxuICBCQVNFX1RPS0VOX0VTVElNQVRFOiBhZGRIZXhQcmVmaXgoT05FX0hVTkRSRURfVEhPVVNBTkQudG9TdHJpbmcoMTYpKSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBHYXNFc3RpbWF0ZVR5cGVzXHJcbiAqIEBwcm9wZXJ0eSB7J2ZlZS1tYXJrZXQnfSBGRUVfTUFSS0VUIC0gQSBnYXMgZXN0aW1hdGUgZm9yIGEgZmVlIG1hcmtldCB0cmFuc2FjdGlvbiBnZW5lcmF0ZWQgYnkgb3VyIGdhcyBlc3RpbWF0aW9uIEFQSS5cclxuICogQHByb3BlcnR5IHsnbGVnYWN5J30gTEVHQUNZIC0gQSBnYXMgZXN0aW1hdGUgZm9yIGEgbGVnYWN5IFRyYW5zYWN0aW9uIGdlbmVyYXRlZCBieSBvdXIgZ2FzIGVzdGltYXRpb24gQVBJLlxyXG4gKiBAcHJvcGVydHkgeydldGhfZ2FzUHJpY2UnfSBFVEhfR0FTX1BSSUNFIC0gQSBnYXMgZXN0aW1hdGUgcHJvdmlkZWQgYnkgdGhlIEV0aGVyZXVtIG5vZGUgdmlhIGV0aF9nYXNQcmljZS5cclxuICogQHByb3BlcnR5IHsnbm9uZSd9IE5PTkUgLSBObyBnYXMgZXN0aW1hdGUgYXZhaWxhYmxlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGVzZSBhcmUgYWxyZWFkeSBkZWNsYXJlZCBpbiBAbWV0YW1hc2svY29udHJvbGxlcnMgYnV0IGltcG9ydGluZyB0aGVtIGZyb21cclxuICogdGhhdCBtb2R1bGUgYW5kIHJlLWV4cG9ydGluZyBjYXVzZXMgdGhlIFVJIGJ1bmRsZSBzaXplIHRvIGV4cGFuZCBiZXlvbmQgNE1CXHJcbiAqXHJcbiAqIChUT0RPOiBUaGlzIGNvbW1lbnQgd2FzIGFkZGVkIGJlZm9yZSBAbWV0YW1hc2svY29udHJvbGxlcnMgd2FzIHNwbGl0IHVwIOKAlFxyXG4gKiByZXZpc2l0IG5vdyB0aGF0IEBtZXRhbWFzay9nYXMtZmVlLWNvbnRyb2xsZXIgaXMgYXZhaWxhYmxlKVxyXG4gKlxyXG4gKiBAdHlwZSB7R2FzRXN0aW1hdGVUeXBlc31cclxuICovXHJcbmV4cG9ydCBlbnVtIEdhc0VzdGltYXRlVHlwZXMge1xyXG4gIGZlZU1hcmtldCA9ICdmZWUtbWFya2V0JyxcclxuICBsZWdhY3kgPSAnbGVnYWN5JyxcclxuICBldGhHYXNQcmljZSA9ICdldGhfZ2FzUHJpY2UnLFxyXG4gIG5vbmUgPSAnbm9uZScsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgZ2FzIHJlY29tbWVuZGF0aW9uIGxldmVscyBwcmVzZW50ZWQgaW4gdGhlIFVJXHJcbiAqL1xyXG5leHBvcnQgZW51bSBHYXNSZWNvbW1lbmRhdGlvbnMge1xyXG4gIGxvdyA9ICdsb3cnLFxyXG4gIG1lZGl1bSA9ICdtZWRpdW0nLFxyXG4gIGhpZ2ggPSAnaGlnaCcsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgdHlwZXMgb2YgZ2FzIGVzdGltYXRpb25cclxuICovXHJcbmV4cG9ydCBlbnVtIFByaW9yaXR5TGV2ZWxzIHtcclxuICB0ZW5QZXJjZW50SW5jcmVhc2VkID0gJ3RlblBlcmNlbnRJbmNyZWFzZWQnLFxyXG4gIGxvdyA9ICdsb3cnLFxyXG4gIG1lZGl1bSA9ICdtZWRpdW0nLFxyXG4gIGhpZ2ggPSAnaGlnaCcsXHJcbiAgY3VzdG9tID0gJ2N1c3RvbScsXHJcbiAgZEFwcFN1Z2dlc3RlZCA9ICdkYXBwU3VnZ2VzdGVkJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHVzZXIgY3VzdG9taXppbmcgdGhlaXIgZ2FzIHByZWZlcmVuY2VcclxuICovXHJcbmV4cG9ydCBjb25zdCBDVVNUT01fR0FTX0VTVElNQVRFID0gJ2N1c3RvbSc7XHJcblxyXG4vKipcclxuICogVGhlc2UgcmVwcmVzZW50IHRoZSBkaWZmZXJlbnQgZWRpdCBtb2RlcyBwcmVzZW50ZWQgaW4gdGhlIFVJXHJcbiAqL1xyXG5leHBvcnQgZW51bSBFZGl0R2FzTW9kZXMge1xyXG4gIHNwZWVkVXAgPSAnc3BlZWQtdXAnLFxyXG4gIGNhbmNlbCA9ICdjYW5jZWwnLFxyXG4gIG1vZGlmeUluUGxhY2UgPSAnbW9kaWZ5LWluLXBsYWNlJyxcclxuICBzd2FwcyA9ICdzd2FwcycsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGxldmVscyBmb3IgYG5ldHdvcmtDb25nZXN0aW9uYCAoY2FsY3VsYXRlZCBhbG9uZyB3aXRoIGdhcyBmZWVcclxuICogZXN0aW1hdGVzOyByZXByZXNlbnRzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSkgdGhhdCB3ZSB1c2UgdG8gcmVuZGVyIHRoZVxyXG4gKiBuZXR3b3JrIHN0YXR1cyBzbGlkZXIgb24gdGhlIHNlbmQgdHJhbnNhY3Rpb24gc2NyZWVuIGFuZCBpbmZvcm0gdXNlcnMgd2hlblxyXG4gKiBnYXMgZmVlcyBhcmUgaGlnaFxyXG4gKi9cclxuZXhwb3J0IGVudW0gTmV0d29ya0Nvbmdlc3Rpb25UaHJlc2hvbGRzIHtcclxuICBub3RCdXN5ID0gMCxcclxuICBzdGFibGUgPSAwLjMzLFxyXG4gIGJ1c3kgPSAwLjY2LFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFR4R2FzRmVlcyB7XHJcbiAgLyoqIE1heG1pbXVtIG51bWJlciBvZiB1bml0cyBvZiBnYXMgdG8gdXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiAqL1xyXG4gIGdhc0xpbWl0OiBzdHJpbmc7XHJcbiAgLyoqIFByaWNlIHBlciBnYXMgZm9yIGxlZ2FjeSB0eHMgKi9cclxuICBnYXNQcmljZTogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIE1heGltdW0gYW1vdW50IHBlciBnYXMgdG8gcGF5IGZvciB0aGUgdHJhbnNhY3Rpb24sIGluY2x1ZGluZyB0aGUgcHJpb3JpdHlcclxuICAgKiBmZWUuXHJcbiAgICovXHJcbiAgbWF4RmVlUGVyR2FzOiBzdHJpbmc7XHJcbiAgLyoqIE1heGltdW0gYW1vdW50IHBlciBnYXMgdG8gZ2l2ZSB0byB2YWxpZGF0b3IgYXMgaW5jZW50aXZlLiAqL1xyXG4gIG1heFByaW9yaXR5RmVlUGVyR2FzOiBzdHJpbmc7XHJcbiAgLyoqIFdoaWNoIGVzdGltYXRlIGxldmVsIHdhcyB1c2VkICovXHJcbiAgZXN0aW1hdGVVc2VkOiBzdHJpbmc7XHJcbiAgLyoqIFdoaWNoIGVzdGltYXRlIGxldmVsIHRoYXQgdGhlIEFQSSBzdWdnZXN0ZWQuICovXHJcbiAgZXN0aW1hdGVTdWdnZXN0ZWQ6IHN0cmluZztcclxuICAvKiogVGhlIGRlZmF1bHQgZXN0aW1hdGUgZm9yIGdhcy4gKi9cclxuICBkZWZhdWx0R2FzRXN0aW1hdGVzOiBzdHJpbmc7XHJcbiAgLyoqIHNhbWUgYXMgZ2FzTGltaXQ/ICovXHJcbiAgZ2FzOiBzdHJpbmc7XHJcbiAgLyoqIE9yaWdpbmFsIGVzdGltYXRlIGZvciBnYXMuICovXHJcbiAgb3JpZ2luYWxHYXNFc3RpbWF0ZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgZ2FzIGxpbWl0IHN1cHBsaWVkIGJ5IHVzZXIuICovXHJcbiAgdXNlckVkaXRlZEdhc0xpbWl0OiBzdHJpbmc7XHJcbiAgLyoqIEVzdGltYXRlIGxldmVsIHVzZXIgc2VsZWN0ZWQuICovXHJcbiAgdXNlckZlZUxldmVsOiBzdHJpbmc7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEhhcmR3YXJlIHdhbGxldHMgc3VwcG9ydGVkIGJ5IE1ldGFNYXNrLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gSGFyZHdhcmVLZXlyaW5nVHlwZSB7XHJcbiAgbGVkZ2VyID0gJ0xlZGdlciBIYXJkd2FyZScsXHJcbiAgdHJlem9yID0gJ1RyZXpvciBIYXJkd2FyZScsXHJcbiAgbGF0dGljZSA9ICdMYXR0aWNlIEhhcmR3YXJlJyxcclxuICBxciA9ICdRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gSGFyZHdhcmVLZXlyaW5nTmFtZXMge1xyXG4gIGxlZGdlciA9ICdMZWRnZXInLFxyXG4gIHRyZXpvciA9ICdUcmV6b3InLFxyXG4gIGxhdHRpY2UgPSAnTGF0dGljZTEnLFxyXG4gIHFyID0gJ1FSJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gSGFyZHdhcmVEZXZpY2VOYW1lcyB7XHJcbiAgbGVkZ2VyID0gJ2xlZGdlcicsXHJcbiAgdHJlem9yID0gJ3RyZXpvcicsXHJcbiAgbGF0dGljZSA9ICdsYXR0aWNlJyxcclxuICBxciA9ICdRUiBIYXJkd2FyZScsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEhhcmR3YXJlVHJhbnNwb3J0U3RhdGVzIHtcclxuICBub25lID0gJ05PTkUnLFxyXG4gIHZlcmlmaWVkID0gJ1ZFUklGSUVEJyxcclxuICBkZXZpY2VPcGVuRmFpbHVyZSA9ICdERVZJQ0VfT1BFTl9GQUlMVVJFJyxcclxuICB1bmtub3duRmFpbHVyZSA9ICdVTktOT1dOX0ZBSUxVUkUnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBIYXJkd2FyZUFmZmlsaWF0ZUxpbmtzIHtcclxuICBsZWRnZXIgPSAnaHR0cHM6Ly9zaG9wLmxlZGdlci5jb20vP3I9MTdjNDk5MWEwM2ZhJyxcclxuICBncmlkcGx1cyA9ICdodHRwczovL2dyaWRwbHVzLmlvLz9hZm1jPTdwJyxcclxuICB0cmV6b3IgPSAnaHR0cHM6Ly9zaG9wLnRyZXpvci5pby9wcm9kdWN0L3RyZXpvci1vbmUtYmxhY2s/b2ZmZXJfaWQ9MzUmYWZmX2lkPTExMDA5JyxcclxuICBrZXlzdG9uZSA9ICdodHRwczovL2tleXN0Lm9uZS9tZXRhbWFzaz9yZnNuPTYwODgyNTcuNjU2YjNlOSZ1dG1fc291cmNlPXJlZmVyc2lvbiZ1dG1fbWVkaXVtPWFmZmlsaWF0ZSZ1dG1fY2FtcGFpZ249NjA4ODI1Ny42NTZiM2U5JyxcclxuICBhaXJnYXAgPSAnaHR0cHM6Ly9haXJnYXAuaXQvJyxcclxuICBjb29sd2FsbGV0ID0gJ2h0dHBzOi8vd3d3LmNvb2x3YWxsZXQuaW8vJyxcclxuICBkY2VudCA9ICdodHRwczovL2RjZW50d2FsbGV0LmNvbS8nLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBIYXJkd2FyZUFmZmlsaWF0ZVR1dG9yaWFsTGlua3Mge1xyXG4gIGxlZGdlciA9ICdodHRwczovL3N1cHBvcnQubGVkZ2VyLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDA0MzY2ODY0NjU3LVNldC11cC1hbmQtdXNlLU1ldGFNYXNrLXRvLWFjY2Vzcy15b3VyLUxlZGdlci1FdGhlcmV1bS1FVEgtYWNjb3VudD9kb2NzPXRydWUnLFxyXG4gIGdyaWRwbHVzID0gJ2h0dHBzOi8vZG9jcy5ncmlkcGx1cy5pby9zZXR1cC9tZXRhbWFzaycsXHJcbiAgdHJlem9yID0gJ2h0dHBzOi8vd2lraS50cmV6b3IuaW8vQXBwczpNZXRhTWFzaycsXHJcbiAga2V5c3RvbmUgPSAnaHR0cHM6Ly9zdXBwb3J0LmtleXN0Lm9uZS8zcmQtcGFydHktd2FsbGV0cy9ldGgtYW5kLXdlYjMtd2FsbGV0cy1rZXlzdG9uZS9iaW5kLW1ldGFtYXNrLXdpdGgta2V5c3RvbmUnLFxyXG4gIGFpcmdhcCA9ICdodHRwczovL3N1cHBvcnQuYWlyZ2FwLml0L2d1aWRlcy9tZXRhbWFzay8nLFxyXG4gIGNvb2x3YWxsZXQgPSAnaHR0cHM6Ly93d3cuY29vbHdhbGxldC5pby9tZXRhbWFzay1zdGVwLWJ5LXN0ZXAtZ3VpZGVzLycsXHJcbiAgZGNlbnQgPSAnaHR0cHM6Ly9tZWRpdW0uY29tL2RjZW50d2FsbGV0L2RjZW50LXdhbGxldC1ub3ctc3VwcG9ydHMtcXItYmFzZWQtcHJvdG9jb2wtdG8tbGluay13aXRoLW1ldGFtYXNrLTU3NTU1ZjAyNjAzZicsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIGZvciBzZXR0aW5nIHRoZSB1c2VycyBwcmVmZXJlbmNlIGZvciBsZWRnZXIgdHJhbnNwb3J0IHR5cGVcclxuICovXHJcbmV4cG9ydCBlbnVtIExlZGdlclRyYW5zcG9ydFR5cGVzIHtcclxuICBsaXZlID0gJ2xlZGdlckxpdmUnLFxyXG4gIHdlYmhpZCA9ICd3ZWJoaWQnLFxyXG4gIHUyZiA9ICd1MmYnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBXZWJISURDb25uZWN0ZWRTdGF0dXNlcyB7XHJcbiAgY29ubmVjdGVkID0gJ2Nvbm5lY3RlZCcsXHJcbiAgbm90Q29ubmVjdGVkID0gJ25vdENvbm5lY3RlZCcsXHJcbiAgdW5rbm93biA9ICd1bmtub3duJyxcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IExFREdFUl9VU0JfVkVORE9SX0lEID0gJzB4MmM5Nyc7XHJcbiIsImltcG9ydCB7IEhhcmR3YXJlS2V5cmluZ1R5cGUgfSBmcm9tICcuL2hhcmR3YXJlLXdhbGxldHMnO1xyXG5cclxuLyoqXHJcbiAqIFRoZXNlIGFyZSB0aGUga2V5cmluZ3MgdGhhdCBhcmUgbWFuYWdlZCBlbnRpcmVseSBieSBNZXRhTWFzay5cclxuICovXHJcbmV4cG9ydCBlbnVtIEludGVybmFsS2V5cmluZ1R5cGUge1xyXG4gIGhkS2V5VHJlZSA9ICdIRCBLZXkgVHJlZScsXHJcbiAgaW1wb3J0ZWQgPSAnU2ltcGxlIEtleSBQYWlyJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbCBrZXlyaW5ncyBzdXBwb3J0ZWQgYnkgTWV0YU1hc2suXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgS2V5cmluZ1R5cGUgPSB7XHJcbiAgLi4uSGFyZHdhcmVLZXlyaW5nVHlwZSxcclxuICAuLi5JbnRlcm5hbEtleXJpbmdUeXBlLFxyXG59O1xyXG4iLCIvLyBUaGUgY2hhcmFjdGVyIGxpbWl0IG9uIEVOUyBuYW1lcywgbmlja25hbWVzIGFuZCBhZGRyZXNzZXMgYmVmb3JlIHdlIHRydW5jYXRlXHJcbmV4cG9ydCBjb25zdCBUUlVOQ0FURURfTkFNRV9DSEFSX0xJTUlUID0gMTE7XHJcblxyXG4vLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2xpY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFuIGFkZHJlc3MgZm9yIHRydW5jYXRlZCBmb3JtYXQ6XHJcbi8vIGAke1RSVU5DQVRFRF9BRERSRVNTX1NUQVJUX0NIQVJTfS4uLiR7VFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTfWBcclxuZXhwb3J0IGNvbnN0IFRSVU5DQVRFRF9BRERSRVNTX1NUQVJUX0NIQVJTID0gNTtcclxuXHJcbi8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzbGljZSBmcm9tIHRoZSBlbmQgb2YgYW4gYWRkcmVzcyBmb3IgdHJ1bmNhdGVkIGZvcm1hdDpcclxuLy8gYCR7VFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlN9Li4uJHtUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlN9YFxyXG5leHBvcnQgY29uc3QgVFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTID0gNDtcclxuIiwiaW1wb3J0IHR5cGUgeyBFbnZpcm9ubWVudFR5cGUgfSBmcm9tICcuL2FwcCc7XHJcbmltcG9ydCB7IExlZGdlclRyYW5zcG9ydFR5cGVzIH0gZnJvbSAnLi9oYXJkd2FyZS13YWxsZXRzJztcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIGF0dGFjaCBjb250ZXh0IG9mIHdoZXJlIHRoZSB1c2VyIHdhcyBhdCBpbiB0aGUgYXBwbGljYXRpb24gd2hlbiB0aGVcclxuICogZXZlbnQgd2FzIHRyaWdnZXJlZC4gQWxzbyBpbmNsdWRlZCBhcyBmdWxsIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZSBpblxyXG4gKiBwYWdlIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzUGFnZU9iamVjdCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgcGF0aCBvZiB0aGUgY3VycmVudCBwYWdlIChlLmcuIFwiL2hvbWVcIikuXHJcbiAgICovXHJcbiAgcGF0aD86IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgcGFnZSAoZS5nLiBcImhvbWVcIikuXHJcbiAgICovXHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgcGFnZS5cclxuICAgKi9cclxuICB1cmw/OiBzdHJpbmc7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGRhcHAgdGhhdCB0cmlnZ2VyZWQgYW4gaW50ZXJhY3Rpb24gKE1ldGFNYXNrIG9ubHkpLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgb3JpZ2luIG9mIHRoZSBkYXBwIGlzc3VpbmcgdGhlIG5vdGlmaWNhdGlvbi5cclxuICAgKi9cclxuICB1cmw/OiBzdHJpbmc7XHJcbn07XHJcblxyXG4vKipcclxuICogV2UgYXR0YWNoIGNvbnRleHQgdG8gZXZlcnkgbWV0YSBtZXRyaWNzIGV2ZW50IHRoYXQgaGVscCB0byBxdWFsaWZ5IG91clxyXG4gKiBhbmFseXRpY3MuIFRoaXMgdHlwZSBoYXMgYWxsIG9wdGlvbmFsIHZhbHVlcyBiZWNhdXNlIGl0IHJlcHJlc2VudHMgYVxyXG4gKiByZXR1cm5lZCBvYmplY3QgZnJvbSBhIG1ldGhvZCBjYWxsLiBJZGVhbGx5IGFwcCBhbmQgdXNlckFnZW50IGFyZVxyXG4gKiBkZWZpbmVkIG9uIGV2ZXJ5IGV2ZW50LiBUaGlzIGlzIGNvbmZpcm1lZCBpbiB0aGUgZ2V0VHJhY2tNZXRhTWV0cmljc0V2ZW50XHJcbiAqIGZ1bmN0aW9uLCBidXQgc3RpbGwgcHJvdmlkZXMgdGhlIGNvbnN1bWVyIGEgd2F5IHRvIG92ZXJyaWRlIHRoZXNlIHZhbHVlcyBpZlxyXG4gKiBuZWNlc3NhcnkuXHJcbiAqL1xyXG50eXBlIE1ldGFNZXRyaWNzQ29udGV4dCA9IHtcclxuICAvKipcclxuICAgKiBBcHBsaWNhdGlvbiBtZXRhZGF0YS5cclxuICAgKi9cclxuICBhcHA6IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uIHRyYWNraW5nIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHZlcnNpb246IHN0cmluZztcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIFRoZSB1c2VyIGFnZW50IG9mIHRoZSBhcHBsaWNhdGlvbi5cclxuICAgKi9cclxuICB1c2VyQWdlbnQ6IHN0cmluZztcclxuICAvKipcclxuICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZS5cclxuICAgKi9cclxuICBwYWdlPzogTWV0YU1ldHJpY3NQYWdlT2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBkYXBwIHRoYXQgdHJpZ2dlcmVkIGFuIGludGVyYWN0aW9uIChNZXRhTWFzayBvbmx5KS5cclxuICAgKi9cclxuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBNZXRhTWV0cmljc0V2ZW50UGF5bG9hZCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgZXZlbnQgbmFtZSB0byB0cmFjay5cclxuICAgKi9cclxuICBldmVudDogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBjYXRlZ29yeSB0byBhc3NvY2lhdGUgdGhlIGV2ZW50IHRvLlxyXG4gICAqL1xyXG4gIGNhdGVnb3J5OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGFjdGlvbiBJRCB0byBkZWR1cGxpY2F0ZSBldmVudCByZXF1ZXN0cyBmcm9tIHRoZSBVSS5cclxuICAgKi9cclxuICBhY3Rpb25JZD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBUaGUgdHlwZSBvZiBlbnZpcm9ubWVudCB0aGlzIGV2ZW50IG9jY3VycmVkIGluLiBEZWZhdWx0cyB0byB0aGUgYmFja2dyb3VuZFxyXG4gICAqIHByb2Nlc3MgdHlwZS5cclxuICAgKi9cclxuICBlbnZpcm9ubWVudFR5cGU/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQ3VzdG9tIHZhbHVlcyB0byB0cmFjay4gS2V5cyBpbiB0aGlzIG9iamVjdCBtdXN0IGJlIGBzbmFrZV9jYXNlYC5cclxuICAgKi9cclxuICBwcm9wZXJ0aWVzPzogb2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFNlbnNpdGl2ZSB2YWx1ZXMgdG8gdHJhY2suIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSBzZW50IGluIGFuIGFkZGl0aW9uYWxcclxuICAgKiBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgYG1ldGFNZXRyaWNzSWRgLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmVcclxuICAgKiBpbiBgc25ha2VfY2FzZWAuXHJcbiAgICovXHJcbiAgc2Vuc2l0aXZlUHJvcGVydGllcz86IG9iamVjdDtcclxuICAvKipcclxuICAgKiBBbW91bnQgb2YgY3VycmVuY3kgdGhhdCB0aGUgZXZlbnQgY3JlYXRlcyBpbiByZXZlbnVlIGZvciBNZXRhTWFzay5cclxuICAgKi9cclxuICByZXZlbnVlPzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIElTTy00MTI3LWZvcm1hdHRlZCBjdXJyZW5jeSBmb3IgZXZlbnRzIHdpdGggcmV2ZW51ZS4gRGVmYXVsdHMgdG8gVVNcclxuICAgKiBkb2xsYXJzLlxyXG4gICAqL1xyXG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0IGJ1c2luZXNzIFwidmFsdWVcIiBhdHRyaWJ1dGFibGUgdG8gY3VzdG9tZXJzIHdobyB0cmlnZ2VyIHRoaXMgZXZlbnQuXHJcbiAgICovXHJcbiAgdmFsdWU/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogVGhlIHBhZ2Uvcm91dGUgdGhhdCB0aGUgZXZlbnQgb2NjdXJyZWQgb24uXHJcbiAgICovXHJcbiAgcGFnZT86IE1ldGFNZXRyaWNzUGFnZU9iamVjdDtcclxuICAvKipcclxuICAgKiBUaGUgb3JpZ2luIG9mIHRoZSBkYXBwIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXHJcbiAgICovXHJcbiAgcmVmZXJyZXI/OiBNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0O1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NFdmVudE9wdGlvbnMgPSB7XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciBvciBub3QgdGhlIGV2ZW50IGhhcHBlbmVkIGR1cmluZyB0aGUgb3B0LWluIHdvcmtmbG93LlxyXG4gICAqL1xyXG4gIGlzT3B0SW4/OiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHNlZ21lbnQgcXVldWUgc2hvdWxkIGJlIGZsdXNoZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxyXG4gICAqIFJlY29tbWVuZGVkIGlmIHRoZSByZXN1bHQgb2YgdHJhY2tpbmcgdGhlIGV2ZW50IG11c3QgYmUga25vd24gYmVmb3JlIFVJXHJcbiAgICogdHJhbnNpdGlvbiBvciB1cGRhdGUuXHJcbiAgICovXHJcbiAgZmx1c2hJbW1lZGlhdGVseT86IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBleGNsdWRlIHRoZSB1c2VyJ3MgYG1ldGFNZXRyaWNzSWRgIGZvciBhbm9ueW1pdHkuXHJcbiAgICovXHJcbiAgZXhjbHVkZU1ldGFNZXRyaWNzSWQ/OiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIEFuIG92ZXJyaWRlIGZvciB0aGUgYG1ldGFNZXRyaWNzSWRgIGluIHRoZSBldmVudCAobm8gcHVuIGludGVuZGVkKSBvbmUgaXNcclxuICAgKiBjcmVhdGVkIGFzIGEgcGFydCBvZiBhbiBhc3luY2hyb25vdXMgd29ya2Zsb3csIHN1Y2ggYXMgYXdhaXRpbmcgdGhlIHJlc3VsdFxyXG4gICAqIG9mIHRoZSBNZXRhTWV0cmljcyBvcHQtaW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIHVzZXInc1xyXG4gICAqIGBtZXRhTWV0cmljc0lkYC5cclxuICAgKi9cclxuICBtZXRhTWV0cmljc0lkPzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIElzIHRoaXMgZXZlbnQgYSBob2xkb3ZlciBmcm9tIE1hdG9tbyB0aGF0IG5lZWRzIGZ1cnRoZXIgbWlncmF0aW9uPyBXaGVuXHJcbiAgICogdHJ1ZSwgc2VuZHMgdGhlIGRhdGEgdG8gYSBzcGVjaWFsIFNlZ21lbnQgc291cmNlIHRoYXQgbWFya3MgdGhlIGV2ZW50IGRhdGFcclxuICAgKiBhcyBub3QgY29uZm9ybWluZyB0byBvdXIgc2NoZW1hLlxyXG4gICAqL1xyXG4gIG1hdG9tb0V2ZW50PzogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzRXZlbnRGcmFnbWVudCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgZXZlbnQgbmFtZSB0byBmaXJlIHdoZW4gdGhlIGZyYWdtZW50IGlzIGNsb3NlZCBpbiBhbiBhZmZpcm1hdGl2ZSBhY3Rpb24uXHJcbiAgICovXHJcbiAgc3VjY2Vzc0V2ZW50OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGV2ZW50IG5hbWUgdG8gZmlyZSB3aGVuIHRoZSBmcmFnbWVudCBpcyBjbG9zZWQgd2l0aCBhIHJlamVjdGlvbi5cclxuICAgKi9cclxuICBmYWlsdXJlRXZlbnQ/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgbmFtZSB0byBmaXJlIGltbWVkaWF0ZWx5IHVwb24gZnJhZ21lbnQgY3JlYXRpb24uIFRoaXMgaXMgdXNlZnVsXHJcbiAgICogZm9yIGJ1aWxkaW5nIGZ1bm5lbHMgaW4gbWl4cGFuZWwgYW5kIGZvciByZWR1Y3Rpb24gb2YgY29kZSBkdXBsaWNhdGlvbi5cclxuICAgKi9cclxuICBpbml0aWFsRXZlbnQ/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGV2ZW50IGNhdGVnb3J5IHRvIHVzZSBmb3IgYm90aCB0aGUgc3VjY2VzcyBhbmQgZmFpbHVyZSBldmVudHMuXHJcbiAgICovXHJcbiAgY2F0ZWdvcnk6IHN0cmluZztcclxuICAvKipcclxuICAgKiBTaG91bGQgdGhpcyBmcmFnbWVudCBiZSBwZXJzaXN0ZWQgaW4gc3RhdGUgYW5kIHByb2dyZXNzZWQgYWZ0ZXIgdGhlXHJcbiAgICogZXh0ZW5zaW9uIGlzIGxvY2tlZCBhbmQgdW5sb2NrZWQuXHJcbiAgICovXHJcbiAgcGVyc2lzdD86IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogVGltZSBpbiBzZWNvbmRzIHRoZSBldmVudCBzaG91bGQgYmUgcGVyc2lzdGVkIGZvci4gQWZ0ZXIgdGhlIHRpbWVvdXQgdGhlXHJcbiAgICogZnJhZ21lbnQgd2lsbCBiZSBjbG9zZWQgYXMgYWJhbmRvbmVkLiBJZiBub3Qgc3VwcGxpZWQgdGhlIGZyYWdtZW50IGlzXHJcbiAgICogc3RvcmVkIGluZGVmaW5pdGVseS5cclxuICAgKi9cclxuICB0aW1lb3V0PzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIGBEYXRlLm5vdygpYCB3aGVuIHRoZSBmcmFnbWVudCB3YXMgbGFzdCB1cGRhdGVkLiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVcclxuICAgKiB0aW1lb3V0IGhhcyBleHBpcmVkIGFuZCB0aGUgZnJhZ21lbnQgc2hvdWxkIGJlIGNsb3NlZC5cclxuICAgKi9cclxuICBsYXN0VXBkYXRlZD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBDdXN0b20gdmFsdWVzIHRvIHRyYWNrLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmUgYHNuYWtlX2Nhc2VgLlxyXG4gICAqL1xyXG4gIHByb3BlcnRpZXM/OiBvYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogU2Vuc2l0aXZlIHZhbHVlcyB0byB0cmFjay4gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHNlbnQgaW4gYW4gYWRkaXRpb25hbFxyXG4gICAqIGV2ZW50IHRoYXQgZXhjbHVkZXMgdGhlIHVzZXIncyBgbWV0YU1ldHJpY3NJZGAuIEtleXMgaW4gdGhpcyBvYmplY3QgbXVzdCBiZVxyXG4gICAqIGluIGBzbmFrZV9jYXNlYC5cclxuICAgKi9cclxuICBzZW5zaXRpdmVQcm9wZXJ0aWVzPzogb2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIEFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IHRoZSBldmVudCBjcmVhdGVzIGluIHJldmVudWUgZm9yIE1ldGFNYXNrLlxyXG4gICAqL1xyXG4gIHJldmVudWU/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogSVNPLTQxMjctZm9ybWF0dGVkIGN1cnJlbmN5IGZvciBldmVudHMgd2l0aCByZXZlbnVlLiBEZWZhdWx0cyB0byBVU1xyXG4gICAqIGRvbGxhcnMuXHJcbiAgICovXHJcbiAgY3VycmVuY3k/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3QgYnVzaW5lc3MgXCJ2YWx1ZVwiIGF0dHJpYnV0YWJsZSB0byBjdXN0b21lcnMgd2hvIHRyaWdnZXIgdGhpcyBldmVudC5cclxuICAgKi9cclxuICB2YWx1ZT86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBUaGUgcGFnZS9yb3V0ZSB0aGF0IHRoZSBldmVudCBvY2N1cnJlZCBvbi5cclxuICAgKi9cclxuICBwYWdlPzogTWV0YU1ldHJpY3NQYWdlT2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBvcmlnaW4gb2YgdGhlIGRhcHAgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC5cclxuICAgKi9cclxuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWMgZ2VuZXJhdGlvbiBvZiBVVUlEIGZvciB0aGUgZXZlbnQgZnJhZ21lbnQuIFRoaXMgaXNcclxuICAgKiB1c2VmdWwgd2hlbiB0cmFja2luZyBldmVudHMgZm9yIHN1YnN5c3RlbXMgdGhhdCBhbHJlYWR5IGdlbmVyYXRlIFVVSURzIHNvXHJcbiAgICogdG8gYXZvaWQgdW5uZWNlc3NhcnkgbG9va3VwcyBhbmQgcmVkdWNlIGFjY2lkZW50YWwgZHVwbGljYXRpb24uXHJcbiAgICovXHJcbiAgdW5pcXVlSWRlbnRpZmllcj86IHN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEYXRhIHNlbnQgdG8gdGhlIGBzZWdtZW50LnRyYWNrYCBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTZWdtZW50RXZlbnRQYXlsb2FkID0ge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBNZXRhTWV0cmljcyBpZCBmb3IgdGhlIHVzZXIuXHJcbiAgICovXHJcbiAgdXNlcklkPzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIEFuIGFub255bW91cyBJRCB0aGF0IGlzIHVzZWQgdG8gdHJhY2sgc2Vuc2l0aXZlIGRhdGEgd2hpbGUgcHJlc2VydmluZ1xyXG4gICAqIGFub255bWl0eS5cclxuICAgKi9cclxuICBhbm9ueW1vdXNJZD86IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2suXHJcbiAgICovXHJcbiAgZXZlbnQ6IHN0cmluZztcclxuICAvKipcclxuICAgKiBQcm9wZXJ0aWVzIHRvIGF0dGFjaCB0byB0aGUgZXZlbnQuXHJcbiAgICovXHJcbiAgcHJvcGVydGllczogb2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBjb250ZXh0IHRoZSBldmVudCBvY2N1cnJlZCBpbi5cclxuICAgKi9cclxuICBjb250ZXh0OiBNZXRhTWV0cmljc0NvbnRleHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRGF0YSBzZW50IHRvIE1ldGFNZXRyaWNzIGZvciBwYWdlIHZpZXdzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NQYWdlUGF5bG9hZCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFnZSB0aGF0IHdhcyB2aWV3ZWQuXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSB2YXJpYWRpYyBwYXJ0cyBvZiB0aGUgcGFnZSBVUkwuXHJcbiAgICpcclxuICAgKiBFeGFtcGxlOiBJZiB0aGUgcm91dGUgaXMgYC9hc3NldC86YXNzZXRgIGFuZCB0aGUgcGF0aCBpcyBgL2Fzc2V0L0VUSGAsXHJcbiAgICogdGhlIGBwYXJhbXNgIHByb3BlcnR5IHdvdWxkIGJlIGB7IGFzc2V0OiAnRVRIJyB9YC5cclxuICAgKi9cclxuICBwYXJhbXM/OiBvYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogVGhlIGVudmlyb25tZW50IHR5cGUgdGhhdCB0aGUgcGFnZSB3YXMgdmlld2VkIGluLlxyXG4gICAqL1xyXG4gIGVudmlyb25tZW50VHlwZTogRW52aXJvbm1lbnRUeXBlO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBkZXRhaWxzIG9mIHRoZSBwYWdlLlxyXG4gICAqL1xyXG4gIHBhZ2U/OiBNZXRhTWV0cmljc1BhZ2VPYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogVGhlIGRhcHAgdGhhdCB0cmlnZ2VyZWQgdGhlIHBhZ2Ugdmlldy5cclxuICAgKi9cclxuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBNZXRhTWV0cmljc1BhZ2VPcHRpb25zID0ge1xyXG4gIC8qKlxyXG4gICAqIElzIHRoZSBjdXJyZW50IHBhdGggb25lIG9mIHRoZSBwYWdlcyBpbiB0aGUgb25ib2FyZGluZyB3b3JrZmxvdz8gKElmIHRoaXNcclxuICAgKiBpcyB0cnVlIGFuZCBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgaXMgbnVsbCwgdGhlbiB0aGUgcGFnZSB2aWV3IHdpbGwgYmVcclxuICAgKiB0cmFja2VkLilcclxuICAgKi9cclxuICBpc09wdEluUGF0aD86IGJvb2xlYW47XHJcbn07XHJcblxyXG4vKipcclxuICogRGF0YSBzZW50IHRvIE1ldGFNZXRyaWNzIGZvciB1c2VyIHRyYWl0cy5cclxuICovXHJcbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzVXNlclRyYWl0cyA9IHtcclxuICAvKipcclxuICAgKiBUaGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHVzZXIncyBhZGRyZXNzIGJvb2suXHJcbiAgICovXHJcbiAgYWRkcmVzc19ib29rX2VudHJpZXM/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogVGhlIHR5cGUgb2YgbGVkZ2VyIGNvbm5lY3Rpb24gc2V0IGJ5IHVzZXIgcHJlZmVyZW5jZS5cclxuICAgKi9cclxuICBsZWRnZXJfY29ubmVjdGlvbl90eXBlPzogTGVkZ2VyVHJhbnNwb3J0VHlwZXM7XHJcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgY29uc2lzdGluZyBvZiBjaGFpbiBJRHMgdGhhdCByZXByZXNlbnQgdGhlIG5ldHdvcmtzIGFkZGVkIGJ5IHRoZVxyXG4gICAqIHVzZXIuXHJcbiAgICovXHJcbiAgbmV0d29ya3NfYWRkZWQ/OiBzdHJpbmdbXTtcclxuICAvKipcclxuICAgKiBBbiBhcnJheSBjb25zaXN0aW5nIG9mIGNoYWluIElEcyB0aGF0IHJlcHJlc2VudCB0aGUgbmV0d29ya3MgYWRkZWQgYnkgdGhlXHJcbiAgICogdXNlciB0aGF0IGRvIG5vdCBoYXZlIGEgdGlja2VyLlxyXG4gICAqL1xyXG4gIG5ldHdvcmtzX3dpdGhvdXRfdGlja2VyPzogc3RyaW5nW107XHJcbiAgLyoqXHJcbiAgICogRG9lcyB0aGUgdXNlciBoYXZlIHRoZSBBdXRvZGV0ZWN0IE5GVHMgZmVhdHVyZSBlbmFibGVkP1xyXG4gICAqL1xyXG4gIG5mdF9hdXRvZGV0ZWN0aW9uX2VuYWJsZWQ/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgaWRlbnRpdGllcyAoYWNjb3VudHMpIGFkZGVkIHRvIHRoZVxyXG4gICAqIHVzZXIncyB3YWxsZXQuXHJcbiAgICovXHJcbiAgbnVtYmVyX29mX2FjY291bnRzPzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgYW1vdW50IG9mIE5GVCBjb2xsZWN0aW9ucyBmcm9tIHdoaWNoIHRoZSB1c2VyXHJcbiAgICogcG9zc2Vzc2VzIE5GVHMuXHJcbiAgICovXHJcbiAgbnVtYmVyX29mX25mdF9jb2xsZWN0aW9ucz86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGFtb3VudCBvZiBhbGwgTkZUcyB0aGUgdXNlciBwb3NzZXNzZXMgYWNyb3NzIGFsbFxyXG4gICAqIG5ldHdvcmtzIGFuZCBhY2NvdW50cy5cclxuICAgKi9cclxuICBudW1iZXJfb2ZfbmZ0cz86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VuIGNvbnRyYWN0cyB0aGUgdXNlciBoYXMgYWNyb3NzIGFsbCBuZXR3b3JrcyBhbmRcclxuICAgKiBhY2NvdW50cy5cclxuICAgKi9cclxuICBudW1iZXJfb2ZfdG9rZW5zPzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIERvZXMgdGhlIHVzZXIgaGF2ZSB0aGUgT3BlblNlYSBBUEkgZW5hYmxlZD9cclxuICAgKi9cclxuICBvcGVuc2VhX2FwaV9lbmFibGVkPzogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBEb2VzIHRoZSB1c2VyIGhhdmUgM0JveCBzeW5jIGVuYWJsZWQ/XHJcbiAgICpcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqL1xyXG4gIHRocmVlX2JveF9lbmFibGVkPzogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBXaGljaCB0aGVtZSB0aGUgdXNlciBoYXMgc2VsZWN0ZWQuXHJcbiAgICovXHJcbiAgdGhlbWU/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogRG9lcyB0aGUgdXNlciBoYXZlIHRva2VuIGRldGVjdGlvbiBlbmFibGVkP1xyXG4gICAqL1xyXG4gIHRva2VuX2RldGVjdGlvbl9lbmFibGVkPzogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBEb2VzIHRoZSB1c2VyIGhhdmUgZGVza3RvcCBlbmFibGVkP1xyXG4gICAqL1xyXG4gIGRlc2t0b3BfZW5hYmxlZD86IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgc2VjdXJpdHkgcHJvdmlkZXIgZmVhdHVyZSBoYXMgYmVlbiBlbmFibGVkLlxyXG4gICAqL1xyXG4gIHNlY3VyaXR5X3Byb3ZpZGVycz86IHN0cmluZ1tdO1xyXG5cbn07XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc1VzZXJUcmFpdCB7XHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSB1c2VyIGFkZHMgb3IgbW9kaWZpZXMgYWRkcmVzc2VzIGluIHRoZSBhZGRyZXNzIGJvb2suXHJcbiAgICovXHJcbiAgQWRkcmVzc0Jvb2tFbnRyaWVzID0gJ2FkZHJlc3NfYm9va19lbnRyaWVzJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgaW5zdGFsbGVkIHRoZSBleHRlbnNpb24uXHJcbiAgICovXHJcbiAgSW5zdGFsbERhdGVFeHQgPSAnaW5zdGFsbF9kYXRlX2V4dCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBMZWRnZXIgTGl2ZSBjb25uZWN0aW9uIHR5cGUgaXMgY2hhbmdlZC5cclxuICAgKi9cclxuICBMZWRnZXJDb25uZWN0aW9uVHlwZSA9ICdsZWRnZXJfY29ubmVjdGlvbl90eXBlJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgbW9kaWZpZXMgbmV0d29ya3MuXHJcbiAgICovXHJcbiAgTmV0d29ya3NBZGRlZCA9ICduZXR3b3Jrc19hZGRlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIG5ldHdvcmtzIHRoYXQgbGFjayBhIHRpY2tlci5cclxuICAgKi9cclxuICBOZXR3b3Jrc1dpdGhvdXRUaWNrZXIgPSAnbmV0d29ya3Nfd2l0aG91dF90aWNrZXInLFxyXG4gIC8qKlxyXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgXCJBdXRvZGV0ZWN0IE5GVHNcIiBmZWF0dXJlIGlzIHRvZ2dsZWQuXHJcbiAgICovXHJcbiAgTmZ0QXV0b2RldGVjdGlvbkVuYWJsZWQgPSAnbmZ0X2F1dG9kZXRlY3Rpb25fZW5hYmxlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIGlkZW50aXRpZXMgY2hhbmdlLlxyXG4gICAqL1xyXG4gIE51bWJlck9mQWNjb3VudHMgPSAnbnVtYmVyX29mX2FjY291bnRzJyxcclxuICAvKipcclxuICAgKiBUaGUgbnVtYmVyIG9mIHVuaXF1ZSBORlQgYWRkcmVzc2VzLlxyXG4gICAqL1xyXG4gIE51bWJlck9mTmZ0Q29sbGVjdGlvbnMgPSAnbnVtYmVyX29mX25mdF9jb2xsZWN0aW9ucycsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBudW1iZXIgb2YgTkZUcyBvd25lZCBieSB0aGUgdXNlciBjaGFuZ2VzLlxyXG4gICAqL1xyXG4gIE51bWJlck9mTmZ0cyA9ICdudW1iZXJfb2ZfbmZ0cycsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBudW1iZXIgb2YgdG9rZW5zIGNoYW5nZS5cclxuICAgKi9cclxuICBOdW1iZXJPZlRva2VucyA9ICdudW1iZXJfb2ZfdG9rZW5zJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIE9wZW5TZWEgQVBJIGlzIGVuYWJsZWQuXHJcbiAgICovXHJcbiAgT3BlblNlYUFwaUVuYWJsZWQgPSAnb3BlbnNlYV9hcGlfZW5hYmxlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSB1c2VyJ3MgdGhlbWUgY2hhbmdlcy5cclxuICAgKi9cclxuICBUaGVtZSA9ICd0aGVtZScsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSAzQm94IGZlYXR1cmUgaXMgdG9nZ2xlZC5cclxuICAgKlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICovXHJcbiAgVGhyZWVCb3hFbmFibGVkID0gJ3RocmVlX2JveF9lbmFibGVkJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHRva2VuIGRldGVjdGlvbiBmZWF0dXJlIGlzIHRvZ2dsZWQuXHJcbiAgICovXHJcbiAgVG9rZW5EZXRlY3Rpb25FbmFibGVkID0gJ3Rva2VuX2RldGVjdGlvbl9lbmFibGVkJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgZW5hYmxlcyBkZXNrdG9wLlxyXG4gICAqL1xyXG4gIERlc2t0b3BFbmFibGVkID0gJ2Rlc2t0b3BfZW5hYmxlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBzZWN1cml0eSBwcm92aWRlciBmZWF0dXJlIGlzIGVuYWJsZWQuXHJcbiAgICovXHJcbiAgU2VjdXJpdHlQcm92aWRlcnMgPSAnc2VjdXJpdHlfcHJvdmlkZXJzJyxcclxuXG59XHJcblxyXG4vKipcclxuICogTWl4cGFuZWwgY29udmVydHMgdGhlIHplcm8gYWRkcmVzcyB2YWx1ZSB0byBhIHRydWx5IGFub255bW91cyBldmVudCwgd2hpY2hcclxuICogc3BlZWRzIHVwIHJlcG9ydGluZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1FVEFNRVRSSUNTX0FOT05ZTU9VU19JRCA9ICcweDAwMDAwMDAwMDAwMDAwMDAnO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gaWRlbnRpZnkgZXZlbnRzIHRoYXQgYXJlIHRyaWdnZXJlZCBieSB0aGUgYmFja2dyb3VuZCBwcm9jZXNzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1FVEFNRVRSSUNTX0JBQ0tHUk9VTkRfUEFHRV9PQkpFQ1Q6IE1ldGFNZXRyaWNzUGFnZU9iamVjdCA9IHtcclxuICBwYXRoOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXHJcbiAgdGl0bGU6ICdCYWNrZ3JvdW5kIFByb2Nlc3MnLFxyXG4gIHVybDogJy9iYWNrZ3JvdW5kLXByb2Nlc3MnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RJRklDQVRJT05fQ0xPU0UgPSAnQ2FuY2VsIFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RJRklDQVRJT05fQ0xPU0VfU0lHID1cclxuICAnQ2FuY2VsIFNpZyBSZXF1ZXN0IFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudE5hbWUge1xyXG4gIEFjY291bnRBZGRlZCA9ICdBY2NvdW50IEFkZGVkJyxcclxuICBBY2NvdW50QWRkU2VsZWN0ZWQgPSAnQWNjb3VudCBBZGQgU2VsZWN0ZWQnLFxyXG4gIEFjY291bnRBZGRGYWlsZWQgPSAnQWNjb3VudCBBZGQgRmFpbGVkJyxcclxuICBBY2NvdW50UGFzc3dvcmRDcmVhdGVkID0gJ0FjY291bnQgUGFzc3dvcmQgQ3JlYXRlZCcsXHJcbiAgQWNjb3VudFJlc2V0ID0gJ0FjY291bnQgUmVzZXQnLFxyXG4gIEFjY291bnRSZW5hbWVkID0gJ0FjY291bnQgUmVuYW1lZCcsXHJcbiAgQXBwSW5zdGFsbGVkID0gJ0FwcCBJbnN0YWxsZWQnLFxyXG4gIEFwcFVubG9ja2VkID0gJ0FwcCBVbmxvY2tlZCcsXHJcbiAgQXBwVW5sb2NrZWRGYWlsZWQgPSAnQXBwIFVubG9ja2VkIEZhaWxlZCcsXHJcbiAgQXBwTG9ja2VkID0gJ0FwcCBMb2NrZWQnLFxyXG4gIEFwcFdpbmRvd0V4cGFuZGVkID0gJ0FwcCBXaW5kb3cgRXhwYW5kZWQnLFxyXG4gIEJyaWRnZUxpbmtDbGlja2VkID0gJ0JyaWRnZSBMaW5rIENsaWNrZWQnLFxyXG4gIERlY3J5cHRpb25BcHByb3ZlZCA9ICdEZWNyeXB0aW9uIEFwcHJvdmVkJyxcclxuICBEZWNyeXB0aW9uUmVqZWN0ZWQgPSAnRGVjcnlwdGlvbiBSZWplY3RlZCcsXHJcbiAgRGVjcnlwdGlvblJlcXVlc3RlZCA9ICdEZWNyeXB0aW9uIFJlcXVlc3RlZCcsXHJcbiAgRW5jcnlwdGlvblB1YmxpY0tleUFwcHJvdmVkID0gJ0VuY3J5cHRpb24gQXBwcm92ZWQnLFxyXG4gIEVuY3J5cHRpb25QdWJsaWNLZXlSZWplY3RlZCA9ICdFbmNyeXB0aW9uIFJlamVjdGVkJyxcclxuICBFbmNyeXB0aW9uUHVibGljS2V5UmVxdWVzdGVkID0gJ0VuY3J5cHRpb24gUmVxdWVzdGVkJyxcclxuICBFeHRlcm5hbExpbmtDbGlja2VkID0gJ0V4dGVybmFsIExpbmsgQ2xpY2tlZCcsXHJcbiAgS2V5RXhwb3J0U2VsZWN0ZWQgPSAnS2V5IEV4cG9ydCBTZWxlY3RlZCcsXHJcbiAgS2V5RXhwb3J0UmVxdWVzdGVkID0gJ0tleSBFeHBvcnQgUmVxdWVzdGVkJyxcclxuICBLZXlFeHBvcnRGYWlsZWQgPSAnS2V5IEV4cG9ydCBGYWlsZWQnLFxyXG4gIEtleUV4cG9ydENhbmNlbGVkID0gJ0tleSBFeHBvcnQgQ2FuY2VsZWQnLFxyXG4gIEtleUV4cG9ydFJldmVhbGVkID0gJ0tleSBNYXRlcmlhbCBSZXZlYWxlZCcsXHJcbiAgS2V5RXhwb3J0Q29waWVkID0gJ0tleSBNYXRlcmlhbCBDb3BpZWQnLFxyXG4gIEtleVRva2VuRGV0ZWN0aW9uU2VsZWN0ZWQgPSAnS2V5IFRva2VuIERldGVjdGlvbiBTZWxlY3RlZCcsXHJcbiAgS2V5R2xvYmFsU2VjdXJpdHlUb2dnbGVTZWxlY3RlZCA9ICdLZXkgR2xvYmFsIFNlY3VyaXR5L1ByaXZhY3kgU2V0dGluZ3MnLFxyXG4gIEtleUJhbGFuY2VUb2tlblByaWNlQ2hlY2tlciA9ICdLZXkgU2hvdyBCYWxhbmNlIGFuZCBUb2tlbiBQcmljZSBDaGVja2VyIFNldHRpbmdzJyxcclxuICBLZXlHYXNGZWVFc3RpbWF0aW9uQnV5U3dhcFRva2VucyA9ICdLZXkgU2hvdyBHYXMgRmVlIEVzdGltYXRpb24sIEJ1eSBDcnlwdG8gYW5kIFN3YXAgVG9rZW5zJyxcclxuICBLZXlBdXRvRGV0ZWN0VG9rZW5zID0gJ0tleSBBdXRvZGV0ZWN0IHRva2VucycsXHJcbiAgS2V5QmF0Y2hBY2NvdW50QmFsYW5jZVJlcXVlc3RzID0gJ0tleSBCYXRjaCBhY2NvdW50IGJhbGFuY2UgcmVxdWVzdHMnLFxyXG4gIE1ldHJpY3NPcHRJbiA9ICdNZXRyaWNzIE9wdCBJbicsXHJcbiAgTWV0cmljc09wdE91dCA9ICdNZXRyaWNzIE9wdCBPdXQnLFxyXG4gIE5hdkFjY291bnRNZW51T3BlbmVkID0gJ0FjY291bnQgTWVudSBPcGVuZWQnLFxyXG4gIE5hdkFjY291bnREZXRhaWxzT3BlbmVkID0gJ0FjY291bnQgRGV0YWlscyBPcGVuZWQnLFxyXG4gIE5hdkNvbm5lY3RlZFNpdGVzT3BlbmVkID0gJ0Nvbm5lY3RlZCBTaXRlcyBPcGVuZWQnLFxyXG4gIE5hdk1haW5NZW51T3BlbmVkID0gJ01haW4gTWVudSBPcGVuZWQnLFxyXG4gIE5hdk5ldHdvcmtNZW51T3BlbmVkID0gJ05ldHdvcmsgTWVudSBPcGVuZWQnLFxyXG4gIE5hdlNldHRpbmdzT3BlbmVkID0gJ1NldHRpbmdzIE9wZW5lZCcsXHJcbiAgTmF2QWNjb3VudFN3aXRjaGVkID0gJ0FjY291bnQgU3dpdGNoZWQnLFxyXG4gIE5hdk5ldHdvcmtTd2l0Y2hlZCA9ICdOZXR3b3JrIFN3aXRjaGVkJyxcclxuICBOYXZCdXlCdXR0b25DbGlja2VkID0gJ0J1eSBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgTmF2U2VuZEJ1dHRvbkNsaWNrZWQgPSAnU2VuZCBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgTmF2U3dhcEJ1dHRvbkNsaWNrZWQgPSAnU3dhcCBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgTmZ0QWRkZWQgPSAnTkZUIEFkZGVkJyxcclxuICBPbmJvYXJkaW5nV2VsY29tZSA9ICdBcHAgSW5zdGFsbGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0Q3JlYXRpb25TdGFydGVkID0gJ1dhbGxldCBTZXR1cCBTZWxlY3RlZCcsXHJcbiAgT25ib2FyZGluZ1dhbGxldEltcG9ydFN0YXJ0ZWQgPSAnV2FsbGV0IEltcG9ydCBTdGFydGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0Q3JlYXRpb25BdHRlbXB0ZWQgPSAnV2FsbGV0IFBhc3N3b3JkIENyZWF0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVN0YXJ0ZWQgPSAnU1JQIEJhY2t1cCBTZWxlY3RlZCcsXHJcbiAgT25ib2FyZGluZ1dhbGxldFNlY3VyaXR5U2tpcEluaXRpYXRlZCA9ICdTUlAgU2tpcCBCYWNrdXAgU2VsZWN0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVNraXBDb25maXJtZWQgPSAnU1JQIEJhY2t1cCBTa2lwcGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlTa2lwQ2FuY2VsZWQgPSAnU1JQIFNraXAgQmFja3VwIENhbmNlbGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlQaHJhc2VSZXZlYWxlZCA9ICdTUlAgUmV2ZWFsZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVBocmFzZVdyaXR0ZW5Eb3duID0gJ1NSUCBCYWNrdXAgQ29uZmlybSBEaXNwbGF5JyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlQaHJhc2VDb25maXJtZWQgPSAnU1JQIEJhY2t1cCBDb25maXJtZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRDcmVhdGlvbkNvbXBsZXRlID0gJ1dhbGxldCBDcmVhdGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2V0dXBDb21wbGV0ZSA9ICdBcHBsaWNhdGlvbiBPcGVuZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRBZHZhbmNlZFNldHRpbmdzID0gJ1NldHRpbmdzIFVwZGF0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRJbXBvcnRBdHRlbXB0ZWQgPSAnV2FsbGV0IEltcG9ydCBBdHRlbXB0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRWaWRlb1BsYXkgPSAnU1JQIEludHJvIFZpZGVvIFBsYXllZCcsXHJcbiAgT25ib2FyZGluZ1R3aXR0ZXJDbGljayA9ICdFeHRlcm5hbCBMaW5rIENsaWNrZWQnLFxyXG4gIE9ucmFtcFByb3ZpZGVyU2VsZWN0ZWQgPSAnT24tcmFtcCBQcm92aWRlciBTZWxlY3RlZCcsXHJcbiAgUGVybWlzc2lvbnNBcHByb3ZlZCA9ICdQZXJtaXNzaW9ucyBBcHByb3ZlZCcsXHJcbiAgUGVybWlzc2lvbnNSZWplY3RlZCA9ICdQZXJtaXNzaW9ucyBSZWplY3RlZCcsXHJcbiAgUGVybWlzc2lvbnNSZXF1ZXN0ZWQgPSAnUGVybWlzc2lvbnMgUmVxdWVzdGVkJyxcclxuICBQaGlzaGluZ1BhZ2VEaXNwbGF5ZWQgPSAnUGhpc2hpbmcgUGFnZSBEaXNwbGF5ZWQnLFxyXG4gIFBvcnRmb2xpb0xpbmtDbGlja2VkID0gJ1BvcnRmb2xpbyBMaW5rIENsaWNrZWQnLFxyXG4gIFByb3ZpZGVyTWV0aG9kQ2FsbGVkID0gJ1Byb3ZpZGVyIE1ldGhvZCBDYWxsZWQnLFxyXG4gIFB1YmxpY0FkZHJlc3NDb3BpZWQgPSAnUHVibGljIEFkZHJlc3MgQ29waWVkJyxcclxuICBTZXJ2aWNlV29ya2VyUmVzdGFydGVkID0gJ1NlcnZpY2UgV29ya2VyIFJlc3RhcnRlZCcsXHJcbiAgU2lnbmF0dXJlQXBwcm92ZWQgPSAnU2lnbmF0dXJlIEFwcHJvdmVkJyxcclxuICBTaWduYXR1cmVGYWlsZWQgPSAnU2lnbmF0dXJlIEZhaWxlZCcsXHJcbiAgU2lnbmF0dXJlUmVqZWN0ZWQgPSAnU2lnbmF0dXJlIFJlamVjdGVkJyxcclxuICBTaWduYXR1cmVSZXF1ZXN0ZWQgPSAnU2lnbmF0dXJlIFJlcXVlc3RlZCcsXHJcbiAgU3JwUmV2ZWFsU3RhcnRlZCA9ICdSZXZlYWwgU1JQIEluaXRpYXRlZCcsXHJcbiAgU3JwUmV2ZWFsQ2xpY2tlZCA9ICdDbGlja2VkIFJldmVhbCBTZWNyZXQgUmVjb3ZlcnknLFxyXG4gIFNycFJldmVhbFZpZXdlZCA9ICdWaWV3cyBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5JyxcclxuICBTcnBSZXZlYWxCYWNrQnV0dG9uQ2xpY2tlZCA9ICdDbGlja2VkIEJhY2sgb24gUmV2ZWFsIFNSUCBQYXNzd29yZCBQYWdlJyxcclxuICBTcnBSZXZlYWxDYW5jZWxsZWQgPSAnUmV2ZWFsIFNSUCBDYW5jZWxsZWQnLFxyXG4gIFNycFJldmVhbENhbmNlbEJ1dHRvbkNsaWNrZWQgPSAnQ2xpY2tzIENhbmNlbCBvbiBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5IFBocmFzZSBQYWdlJyxcclxuICBTcnBSZXZlYWxDbG9zZUNsaWNrZWQgPSAnQ2xpY2tzIENMT1NFIHdpdGggU1JQJyxcclxuICBTcnBSZXZlYWxOZXh0Q2xpY2tlZCA9ICdDbGlja3MgTmV4dCBvbiBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5IFBocmFzZScsXHJcbiAgU3JwSG9sZFRvUmV2ZWFsQ2xpY2tTdGFydGVkID0gJ1JldmVhbCBTUlAgQ2xpY2sgU3RhcnRlZCcsXHJcbiAgU3JwSG9sZFRvUmV2ZWFsQ2xvc2VDbGlja2VkID0gJ0Nsb3NlcyBIb2xkIFRvIFJldmVhbCBTUlAnLFxyXG4gIFNycEhvbGRUb1JldmVhbENvbXBsZXRlZCA9ICdSZXZlYWwgU1JQIENvbXBsZXRlZCcsXHJcbiAgU3JwVmlld3NTcnBRUiA9ICdWaWV3cyBTUlAgUVIgQ29kZScsXHJcbiAgU3JwVmlld1NycFRleHQgPSAnVmlld3MgU1JQJyxcclxuICBTcnBDb3BpZWRUb0NsaXBib2FyZCA9ICdDb3BpZXMgU1JQIHRvIGNsaXBib2FyZCcsXHJcbiAgU3JwVG9Db25maXJtQmFja3VwID0gJ1NSUCBCYWNrdXAgQ29uZmlybSBEaXNwbGF5ZWQnLFxyXG4gIFN1cHBvcnRMaW5rQ2xpY2tlZCA9ICdTdXBwb3J0IExpbmsgQ2xpY2tlZCcsXHJcbiAgVGVybXNPZlVzZVNob3duID0gJ1Rlcm1zIG9mIFVzZSBTaG93bicsXHJcbiAgVGVybXNPZlVzZUFjY2VwdGVkID0gJ1Rlcm1zIG9mIFVzZSBBY2NlcHRlZCcsXHJcbiAgVG9rZW5JbXBvcnRCdXR0b25DbGlja2VkID0gJ0ltcG9ydCBUb2tlbiBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgVG9rZW5TY3JlZW5PcGVuZWQgPSAnVG9rZW4gU2NyZWVuIE9wZW5lZCcsXHJcbiAgVG9rZW5BZGRlZCA9ICdUb2tlbiBBZGRlZCcsXHJcbiAgVG9rZW5EZXRlY3RlZCA9ICdUb2tlbiBEZXRlY3RlZCcsXHJcbiAgVG9rZW5IaWRkZW4gPSAnVG9rZW4gSGlkZGVuJyxcclxuICBUb2tlbkltcG9ydENhbmNlbGVkID0gJ1Rva2VuIEltcG9ydCBDYW5jZWxlZCcsXHJcbiAgVG9rZW5JbXBvcnRDbGlja2VkID0gJ1Rva2VuIEltcG9ydCBDbGlja2VkJyxcclxuICBXYWxsZXRTZXR1cFN0YXJ0ZWQgPSAnV2FsbGV0IFNldHVwIFNlbGVjdGVkJyxcclxuICBXYWxsZXRTZXR1cENhbmNlbGVkID0gJ1dhbGxldCBTZXR1cCBDYW5jZWxlZCcsXHJcbiAgV2FsbGV0U2V0dXBGYWlsZWQgPSAnV2FsbGV0IFNldHVwIEZhaWxlZCcsXHJcbiAgV2FsbGV0Q3JlYXRlZCA9ICdXYWxsZXQgQ3JlYXRlZCcsXHJcblxuICBBY2NvdW50RGV0YWlsTWVudU9wZW5lZCA9ICdBY2NvdW50IERldGFpbHMgTWVudSBPcGVuZWQnLFxyXG4gIEJsb2NrRXhwbG9yZXJMaW5rQ2xpY2tlZCA9ICdCbG9jayBFeHBsb3JlciBDbGlja2VkJyxcclxuICBBY2NvdW50UmVtb3ZlZCA9ICdBY2NvdW50IFJlbW92ZWQnLFxyXG4gIFRlc3ROZXR3b3Jrc0Rpc3BsYXllZCA9ICdUZXN0IE5ldHdvcmtzIERpc3BsYXllZCcsXHJcbiAgQWRkTmV0d29ya0J1dHRvbkNsaWNrID0gJ0FkZCBOZXR3b3JrIEJ1dHRvbiBDbGlja2VkJyxcclxuICBDdXN0b21OZXR3b3JrQWRkZWQgPSAnQ3VzdG9tIE5ldHdvcmsgQWRkZWQnLFxyXG4gIFRva2VuRGV0YWlsc09wZW5lZCA9ICdUb2tlbiBEZXRhaWxzIE9wZW5lZCcsXHJcbiAgTmZ0U2NyZWVuT3BlbmVkID0gJ05GVCBTY3JlZW4gT3BlbmVkJyxcclxuICBBY3Rpdml0eVNjcmVlbk9wZW5lZCA9ICdBY3Rpdml0eSBTY3JlZW4gT3BlbmVkJyxcclxuICBXaGF0c05ld1ZpZXdlZCA9IGBXaGF0J3MgTmV3IFZpZXdlZGAsXHJcbiAgV2hhdHNOZXdDbGlja2VkID0gYFdoYXQncyBOZXcgTGluayBDbGlja2VkYCxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudEFjY291bnRUeXBlIHtcclxuICBEZWZhdWx0ID0gJ21ldGFtYXNrJyxcclxuICBIYXJkd2FyZSA9ICdoYXJkd2FyZScsXHJcbiAgSW1wb3J0ZWQgPSAnaW1wb3J0ZWQnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc0V2ZW50QWNjb3VudEltcG9ydFR5cGUge1xyXG4gIEpzb24gPSAnanNvbicsXHJcbiAgUHJpdmF0ZUtleSA9ICdwcml2YXRlX2tleScsXHJcbiAgU3JwID0gJ3NycCcsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRDYXRlZ29yeSB7XHJcbiAgQWNjb3VudHMgPSAnQWNjb3VudHMnLFxyXG4gIEFwcCA9ICdBcHAnLFxyXG4gIEF1dGggPSAnQXV0aCcsXHJcbiAgQmFja2dyb3VuZCA9ICdCYWNrZ3JvdW5kJyxcclxuICBEZXNrdG9wID0gJ0Rlc2t0b3AnLFxyXG4gIC8vIFRoZSBUeXBlU2NyaXB0IEVTTGludCBydWxlIGlzIGluY29ycmVjdGx5IG1hcmtpbmcgdGhpcyBsaW5lLlxyXG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93ICovXHJcbiAgRXJyb3IgPSAnRXJyb3InLFxyXG4gIEZvb3RlciA9ICdGb290ZXInLFxyXG4gIEhvbWUgPSAnSG9tZScsXHJcbiAgSW5wYWdlUHJvdmlkZXIgPSAnaW5wYWdlX3Byb3ZpZGVyJyxcclxuICBLZXlzID0gJ0tleXMnLFxyXG4gIE1lc3NhZ2VzID0gJ01lc3NhZ2VzJyxcclxuICBOYXZpZ2F0aW9uID0gJ05hdmlnYXRpb24nLFxyXG4gIE5ldHdvcmsgPSAnTmV0d29yaycsXHJcbiAgT25ib2FyZGluZyA9ICdPbmJvYXJkaW5nJyxcclxuICBQaGlzaGluZyA9ICdQaGlzaGluZycsXHJcbiAgUmV0ZW50aW9uID0gJ1JldGVudGlvbicsXHJcbiAgU2VydmljZVdvcmtlcnMgPSAnc2VydmljZV93b3JrZXJzJyxcclxuICBTZXR0aW5ncyA9ICdTZXR0aW5ncycsXHJcbiAgU25hcHMgPSAnU25hcHMnLFxyXG4gIFN3YXBzID0gJ1N3YXBzJyxcclxuICBUcmFuc2FjdGlvbnMgPSAnVHJhbnNhY3Rpb25zJyxcclxuICBXYWxsZXQgPSAnV2FsbGV0JyxcclxuXG4gIFRva2VucyA9ICdUb2tlbnMnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc0V2ZW50TGlua1R5cGUge1xyXG4gIEFjY291bnRUcmFja2VyID0gJ0FjY291bnQgVHJhY2tlcicsXHJcbiAgQmxvY2tFeHBsb3JlciA9ICdCbG9jayBFeHBsb3JlcicsXHJcbiAgVG9rZW5UcmFja2VyID0gJ1Rva2VuIFRyYWNrZXInLFxyXG4gIFRyYW5zYWN0aW9uQmxvY2tFeHBsb3JlciA9ICdUcmFuc2FjdGlvbiBCbG9jayBFeHBsb3JlcicsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRLZXlUeXBlIHtcclxuICBQa2V5ID0gJ3ByaXZhdGVfa2V5JyxcclxuICBTcnAgPSAnc3JwJyxcclxufVxyXG5cclxuLy8gTk9URTogVGhpcyBkb2Vzbid0IHNlZW0gdG8gYmUgdXNlZCBhdCBhbGxcclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudE9ucmFtcFByb3ZpZGVyVHlwZSB7XHJcbiAgQ29pbmJhc2UgPSAnY29pbmJhc2UnLFxyXG4gIE1vb25wYXkgPSAnbW9vbnBheScsXHJcbiAgU2VsZkRlcG9zaXQgPSAnZGlyZWN0X2RlcG9zaXQnLFxyXG4gIFRyYW5zYWsgPSAndHJhbnNhaycsXHJcbiAgV3lyZSA9ICd3eXJlJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NOZXR3b3JrRXZlbnRTb3VyY2Uge1xyXG4gIEN1c3RvbU5ldHdvcmtGb3JtID0gJ2N1c3RvbV9uZXR3b3JrX2Zvcm0nLFxyXG4gIFBvcHVsYXJOZXR3b3JrTGlzdCA9ICdwb3B1bGFyX25ldHdvcmtfbGlzdCcsXHJcbiAgRGFwcCA9ICdkYXBwJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NTd2Fwc0V2ZW50U291cmNlIHtcclxuICBNYWluVmlldyA9ICdNYWluIFZpZXcnLFxyXG4gIFRva2VuVmlldyA9ICdUb2tlbiBWaWV3JyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NUb2tlbkV2ZW50U291cmNlIHtcclxuICBDdXN0b20gPSAnY3VzdG9tJyxcclxuICBEYXBwID0gJ2RhcHAnLFxyXG4gIERldGVjdGVkID0gJ2RldGVjdGVkJyxcclxuICBMaXN0ID0gJ2xpc3QnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc1RyYW5zYWN0aW9uRXZlbnRTb3VyY2Uge1xyXG4gIERhcHAgPSAnZGFwcCcsXHJcbiAgVXNlciA9ICd1c2VyJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudExvY2F0aW9uIHtcclxuICBUb2tlbkRldGFpbHMgPSAndG9rZW5fZGV0YWlscycsXHJcbiAgVG9rZW5EZXRlY3Rpb24gPSAndG9rZW5fZGV0ZWN0aW9uJyxcclxuICBUb2tlbk1lbnUgPSAndG9rZW5fbWVudScsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRVaUN1c3RvbWl6YXRpb24ge1xyXG4gIEZsYWdnZWRBc01hbGljaW91cyA9ICdmbGFnZ2VkX2FzX21hbGljaW91cycsXHJcbiAgRmxhZ2dlZEFzU2FmZXR5VW5rbm93biA9ICdmbGFnZ2VkX2FzX3NhZmV0eV91bmtub3duJyxcclxuICBTaXdlID0gJ3NpZ25faW5fd2l0aF9ldGhlcmV1bScsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWx1ZXMgdGhhdCBjYW4gdXNlZCBpbiB0aGUgXCJwcm9wZXJ0aWVzXCIgdHJhY2tpbmcgb2JqZWN0IGFzIGtleXMsIGUuZy4gYHtcclxuICogbG9jYXRpb246ICdIb21lJyB9YC5cclxuICovXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzQ29udGV4dFByb3Age1xyXG4gIFBhZ2VUaXRsZSA9ICdsb2NhdGlvbicsXHJcbn1cclxuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSwgcGljayB9IGZyb20gJ2xvZGFzaCc7XHJcbi8qKlxyXG4gKiBBIHR5cGUgcmVwcmVzZW50aW5nIGFueSB2YWxpZCB2YWx1ZSBmb3IgJ3R5cGUnIGZvciBzZXRQcm92aWRlclR5cGUgYW5kIG90aGVyXHJcbiAqIG1ldGhvZHMgdGhhdCBhZGQgb3IgbWFuaXB1bGF0ZSBuZXR3b3JrcyBpbiBNZXRhTWFzayBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIE5ldHdvcmtUeXBlID0gKHR5cGVvZiBORVRXT1JLX1RZUEVTKVtrZXlvZiB0eXBlb2YgTkVUV09SS19UWVBFU107XHJcblxyXG4vKipcclxuICogQSB1bmlvbiB0eXBlIG9mIGFsbCBwb3NzaWJsZSBoYXJkLWNvZGVkIGNoYWluIGlkcy4gVGhpcyB0eXBlIGlzIG5vdFxyXG4gKiBleGhhdXN0aXZlIGFuZCBjYW5ub3QgYmUgdXNlZCBmb3IgdHlwaW5nIGNoYWluSWQgaW4gYXJlYXMgd2hlcmUgdGhlIHVzZXIgb3JcclxuICogZGFwcCBtYXkgc3BlY2lmeSBhbnkgY2hhaW5JZC5cclxuICovXHJcbmV4cG9ydCB0eXBlIENoYWluSWQgPSAodHlwZW9mIENIQUlOX0lEUylba2V5b2YgdHlwZW9mIENIQUlOX0lEU107XHJcblxyXG4vKipcclxuICogQSB0eXBlIHRoYXQgaXMgYSB1bmlvbiB0eXBlIG9mIGFsbCBwb3NzaWJsZSBoYXJkY29kZWQgY3VycmVuY3kgc3ltYm9scy5cclxuICogVGhpcyB0eXBlIGlzIG5vbi1leGhhdXN0aXZlLCBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIGFyZWFzIHdoZXJlIHRoZSB1c2VyXHJcbiAqIG9yIGRhcHAgbWF5IHN1cHBseSB0aGVpciBvd24gc3ltYm9sLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ3VycmVuY3lTeW1ib2wgPVxyXG4gICh0eXBlb2YgQ1VSUkVOQ1lfU1lNQk9MUylba2V5b2YgdHlwZW9mIENVUlJFTkNZX1NZTUJPTFNdO1xyXG4vKipcclxuICogVGVzdCBuZXR3b3JrcyBoYXZlIHNwZWNpYWwgc3ltYm9scyB0aGF0IGNvbWJpbmUgdGhlIG5ldHdvcmsgbmFtZSBhbmQgJ0VUSCdcclxuICogc28gdGhhdCB0aGV5IGFyZSBkaXN0aW5jdCBmcm9tIG1haW5uZXQgYW5kIG90aGVyIG5ldHdvcmtzIHRoYXQgdXNlICdFVEgnLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgVGVzdE5ldHdvcmtDdXJyZW5jeVN5bWJvbCA9XHJcbiAgKHR5cGVvZiBURVNUX05FVFdPUktfVElDS0VSX01BUClba2V5b2YgdHlwZW9mIFRFU1RfTkVUV09SS19USUNLRVJfTUFQXTtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBwcmVmZXJlbmNlcyBmb3IgYW4gUlBDIGRlZmluaXRpb25cclxuICovXHJcbnR5cGUgUlBDUHJlZmVyZW5jZXMgPSB7XHJcbiAgLyoqXHJcbiAgICogQSBVUkwgZm9yIHRoZSBibG9jayBleHBsb3JlciBmb3IgdGhlIFJQQydzIG5ldHdvcmtcclxuICAgKi9cclxuICBibG9ja0V4cGxvcmVyVXJsOiBgaHR0cHM6Ly8ke3N0cmluZ31gO1xyXG4gIC8qKlxyXG4gICAqIEEgaW1hZ2UgcmVmbGVjdGluZyB0aGUgYXNzZXQgc3ltYm9sIGZvciB0aGUgbmV0d29ya1xyXG4gICAqL1xyXG4gIGltYWdlVXJsOiBzdHJpbmc7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbmV0d29yayB0byBiZSB1c2VkIGluc2lkZSBvZiBNZXRhTWFza1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgUlBDRGVmaW5pdGlvbiA9IHtcclxuICAvKipcclxuICAgKiBUaGUgaGV4IGVuY29kZWQgQ2hhaW5JZCBmb3IgdGhlIG5ldHdvcmtcclxuICAgKi9cclxuICBjaGFpbklkOiBDaGFpbklkO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBuaWNrbmFtZSBmb3IgdGhlIG5ldHdvcmtcclxuICAgKi9cclxuICBuaWNrbmFtZTogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBVUkwgZm9yIHRoZSBjbGllbnQgdG8gc2VuZCBuZXR3b3JrIHJlcXVlc3RzIHRvXHJcbiAgICovXHJcbiAgcnBjVXJsOiBgaHR0cHM6Ly8ke3N0cmluZ31gO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBDdXJyZW5jeSBTeW1ib2wgZm9yIHRoZSBuZXR3b3JrXHJcbiAgICovXHJcbiAgdGlja2VyOiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQWRkaXRpb25hbCBwcmVmZXJlbmNlcyBmb3IgdGhlIG5ldHdvcmssIHN1Y2ggYXMgYmxvY2tFeHBsb3JlclVybFxyXG4gICAqL1xyXG4gIHJwY1ByZWZzOiBSUENQcmVmZXJlbmNlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGb3IgZWFjaCBjaGFpbiB0aGF0IHdlIHN1cHBvcnQgZmlhdCBvbnJhbXBzIGZvciwgd2UgcHJvdmlkZSBhIHNldCBvZlxyXG4gKiBjb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBoZWxwIGZvciBpbml0aWFsaXppbmcgdGhlIGNvbm5lY3Rpb25nIHRvIHRoZVxyXG4gKiBvbnJhbXAgcHJvdmlkZXJzLlxyXG4gKi9cclxudHlwZSBCdXlhYmxlQ2hhaW5TZXR0aW5ncyA9IHtcclxuICAvKipcclxuICAgKiBUaGUgbmF0aXZlIGN1cnJlbmN5IGZvciB0aGUgZ2l2ZW4gY2hhaW5cclxuICAgKi9cclxuICBuYXRpdmVDdXJyZW5jeTogQ3VycmVuY3lTeW1ib2wgfCBUZXN0TmV0d29ya0N1cnJlbmN5U3ltYm9sO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBuZXR3b3JrIG5hbWUgb3IgaWRlbnRpZmllclxyXG4gICAqL1xyXG4gIG5ldHdvcms6IHN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaHJvdWdob3V0IHRoZSBleHRlbnNpb24gd2Ugc2V0IHRoZSBjdXJyZW50IHByb3ZpZGVyIGJ5IHJlZmVyZW5jaW5nIGl0c1xyXG4gKiBcInR5cGVcIiwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgdmFsdWVzIGluIHRoZSBiZWxvdyBvYmplY3QuIFRoZXNlIHZhbHVlc1xyXG4gKiByZXByZXNlbnQgdGhlIGJ1aWx0LWluIG5ldHdvcmtzIG9mIE1ldGFNYXNrLCBpbmNsdWRpbmcgdGVzdCBuZXRzLCBhcyB3ZWxsXHJcbiAqIGFzIFwicnBjXCIgd2hpY2ggaXMgdGhlIFwidHlwZVwiIG9mIGEgY3VzdG9tIG5ldHdvcmsgYWRkZWQgYnkgdGhlIHVzZXIgb3IgdmlhXHJcbiAqIHdhbGxldF9hZGRFdGhlcmV1bUNoYWluLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE5FVFdPUktfVFlQRVMgPSB7XHJcbiAgR09FUkxJOiAnZ29lcmxpJyxcclxuICBMT0NBTEhPU1Q6ICdsb2NhbGhvc3QnLFxyXG4gIE1BSU5ORVQ6ICdtYWlubmV0JyxcclxuICBSUEM6ICdycGMnLFxyXG4gIFNFUE9MSUE6ICdzZXBvbGlhJyxcclxuICBMSU5FQV9URVNUTkVUOiAnbGluZWF0ZXN0bmV0JyxcclxufSBhcyBjb25zdDtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBzaG9ydGN1dCBuYW1lcyBmb3IgYW55IG5vbi1idWlsdGluIG5ldHdvcmsuIFdlIG5lZWRcclxuICogdGhpcyB0byBiZSBhYmxlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBuZXR3b3JrcyB0aGF0IHJlcXVpcmUgY3VzdG9tXHJcbiAqIHNlY3Rpb25zIG9mIGNvZGUgZm9yIG91ciB2YXJpb3VzIGZlYXR1cmVzLCBzdWNoIGFzIHN3YXBzIG9yIHRva2VuIGxpc3RzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE5FVFdPUktfTkFNRVMgPSB7XHJcbiAgSE9NRVNURUFEOiAnaG9tZXN0ZWFkJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgTmV0d29yayBJRCBmb3Igb3VyIGJ1aWx0aW4gbmV0d29ya3MuIFRoaXMgaXMgdGhlIGRlY2ltYWwgZXF1aXZhbGVudCBvZlxyXG4gKiB0aGUgY2hhaW4gaWQgZm9yIHRoZSBuZXR3b3JrLCBidXQgaXMgZXhwcmVzc3NlZCBhcyBhIHN0cmluZy4gTWFueSBtb29ucyBhZ29cclxuICogdGhlIGRlY2lzaW9uIHdhcyBtYWRlIG9uIHRoZSBleHRlbnNpb24gdGVhbSB0byBleHByZXNzbHkgdXNlIGNoYWluSWQgd2l0aFxyXG4gKiBoZXggZW5jb2Rpbmcgb3ZlciBuZXR3b3JrIGlkLiBDb25zaWRlciB0aGF0IHdoZW4gYWNjZXNzaW5nIHRoaXMgb2JqZWN0LiBOb3RlXHJcbiAqIGZvciBjcm9zcyBwcm9kdWN0IHB1cnBvc2VzOiBhbGlnbm1lbnQgd2l0aCBtb2JpbGUgb24gdGhpcyBtYXR0ZXIgaGFzIG5vdFxyXG4gKiBiZWVuIGZ1bGx5IGFjaGlldmVkLCB0aHVzIGl0IGlzIHBvc3NpYmxlIGZvciBzb21lIGRlcGVuZGVuY2llcyB0byBzdGlsbFxyXG4gKiBhc2sgZm9yIG9yIHJlcXVpcmUgbmV0d29yayBpZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBORVRXT1JLX0lEUyA9IHtcclxuICBNQUlOTkVUOiAnMScsXHJcbiAgR09FUkxJOiAnNScsXHJcbiAgTE9DQUxIT1NUOiAnMTMzNycsXHJcbiAgU0VQT0xJQTogJzExMTU1MTExJyxcclxuICBMSU5FQV9URVNUTkVUOiAnNTkxNDAnLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLyoqXHJcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgY2hhaW4gaWRzIGZvciBuZXR3b3JrcyBib3RoIGJ1aWx0IGluIGFuZFxyXG4gKiB0aG9zZSB0aGF0IHdlIGhhdmUgYWRkZWQgY3VzdG9tIGNvZGUgdG8gc3VwcG9ydCBvdXIgZmVhdHVyZSBzZXQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ0hBSU5fSURTID0ge1xyXG4gIE1BSU5ORVQ6ICcweDEnLFxyXG4gIEdPRVJMSTogJzB4NScsXHJcbiAgTE9DQUxIT1NUOiAnMHg1MzknLFxyXG4gIEJTQzogJzB4MzgnLFxyXG4gIEJTQ19URVNUTkVUOiAnMHg2MScsXHJcbiAgT1BUSU1JU006ICcweGEnLFxyXG4gIE9QVElNSVNNX1RFU1RORVQ6ICcweDFhNCcsXHJcbiAgUE9MWUdPTjogJzB4ODknLFxyXG4gIFBPTFlHT05fVEVTVE5FVDogJzB4MTM4ODEnLFxyXG4gIEFWQUxBTkNIRTogJzB4YTg2YScsXHJcbiAgQVZBTEFOQ0hFX1RFU1RORVQ6ICcweGE4NjknLFxyXG4gIEZBTlRPTTogJzB4ZmEnLFxyXG4gIEZBTlRPTV9URVNUTkVUOiAnMHhmYTInLFxyXG4gIENFTE86ICcweGE0ZWMnLFxyXG4gIEFSQklUUlVNOiAnMHhhNGIxJyxcclxuICBIQVJNT05ZOiAnMHg2MzU2NGM0MCcsXHJcbiAgUEFMTTogJzB4MmExNWMzMDhkJyxcclxuICBTRVBPTElBOiAnMHhhYTM2YTcnLFxyXG4gIExJTkVBX1RFU1RORVQ6ICcweGU3MDQnLFxyXG4gIEFVUk9SQTogJzB4NGU0NTQxNTInLFxyXG4gIE1PT05CRUFNOiAnMHg1MDQnLFxyXG4gIE1PT05CRUFNX1RFU1RORVQ6ICcweDUwNycsXHJcbiAgTU9PTlJJVkVSOiAnMHg1MDUnLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBsYXJnZXN0IHBvc3NpYmxlIGNoYWluIElEIHdlIGNhbiBoYW5kbGUuXHJcbiAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yZWttYXJrcy9hNDdiZDVmMjUyNTkzNmM0YjhlZWUzMWExNjM0NTU1M1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0NIQUlOX0lEID0gNDUwMzU5OTYyNzM3MDQ3NjtcclxuXHJcbmV4cG9ydCBjb25zdCBNQUlOTkVUX0RJU1BMQVlfTkFNRSA9ICdFdGhlcmV1bSBNYWlubmV0JztcclxuZXhwb3J0IGNvbnN0IEdPRVJMSV9ESVNQTEFZX05BTUUgPSAnR29lcmxpJztcclxuZXhwb3J0IGNvbnN0IFNFUE9MSUFfRElTUExBWV9OQU1FID0gJ1NlcG9saWEnO1xyXG5leHBvcnQgY29uc3QgTElORUFfVEVTVE5FVF9ESVNQTEFZX05BTUUgPSAnTGluZWEgR29lcmxpIHRlc3QgbmV0d29yayc7XHJcbmV4cG9ydCBjb25zdCBMT0NBTEhPU1RfRElTUExBWV9OQU1FID0gJ0xvY2FsaG9zdCA4NTQ1JztcclxuZXhwb3J0IGNvbnN0IEJTQ19ESVNQTEFZX05BTUUgPSAnQmluYW5jZSBTbWFydCBDaGFpbic7XHJcbmV4cG9ydCBjb25zdCBQT0xZR09OX0RJU1BMQVlfTkFNRSA9ICdQb2x5Z29uJztcclxuZXhwb3J0IGNvbnN0IEFWQUxBTkNIRV9ESVNQTEFZX05BTUUgPSAnQXZhbGFuY2hlIE5ldHdvcmsgQy1DaGFpbic7XHJcbmV4cG9ydCBjb25zdCBBUkJJVFJVTV9ESVNQTEFZX05BTUUgPSAnQXJiaXRydW0gT25lJztcclxuZXhwb3J0IGNvbnN0IEJOQl9ESVNQTEFZX05BTUUgPVxyXG4gICdCTkIgU21hcnQgQ2hhaW4gKHByZXZpb3VzbHkgQmluYW5jZSBTbWFydCBDaGFpbiBNYWlubmV0KSc7XHJcbmV4cG9ydCBjb25zdCBPUFRJTUlTTV9ESVNQTEFZX05BTUUgPSAnT3B0aW1pc20nO1xyXG5leHBvcnQgY29uc3QgRkFOVE9NX0RJU1BMQVlfTkFNRSA9ICdGYW50b20gT3BlcmEnO1xyXG5leHBvcnQgY29uc3QgSEFSTU9OWV9ESVNQTEFZX05BTUUgPSAnSGFybW9ueSBNYWlubmV0IFNoYXJkIDAnO1xyXG5leHBvcnQgY29uc3QgUEFMTV9ESVNQTEFZX05BTUUgPSAnUGFsbSc7XHJcbmV4cG9ydCBjb25zdCBBVVJPUkFfRElTUExBWV9OQU1FID0gJ0F1cm9yYSBNYWlubmV0JztcclxuZXhwb3J0IGNvbnN0IENFTE9fRElTUExBWV9OQU1FID0gJ0NlbG8gTWFpbm5ldCc7XHJcblxyXG5leHBvcnQgY29uc3QgaW5mdXJhUHJvamVjdElkID0gcHJvY2Vzcy5lbnYuSU5GVVJBX1BST0pFQ1RfSUQ7XHJcbmV4cG9ydCBjb25zdCBnZXRScGNVcmwgPSAoe1xyXG4gIG5ldHdvcmssXHJcbiAgZXhjbHVkZVByb2plY3RJZCA9IGZhbHNlLFxyXG59OiB7XHJcbiAgbmV0d29yazogTmV0d29ya1R5cGU7XHJcbiAgZXhjbHVkZVByb2plY3RJZD86IGJvb2xlYW47XHJcbn0pID0+XHJcbiAgYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW8vdjMvJHtleGNsdWRlUHJvamVjdElkID8gJycgOiBpbmZ1cmFQcm9qZWN0SWR9YDtcclxuXHJcbmV4cG9ydCBjb25zdCBNQUlOTkVUX1JQQ19VUkwgPSBnZXRScGNVcmwoe1xyXG4gIG5ldHdvcms6IE5FVFdPUktfVFlQRVMuTUFJTk5FVCxcclxufSk7XHJcbmV4cG9ydCBjb25zdCBHT0VSTElfUlBDX1VSTCA9IGdldFJwY1VybCh7IG5ldHdvcms6IE5FVFdPUktfVFlQRVMuR09FUkxJIH0pO1xyXG5leHBvcnQgY29uc3QgU0VQT0xJQV9SUENfVVJMID0gZ2V0UnBjVXJsKHsgbmV0d29yazogTkVUV09SS19UWVBFUy5TRVBPTElBIH0pO1xyXG5leHBvcnQgY29uc3QgTElORUFfVEVTVE5FVF9SUENfVVJMID0gJ2h0dHBzOi8vcnBjLmdvZXJsaS5saW5lYS5idWlsZCc7XHJcbmV4cG9ydCBjb25zdCBMT0NBTEhPU1RfUlBDX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnO1xyXG5cclxuLyoqXHJcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbiBzeW1ib2xzIGZvciB2YXJpb3VzIHRva2VucyB0aGF0IGFyZSBlaXRoZXJcclxuICogbmF0aXZlIGN1cnJlbmNpZXMgb3IgdGhvc2UgdGhhdCBoYXZlIGJlZW4gc3BlY2lhbCBjYXNlZCBieSB0aGUgZXh0ZW5zaW9uXHJcbiAqIGZvciBzdXBwb3J0aW5nIG91ciBmZWF0dXJlIHNldC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBDVVJSRU5DWV9TWU1CT0xTID0ge1xyXG4gIEFSQklUUlVNOiAnRVRIJyxcclxuICBBVVJPUkE6ICdBdXJvcmEgRVRIJyxcclxuICBBVkFMQU5DSEU6ICdBVkFYJyxcclxuICBCTkI6ICdCTkInLFxyXG4gIEJVU0Q6ICdCVVNEJyxcclxuICBDRUxPOiAnQ0VMTycsXHJcbiAgREFJOiAnREFJJyxcclxuICBFVEg6ICdFVEgnLFxyXG4gIEZBTlRPTTogJ0ZUTScsXHJcbiAgSEFSTU9OWTogJ09ORScsXHJcbiAgUEFMTTogJ1BBTE0nLFxyXG4gIE1BVElDOiAnTUFUSUMnLFxyXG4gIFRFU1RfRVRIOiAnVEVTVEVUSCcsXHJcbiAgVVNEQzogJ1VTREMnLFxyXG4gIFVTRFQ6ICdVU0RUJyxcclxuICBXRVRIOiAnV0VUSCcsXHJcbiAgT1BUSU1JU006ICdPUCcsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgRVRIX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ldGhfbG9nby5wbmcnO1xyXG5leHBvcnQgY29uc3QgVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2JsYWNrLWV0aC1sb2dvLnN2Zyc7XHJcbmV4cG9ydCBjb25zdCBCTkJfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2JuYi5wbmcnO1xyXG5leHBvcnQgY29uc3QgTUFUSUNfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL21hdGljLXRva2VuLnBuZyc7XHJcbmV4cG9ydCBjb25zdCBBVkFYX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9hdmF4LXRva2VuLnBuZyc7XHJcbmV4cG9ydCBjb25zdCBBRVRIX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9hcmJpdHJ1bS5zdmcnO1xyXG5leHBvcnQgY29uc3QgRlRNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9mYW50b20tb3BlcmEuc3ZnJztcclxuZXhwb3J0IGNvbnN0IEhBUk1PTllfT05FX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9oYXJtb255LW9uZS5zdmcnO1xyXG5leHBvcnQgY29uc3QgT1BUSU1JU01fVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL29wdGltaXNtLnN2Zyc7XHJcbmV4cG9ydCBjb25zdCBQQUxNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9wYWxtLnN2Zyc7XHJcbmV4cG9ydCBjb25zdCBBVVJPUkFfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2F1cm9yYS5wbmcnO1xyXG5leHBvcnQgY29uc3QgQ0VMT19UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvY2Vsby5zdmcnO1xyXG5cclxuZXhwb3J0IGNvbnN0IElORlVSQV9QUk9WSURFUl9UWVBFUyA9IFtcclxuICBORVRXT1JLX1RZUEVTLk1BSU5ORVQsXHJcbiAgTkVUV09SS19UWVBFUy5HT0VSTEksXHJcbiAgTkVUV09SS19UWVBFUy5TRVBPTElBLFxyXG5dIGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFRFU1RfQ0hBSU5TID0gW1xyXG4gIENIQUlOX0lEUy5HT0VSTEksXHJcbiAgQ0hBSU5fSURTLlNFUE9MSUEsXHJcbiAgQ0hBSU5fSURTLkxJTkVBX1RFU1RORVQsXHJcbiAgQ0hBSU5fSURTLkxPQ0FMSE9TVCxcclxuXTtcclxuXHJcbmNvbnN0IHR5cGVkQ2FwaXRhbGl6ZSA9IDxLIGV4dGVuZHMgc3RyaW5nPihrOiBLKTogQ2FwaXRhbGl6ZTxLPiA9PlxyXG4gIGNhcGl0YWxpemUoaykgYXMgQ2FwaXRhbGl6ZTx0eXBlb2Ygaz47XHJcblxyXG5leHBvcnQgY29uc3QgVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVA6IHtcclxuICBbSyBpbiBFeGNsdWRlPFxyXG4gICAgTmV0d29ya1R5cGUsXHJcbiAgICAnbG9jYWxob3N0JyB8ICdtYWlubmV0JyB8ICdycGMnXHJcbiAgPl06IGAke0NhcGl0YWxpemU8Sz59JHt0eXBlb2YgQ1VSUkVOQ1lfU1lNQk9MUy5FVEh9YDtcclxufSA9IHtcclxuICBbTkVUV09SS19UWVBFUy5HT0VSTEldOiBgJHt0eXBlZENhcGl0YWxpemUoTkVUV09SS19UWVBFUy5HT0VSTEkpfSR7XHJcbiAgICBDVVJSRU5DWV9TWU1CT0xTLkVUSFxyXG4gIH1gLFxyXG4gIFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdOiBgJHt0eXBlZENhcGl0YWxpemUoTkVUV09SS19UWVBFUy5TRVBPTElBKX0ke1xyXG4gICAgQ1VSUkVOQ1lfU1lNQk9MUy5FVEhcclxuICB9YCxcclxuICBbTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVUXTpcclxuICAgIGBMaW5lYSR7Q1VSUkVOQ1lfU1lNQk9MUy5FVEh9YCBhcyBgJHtDYXBpdGFsaXplPFxyXG4gICAgICB0eXBlb2YgTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVUXHJcbiAgICA+fSR7dHlwZW9mIENVUlJFTkNZX1NZTUJPTFMuRVRIfWAsXHJcbn07XHJcblxyXG4vKipcclxuICogTWFwIG9mIGFsbCBidWlsZC1pbiBJbmZ1cmEgbmV0d29ya3MgdG8gdGhlaXIgbmV0d29yaywgdGlja2VyIGFuZCBjaGFpbiBJRHMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQlVJTFRfSU5fTkVUV09SS1MgPSB7XHJcbiAgW05FVFdPUktfVFlQRVMuR09FUkxJXToge1xyXG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5HT0VSTEksXHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuR09FUkxJLFxyXG4gICAgdGlja2VyOiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLkdPRVJMSV0sXHJcbiAgICBibG9ja0V4cGxvcmVyVXJsOiBgaHR0cHM6Ly8ke05FVFdPUktfVFlQRVMuR09FUkxJfS5ldGhlcnNjYW4uaW9gLFxyXG4gIH0sXHJcbiAgW05FVFdPUktfVFlQRVMuU0VQT0xJQV06IHtcclxuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuU0VQT0xJQSxcclxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5TRVBPTElBLFxyXG4gICAgdGlja2VyOiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdLFxyXG4gICAgYmxvY2tFeHBsb3JlclVybDogYGh0dHBzOi8vJHtORVRXT1JLX1RZUEVTLlNFUE9MSUF9LmV0aGVyc2Nhbi5pb2AsXHJcbiAgfSxcclxuICBbTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVUXToge1xyXG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5MSU5FQV9URVNUTkVULFxyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkxJTkVBX1RFU1RORVQsXHJcbiAgICB0aWNrZXI6IFRFU1RfTkVUV09SS19USUNLRVJfTUFQW05FVFdPUktfVFlQRVMuTElORUFfVEVTVE5FVF0sXHJcbiAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5nb2VybGkubGluZWEuYnVpbGQnLFxyXG4gIH0sXHJcbiAgW05FVFdPUktfVFlQRVMuTUFJTk5FVF06IHtcclxuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuTUFJTk5FVCxcclxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5NQUlOTkVULFxyXG4gICAgYmxvY2tFeHBsb3JlclVybDogYGh0dHBzOi8vZXRoZXJzY2FuLmlvYCxcclxuICB9LFxyXG4gIFtORVRXT1JLX1RZUEVTLkxPQ0FMSE9TVF06IHtcclxuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuTE9DQUxIT1NULFxyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkxPQ0FMSE9TVCxcclxuICB9LFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEJVSUxUX0lOX0lORlVSQV9ORVRXT1JLUyA9IHBpY2soXHJcbiAgQlVJTFRfSU5fTkVUV09SS1MsXHJcbiAgSU5GVVJBX1BST1ZJREVSX1RZUEVTLFxyXG4pO1xyXG5cclxuZXhwb3J0IHR5cGUgQnVpbHRJbkluZnVyYU5ldHdvcmsgPSBrZXlvZiB0eXBlb2YgQlVJTFRfSU5fSU5GVVJBX05FVFdPUktTO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5FVFdPUktfVE9fTkFNRV9NQVAgPSB7XHJcbiAgW05FVFdPUktfVFlQRVMuTUFJTk5FVF06IE1BSU5ORVRfRElTUExBWV9OQU1FLFxyXG4gIFtORVRXT1JLX1RZUEVTLkdPRVJMSV06IEdPRVJMSV9ESVNQTEFZX05BTUUsXHJcbiAgW05FVFdPUktfVFlQRVMuU0VQT0xJQV06IFNFUE9MSUFfRElTUExBWV9OQU1FLFxyXG4gIFtORVRXT1JLX1RZUEVTLkxJTkVBX1RFU1RORVRdOiBMSU5FQV9URVNUTkVUX0RJU1BMQVlfTkFNRSxcclxuICBbTkVUV09SS19UWVBFUy5MT0NBTEhPU1RdOiBMT0NBTEhPU1RfRElTUExBWV9OQU1FLFxyXG5cclxuICBbTkVUV09SS19JRFMuR09FUkxJXTogR09FUkxJX0RJU1BMQVlfTkFNRSxcclxuICBbTkVUV09SS19JRFMuU0VQT0xJQV06IFNFUE9MSUFfRElTUExBWV9OQU1FLFxyXG4gIFtORVRXT1JLX0lEUy5MSU5FQV9URVNUTkVUXTogTElORUFfVEVTVE5FVF9ESVNQTEFZX05BTUUsXHJcbiAgW05FVFdPUktfSURTLk1BSU5ORVRdOiBNQUlOTkVUX0RJU1BMQVlfTkFNRSxcclxuICBbTkVUV09SS19JRFMuTE9DQUxIT1NUXTogTE9DQUxIT1NUX0RJU1BMQVlfTkFNRSxcclxuXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBHT0VSTElfRElTUExBWV9OQU1FLFxyXG4gIFtDSEFJTl9JRFMuU0VQT0xJQV06IFNFUE9MSUFfRElTUExBWV9OQU1FLFxyXG4gIFtDSEFJTl9JRFMuTElORUFfVEVTVE5FVF06IExJTkVBX1RFU1RORVRfRElTUExBWV9OQU1FLFxyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE1BSU5ORVRfRElTUExBWV9OQU1FLFxyXG4gIFtDSEFJTl9JRFMuTE9DQUxIT1NUXTogTE9DQUxIT1NUX0RJU1BMQVlfTkFNRSxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBDSEFJTl9JRF9UT19UWVBFX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBORVRXT1JLX1RZUEVTLk1BSU5ORVQsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBORVRXT1JLX1RZUEVTLkdPRVJMSSxcclxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEsXHJcbiAgW0NIQUlOX0lEUy5MSU5FQV9URVNUTkVUXTogTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVULFxyXG4gIFtDSEFJTl9JRFMuTE9DQUxIT1NUXTogTkVUV09SS19UWVBFUy5MT0NBTEhPU1QsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgQ0hBSU5fSURfVE9fUlBDX1VSTF9NQVAgPSB7XHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBHT0VSTElfUlBDX1VSTCxcclxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBTRVBPTElBX1JQQ19VUkwsXHJcbiAgW0NIQUlOX0lEUy5MSU5FQV9URVNUTkVUXTogTElORUFfVEVTVE5FVF9SUENfVVJMLFxyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE1BSU5ORVRfUlBDX1VSTCxcclxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9SUENfVVJMLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX05FVFdPUktfSU1BR0VfVVJMX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBFVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogQVZBWF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NIQUlOX0lEUy5CU0NdOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IE1BVElDX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogQUVUSF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NIQUlOX0lEUy5GQU5UT01dOiBGVE1fVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuSEFSTU9OWV06IEhBUk1PTllfT05FX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogT1BUSU1JU01fVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuUEFMTV06IFBBTE1fVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuQVVST1JBXTogQVVST1JBX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLkNFTE9dOiBDRUxPX1RPS0VOX0lNQUdFX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBORVRXT1JLX0lEX1RPX0VUSEVSU19ORVRXT1JLX05BTUVfTUFQID0ge1xyXG4gIFtORVRXT1JLX0lEUy5HT0VSTEldOiBORVRXT1JLX1RZUEVTLkdPRVJMSSxcclxuICBbTkVUV09SS19JRFMuU0VQT0xJQV06IE5FVFdPUktfVFlQRVMuU0VQT0xJQSxcclxuICBbTkVUV09SS19JRFMuTElORUFfVEVTVE5FVF06IE5FVFdPUktfVFlQRVMuTElORUFfVEVTVE5FVCxcclxuICBbTkVUV09SS19JRFMuTUFJTk5FVF06IE5FVFdPUktfTkFNRVMuSE9NRVNURUFELFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQID0ge1xyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE5FVFdPUktfSURTLk1BSU5ORVQsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBORVRXT1JLX0lEUy5HT0VSTEksXHJcbiAgW0NIQUlOX0lEUy5TRVBPTElBXTogTkVUV09SS19JRFMuU0VQT0xJQSxcclxuICBbQ0hBSU5fSURTLkxJTkVBX1RFU1RORVRdOiBORVRXT1JLX0lEUy5MSU5FQV9URVNUTkVULFxyXG4gIFtDSEFJTl9JRFMuTE9DQUxIT1NUXTogTkVUV09SS19JRFMuTE9DQUxIT1NULFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IE5BVElWRV9DVVJSRU5DWV9UT0tFTl9JTUFHRV9NQVAgPSB7XHJcbiAgW0NVUlJFTkNZX1NZTUJPTFMuRVRIXTogRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5URVNUX0VUSF06IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5CTkJdOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDVVJSRU5DWV9TWU1CT0xTLk1BVElDXTogTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDVVJSRU5DWV9TWU1CT0xTLkFWQUxBTkNIRV06IEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDVVJSRU5DWV9TWU1CT0xTLk9QVElNSVNNXTogT1BUSU1JU01fVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDVVJSRU5DWV9TWU1CT0xTLkNFTE9dOiBDRUxPX1RPS0VOX0lNQUdFX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBJTkZVUkFfQkxPQ0tFRF9LRVkgPSAnY291bnRyeUJsb2NrZWQnO1xyXG5cclxuY29uc3QgZGVmYXVsdEV0aGVyc2NhbkRvbWFpbiA9ICdldGhlcnNjYW4uaW8nO1xyXG5jb25zdCBkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4ID0gJ2FwaSc7XHJcbi8qKlxyXG4gKiBNYXAgb2YgYWxsIEV0aGVyc2NhbiBzdXBwb3J0ZWQgbmV0d29ya3MuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRVRIRVJTQ0FOX1NVUFBPUlRFRF9ORVRXT1JLUyA9IHtcclxuICBbQ0hBSU5fSURTLkdPRVJMSV06IHtcclxuICAgIGRvbWFpbjogZGVmYXVsdEV0aGVyc2NhbkRvbWFpbixcclxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tJHtcclxuICAgICAgQ0hBSU5fSURfVE9fVFlQRV9NQVBbQ0hBSU5fSURTLkdPRVJMSV1cclxuICAgIH1gLFxyXG4gICAgbmV0d29ya0lkOiBDSEFJTl9JRF9UT19ORVRXT1JLX0lEX01BUFtDSEFJTl9JRFMuR09FUkxJXSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IHtcclxuICAgIGRvbWFpbjogZGVmYXVsdEV0aGVyc2NhbkRvbWFpbixcclxuICAgIHN1YmRvbWFpbjogZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeCxcclxuICAgIG5ldHdvcmtJZDogQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbQ0hBSU5fSURTLk1BSU5ORVRdLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5TRVBPTElBXToge1xyXG4gICAgZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuRG9tYWluLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS0ke1xyXG4gICAgICBDSEFJTl9JRF9UT19UWVBFX01BUFtDSEFJTl9JRFMuU0VQT0xJQV1cclxuICAgIH1gLFxyXG4gICAgbmV0d29ya0lkOiBDSEFJTl9JRF9UT19ORVRXT1JLX0lEX01BUFtDSEFJTl9JRFMuU0VQT0xJQV0sXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLkxJTkVBX1RFU1RORVRdOiB7XHJcbiAgICBkb21haW46ICdsaW5lYS5idWlsZCcsXHJcbiAgICBzdWJkb21haW46ICdleHBsb3Jlci5nb2VybGknLFxyXG4gICAgbmV0d29ya0lkOiBDSEFJTl9JRF9UT19ORVRXT1JLX0lEX01BUFtDSEFJTl9JRFMuTElORUFfVEVTVE5FVF0sXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLkJTQ106IHtcclxuICAgIGRvbWFpbjogJ2JzY3NjYW4uY29tJyxcclxuICAgIHN1YmRvbWFpbjogZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeCxcclxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLkJTQywgMTYpLnRvU3RyaW5nKCksXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLkJTQ19URVNUTkVUXToge1xyXG4gICAgZG9tYWluOiAnYnNjc2Nhbi5jb20nLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS10ZXN0bmV0YCxcclxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLkJTQ19URVNUTkVULCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiB7XHJcbiAgICBkb21haW46IGRlZmF1bHRFdGhlcnNjYW5Eb21haW4sXHJcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LW9wdGltaXN0aWNgLFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuT1BUSU1JU00sIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVUXToge1xyXG4gICAgZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuRG9tYWluLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS1nb2VybGktb3B0aW1pc3RpY2AsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVULCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IHtcclxuICAgIGRvbWFpbjogJ3BvbHlnb25zY2FuLmNvbScsXHJcbiAgICBzdWJkb21haW46IGRlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXgsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5QT0xZR09OLCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl9URVNUTkVUXToge1xyXG4gICAgZG9tYWluOiAncG9seWdvbnNjYW4uY29tJyxcclxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tbXVtYmFpYCxcclxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLlBPTFlHT05fVEVTVE5FVCwgMTYpLnRvU3RyaW5nKCksXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IHtcclxuICAgIGRvbWFpbjogJ3Nub3d0cmFjZS5pbycsXHJcbiAgICBzdWJkb21haW46IGRlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXgsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5BVkFMQU5DSEUsIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVfVEVTVE5FVF06IHtcclxuICAgIGRvbWFpbjogJ3Nub3d0cmFjZS5pbycsXHJcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LXRlc3RuZXRgLFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuQVZBTEFOQ0hFX1RFU1RORVQsIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5GQU5UT01dOiB7XHJcbiAgICBkb21haW46ICdmdG1zY2FuLmNvbScsXHJcbiAgICBzdWJkb21haW46IGRlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXgsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5GQU5UT00sIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5GQU5UT01fVEVTVE5FVF06IHtcclxuICAgIGRvbWFpbjogJ2Z0bXNjYW4uY29tJyxcclxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tdGVzdG5ldGAsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5GQU5UT01fVEVTVE5FVCwgMTYpLnRvU3RyaW5nKCksXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLk1PT05CRUFNXToge1xyXG4gICAgZG9tYWluOiAnbW9vbnNjYW4uaW8nLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS1tb29uYmVhbWAsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5NT09OQkVBTSwgMTYpLnRvU3RyaW5nKCksXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLk1PT05CRUFNX1RFU1RORVRdOiB7XHJcbiAgICBkb21haW46ICdtb29uc2Nhbi5pbycsXHJcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LW1vb25iYXNlYCxcclxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLk1PT05CRUFNX1RFU1RORVQsIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5NT09OUklWRVJdOiB7XHJcbiAgICBkb21haW46ICdtb29uc2Nhbi5pbycsXHJcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LW1vb25yaXZlcmAsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5NT09OUklWRVIsIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVAgPSB7XHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IDEsXHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVUXTogMSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFdGhlcmV1bSBKU09OLVJQQyBtZXRob2RzIHRoYXQgYXJlIGtub3duIHRvIGV4aXN0IGJ1dCB0aGF0IHdlIGludGVudGlvbmFsbHlcclxuICogZG8gbm90IHN1cHBvcnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVU5TVVBQT1JURURfUlBDX01FVEhPRFMgPSBuZXcgU2V0KFtcclxuICAvLyBUaGlzIGlzIGltcGxlbWVudGVkIGxhdGVyIGluIG91ciBtaWRkbGV3YXJlIHN0YWNrIOKAkyBzcGVjaWZpY2FsbHksIGluXHJcbiAgLy8gZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUg4oCTIGJ1dCBvdXIgVUkgZG9lcyBub3Qgc3VwcG9ydCBpdC5cclxuICAnZXRoX3NpZ25UcmFuc2FjdGlvbicgYXMgY29uc3QsXHJcbl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IElQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCA9ICdkd2ViLmxpbmsnO1xyXG5cclxuLy8gVGhlIGZpcnN0IGl0ZW0gaW4gdHJhbnNha0N1cnJlbmNpZXMgbXVzdCBiZSB0aGVcclxuLy8gZGVmYXVsdCBjcnlwdG8gY3VycmVuY3kgZm9yIHRoZSBuZXR3b3JrXHJcbmNvbnN0IEJVWUFCTEVfQ0hBSU5fRVRIRVJFVU1fTkVUV09SS19OQU1FID0gJ2V0aGVyZXVtJztcclxuXHJcbmV4cG9ydCBjb25zdCBCVVlBQkxFX0NIQUlOU19NQVA6IHtcclxuICBbSyBpbiBFeGNsdWRlPFxyXG4gICAgQ2hhaW5JZCxcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5MT0NBTEhPU1RcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5QQUxNXHJcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuSEFSTU9OWVxyXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLk9QVElNSVNNX1RFU1RORVRcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5CU0NfVEVTVE5FVFxyXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLlBPTFlHT05fVEVTVE5FVFxyXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLkFWQUxBTkNIRV9URVNUTkVUXHJcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuRkFOVE9NX1RFU1RORVRcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5NT09OQkVBTVxyXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLk1PT05CRUFNX1RFU1RORVRcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5NT09OUklWRVJcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5BVVJPUkFcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5MSU5FQV9URVNUTkVUXHJcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuR09FUkxJXHJcbiAgPl06IEJ1eWFibGVDaGFpblNldHRpbmdzO1xyXG59ID0ge1xyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IHtcclxuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcclxuICAgIG5ldHdvcms6IEJVWUFCTEVfQ0hBSU5fRVRIRVJFVU1fTkVUV09SS19OQU1FLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5TRVBPTElBXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IFRFU1RfTkVUV09SS19USUNLRVJfTUFQW05FVFdPUktfVFlQRVMuU0VQT0xJQV0sXHJcbiAgICBuZXR3b3JrOiBCVVlBQkxFX0NIQUlOX0VUSEVSRVVNX05FVFdPUktfTkFNRSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuQlNDXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQk5CLFxyXG4gICAgbmV0d29yazogJ2JzYycsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcclxuICAgIG5ldHdvcms6ICdwb2x5Z29uJyxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFLFxyXG4gICAgbmV0d29yazogJ2F2YXhjY2hhaW4nLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5GQU5UT01dOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5GQU5UT00sXHJcbiAgICBuZXR3b3JrOiAnZmFudG9tJyxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuQ0VMT106IHtcclxuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkNFTE8sXHJcbiAgICBuZXR3b3JrOiAnY2VsbycsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLk9QVElNSVNNXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxyXG4gICAgbmV0d29yazogJ29wdGltaXNtJyxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5BUkJJVFJVTSxcclxuICAgIG5ldHdvcms6ICdhcmJpdHJ1bScsXHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBGRUFUVVJFRF9SUENTOiBSUENEZWZpbml0aW9uW10gPSBbXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkFSQklUUlVNLFxyXG4gICAgbmlja25hbWU6IEFSQklUUlVNX0RJU1BMQVlfTkFNRSxcclxuICAgIHJwY1VybDogYGh0dHBzOi8vYXJiaXRydW0tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcclxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5BUkJJVFJVTSxcclxuICAgIHJwY1ByZWZzOiB7XHJcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL2V4cGxvcmVyLmFyYml0cnVtLmlvJyxcclxuICAgICAgaW1hZ2VVcmw6IEFFVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIHtcclxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5BVVJPUkEsXHJcbiAgICBuaWNrbmFtZTogQVVST1JBX0RJU1BMQVlfTkFNRSxcclxuICAgIHJwY1VybDogYGh0dHBzOi8vYXVyb3JhLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXHJcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuQVVST1JBLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vYXVyb3Jhc2Nhbi5kZXYvJyxcclxuICAgICAgaW1hZ2VVcmw6IEFVUk9SQV9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkFWQUxBTkNIRSxcclxuICAgIG5pY2tuYW1lOiBBVkFMQU5DSEVfRElTUExBWV9OQU1FLFxyXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hdmFsYW5jaGUtbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcclxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXHJcbiAgICBycGNQcmVmczoge1xyXG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9zbm93dHJhY2UuaW8vJyxcclxuICAgICAgaW1hZ2VVcmw6IEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIHtcclxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5CU0MsXHJcbiAgICBuaWNrbmFtZTogQk5CX0RJU1BMQVlfTkFNRSxcclxuICAgIHJwY1VybDogJ2h0dHBzOi8vYnNjLWRhdGFzZWVkLmJpbmFuY2Uub3JnLycsXHJcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuQk5CLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vYnNjc2Nhbi5jb20vJyxcclxuICAgICAgaW1hZ2VVcmw6IEJOQl9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkZBTlRPTSxcclxuICAgIG5pY2tuYW1lOiBGQU5UT01fRElTUExBWV9OQU1FLFxyXG4gICAgcnBjVXJsOiAnaHR0cHM6Ly9ycGMuZnRtLnRvb2xzLycsXHJcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuRkFOVE9NLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZnRtc2Nhbi5jb20vJyxcclxuICAgICAgaW1hZ2VVcmw6IEZUTV9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkhBUk1PTlksXHJcbiAgICBuaWNrbmFtZTogSEFSTU9OWV9ESVNQTEFZX05BTUUsXHJcbiAgICBycGNVcmw6ICdodHRwczovL2FwaS5oYXJtb255Lm9uZS8nLFxyXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkhBUk1PTlksXHJcbiAgICBycGNQcmVmczoge1xyXG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5oYXJtb255Lm9uZS8nLFxyXG4gICAgICBpbWFnZVVybDogSEFSTU9OWV9PTkVfVE9LRU5fSU1BR0VfVVJMLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIHtcclxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5PUFRJTUlTTSxcclxuICAgIG5pY2tuYW1lOiBPUFRJTUlTTV9ESVNQTEFZX05BTUUsXHJcbiAgICBycGNVcmw6IGBodHRwczovL29wdGltaXNtLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXHJcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW8vJyxcclxuICAgICAgaW1hZ2VVcmw6IE9QVElNSVNNX1RPS0VOX0lNQUdFX1VSTCxcclxuICAgIH0sXHJcbiAgfSxcclxuICB7XHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuUEFMTSxcclxuICAgIG5pY2tuYW1lOiBQQUxNX0RJU1BMQVlfTkFNRSxcclxuICAgIHJwY1VybDogYGh0dHBzOi8vcGFsbS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxyXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLlBBTE0sXHJcbiAgICBycGNQcmVmczoge1xyXG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5wYWxtLmlvLycsXHJcbiAgICAgIGltYWdlVXJsOiBQQUxNX1RPS0VOX0lNQUdFX1VSTCxcclxuICAgIH0sXHJcbiAgfSxcclxuICB7XHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuUE9MWUdPTixcclxuICAgIG5pY2tuYW1lOiBgJHtQT0xZR09OX0RJU1BMQVlfTkFNRX0gJHtjYXBpdGFsaXplKE5FVFdPUktfVFlQRVMuTUFJTk5FVCl9YCxcclxuICAgIHJwY1VybDogYGh0dHBzOi8vcG9seWdvbi1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxyXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vcG9seWdvbnNjYW4uY29tLycsXHJcbiAgICAgIGltYWdlVXJsOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkNFTE8sXHJcbiAgICBuaWNrbmFtZTogQ0VMT19ESVNQTEFZX05BTUUsXHJcbiAgICBycGNVcmw6IGBodHRwczovL2NlbG8tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcclxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5DRUxPLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vY2Vsb3NjYW4uaW8nLFxyXG4gICAgICBpbWFnZVVybDogQ0VMT19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgU0hPVUxEX1NIT1dfTElORUFfVEVTVE5FVF9ORVRXT1JLID1cclxuICBuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IERhdGUuVVRDKDIwMjMsIDIsIDI4LCA4KTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBhdmFpbGFiaWxpdHkgc3RhdGUgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBuZXR3b3JrLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gTmV0d29ya1N0YXR1cyB7XHJcbiAgLyoqXHJcbiAgICogVGhlIG5ldHdvcmsgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byByZWNlaXZlIHJlcXVlc3RzLCBidXQgZWl0aGVyIG5vXHJcbiAgICogYXR0ZW1wdCBoYXMgYmVlbiBtYWRlIHRvIGRldGVybWluZSB0aGlzLCBvciBhbiBhdHRlbXB0IHdhcyBtYWRlIGJ1dCB3YXNcclxuICAgKiB1bnN1Y2Nlc3NmdWwuXHJcbiAgICovXHJcbiAgVW5rbm93biA9ICd1bmtub3duJyxcclxuICAvKipcclxuICAgKiBUaGUgbmV0d29yayBpcyBhYmxlIHRvIHJlY2VpdmUgYW5kIHJlc3BvbmQgdG8gcmVxdWVzdHMuXHJcbiAgICovXHJcbiAgQXZhaWxhYmxlID0gJ2F2YWlsYWJsZScsXHJcbiAgLyoqXHJcbiAgICogVGhlIG5ldHdvcmsgaXMgdW5hYmxlIHRvIHJlY2VpdmUgYW5kIHJlc3BvbmQgdG8gcmVxdWVzdHMgZm9yIHVua25vd25cclxuICAgKiByZWFzb25zLlxyXG4gICAqL1xyXG4gIFVuYXZhaWxhYmxlID0gJ3VuYXZhaWxhYmxlJyxcclxuICAvKipcclxuICAgKiBUaGUgbmV0d29yayBpcyBub3Qgb25seSB1bmF2YWlsYWJsZSwgYnV0IGlzIGFsc28gaW5hY2Nlc3NpYmxlIGZvciB0aGUgdXNlclxyXG4gICAqIHNwZWNpZmljYWxseSBiYXNlZCBvbiB0aGVpciBsb2NhdGlvbi4gVGhpcyBzdGF0ZSBvbmx5IGFwcGxpZXMgdG8gSW5mdXJhXHJcbiAgICogbmV0d29ya3MuXHJcbiAgICovXHJcbiAgQmxvY2tlZCA9ICdibG9ja2VkJyxcclxufVxyXG4iLCJleHBvcnQgY29uc3QgQ2F2ZWF0VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcclxuICByZXN0cmljdFJldHVybmVkQWNjb3VudHM6ICdyZXN0cmljdFJldHVybmVkQWNjb3VudHMnIGFzIGNvbnN0LFxyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCBSZXN0cmljdGVkTWV0aG9kcyA9IE9iamVjdC5mcmVlemUoe1xyXG4gIGV0aF9hY2NvdW50czogJ2V0aF9hY2NvdW50cycsXHJcblxufSBhcyBjb25zdCk7XHJcblxyXG5cbiIsImV4cG9ydCBlbnVtIFRoZW1lVHlwZSB7XHJcbiAgbGlnaHQgPSAnbGlnaHQnLFxyXG4gIGRhcmsgPSAnZGFyaycsXHJcbiAgb3MgPSAnb3MnLFxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxuICBURVNUX0VUSF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgQk5CX1RPS0VOX0lNQUdFX1VSTCxcclxuICBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgQVZBWF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgQ1VSUkVOQ1lfU1lNQk9MUyxcclxuICBDSEFJTl9JRFMsXHJcbn0gZnJvbSAnLi9uZXR3b3JrJztcclxuXHJcbmV4cG9ydCBjb25zdCBRVU9URVNfRVhQSVJFRF9FUlJPUiA9ICdxdW90ZXMtZXhwaXJlZCc7XHJcbmV4cG9ydCBjb25zdCBTV0FQX0ZBSUxFRF9FUlJPUiA9ICdzd2FwLWZhaWxlZC1lcnJvcic7XHJcbmV4cG9ydCBjb25zdCBFUlJPUl9GRVRDSElOR19RVU9URVMgPSAnZXJyb3ItZmV0Y2hpbmctcXVvdGVzJztcclxuZXhwb3J0IGNvbnN0IFFVT1RFU19OT1RfQVZBSUxBQkxFX0VSUk9SID0gJ3F1b3Rlcy1ub3QtYXZpbGFibGUnO1xyXG5leHBvcnQgY29uc3QgQ09OVFJBQ1RfREFUQV9ESVNBQkxFRF9FUlJPUiA9ICdjb250cmFjdC1kYXRhLWRpc2FibGVkJztcclxuZXhwb3J0IGNvbnN0IE9GRkxJTkVfRk9SX01BSU5URU5BTkNFID0gJ29mZmxpbmUtZm9yLW1haW50ZW5hbmNlJztcclxuZXhwb3J0IGNvbnN0IFNXQVBTX0ZFVENIX09SREVSX0NPTkZMSUNUID0gJ3N3YXBzLWZldGNoLW9yZGVyLWNvbmZsaWN0JztcclxuXHJcbi8vIEFuIGFkZHJlc3MgdGhhdCB0aGUgbWV0YXN3YXAtYXBpIHJlY29nbml6ZXMgYXMgdGhlIGRlZmF1bHQgdG9rZW4gZm9yIHRoZSBjdXJyZW50IG5ldHdvcmssXHJcbi8vIGluIHBsYWNlIG9mIHRoZSB0b2tlbiBhZGRyZXNzIHRoYXQgRVJDLTIwIHRva2VucyBoYXZlXHJcbmNvbnN0IERFRkFVTFRfVE9LRU5fQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTd2Fwc1Rva2VuT2JqZWN0IHtcclxuICAvKipcclxuICAgKiBUaGUgc3ltYm9sIG9mIHRva2VuIG9iamVjdFxyXG4gICAqL1xyXG4gIHN5bWJvbDogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBuYW1lIGZvciB0aGUgbmV0d29ya1xyXG4gICAqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuICAvKipcclxuICAgKiBBbiBhZGRyZXNzIHRoYXQgdGhlIG1ldGFzd2FwLWFwaSByZWNvZ25pemVzIGFzIHRoZSBkZWZhdWx0IHRva2VuXHJcbiAgICovXHJcbiAgYWRkcmVzczogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIE51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZGVjaW1hbCBwb2ludFxyXG4gICAqL1xyXG4gIGRlY2ltYWxzOiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogVVJMIGZvciB0b2tlbiBpY29uXHJcbiAgICovXHJcbiAgaWNvblVybDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgRVRIX1NXQVBTX1RPS0VOX09CSkVDVDogU3dhcHNUb2tlbk9iamVjdCA9IHtcclxuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxyXG4gIG5hbWU6ICdFdGhlcicsXHJcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxyXG4gIGRlY2ltYWxzOiAxOCxcclxuICBpY29uVXJsOiBFVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEJOQl9TV0FQU19UT0tFTl9PQkpFQ1Q6IFN3YXBzVG9rZW5PYmplY3QgPSB7XHJcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLkJOQixcclxuICBuYW1lOiAnQmluYW5jZSBDb2luJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6IEJOQl9UT0tFTl9JTUFHRV9VUkwsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgTUFUSUNfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcclxuICBuYW1lOiAnTWF0aWMnLFxyXG4gIGFkZHJlc3M6IERFRkFVTFRfVE9LRU5fQUREUkVTUyxcclxuICBkZWNpbWFsczogMTgsXHJcbiAgaWNvblVybDogTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFWQVhfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXHJcbiAgbmFtZTogJ0F2YWxhbmNoZScsXHJcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxyXG4gIGRlY2ltYWxzOiAxOCxcclxuICBpY29uVXJsOiBBVkFYX1RPS0VOX0lNQUdFX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBURVNUX0VUSF9TV0FQU19UT0tFTl9PQkpFQ1Q6IFN3YXBzVG9rZW5PYmplY3QgPSB7XHJcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLlRFU1RfRVRILFxyXG4gIG5hbWU6ICdUZXN0IEV0aGVyJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBHT0VSTElfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXHJcbiAgbmFtZTogJ0V0aGVyJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBBUkJJVFJVTV9TV0FQU19UT0tFTl9PQkpFQ1Q6IFN3YXBzVG9rZW5PYmplY3QgPSB7XHJcbiAgLi4uRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBPUFRJTUlTTV9TV0FQU19UT0tFTl9PQkpFQ1Q6IFN3YXBzVG9rZW5PYmplY3QgPSB7XHJcbiAgLi4uRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcclxufSBhcyBjb25zdDtcclxuXHJcbi8vIEEgZ2FzIHZhbHVlIGZvciBFUkMyMCBhcHByb3ZlIGNhbGxzIHRoYXQgc2hvdWxkIGJlIHN1ZmZpY2llbnQgZm9yIGFsbCBFUkMyMCBhcHByb3ZlIGltcGxlbWVudGF0aW9uc1xyXG5leHBvcnQgY29uc3QgREVGQVVMVF9FUkMyMF9BUFBST1ZFX0dBUyA9ICcweDFkNGMwJztcclxuXHJcbi8vIENvbnRyYWN0IGFkZHJlc3NlcyBiZWxvdyBzaG91bGQgYmUgaW4gbG93ZXJjYXNlLlxyXG5jb25zdCBNQUlOTkVUX0NPTlRSQUNUX0FERFJFU1MgPSAnMHg4ODFkNDAyMzc2NTljMjUxODExY2VjOWMzNjRlZjkxZGMwOGQzMDBjJztcclxuY29uc3QgVEVTVE5FVF9DT05UUkFDVF9BRERSRVNTID0gJzB4ODgxZDQwMjM3NjU5YzI1MTgxMWNlYzljMzY0ZWY5MWRjMDhkMzAwYyc7XHJcbmNvbnN0IEJTQ19DT05UUkFDVF9BRERSRVNTID0gJzB4MWExZWMyNWRjMDhlOThlNWU5M2YxMTA0YjVlNWNkZDI5ODcwN2QzMSc7XHJcbmNvbnN0IFBPTFlHT05fQ09OVFJBQ1RfQUREUkVTUyA9ICcweDFhMWVjMjVkYzA4ZTk4ZTVlOTNmMTEwNGI1ZTVjZGQyOTg3MDdkMzEnO1xyXG5jb25zdCBBVkFMQU5DSEVfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDFhMWVjMjVkYzA4ZTk4ZTVlOTNmMTEwNGI1ZTVjZGQyOTg3MDdkMzEnO1xyXG5jb25zdCBPUFRJTUlTTV9DT05UUkFDVF9BRERSRVNTID0gJzB4OWRkYTZlZjNkOTE5YzliYzg4ODVkNTU2MDk5OWEzNjQwNDMxZThlNic7XHJcbmNvbnN0IEFSQklUUlVNX0NPTlRSQUNUX0FERFJFU1MgPSAnMHg5ZGRhNmVmM2Q5MTljOWJjODg4NWQ1NTYwOTk5YTM2NDA0MzFlOGU2JztcclxuXHJcbmV4cG9ydCBjb25zdCBXRVRIX0NPTlRSQUNUX0FERFJFU1MgPVxyXG4gICcweGMwMmFhYTM5YjIyM2ZlOGQwYTBlNWM0ZjI3ZWFkOTA4M2M3NTZjYzInO1xyXG5leHBvcnQgY29uc3QgV0VUSF9HT0VSTElfQ09OVFJBQ1RfQUREUkVTUyA9XHJcbiAgJzB4QjRGQkYyNzExNDNGNEZCZjdCOTFBNWRlZDMxODA1ZTQyYjIyMDhkNic7XHJcbmV4cG9ydCBjb25zdCBXQk5CX0NPTlRSQUNUX0FERFJFU1MgPVxyXG4gICcweGJiNGNkYjljYmQzNmIwMWJkMWNiYWViZjJkZTA4ZDkxNzNiYzA5NWMnO1xyXG5leHBvcnQgY29uc3QgV01BVElDX0NPTlRSQUNUX0FERFJFU1MgPVxyXG4gICcweDBkNTAwYjFkOGU4ZWYzMWUyMWM5OWQxZGI5YTY0NDRkM2FkZjEyNzAnO1xyXG5leHBvcnQgY29uc3QgV0FWQVhfQ09OVFJBQ1RfQUREUkVTUyA9XHJcbiAgJzB4YjMxZjY2YWEzYzFlNzg1MzYzZjA4NzVhMWI3NGUyN2I4NWZkNjZjNyc7XHJcblxyXG5leHBvcnQgY29uc3QgV0VUSF9PUFRJTUlTTV9DT05UUkFDVF9BRERSRVNTID1cclxuICAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2JztcclxuZXhwb3J0IGNvbnN0IFdFVEhfQVJCSVRSVU1fQ09OVFJBQ1RfQUREUkVTUyA9XHJcbiAgJzB4ODJhZjQ5NDQ3ZDhhMDdlM2JkOTViZDBkNTZmMzUyNDE1MjNmYmFiMSc7XHJcblxyXG5jb25zdCBTV0FQU19URVNUTkVUX0NIQUlOX0lEID0gJzB4NTM5JztcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19BUElfVjJfQkFTRV9VUkwgPSAnaHR0cHM6Ly9zd2FwLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrJztcclxuZXhwb3J0IGNvbnN0IFNXQVBTX0RFVl9BUElfVjJfQkFTRV9VUkwgPVxyXG4gICdodHRwczovL3N3YXAubWV0YXN3YXAtZGV2LmNvZGVmaS5uZXR3b3JrJztcclxuZXhwb3J0IGNvbnN0IEdBU19BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9nYXMtYXBpLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrJztcclxuZXhwb3J0IGNvbnN0IEdBU19ERVZfQVBJX0JBU0VfVVJMID1cclxuICAnaHR0cHM6Ly9nYXMtYXBpLm1ldGFzd2FwLWRldi5jb2RlZmkubmV0d29yayc7XHJcblxyXG5jb25zdCBCU0NfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9ic2NzY2FuLmNvbS8nO1xyXG5jb25zdCBNQUlOTkVUX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMID0gJ2h0dHBzOi8vZXRoZXJzY2FuLmlvLyc7XHJcbmNvbnN0IEdPRVJMSV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2dvZXJsaS5ldGhlcnNjYW4uaW8vJztcclxuY29uc3QgUE9MWUdPTl9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL3BvbHlnb25zY2FuLmNvbS8nO1xyXG5jb25zdCBBVkFMQU5DSEVfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9zbm93dHJhY2UuaW8vJztcclxuY29uc3QgT1BUSU1JU01fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9vcHRpbWlzdGljLmV0aGVyc2Nhbi5pby8nO1xyXG5jb25zdCBBUkJJVFJVTV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2FyYmlzY2FuLmlvLyc7XHJcblxyXG5leHBvcnQgY29uc3QgQUxMT1dFRF9QUk9EX1NXQVBTX0NIQUlOX0lEUyA9IFtcclxuICBDSEFJTl9JRFMuTUFJTk5FVCxcclxuICBTV0FQU19URVNUTkVUX0NIQUlOX0lELFxyXG4gIENIQUlOX0lEUy5CU0MsXHJcbiAgQ0hBSU5fSURTLlBPTFlHT04sXHJcbiAgQ0hBSU5fSURTLkFWQUxBTkNIRSxcclxuICBDSEFJTl9JRFMuT1BUSU1JU00sXHJcbiAgQ0hBSU5fSURTLkFSQklUUlVNLFxyXG5dIGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMTE9XRURfREVWX1NXQVBTX0NIQUlOX0lEUyA9IFtcclxuICAuLi5BTExPV0VEX1BST0RfU1dBUFNfQ0hBSU5fSURTLFxyXG4gIENIQUlOX0lEUy5HT0VSTEksXHJcbl0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgQUxMT1dFRF9TTUFSVF9UUkFOU0FDVElPTlNfQ0hBSU5fSURTID0gW1xyXG4gIENIQUlOX0lEUy5NQUlOTkVULFxyXG4gIENIQUlOX0lEUy5HT0VSTEksXHJcbl0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBURVNUTkVUX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5CU0NdOiBCU0NfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBQT0xZR09OX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBURVNUTkVUX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFMQU5DSEVfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogQVJCSVRSVU1fQ09OVFJBQ1RfQUREUkVTUyxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVMgPSB7XHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogV0VUSF9DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXTogV0VUSF9DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuQlNDXTogV0JOQl9DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFdNQVRJQ19DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogV0VUSF9HT0VSTElfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IFdBVkFYX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IFdFVEhfT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogV0VUSF9BUkJJVFJVTV9DT05UUkFDVF9BRERSRVNTLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMTE9XRURfQ09OVFJBQ1RfQUREUkVTU0VTID0ge1xyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLk1BSU5ORVRdLFxyXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5NQUlOTkVUXSxcclxuICBdLFxyXG4gIFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tTV0FQU19URVNUTkVUX0NIQUlOX0lEXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuR09FUkxJXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuR09FUkxJXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuQlNDXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuQlNDXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuQlNDXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLlBPTFlHT05dLFxyXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5QT0xZR09OXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuQVZBTEFOQ0hFXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuQVZBTEFOQ0hFXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBbXHJcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5PUFRJTUlTTV0sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLk9QVElNSVNNXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBbXHJcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5BUkJJVFJVTV0sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkFSQklUUlVNXSxcclxuICBdLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVAgPSB7XHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcclxuICBbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF06IFRFU1RfRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcclxuICBbQ0hBSU5fSURTLkJTQ106IEJOQl9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbiAgW0NIQUlOX0lEUy5QT0xZR09OXTogTUFUSUNfU1dBUFNfVE9LRU5fT0JKRUNULFxyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX1NXQVBTX1RPS0VOX09CSkVDVCxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IEFWQVhfU1dBUFNfVE9LRU5fT0JKRUNULFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBPUFRJTUlTTV9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IEFSQklUUlVNX1NXQVBTX1RPS0VOX09CSkVDVCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLkJTQ106IEJTQ19ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFBPTFlHT05fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBHT0VSTElfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFMQU5DSEVfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IE9QVElNSVNNX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxyXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBBUkJJVFJVTV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBFVEhFUkVVTSA9ICdldGhlcmV1bSc7XHJcbmV4cG9ydCBjb25zdCBQT0xZR09OID0gJ3BvbHlnb24nO1xyXG5leHBvcnQgY29uc3QgQlNDID0gJ2JzYyc7XHJcbmV4cG9ydCBjb25zdCBHT0VSTEkgPSAnZ29lcmxpJztcclxuZXhwb3J0IGNvbnN0IEFWQUxBTkNIRSA9ICdhdmFsYW5jaGUnO1xyXG5leHBvcnQgY29uc3QgT1BUSU1JU00gPSAnb3B0aW1pc20nO1xyXG5leHBvcnQgY29uc3QgQVJCSVRSVU0gPSAnYXJiaXRydW0nO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNXQVBTX0NMSUVOVF9JRCA9ICdleHRlbnNpb24nO1xyXG5cclxuZXhwb3J0IGVudW0gVG9rZW5CdWNrZXRQcmlvcml0eSB7XHJcbiAgb3duZWQgPSAnb3duZWQnLFxyXG4gIHRvcCA9ICd0b3AnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBTbGlwcGFnZSB7XHJcbiAgZGVmYXVsdCA9IDIsXHJcbiAgaGlnaCA9IDMsXHJcbn1cclxuIiwiZXhwb3J0IGNvbnN0IE1JTExJU0VDT05EID0gMTtcclxuZXhwb3J0IGNvbnN0IFNFQ09ORCA9IE1JTExJU0VDT05EICogMTAwMDtcclxuZXhwb3J0IGNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xyXG5leHBvcnQgY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwO1xyXG5leHBvcnQgY29uc3QgREFZID0gSE9VUiAqIDI0O1xyXG4iLCJpbXBvcnQgY29udHJhY3RNYXAgZnJvbSAnQG1ldGFtYXNrL2NvbnRyYWN0LW1ldGFkYXRhJztcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgbm9ybWFsaXplZCBsaXN0IG9mIGFkZHJlc3NlcyBleHBvcnRlZCBhcyBwYXJ0IG9mIHRoZSBjb250cmFjdE1hcCBpblxyXG4gKiBgQG1ldGFtYXNrL2NvbnRyYWN0LW1ldGFkYXRhYC4gVXNlZCBwcmltYXJpbHkgdG8gdmFsaWRhdGUgaWYgbWFudWFsbHkgZW50ZXJlZFxyXG4gKiBjb250cmFjdCBhZGRyZXNzZXMgZG8gbm90IG1hdGNoIG9uZSBvZiBvdXIgbGlzdGVkIHRva2Vuc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExJU1RFRF9DT05UUkFDVF9BRERSRVNTRVMgPSBPYmplY3Qua2V5cyhjb250cmFjdE1hcCkubWFwKFxyXG4gIChhZGRyZXNzKSA9PiBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXHJcbik7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gVG9rZW5EZXRhaWxzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlbGVjdGVkICdUT0tFTicgb3JcclxuICogICdORlQnIGNvbnRyYWN0LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N5bWJvbF0gLSBUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbi5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWNpbWFsc10gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9mIHRoZSBzZWxlY3RlZFxyXG4gKiAgJ0VSQzIwJyBhc3NldC5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b2tlbklkXSAtIFRoZSBpZCBvZiB0aGUgc2VsZWN0ZWQgJ05GVCcgYXNzZXQuXHJcbiAqIEBwcm9wZXJ0eSB7VG9rZW5TdGFuZGFyZFN0cmluZ3N9IFtzdGFuZGFyZF0gLSBUaGUgc3RhbmRhcmQgb2YgdGhlIHNlbGVjdGVkXHJcbiAqICBhc3NldC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBbaXNFUkM3MjFdIC0gVHJ1ZSB3aGVuIHRoZSBhc3NldCBpcyBhIEVSQzcyMSB0b2tlbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBTVEFUSUNfTUFJTk5FVF9UT0tFTl9MSVNUID0gT2JqZWN0LmtleXMoY29udHJhY3RNYXApLnJlZHVjZShcclxuICAoYWNjLCBiYXNlKSA9PiB7XHJcbiAgICBjb25zdCB7IGxvZ28sIC4uLnRva2VuTWV0YWRhdGEgfSA9IGNvbnRyYWN0TWFwW2Jhc2VdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4uYWNjLFxyXG4gICAgICBbYmFzZS50b0xvd2VyQ2FzZSgpXToge1xyXG4gICAgICAgIC4uLnRva2VuTWV0YWRhdGEsXHJcbiAgICAgICAgYWRkcmVzczogYmFzZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgIGljb25Vcmw6IGBpbWFnZXMvY29udHJhY3QvJHtsb2dvfWAsXHJcbiAgICAgICAgYWdncmVnYXRvcnM6IFtdLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9LFxyXG4gIHt9LFxyXG4pO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRPS0VOX0FQSV9NRVRBU1dBUF9DT0RFRklfVVJMID1cclxuICAnaHR0cHM6Ly90b2tlbi1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsvdG9rZW5zLyc7XHJcbmV4cG9ydCBjb25zdCBNQVhfVE9LRU5fQUxMT1dBTkNFX0FNT1VOVCA9IG5ldyBCaWdOdW1iZXIoMilcclxuICAucG93KDI1NilcclxuICAubWludXMoMSlcclxuICAudG9TdHJpbmcoMTApO1xyXG4vLyBudW1iZXIgd2l0aCBvcHRpb25hbCBkZWNpbWFsIHBvaW50IHVzaW5nIGEgY29tbWEgb3IgZG90XHJcbmV4cG9ydCBjb25zdCBOVU1fV19PUFRfREVDSU1BTF9DT01NQV9PUl9ET1RfUkVHRVggPVxyXG4gIC9eWzAtOV17MSx9KFssLl1bMC05XXsxLH0pPyQvdTtcclxuZXhwb3J0IGNvbnN0IERFQ0lNQUxfUkVHRVggPSAvXFwuKFxcZCopL3U7XHJcbiIsImltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdAZXRoZXJldW1qcy90eCc7XHJcblxyXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvblR5cGUge1xyXG4gIC8qKlxyXG4gICAqIEEgdHJhbnNhY3Rpb24gc3VibWl0dGVkIHdpdGggdGhlIHNhbWUgbm9uY2UgYXMgYSBwcmV2aW91cyB0cmFuc2FjdGlvbiwgYVxyXG4gICAqIGhpZ2hlciBnYXMgcHJpY2UgYW5kIGEgemVyb2VkIG91dCBzZW5kIGFtb3VudC4gVXNlZnVsIGZvciB1c2VycyB3aG9cclxuICAgKiBhY2NpZGVudGFsbHkgc2VuZCB0byBlcnJvbmVvdXMgYWRkcmVzc2VzIG9yIGlmIHRoZXkgc2VuZCB0b28gbXVjaC5cclxuICAgKi9cclxuICBjYW5jZWwgPSAnY2FuY2VsJyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIHRoYXQgaXMgaW50ZXJhY3Rpbmcgd2l0aCBhIHNtYXJ0IGNvbnRyYWN0J3MgbWV0aG9kcyB0aGF0IHdlXHJcbiAgICogaGF2ZSBub3QgdHJlYXRlZCBhcyBhIHNwZWNpYWwgY2FzZSwgc3VjaCBhcyBhcHByb3ZlLCB0cmFuc2ZlciwgYW5kXHJcbiAgICogdHJhbnNmZXJmcm9tXHJcbiAgICovXHJcbiAgY29udHJhY3RJbnRlcmFjdGlvbiA9ICdjb250cmFjdEludGVyYWN0aW9uJyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIHRoYXQgZGVwbG95ZWQgYSBzbWFydCBjb250cmFjdFxyXG4gICAqL1xyXG4gIGRlcGxveUNvbnRyYWN0ID0gJ2NvbnRyYWN0RGVwbG95bWVudCcsXHJcbiAgZXRoRGVjcnlwdCA9ICdldGhfZGVjcnlwdCcsXHJcbiAgZXRoR2V0RW5jcnlwdGlvblB1YmxpY0tleSA9ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXHJcbiAgLyoqXHJcbiAgICogQW4gaW5jb21pbmcgKGRlcG9zaXQpIHRyYW5zYWN0aW9uXHJcbiAgICovXHJcbiAgaW5jb21pbmcgPSAnaW5jb21pbmcnLFxyXG4gIHBlcnNvbmFsU2lnbiA9ICdwZXJzb25hbF9zaWduJyxcclxuICAvKipcclxuICAgKiBXaGVuIGEgdHJhbnNhY3Rpb24gaXMgZmFpbGVkIGl0IGNhbiBiZSByZXRyaWVkIGJ5XHJcbiAgICogcmVzdWJtaXR0aW5nIHRoZSBzYW1lIHRyYW5zYWN0aW9uIHdpdGggYSBoaWdoZXIgZ2FzIGZlZS4gVGhpcyB0eXBlIGlzIGFsc28gdXNlZFxyXG4gICAqIHRvIHNwZWVkIHVwIHBlbmRpbmcgdHJhbnNhY3Rpb25zLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBjcmVhdGluZyBhIG5ldyB0eCB3aXRoXHJcbiAgICogdGhlIHNhbWUgbm9uY2UgYW5kIGhpZ2hlciBnYXMgZmVlcy5cclxuICAgKi9cclxuICByZXRyeSA9ICdyZXRyeScsXHJcbiAgc2lnbiA9ICdldGhfc2lnbicsXHJcbiAgc2lnblR5cGVkRGF0YSA9ICdldGhfc2lnblR5cGVkRGF0YScsXHJcbiAgLyoqIEEgdHJhbnNhY3Rpb24gc2VuZGluZyBhIG5ldHdvcmsncyBuYXRpdmUgYXNzZXQgdG8gYSByZWNpcGllbnQgKi9cclxuICBzaW1wbGVTZW5kID0gJ3NpbXBsZVNlbmQnLFxyXG4gIHNtYXJ0ID0gJ3NtYXJ0JyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIHN3YXBwaW5nIG9uZSB0b2tlbiBmb3IgYW5vdGhlciB0aHJvdWdoIE1ldGFNYXNrIFN3YXBzXHJcbiAgICovXHJcbiAgc3dhcCA9ICdzd2FwJyxcclxuICAvKipcclxuICAgKiBTaW1pbGFyIHRvIHRoZSBhcHByb3ZlIHR5cGUsIGEgc3dhcCBhcHByb3ZhbCBpcyBhIHNwZWNpYWwgY2FzZSBvZiBFUkMyMFxyXG4gICAqIGFwcHJvdmUgbWV0aG9kIHRoYXQgcmVxdWVzdHMgYW4gYWxsb3dhbmNlIG9mIHRoZSB0b2tlbiB0byBzcGVuZCBvbiBiZWhhbGZcclxuICAgKiBvZiB0aGUgdXNlciBmb3IgdGhlIE1ldGFNYXNrIFN3YXBzIGNvbnRyYWN0LiBUaGUgZmlyc3Qgc3dhcCBmb3IgYW55IHRva2VuXHJcbiAgICogd2lsbCBoYXZlIGFuIGFjY29tcGFueWluZyBzd2FwQXBwcm92YWwgdHJhbnNhY3Rpb24uXHJcbiAgICovXHJcbiAgc3dhcEFwcHJvdmFsID0gJ3N3YXBBcHByb3ZhbCcsXHJcbiAgLyoqXHJcbiAgICogQSB0b2tlbiB0cmFuc2FjdGlvbiByZXF1ZXN0aW5nIGFuIGFsbG93YW5jZSBvZiB0aGUgdG9rZW4gdG8gc3BlbmQgb25cclxuICAgKiBiZWhhbGYgb2YgdGhlIHVzZXJcclxuICAgKi9cclxuICB0b2tlbk1ldGhvZEFwcHJvdmUgPSAnYXBwcm92ZScsXHJcbiAgLyoqXHJcbiAgICogQSB0b2tlbiB0cmFuc2FjdGlvbiB0cmFuc2ZlcnJpbmcgdG9rZW5zIGZyb20gYW4gYWNjb3VudCB0aGF0IHRoZSBzZW5kZXJcclxuICAgKiBoYXMgYW4gYWxsb3dhbmNlIG9mLiBUaGUgbWV0aG9kIGlzIHByZWZpeGVkIHdpdGggc2FmZSBiZWNhdXNlIHdoZW4gY2FsbGluZ1xyXG4gICAqIHRoaXMgbWV0aG9kIHRoZSBjb250cmFjdCBjaGVja3MgdG8gZW5zdXJlIHRoYXQgdGhlIHJlY2VpdmVyIGlzIGFuIGFkZHJlc3NcclxuICAgKiBjYXBhYmxlIG9mIGhhbmRsaW5nIHdpdGggdGhlIHRva2VuIGJlaW5nIHNlbnQuXHJcbiAgICovXHJcbiAgdG9rZW5NZXRob2RTYWZlVHJhbnNmZXJGcm9tID0gJ3NhZmV0cmFuc2ZlcmZyb20nLFxyXG4gIC8qKlxyXG4gICAqIEEgdG9rZW4gdHJhbnNhY3Rpb24gd2hlcmUgdGhlIHVzZXIgaXMgc2VuZGluZyB0b2tlbnMgdGhhdCB0aGV5IG93biB0b1xyXG4gICAqIGFub3RoZXIgYWRkcmVzc1xyXG4gICAqL1xyXG4gIHRva2VuTWV0aG9kVHJhbnNmZXIgPSAndHJhbnNmZXInLFxyXG4gIC8qKlxyXG4gICAqIEEgdG9rZW4gdHJhbnNhY3Rpb24gdHJhbnNmZXJyaW5nIHRva2VucyBmcm9tIGFuIGFjY291bnQgdGhhdCB0aGUgc2VuZGVyXHJcbiAgICogaGFzIGFuIGFsbG93YW5jZSBvZi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYWxsb3dhbmNlcywgc2VlIHRoZSBhcHByb3ZlXHJcbiAgICogdHlwZS5cclxuICAgKi9cclxuICB0b2tlbk1ldGhvZFRyYW5zZmVyRnJvbSA9ICd0cmFuc2ZlcmZyb20nLFxyXG4gIC8qKlxyXG4gICAqIEEgdG9rZW4gdHJhbnNhY3Rpb24gcmVxdWVzdGluZyBhbiBhbGxvd2FuY2Ugb2YgYWxsIG9mIGEgdXNlcidzIHRva2VuIHRvXHJcbiAgICogc3BlbmQgb24gYmVoYWxmIG9mIHRoZSB1c2VyXHJcbiAgICovXHJcbiAgdG9rZW5NZXRob2RTZXRBcHByb3ZhbEZvckFsbCA9ICdzZXRhcHByb3ZhbGZvcmFsbCcsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbiBFSVAtMjcxOCB0eXBlZCB0cmFuc2FjdGlvbiBlbnZlbG9wZXMgd2VyZSBzcGVjaWZpZWQsIHdpdGggdGhlIHZlcnkgZmlyc3RcclxuICogdHlwZWQgZW52ZWxvcGUgYmVpbmcgJ2xlZ2FjeScgYW5kIGRlc2NyaWJpbmcgdGhlIHNoYXBlIG9mIHRoZSBiYXNlXHJcbiAqIHRyYW5zYWN0aW9uIHBhcmFtcyB0aGF0IHdlcmUgaGl0aGVydG8gdGhlIG9ubHkgdHJhbnNhY3Rpb24gdHlwZSBzZW50IG9uXHJcbiAqIEV0aGVyZXVtLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gVHJhbnNhY3Rpb25FbnZlbG9wZVR5cGUge1xyXG4gIC8qKlxyXG4gICAqIEEgbGVnYWN5IHRyYW5zYWN0aW9uLCB0aGUgdmVyeSBmaXJzdCB0eXBlLlxyXG4gICAqL1xyXG4gIGxlZ2FjeSA9ICcweDAnLFxyXG4gIC8qKlxyXG4gICAqIEVJUC0yOTMwIGRlZmluZWQgdGhlIGFjY2VzcyBsaXN0IHRyYW5zYWN0aW9uIHR5cGUgdGhhdCBhbGxvd2VkIGZvclxyXG4gICAqIHNwZWNpZnlpbmcgdGhlIHN0YXRlIHRoYXQgYSB0cmFuc2FjdGlvbiB3b3VsZCBhY3QgdXBvbiBpbiBhZHZhbmNlIGFuZFxyXG4gICAqIHRoZW9yZXRpY2FsbHkgc2F2ZSBvbiBnYXMgZmVlcy5cclxuICAgKi9cclxuICBhY2Nlc3NMaXN0ID0gJzB4MScsXHJcbiAgLyoqXHJcbiAgICogVGhlIHR5cGUgaW50cm9kdWNlZCBjb21lcyBmcm9tIEVJUC0xNTU5LCBGZWUgTWFya2V0IGRlc2NyaWJlcyB0aGUgYWRkaXRpb25cclxuICAgKiBvZiBhIGJhc2VGZWUgdG8gYmxvY2tzIHRoYXQgd2lsbCBiZSBidXJuZWQgaW5zdGVhZCBvZiBkaXN0cmlidXRlZCB0b1xyXG4gICAqIG1pbmVycy4gVHJhbnNhY3Rpb25zIG9mIHRoaXMgdHlwZSBoYXZlIGJvdGggYSBtYXhGZWVQZXJHYXMgKG1heGltdW0gdG90YWxcclxuICAgKiBhbW91bnQgaW4gZ3dlaSBwZXIgZ2FzIHRvIHNwZW5kIG9uIHRoZSB0cmFuc2FjdGlvbikgd2hpY2ggaXMgaW5jbHVzaXZlIG9mXHJcbiAgICogdGhlIG1heFByaW9yaXR5RmVlUGVyR2FzIChtYXhpbXVtIGFtb3VudCBvZiBnd2VpIHBlciBnYXMgZnJvbSB0aGVcclxuICAgKiB0cmFuc2FjdGlvbiBmZWUgdG8gZGlzdHJpYnV0ZSB0byBtaW5lcikuXHJcbiAgICovXHJcbiAgZmVlTWFya2V0ID0gJzB4MicsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2FjdGlvbiBTdGF0dXMgaXMgYSBtaXggb2YgRXRoZXJldW0gYW5kIE1ldGFNYXNrIHRlcm1pbm9sb2d5LCB1c2VkIGludGVybmFsbHlcclxuICogZm9yIHRyYW5zYWN0aW9uIHByb2Nlc3NpbmcuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvblN0YXR1cyB7XHJcbiAgLyoqXHJcbiAgICogQSBuZXcgdHJhbnNhY3Rpb24gdGhhdCB0aGUgdXNlciBoYXMgbm90IGFwcHJvdmVkIG9yIHJlamVjdGVkXHJcbiAgICovXHJcbiAgdW5hcHByb3ZlZCA9ICd1bmFwcHJvdmVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdXNlciBoYXMgYXBwcm92ZWQgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBNZXRhTWFzayBVSVxyXG4gICAqL1xyXG4gIGFwcHJvdmVkID0gJ2FwcHJvdmVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdXNlciBoYXMgcmVqZWN0ZWQgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBNZXRhTWFzayBVSVxyXG4gICAqL1xyXG4gIHJlamVjdGVkID0gJ3JlamVjdGVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkXHJcbiAgICovXHJcbiAgc2lnbmVkID0gJ3NpZ25lZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHN1Ym1pdHRlZCB0byBuZXR3b3JrXHJcbiAgICovXHJcbiAgc3VibWl0dGVkID0gJ3N1Ym1pdHRlZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIGhhcyBmYWlsZWQgZm9yIHNvbWUgcmVhc29uXHJcbiAgICovXHJcbiAgZmFpbGVkID0gJ2ZhaWxlZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIHdhcyBkcm9wcGVkIGR1ZSB0byBhIHR4IHdpdGggc2FtZSBub25jZSBiZWluZyBhY2NlcHRlZFxyXG4gICAqL1xyXG4gIGRyb3BwZWQgPSAnZHJvcHBlZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgYnkgdGhlIG5ldHdvcmtcclxuICAgKi9cclxuICBjb25maXJtZWQgPSAnY29uZmlybWVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkIGFuZCBpcyB3YWl0aW5nIHRvIGVpdGhlciBiZSBjb25maXJtZWQsXHJcbiAgICogZHJvcHBlZCBvciBmYWlsZWQuIFRoaXMgaXMgYSBcImZha2VcIiBzdGF0dXMgdGhhdCB3ZSB1c2UgdG8gZ3JvdXAgc3RhdHVzZXNcclxuICAgKiB0aGF0IGFyZSB2ZXJ5IHNpbWlsYXIgZnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlIChhcHByb3ZlZCxcclxuICAgKiBzaWduZWQsIHN1Ym1pdHRlZCkuIFRoZSBvbmx5IG5vdGFibGUgY2FzZSB3aGVyZSBhcHByb3ZlIGFuZCBzaWduZWQgYXJlXHJcbiAgICogZGlmZmVyZW50IGZyb20gdXNlciBwZXJzcGVjdGl2ZSBpcyBpbiBoYXJkd2FyZSB3YWxsZXRzIHdoZXJlIHRoZVxyXG4gICAqIHRyYW5zYWN0aW9uIGlzIHNpZ25lZCBvbiBhbiBleHRlcm5hbCBkZXZpY2UuIE90aGVyd2lzZSBzaWduaW5nIGhhcHBlbnNcclxuICAgKiB0cmFuc3BhcmVudGx5IHRvIHVzZXJzLlxyXG4gICAqL1xyXG4gIHBlbmRpbmcgPSAncGVuZGluZycsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXaXRoIHRoaXMgbGlzdCB3ZSBjYW4gZGV0ZWN0IGlmIGEgdHJhbnNhY3Rpb24gaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSU5fUFJPR1JFU1NfVFJBTlNBQ1RJT05fU1RBVFVTRVMgPSBbXHJcbiAgVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCxcclxuICBUcmFuc2FjdGlvblN0YXR1cy5hcHByb3ZlZCxcclxuICBUcmFuc2FjdGlvblN0YXR1cy5zaWduZWQsXHJcbiAgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkLFxyXG4gIFRyYW5zYWN0aW9uU3RhdHVzLnBlbmRpbmcsXHJcbl07XHJcblxyXG4vKipcclxuICogVHJhbnNhY3Rpb24gR3JvdXAgU3RhdHVzIGlzIGEgTWV0YU1hc2sgY29uc3RydWN0IHRvIHRyYWNrIHRoZSBzdGF0dXMgb2YgZ3JvdXBzXHJcbiAqIG9mIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uR3JvdXBTdGF0dXMge1xyXG4gIC8qKlxyXG4gICAqIEEgY2FuY2VsIHR5cGUgdHJhbnNhY3Rpb24gaW4gdGhlIGdyb3VwIHdhcyBjb25maXJtZWRcclxuICAgKi9cclxuICBjYW5jZWxsZWQgPSAnY2FuY2VsbGVkJyxcclxuICAvKipcclxuICAgKiBUaGUgcHJpbWFyeVRyYW5zYWN0aW9uIG9mIHRoZSBncm91cCBoYXMgYSBzdGF0dXMgdGhhdCBpcyBvbmUgb2ZcclxuICAgKiBUcmFuc2FjdGlvblN0YXR1cy5hcHByb3ZlZCwgVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCBvclxyXG4gICAqIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZFxyXG4gICAqL1xyXG4gIHBlbmRpbmcgPSAncGVuZGluZycsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGF0dXNlcyB0aGF0IGFyZSBzcGVjaWZpYyB0byBTbWFydCBUcmFuc2FjdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBTbWFydFRyYW5zYWN0aW9uU3RhdHVzIHtcclxuICAvKiogSXQgY2FuIGJlIGNhbmNlbGxlZCBmb3IgdmFyaW91cyByZWFzb25zLiAqL1xyXG4gIGNhbmNlbGxlZCA9ICdjYW5jZWxsZWQnLFxyXG4gIC8qKiBTbWFydCB0cmFuc2FjdGlvbiBpcyBiZWluZyBwcm9jZXNzZWQuICovXHJcbiAgcGVuZGluZyA9ICdwZW5kaW5nJyxcclxuICAvKiogU21hcnQgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBtaW5lZC4gKi9cclxuICBzdWNjZXNzID0gJ3N1Y2Nlc3MnLFxyXG59XHJcblxyXG4vKipcclxuICogVHlwZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhlIHRyYW5zYWN0aW9uIGFwcHJvdmFsIGFtb3VudC5cclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uQXBwcm92YWxBbW91bnRUeXBlIHtcclxuICAvKiogVGhlIHVzZXIgaGFzIGVkaXRlZCB0aGUgdG9rZW4gYW1vdW50LiAqL1xyXG4gIGN1c3RvbSA9ICdjdXN0b20nLFxyXG4gIC8qKiBUaGUgc2VsZWN0ZWQgYW1vdW50IChlaXRoZXIgY3VzdG9tIG9yIGRhcHBQcm9wb3NlZCkgaXMgMC4gKi9cclxuICByZXZva2UgPSAncmV2b2tlJyxcclxuICAvKiogVGhlIGRhcHAgcHJvcG9zZWQgdG9rZW4gYW1vdW50LiAqL1xyXG4gIGRhcHBQcm9wb3NlZCA9ICdkYXBwX3Byb3Bvc2VkJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYW5zYWN0aW9uIEdyb3VwIENhdGVnb3J5IGlzIGEgTWV0YU1hc2sgY29uc3RydWN0IHRvIGNhdGVnb3JpemUgdGhlIGludGVudFxyXG4gKiBvZiBhIGdyb3VwIG9mIHRyYW5zYWN0aW9ucyBmb3IgcHVycG9zZXMgb2YgZGlzcGxheWluZyBpbiB0aGUgVUlcclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uR3JvdXBDYXRlZ29yeSB7XHJcbiAgLyoqXHJcbiAgICogVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGEgcmVxdWVzdCBmb3IgYW4gYWxsb3dhbmNlIG9mIGEgdG9rZW4gdG9cclxuICAgKiBzcGVuZCBvbiB0aGUgdXNlcidzIGJlaGFsZi5cclxuICAgKi9cclxuICBhcHByb3ZhbCA9ICdhcHByb3ZhbCcsXHJcbiAgLyoqXHJcbiAgICogVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGFuIGludGVyYWN0aW9uIHdpdGggYSBzbWFydCBjb250cmFjdCdzIG1ldGhvZHMuXHJcbiAgICovXHJcbiAgaW50ZXJhY3Rpb24gPSAnaW50ZXJhY3Rpb24nLFxyXG4gIC8qKlxyXG4gICAqIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBhIGRlcG9zaXQvaW5jb21pbmcgdHJhbnNhY3Rpb24uIFRoaXNcclxuICAgKiBjYXRlZ29yeSBtYXBzIDE6MSB3aXRoIFRyYW5zYWN0aW9uVHlwZS5pbmNvbWluZy5cclxuICAgKi9cclxuICByZWNlaXZlID0gJ3JlY2VpdmUnLFxyXG4gIC8qKlxyXG4gICAqIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyB0aGUgbmV0d29yayBuYXRpdmUgY3VycmVuY3kgYmVpbmcgc2VudCBmcm9tXHJcbiAgICogdGhlIHVzZXIuXHJcbiAgICovXHJcbiAgc2VuZCA9ICdzZW5kJyxcclxuICAvKipcclxuICAgKiBUcmFuc2FjdGlvbiBncm91cCByZXByZXNlbnRpbmcgYSBzaWduYXR1cmUgcmVxdWVzdCBUaGlzIGN1cnJlbnRseSBvbmx5XHJcbiAgICogc2hvd3MgdXAgaW4gdGhlIFVJIHdoZW4gaXRzIHBlbmRpbmcgdXNlciBhcHByb3ZhbCBpbiB0aGUgVUkuIE9uY2UgdGhlIHVzZXJcclxuICAgKiBhcHByb3ZlcyBvciByZWplY3RzIGl0IHdpbGwgbm8gbG9uZ2VyIHNob3cgaW4gYWN0aXZpdHkuXHJcbiAgICovXHJcbiAgc2lnbmF0dXJlUmVxdWVzdCA9ICdzaWduYXR1cmUtcmVxdWVzdCcsXHJcbiAgLyoqXHJcbiAgICogVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGEgdG9rZW4gc3dhcCB0aHJvdWdoIE1ldGFNYXNrIFN3YXBzLiBUaGlzXHJcbiAgICogdHJhbnNhY3Rpb24gZ3JvdXAncyBwcmltYXJ5IGN1cnJlbmN5IGNoYW5nZXMgZGVwZW5kaW5nIG9uIGNvbnRleHQuIElmIHRoZVxyXG4gICAqIHVzZXIgaXMgdmlld2luZyBhbiBhc3NldCBwYWdlIGZvciBhIHRva2VuIHJlY2VpdmVkIGZyb20gYSBzd2FwLCB0aGVcclxuICAgKiBwcmltYXJ5IGN1cnJlbmN5IHdpbGwgYmUgdGhlIHJlY2VpdmVkIHRva2VuLiBPdGhlcndpc2UgdGhlIHRva2VuIGV4Y2hhbmdlZFxyXG4gICAqIHdpbGwgYmUgc2hvd24uXHJcbiAgICovXHJcbiAgc3dhcCA9ICdzd2FwJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgcGFyYW1ldGVycyBvZiBhIHRyYW5zYWN0aW9uIHRvIHN1Ym1pdCB0byB0aGUgbmV0d29ya1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUeFBhcmFtcyB7XHJcbiAgLyoqIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiBpcyBzZW50IGZyb20gKi9cclxuICBmcm9tOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiBpcyBzZW50IHRvICovXHJcbiAgdG86IHN0cmluZztcclxuICAvKiogVGhlIGFtb3VudCBvZiB3ZWksIGluIGhleGFkZWNpbWFsLCB0byBzZW5kICovXHJcbiAgdmFsdWU6IHN0cmluZztcclxuICAvKiogVGhlIHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGUgY3VycmVudCBhY2NvdW50L25ldHdvcmsgKi9cclxuICBub25jZTogbnVtYmVyO1xyXG4gIC8qKiBUaGUgYW1vdW50IG9mIGd3ZWksIGluIGhleGFkZWNpbWFsLCBwZXIgdW5pdCBvZiBnYXMgKi9cclxuICBnYXNQcmljZT86IHN0cmluZztcclxuICAvKiogVGhlIG1heCBhbW91bnQgb2YgZ3dlaSwgaW4gaGV4YWRlY2ltYWwsIHRoZSB1c2VyIGlzIHdpbGxpbmcgdG8gcGF5ICovXHJcbiAgZ2FzOiBzdHJpbmc7XHJcbiAgLyoqIEhleGFkZWNpbWFsIGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyBjYWxscyB0byB0aGUgRVZNJ3MgQUJJICovXHJcbiAgZGF0YT86IHN0cmluZztcclxuICAvKipcclxuICAgKiBFSVAtMjkzMCBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI5MzAgYWRkZWQgdGhlIGFiaWxpdHkgZm9yXHJcbiAgICogdHJhbnNhY3Rpb25zIHRvIHNwZWNpZnkgd2hpY2ggYWRkcmVzc2VzIHRoZXkgd2lsbCBpbnRlcmFjdCB3aXRoIGFuZCBhbGxvd3NcclxuICAgKiBmb3IgbG93ZXIgZ2FzIGZlZXMgb24gc3BlY2lmaWMgb3Bjb2Rlcy4gU2VlIHRoZSBFSVAgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgKi9cclxuICBhY2Nlc3NMaXN0PzogQWNjZXNzTGlzdDtcclxuICBtYXhGZWVQZXJHYXM/OiBzdHJpbmc7XHJcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHhSZWNlaXB0IHtcclxuICBibG9ja0hhc2g/OiBzdHJpbmc7XHJcbiAgYmxvY2tOdW1iZXI/OiBzdHJpbmc7XHJcbiAgdHJhbnNhY3Rpb25JbmRleD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUeEVycm9yIHtcclxuICAvKiogVGhlIG1lc3NhZ2UgZnJvbSB0aGUgZW5jb3VudGVyZWQgZXJyb3IuICovXHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgXCJ2YWx1ZVwiIG9mIHRoZSBlcnJvci4gKi9cclxuICBycGM6IGFueTtcclxuICAvKiogdGhlIHN0YWNrIHRyYWNlIGZyb20gdGhlIGVycm9yLCBpZiBhdmFpbGFibGUuICovXHJcbiAgc3RhY2s/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXZSBhdHRhY2ggYW4gb2JqZWN0IHRvIHRyYW5zYWN0aW9ucyBwcm9wb3NlZCBieSBkYXBwcyB0byBzaG93IHRoZSB2YWx1ZXNcclxuICogdGhhdCB0aGUgZGFwcCBzdWdnZXN0ZWQgZm9yIGdhcyBmZWVzLiBUaGlzIGlzIHVzZWQgdG8gY29tcGFyZSB0byB3aGF0IG91clxyXG4gKiBpbnRlcm5hbCBnYXMgcHJpY2UgbG9naWMgd291bGQgaGF2ZSB0aGUgdHJhbnNhY3Rpb24gcHJpY2VkIGF0IGZvciBtZXRyaWNzXHJcbiAqIHdpdGggdGhlIGFpbSBvZiBpbXByb3Zpbmcgb3VyIHN1Z2dlc3Rpb25zIGFzIHdlbGwgYXMgZ2l2aW5nIHRoZSB1c2VyIHRoZVxyXG4gKiBvcHRpb24gdG8gcmV0dXJuIHRvIHRoZSBkZWZhdWx0cyBzdWdnZXN0ZWQgYnkgdGhlIGRhcHAgaWYgdGhleSBoYXZlIGVkaXRlZFxyXG4gKiB0aGUgZ2FzIGZlZXMgb24gdGhlIGNvbmZpcm1hdGlvbiBzY3JlZW4uXHJcbiAqL1xyXG5pbnRlcmZhY2UgRGFwcFN1Z2dlc3RlZEdhc0ZlZXMge1xyXG4gIGdhc1ByaWNlPzogc3RyaW5nO1xyXG4gIG1heEZlZVBlckdhcz86IHN0cmluZztcclxuICBtYXhQcmlvcml0eUZlZVBlckdhcz86IHN0cmluZztcclxuICBnYXM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHJhbnNhY3Rpb24sIGluIHdoYXRldmVyIHN0YXRlIGl0IGlzIGluLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbk1ldGEge1xyXG5cbiAgLyoqXHJcbiAgICogVGhlIGJsb2NrIG51bWJlciB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi4gQ3VycmVudGx5IG9ubHkgcHJlc2VudFxyXG4gICAqIG9uIGluY29taW5nIHRyYW5zYWN0aW9ucyFcclxuICAgKi9cclxuICBibG9ja051bWJlcj86IHN0cmluZztcclxuICAvKiogQW4gaW50ZXJuYWxseSB1bmlxdWUgdHggaWRlbnRpZmllci4gKi9cclxuICBpZDogbnVtYmVyO1xyXG4gIC8qKiBUaW1lIHRoZSB0cmFuc2FjdGlvbiB3YXMgZmlyc3Qgc3VnZ2VzdGVkLCBpbiB1bml4IGVwb2NoIHRpbWUgKG1zKS4gKi9cclxuICB0aW1lOiBudW1iZXI7XHJcbiAgLyoqIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhIG5hbWUgb2YgdHJhbnNhY3Rpb24gY29udHJhY3QgbWV0aG9kLiAqL1xyXG4gIGNvbnRyYWN0TWV0aG9kTmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgY3VzdG9tIHRva2VuIGFtb3VudCBpcyB0aGUgYW1vdW50IHNldCBieSB0aGUgdXNlciAqL1xyXG4gIGN1c3RvbVRva2VuQW1vdW50OiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBkYXBwIHByb3Bvc2VkIHRva2VuIGFtb3VudCAqL1xyXG4gIGRhcHBQcm9wb3NlZFRva2VuQW1vdW50OiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBvcmlnaW5hbCBnYXMgZmVlcyBzdWdnZXN0ZWQgYnkgdGhlIGRhcHAgdGhhdCBwcm9wb3NlZCB0aGlzIHRyYW5zYWN0aW9uICovXHJcbiAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXM/OiBEYXBwU3VnZ2VzdGVkR2FzRmVlcztcclxuICAvKiogVGhlIGJhbGFuY2Ugb2YgdGhlIHRva2VuIHRoYXQgaXMgYmVpbmcgc2VudCAqL1xyXG4gIGN1cnJlbnRUb2tlbkJhbGFuY2U6IHN0cmluZztcclxuICAvKiogVGhlIG9yaWdpbmFsIGRhcHAgcHJvcG9zZWQgdG9rZW4gYXBwcm92YWwgYW1vdW50IGJlZm9yZSBlZGl0IGJ5IHVzZXIgKi9cclxuICBvcmlnaW5hbEFwcHJvdmFsQW1vdW50OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGNob3NlbiBhbW91bnQgd2hpY2ggd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luYWxseSBwcm9wb3NlZCB0b2tlblxyXG4gICAqIGFtb3VudCBpZiB0aGUgdXNlciBkb2VzIG5vdCBlZGl0IHRoZSAgYW1vdW50IG9yIHdpbGwgYmUgYSBjdXN0b20gdG9rZW5cclxuICAgKiBhbW91bnQgc2V0IGJ5IHRoZSB1c2VyXHJcbiAgICovXHJcbiAgZmluYWxBcHByb3ZhbEFtb3VudDogc3RyaW5nO1xyXG4gIC8qKiBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvbiB0aGlzIHR4TWV0YSByZXByZXNlbnRzLiAqL1xyXG4gIHR5cGU6IFRyYW5zYWN0aW9uVHlwZTtcclxuICAvKipcclxuICAgKiBXaGVuIHdlIHNwZWVkIHVwIGEgdHJhbnNhY3Rpb24sIHdlIHNldCB0aGUgdHlwZSBhcyBSZXRyeSBhbmQgd2UgbG9zZVxyXG4gICAqIGluZm9ybWF0aW9uIGFib3V0IHR5cGUgb2YgdHJhbnNhY3Rpb24gdGhhdCBpcyBiZWluZyBzZXQgdXAsIHNvIHdlIHVzZVxyXG4gICAqIG9yaWdpbmFsIHR5cGUgdG8gdHJhY2sgdGhhdCBpbmZvcm1hdGlvbi5cclxuICAgKi9cclxuICBvcmlnaW5hbFR5cGU6IFRyYW5zYWN0aW9uVHlwZTtcclxuICAvKiogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSB0cmFuc2FjdGlvbi4gKi9cclxuICBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzO1xyXG4gIC8qKiBUaGUgdHJhbnNhY3Rpb24ncyBuZXR3b3JrIElELCB1c2VkIGZvciBFSVAtMTU1IGNvbXBsaWFuY2UuICovXHJcbiAgbWV0YW1hc2tOZXR3b3JrSWQ6IHN0cmluZztcclxuICAvKiogVE9ETzogRmluZCBvdXQgd2hhdCB0aGlzIGlzIGFuZCBkb2N1bWVudCBpdCAqL1xyXG4gIGxvYWRpbmdEZWZhdWx0czogYm9vbGVhbjtcclxuICAvKiogVGhlIHRyYW5zYWN0aW9uIHBhcmFtcyBhcyBwYXNzZWQgdG8gdGhlIG5ldHdvcmsgcHJvdmlkZXIuICovXHJcbiAgdHhQYXJhbXM6IFR4UGFyYW1zO1xyXG4gIHR4UmVjZWlwdDogVHhSZWNlaXB0O1xyXG4gIC8qKiBBIGhpc3Rvcnkgb2YgbXV0YXRpb25zIHRvIHRoaXMgVHJhbnNhY3Rpb25NZXRhIG9iamVjdC4gKi9cclxuICBoaXN0b3J5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+W107XHJcbiAgLyoqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaW50ZXJmYWNlIHRoYXQgc3VnZ2VzdGVkIHRoZSB0cmFuc2FjdGlvbi4gKi9cclxuICBvcmlnaW46IHN0cmluZztcclxuICAvKipcclxuICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yaWdpbmFsIGdhcyBlc3RpbWF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvblxyXG4gICAqIG1ldGFkYXRhLlxyXG4gICAqL1xyXG4gIG9yaWdpbmFsR2FzRXN0aW1hdGU6IHN0cmluZztcclxuICAvKiogQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGVuIHRoZSB1c2VyIG1hbnVhbGx5IGVkaXRlZCB0aGUgZ2FzIGxpbWl0LiAqL1xyXG4gIHVzZXJFZGl0ZWRHYXNMaW1pdDogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBBIG1ldGFkYXRhIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIHVzZWQgdG8gZGVyaXZlIHRoZSBzdWdnZXN0ZWRcclxuICAgKiBub25jZSwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgbm9uY2UgaXNzdWVzLlxyXG4gICAqL1xyXG4gIG5vbmNlRGV0YWlsczogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICAvKipcclxuICAgKiBBIGhleCBzdHJpbmcgb2YgdGhlIGZpbmFsIHNpZ25lZCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gc3VibWl0IHRvIHRoZVxyXG4gICAqIG5ldHdvcmsuXHJcbiAgICovXHJcbiAgcmF3VHg6IHN0cmluZztcclxuICAvKipcclxuICAgKiBBIGhleCBzdHJpbmcgb2YgdGhlIHRyYW5zYWN0aW9uIGhhc2gsIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICogb24gdGhlIG5ldHdvcmsuXHJcbiAgICovXHJcbiAgaGFzaDogc3RyaW5nO1xyXG4gIHY/OiBzdHJpbmc7XHJcbiAgcj86IHN0cmluZztcclxuICBzPzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSB0aW1lIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VibWl0dGVkIHRvIHRoZSBuZXR3b3JrLCBpbiBVbml4IGVwb2NoIHRpbWVcclxuICAgKiAobXMpLlxyXG4gICAqL1xyXG4gIHN1Ym1pdHRlZFRpbWU/OiBudW1iZXI7XHJcbiAgLyoqIFRoZSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uICovXHJcbiAgdHhFcnI/OiBUeEVycm9yO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lcyB0aGUgcG9zc2libGUgdHlwZXNcclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uTWV0YU1ldHJpY3NFdmVudCB7XHJcbiAgLyoqXHJcbiAgICogQWxsIHRyYW5zYWN0aW9ucywgZXhjZXB0IGluY29taW5nIG9uZXMsIGFyZSBhZGRlZCB0byB0aGUgY29udHJvbGxlciBzdGF0ZVxyXG4gICAqIGluIGFuIHVuYXBwcm92ZWQgc3RhdHVzLiBXaGVuIHRoaXMgaGFwcGVucyB3ZSBmaXJlIHRoZSBUcmFuc2FjdGlvbiBBZGRlZFxyXG4gICAqIGV2ZW50IHRvIHNob3cgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHVzZXIncyBNZXRhTWFzay5cclxuICAgKi9cclxuICBhZGRlZCA9ICdUcmFuc2FjdGlvbiBBZGRlZCcsXHJcbiAgLyoqXHJcbiAgICogV2hlbiBhbiB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uIGlzIGluIHRoZSBjb250cm9sbGVyIHN0YXRlLCBNZXRhTWFzayB3aWxsXHJcbiAgICogcmVuZGVyIGEgY29uZmlybWF0aW9uIHNjcmVlbiBmb3IgdGhhdCB0cmFuc2FjdGlvbi4gSWYgdGhlIHVzZXIgYXBwcm92ZXNcclxuICAgKiB0aGUgdHJhbnNhY3Rpb24gd2UgZmlyZSB0aGlzIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZXIgaGFzIGFwcHJvdmVkXHJcbiAgICogdGhlIHRyYW5zYWN0aW9uIGZvciBzdWJtaXNzaW9uIHRvIHRoZSBuZXR3b3JrLlxyXG4gICAqL1xyXG4gIGFwcHJvdmVkID0gJ1RyYW5zYWN0aW9uIEFwcHJvdmVkJyxcclxuICAvKipcclxuICAgKiBBbGwgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIHN1Ym1pdHRlZCB3aWxsIGZpbmFsaXplZCAoZXZlbnR1YWxseSkgYnkgZWl0aGVyXHJcbiAgICogYmVpbmcgZHJvcHBlZCwgZmFpbGluZyBvciBiZWluZyBjb25maXJtZWQuIFdoZW4gdGhpcyBoYXBwZW5zIHdlIHRyYWNrIHRoaXNcclxuICAgKiBldmVudCwgYWxvbmcgd2l0aCB0aGUgc3RhdHVzLlxyXG4gICAqL1xyXG4gIGZpbmFsaXplZCA9ICdUcmFuc2FjdGlvbiBGaW5hbGl6ZWQnLFxyXG4gIC8qKlxyXG4gICAqIFdoZW4gYW4gdW5hcHByb3ZlZCB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgY29udHJvbGxlciBzdGF0ZSwgTWV0YU1hc2sgd2lsbFxyXG4gICAqIHJlbmRlciBhIGNvbmZpcm1hdGlvbiBzY3JlZW4gZm9yIHRoYXQgdHJhbnNhY3Rpb24uIElmIHRoZSB1c2VyIHJlamVjdHMgdGhlXHJcbiAgICogdHJhbnNhY3Rpb24gd2UgZmlyZSB0aGlzIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZXIgaGFzIHJlamVjdGVkIHRoZVxyXG4gICAqIHRyYW5zYWN0aW9uLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBzdGF0ZSBhcyBhIHJlc3VsdC5cclxuICAgKi9cclxuICByZWplY3RlZCA9ICdUcmFuc2FjdGlvbiBSZWplY3RlZCcsXHJcbiAgLyoqXHJcbiAgICogQWZ0ZXIgYSB0cmFuc2FjdGlvbiBpcyBhcHByb3ZlZCBieSB0aGUgdXNlciwgaXQgaXMgdGhlbiBzdWJtaXR0ZWQgdG8gdGhlXHJcbiAgICogbmV0d29yayBmb3IgaW5jbHVzaW9uIGluIGEgYmxvY2suIFdoZW4gdGhpcyBoYXBwZW5zIHdlIGZpcmUgdGhlXHJcbiAgICogVHJhbnNhY3Rpb24gU3VibWl0dGVkIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgTWV0YU1hc2sgaXMgc3VibWl0dGluZyBhXHJcbiAgICogdHJhbnNhY3Rpb24gYXQgdGhlIHVzZXIncyByZXF1ZXN0LlxyXG4gICAqL1xyXG4gIHN1Ym1pdHRlZCA9ICdUcmFuc2FjdGlvbiBTdWJtaXR0ZWQnLFxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHR5cGVzIG9mIGFzc2V0cyB0aGF0IGEgdXNlciBjYW4gc2VuZFxyXG4gKlxyXG4gKiBAdHlwZSB7QXNzZXRUeXBlc31cclxuICovXHJcbmV4cG9ydCBlbnVtIEFzc2V0VHlwZSB7XHJcbiAgLyoqIFRoZSBuYXRpdmUgYXNzZXQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmssIHN1Y2ggYXMgRVRIICovXHJcbiAgbmF0aXZlID0gJ05BVElWRScsXHJcbiAgLyoqIEFuIEVSQzIwIHRva2VuICovXHJcbiAgdG9rZW4gPSAnVE9LRU4nLFxyXG4gIC8qKiBBbiBFUkM3MjEgb3IgRVJDMTE1NSB0b2tlbi4gKi9cclxuICBORlQgPSAnTkZUJyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIGludGVyYWN0aW5nIHdpdGggYSBjb250cmFjdCB0aGF0IGlzbid0IGEgdG9rZW4gbWV0aG9kXHJcbiAgICogaW50ZXJhY3Rpb24gd2lsbCBiZSBtYXJrZWQgYXMgZGVhbGluZyB3aXRoIGFuIHVua25vd24gYXNzZXQgdHlwZS5cclxuICAgKi9cclxuICB1bmtub3duID0gJ1VOS05PV04nLFxyXG59XHJcblxyXG4vKipcclxuICogRGVzY3JpYmVzIHRoZSBzdGFuZGFyZCB3aGljaCBhIHRva2VuIGNvbmZvcm1zIHRvLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gVG9rZW5TdGFuZGFyZCB7XHJcbiAgLyoqIEEgdG9rZW4gdGhhdCBjb25mb3JtcyB0byB0aGUgRVJDMjAgc3RhbmRhcmQuICovXHJcbiAgRVJDMjAgPSAnRVJDMjAnLFxyXG4gIC8qKiBBIHRva2VuIHRoYXQgY29uZm9ybXMgdG8gdGhlIEVSQzcyMSBzdGFuZGFyZC4gKi9cclxuICBFUkM3MjEgPSAnRVJDNzIxJyxcclxuICAvKiogQSB0b2tlbiB0aGF0IGNvbmZvcm1zIHRvIHRoZSBFUkMxMTU1IHN0YW5kYXJkLiAqL1xyXG4gIEVSQzExNTUgPSAnRVJDMTE1NScsXHJcbiAgLyoqIE5vdCBhIHRva2VuLCBidXQgcmF0aGVyIHRoZSBiYXNlIGFzc2V0IG9mIHRoZSBzZWxlY3RlZCBjaGFpbi4gKi9cclxuICBub25lID0gJ05PTkUnLFxyXG59XHJcbiIsImltcG9ydCB7IE1JTlVURSwgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xyXG5pbXBvcnQgZ2V0RmV0Y2hXaXRoVGltZW91dCBmcm9tICcuLi9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XHJcbmltcG9ydCB7IGdldFN0b3JhZ2VJdGVtLCBzZXRTdG9yYWdlSXRlbSB9IGZyb20gJy4vc3RvcmFnZS1oZWxwZXJzJztcclxuXHJcbmNvbnN0IGZldGNoV2l0aENhY2hlID0gYXN5bmMgKFxyXG4gIHVybCxcclxuICBmZXRjaE9wdGlvbnMgPSB7fSxcclxuICB7IGNhY2hlUmVmcmVzaFRpbWUgPSBNSU5VVEUgKiA2LCB0aW1lb3V0ID0gU0VDT05EICogMzAgfSA9IHt9LFxyXG4pID0+IHtcclxuICBpZiAoXHJcbiAgICBmZXRjaE9wdGlvbnMuYm9keSB8fFxyXG4gICAgKGZldGNoT3B0aW9ucy5tZXRob2QgJiYgZmV0Y2hPcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcpXHJcbiAgKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoV2l0aENhY2hlIG9ubHkgc3VwcG9ydHMgR0VUIHJlcXVlc3RzJyk7XHJcbiAgfVxyXG4gIGlmICghKGZldGNoT3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2Ygd2luZG93LkhlYWRlcnMpKSB7XHJcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyB3aW5kb3cuSGVhZGVycyhmZXRjaE9wdGlvbnMuaGVhZGVycyk7XHJcbiAgfVxyXG4gIGlmIChcclxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykgJiZcclxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT09ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaFdpdGhDYWNoZSBvbmx5IHN1cHBvcnRzIEpTT04gcmVzcG9uc2VzJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XHJcbiAgY29uc3QgY2FjaGVLZXkgPSBgY2FjaGVkRmV0Y2g6JHt1cmx9YDtcclxuICBjb25zdCB7IGNhY2hlZFJlc3BvbnNlLCBjYWNoZWRUaW1lIH0gPSAoYXdhaXQgZ2V0U3RvcmFnZUl0ZW0oY2FjaGVLZXkpKSB8fCB7fTtcclxuICBpZiAoY2FjaGVkUmVzcG9uc2UgJiYgY3VycmVudFRpbWUgLSBjYWNoZWRUaW1lIDwgY2FjaGVSZWZyZXNoVGltZSkge1xyXG4gICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xyXG4gIH1cclxuICBmZXRjaE9wdGlvbnMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XHJcbiAgY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQodGltZW91dCk7XHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KHVybCwge1xyXG4gICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXHJcbiAgICBib2R5OiBudWxsLFxyXG4gICAgbWV0aG9kOiAnR0VUJyxcclxuICAgIG1vZGU6ICdjb3JzJyxcclxuICAgIC4uLmZldGNoT3B0aW9ucyxcclxuICB9KTtcclxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBGZXRjaCBmYWlsZWQgd2l0aCBzdGF0dXMgJyR7cmVzcG9uc2Uuc3RhdHVzfSc6ICcke3Jlc3BvbnNlLnN0YXR1c1RleHR9J2AsXHJcbiAgICApO1xyXG4gIH1cclxuICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgY29uc3QgY2FjaGVFbnRyeSA9IHtcclxuICAgIGNhY2hlZFJlc3BvbnNlOiByZXNwb25zZUpzb24sXHJcbiAgICBjYWNoZWRUaW1lOiBjdXJyZW50VGltZSxcclxuICB9O1xyXG5cclxuICBhd2FpdCBzZXRTdG9yYWdlSXRlbShjYWNoZUtleSwgY2FjaGVFbnRyeSk7XHJcbiAgcmV0dXJuIHJlc3BvbnNlSnNvbjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZldGNoV2l0aENhY2hlO1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5WYWx1ZVBhcmFtKHRva2VuRGF0YSA9IHt9KSB7XHJcbiAgcmV0dXJuIHRva2VuRGF0YT8uYXJncz8uX3ZhbHVlPy50b1N0cmluZygpO1xyXG59XHJcbiIsImltcG9ydCBsb2NhbGZvcmFnZSBmcm9tICdsb2NhbGZvcmFnZSc7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZUl0ZW0oa2V5KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gYXdhaXQgbG9jYWxmb3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgaWYgKHNlcmlhbGl6ZWREYXRhID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VyaWFsaXplZERhdGEpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRTdG9yYWdlSXRlbShrZXksIHZhbHVlKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgYXdhaXQgbG9jYWxmb3JhZ2Uuc2V0SXRlbShrZXksIHNlcmlhbGl6ZWREYXRhKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUud2FybihlcnIpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgeyBDSEFJTl9JRFMgfSBmcm9tICcuLi9jb25zdGFudHMvbmV0d29yayc7XHJcbmltcG9ydCB7XHJcbiAgR0FTX0FQSV9CQVNFX1VSTCxcclxuICBHQVNfREVWX0FQSV9CQVNFX1VSTCxcclxuICBTV0FQU19BUElfVjJfQkFTRV9VUkwsXHJcbiAgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUCxcclxuICBTV0FQU19DTElFTlRfSUQsXHJcbiAgU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTCxcclxuICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVMsXHJcbn0gZnJvbSAnLi4vY29uc3RhbnRzL3N3YXBzJztcclxuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xyXG5pbXBvcnQgeyBpc1ZhbGlkSGV4QWRkcmVzcyB9IGZyb20gJy4uL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcclxuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uL21vZHVsZXMvc3RyaW5nLXV0aWxzJztcclxuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vYXBwL3NjcmlwdHMvbGliL3V0aWwnO1xyXG5pbXBvcnQgeyBkZWNpbWFsVG9IZXggfSBmcm9tICcuLi9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMnO1xyXG5pbXBvcnQgZmV0Y2hXaXRoQ2FjaGUgZnJvbSAnLi9mZXRjaC13aXRoLWNhY2hlJztcclxuXHJcbmNvbnN0IFRFU1RfQ0hBSU5fSURTID0gW0NIQUlOX0lEUy5HT0VSTEksIENIQUlOX0lEUy5MT0NBTEhPU1RdO1xyXG5cclxuY29uc3QgY2xpZW50SWRIZWFkZXIgPSB7ICdYLUNsaWVudC1JZCc6IFNXQVBTX0NMSUVOVF9JRCB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkSGV4ID0gKHN0cmluZykgPT4gQm9vbGVhbihzdHJpbmc/Lm1hdGNoKC9eMHhbYS1mMC05XSskL3UpKTtcclxuZXhwb3J0IGNvbnN0IHRydXRoeVN0cmluZyA9IChzdHJpbmcpID0+IEJvb2xlYW4oc3RyaW5nPy5sZW5ndGgpO1xyXG5leHBvcnQgY29uc3QgdHJ1dGh5RGlnaXRTdHJpbmcgPSAoc3RyaW5nKSA9PlxyXG4gIHRydXRoeVN0cmluZyhzdHJpbmcpICYmIEJvb2xlYW4oc3RyaW5nLm1hdGNoKC9eXFxkKyQvdSkpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRGF0YSh2YWxpZGF0b3JzLCBvYmplY3QsIHVybFVzZWQsIGxvZ0Vycm9yID0gdHJ1ZSkge1xyXG4gIHJldHVybiB2YWxpZGF0b3JzLmV2ZXJ5KCh7IHByb3BlcnR5LCB0eXBlLCB2YWxpZGF0b3IgfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KCd8Jyk7XHJcblxyXG4gICAgY29uc3QgdmFsaWQgPVxyXG4gICAgICB0eXBlcy5zb21lKChfdHlwZSkgPT4gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV0gPT09IF90eXBlKSAmJlxyXG4gICAgICAoIXZhbGlkYXRvciB8fCB2YWxpZGF0b3Iob2JqZWN0W3Byb3BlcnR5XSkpO1xyXG4gICAgaWYgKCF2YWxpZCAmJiBsb2dFcnJvcikge1xyXG4gICAgICBsb2cuZXJyb3IoXHJcbiAgICAgICAgYHJlc3BvbnNlIHRvIEdFVCAke3VybFVzZWR9IGludmFsaWQgZm9yIHByb3BlcnR5ICR7cHJvcGVydHl9OyB2YWx1ZSB3YXM6YCxcclxuICAgICAgICBvYmplY3RbcHJvcGVydHldLFxyXG4gICAgICAgICd8IHR5cGUgd2FzOiAnLFxyXG4gICAgICAgIHR5cGVvZiBvYmplY3RbcHJvcGVydHldLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgUVVPVEVfVkFMSURBVE9SUyA9IFtcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ3RyYWRlJyxcclxuICAgIHR5cGU6ICdvYmplY3QnLFxyXG4gICAgdmFsaWRhdG9yOiAodHJhZGUpID0+XHJcbiAgICAgIHRyYWRlICYmXHJcbiAgICAgIHZhbGlkSGV4KHRyYWRlLmRhdGEpICYmXHJcbiAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyYWRlLnRvLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pICYmXHJcbiAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyYWRlLmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkgJiZcclxuICAgICAgdHJ1dGh5U3RyaW5nKHRyYWRlLnZhbHVlKSxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnYXBwcm92YWxOZWVkZWQnLFxyXG4gICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICB2YWxpZGF0b3I6IChhcHByb3ZhbFR4KSA9PlxyXG4gICAgICBhcHByb3ZhbFR4ID09PSBudWxsIHx8XHJcbiAgICAgIChhcHByb3ZhbFR4ICYmXHJcbiAgICAgICAgdmFsaWRIZXgoYXBwcm92YWxUeC5kYXRhKSAmJlxyXG4gICAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKGFwcHJvdmFsVHgudG8sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkgJiZcclxuICAgICAgICBpc1ZhbGlkSGV4QWRkcmVzcyhhcHByb3ZhbFR4LmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkpLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdzb3VyY2VBbW91bnQnLFxyXG4gICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICB2YWxpZGF0b3I6IHRydXRoeURpZ2l0U3RyaW5nLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvbkFtb3VudCcsXHJcbiAgICB0eXBlOiAnc3RyaW5nJyxcclxuICAgIHZhbGlkYXRvcjogdHJ1dGh5RGlnaXRTdHJpbmcsXHJcbiAgfSxcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ3NvdXJjZVRva2VuJyxcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvblRva2VuJyxcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdhZ2dyZWdhdG9yJyxcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgdmFsaWRhdG9yOiB0cnV0aHlTdHJpbmcsXHJcbiAgfSxcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ2FnZ1R5cGUnLFxyXG4gICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICB2YWxpZGF0b3I6IHRydXRoeVN0cmluZyxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnZXJyb3InLFxyXG4gICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICB2YWxpZGF0b3I6IChlcnJvcikgPT4gZXJyb3IgPT09IG51bGwgfHwgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnYXZlcmFnZUdhcycsXHJcbiAgICB0eXBlOiAnbnVtYmVyJyxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnbWF4R2FzJyxcclxuICAgIHR5cGU6ICdudW1iZXInLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdnYXNFc3RpbWF0ZScsXHJcbiAgICB0eXBlOiAnbnVtYmVyfHVuZGVmaW5lZCcsXHJcbiAgICB2YWxpZGF0b3I6IChnYXNFc3RpbWF0ZSkgPT4gZ2FzRXN0aW1hdGUgPT09IHVuZGVmaW5lZCB8fCBnYXNFc3RpbWF0ZSA+IDAsXHJcbiAgfSxcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ2ZlZScsXHJcbiAgICB0eXBlOiAnbnVtYmVyJyxcclxuICB9LFxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBhbiBBUEkgY2FsbCwgZS5nLiBcInRva2Vuc1wiXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkXHJcbiAqIEByZXR1cm5zIHN0cmluZ1xyXG4gKi9cclxuY29uc3QgZ2V0QmFzZVVybEZvck5ld1N3YXBzQXBpID0gKHR5cGUsIGNoYWluSWQpID0+IHtcclxuICBjb25zdCB1c2VEZXZBcGlzID0gcHJvY2Vzcy5lbnYuU1dBUFNfVVNFX0RFVl9BUElTO1xyXG4gIGNvbnN0IHYyQXBpQmFzZVVybCA9IHVzZURldkFwaXNcclxuICAgID8gU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTFxyXG4gICAgOiBTV0FQU19BUElfVjJfQkFTRV9VUkw7XHJcbiAgY29uc3QgZ2FzQXBpQmFzZVVybCA9IHVzZURldkFwaXMgPyBHQVNfREVWX0FQSV9CQVNFX1VSTCA6IEdBU19BUElfQkFTRV9VUkw7XHJcbiAgY29uc3Qgbm9OZXR3b3JrU3BlY2lmaWNUeXBlcyA9IFsncmVmcmVzaFRpbWUnXTsgLy8gVGhlc2UgdHlwZXMgZG9uJ3QgbmVlZCBuZXR3b3JrIGluZm8gaW4gdGhlIFVSTC5cclxuICBpZiAobm9OZXR3b3JrU3BlY2lmaWNUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xyXG4gICAgcmV0dXJuIHYyQXBpQmFzZVVybDtcclxuICB9XHJcbiAgY29uc3QgY2hhaW5JZERlY2ltYWwgPSBjaGFpbklkICYmIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcclxuICBjb25zdCBnYXNBcGlUeXBlcyA9IFsnZ2FzUHJpY2VzJ107XHJcbiAgaWYgKGdhc0FwaVR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XHJcbiAgICByZXR1cm4gYCR7Z2FzQXBpQmFzZVVybH0vbmV0d29ya3MvJHtjaGFpbklkRGVjaW1hbH1gOyAvLyBHYXMgY2FsY3VsYXRpb25zIGFyZSBpbiBpdHMgb3duIHJlcG8uXHJcbiAgfVxyXG4gIHJldHVybiBgJHt2MkFwaUJhc2VVcmx9L25ldHdvcmtzLyR7Y2hhaW5JZERlY2ltYWx9YDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRCYXNlQXBpID0gZnVuY3Rpb24gKHR5cGUsIGNoYWluSWQpIHtcclxuICBjb25zdCBfY2hhaW5JZCA9IFRFU1RfQ0hBSU5fSURTLmluY2x1ZGVzKGNoYWluSWQpXHJcbiAgICA/IENIQUlOX0lEUy5NQUlOTkVUXHJcbiAgICA6IGNoYWluSWQ7XHJcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmxGb3JOZXdTd2Fwc0FwaSh0eXBlLCBfY2hhaW5JZCk7XHJcbiAgaWYgKCFiYXNlVXJsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFN3YXBzIEFQSSBjYWxscyBhcmUgZGlzYWJsZWQgZm9yIGNoYWluSWQ6ICR7X2NoYWluSWR9YCk7XHJcbiAgfVxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSAndHJhZGUnOlxyXG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdHJhZGVzP2A7XHJcbiAgICBjYXNlICd0b2tlbnMnOlxyXG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9rZW5zYDtcclxuICAgIGNhc2UgJ3Rva2VuJzpcclxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3Rva2VuYDtcclxuICAgIGNhc2UgJ3RvcEFzc2V0cyc6XHJcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS90b3BBc3NldHNgO1xyXG4gICAgY2FzZSAnYWdncmVnYXRvck1ldGFkYXRhJzpcclxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FnZ3JlZ2F0b3JNZXRhZGF0YWA7XHJcbiAgICBjYXNlICdnYXNQcmljZXMnOlxyXG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vZ2FzUHJpY2VzYDtcclxuICAgIGNhc2UgJ25ldHdvcmsnOlxyXG4gICAgICByZXR1cm4gYmFzZVVybDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0QmFzZUFwaSByZXF1aXJlcyBhbiBhcGkgY2FsbCB0eXBlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNUb2tlblZhbHVlKHZhbHVlLCBkZWNpbWFscykge1xyXG4gIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTnVtYmVyKGRlY2ltYWxzIHx8IDApKTtcclxuICByZXR1cm4gbmV3IEJpZ051bWJlcihTdHJpbmcodmFsdWUpKS50aW1lcyhtdWx0aXBsaWVyKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNob3VsZEVuYWJsZURpcmVjdFdyYXBwaW5nID0gKFxyXG4gIGNoYWluSWQsXHJcbiAgc291cmNlVG9rZW4sXHJcbiAgZGVzdGluYXRpb25Ub2tlbixcclxuKSA9PiB7XHJcbiAgaWYgKCFzb3VyY2VUb2tlbiB8fCAhZGVzdGluYXRpb25Ub2tlbikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCB3cmFwcGVkVG9rZW4gPSBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbY2hhaW5JZF07XHJcbiAgY29uc3QgbmF0aXZlVG9rZW4gPSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5hZGRyZXNzO1xyXG4gIHJldHVybiAoXHJcbiAgICAoaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShzb3VyY2VUb2tlbiwgd3JhcHBlZFRva2VuKSAmJlxyXG4gICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGRlc3RpbmF0aW9uVG9rZW4sIG5hdGl2ZVRva2VuKSkgfHxcclxuICAgIChpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKHNvdXJjZVRva2VuLCBuYXRpdmVUb2tlbikgJiZcclxuICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShkZXN0aW5hdGlvblRva2VuLCB3cmFwcGVkVG9rZW4pKVxyXG4gICk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW5kIG9iamVjdCB3aGVyZSBhbGwgdmFsdWVzIGFyZSBzdHJpbmdzLCByZXR1cm5zIHRoZSBzYW1lIG9iamVjdCB3aXRoIGFsbCB2YWx1ZXNcclxuICogbm93IHByZWZpeGVkIHdpdGggJzB4J1xyXG4gKlxyXG4gKiBAcGFyYW0gb2JqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkSGV4UHJlZml4VG9PYmplY3RWYWx1ZXMob2JqKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChuZXdPYmosIGtleSkgPT4ge1xyXG4gICAgcmV0dXJuIHsgLi4ubmV3T2JqLCBba2V5XTogYWRkSGV4UHJlZml4KG9ialtrZXldKSB9O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBzdGFuZGFyZCBzZXQgb2YgaW5mb3JtYXRpb24gYWJvdXQgYSB0cmFuc2FjdGlvbiwgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHByb3Blcmx5IGZvcm1hdHRlZCBmb3JcclxuICogcHVibGlzaGluZyB2aWEgSlNPTiBSUEMgYW5kIHdlYjNcclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kVG9rZW5dIC0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc2FjaXRvbiBpcyBhIHRva2VuIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRhdGEgLSBBIGhleCBzdHJpbmcgY29udGFpbmluZyB0aGUgZGF0YSB0byBpbmNsdWRlIGluIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50byAtIEEgaGV4IGFkZHJlc3Mgb2YgdGhlIHR4IHJlY2lwaWVudCBhZGRyZXNzXHJcbiAqIEBwYXJhbSBvcHRpb25zLmFtb3VudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mcm9tIC0gQSBoZXggYWRkcmVzcyBvZiB0aGUgdHggc2VuZGVyIGFkZHJlc3NcclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZ2FzIC0gQSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGdhcyB2YWx1ZSBmb3IgdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmdhc1ByaWNlIC0gQSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGdhcyBwcmljZSBmb3IgdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCByZWFkeSBmb3Igc3VibWlzc2lvbiB0byB0aGUgYmxvY2tjaGFpbiwgd2l0aCBhbGwgdmFsdWVzIGFwcHJvcHJpYXRlbHkgaGV4IHByZWZpeGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0VHhQYXJhbXMoe1xyXG4gIHNlbmRUb2tlbixcclxuICBkYXRhLFxyXG4gIHRvLFxyXG4gIGFtb3VudCxcclxuICBmcm9tLFxyXG4gIGdhcyxcclxuICBnYXNQcmljZSxcclxufSkge1xyXG4gIGNvbnN0IHR4UGFyYW1zID0ge1xyXG4gICAgZGF0YSxcclxuICAgIGZyb20sXHJcbiAgICB2YWx1ZTogJzAnLFxyXG4gICAgZ2FzLFxyXG4gICAgZ2FzUHJpY2UsXHJcbiAgfTtcclxuXHJcbiAgaWYgKCFzZW5kVG9rZW4pIHtcclxuICAgIHR4UGFyYW1zLnZhbHVlID0gYW1vdW50O1xyXG4gICAgdHhQYXJhbXMudG8gPSB0bztcclxuICB9XHJcbiAgcmV0dXJuIGFkZEhleFByZWZpeFRvT2JqZWN0VmFsdWVzKHR4UGFyYW1zKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVHJhZGVzSW5mbyhcclxuICB7XHJcbiAgICBzbGlwcGFnZSxcclxuICAgIHNvdXJjZVRva2VuLFxyXG4gICAgc291cmNlRGVjaW1hbHMsXHJcbiAgICBkZXN0aW5hdGlvblRva2VuLFxyXG4gICAgdmFsdWUsXHJcbiAgICBmcm9tQWRkcmVzcyxcclxuICAgIGV4Y2hhbmdlTGlzdCxcclxuICB9LFxyXG4gIHsgY2hhaW5JZCB9LFxyXG4pIHtcclxuICBjb25zdCB1cmxQYXJhbXMgPSB7XHJcbiAgICBkZXN0aW5hdGlvblRva2VuLFxyXG4gICAgc291cmNlVG9rZW4sXHJcbiAgICBzb3VyY2VBbW91bnQ6IGNhbGNUb2tlblZhbHVlKHZhbHVlLCBzb3VyY2VEZWNpbWFscykudG9TdHJpbmcoMTApLFxyXG4gICAgc2xpcHBhZ2UsXHJcbiAgICB0aW1lb3V0OiBTRUNPTkQgKiAxMCxcclxuICAgIHdhbGxldEFkZHJlc3M6IGZyb21BZGRyZXNzLFxyXG4gIH07XHJcblxyXG4gIGlmIChleGNoYW5nZUxpc3QpIHtcclxuICAgIHVybFBhcmFtcy5leGNoYW5nZUxpc3QgPSBleGNoYW5nZUxpc3Q7XHJcbiAgfVxyXG4gIGlmIChzaG91bGRFbmFibGVEaXJlY3RXcmFwcGluZyhjaGFpbklkLCBzb3VyY2VUb2tlbiwgZGVzdGluYXRpb25Ub2tlbikpIHtcclxuICAgIHVybFBhcmFtcy5lbmFibGVEaXJlY3RXcmFwcGluZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBxdWVyeVN0cmluZyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsUGFyYW1zKS50b1N0cmluZygpO1xyXG4gIGNvbnN0IHRyYWRlVVJMID0gYCR7Z2V0QmFzZUFwaSgndHJhZGUnLCBjaGFpbklkKX0ke3F1ZXJ5U3RyaW5nfWA7XHJcbiAgY29uc3QgdHJhZGVzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhDYWNoZShcclxuICAgIHRyYWRlVVJMLFxyXG4gICAgeyBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBjbGllbnRJZEhlYWRlciB9LFxyXG4gICAgeyBjYWNoZVJlZnJlc2hUaW1lOiAwLCB0aW1lb3V0OiBTRUNPTkQgKiAxNSB9LFxyXG4gICk7XHJcbiAgY29uc3QgbmV3UXVvdGVzID0gdHJhZGVzUmVzcG9uc2UucmVkdWNlKChhZ2dJZFRyYWRlTWFwLCBxdW90ZSkgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICBxdW90ZS50cmFkZSAmJlxyXG4gICAgICAhcXVvdGUuZXJyb3IgJiZcclxuICAgICAgdmFsaWRhdGVEYXRhKFFVT1RFX1ZBTElEQVRPUlMsIHF1b3RlLCB0cmFkZVVSTClcclxuICAgICkge1xyXG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFRyYWRlID0gY29uc3RydWN0VHhQYXJhbXMoe1xyXG4gICAgICAgIHRvOiBxdW90ZS50cmFkZS50byxcclxuICAgICAgICBmcm9tOiBxdW90ZS50cmFkZS5mcm9tLFxyXG4gICAgICAgIGRhdGE6IHF1b3RlLnRyYWRlLmRhdGEsXHJcbiAgICAgICAgYW1vdW50OiBkZWNpbWFsVG9IZXgocXVvdGUudHJhZGUudmFsdWUpLFxyXG4gICAgICAgIGdhczogZGVjaW1hbFRvSGV4KHF1b3RlLm1heEdhcyksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGV0IHsgYXBwcm92YWxOZWVkZWQgfSA9IHF1b3RlO1xyXG5cclxuICAgICAgaWYgKGFwcHJvdmFsTmVlZGVkKSB7XHJcbiAgICAgICAgYXBwcm92YWxOZWVkZWQgPSBjb25zdHJ1Y3RUeFBhcmFtcyh7XHJcbiAgICAgICAgICAuLi5hcHByb3ZhbE5lZWRlZCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5hZ2dJZFRyYWRlTWFwLFxyXG4gICAgICAgIFtxdW90ZS5hZ2dyZWdhdG9yXToge1xyXG4gICAgICAgICAgLi4ucXVvdGUsXHJcbiAgICAgICAgICBzbGlwcGFnZSxcclxuICAgICAgICAgIHRyYWRlOiBjb25zdHJ1Y3RlZFRyYWRlLFxyXG4gICAgICAgICAgYXBwcm92YWxOZWVkZWQsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBhZ2dJZFRyYWRlTWFwO1xyXG4gIH0sIHt9KTtcclxuXHJcbiAgcmV0dXJuIG5ld1F1b3RlcztcclxufVxyXG4iLCJpbXBvcnQgeyBhYmlFUkMyMCB9IGZyb20gJ0BtZXRhbWFzay9tZXRhbWFzay1ldGgtYWJpcyc7XHJcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJztcclxuaW1wb3J0IHsgV2ViM1Byb3ZpZGVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJztcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSAnX3ZhbHVlJyBwYXJhbWV0ZXIgb2YgdGhlIGdpdmVuIHRva2VuIHRyYW5zYWN0aW9uIGRhdGFcclxuICogKGkuZSBmdW5jdGlvbiBjYWxsKSBwZXIgdGhlIEh1bWFuIFN0YW5kYXJkIFRva2VuIEFCSSwgaWYgcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHRva2VuRGF0YSAtIGV0aGVycyBJbnRlcmZhY2UgdG9rZW4gZGF0YS5cclxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gQSBkZWNpbWFsIHN0cmluZyB2YWx1ZS5cclxuICovXHJcbi8qKlxyXG4gKiBHZXRzIGVpdGhlciB0aGUgJ190b2tlbklkJyBwYXJhbWV0ZXIgb3IgdGhlICdpZCcgcGFyYW0gb2YgdGhlIHBhc3NlZCB0b2tlbiB0cmFuc2FjdGlvbiBkYXRhLixcclxuICogVGhlc2UgYXJlIHRoZSBwYXJzZWQgdG9rZW5JZCB2YWx1ZXMgcmV0dXJuZWQgYnkgYHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YWAgYXMgZGVmaW5lZFxyXG4gKiBpbiB0aGUgRVJDNzIxIGFuZCBFUkMxMTU1IEFCSXMgZnJvbSBtZXRhbWFzay1ldGgtYWJpcyAoaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV0aC1hYmlzL3RyZWUvbWFpbi9zcmMvYWJpcylcclxuICpcclxuICogQHBhcmFtIHRva2VuRGF0YSAtIGV0aGVycyBJbnRlcmZhY2UgdG9rZW4gZGF0YS5cclxuICogQHJldHVybnMgQSBkZWNpbWFsIHN0cmluZyB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUb2tlbklkUGFyYW0odG9rZW5EYXRhOiBhbnkgPSB7fSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgcmV0dXJuIChcclxuICAgIHRva2VuRGF0YT8uYXJncz8uX3Rva2VuSWQ/LnRvU3RyaW5nKCkgPz8gdG9rZW5EYXRhPy5hcmdzPy5pZD8udG9TdHJpbmcoKVxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRva2VuQmFsYW5jZShcclxuICBhZGRyZXNzOiBzdHJpbmcsXHJcbiAgdXNlckFkZHJlc3M6IHN0cmluZyxcclxuICBwcm92aWRlcjogYW55LFxyXG4pOiBQcm9taXNlPGFueT4ge1xyXG4gIGNvbnN0IGV0aGVyc1Byb3ZpZGVyID0gbmV3IFdlYjNQcm92aWRlcihwcm92aWRlcik7XHJcbiAgY29uc3QgdG9rZW5Db250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBhYmlFUkMyMCwgZXRoZXJzUHJvdmlkZXIpO1xyXG4gIGNvbnN0IHRva2VuQmFsYW5jZVByb21pc2UgPSB0b2tlbkNvbnRyYWN0XHJcbiAgICA/IHRva2VuQ29udHJhY3QuYmFsYW5jZU9mKHVzZXJBZGRyZXNzKVxyXG4gICAgOiBQcm9taXNlLnJlc29sdmUoKTtcclxuICByZXR1cm4gYXdhaXQgdG9rZW5CYWxhbmNlUHJvbWlzZTtcclxufVxyXG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCB7IEV0aGVyRGVub21pbmF0aW9uIH0gZnJvbSAnLi4vY29uc3RhbnRzL2NvbW1vbic7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVUeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuaW1wb3J0IHsgTnVtZXJpYyB9IGZyb20gJy4uL21vZHVsZXMvTnVtZXJpYyc7XHJcbmltcG9ydCB7IGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2wgfSBmcm9tICcuLi9tb2R1bGVzL3N3YXBzLnV0aWxzJztcclxuXHJcbmV4cG9ydCBjb25zdCBUT0tFTl9UUkFOU0ZFUl9MT0dfVE9QSUNfSEFTSCA9XHJcbiAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZic7XHJcblxyXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fTk9fQ09OVFJBQ1RfRVJST1JfS0VZID0gJ3RyYW5zYWN0aW9uRXJyb3JOb0NvbnRyYWN0JztcclxuXHJcbmV4cG9ydCBjb25zdCBURU5fU0VDT05EU19JTl9NSUxMSVNFQ09ORFMgPSAxMF8wMDA7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY0dhc1RvdGFsKGdhc0xpbWl0ID0gJzAnLCBnYXNQcmljZSA9ICcwJykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhnYXNMaW1pdCwgMTYpLnRpbWVzKG5ldyBOdW1lcmljKGdhc1ByaWNlLCAxNikpLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG51bWJlciBhbmQgc3BlY2lmaWVkIHByZWNpc2lvbiwgcmV0dXJucyB0aGF0IG51bWJlciBpbiBiYXNlIDEwIHdpdGggYSBtYXhpbXVtIG9mIHByZWNpc2lvblxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMsIGJ1dCB3aXRob3V0IGFueSB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCBUbyBiZSB1c2VkIHdoZW4gd2lzaGluZ1xyXG4gKiB0byBkaXNwbGF5IG9ubHkgYXMgbXVjaCBkaWdpdHMgdG8gdGhlIHVzZXIgYXMgbmVjZXNzYXJ5XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgQmlnTnVtYmVyfSBuIC0gVGhlIG51bWJlciB0byBmb3JtYXRcclxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJldHVybiB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbnVtYmVyIGluIGRlY2ltYWwgZm9ybSwgd2l0aCA8PSBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGlnaXRzIGFuZCBubyBkZWNpbWFsIHRyYWlsaW5nIHplcm9zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9QcmVjaXNpb25XaXRob3V0VHJhaWxpbmdaZXJvcyhuLCBwcmVjaXNpb24pIHtcclxuICByZXR1cm4gbmV3IEJpZ051bWJlcihuKVxyXG4gICAgLnRvUHJlY2lzaW9uKHByZWNpc2lvbilcclxuICAgIC5yZXBsYWNlKC8oXFwuWzAtOV0qWzEtOV0pMCp8KFxcLjAqKS91LCAnJDEnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNUb2tlbkFtb3VudCh2YWx1ZSwgZGVjaW1hbHMpIHtcclxuICBjb25zdCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIE51bWJlcihkZWNpbWFscyB8fCAwKSk7XHJcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoU3RyaW5nKHZhbHVlKSkuZGl2KG11bHRpcGxpZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3dhcHNUb2tlbnNSZWNlaXZlZEZyb21UeE1ldGEoXHJcbiAgdG9rZW5TeW1ib2wsXHJcbiAgdHhNZXRhLFxyXG4gIHRva2VuQWRkcmVzcyxcclxuICBhY2NvdW50QWRkcmVzcyxcclxuICB0b2tlbkRlY2ltYWxzLFxyXG4gIGFwcHJvdmFsVHhNZXRhLFxyXG4gIGNoYWluSWQsXHJcbikge1xyXG4gIGNvbnN0IHR4UmVjZWlwdCA9IHR4TWV0YT8udHhSZWNlaXB0O1xyXG4gIGNvbnN0IG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5ID1cclxuICAgIHR4TWV0YT8udHhSZWNlaXB0Py50eXBlID09PSBUcmFuc2FjdGlvbkVudmVsb3BlVHlwZS5mZWVNYXJrZXQ7XHJcbiAgaWYgKGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2wodG9rZW5TeW1ib2wsIGNoYWluSWQpKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgICF0eFJlY2VpcHQgfHxcclxuICAgICAgIXR4TWV0YSB8fFxyXG4gICAgICAhdHhNZXRhLnBvc3RUeEJhbGFuY2UgfHxcclxuICAgICAgIXR4TWV0YS5wcmVUeEJhbGFuY2VcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHhNZXRhLnN3YXBNZXRhRGF0YSAmJiB0eE1ldGEucHJlVHhCYWxhbmNlID09PSB0eE1ldGEucG9zdFR4QmFsYW5jZSkge1xyXG4gICAgICAvLyBJZiBwcmVUeEJhbGFuY2UgYW5kIHBvc3RUeEJhbGFuY2UgYXJlIGVxdWFsLCBwb3N0VHhCYWxhbmNlIGhhc24ndCBiZWVuIHVwZGF0ZWQgb24gdGltZVxyXG4gICAgICAvLyBiZWNhdXNlIG9mIHRoZSBSUEMgcHJvdmlkZXIgZGVsYXksIHNvIHdlIHJldHVybiBhbiBlc3RpbWF0ZWQgcmVjZWl2aW5nIGFtb3VudCBpbnN0ZWFkLlxyXG4gICAgICByZXR1cm4gdHhNZXRhLnN3YXBNZXRhRGF0YS50b2tlbl90b19hbW91bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFwcHJvdmFsVHhHYXNDb3N0ID0gbmV3IE51bWVyaWMoJzB4MCcsIDE2KTtcclxuICAgIGlmIChhcHByb3ZhbFR4TWV0YSAmJiBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQpIHtcclxuICAgICAgYXBwcm92YWxUeEdhc0Nvc3QgPSBuZXcgTnVtZXJpYyhcclxuICAgICAgICBjYWxjR2FzVG90YWwoXHJcbiAgICAgICAgICBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQuZ2FzVXNlZCxcclxuICAgICAgICAgIG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5XHJcbiAgICAgICAgICAgID8gYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0LmVmZmVjdGl2ZUdhc1ByaWNlIC8vIEJhc2UgZmVlICsgcHJpb3JpdHkgZmVlLlxyXG4gICAgICAgICAgICA6IGFwcHJvdmFsVHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgMTYsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2FzQ29zdCA9IGNhbGNHYXNUb3RhbChcclxuICAgICAgdHhSZWNlaXB0Lmdhc1VzZWQsXHJcbiAgICAgIG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5XHJcbiAgICAgICAgPyB0eFJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2VcclxuICAgICAgICA6IHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSxcclxuICAgICk7XHJcbiAgICBjb25zdCB0b3RhbEdhc0Nvc3QgPSBuZXcgTnVtZXJpYyhnYXNDb3N0LCAxNikuYWRkKGFwcHJvdmFsVHhHYXNDb3N0KTtcclxuXHJcbiAgICBjb25zdCBwcmVUeEJhbGFuY2VMZXNzR2FzQ29zdCA9IG5ldyBOdW1lcmljKHR4TWV0YS5wcmVUeEJhbGFuY2UsIDE2KS5taW51cyhcclxuICAgICAgdG90YWxHYXNDb3N0LFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBldGhSZWNlaXZlZCA9IG5ldyBOdW1lcmljKFxyXG4gICAgICB0eE1ldGEucG9zdFR4QmFsYW5jZSxcclxuICAgICAgMTYsXHJcbiAgICAgIEV0aGVyRGVub21pbmF0aW9uLldFSSxcclxuICAgIClcclxuICAgICAgLm1pbnVzKHByZVR4QmFsYW5jZUxlc3NHYXNDb3N0KVxyXG4gICAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxyXG4gICAgICAudG9CYXNlKDEwKVxyXG4gICAgICAucm91bmQoNik7XHJcbiAgICByZXR1cm4gZXRoUmVjZWl2ZWQudG9TdHJpbmcoKTtcclxuICB9XHJcbiAgY29uc3QgdHhSZWNlaXB0TG9ncyA9IHR4UmVjZWlwdD8ubG9ncztcclxuICBpZiAodHhSZWNlaXB0TG9ncyAmJiB0eFJlY2VpcHQ/LnN0YXR1cyAhPT0gJzB4MCcpIHtcclxuICAgIGNvbnN0IHRva2VuVHJhbnNmZXJMb2cgPSB0eFJlY2VpcHRMb2dzLmZpbmQoKHR4UmVjZWlwdExvZykgPT4ge1xyXG4gICAgICBjb25zdCBpc1Rva2VuVHJhbnNmZXIgPVxyXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3MgJiZcclxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzBdID09PSBUT0tFTl9UUkFOU0ZFUl9MT0dfVE9QSUNfSEFTSDtcclxuICAgICAgY29uc3QgaXNUcmFuc2ZlckZyb21HaXZlblRva2VuID0gdHhSZWNlaXB0TG9nLmFkZHJlc3MgPT09IHRva2VuQWRkcmVzcztcclxuICAgICAgY29uc3QgaXNUcmFuc2ZlckZyb21HaXZlbkFkZHJlc3MgPVxyXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3MgJiZcclxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzJdICYmXHJcbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljc1syXS5tYXRjaChhY2NvdW50QWRkcmVzcy5zbGljZSgyKSk7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgaXNUb2tlblRyYW5zZmVyICYmXHJcbiAgICAgICAgaXNUcmFuc2ZlckZyb21HaXZlblRva2VuICYmXHJcbiAgICAgICAgaXNUcmFuc2ZlckZyb21HaXZlbkFkZHJlc3NcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRva2VuVHJhbnNmZXJMb2dcclxuICAgICAgPyB0b1ByZWNpc2lvbldpdGhvdXRUcmFpbGluZ1plcm9zKFxyXG4gICAgICAgICAgY2FsY1Rva2VuQW1vdW50KHRva2VuVHJhbnNmZXJMb2cuZGF0YSwgdG9rZW5EZWNpbWFscykudG9TdHJpbmcoMTApLFxyXG4gICAgICAgICAgNixcclxuICAgICAgICApXHJcbiAgICAgIDogJyc7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRV9OQU1FUyA9IHtcclxuICBGRUVfTUFSS0VUOiAnZmVlLW1hcmtldCcsXHJcbiAgTEVHQUNZOiAnbGVnYWN5JyxcclxufTtcclxuIiwiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcclxuaW1wb3J0IHsgaXNIZXhTdHJpbmcsIGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcclxuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHsgRXRoZXJEZW5vbWluYXRpb24gfSBmcm9tICcuLi9jb25zdGFudHMvY29tbW9uJztcclxuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuL2hleHN0cmluZy11dGlscyc7XHJcblxyXG5leHBvcnQgdHlwZSBOdW1lcmljVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgfCBCTiB8IEJpZ051bWJlcjtcclxuZXhwb3J0IHR5cGUgTnVtZXJpY0Jhc2UgPSAxMCB8IDE2O1xyXG5cclxuLyoqXHJcbiAqIEFsbCB2YXJpYXRpb25zIG9mIGlzSGV4U3RyaW5nIGZyb20gb3VyIG93biB1dGlsaXRpZXMgYW5kIGV0aGVydW1qcy11dGlsc1xyXG4gKiByZXR1cm4gZmFsc2UgZm9yIGEgJy0nIHByZWZpeGVkIGhleCBzdHJpbmcuIFRoaXMgdXRpbGl0eSBtZXRob2Qgc3RyaXBzIHRoZVxyXG4gKiBwb3NzaWJsZSAnLScgZnJvbSB0aGUgc3RyaW5nIGJlZm9yZSB0ZXN0aW5nIGl0cyB2YWxpZGl0eSBzbyB0aGF0IG5lZ2F0aXZlXHJcbiAqIGhleCB2YWx1ZXMgY2FuIGJlIHByb3Blcmx5IGhhbmRsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY2hlY2tcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChuZWdhdGl2ZSBvciBvdGhlcndpc2UpXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0hleFN0cmluZ09yTmVnYXRlZEhleFN0cmluZyh2YWx1ZTogc3RyaW5nKTogdmFsdWUgaXMgc3RyaW5nIHtcclxuICByZXR1cm4gaXNIZXhTdHJpbmcodmFsdWUucmVwbGFjZSgnLScsICcnKSkgfHwgaXNIZXhTdHJpbmcodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQmlnTnVtYmVyIHN1cHBvcnRzIGhleCBzdHJpbmdzIHdpdGggJy4nIChha2EgZGVjaW1hbHMpIGluIHRoZSBzdHJpbmcuXHJcbiAqIE5vIHZlcnNpb24gb2YgaXNIZXhTdHJpbmcgcmV0dXJzIHRydWUgaWYgdGhlIHN0cmluZyBjb250YWlucyBhIGRlY2ltYWwgc29cclxuICogdGhpcyBtZXRob2QgaXMgdXNlZCB0byBjaGVjayBpZiBib3RoIHBhcnRzIG9mIHRoZSBzdHJpbmcgc3BsaXQgYnkgdGhlXHJcbiAqIGRlY2ltYWwgYXJlIGhleCBzdHJpbmdzLiBJZiBzbyB3ZSBjYW4gZmVlZCB0aGlzIHZhbHVlIGludG8gQmlnTnVtYmVyIHRvIGdldFxyXG4gKiBhIHZhbGlkIE51bWVyaWMuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY2hlY2tcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgaGV4YWRlY2ltYWwgc3BsaXQgYnkgJy4nXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RlY2ltYWxIZXgodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoJy4nKTtcclxuICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBwYXJ0cy5ldmVyeSgocGFydCkgPT4gaXNIZXhTdHJpbmdPck5lZ2F0ZWRIZXhTdHJpbmcocGFydCkpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBpbiBzdHJpbmcgb3IgbnVtYmVyIGZvcm1hdCB0byBhIEJpZ051bWJlci5cclxuICogTm90ZSB0aGF0IGluIG1hbnkgcGxhY2VzIGluIG91ciBjb2RlYmFzZSB3ZSBjYWxsICdhZGRIZXhQcmVmaXgnIG9uIGEgbmVnYXRlZFxyXG4gKiBoZXhhZGVjaW1hbCBzdHJpbmcgcmVzdWx0aW5nIGluICcweC1hJyB3aGljaCB3aWxsIGZhaWwgY2hlY2tzIGZvclxyXG4gKiBpc0hleFN0cmluZy4gU29tZXRpbWVzIHdlIERPIG5vdCBhZGQgdGhlIDB4IHNvIHdlIGhhdmUgdG8gY2hlY2sgZm9yICctYSdcclxuICogYXMgd2VsbC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gaGV4YWRlY2ltYWwgdmFsdWUgaW4gc3RyaW5nIG9yIG51bWJlciBmb3JtYXQuXHJcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0JpZ051bWJlcih2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogQmlnTnVtYmVyIHtcclxuICBjb25zdCBzdHJpbmdpZmllZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBgJHt2YWx1ZX1gIDogdmFsdWU7XHJcbiAgY29uc3QgaXNOZWdhdGl2ZSA9IHN0cmlwSGV4UHJlZml4KHN0cmluZ2lmaWVkKVswXSA9PT0gJy0nO1xyXG4gIGNvbnN0IHZhbHVlV2l0aG91dE5lZ2F0aW9uID0gc3RyaW5naWZpZWQucmVwbGFjZSgnLScsICcnKTtcclxuXHJcbiAgY29uc3QgdmFsdWVBc0JpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIoXHJcbiAgICBzdHJpcEhleFByZWZpeCh2YWx1ZVdpdGhvdXROZWdhdGlvbiksXHJcbiAgICAxNixcclxuICApO1xyXG5cclxuICByZXR1cm4gaXNOZWdhdGl2ZSA/IHZhbHVlQXNCaWdOdW1iZXIubmVnYXRlZCgpIDogdmFsdWVBc0JpZ051bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgZGVjaW1hbCBpbiBzdHJpbmcgb3IgbnVtYmVyIGZvcm1hdCB0byBhIEJpZ051bWJlci5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gZGVjaW1hbCB2YWx1ZSBpbiBzdHJpbmcgb3IgbnVtYmVyIGZvcm1hdC5cclxuICogQHJldHVybnMgQSBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNpbWFsVG9CaWdOdW1iZXIodmFsdWU6IHN0cmluZyB8IG51bWJlcikge1xyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKFN0cmluZyh2YWx1ZSksIDEwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2FmZWx5IGNvbnZlcnQgYSBzdHJpbmcgdHlwZSB2YWx1ZSB0byBhIEJpZ051bWJlci5cclxuICogVGhlIG9ubHkgdmFsaWQgc3RyaW5ncyBmb3IgdGhpcyBtZXRob2QgYXJlIHRob3NlIHRoYXQgYXJlIGVpdGhlciBoZXhhZGVjaW1hbFxyXG4gKiBudW1lcmljIHZhbHVlcyBPUiBudW1lcmljIHN0cmluZ3MgdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIEJpZ051bWJlcnMuIEl0IGlzXHJcbiAqIGltcG9zc2libGUgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgaGV4IHZhbHVlIG9mIDEwMDAwMCB2cyBhIGRlY2ltYWxcclxuICogdmFsdWUgb2YgMTAwMDAwIHNvIGEgc2Vjb25kIHBhcmFtZXRlciBpbmRpY2F0aW5nIHRoZSBudW1lcmljIGJhc2Ugb2YgdGhlXHJcbiAqIHN0cmluZyB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBBIGhleGFkZWNpbWFsIG9yIGRlY2ltYWwgc3RyaW5nXHJcbiAqIEBwYXJhbSBudW1lcmljQmFzZSAtIEVpdGhlciAxNiBmb3IgYSBoZXhhZGVjaWFtbCBvciAxMCBmb3IgYSBkZWNpbWFsXHJcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5nVG9CaWdOdW1iZXIodmFsdWU6IHN0cmluZywgbnVtZXJpY0Jhc2U6IE51bWVyaWNCYXNlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYFZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9IHBhc3NlZCB0byBzdHJpbmdUb0JpZ051bWJlcmAsXHJcbiAgICApO1xyXG4gIH1cclxuICBpZiAoXHJcbiAgICBudW1lcmljQmFzZSA9PT0gMTYgJiZcclxuICAgIChpc0hleFN0cmluZ09yTmVnYXRlZEhleFN0cmluZyh2YWx1ZSkgfHwgaXNEZWNpbWFsSGV4KHZhbHVlKSlcclxuICApIHtcclxuICAgIHJldHVybiBoZXhhZGVjaW1hbFRvQmlnTnVtYmVyKHZhbHVlKTtcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgbnVtZXJpY0Jhc2UgPT09IDEwICYmXHJcbiAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgZmluaXRlIGludGVnZXIgb3IgZmxvYXRcclxuICAgIChpc0Zpbml0ZShwYXJzZUludCh2YWx1ZSwgMTApKSB8fCBpc0Zpbml0ZShwYXJzZUZsb2F0KHZhbHVlKSkpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gZGVjaW1hbFRvQmlnTnVtYmVyKHZhbHVlKTtcclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgYFN0cmluZyBwcm92aWRlZCB0byBzdHJpbmdUb0JpZ051bWJlciBpcyBub3QgYSBoZXhhZGVjaW1hbCBvciBkZWNpbWFsIHN0cmluZzogJHt2YWx1ZX0sICR7bnVtZXJpY0Jhc2V9YCxcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2Qgd2lsbCBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgb3IgZGVjaWFtbCBudW1iZXIgaW50byBhIEJpZ051bWJlci5cclxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIgbXVzdCBiZSBzdXBwbGllZCBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHRyZWF0IHRoZVxyXG4gKiB2YWx1ZSBhcyBhIGhleGFkZWNpbWFsIG9yIGRlY2ltYWwgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIGhleGFkZWNpbWFsIG9yIGRlY2ltYWwgbnVtYmVyW11cclxuICogQHBhcmFtIG51bWVyaWNCYXNlIC0gMTAgZm9yIGRlY2ltYWwsIDE2IGZvciBoZXhhZGVjaW1hbFxyXG4gKiBAcmV0dXJucyBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBudW1iZXJUb0JpZ051bWJlcih2YWx1ZTogbnVtYmVyLCBudW1lcmljQmFzZTogTnVtZXJpY0Jhc2UpIHtcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgVmFsdWUgb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0gcGFzc2VkIHRvIG51bWJlclRvQmlnTnVtYmVyYCxcclxuICAgICk7XHJcbiAgfVxyXG4gIGlmIChudW1lcmljQmFzZSA9PT0gMTYgJiYgaXNIZXhTdHJpbmcoYCR7dmFsdWV9YCkpIHtcclxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGAke3ZhbHVlfWAsIDE2KTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDEwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ldGhvZCB0byBjb252ZXJ0IGEgQk4gdG8gYSBCaWdOdW1iZXJcclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gQSBCTiByZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlXHJcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCTidzIHVuZGVybHlpbmcgdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIGJuVG9CaWdOdW1iZXIodmFsdWU6IEJOKSB7XHJcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQk4gPT09IGZhbHNlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGB2YWx1ZSBwYXNzZWQgdG8gYm5Ub0JpZ051bWJlciBpcyBub3QgYSBCTi4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiB2YWx1ZX1gLFxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUudG9TdHJpbmcoMTYpLCAxNik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHZhbHVlIG9mIHRoZSBzdXBwb3J0ZWQgdHlwZXMgKHN0cmluZywgbnVtYmVyLCBCTikgdG8gYSBCaWdOdW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgQmlnTnVtYmVyXHJcbiAqIEBwYXJhbSBudW1lcmljQmFzZSAtIFRoZSBudW1lcmljIGJhc2Ugb2YgdGhlIHVuZGVybHlpbmcgdmFsdWVcclxuICogQHJldHVybnMgQSBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWx1ZVRvQmlnTnVtYmVyKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIG51bWVyaWNCYXNlOiBOdW1lcmljQmFzZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nVG9CaWdOdW1iZXIodmFsdWUsIG51bWVyaWNCYXNlKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIG51bWJlclRvQmlnTnVtYmVyKHZhbHVlLCBudW1lcmljQmFzZSk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICBgVmFsdWU6ICR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZywgbnVtYmVyLCBCaWdOdW1iZXIgb3IgQk4uIFR5cGUgaXM6ICR7dHlwZW9mIHZhbHVlfS5gLFxyXG4gICk7XHJcbn1cclxuXHJcbi8vIEJpZyBOdW1iZXIgQ29uc3RhbnRzXHJcbmNvbnN0IEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIgPSBuZXcgQmlnTnVtYmVyKCcxMDAwMDAwMDAwMDAwMDAwMDAwJyk7XHJcbmNvbnN0IEJJR19OVU1CRVJfR1dFSV9NVUxUSVBMSUVSID0gbmV3IEJpZ051bWJlcignMTAwMDAwMDAwMCcpO1xyXG5jb25zdCBCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSID0gbmV3IEJpZ051bWJlcignMScpO1xyXG5cclxuY29uc3QgdG9Ob3JtYWxpemVkRGVub21pbmF0aW9uID0ge1xyXG4gIFdFSTogKGJpZ051bWJlcjogQmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIuZGl2KEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIpLFxyXG4gIEdXRUk6IChiaWdOdW1iZXI6IEJpZ051bWJlcikgPT4gYmlnTnVtYmVyLmRpdihCSUdfTlVNQkVSX0dXRUlfTVVMVElQTElFUiksXHJcbiAgRVRIOiAoYmlnTnVtYmVyOiBCaWdOdW1iZXIpID0+IGJpZ051bWJlci5kaXYoQklHX05VTUJFUl9FVEhfTVVMVElQTElFUiksXHJcbn07XHJcbmNvbnN0IHRvU3BlY2lmaWVkRGVub21pbmF0aW9uID0ge1xyXG4gIFdFSTogKGJpZ051bWJlcjogQmlnTnVtYmVyKSA9PlxyXG4gICAgYmlnTnVtYmVyLnRpbWVzKEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIpLnJvdW5kKCksXHJcbiAgR1dFSTogKGJpZ051bWJlcjogQmlnTnVtYmVyKSA9PlxyXG4gICAgYmlnTnVtYmVyLnRpbWVzKEJJR19OVU1CRVJfR1dFSV9NVUxUSVBMSUVSKS5yb3VuZCg5KSxcclxuICBFVEg6IChiaWdOdW1iZXI6IEJpZ051bWJlcikgPT5cclxuICAgIGJpZ051bWJlci50aW1lcyhCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSKS5yb3VuZCg5KSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB2YWx1ZSBpbiBFVEggb2YgdGhlIG51bWVyaWMgc3VwcGxpZWQsIHVzZWQgaW4gdGhpcyBmaWxlIG9ubHkgdG9cclxuICogY29udmVydCB0byBFVEggcHJpb3IgdG8gY29udmVydGluZyB0byBhbm90aGVyIGRlbm9taW5hdGlvbi4gVGhlIGZvbGxvd2luZ1xyXG4gKiBxdWlya3Mgd2VyZSBwcm9ncmFtbWVkIGludG8gdGhpcyBtZXRob2QgdG8gcmVwbGljYXRlIGJlaGF2aW9yIG9mIHRoZVxyXG4gKiBwcmVkZWNlc3NvciB0byBOdW1lcmljLCB3aGljaCB3YXMgJ2NvbnZlcnNpb25VdGlsJy4gSWYgYSBkZW5vbWluYXRpb24gaXNcclxuICogbm90IHN1cHBsaWVkLCBhbmQgdG9EZW5vbWluYXRpb24gaXMgY2FsbGVkLCB0aGVuIHdlIGFzc3VtZSB0aGUgZGVub21pbmF0aW9uXHJcbiAqIHdhcyBvcmlnaW5hbGx5IEVUSCwgb3RoZXJ3aXNlIHdlIGNvbnZlcnQgaXQgdG8gRVRILlxyXG4gKlxyXG4gKiBAcGFyYW0gbnVtZXJpY1xyXG4gKiBAcmV0dXJucyB2YWx1ZSBpbiBFVEhcclxuICovXHJcbmZ1bmN0aW9uIGdldFZhbHVlSW5FVEgobnVtZXJpYzogTnVtZXJpYykge1xyXG4gIGlmIChcclxuICAgIG51bWVyaWMuZGVub21pbmF0aW9uID09PSBFdGhlckRlbm9taW5hdGlvbi5FVEggfHxcclxuICAgIHR5cGVvZiBudW1lcmljLmRlbm9taW5hdGlvbiA9PT0gJ3VuZGVmaW5lZCdcclxuICApIHtcclxuICAgIHJldHVybiBudW1lcmljLnZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gdG9Ob3JtYWxpemVkRGVub21pbmF0aW9uW251bWVyaWMuZGVub21pbmF0aW9uXShudW1lcmljLnZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZW4gYXBwbHlpbmcgb3BlcmFuZHMgdG8gTnVtZXJpY3MgdGhhdCBoYXZlIGEgc3BlY2lmaWVkIERlbm9taW5hdGlvbiB0aGVuXHJcbiAqIHdlIHNob3VsZCBmaXJzdCBjb252ZXJ0IHRoZSBwcm92aWRlZCBpbnB1dE51bWVyaWMgdG8gdGhlIHNhbWUgRGVub21pbmF0aW9uXHJcbiAqIGFzIHRoZSBiYXNlTnVtZXJpYy4gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoaXMgZG9lc24ndCBhcHBseTpcclxuICpcclxuICogMS4gSWYgdGhlIGRlbm9taW5hdGlvbnMgYXJlIGFscmVhZHkgdGhlIHNhbWUuIE5vIGNvbnZlcnNpb24gaXMgbmVjZXNzYXJ5LlxyXG4gKiAyLiBJZiB0aGUgaW5wdXROdW1lcmljIGRvZXMgbm90IGhhdmUgYSBkZW5vbWluYXRpb24gc2V0LiBXZSBhc3N1bWUgaW4gdGhpc1xyXG4gKiBjYXNlIHRoYXQgdGhlIHZhbHVlIGlzIGFscmVhZHkgaW4gdGhlIGFwcHJvcHJpYXRlIGRlbm9taW5hdGlvbi5cclxuICpcclxuICogQHBhcmFtIGJhc2VOdW1lcmljXHJcbiAqIEBwYXJhbSBpbnB1dE51bWVyaWNcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGFsaWduT3BlcmFuZERlbm9taW5hdGlvbnMoXHJcbiAgYmFzZU51bWVyaWM6IE51bWVyaWMsXHJcbiAgaW5wdXROdW1lcmljOiBOdW1lcmljLFxyXG4pIHtcclxuICBpZiAoXHJcbiAgICB0eXBlb2YgaW5wdXROdW1lcmljLmRlbm9taW5hdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIGJhc2VOdW1lcmljLmRlbm9taW5hdGlvbiAhPT0gaW5wdXROdW1lcmljLmRlbm9taW5hdGlvblxyXG4gICkge1xyXG4gICAgcmV0dXJuIGlucHV0TnVtZXJpYy50b0Rlbm9taW5hdGlvbihiYXNlTnVtZXJpYy5kZW5vbWluYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlucHV0TnVtZXJpYztcclxufVxyXG5cclxuLyoqXHJcbiAqIE51bWVyaWMgaXMgYSBjbGFzcyB3aG9zZSBtZXRob2RzIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ldywgbm90IG11dGF0ZWQsXHJcbiAqIHZhbHVlLiBUaGlzIGFsbG93cyBmb3IgY2hhaW5pbmcgb2Ygbm9uLXRlcm1pbmF0aW5nIG1ldGhvZHMuIFByZXZpb3VzbHkgd2VcclxuICogaGFkIG5lYXIgYSBodW5kcmVkIGhlbHBlciBtZXRob2RzIHRoYXQgY29tcG9zZWQgb25lLWFub3RoZXIsIG1ha2luZyB0cmFja2luZ1xyXG4gKiB0aHJvdWdoIHRoZSBjaGFpbiBuZWFyIGltcG9zc2libGUuIFRoaXMgQVBJIGlzIGRlc2lnbmVkIHN1Y2ggdGhhdCBubyBoZWxwZXJcclxuICogbWV0aG9kcyBzaG91bGQgYmUgbmVlZGVkLiBUYWtlIHRoZSBjYXNlIG9mIGhleFdFSVRvRGVjR1dFSSwgYSBoZWxwZXIgbWV0aG9kXHJcbiAqIGZvciB0YWtpbmcgYSBoZXggc3RyaW5nIHJlcHJlc2VudGluZyBhIHZhbHVlIGluIFdFSSBhbmQgY29udmVydGluZyB0aGF0IHRvIGFcclxuICogZGVjaW1hbCBvZiBHV0VJLiBQcmlvciB0byB0aGlzIGNsYXNzIHRoZSBtZXRob2Qgd291bGQgY2FsbCBpbnRvIG91ciByb290XHJcbiAqIGxldmVsICdjb252ZXJzaW9uVXRpbCcgd2hpY2ggd2FzIHRoZSBwcm92ZXJiaWFsIGtpdGNoZW4gc2luayBkb2luZ1xyXG4gKiBldmVyeXRoaW5nIGZyb20gZGVub21pbmF0aW9uIGNvbnZlcnNpb24sIGN1cnJlbmN5IGNvbnZlcnNpb24gKHdpdGggcHJvdmlkZWRcclxuICogY29udmVyc2lvblJhdGUgcHJvcCkgYW5kIG1vcmUuIFRoZSBzYW1lIG9wZWFydGlvbiBjYW4gbm93IGJlIGV4cHJlc3NlZCBhczpcclxuICogbmV3IE51bWVyaWMoaGV4U3RyaW5nLCAxNiwgRXRoZXJEZW5vbWluYXRpb24uV0VJKVxyXG4gKiAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uR1dFSSlcclxuICogLnRvQmFzZSgxMClcclxuICogLnRvU3RyaW5nKCk7XHJcbiAqIFRoaXMgaGFzIHRoZSBiZW5lZml0IG9mIGJlaW5nIGZhaXJseSB0cmFuc3BhcmVudCBhcyB5b3UgY2FuIHJlYWQgZWFjaCBzdGVwXHJcbiAqIGluIHRoZSBjaGFpbiBhbmQgaGF2ZSBhIGdvb2Qgc2Vuc2Ugb2Ygd2hhdCBpcyBiZWluZyBkb25lLiBJdCBhbHNvIGlzIGhpZ2hseVxyXG4gKiBjb21wb3NhYmxlIHNvIHRoYXQgd2Ugc2hvdWxkbid0IG5lZWQgdG9ucyBvZiBoZWxwZXIgbWV0aG9kcyBmb3Igc2hvcnRjdXRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE51bWVyaWMge1xyXG4gIC8qKlxyXG4gICAqIFRoZSB1bmRlcmx5aW5nIHZhbHVlIG9mIHRoZSBOdW1lcmljLCBhbHdheXMgaW4gQmlnTnVtYmVyIGZvcm1cclxuICAgKi9cclxuICB2YWx1ZTogQmlnTnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgbnVtZXJpYyBiYXNlIGZvciB0aGlzIE51bWVyaWMsIGVpdGhlciAxMCBmb3IgZGVjaW1hbCBvciAxNiBmb3IgSGV4XHJcbiAgICovXHJcbiAgYmFzZT86IE51bWVyaWNCYXNlO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgY3VycmVudCBkZW5vbWluYXRpb24sIGlmIGFueS4gVGhlIG9ubHkgc3VwcG9ydGVkIGRlbm9taW5hdGlvbnMgYXJlXHJcbiAgICogRVRILCBHV0VJLCBXRUkuXHJcbiAgICovXHJcbiAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb247XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgdmFsdWU6IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgdGhpcy5iYXNlID0gYmFzZTtcclxuICAgIHRoaXMuZGVub21pbmF0aW9uID0gZGVub21pbmF0aW9uO1xyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCTikge1xyXG4gICAgICB0aGlzLnZhbHVlID0gYm5Ub0JpZ051bWJlcih2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHxcclxuICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB8fFxyXG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gJycpXHJcbiAgICApIHtcclxuICAgICAgLy8gVGhlcmUgYXJlIHBhcnRzIG9mIHRoZSBjb2RlYmFzZSB0aGF0IGNhbGwgdGhpcyBtZXRob2Qgd2l0aG91dCBhIHZhbHVlLFxyXG4gICAgICAvLyBvciB3aXRoIGEgJ05hTicgKHdoaWNoIGlzIHByb2JhYmx5IGEgYnVnIHNvbWV3aGVyZSBpbiBvdXIgdGVzdHM/KS5cclxuICAgICAgLy8gT3ZlciB0aW1lIG9mIGNvbnZlcnRpbmcgdG8gVHlwZVNjcmlwdCB3ZSB3aWxsIGVyYWRpY2F0ZSB0aG9zZSwgYnV0IHRoZVxyXG4gICAgICAvLyBoZWxwZXIgbWV0aG9kcyB0aGF0IHRob3NlIGluc3RhbmNlcyBlbXBsb3kgd291bGQgZGVmYXVsdCB0aGUgdmFsdWUgdG9cclxuICAgICAgLy8gMC4gVGhpcyBibG9jayBrZWVwcyB0aGF0IGludGFjdC5cclxuICAgICAgdGhpcy52YWx1ZSA9IG5ldyBCaWdOdW1iZXIoJzAnLCAxMCk7XHJcbiAgICAgIHRoaXMuYmFzZSA9IDEwO1xyXG4gICAgfSBlbHNlIGlmIChiYXNlKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZVRvQmlnTnVtYmVyKHZhbHVlLCBiYXNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgWW91IG11c3Qgc3BlY2lmeSB0aGUgYmFzZSBvZiB0aGUgcHJvdmlkZWQgbnVtYmVyIGlmIHRoZSB2YWx1ZSBpcyBub3QgYWxyZWFkeSBhIEJpZ051bWJlcmAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIGEgdG9vbCB1c2VkIGludGVybmFsbHkgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhbHJlYWR5IGEgTnVtZXJpY1xyXG4gICAqIGFuZCByZXR1cm4gaXQgaWYgaXQgaXMsIG90aGVyd2lzZSBpdCB1c2VzIHRoZSBvdGhlciBwcm92aWRlZCBhcmd1bWVudHMgdG9cclxuICAgKiBjcmVhdGUgYSBuZXcgTnVtZXJpYy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgTnVtZXJpY1xyXG4gICAqIEBwYXJhbSBiYXNlIC0gRWl0aGVyIHVuZGVmaW5lZCwgMTAgZm9yIGRlY2ltYWwgb3IgMTYgZm9yIGhleGFkZWNpbWFsXHJcbiAgICogQHBhcmFtIGRlbm9taW5hdGlvbiAtIFRoZSBFdGhlciBkZW5vbWluYXRpb24gdG8gc2V0LCBpZiBhbnlcclxuICAgKi9cclxuICBzdGF0aWMgZnJvbShcclxuICAgIHZhbHVlOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1lcmljKSB7XHJcbiAgICAgIGlmIChiYXNlIHx8IGRlbm9taW5hdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBOdW1lcmljLmZyb20gd2FzIGNhbGxlZCB3aXRoIGEgdmFsdWUgKCR7dmFsdWUudG9TdHJpbmcoKX0pIHRoYXQgaXMgYWxyZWFkeSBhIE51bWVyaWMgYnV0IGEgYmFzZSBhbmQvb3IgZGVub21pbmF0aW9uIHdhcyBwcm92aWRlZC4gT25seSBzdXBwbHkgYmFzZSBvciBkZW5vbWluYXRpb24gd2hlbiBjcmVhdGluZyBhIG5ldyBOdW1lcmljYCxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTnVtZXJpYyh2YWx1ZSwgYmFzZSwgZGVub21pbmF0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKiBDb252ZXJzaW9ucyAqL1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IE51bWVyaWMgd2l0aCB0aGUgYmFzZSB2YWx1ZSBjaGFuZ2VkIHRvIHRoZSBwcm92aWRlZCBiYXNlLFxyXG4gICAqIG9yIHRoZSBvcmlnaW5hbCBOdW1lcmljIGlmIHRoZSBiYXNlIHByb3ZpZGVkIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XHJcbiAgICogYmFzZS4gTm8gY29tcHV0YXRpb24gb3IgY29udmVyc2lvbiBoYXBwZW5zIGhlcmUgYnV0IHJhdGhlciB0aGUgcmVzdWx0IG9mXHJcbiAgICogdG9TdHJpbmcgd2lsbCBiZSBjaGFuZ2VkIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgdGhpcy5iYXNlIHdoZW4gdGhhdFxyXG4gICAqIG1ldGhvZCBpcyBpbnZva2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJhc2UgLSBUaGUgbnVtZXJpYyBiYXNlIHRvIGNoYW5nZSB0aGUgTnVtZXJpYyB0bywgZWl0aGVyIDEwIG9yIDE2XHJcbiAgICogQHJldHVybnMgQSBuZXcgTnVtZXJpYyB3aXRoIHRoZSBiYXNlIHVwZGF0ZWRcclxuICAgKi9cclxuICB0b0Jhc2UoYmFzZTogTnVtZXJpY0Jhc2UpIHtcclxuICAgIGlmICh0aGlzLmJhc2UgIT09IGJhc2UpIHtcclxuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljKHRoaXMudmFsdWUsIGJhc2UsIHRoaXMuZGVub21pbmF0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdGhlIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgZGVub21pbmF0aW9uLiBUaGUgZm9sbG93aW5nIHF1aXJrcyBvZlxyXG4gICAqIHRoZSBwcmVkZWNlc3NvciB0byBOdW1lcmljLCAnY29udmVyc2lvblV0aWwnLCB3ZXJlIHByb2dyYW1tZWQgaW50byB0aGlzXHJcbiAgICogbWV0aG9kOlxyXG4gICAqIDEuIFlvdSBtYXkgc3VwcGx5IGEgZGVub21pbmF0aW9uIHRoYXQgaXMgdW5kZWZpbmVkLCB3aGljaCB3aWxsIHJlc3VsdCBpblxyXG4gICAqIG5vdGhpbmcgaGFwcGVuaW5nLiBDb2luY2lkZW50bHkgdGhpcyBpcyBhbHNvIHVzZWZ1bCBkdWUgdG8gdGhlIG5hdHVyZSBvZlxyXG4gICAqIGNoYWluaW5nIG9wZXJhdGlvbnMgb24gTnVtZXJpYy4gWW91IG1heSBwYXNzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGlzXHJcbiAgICogbWV0aG9kIHdpdGhvdXQgYnJlYWtpbmcgdGhlIGNoYWluIHRvIGNvbmRpdGlvbmFsbHkgYXBwbHkgYSBvcGVyYXRvci5cclxuICAgKiAyLiBJZiB0aGUgbnVtZXJpYyB0aGF0IC50b0Rlbm9taW5hdGlvbiBpcyBjYWxsZWQgb24gZG9lcyBub3QgaGF2ZSBhXHJcbiAgICogZGVub21pbmF0aW9uIHNldCwgdGhhdCBpcyBpdCB3YXMgY29uc3RydWN0ZWQgd2l0aG91dCB0aGUgdGhpcmQgcGFyYW1ldGVyLFxyXG4gICAqIHRoZW4gaXQgaXMgYXNzdW1lZCB0byBiZSBpbiBFVEguIE90aGVyd2lzZSB3ZSBjb252ZXJ0IGl0IHRvIEVUSCBwcmlvciB0b1xyXG4gICAqIGF0dGVtcHRpbmcgdG8gY29udmVydCBpdCB0byBhbm90aGVyIGRlbm9taW5hdGlvbiBiZWNhdXNlIGFsbCBvZiB0aGVcclxuICAgKiB0b1NwZWNpZmllZERlbm9taW5hdGlvbiBtZXRob2RzIGFzc3VtZSBhIHZhbHVlIGluIEVUSCBpcyBwYXNzZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGVub21pbmF0aW9uIC0gVGhlIGRlbm9taW5hdGlvbiB0byBjb252ZXJ0IHRvXHJcbiAgICogQHJldHVybnMgQSBuZXcgbnVtZXJpYyB3aXRoIHRoZSBzYW1lIGJhc2UgYXMgdGhlIHByZXZpb3VzLCBidXQgdGhlXHJcbiAgICogdmFsdWUgYW5kIGRlbm9taW5hdGlvbiBjaGFuZ2VkIGFjY29yZGluZ2x5XHJcbiAgICovXHJcbiAgdG9EZW5vbWluYXRpb24oZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24pIHtcclxuICAgIGlmIChkZW5vbWluYXRpb24gJiYgdGhpcy5kZW5vbWluYXRpb24gIT09IGRlbm9taW5hdGlvbikge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgTnVtZXJpYyhcclxuICAgICAgICB0b1NwZWNpZmllZERlbm9taW5hdGlvbltkZW5vbWluYXRpb25dKGdldFZhbHVlSW5FVEgodGhpcykpLFxyXG4gICAgICAgIHRoaXMuYmFzZSxcclxuICAgICAgICBkZW5vbWluYXRpb24sXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcGxpY2F0ZXMgYSBtZXRob2Qgb2YgQmlnTnVtYmVyIHRoYXQgaXMgbm90IGluIHRoZSB2ZXJzaW9uIG9mIEJpZ051bWJlclxyXG4gICAqIHRoYXQgd2UgdXNlIGN1cnJlbnRseS4gRXNzZW50aWFsbHkgc2hpZnRpbmcgdGhlIGRlY2ltYWwgcG9pbnQgYmFja3dhcmRzIGJ5XHJcbiAgICogYW4gYW1vdW50IGVxdWFsIHRvIHRoZSBwb3NpdGl2ZSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIGRlY2ltYWxzIG9wZXJhdG9yLlxyXG4gICAqIEZvciBleGFtcGxlLCBjYWxsaW5nIHNoaWZ0ZWRCeSgxMCkgb24gdGhlIHZhbHVlIDEwMDAwMDAwMDAwIHdpbGwgcmVzdWx0IGluXHJcbiAgICogYSB2YWx1ZSBvZiAxLjAwMDAwMDAwMDAuIElmIHBhc3NpbmcgYSBuZWdhdGl2ZSBudW1iZXIsIHRoZW4gdGhlIGRlY2ltYWxcclxuICAgKiBwb3NpdGlvbiB3aWxsIG1vdmUgZm9yd2FyZC4gMS4wMDAwMDAwMDAwIHNoaWZ0ZWRCeSgtMTApIHlpZWxkcyAxMDAwMDAwMDAwMFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byBtb3ZlLiBQb3NpdGl2ZSBtb3Zlc1xyXG4gICAqIGRlY2ltYWwgYmFja3dhcmRzLCBjcmVhdGluZyBhIHNtYWxsZXIgbnVtYmVyLiBOZWdhdGl2ZSB2YWx1ZXMgbW92ZSB0aGVcclxuICAgKiBkZWNpbWFsIGZvcndhcmRzLCBjcmVhdGluZyBhIGxhcmdlciBudW1iZXIuXHJcbiAgICogQHJldHVybnMgQSBuZXcgbnVtZXJpYyB3aXRoIHRoZSBzYW1lIGJhc2UgYW5kIGRlbm9taW5hdGlvbiBhcyB0aGUgY3VycmVudFxyXG4gICAqIGJ1dCB3aXRoIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNoaWZ0ZWRCeShkZWNpbWFsczogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBwb3dlck9mID0gbmV3IE51bWVyaWMoTWF0aC5wb3coMTAsIGRlY2ltYWxzKSwgMTApO1xyXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlKHBvd2VyT2YpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbGllcyBhIGNvbnZlcnNpb24gcmF0ZSB0byB0aGUgTnVtZXJpYy4gSWYgcmF0ZSBpcyB1bmRlZmluZWQgcmV0dXJucyB0aGVcclxuICAgKiBzYW1lIGluc3RhbmNlIHRoYXQgd2FzIG9wZXJhdGVkIG9uLiBBbGxvd2luZyBhbiB1bmRlZmluZWQgdmFsdWUgbWFrZXNcclxuICAgKiBjaGFpbmluZyB0aGlzIG9wZXJhdG9yIGZlYXNpYmxlIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHRoZSB1c2VyIG9yXHJcbiAgICogc3RhdGUgd2l0aG91dCBtYW5pcHVsYXRpbmcgdGhlIG51bWJlci4gRm9yIGV4YW1wbGU6XHJcbiAgICpcclxuICAgKiBuZXcgTnVtZXJpYyg1LCAxMClcclxuICAgKiAuYXBwbHlDb252ZXJzaW9uUmF0ZShwb3NzaWJseVVuZGVmaW5lZFJhdGUpXHJcbiAgICogLnRvQmFzZSgxNilcclxuICAgKiAudG9TdHJpbmcoKTtcclxuICAgKlxyXG4gICAqIFdpbGwgcmV0dXJuIGEgdmFsaWQgcmVzdWx0IGFzIGxvbmcgYXMgcG9zc2libHlVbmRlZmluZWRSYXRlIGlzIHVuZGVmaW5lZCxcclxuICAgKiBhIEJpZ051bWJlciBvciBhIG51bWJlci4gSW4gc29tZSBhcmVhcyBvZiB0aGUgY29kZWJhc2Ugd2UgY2hlY2sgdG8gc2VlIGlmXHJcbiAgICogdGhlIHRhcmdldCBjdXJyZW5jeSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBjdXJyZW5jeSBiZWZvcmUgYXBwbHlpbmdcclxuICAgKiBhIGNvbnZlcnNpb25SYXRlLiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgbm90IGJ1aWx0IGludG8gTnVtZXJpYyBhbmQgd2lsbFxyXG4gICAqIHJlcXVpcmUgYnJlYWtpbmcgdGhlIGNoYWluIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kOlxyXG4gICAqIGxldCB2YWx1ZSA9IG5ldyBOdW1lcmljKDUsIDEwKTtcclxuICAgKlxyXG4gICAqIGlmIChmcm9tQ3VycmVuY3kgIT09IHRvQ3VycmVuY3kpIHtcclxuICAgKiB2YWx1ZSA9IHZhbHVlLmFwcGx5Q29udmVyc2lvblJhdGUocG9zc2libHlVbmRlZmluZWRSYXRlKTtcclxuICAgKiB9XHJcbiAgICpcclxuICAgKiByZXR1cm4gdmFsdWUudG9CYXNlKDE2KS50b1N0cmluZygpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHJhdGUgLSBUaGUgbXVsdGlwbGllciB0byBhcHBseVxyXG4gICAqIEBwYXJhbSBpbnZlcnQgLSBpZiB0cnVlLCBpbnZlcnRzIHRoZSByYXRlXHJcbiAgICogQHJldHVybnMgTmV3IE51bWVyaWMgdmFsdWUgd2l0aCBjb252ZXJzaW9uIHJhdGUgYXBwbGllZC5cclxuICAgKi9cclxuICBhcHBseUNvbnZlcnNpb25SYXRlKHJhdGU/OiBudW1iZXIgfCBCaWdOdW1iZXIsIGludmVydD86IGJvb2xlYW4pIHtcclxuICAgIGlmICh0eXBlb2YgcmF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbnZlcnNpb25SYXRlID0gbmV3IE51bWVyaWMocmF0ZSwgMTApO1xyXG4gICAgaWYgKGludmVydCkge1xyXG4gICAgICBjb252ZXJzaW9uUmF0ZSA9IG5ldyBOdW1lcmljKG5ldyBCaWdOdW1iZXIoMS4wKSkuZGl2aWRlKGNvbnZlcnNpb25SYXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnRpbWVzKGNvbnZlcnNpb25SYXRlKTtcclxuICB9XHJcblxyXG4gIHJvdW5kKFxyXG4gICAgbnVtYmVyT2ZEZWNpbWFscz86IG51bWJlcixcclxuICAgIHJvdW5kaW5nTW9kZTogbnVtYmVyID0gQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTixcclxuICApIHtcclxuICAgIGlmICh0eXBlb2YgbnVtYmVyT2ZEZWNpbWFscyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljKFxyXG4gICAgICAgIHRoaXMudmFsdWUucm91bmQobnVtYmVyT2ZEZWNpbWFscywgcm91bmRpbmdNb2RlKSxcclxuICAgICAgICB0aGlzLmJhc2UsXHJcbiAgICAgICAgdGhpcy5kZW5vbWluYXRpb24sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86IG1ha2UgaXQgcG9zc2libGUgdG8gYWRkIEVUSCArIEdXRUkgdmFsdWUuIFNvIGlmIHlvdSBoYXZlXHJcbiAgICogTnVtZXJpYyAxIHdpdGggZGVub21pbmF0aW9uIEVUSCBhbmQgTnVtZXJpYyAyIHdpdGggRGVub21pbmF0aW9uIFdFSSxcclxuICAgKiBmaXJzdCBjb252ZXJ0IE51bWVyaWMgMiB0byBFVEggdGhlbiBhZGQgdGhlIGFtb3VudCB0byBOdW1lcmljIDEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFsdWVcclxuICAgKiBAcGFyYW0gYmFzZVxyXG4gICAqIEBwYXJhbSBkZW5vbWluYXRpb25cclxuICAgKi9cclxuICBhZGQoXHJcbiAgICB2YWx1ZTogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgY29uc3QgbnVtZXJpYyA9IE51bWVyaWMuZnJvbSh2YWx1ZSwgYmFzZSwgZGVub21pbmF0aW9uKTtcclxuICAgIHJldHVybiBuZXcgTnVtZXJpYyhcclxuICAgICAgdGhpcy52YWx1ZS5hZGQoYWxpZ25PcGVyYW5kRGVub21pbmF0aW9ucyh0aGlzLCBudW1lcmljKS52YWx1ZSksXHJcbiAgICAgIHRoaXMuYmFzZSxcclxuICAgICAgdGhpcy5kZW5vbWluYXRpb24sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVE9ETzogbWFrZSBpdCBwb3NzaWJsZSB0byBzdWJ0cmFjdCBFVEggLSBHV0VJIHZhbHVlLiBTbyBpZiB5b3UgaGF2ZVxyXG4gICAqIE51bWVyaWMgMSB3aXRoIGRlbm9taW5hdGlvbiBFVEggYW5kIE51bWVyaWMgMiB3aXRoIERlbm9taW5hdGlvbiBXRUksXHJcbiAgICogZmlyc3QgY29udmVydCBOdW1lcmljIDIgdG8gRVRIIHRoZW4gc3VidHJhY3QgdGhlIGFtb3VudCBmcm9tIE51bWVyaWMgMS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAqIEBwYXJhbSBiYXNlXHJcbiAgICogQHBhcmFtIGRlbm9taW5hdGlvblxyXG4gICAqL1xyXG4gIG1pbnVzKFxyXG4gICAgdmFsdWU6IE51bWVyaWMgfCBOdW1lcmljVmFsdWUsXHJcbiAgICBiYXNlPzogTnVtZXJpY0Jhc2UsXHJcbiAgICBkZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbixcclxuICApIHtcclxuICAgIGNvbnN0IG51bWVyaWMgPSBOdW1lcmljLmZyb20odmFsdWUsIGJhc2UsIGRlbm9taW5hdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBOdW1lcmljKFxyXG4gICAgICB0aGlzLnZhbHVlLm1pbnVzKGFsaWduT3BlcmFuZERlbm9taW5hdGlvbnModGhpcywgbnVtZXJpYykudmFsdWUpLFxyXG4gICAgICB0aGlzLmJhc2UsXHJcbiAgICAgIHRoaXMuZGVub21pbmF0aW9uLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHRpbWVzKFxyXG4gICAgbXVsdGlwbGllcjogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgY29uc3QgbXVsdGlwbGllck51bWVyaWMgPSBOdW1lcmljLmZyb20obXVsdGlwbGllciwgYmFzZSwgZGVub21pbmF0aW9uKTtcclxuICAgIHJldHVybiBuZXcgTnVtZXJpYyhcclxuICAgICAgdGhpcy52YWx1ZS50aW1lcyhcclxuICAgICAgICBhbGlnbk9wZXJhbmREZW5vbWluYXRpb25zKHRoaXMsIG11bHRpcGxpZXJOdW1lcmljKS52YWx1ZSxcclxuICAgICAgKSxcclxuICAgICAgdGhpcy5iYXNlLFxyXG4gICAgICB0aGlzLmRlbm9taW5hdGlvbixcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXZpZGVzIHRoZSBOdW1lcmljIGJ5IGFub3RoZXIgc3VwcGxpZWQgTnVtZXJpYywgY2Fycnlpbmcgb3ZlciB0aGUgYmFzZVxyXG4gICAqIGFuZCBkZW5vbWluYXRpb24gZnJvbSB0aGUgY3VycmVudCBOdW1lcmljLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRpdmlzb3IgLSBUaGUgTnVtZXJpYyB0byBkaXZpZGUgdGhpcyBOdW1lcmljIGJ5XHJcbiAgICogQHBhcmFtIGJhc2VcclxuICAgKiBAcGFyYW0gZGVub21pbmF0aW9uXHJcbiAgICogQHJldHVybnMgQSBuZXcgTnVtZXJpYyB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uXHJcbiAgICovXHJcbiAgZGl2aWRlKFxyXG4gICAgZGl2aXNvcjogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgcmV0dXJuIG5ldyBOdW1lcmljKFxyXG4gICAgICB0aGlzLnZhbHVlLmRpdihcclxuICAgICAgICBhbGlnbk9wZXJhbmREZW5vbWluYXRpb25zKFxyXG4gICAgICAgICAgdGhpcyxcclxuICAgICAgICAgIE51bWVyaWMuZnJvbShkaXZpc29yLCBiYXNlLCBkZW5vbWluYXRpb24pLFxyXG4gICAgICAgICkudmFsdWUsXHJcbiAgICAgICksXHJcbiAgICAgIHRoaXMuYmFzZSxcclxuICAgICAgdGhpcy5kZW5vbWluYXRpb24sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ3JlYXRlclRoYW4oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5ncmVhdGVyVGhhbihcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ3JlYXRlclRoYW5PckVxdWFsVG8oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5ncmVhdGVyVGhhbk9yRXF1YWxUbyhcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbGVzc1RoYW4oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sZXNzVGhhbihcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbGVzc1RoYW5PckVxdWFsVG8oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sZXNzVGhhbk9yRXF1YWxUbyhcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaXNOZWdhdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlLmlzTmVnYXRpdmUoKTtcclxuICB9XHJcblxyXG4gIGlzUG9zaXRpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCkgPT09IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgYmFzZSAxNiBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE51bWVyaWMgdGhhdCBpc1xyXG4gICAqIDB4IHByZWZpeGVkLiBUaGlzIG9wZXJhdGlvbiBieXBhc3NlcyB0aGUgY3VycmVudGx5IHNldCBiYXNlIG9mIHRoZVxyXG4gICAqIE51bWVyaWMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyAweCBwcmVmaXhlZCBoZXhzdHJpbmcuXHJcbiAgICovXHJcbiAgdG9QcmVmaXhlZEhleFN0cmluZygpIHtcclxuICAgIHJldHVybiBhZGRIZXhQcmVmaXgodGhpcy52YWx1ZS50b1N0cmluZygxNikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1lcmljLCB1c2luZyB0aGUgY3VycmVudCB2YWx1ZSBvZlxyXG4gICAqIHRoaXMuYmFzZSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIGJlIGEgZGVjaW1hbCBvciBoZXhhZGVjaW1hbCBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1lcmljXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyh0aGlzLmJhc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGZpeGVkLXBvaW50IGRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1lcmljXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGVjaW1hbHMgLSB0aGUgYW1vdW50IG9mIGRlY2ltYWwgcHJlY2lzaW9uIHRvIHVzZSB3aGVuIHJvdW5kaW5nXHJcbiAgICogQHJldHVybnMgQSBmaXhlZCBwb2ludCBkZWNpbWFsIHN0cmluZyByZXByZXNlbmF0aW9uIG9mIHRoZSBOdW1lcmljXHJcbiAgICovXHJcbiAgdG9GaXhlZChkZWNpbWFsczogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b0ZpeGVkKGRlY2ltYWxzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoZSB2YWx1ZSB0byBhIEphdmFTY3JpcHQgTnVtYmVyLCB3aXRoIGFsbCBvZiB0aGUgaW5hY2N1cmFjeSB0aGF0XHJcbiAgICogY291bGQgY29tZSB3aXRoIHRoYXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBKUyBOdW1iZXJcclxuICAgKi9cclxuICB0b051bWJlcigpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvTnVtYmVyKCk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBVdGlsaXR5IEZ1bmN0aW9ucyB0byBzdXBwb3J0IGJyb3dzZXIucnVudGltZSBKYXZhU2NyaXB0IEFQSVxyXG4gKi9cclxuXHJcbmltcG9ydCBicm93c2VyIGZyb20gJ3dlYmV4dGVuc2lvbi1wb2x5ZmlsbCc7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gRXJyb3IgaWYgZXh0ZW5zaW9uLnJ1bnRpbWUubGFzdEVycm9yIGlzIHByZXNlbnRcclxuICogdGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHRoZSBub24tc3RhbmRhcmQgZXJyb3Igb2JqZWN0IHRoYXQncyB1c2VkXHJcbiAqXHJcbiAqIEFjY29yZGluZyB0byB0aGUgZG9jcywgd2UgYXJlIGV4cGVjdGVkIHRvIGNoZWNrIGxhc3RFcnJvciBpbiBydW50aW1lIEFQSSBjYWxsYmFja3M6XHJcbiAqIFwiXHJcbiAqIElmIHlvdSBjYWxsIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IG1heSBzZXQgbGFzdEVycm9yLCB5b3UgYXJlIGV4cGVjdGVkIHRvXHJcbiAqIGNoZWNrIGZvciB0aGUgZXJyb3Igd2hlbiB5b3UgaGFuZGxlIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uLiBJZiBsYXN0RXJyb3IgaGFzIGJlZW5cclxuICogc2V0IGFuZCB5b3UgZG9uJ3QgY2hlY2sgaXQgd2l0aGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgdGhlbiBhbiBlcnJvciB3aWxsIGJlIHJhaXNlZC5cclxuICogXCJcclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9sYXN0RXJyb3J9XHJcbiAqIEByZXR1cm5zIHtFcnJvcnx1bmRlZmluZWR9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tGb3JMYXN0RXJyb3IoKSB7XHJcbiAgY29uc3QgeyBsYXN0RXJyb3IgfSA9IGJyb3dzZXIucnVudGltZTtcclxuICBpZiAoIWxhc3RFcnJvcikge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLy8gaWYgaXQgcXVhY2tzIGxpa2UgYW4gRXJyb3IsIGl0cyBhbiBFcnJvclxyXG4gIGlmIChsYXN0RXJyb3Iuc3RhY2sgJiYgbGFzdEVycm9yLm1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBsYXN0RXJyb3I7XHJcbiAgfVxyXG4gIC8vIHJlcGFpciBpbmNvbXBsZXRlIGVycm9yIG9iamVjdCAoZWcgY2hyb21pdW0gdjc3KVxyXG4gIHJldHVybiBuZXcgRXJyb3IobGFzdEVycm9yLm1lc3NhZ2UpO1xyXG59XHJcblxyXG4vKiogQHJldHVybnMge0Vycm9yfHVuZGVmaW5lZH0gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yTGFzdEVycm9yQW5kTG9nKCkge1xyXG4gIGNvbnN0IGVycm9yID0gY2hlY2tGb3JMYXN0RXJyb3IoKTtcclxuXHJcbiAgaWYgKGVycm9yKSB7XHJcbiAgICBsb2cuZXJyb3IoZXJyb3IpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVycm9yO1xyXG59XHJcblxyXG4vKiogQHJldHVybnMge0Vycm9yfHVuZGVmaW5lZH0gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yTGFzdEVycm9yQW5kV2FybigpIHtcclxuICBjb25zdCBlcnJvciA9IGNoZWNrRm9yTGFzdEVycm9yKCk7XHJcblxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBlcnJvcjtcclxufVxyXG4iLCJ0eXBlIGNvbnRyYWN0ID0ge1xyXG4gIGNvbnRyYWN0Q29kZTogc3RyaW5nIHwgbnVsbDtcclxuICBpc0NvbnRyYWN0QWRkcmVzczogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWFkQWRkcmVzc0FzQ29udHJhY3QgPSBhc3luYyAoXHJcbiAgZXRoUXVlcnk6IHtcclxuICAgIGdldENvZGU6IChhZGRyZXNzOiBzdHJpbmcpID0+IHN0cmluZztcclxuICB9LFxyXG4gIGFkZHJlc3M6IHN0cmluZyxcclxuKTogUHJvbWlzZTxjb250cmFjdD4gPT4ge1xyXG4gIGxldCBjb250cmFjdENvZGU7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnRyYWN0Q29kZSA9IGF3YWl0IGV0aFF1ZXJ5LmdldENvZGUoYWRkcmVzcyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29udHJhY3RDb2RlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlzQ29udHJhY3RBZGRyZXNzID0gY29udHJhY3RDb2RlXHJcbiAgICA/IGNvbnRyYWN0Q29kZSAhPT0gJzB4JyAmJiBjb250cmFjdENvZGUgIT09ICcweDAnXHJcbiAgICA6IGZhbHNlO1xyXG4gIHJldHVybiB7IGNvbnRyYWN0Q29kZSwgaXNDb250cmFjdEFkZHJlc3MgfTtcclxufTtcclxuIiwiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuXHJcbmltcG9ydCB7IGFkZEhleFByZWZpeCwgQk4gfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xyXG5pbXBvcnQgeyBFdGhlckRlbm9taW5hdGlvbiB9IGZyb20gJy4uL2NvbnN0YW50cy9jb21tb24nO1xyXG5pbXBvcnQgeyBOdW1lcmljLCBOdW1lcmljVmFsdWUgfSBmcm9tICcuL051bWVyaWMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY0dXRUlUb0hleFdFSShkZWNHV0VJOiBudW1iZXIpIHtcclxuICByZXR1cm4gbmV3IE51bWVyaWMoZGVjR1dFSSwgMTAsIEV0aGVyRGVub21pbmF0aW9uLkdXRUkpXHJcbiAgICAudG9CYXNlKDE2KVxyXG4gICAgLnRvRGVub21pbmF0aW9uKEV0aGVyRGVub21pbmF0aW9uLldFSSlcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3RIZXhlcyhhSGV4V0VJOiBzdHJpbmcsIGJIZXhXRUk6IHN0cmluZykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhhSGV4V0VJLCAxNilcclxuICAgIC5taW51cyhuZXcgTnVtZXJpYyhiSGV4V0VJLCAxNikpXHJcbiAgICAucm91bmQoNiwgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTilcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkSGV4ZXMoYUhleFdFSTogc3RyaW5nLCBiSGV4V0VJOiBzdHJpbmcpIHtcclxuICByZXR1cm4gbmV3IE51bWVyaWMoYUhleFdFSSwgMTYpXHJcbiAgICAuYWRkKG5ldyBOdW1lcmljKGJIZXhXRUksIDE2KSlcclxuICAgIC5yb3VuZCg2LCBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOKVxyXG4gICAgLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNXRUlUb0RlY0VUSChkZWNXRUk6IHN0cmluZykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhkZWNXRUksIDEwLCBFdGhlckRlbm9taW5hdGlvbi5XRUkpXHJcbiAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxyXG4gICAgLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoZXhXRUlUb0RlY0VUSChoZXhXRUk6IHN0cmluZykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhoZXhXRUksIDE2LCBFdGhlckRlbm9taW5hdGlvbi5XRUkpXHJcbiAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxyXG4gICAgLnRvQmFzZSgxMClcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVjRXRoVG9Db252ZXJ0ZWRDdXJyZW5jeShcclxuICBldGhUb3RhbDogTnVtZXJpY1ZhbHVlLFxyXG4gIGNvbnZlcnRlZEN1cnJlbmN5Pzogc3RyaW5nLFxyXG4gIGNvbnZlcnNpb25SYXRlPzogbnVtYmVyLFxyXG4pIHtcclxuICBsZXQgbnVtZXJpYyA9IG5ldyBOdW1lcmljKGV0aFRvdGFsLCAxMCwgRXRoZXJEZW5vbWluYXRpb24uRVRIKTtcclxuXHJcbiAgaWYgKGNvbnZlcnRlZEN1cnJlbmN5ICE9PSBFdGhlckRlbm9taW5hdGlvbi5FVEgpIHtcclxuICAgIG51bWVyaWMgPSBudW1lcmljLmFwcGx5Q29udmVyc2lvblJhdGUoY29udmVyc2lvblJhdGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bWVyaWMucm91bmQoMik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWlIZXhGcm9tRGVjaW1hbFZhbHVlKHtcclxuICB2YWx1ZSxcclxuICBjb252ZXJzaW9uUmF0ZSA9IDEsXHJcbiAgZnJvbURlbm9taW5hdGlvbixcclxuICBmcm9tQ3VycmVuY3ksXHJcbiAgaW52ZXJ0Q29udmVyc2lvblJhdGUgPSBmYWxzZSxcclxufToge1xyXG4gIHZhbHVlOiBOdW1lcmljVmFsdWU7XHJcbiAgY29udmVyc2lvblJhdGU/OiBudW1iZXI7XHJcbiAgZnJvbURlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uO1xyXG4gIGZyb21DdXJyZW5jeT86IHN0cmluZztcclxuICBpbnZlcnRDb252ZXJzaW9uUmF0ZT86IGJvb2xlYW47XHJcbn0pIHtcclxuICBsZXQgbnVtZXJpYyA9IG5ldyBOdW1lcmljKHZhbHVlLCAxMCwgZnJvbURlbm9taW5hdGlvbik7XHJcbiAgaWYgKGZyb21DdXJyZW5jeSAhPT0gRXRoZXJEZW5vbWluYXRpb24uRVRIKSB7XHJcbiAgICBudW1lcmljID0gbnVtZXJpYy5hcHBseUNvbnZlcnNpb25SYXRlKGNvbnZlcnNpb25SYXRlLCBpbnZlcnRDb252ZXJzaW9uUmF0ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBudW1lcmljLnRvQmFzZSgxNikudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uV0VJKS50b1N0cmluZygpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBCTiBvYmplY3QgdG8gYSBoZXggc3RyaW5nIHdpdGggYSAnMHgnIHByZWZpeFxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXRCbiAtIFRoZSBCTiB0byBjb252ZXJ0IHRvIGEgaGV4IHN0cmluZ1xyXG4gKiBAcmV0dXJucyBBICcweCcgcHJlZml4ZWQgaGV4IHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJuVG9IZXgoaW5wdXRCbjogQk4pIHtcclxuICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0Qm4udG9TdHJpbmcoMTYpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEV0aENvbnZlcnNpb25Gcm9tV2VpSGV4KHtcclxuICB2YWx1ZSxcclxuICBmcm9tQ3VycmVuY3kgPSBFdGhlckRlbm9taW5hdGlvbi5FVEgsXHJcbiAgY29udmVyc2lvblJhdGUsXHJcbiAgbnVtYmVyT2ZEZWNpbWFscyA9IDYsXHJcbn06IHtcclxuICB2YWx1ZTogTnVtZXJpY1ZhbHVlO1xyXG4gIGNvbnZlcnNpb25SYXRlPzogbnVtYmVyO1xyXG4gIGZyb21DdXJyZW5jeT86IEV0aGVyRGVub21pbmF0aW9uIHwgc3RyaW5nO1xyXG4gIG51bWJlck9mRGVjaW1hbHM/OiBudW1iZXI7XHJcbn0pIHtcclxuICBjb25zdCBkZW5vbWluYXRpb25zID0gW1xyXG4gICAgRXRoZXJEZW5vbWluYXRpb24uRVRILFxyXG4gICAgRXRoZXJEZW5vbWluYXRpb24uR1dFSSxcclxuICAgIEV0aGVyRGVub21pbmF0aW9uLldFSSxcclxuICBdO1xyXG5cclxuICBsZXQgbm9uWmVyb0Rlbm9taW5hdGlvbjtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZW5vbWluYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGdldFZhbHVlRnJvbVdlaUhleCh7XHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBjb252ZXJzaW9uUmF0ZSxcclxuICAgICAgZnJvbUN1cnJlbmN5LFxyXG4gICAgICB0b0N1cnJlbmN5OiBmcm9tQ3VycmVuY3ksXHJcbiAgICAgIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgICAgIHRvRGVub21pbmF0aW9uOiBkZW5vbWluYXRpb25zW2ldLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGNvbnZlcnRlZFZhbHVlICE9PSAnMCcgfHwgaSA9PT0gZGVub21pbmF0aW9ucy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIG5vblplcm9EZW5vbWluYXRpb24gPSBgJHtjb252ZXJ0ZWRWYWx1ZX0gJHtkZW5vbWluYXRpb25zW2ldfWA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5vblplcm9EZW5vbWluYXRpb247XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21XZWlIZXgoe1xyXG4gIHZhbHVlLFxyXG4gIGZyb21DdXJyZW5jeSA9IEV0aGVyRGVub21pbmF0aW9uLkVUSCxcclxuICB0b0N1cnJlbmN5LFxyXG4gIGNvbnZlcnNpb25SYXRlLFxyXG4gIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgdG9EZW5vbWluYXRpb24gPSBFdGhlckRlbm9taW5hdGlvbi5FVEgsXHJcbn06IHtcclxuICB2YWx1ZTogTnVtZXJpY1ZhbHVlO1xyXG4gIGZyb21DdXJyZW5jeT86IEV0aGVyRGVub21pbmF0aW9uIHwgc3RyaW5nO1xyXG4gIHRvQ3VycmVuY3k/OiBFdGhlckRlbm9taW5hdGlvbiB8IHN0cmluZztcclxuICBjb252ZXJzaW9uUmF0ZT86IG51bWJlcjtcclxuICBudW1iZXJPZkRlY2ltYWxzPzogbnVtYmVyO1xyXG4gIHRvRGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb247XHJcbn0pIHtcclxuICBsZXQgbnVtZXJpYyA9IG5ldyBOdW1lcmljKHZhbHVlLCAxNiwgRXRoZXJEZW5vbWluYXRpb24uV0VJKTtcclxuICBpZiAoZnJvbUN1cnJlbmN5ICE9PSB0b0N1cnJlbmN5KSB7XHJcbiAgICBudW1lcmljID0gbnVtZXJpYy5hcHBseUNvbnZlcnNpb25SYXRlKGNvbnZlcnNpb25SYXRlKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bWVyaWNcclxuICAgIC50b0Jhc2UoMTApXHJcbiAgICAudG9EZW5vbWluYXRpb24odG9EZW5vbWluYXRpb24pXHJcbiAgICAucm91bmQobnVtYmVyT2ZEZWNpbWFscywgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTilcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VtSGV4ZXMoZmlyc3Q6IHN0cmluZywgLi4uYXJnczogc3RyaW5nW10pIHtcclxuICBjb25zdCBmaXJzdFZhbHVlID0gbmV3IE51bWVyaWMoZmlyc3QsIDE2KTtcclxuICBjb25zdCB0b3RhbCA9IGFyZ3MucmVkdWNlKFxyXG4gICAgKGFjYywgaGV4QW1vdW50KSA9PiBhY2MuYWRkKG5ldyBOdW1lcmljKGhleEFtb3VudCwgMTYpKSxcclxuICAgIGZpcnN0VmFsdWUsXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHRvdGFsLnRvUHJlZml4ZWRIZXhTdHJpbmcoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhleFdFSVRvRGVjR1dFSSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIHwgQmlnTnVtYmVyIHwgQk4pIHtcclxuICByZXR1cm4gbmV3IE51bWVyaWModmFsdWUsIDE2LCBFdGhlckRlbm9taW5hdGlvbi5XRUkpXHJcbiAgICAudG9CYXNlKDEwKVxyXG4gICAgLnRvRGVub21pbmF0aW9uKEV0aGVyRGVub21pbmF0aW9uLkdXRUkpXHJcbiAgICAudG9TdHJpbmcoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY2ltYWxUb0hleChkZWNpbWFsOiBudW1iZXIgfCBzdHJpbmcgfCBCaWdOdW1iZXIgfCBCTikge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhkZWNpbWFsLCAxMCkudG9CYXNlKDE2KS50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9EZWNpbWFsKGhleFZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBCaWdOdW1iZXIgfCBCTikge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhoZXhWYWx1ZSwgMTYpLnRvQmFzZSgxMCkudG9TdHJpbmcoKTtcclxufVxyXG4iLCJpbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuXHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXHJcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cclxuICpcclxuICogVE9ETzogUmVtb3ZlIG9uY2UgdGhpcyBiZWNvbWVzIGF2YWlsYWJsZSBhdCBAbWV0YW1hc2svdXRpbHNcclxuICpcclxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cclxuICogQHJldHVybnMgVHJ1ZSBvciBmYWxzZSwgZGVwZW5kaW5nIG9uIHRoZSByZXN1bHQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcldpdGhNZXNzYWdlKFxyXG4gIGVycm9yOiB1bmtub3duLFxyXG4pOiBlcnJvciBpcyB7IG1lc3NhZ2U6IHN0cmluZyB9IHtcclxuICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2dFcnJvcldpdGhNZXNzYWdlKGVycm9yOiB1bmtub3duKSB7XHJcbiAgaWYgKGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikpIHtcclxuICAgIGxvZy5lcnJvcihlcnJvci5tZXNzYWdlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbG9nLmVycm9yKGVycm9yKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uL2NvbnN0YW50cy90aW1lJztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFuIEhUVFAgcmVxdWVzdCBidXQgdGltaW5nIG91dFxyXG4gKiBhdXRvbWF0aWNhbGx5IGFmdGVyIGEgZGVzaXJlZCBhbW91bnQgb2YgdGltZS5cclxuICpcclxuICogQHBhcmFtIHRpbWVvdXQgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsIHRoZSByZXF1ZXN0IHRpbWVzXHJcbiAqIG91dC5cclxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgcmV0dXJucyBhIHByb21pc2UgdGhhdCBlaXRoZXIgcmVzb2x2ZXNcclxuICogdG8gdGhlIEhUVFAgcmVzcG9uc2Ugb2JqZWN0IG9yIGlzIHJlamVjdGVkIGlmIGEgbmV0d29yayBlcnJvciBpcyBlbmNvdW50ZXJlZFxyXG4gKiBvciB0aGUgcmVxdWVzdCB0aW1lcyBvdXQuXHJcbiAqL1xyXG5jb25zdCBnZXRGZXRjaFdpdGhUaW1lb3V0ID0gbWVtb2l6ZSgodGltZW91dCA9IFNFQ09ORCAqIDMwKSA9PiB7XHJcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHRpbWVvdXQpIHx8IHRpbWVvdXQgPCAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBwb3NpdGl2ZSBpbnRlZ2VyIHRpbWVvdXQuJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoVGltZW91dChcclxuICAgIHVybDogUmVxdWVzdEluZm8sXHJcbiAgICBvcHRzPzogUmVxdWVzdEluaXQsXHJcbiAgKTogUHJvbWlzZTxSZXNwb25zZT4ge1xyXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IHdpbmRvdy5BYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBhYm9ydENvbnRyb2xsZXI7XHJcbiAgICBjb25zdCBmID0gd2luZG93LmZldGNoKHVybCwge1xyXG4gICAgICAuLi5vcHRzLFxyXG4gICAgICBzaWduYWwsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCBmO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldEZldGNoV2l0aFRpbWVvdXQ7XHJcbiIsImltcG9ydCB7XHJcbiAgaXNIZXhTdHJpbmcsXHJcbiAgaXNWYWxpZEFkZHJlc3MsXHJcbiAgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyxcclxuICBhZGRIZXhQcmVmaXgsXHJcbiAgdG9DaGVja3N1bUFkZHJlc3MsXHJcbiAgemVyb0FkZHJlc3MsXHJcbiAgaXNIZXhQcmVmaXhlZCxcclxufSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xyXG5cclxuZXhwb3J0IGNvbnN0IEJVUk5fQUREUkVTUyA9IHplcm9BZGRyZXNzKCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNCdXJuQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpIHtcclxuICByZXR1cm4gYWRkcmVzcyA9PT0gQlVSTl9BRERSRVNTO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGlucHV0IGlzIGEgaGV4IGFkZHJlc3MuIFRoaXMgdXRpbGl0eSBtZXRob2QgaXMgYSB0aGluXHJcbiAqIHdyYXBwZXIgYXJvdW5kIGV0aGVyZXVtanMtdXRpbC5pc1ZhbGlkQWRkcmVzcywgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaXRcclxuICogZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBwcm92aWRlZCB2YWx1ZXMgdGhhdCBhcmUgbm90IGhleCBzdHJpbmdzLiBJblxyXG4gKiBhZGRpdGlvbiwgYW5kIGJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRydWUgZm9yIGhleCBzdHJpbmdzIHRoYXRcclxuICogbWVldCB0aGUgbGVuZ3RoIHJlcXVpcmVtZW50IG9mIGEgaGV4IGFkZHJlc3MsIGJ1dCBhcmUgbm90IHByZWZpeGVkIHdpdGggYDB4YFxyXG4gKiBGaW5hbGx5LCBpZiB0aGUgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gZmxhZyBpcyB0cnVlIGFuZCBhIG1peGVkIGNhc2Ugc3RyaW5nIGlzXHJcbiAqIHByb3ZpZGVkIHRoaXMgbWV0aG9kIHdpbGwgdmFsaWRhdGUgaXQgaGFzIHRoZSBwcm9wZXIgY2hlY2tzdW0gZm9ybWF0dGluZy5cclxuICpcclxuICogQHBhcmFtIHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0XHJcbiAqIEBwYXJhbSBbb3B0aW9uc10gLSBvcHRpb25zIGJhZ1xyXG4gKiBAcGFyYW0gW29wdGlvbnMuYWxsb3dOb25QcmVmaXhlZF0gLSBJZiB0cnVlIHdpbGwgZmlyc3QgZW5zdXJlICcweCdcclxuICogaXMgcHJlcGVuZGVkIHRvIHRoZSBzdHJpbmdcclxuICogQHBhcmFtIFtvcHRpb25zLm1peGVkQ2FzZVVzZUNoZWNrc3VtXSAtIElmIHRydWUgd2lsbCB0cmVhdCBtaXhlZFxyXG4gKiBjYXNlIGFkZHJlc3NlcyBhcyBjaGVja3N1bSBhZGRyZXNzZXMgYW5kIHZhbGlkYXRlIHRoYXQgcHJvcGVyIGNoZWNrc3VtXHJcbiAqIGZvcm1hdCBpcyB1c2VkXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleEFkZHJlc3MoXHJcbiAgcG9zc2libGVBZGRyZXNzOiBzdHJpbmcsXHJcbiAgeyBhbGxvd05vblByZWZpeGVkID0gdHJ1ZSwgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gPSBmYWxzZSB9ID0ge30sXHJcbikge1xyXG4gIGNvbnN0IGFkZHJlc3NUb0NoZWNrID0gYWxsb3dOb25QcmVmaXhlZFxyXG4gICAgPyBhZGRIZXhQcmVmaXgocG9zc2libGVBZGRyZXNzKVxyXG4gICAgOiBwb3NzaWJsZUFkZHJlc3M7XHJcbiAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzVG9DaGVjaykpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChtaXhlZENhc2VVc2VDaGVja3N1bSkge1xyXG4gICAgY29uc3QgcHJlZml4UmVtb3ZlZCA9IGFkZHJlc3NUb0NoZWNrLnNsaWNlKDIpO1xyXG4gICAgY29uc3QgbG93ZXIgPSBwcmVmaXhSZW1vdmVkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCB1cHBlciA9IHByZWZpeFJlbW92ZWQudG9VcHBlckNhc2UoKTtcclxuICAgIGNvbnN0IGFsbE9uZUNhc2UgPSBwcmVmaXhSZW1vdmVkID09PSBsb3dlciB8fCBwcmVmaXhSZW1vdmVkID09PSB1cHBlcjtcclxuICAgIGlmICghYWxsT25lQ2FzZSkge1xyXG4gICAgICByZXR1cm4gaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzVG9DaGVjayk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzc1RvQ2hlY2spO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKSB7XHJcbiAgaWYgKCFhZGRyZXNzKSB7XHJcbiAgICAvLyBvdXIgaW50ZXJuYWwgY2hlY2tzdW1BZGRyZXNzIGZ1bmN0aW9uIHRoYXQgdGhpcyBtZXRob2QgcmVwbGFjZXMgd291bGRcclxuICAgIC8vIHJldHVybiBhbiBlbXB0eSBzdHJpbmcgZm9yIG51bGxpc2ggaW5wdXQuIElmIGFueSBkaXJlY3QgdXNhZ2VzIG9mXHJcbiAgICAvLyBldGhlcmV1bWpzLXV0aWwudG9DaGVja3N1bUFkZHJlc3Mgd2VyZSBjYWxsZWQgd2l0aCBudWxsaXNoIGlucHV0IGl0XHJcbiAgICAvLyB3b3VsZCBoYXZlIHJlc3VsdGVkIGluIGFuIGVycm9yIG9uIHZlcnNpb24gNS4xLlxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBjb25zdCBoZXhQcmVmaXhlZCA9IGFkZEhleFByZWZpeChhZGRyZXNzKTtcclxuICBpZiAoIWlzSGV4U3RyaW5nKGhleFByZWZpeGVkKSkge1xyXG4gICAgLy8gVmVyc2lvbiA1LjEgb2YgZXRoZXJldW1qcy11dGlscyB3b3VsZCBoYXZlIHJldHVybmVkICcweFknIGZvciBpbnB1dCAneSdcclxuICAgIC8vIGJ1dCB3ZSBzaG91bGRuJ3Qgd2FzdGUgZWZmb3J0IHRyeWluZyB0byBjaGFuZ2UgY2FzZSBvbiBhIGNsZWFybHkgaW52YWxpZFxyXG4gICAgLy8gc3RyaW5nLiBJbnN0ZWFkIGp1c3QgcmV0dXJuIHRoZSBoZXggcHJlZml4ZWQgb3JpZ2luYWwgc3RyaW5nIHdoaWNoIG1vc3RcclxuICAgIC8vIGNsb3NlbHkgbWltaWNzIHRoZSBvcmlnaW5hbCBiZWhhdmlvci5cclxuICAgIHJldHVybiBoZXhQcmVmaXhlZDtcclxuICB9XHJcbiAgcmV0dXJuIHRvQ2hlY2tzdW1BZGRyZXNzKGhleFByZWZpeGVkKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cjogc3RyaW5nKSB7XHJcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xyXG59XHJcbiIsImltcG9ydCBicm93c2VyIGZyb20gJ3dlYmV4dGVuc2lvbi1wb2x5ZmlsbCc7XHJcblxyXG5leHBvcnQgY29uc3QgaXNNYW5pZmVzdFYzID1cclxuICBicm93c2VyLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKS5tYW5pZmVzdF92ZXJzaW9uID09PSAzO1xyXG4iLCJpbXBvcnQgeyBDSEFJTl9JRFMsIE1BWF9TQUZFX0NIQUlOX0lEIH0gZnJvbSAnLi4vY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBudW1iZXIgcHJpbWl0aXZlIGNoYWluIElEIGlzIHNhZmUuXHJcbiAqIEJlY2F1c2Ugc29tZSBjcnlwdG9ncmFwaGljIGxpYnJhcmllcyB3ZSB1c2UgZXhwZWN0IHRoZSBjaGFpbiBJRCB0byBiZSBhXHJcbiAqIG51bWJlciBwcmltaXRpdmUsIGl0IG11c3Qgbm90IGV4Y2VlZCBhIGNlcnRhaW4gc2l6ZS5cclxuICpcclxuICogQHBhcmFtIGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgdG8gY2hlY2sgZm9yIHNhZmV0eS5cclxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gY2hhaW4gSUQgaXMgc2FmZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmVDaGFpbklkKGNoYWluSWQ6IHVua25vd24pOiBib29sZWFuIHtcclxuICByZXR1cm4gaXNTYWZlSW50ZWdlcihjaGFpbklkKSAmJiBjaGFpbklkID4gMCAmJiBjaGFpbklkIDw9IE1BWF9TQUZFX0NIQUlOX0lEO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgMHgtcHJlZml4ZWQsIG5vbi16ZXJvLCBub24temVyby1wYWRkZWQsXHJcbiAqIGhleGFkZWNpbWFsIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGNvcnJlY3RseSBmb3JtYXR0ZWQgaGV4IHN0cmluZyxcclxuICogZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcodmFsdWU6IHVua25vd24pIHtcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gL14weFsxLTlhLWZdK1swLTlhLWZdKiQvaXUudGVzdCh2YWx1ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0b2tlbiBkZXRlY3Rpb24gaXMgZW5hYmxlZCBmb3IgY2VydGFpbiBuZXR3b3Jrc1xyXG4gKlxyXG4gKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluSUQgb2YgbmV0d29ya1xyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjdXJyZW50IG5ldHdvcmsgc3VwcG9ydHMgdG9rZW4gZGV0ZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbkRldGVjdGlvbkVuYWJsZWRGb3JOZXR3b3JrKGNoYWluSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xyXG4gIHN3aXRjaCAoY2hhaW5JZCkge1xyXG4gICAgY2FzZSBDSEFJTl9JRFMuTUFJTk5FVDpcclxuICAgIGNhc2UgQ0hBSU5fSURTLkJTQzpcclxuICAgIGNhc2UgQ0hBSU5fSURTLlBPTFlHT046XHJcbiAgICBjYXNlIENIQUlOX0lEUy5BVkFMQU5DSEU6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExpa2Uge0BsaW5rIE51bWJlci5pc1NhZmVJbnRlZ2VyfSwgYnV0IHR5cGVzIHRoZSBpbnB1dCBhcyBhIGBudW1iZXJgIGlmIGl0IGlzXHJcbiAqIGluZGVlZCBhIHNhZmUgaW50ZWdlci5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHNhZmUgaW50ZWdlciwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XHJcbiAgcmV0dXJuIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKTtcclxufVxyXG4iLCIvKipcclxuICogUmV0dXJuIGEgXCJtYXNrZWRcIiBjb3B5IG9mIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBvYmplY3QgaW5jbHVkZXMgb25seSB0aGUgcHJvcGVydGllcyBwcmVzZW50IGluIHRoZSBtYXNrLiBUaGVcclxuICogbWFzayBpcyBhbiBvYmplY3QgdGhhdCBtaXJyb3JzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIG9iamVjdCwgZXhjZXB0XHJcbiAqIHRoZSBvbmx5IHZhbHVlcyBhcmUgYHRydWVgIG9yIGEgc3ViLW1hc2suIGB0cnVlYCBpbXBsaWVzIHRoZSBwcm9wZXJ0eVxyXG4gKiBzaG91bGQgYmUgaW5jbHVkZWQsIGFuZCBhIHN1Yi1tYXNrIGltcGxpZXMgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBmdXJ0aGVyXHJcbiAqIG1hc2tlZCBhY2NvcmRpbmcgdG8gdGhhdCBzdWItbWFzay5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFza1xyXG4gKiBAcGFyYW0ge09iamVjdDxvYmplY3QgfCBib29sZWFuPn0gbWFzayAtIFRoZSBtYXNrIHRvIGFwcGx5IHRvIHRoZSBvYmplY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXNrT2JqZWN0KG9iamVjdCwgbWFzaykge1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZSgoc3RhdGUsIGtleSkgPT4ge1xyXG4gICAgaWYgKG1hc2tba2V5XSA9PT0gdHJ1ZSkge1xyXG4gICAgICBzdGF0ZVtrZXldID0gb2JqZWN0W2tleV07XHJcbiAgICB9IGVsc2UgaWYgKG1hc2tba2V5XSkge1xyXG4gICAgICBzdGF0ZVtrZXldID0gbWFza09iamVjdChvYmplY3Rba2V5XSwgbWFza1trZXldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9LCB7fSk7XHJcbn1cclxuIiwiY29uc3QgTUFYID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcblxyXG5sZXQgaWRDb3VudGVyID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTUFYKTtcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUmFuZG9tSWQoKSB7XHJcbiAgaWRDb3VudGVyICU9IE1BWDtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcclxuICByZXR1cm4gaWRDb3VudGVyKys7XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvbXBhcmUgMiBnaXZlbiBzdHJpbmdzIGFuZCByZXR1cm4gYm9vbGVhblxyXG4gKiBlZzogXCJmb29cIiBhbmQgXCJGT09cIiA9PiB0cnVlXHJcbiAqIGVnOiBcImZvb1wiIGFuZCBcImJhclwiID0+IGZhbHNlXHJcbiAqIGVnOiBcImZvb1wiIGFuZCAxMjMgPT4gZmFsc2VcclxuICpcclxuICogQHBhcmFtIHZhbHVlMSAtIGZpcnN0IHN0cmluZyB0byBjb21wYXJlXHJcbiAqIEBwYXJhbSB2YWx1ZTIgLSBmaXJzdCBzdHJpbmcgdG8gY29tcGFyZVxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIDIgc3RyaW5ncyBhcmUgaWRlbnRpY2FsIHdoZW4gdGhleSBhcmUgbG93ZXJjYXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShcclxuICB2YWx1ZTE6IHN0cmluZyxcclxuICB2YWx1ZTI6IHN0cmluZyxcclxuKTogYm9vbGVhbiB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZTEgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZTIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTEudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUyLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhIG51bWJlciB3aXRoIG1heCBsZW5ndGggdW50aWwgdGhlIHJlc3VsdGluZyBzdHJpbmcgcmVhY2hlcyB0aGUgZ2l2ZW4gbGVuZ3RoXHJcbiAqXHJcbiAqIEBwYXJhbSBudW1cclxuICogQHBhcmFtIG1heExlbmd0aFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXBlbmRaZXJvKG51bTogbnVtYmVyLCBtYXhMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KG1heExlbmd0aCwgJzAnKTtcclxufVxyXG4iLCJpbXBvcnQgeyBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQIH0gZnJvbSAnLi4vY29uc3RhbnRzL3N3YXBzJztcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgYWRkcmVzcyBpcyBzdHJpY3RseSBlcXVhbCB0byB0aGUgYWRkcmVzcyBmb3JcclxuICogdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gb2YgdGhlIHByb3ZpZGVkIGNoYWluLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBzdHJpbmcgdG8gY29tcGFyZSB0byB0aGUgZGVmYXVsdCB0b2tlbiBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkIC0gVGhlIGhleCBlbmNvZGVkIGNoYWluIElEIG9mIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBhZGRyZXNzIGlzIHRoZSBwcm92aWRlZCBjaGFpbidzIGRlZmF1bHQgdG9rZW4gYWRkcmVzc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzKGFkZHJlc3MsIGNoYWluSWQpIHtcclxuICBpZiAoIWFkZHJlc3MgfHwgIWNoYWluSWQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhZGRyZXNzID09PSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5hZGRyZXNzO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN5bWJvbCBpcyBzdHJpY3RseSBlcXVhbCB0byB0aGUgc3ltYm9sIGZvclxyXG4gKiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiBvZiB0aGUgcHJvdmlkZWQgY2hhaW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgLSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUgdG8gdGhlIGRlZmF1bHQgdG9rZW4gc3ltYm9sXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkIC0gVGhlIGhleCBlbmNvZGVkIGNoYWluIElEIG9mIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBzeW1ibCBpcyB0aGUgcHJvdmlkZWQgY2hhaW4ncyBkZWZhdWx0IHRva2VuIHN5bWJvbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2woc3ltYm9sLCBjaGFpbklkKSB7XHJcbiAgaWYgKCFzeW1ib2wgfHwgIWNoYWluSWQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzeW1ib2wgPT09IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVBbY2hhaW5JZF0/LnN5bWJvbDtcclxufVxyXG4iLCJpbXBvcnQgeyBpc0hleFN0cmluZyB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XHJcbmltcG9ydCB7IEludGVyZmFjZSB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2FiaSc7XHJcbmltcG9ydCB7IGFiaUVSQzcyMSwgYWJpRVJDMjAsIGFiaUVSQzExNTUgfSBmcm9tICdAbWV0YW1hc2svbWV0YW1hc2stZXRoLWFiaXMnO1xyXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuaW1wb3J0IHtcclxuICBBc3NldFR5cGUsXHJcbiAgVG9rZW5TdGFuZGFyZCxcclxuICBUcmFuc2FjdGlvblR5cGUsXHJcbn0gZnJvbSAnLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuaW1wb3J0IHsgcmVhZEFkZHJlc3NBc0NvbnRyYWN0IH0gZnJvbSAnLi9jb250cmFjdC11dGlscyc7XHJcbmltcG9ydCB7IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUgfSBmcm9tICcuL3N0cmluZy11dGlscyc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgeyAndHJhbnNmZXInIHwgJ2FwcHJvdmUnIHwgJ3NldGFwcHJvdmFsZm9yYWxsJyB8ICd0cmFuc2ZlcmZyb20nIHwgJ2NvbnRyYWN0SW50ZXJhY3Rpb24nfCAnc2ltcGxlU2VuZCcgfSBJbmZlcnJhYmxlVHJhbnNhY3Rpb25UeXBlc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdFxyXG4gKiBAcHJvcGVydHkge0luZmVycmFibGVUcmFuc2FjdGlvblR5cGVzfSB0eXBlIC0gVGhlIHR5cGUgb2YgdHJhbnNhY3Rpb25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdldENvZGVSZXNwb25zZSAtIFRoZSBjb250cmFjdCBjb2RlLCBpbiBoZXggZm9ybWF0IGlmXHJcbiAqICBpdCBleGlzdHMuICcweDAnIG9yICcweCcgYXJlIGFsc28gaW5kaWNhdG9ycyBvZiBub24tZXhpc3RlbnQgY29udHJhY3RcclxuICogIGNvZGVcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgRXRoZXJzQ29udHJhY3RDYWxsXHJcbiAqIEB0eXBlIG9iamVjdFxyXG4gKiBAcHJvcGVydHkge2FueVtdfSBhcmdzIC0gVGhlIGFyZ3MvcGFyYW1zIHRvIHRoZSBmdW5jdGlvbiBjYWxsLlxyXG4gKiBBbiBhcnJheS1saWtlIG9iamVjdCB3aXRoIG51bWVyaWNhbCBhbmQgc3RyaW5nIGluZGljZXMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2lnbmF0dXJlIC0gVGhlIGZ1bmN0aW9uIHNpZ25hdHVyZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ2hhc2ggLSBUaGUgZnVuY3Rpb24gc2lnbmF0dXJlIGhhc2guXHJcbiAqIEBwcm9wZXJ0eSB7RXRoZXJzQmlnTnVtYmVyfSB2YWx1ZSAtIFRoZSBFVEggdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxsLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9uRnJhZ21lbnR9IGZ1bmN0aW9uRnJhZ21lbnQgLSBUaGUgRXRoZXJzIGZ1bmN0aW9uIGZyYWdtZW50XHJcbiAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdW5jdGlvbi5cclxuICovXHJcblxyXG5jb25zdCBlcmMyMEludGVyZmFjZSA9IG5ldyBJbnRlcmZhY2UoYWJpRVJDMjApO1xyXG5jb25zdCBlcmM3MjFJbnRlcmZhY2UgPSBuZXcgSW50ZXJmYWNlKGFiaUVSQzcyMSk7XHJcbmNvbnN0IGVyYzExNTVJbnRlcmZhY2UgPSBuZXcgSW50ZXJmYWNlKGFiaUVSQzExNTUpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsodHJhbnNhY3Rpb24sIGNoYWluSWQsIG5ldHdvcmtJZCkge1xyXG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5jaGFpbklkID09PSBjaGFpbklkO1xyXG4gIH1cclxuICByZXR1cm4gdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPT09IG5ldHdvcmtJZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgdGhlIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgZmllbGRzIGFyZSBzdXBwbGllZFxyXG4gKiBhbmQgdmFsaWQgaW5wdXRzLiBUaGlzIHdpbGwgcmV0dXJuIGZhbHNlIGZvciBub24gaGV4IHN0cmluZyBpbnB1dHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxyXG4gKiAgdGhlIHRyYW5zYWN0aW9uIHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRyYW5zYWN0aW9uIHVzZXMgdmFsaWQgRUlQMTU1OSBmaWVsZHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0VJUDE1NTlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xyXG4gIHJldHVybiAoXHJcbiAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbj8udHhQYXJhbXM/Lm1heEZlZVBlckdhcykgJiZcclxuICAgIGlzSGV4U3RyaW5nKHRyYW5zYWN0aW9uPy50eFBhcmFtcz8ubWF4UHJpb3JpdHlGZWVQZXJHYXMpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBpZiB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyBmaWVsZHMgYXJlIG5vdFxyXG4gKiBzdXBwbGllZCBhbmQgdGhhdCB0aGUgZ2FzUHJpY2UgZmllbGQgaXMgdmFsaWQgaWYgaXQgaXMgcHJvdmlkZWQuIFRoaXMgd2lsbFxyXG4gKiByZXR1cm4gZmFsc2UgaWYgZ2FzUHJpY2UgaXMgYSBub24gaGV4IHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb25zdGFudHMvdHJhbnNhY3Rpb25cIikuVHJhbnNhY3Rpb25NZXRhfSB0cmFuc2FjdGlvbiAtXHJcbiAqICB0aGUgdHJhbnNhY3Rpb24gdG8gY2hlY2tcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdHJhbnNhY3Rpb24gdXNlcyB2YWxpZCBMZWdhY3kgZmllbGRzIE9SIGxhY2tzXHJcbiAqICBFSVAxNTU5IGZpZWxkc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTGVnYWN5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICByZXR1cm4gKFxyXG4gICAgdHlwZW9mIHRyYW5zYWN0aW9uLnR4UGFyYW1zLm1heEZlZVBlckdhcyA9PT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIHR5cGVvZiB0cmFuc2FjdGlvbi50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICh0eXBlb2YgdHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzUHJpY2UgPT09ICd1bmRlZmluZWQnIHx8XHJcbiAgICAgIGlzSGV4U3RyaW5nKHRyYW5zYWN0aW9uLnR4UGFyYW1zLmdhc1ByaWNlKSlcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIGlmIGEgdHJhbnNhY3Rpb25zIGdhcyBmZWVzIGluIHR4UGFyYW1zIG1hdGNoIHRob3NlIGluIGl0cyBkYXBwU3VnZ2VzdGVkR2FzRmVlcyBwcm9wZXJ0eVxyXG4gKlxyXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbnN0YW50cy90cmFuc2FjdGlvblwiKS5UcmFuc2FjdGlvbk1ldGF9IHRyYW5zYWN0aW9uIC1cclxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBib3RoIHRoZSB0eFBhcmFtcyBhbmQgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgYXJlIG9iamVjdHMgd2l0aCB0cnV0aHkgZ2FzIGZlZSBwcm9wZXJ0aWVzLFxyXG4gKiAgIGFuZCB0aG9zZSBwcm9wZXJ0aWVzIGFyZSBzdHJpY3RseSBlcXVhbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHR4UGFyYW1zQXJlRGFwcFN1Z2dlc3RlZCh0cmFuc2FjdGlvbikge1xyXG4gIGNvbnN0IHsgZ2FzUHJpY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMgfSA9XHJcbiAgICB0cmFuc2FjdGlvbj8udHhQYXJhbXMgfHwge307XHJcbiAgcmV0dXJuIChcclxuICAgIChnYXNQcmljZSAmJiBnYXNQcmljZSA9PT0gdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5nYXNQcmljZSkgfHxcclxuICAgIChtYXhQcmlvcml0eUZlZVBlckdhcyAmJlxyXG4gICAgICBtYXhGZWVQZXJHYXMgJiZcclxuICAgICAgdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT1cclxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyAmJlxyXG4gICAgICB0cmFuc2FjdGlvbj8uZGFwcFN1Z2dlc3RlZEdhc0ZlZXM/Lm1heEZlZVBlckdhcyA9PT0gbWF4RmVlUGVyR2FzKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBkZWNvZGUgdHJhbnNhY3Rpb24gZGF0YSB1c2luZyBBQklzIGZvciB0aHJlZSBkaWZmZXJlbnQgdG9rZW4gc3RhbmRhcmRzOiBFUkMyMCwgRVJDNzIxLCBFUkMxMTU1LlxyXG4gKiBUaGUgZGF0YSB3aWxsIGRlY29kZSBjb3JyZWN0bHkgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGludGVyYWN0aW9uIHdpdGggYSBjb250cmFjdCB0aGF0IG1hdGNoZXMgb25lIG9mIHRoZXNlXHJcbiAqIGNvbnRyYWN0IHN0YW5kYXJkc1xyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YSAtIGVuY29kZWQgdHJhbnNhY3Rpb24gZGF0YVxyXG4gKiBAcmV0dXJucyB7RXRoZXJzQ29udHJhY3RDYWxsIHwgdW5kZWZpbmVkfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YShkYXRhKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBlcmMyMEludGVyZmFjZS5wYXJzZVRyYW5zYWN0aW9uKHsgZGF0YSB9KTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIGlnbm9yZSBhbmQgbmV4dCB0cnkgdG8gcGFyc2Ugd2l0aCBlcmM3MjEgQUJJXHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGVyYzcyMUludGVyZmFjZS5wYXJzZVRyYW5zYWN0aW9uKHsgZGF0YSB9KTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIGlnbm9yZSBhbmQgbmV4dCB0cnkgdG8gcGFyc2Ugd2l0aCBlcmMxMTU1IEFCSVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBlcmMxMTU1SW50ZXJmYWNlLnBhcnNlVHJhbnNhY3Rpb24oeyBkYXRhIH0pO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgLy8gaWdub3JlIGFuZCByZXR1cm4gdW5kZWZpbmVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgY29udHJhY3RDb2RlIG9mIHRoZSB0cmFuc2FjdGlvbiBieSBhbmFseXppbmcgdGhlIHR4UGFyYW1zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gdHhQYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgdHJhbnNhY3Rpb25cclxuICogQHBhcmFtIHtFdGhRdWVyeX0gcXVlcnkgLSBFdGhRdWVyeSBpbnN0YW5jZVxyXG4gKiBAcmV0dXJucyB7SW5mZXJUcmFuc2FjdGlvblR5cGVSZXN1bHR9XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZXJtaW5lVHJhbnNhY3Rpb25Db250cmFjdENvZGUodHhQYXJhbXMsIHF1ZXJ5KSB7XHJcbiAgY29uc3QgeyB0byB9ID0gdHhQYXJhbXM7XHJcbiAgY29uc3QgeyBjb250cmFjdENvZGUgfSA9IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChxdWVyeSwgdG8pO1xyXG4gIHJldHVybiBjb250cmFjdENvZGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRoZSB0cmFuc2FjdGlvbiBieSBhbmFseXppbmcgdGhlIHR4UGFyYW1zLlxyXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBvbmUgb2YgdGhlIHR5cGVzIGRlZmluZWQgaW4gc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbnNcclxuICogSXQgd2lsbCBuZXZlciByZXR1cm4gVFJBTlNBQ1RJT05fVFlQRV9DQU5DRUwgb3IgVFJBTlNBQ1RJT05fVFlQRV9SRVRSWSBhcyB0aGVzZVxyXG4gKiByZXByZXNlbnQgc3BlY2lmaWMgZXZlbnRzIHRoYXQgd2UgY29udHJvbCBmcm9tIHRoZSBleHRlbnNpb24gYW5kIGFyZSBhZGRlZCBtYW51YWxseVxyXG4gKiBhdCB0cmFuc2FjdGlvbiBjcmVhdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHR4UGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcclxuICogQHJldHVybnMge0luZmVyVHJhbnNhY3Rpb25UeXBlUmVzdWx0fVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uVHlwZSh0eFBhcmFtcywgcXVlcnkpIHtcclxuICBjb25zdCB7IGRhdGEsIHRvIH0gPSB0eFBhcmFtcztcclxuICBsZXQgbmFtZTtcclxuICB0cnkge1xyXG4gICAgKHsgbmFtZSB9ID0gZGF0YSAmJiBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEoZGF0YSkpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBsb2cuZGVidWcoJ0ZhaWxlZCB0byBwYXJzZSB0cmFuc2FjdGlvbiBkYXRhLicsIGVycm9yLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIGxldCByZXN1bHQ7XHJcbiAgbGV0IGNvbnRyYWN0Q29kZTtcclxuXHJcbiAgaWYgKGRhdGEgJiYgIXRvKSB7XHJcbiAgICByZXN1bHQgPSBUcmFuc2FjdGlvblR5cGUuZGVwbG95Q29udHJhY3Q7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHsgY29udHJhY3RDb2RlOiByZXN1bHRDb2RlLCBpc0NvbnRyYWN0QWRkcmVzcyB9ID1cclxuICAgICAgYXdhaXQgcmVhZEFkZHJlc3NBc0NvbnRyYWN0KHF1ZXJ5LCB0byk7XHJcblxyXG4gICAgY29udHJhY3RDb2RlID0gcmVzdWx0Q29kZTtcclxuXHJcbiAgICBpZiAoaXNDb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgY29uc3QgaGFzVmFsdWUgPSB0eFBhcmFtcy52YWx1ZSAmJiB0eFBhcmFtcy52YWx1ZSAhPT0gJzB4MCc7XHJcblxyXG4gICAgICBjb25zdCB0b2tlbk1ldGhvZE5hbWUgPSBbXHJcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kQXBwcm92ZSxcclxuICAgICAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RTZXRBcHByb3ZhbEZvckFsbCxcclxuICAgICAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RUcmFuc2ZlcixcclxuICAgICAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RUcmFuc2ZlckZyb20sXHJcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kU2FmZVRyYW5zZmVyRnJvbSxcclxuICAgICAgXS5maW5kKChtZXRob2ROYW1lKSA9PiBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKG1ldGhvZE5hbWUsIG5hbWUpKTtcclxuXHJcbiAgICAgIHJlc3VsdCA9XHJcbiAgICAgICAgZGF0YSAmJiB0b2tlbk1ldGhvZE5hbWUgJiYgIWhhc1ZhbHVlXHJcbiAgICAgICAgICA/IHRva2VuTWV0aG9kTmFtZVxyXG4gICAgICAgICAgOiBUcmFuc2FjdGlvblR5cGUuY29udHJhY3RJbnRlcmFjdGlvbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9IFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgdHlwZTogcmVzdWx0LCBnZXRDb2RlUmVzcG9uc2U6IGNvbnRyYWN0Q29kZSB9O1xyXG59XHJcblxyXG5jb25zdCBJTkZFUlJBQkxFX1RSQU5TQUNUSU9OX1RZUEVTID0gW1xyXG4gIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZEFwcHJvdmUsXHJcbiAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kU2V0QXBwcm92YWxGb3JBbGwsXHJcbiAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXIsXHJcbiAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXJGcm9tLFxyXG4gIFRyYW5zYWN0aW9uVHlwZS5jb250cmFjdEludGVyYWN0aW9uLFxyXG4gIFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kLFxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgdHJhbnNhY3Rpb24gbWV0YSBvYmplY3QsIGRldGVybWluZSB0aGUgYXNzZXQgdHlwZSB0aGF0IHRoZVxyXG4gKiB0cmFuc2FjdGlvbiBpcyBkZWFsaW5nIHdpdGgsIGFzIHdlbGwgYXMgdGhlIHN0YW5kYXJkIGZvciB0aGUgdG9rZW4gaWYgaXRcclxuICogaXMgYSB0b2tlbiB0cmFuc2FjdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvbnN0YW50cy90cmFuc2FjdGlvbicpLlRyYW5zYWN0aW9uTWV0YX0gdHhNZXRhIC1cclxuICogIHRyYW5zYWN0aW9uIG1ldGEgb2JqZWN0XHJcbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMgLSBmdW5jdGlvbiB0byBnZXQgdG9rZW5cclxuICogIHN0YW5kYXJkcyBhbmQgZGV0YWlscy5cclxuICogQHJldHVybnMge3sgYXNzZXRUeXBlOiBzdHJpbmcsIHRva2VuU3RhbmRhcmQ6IHN0cmluZ319XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZXJtaW5lVHJhbnNhY3Rpb25Bc3NldFR5cGUoXHJcbiAgdHhNZXRhLFxyXG4gIHF1ZXJ5LFxyXG4gIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzLFxyXG4pIHtcclxuICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gdHlwZSBpcyBhbHJlYWR5IG9uZSBvZiB0aGUgaW5mZXJyYWJsZSB0eXBlcywgdGhlbiB3ZSBkb1xyXG4gIC8vIG5vdCBuZWVkIHRvIHJlLWVzdGFibGlzaCB0aGUgdHlwZS5cclxuICBsZXQgaW5mZXJyYWJsZVR5cGUgPSB0eE1ldGEudHlwZTtcclxuICBpZiAoSU5GRVJSQUJMRV9UUkFOU0FDVElPTl9UWVBFUy5pbmNsdWRlcyh0eE1ldGEudHlwZSkgPT09IGZhbHNlKSB7XHJcbiAgICAvLyBCZWNhdXNlIHdlIHdpbGwgZGVhbCB3aXRoIGFsbCB0eXBlcyBvZiB0cmFuc2FjdGlvbnMgKGluY2x1ZGluZyBzd2FwcylcclxuICAgIC8vIHdlIHdhbnQgdG8gZ2V0IGFuIGluZmVycmFibGUgdHlwZSBvZiB0cmFuc2FjdGlvbiB0aGF0IGlzbid0IHNwZWNpYWwgY2FzZWRcclxuICAgIC8vIHRoYXQgd2F5IHdlIGNhbiBuYXJyb3cgdGhlIG51bWJlciBvZiBsb2dpYyBnYXRlcyByZXF1aXJlZC5cclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRldGVybWluZVRyYW5zYWN0aW9uVHlwZSh0eE1ldGEudHhQYXJhbXMsIHF1ZXJ5KTtcclxuICAgIGluZmVycmFibGVUeXBlID0gcmVzdWx0LnR5cGU7XHJcbiAgfVxyXG5cclxuICAvLyBJZiB0aGUgaW5mZXJyZWQgdHlwZSBvZiB0aGUgdHJhbnNhY3Rpb24gaXMgb25lIG9mIHRob3NlIHRoYXQgYXJlIHBhcnQgb2ZcclxuICAvLyB0aGUgdG9rZW4gY29udHJhY3Qgc3RhbmRhcmRzLCB3ZSBjYW4gdXNlIHRoZSBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlsc1xyXG4gIC8vIG1ldGhvZCB0byBnZXQgdGhlIGFzc2V0IHR5cGUuXHJcbiAgY29uc3QgaXNUb2tlbk1ldGhvZCA9IFtcclxuICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZEFwcHJvdmUsXHJcbiAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RTZXRBcHByb3ZhbEZvckFsbCxcclxuICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFRyYW5zZmVyLFxyXG4gICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXJGcm9tLFxyXG4gIF0uZmluZCgobWV0aG9kTmFtZSkgPT4gbWV0aG9kTmFtZSA9PT0gaW5mZXJyYWJsZVR5cGUpO1xyXG5cclxuICBpZiAoXHJcbiAgICBpc1Rva2VuTWV0aG9kIHx8XHJcbiAgICAvLyBXZSBjYW4gYWxzbyBjaGVjayBhbnkgY29udHJhY3QgaW50ZXJhY3Rpb24gdHlwZSB0byBzZWUgaWYgdGhlIHRvIGFkZHJlc3NcclxuICAgIC8vIGlzIGEgdG9rZW4gY29udHJhY3QuIElmIGl0IGlzbid0LCB0aGVuIHRoZSBtZXRob2Qgd2lsbCB0aHJvdyBhbmQgd2UgY2FuXHJcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIG90aGVyIGNoZWNrcy5cclxuICAgIGluZmVycmFibGVUeXBlID09PSBUcmFuc2FjdGlvblR5cGUuY29udHJhY3RJbnRlcmFjdGlvblxyXG4gICkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhIGJhbGFuY2UgY2hlY2ssIHNvIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvXHJcbiAgICAgIC8vIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzIGlzIG9taXR0ZWQuXHJcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBhd2FpdCBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyh0eE1ldGEudHhQYXJhbXMudG8pO1xyXG4gICAgICBpZiAoZGV0YWlscy5zdGFuZGFyZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBhc3NldFR5cGU6XHJcbiAgICAgICAgICAgIGRldGFpbHMuc3RhbmRhcmQgPT09IFRva2VuU3RhbmRhcmQuRVJDMjBcclxuICAgICAgICAgICAgICA/IEFzc2V0VHlwZS50b2tlblxyXG4gICAgICAgICAgICAgIDogQXNzZXRUeXBlLk5GVCxcclxuICAgICAgICAgIHRva2VuU3RhbmRhcmQ6IGRldGFpbHMuc3RhbmRhcmQsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIG5vb3AsIFdlIGV4cGVjdCBlcnJvcnMgaGVyZSBidXQgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgdGhlbSBvciBkb1xyXG4gICAgICAvLyBhbnl0aGluZyBpbiByZXNwb25zZS5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBpcyBpbnRlcmFjdGluZyB3aXRoIGEgY29udHJhY3QgYnV0IGlzbid0IGEgdG9rZW4gbWV0aG9kXHJcbiAgLy8gd2UgdXNlIHRoZSAnVU5LTk9XTicgdmFsdWUgdG8gc2hvdyB0aGF0IGl0IGlzbid0IGEgdHJhbnNhY3Rpb24gc2VuZGluZyBhbnlcclxuICAvLyBwYXJ0aWN1bGFyIGFzc2V0LlxyXG4gIGlmIChpbmZlcnJhYmxlVHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLmNvbnRyYWN0SW50ZXJhY3Rpb24pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFzc2V0VHlwZTogQXNzZXRUeXBlLnVua25vd24sXHJcbiAgICAgIHRva2VuU3RhbmRhcmQ6IFRva2VuU3RhbmRhcmQubm9uZSxcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiB7IGFzc2V0VHlwZTogQXNzZXRUeXBlLm5hdGl2ZSwgdG9rZW5TdGFuZGFyZDogVG9rZW5TdGFuZGFyZC5ub25lIH07XHJcbn1cclxuIiwiLy8gTWVzc2FnZXMgYW5kIGRlc2NyaXB0aW9ucyBmb3IgdGhlc2UgbG9jYWxlIGtleXMgYXJlIGluIGFwcC9fbG9jYWxlcy9lbi9tZXNzYWdlcy5qc29uXHJcbmV4cG9ydCBjb25zdCBVSV9OT1RJRklDQVRJT05TID0ge1xyXG4gIDE6IHtcclxuICAgIGlkOiAxLFxyXG4gICAgZGF0ZTogJzIwMjEtMDMtMTcnLFxyXG4gICAgaW1hZ2U6IHtcclxuICAgICAgc3JjOiAnaW1hZ2VzL21vYmlsZS1saW5rLXFyLnN2ZycsXHJcbiAgICAgIGhlaWdodDogJzIzMHB4JyxcclxuICAgICAgd2lkdGg6ICcyMzBweCcsXHJcbiAgICAgIHBsYWNlSW1hZ2VCZWxvd0Rlc2NyaXB0aW9uOiB0cnVlLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIDM6IHtcclxuICAgIGlkOiAzLFxyXG4gICAgZGF0ZTogJzIwMjEtMDMtMDgnLFxyXG4gIH0sXHJcbiAgNDoge1xyXG4gICAgaWQ6IDQsXHJcbiAgICBkYXRlOiAnMjAyMS0wNS0xMScsXHJcbiAgICBpbWFnZToge1xyXG4gICAgICBzcmM6ICdpbWFnZXMvc291cmNlLWxvZ29zLWJzYy5zdmcnLFxyXG4gICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIDU6IHtcclxuICAgIGlkOiA1LFxyXG4gICAgZGF0ZTogJzIwMjEtMDYtMDknLFxyXG4gIH0sXHJcbiAgNjoge1xyXG4gICAgaWQ6IDYsXHJcbiAgICBkYXRlOiAnMjAyMS0wNS0yNicsXHJcbiAgfSxcclxuICA3OiB7XHJcbiAgICBpZDogNyxcclxuICAgIGRhdGU6ICcyMDIxLTA5LTE3JyxcclxuICB9LFxyXG4gIDg6IHtcclxuICAgIGlkOiA4LFxyXG4gICAgZGF0ZTogJzIwMjEtMTEtMDEnLFxyXG4gIH0sXHJcbiAgOToge1xyXG4gICAgaWQ6IDksXHJcbiAgICBkYXRlOiAnMjAyMS0xMi0wNycsXHJcbiAgICBpbWFnZToge1xyXG4gICAgICBzcmM6ICdpbWFnZXMvdHhpbnNpZ2h0cy5wbmcnLFxyXG4gICAgICB3aWR0aDogJzgwJScsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgMTA6IHtcclxuICAgIGlkOiAxMCxcclxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy90b2tlbi1kZXRlY3Rpb24uc3ZnJyxcclxuICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgIH0sXHJcbiAgfSxcclxuICAxMToge1xyXG4gICAgaWQ6IDExLFxyXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxyXG4gIH0sXHJcbiAgMTI6IHtcclxuICAgIGlkOiAxMixcclxuICAgIGRhdGU6ICcyMDIyLTA1LTE4JyxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy9kYXJrbW9kZS1iYW5uZXIucG5nJyxcclxuICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgIH0sXHJcbiAgfSxcclxuICAxMzoge1xyXG4gICAgaWQ6IDEzLFxyXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxyXG4gIH0sXHJcbiAgMTQ6IHtcclxuICAgIGlkOiAxNCxcclxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcclxuICB9LFxyXG4gIDE1OiB7XHJcbiAgICBpZDogMTUsXHJcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXHJcbiAgfSxcclxuICAxNjoge1xyXG4gICAgaWQ6IDE2LFxyXG4gICAgZGF0ZTogbnVsbCxcclxuICB9LFxyXG4gIDE3OiB7XHJcbiAgICBpZDogMTcsXHJcbiAgICBkYXRlOiBudWxsLFxyXG4gIH0sXHJcbiAgMTg6IHtcclxuICAgIGlkOiAxOCxcclxuICAgIGRhdGU6IG51bGwsXHJcbiAgICBpbWFnZToge1xyXG4gICAgICBzcmM6ICdpbWFnZXMvb3Blbi1zZWEtc2VjdXJpdHktcHJvdmlkZXIuc3ZnJyxcclxuICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgIH0sXHJcbiAgfSxcclxuICAxOToge1xyXG4gICAgaWQ6IDE5LFxyXG4gICAgZGF0ZTogbnVsbCxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy9uZnRzLnN2ZycsXHJcbiAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgMjA6IHtcclxuICAgIGlkOiAyMCxcclxuICAgIGRhdGU6IG51bGwsXHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUcmFuc2xhdGVkVUlOb3RpZmljYXRpb25zID0gKHQsIGxvY2FsZSkgPT4ge1xyXG4gIGNvbnN0IGZvcm1hdHRlZExvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKCdfJywgJy0nKTtcclxuICByZXR1cm4ge1xyXG4gICAgMToge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzFdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczFUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczFEZXNjcmlwdGlvbicpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzFdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDM6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1szXSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMzVGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMzRGVzY3JpcHRpb24nKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczNBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbM10uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgNDoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzRdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczRUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczREZXNjcmlwdGlvbicpLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zNEFjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s0XS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICA1OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbNV0sXHJcbiAgICAgIHRpdGxlOiB0KCdzZWNyZXRSZWNvdmVyeVBocmFzZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczVEZXNjcmlwdGlvbicpLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zM0FjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s1XS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICA2OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbNl0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zNlRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBbXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczZEZXNjcmlwdGlvbk9uZScpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM2RGVzY3JpcHRpb25Ud28nKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zNkRlc2NyaXB0aW9uVGhyZWUnKSxcclxuICAgICAgXSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s2XS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICA3OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbN10sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zN1RpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBbXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczdEZXNjcmlwdGlvbk9uZScpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM3RGVzY3JpcHRpb25Ud28nKSxcclxuICAgICAgXSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s3XS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICA4OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbOF0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zOFRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBbXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczhEZXNjcmlwdGlvbk9uZScpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM4RGVzY3JpcHRpb25Ud28nKSxcclxuICAgICAgXSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s4XS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczhBY3Rpb25UZXh0JyksXHJcbiAgICB9LFxyXG4gICAgOToge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzldLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczlUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogW1xyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM5RGVzY3JpcHRpb25PbmUnKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zOURlc2NyaXB0aW9uVHdvJyksXHJcbiAgICAgIF0sXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbOV0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgMTA6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxMF0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTBUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogW1xyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxMERlc2NyaXB0aW9uT25lJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczEwRGVzY3JpcHRpb25Ud28nKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zMTBEZXNjcmlwdGlvblRocmVlJyksXHJcbiAgICAgIF0sXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxMEFjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxMF0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgMTE6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxMV0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTFUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczExRGVzY3JpcHRpb24nKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxMV0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgMTI6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxMl0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTJUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczEyRGVzY3JpcHRpb24nKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczEyQWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzEyXS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICAxMzoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzEzXSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxM1RpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTNEZXNjcmlwdGlvbicpLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTNBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTNdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDE0OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTRdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczE0VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxNERlc2NyaXB0aW9uJyksXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxNEFjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogVUlfTk9USUZJQ0FUSU9OU1sxNF0uZGF0ZVxyXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTRdLmRhdGUpLFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogJycsXHJcbiAgICB9LFxyXG4gICAgMTU6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxNV0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTVUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczE1RGVzY3JpcHRpb24nKSxcclxuICAgICAgZGF0ZTogVUlfTk9USUZJQ0FUSU9OU1sxNV0uZGF0ZVxyXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTVdLmRhdGUpLFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogJycsXHJcbiAgICB9LFxyXG4gICAgMTg6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxOF0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMThUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogW1xyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxOERlc2NyaXB0aW9uT25lJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczE4RGVzY3JpcHRpb25Ud28nKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zMThEZXNjcmlwdGlvblRocmVlJyksXHJcbiAgICAgIF0sXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxOEFjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogVUlfTk9USUZJQ0FUSU9OU1sxOF0uZGF0ZVxyXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMThdLmRhdGUpLFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogJycsXHJcbiAgICB9LFxyXG5cclxuICAgIDE5OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTldLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczE5VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zMTlEZXNjcmlwdGlvbk9uZScpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxOURlc2NyaXB0aW9uVHdvJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczE5RGVzY3JpcHRpb25UaHJlZScpLFxyXG4gICAgICBdLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTlBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IFVJX05PVElGSUNBVElPTlNbMTldLmRhdGVcclxuICAgICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzE5XS5kYXRlKSxcclxuICAgICAgICAgIClcclxuICAgICAgICA6ICcnLFxyXG4gICAgfSxcclxuICAgIDIwOiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMjBdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczIwVGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFt0KCdub3RpZmljYXRpb25zMjBEZXNjcmlwdGlvbicpXSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczIwQWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzIwXS5kYXRlXHJcbiAgICAgICAgPyBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1syMF0uZGF0ZSksXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiAnJyxcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuIiwiZXhwb3J0IGNvbnN0IFBSSU1BUlkgPSAnUFJJTUFSWSc7XHJcbmV4cG9ydCBjb25zdCBTRUNPTkRBUlkgPSAnU0VDT05EQVJZJztcclxuXHJcbmNvbnN0IF9jb250cmFjdEFkZHJlc3NMaW5rID1cclxuICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMjAwMjgwOTItV2hhdC1pcy10aGUta25vd24tY29udHJhY3QtYWRkcmVzcy13YXJuaW5nLSc7XHJcblxyXG5cblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcclxuZXhwb3J0IGNvbnN0IFNVUFBPUlRfUkVRVUVTVF9MSU5LID0gcHJvY2Vzcy5lbnYuU1VQUE9SVF9SRVFVRVNUX0xJTks7XHJcbmV4cG9ydCBjb25zdCBDT05UUkFDVF9BRERSRVNTX0xJTksgPSBfY29udHJhY3RBZGRyZXNzTGluaztcclxuZXhwb3J0IGNvbnN0IFBBU1NXT1JEX01JTl9MRU5HVEggPSA4O1xyXG5leHBvcnQgY29uc3QgT1VUREFURURfQlJPV1NFUl9WRVJTSU9OUyA9IHtcclxuICAvLyBDaHJvbWUgYW5kIEVkZ2Ugc2hvdWxkIG1hdGNoIHRoZSBsYXRlc3QgQ2hyb21lIHZlcnNpb24gcmVsZWFzZWQgfjIgeWVhcnMgYWdvXHJcbiAgY2hyb21lOiAnPDkwJyxcclxuICBlZGdlOiAnPDkwJyxcclxuICAvLyBGaXJlZm94IHNob3VsZCBtYXRjaCB0aGUgbW9zdCByZWNlbnQgZW5kLW9mLWxpZmUgZXh0ZW5kZWQgc3VwcG9ydCByZWxlYXNlXHJcbiAgZmlyZWZveDogJzw5MScsXHJcbiAgLy8gT3BlcmEgc2hvdWxkIGJlIHNldCB0byB0aGUgZXF1aXZhbGVudCBvZiB0aGUgQ2hyb21lIHZlcnNpb24gc2V0XHJcbiAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hpc3Rvcnlfb2ZfdGhlX09wZXJhX3dlYl9icm93c2VyXHJcbiAgb3BlcmE6ICc8NzYnLFxyXG59O1xyXG4iLCJcblxuXHJcbmNvbnN0IGFzc2V0TGlzdCA9IHtcclxuICBtYWluOiB7XHJcbiAgICAvLyBXaWxsIHVzZSBkZWZhdWx0IHByb3ZpZGVkIGJ5IHRoZSBAbWV0YW1hc2svbG9nbyBsaWJyYXJ5XHJcbiAgICBmb3hNZXNoSnNvbjogdW5kZWZpbmVkLFxyXG4gIH0sXHJcblxuXG5cbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNCZXRhKCkge1xyXG4gIHJldHVybiBwcm9jZXNzLmVudi5NRVRBTUFTS19CVUlMRF9UWVBFID09PSAnYmV0YSc7XHJcbn1cclxuXHJcbi8vIFJldHVybnMgYSBzcGVjaWZpYyB2ZXJzaW9uIG9mIGFuIGFzc2V0IGJhc2VkIG9uXHJcbi8vIHRoZSBjdXJyZW50IG1ldGFtYXNrIHZlcnNpb24gKGkuZS4gbWFpbiwgYmV0YSwgZXRjLilcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1aWxkU3BlY2lmaWNBc3NldChhc3NldE5hbWUpIHtcclxuICBjb25zdCBidWlsZFR5cGUgPSBwcm9jZXNzLmVudi5NRVRBTUFTS19CVUlMRF9UWVBFO1xyXG4gIGlmIChcclxuICAgICFhc3NldExpc3RbYnVpbGRUeXBlXSB8fFxyXG4gICAgIU9iamVjdC5rZXlzKGFzc2V0TGlzdFtidWlsZFR5cGVdKS5pbmNsdWRlcyhhc3NldE5hbWUpXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICBgQ2Fubm90IGZpbmQgYXNzZXQgXCIke2Fzc2V0TmFtZX1cIiBmb3IgYnVpbGQgXCIke2J1aWxkVHlwZX1cIiwgcmV0dXJuaW5nIG1haW4gYnVpbGQgYXNzZXQuYCxcclxuICAgICk7XHJcbiAgICByZXR1cm4gYXNzZXRMaXN0Lm1haW5bYXNzZXROYW1lXTtcclxuICB9XHJcbiAgcmV0dXJuIGFzc2V0TGlzdFtidWlsZFR5cGVdW2Fzc2V0TmFtZV07XHJcbn1cclxuIiwiaW1wb3J0IHsgb21pdCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IEJOIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHsgQ29tbW9uLCBIYXJkZm9yayB9IGZyb20gJ0BldGhlcmV1bWpzL2NvbW1vbic7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9IGZyb20gJ0BldGhlcmV1bWpzL3R4JztcclxuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xyXG5cclxuZnVuY3Rpb24gYnVpbGRUeFBhcmFtcyh0eE1ldGEpIHtcclxuICByZXR1cm4ge1xyXG4gICAgLi4ub21pdCh0eE1ldGEudHhQYXJhbXMsICdnYXMnKSxcclxuICAgIGdhc0xpbWl0OiB0eE1ldGEudHhQYXJhbXMuZ2FzLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKSB7XHJcbiAgLy8gVGhpcyBwcm9kdWNlcyBhIHRyYW5zYWN0aW9uIHdob3NlIGluZm9ybWF0aW9uIGRvZXMgbm90IGNvbXBsZXRlbHkgbWF0Y2ggYW5cclxuICAvLyBPcHRpbWlzbSB0cmFuc2FjdGlvbiDigJQgZm9yIGluc3RhbmNlLCBERUZBVUxUX0NIQUlOIGlzIHN0aWxsICdtYWlubmV0JyBhbmRcclxuICAvLyBnZW5lc2lzIHBvaW50cyB0byB0aGUgbWFpbm5ldCBnZW5lc2lzLCBub3QgdGhlIE9wdGltaXNtIGdlbmVzaXMg4oCUIGJ1dFxyXG4gIC8vIGNvbnNpZGVyaW5nIHRoYXQgYWxsIHdlIHdhbnQgdG8gZG8gaXMgc2VyaWFsaXplIGEgdHJhbnNhY3Rpb24sIHRoaXMgd29ya3NcclxuICAvLyBmaW5lIGZvciBvdXIgdXNlIGNhc2UuXHJcbiAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xyXG4gICAgY2hhaW5JZDogbmV3IEJOKHN0cmlwSGV4UHJlZml4KHR4TWV0YS5jaGFpbklkKSwgMTYpLFxyXG4gICAgbmV0d29ya0lkOiBuZXcgQk4odHhNZXRhLm1ldGFtYXNrTmV0d29ya0lkLCAxMCksXHJcbiAgICAvLyBPcHRpbWlzbSBvbmx5IHN1cHBvcnRzIHR5cGUtMCB0cmFuc2FjdGlvbnM7IGl0IGRvZXMgbm90IHN1cHBvcnQgYW55IG9mXHJcbiAgICAvLyB0aGUgbmV3ZXIgRUlQcyBzaW5jZSBFSVAtMTU1LiBTb3VyY2U6XHJcbiAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtLW9wdGltaXNtL29wdGltaXNtL2Jsb2IvZGV2ZWxvcC9zcGVjcy9sMmdldGgvdHJhbnNhY3Rpb24tdHlwZXMubWQ+XHJcbiAgICBkZWZhdWx0SGFyZGZvcms6IEhhcmRmb3JrLlNwdXJpb3VzRHJhZ29uLFxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uKHR4TWV0YSkge1xyXG4gIGNvbnN0IHR4UGFyYW1zID0gYnVpbGRUeFBhcmFtcyh0eE1ldGEpO1xyXG4gIGNvbnN0IGNvbW1vbiA9IGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKTtcclxuICByZXR1cm4gVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhQYXJhbXMsIHsgY29tbW9uIH0pO1xyXG59XHJcbiIsImltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJztcclxuaW1wb3J0IHsgV2ViM1Byb3ZpZGVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJztcclxuaW1wb3J0IGJ1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24gZnJvbSAnLi9idWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uJztcclxuXHJcbi8vIFNuaXBwZXQgb2YgdGhlIEFCSSB0aGF0IHdlIG5lZWRcclxuLy8gU2hvdWxkIHdlIG5lZWQgbW9yZSBvZiBpdCBhdCBzb21lIHBvaW50LCB0aGUgZnVsbCBBQkkgY2FuIGJlIGZvdW5kIGhlcmU6XHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS1vcHRpbWlzbS9vcHRpbWlzbS9ibG9iL2RldmVsb3AvZ2FzLW9yYWNsZS9hYmlzL09WTV9HYXNQcmljZU9yYWNsZS5qc29uXHJcbmNvbnN0IE9QVElNSVNNX0dBU19QUklDRV9PUkFDTEVfQUJJID0gW1xyXG4gIHtcclxuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLCBuYW1lOiAnX2RhdGEnLCB0eXBlOiAnYnl0ZXMnIH1dLFxyXG4gICAgbmFtZTogJ2dldEwxRmVlJyxcclxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogJ3VpbnQyNTYnLCBuYW1lOiAnJywgdHlwZTogJ3VpbnQyNTYnIH1dLFxyXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXHJcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxyXG4gIH0sXHJcbl07XHJcblxyXG4vLyBCbG9ja0V4cGxvcmVyIGxpbms6IGh0dHBzOi8vb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW8vYWRkcmVzcy8weDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGYjY29kZVxyXG5jb25zdCBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FERFJFU1MgPVxyXG4gICcweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEYnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hFc3RpbWF0ZWRMMUZlZShcclxuICBjaGFpbklkLFxyXG4gIHR4TWV0YSxcclxuICBldGhlcnNQcm92aWRlcixcclxuKSB7XHJcbiAgY29uc3QgbmV0d29ya0lkID0gTnVtYmVyKGNoYWluSWQpO1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gZ2xvYmFsLmV0aGVyZXVtUHJvdmlkZXJcclxuICAgID8gbmV3IFdlYjNQcm92aWRlcihnbG9iYWwuZXRoZXJldW1Qcm92aWRlciwgbmV0d29ya0lkKVxyXG4gICAgOiBldGhlcnNQcm92aWRlcjtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52LklOX1RFU1QpIHtcclxuICAgIHByb3ZpZGVyLmRldGVjdE5ldHdvcmsgPSBhc3luYyAoKSA9PiAoe1xyXG4gICAgICBuYW1lOiAnb3B0aW1pc20nLFxyXG4gICAgICBjaGFpbklkOiBuZXR3b3JrSWQsXHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXHJcbiAgICBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FERFJFU1MsXHJcbiAgICBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FCSSxcclxuICAgIHByb3ZpZGVyLFxyXG4gICk7XHJcbiAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID1cclxuICAgIGJ1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24odHhNZXRhKS5zZXJpYWxpemUoKTtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5nZXRMMUZlZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xyXG4gIHJldHVybiByZXN1bHQ/LnRvSGV4U3RyaW5nKCk7XHJcbn1cclxuIiwiaW1wb3J0IHB1bnljb2RlIGZyb20gJ3B1bnljb2RlL3B1bnljb2RlJztcclxuaW1wb3J0IGFiaSBmcm9tICdodW1hbi1zdGFuZGFyZC10b2tlbi1hYmknO1xyXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCAqIGFzIGV0aFV0aWwgZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XHJcbmltcG9ydCB7IGdldEZvcm1hdHRlZElwZnNVcmwgfSBmcm9tICdAbWV0YW1hc2svYXNzZXRzLWNvbnRyb2xsZXJzJztcclxuaW1wb3J0IHNsaXA0NCBmcm9tICdAbWV0YW1hc2svc2xpcDQ0JztcclxuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBib3dzZXIgZnJvbSAnYm93c2VyJztcclxuXG5pbXBvcnQgeyBDSEFJTl9JRFMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5pbXBvcnQge1xyXG4gIHRvQ2hlY2tzdW1IZXhBZGRyZXNzLFxyXG4gIHN0cmlwSGV4UHJlZml4LFxyXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XHJcbmltcG9ydCB7XHJcbiAgVFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlMsXHJcbiAgVFJVTkNBVEVEX05BTUVfQ0hBUl9MSU1JVCxcclxuICBUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlMsXHJcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9sYWJlbHMnO1xyXG5pbXBvcnQgeyBOdW1lcmljIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvTnVtZXJpYyc7XHJcbmltcG9ydCB7IE9VVERBVEVEX0JST1dTRVJfVkVSU0lPTlMgfSBmcm9tICcuLi9jb25zdGFudHMvY29tbW9uJztcclxuXG5cclxuLy8gZm9ybWF0RGF0YSA6OiAoIGRhdGU6IDxVbml4IFRpbWVzdGFtcD4gKSAtPiBTdHJpbmdcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0ID0gXCJNL2QveSAnYXQnIFRcIikge1xyXG4gIGlmICghZGF0ZSkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICByZXR1cm4gRGF0ZVRpbWUuZnJvbU1pbGxpcyhkYXRlKS50b0Zvcm1hdChmb3JtYXQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVdpdGhZZWFyQ29udGV4dChcclxuICBkYXRlLFxyXG4gIGZvcm1hdFRoaXNZZWFyID0gJ01NTSBkJyxcclxuICBmYWxsYmFjayA9ICdNTU0gZCwgeScsXHJcbikge1xyXG4gIGlmICghZGF0ZSkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBjb25zdCBkYXRlVGltZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSk7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZVRpbWUubG9jYWwoKTtcclxuICByZXR1cm4gZGF0ZVRpbWUudG9Gb3JtYXQoXHJcbiAgICBub3cueWVhciA9PT0gZGF0ZVRpbWUueWVhciA/IGZvcm1hdFRoaXNZZWFyIDogZmFsbGJhY2ssXHJcbiAgKTtcclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvdmlkZWQgY2hhaW5JZCBpcyBhIGRlZmF1bHQgTWV0YU1hc2sgY2hhaW5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBjaGFpbklkIHRvIGNoZWNrXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZhdWx0TWV0YU1hc2tDaGFpbihjaGFpbklkKSB7XHJcbiAgaWYgKFxyXG4gICAgIWNoYWluSWQgfHxcclxuICAgIGNoYWluSWQgPT09IENIQUlOX0lEUy5NQUlOTkVUIHx8XHJcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuR09FUkxJIHx8XHJcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuU0VQT0xJQSB8fFxyXG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLkxJTkVBX1RFU1RORVQgfHxcclxuICAgIGNoYWluSWQgPT09IENIQUlOX0lEUy5MT0NBTEhPU1RcclxuICApIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzRm9yKG9iaikge1xyXG4gIGlmICghb2JqKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRyZXNzU3VtbWFyeShcclxuICBhZGRyZXNzLFxyXG4gIGZpcnN0U2VnTGVuZ3RoID0gMTAsXHJcbiAgbGFzdFNlZ0xlbmd0aCA9IDQsXHJcbiAgaW5jbHVkZUhleCA9IHRydWUsXHJcbikge1xyXG4gIGlmICghYWRkcmVzcykge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBsZXQgY2hlY2tlZCA9IHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xyXG4gIGlmICghaW5jbHVkZUhleCkge1xyXG4gICAgY2hlY2tlZCA9IHN0cmlwSGV4UHJlZml4KGNoZWNrZWQpO1xyXG4gIH1cclxuICByZXR1cm4gY2hlY2tlZFxyXG4gICAgPyBgJHtjaGVja2VkLnNsaWNlKDAsIGZpcnN0U2VnTGVuZ3RoKX0uLi4ke2NoZWNrZWQuc2xpY2UoXHJcbiAgICAgICAgY2hlY2tlZC5sZW5ndGggLSBsYXN0U2VnTGVuZ3RoLFxyXG4gICAgICApfWBcclxuICAgIDogJy4uLic7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRG9tYWluTmFtZShhZGRyZXNzKSB7XHJcbiAgY29uc3QgbWF0Y2ggPSBwdW55Y29kZVxyXG4gICAgLnRvQVNDSUkoYWRkcmVzcylcclxuICAgIC50b0xvd2VyQ2FzZSgpXHJcbiAgICAvLyBDaGVja3MgdGhhdCB0aGUgZG9tYWluIGNvbnNpc3RzIG9mIGF0IGxlYXN0IG9uZSB2YWxpZCBkb21haW4gcGllY2VzIHNlcGFyYXRlZCBieSBwZXJpb2RzLCBmb2xsb3dlZCBieSBhIHRsZFxyXG4gICAgLy8gRWFjaCBwaWVjZSBvZiBkb21haW4gbmFtZSBoYXMgb25seSB0aGUgY2hhcmFjdGVycyBhLXosIDAtOSwgYW5kIGEgaHlwaGVuIChidXQgbm90IGF0IHRoZSBzdGFydCBvciBlbmQgb2YgY2h1bmspXHJcbiAgICAvLyBBIGNodW5rIGhhcyBtaW5pbXVtIGxlbmd0aCBvZiAxLCBidXQgbWluaW11bSB0bGQgaXMgc2V0IHRvIDIgZm9yIG5vdyAobm8gMS1jaGFyYWN0ZXIgdGxkcyBleGlzdCB5ZXQpXHJcbiAgICAubWF0Y2goXHJcbiAgICAgIC9eKD86W2EtejAtOV0oPzpbLWEtejAtOV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV1bLWEtejAtOV0qW2EtejAtOV0kL3UsXHJcbiAgICApO1xyXG4gIHJldHVybiBtYXRjaCAhPT0gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3JpZ2luQ29udHJhY3RBZGRyZXNzKHRvLCBzZW5kVG9rZW5BZGRyZXNzKSB7XHJcbiAgaWYgKCF0byB8fCAhc2VuZFRva2VuQWRkcmVzcykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdG8udG9Mb3dlckNhc2UoKSA9PT0gc2VuZFRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG4vLyBUYWtlcyB3ZWkgSGV4LCByZXR1cm5zIHdlaSBCTiwgZXZlbiBpZiBpbnB1dCBpcyBudWxsXHJcbmV4cG9ydCBmdW5jdGlvbiBudW1lcmljQmFsYW5jZShiYWxhbmNlKSB7XHJcbiAgaWYgKCFiYWxhbmNlKSB7XHJcbiAgICByZXR1cm4gbmV3IGV0aFV0aWwuQk4oMCwgMTYpO1xyXG4gIH1cclxuICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGJhbGFuY2UpO1xyXG4gIHJldHVybiBuZXcgZXRoVXRpbC5CTihzdHJpcHBlZCwgMTYpO1xyXG59XHJcblxyXG4vLyBUYWtlcyAgaGV4LCByZXR1cm5zIFtiZWZvcmVEZWNpbWFsLCBhZnRlckRlY2ltYWxdXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJhbGFuY2UoYmFsYW5jZSkge1xyXG4gIGxldCBhZnRlckRlY2ltYWw7XHJcbiAgY29uc3Qgd2VpID0gbnVtZXJpY0JhbGFuY2UoYmFsYW5jZSk7XHJcbiAgY29uc3Qgd2VpU3RyaW5nID0gd2VpLnRvU3RyaW5nKCk7XHJcbiAgY29uc3QgdHJhaWxpbmdaZXJvcyA9IC8wKyQvdTtcclxuXHJcbiAgY29uc3QgYmVmb3JlRGVjaW1hbCA9XHJcbiAgICB3ZWlTdHJpbmcubGVuZ3RoID4gMTggPyB3ZWlTdHJpbmcuc2xpY2UoMCwgd2VpU3RyaW5nLmxlbmd0aCAtIDE4KSA6ICcwJztcclxuICBhZnRlckRlY2ltYWwgPSBgMDAwMDAwMDAwMDAwMDAwMDAwJHt3ZWl9YFxyXG4gICAgLnNsaWNlKC0xOClcclxuICAgIC5yZXBsYWNlKHRyYWlsaW5nWmVyb3MsICcnKTtcclxuICBpZiAoYWZ0ZXJEZWNpbWFsID09PSAnJykge1xyXG4gICAgYWZ0ZXJEZWNpbWFsID0gJzAnO1xyXG4gIH1cclxuICByZXR1cm4gW2JlZm9yZURlY2ltYWwsIGFmdGVyRGVjaW1hbF07XHJcbn1cclxuXHJcbi8vIFRha2VzIHdlaSBoZXgsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhyZWUgcHJvcGVydGllcy5cclxuLy8gSXRzIFwiZm9ybWF0dGVkXCIgcHJvcGVydHkgaXMgd2hhdCB3ZSBnZW5lcmFsbHkgdXNlIHRvIHJlbmRlciB2YWx1ZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCYWxhbmNlKFxyXG4gIGJhbGFuY2UsXHJcbiAgZGVjaW1hbHNUb0tlZXAsXHJcbiAgbmVlZHNQYXJzZSA9IHRydWUsXHJcbiAgdGlja2VyID0gJ0VUSCcsXHJcbikge1xyXG4gIGNvbnN0IHBhcnNlZCA9IG5lZWRzUGFyc2UgPyBwYXJzZUJhbGFuY2UoYmFsYW5jZSkgOiBiYWxhbmNlLnNwbGl0KCcuJyk7XHJcbiAgY29uc3QgYmVmb3JlRGVjaW1hbCA9IHBhcnNlZFswXTtcclxuICBsZXQgYWZ0ZXJEZWNpbWFsID0gcGFyc2VkWzFdO1xyXG4gIGxldCBmb3JtYXR0ZWQgPSAnTm9uZSc7XHJcbiAgaWYgKGRlY2ltYWxzVG9LZWVwID09PSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChiZWZvcmVEZWNpbWFsID09PSAnMCcpIHtcclxuICAgICAgaWYgKGFmdGVyRGVjaW1hbCAhPT0gJzAnKSB7XHJcbiAgICAgICAgY29uc3Qgc2lnRmlncyA9IGFmdGVyRGVjaW1hbC5tYXRjaCgvXjAqKC57Mn0pL3UpOyAvLyBkZWZhdWx0OiBncmFicyAyIG1vc3Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgaWYgKHNpZ0ZpZ3MpIHtcclxuICAgICAgICAgIGFmdGVyRGVjaW1hbCA9IHNpZ0ZpZ3NbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdHRlZCA9IGAwLiR7YWZ0ZXJEZWNpbWFsfSAke3RpY2tlcn1gO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3JtYXR0ZWQgPSBgJHtiZWZvcmVEZWNpbWFsfS4ke2FmdGVyRGVjaW1hbC5zbGljZSgwLCAzKX0gJHt0aWNrZXJ9YDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgYWZ0ZXJEZWNpbWFsICs9IEFycmF5KGRlY2ltYWxzVG9LZWVwKS5qb2luKCcwJyk7XHJcbiAgICBmb3JtYXR0ZWQgPSBgJHtiZWZvcmVEZWNpbWFsfS4ke2FmdGVyRGVjaW1hbC5zbGljZShcclxuICAgICAgMCxcclxuICAgICAgZGVjaW1hbHNUb0tlZXAsXHJcbiAgICApfSAke3RpY2tlcn1gO1xyXG4gIH1cclxuICByZXR1cm4gZm9ybWF0dGVkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udHJhY3RBdEFkZHJlc3ModG9rZW5BZGRyZXNzKSB7XHJcbiAgcmV0dXJuIGdsb2JhbC5ldGguY29udHJhY3QoYWJpKS5hdCh0b2tlbkFkZHJlc3MpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tRmlsZU5hbWUoKSB7XHJcbiAgbGV0IGZpbGVOYW1lID0gJyc7XHJcbiAgY29uc3QgY2hhckJhbmsgPSBbXHJcbiAgICAuLi4nYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknLFxyXG4gIF07XHJcbiAgY29uc3QgZmlsZU5hbWVMZW5ndGggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA3ICsgNik7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZU5hbWVMZW5ndGg7IGkrKykge1xyXG4gICAgZmlsZU5hbWUgKz0gY2hhckJhbmtbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhckJhbmsubGVuZ3RoKV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmlsZU5hbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaG9ydGVucyBhbiBFdGhlcmV1bSBhZGRyZXNzIGZvciBkaXNwbGF5LCBwcmVzZXJ2aW5nIHRoZSBiZWdpbm5pbmcgYW5kIGVuZC5cclxuICogUmV0dXJucyB0aGUgZ2l2ZW4gYWRkcmVzcyBpZiBpdCBpcyBubyBsb25nZXIgdGhhbiAxMCBjaGFyYWN0ZXJzLlxyXG4gKiBTaG9ydGVuZWQgYWRkcmVzc2VzIGFyZSAxMyBjaGFyYWN0ZXJzIGxvbmcuXHJcbiAqXHJcbiAqIEV4YW1wbGUgb3V0cHV0OiAweGFiY2QuLi4xMjM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gc2hvcnRlbi5cclxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHNob3J0ZW5lZCBhZGRyZXNzLCBvciB0aGUgb3JpZ2luYWwgaWYgaXQgd2FzIG5vIGxvbmdlclxyXG4gKiB0aGFuIDEwIGNoYXJhY3RlcnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvcnRlbkFkZHJlc3MoYWRkcmVzcyA9ICcnKSB7XHJcbiAgaWYgKGFkZHJlc3MubGVuZ3RoIDwgVFJVTkNBVEVEX05BTUVfQ0hBUl9MSU1JVCkge1xyXG4gICAgcmV0dXJuIGFkZHJlc3M7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYCR7YWRkcmVzcy5zbGljZSgwLCBUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSUyl9Li4uJHthZGRyZXNzLnNsaWNlKFxyXG4gICAgLVRSVU5DQVRFRF9BRERSRVNTX0VORF9DSEFSUyxcclxuICApfWA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50QnlBZGRyZXNzKGFjY291bnRzID0gW10sIHRhcmdldEFkZHJlc3MpIHtcclxuICByZXR1cm4gYWNjb3VudHMuZmluZCgoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MgPT09IHRhcmdldEFkZHJlc3MpO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaXBzIHRoZSBmb2xsb3dpbmcgc2NoZW1lcyBmcm9tIFVSTCBzdHJpbmdzOlxyXG4gKiAtIGh0dHBcclxuICogLSBodHRwc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwU2NoZW1lcyh1cmxTdHJpbmcpIHtcclxuICByZXR1cm4gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwcz86XFwvXFwvL3UsICcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0cmlwcyB0aGUgZm9sbG93aW5nIHNjaGVtZXMgZnJvbSBVUkwgc3RyaW5nczpcclxuICogLSBodHRwc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwc1NjaGVtZSh1cmxTdHJpbmcpIHtcclxuICByZXR1cm4gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwczpcXC9cXC8vdSwgJycpO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaXBzIGBodHRwc2Agc2NoZW1lcyBmcm9tIFVSTCBzdHJpbmdzLCBpZiB0aGUgVVJMIGRvZXMgbm90IGhhdmUgYSBwb3J0LlxyXG4gKiBUaGlzIGlzIHVzZWZ1bFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwc1NjaGVtZVdpdGhvdXRQb3J0KHVybFN0cmluZykge1xyXG4gIGlmIChnZXRVUkwodXJsU3RyaW5nKS5wb3J0KSB7XHJcbiAgICByZXR1cm4gdXJsU3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmlwSHR0cHNTY2hlbWUodXJsU3RyaW5nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGEgVVJMLWxpa2UgdmFsdWUgKG9iamVjdCBvciBzdHJpbmcpIGlzIGFuIGV4dGVuc2lvbiBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgVVJMIHwgb2JqZWN0fSB1cmxMaWtlIC0gVGhlIFVSTC1saWtlIHZhbHVlIHRvIHRlc3QuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBVUkwtbGlrZSB2YWx1ZSBpcyBhbiBleHRlbnNpb24gVVJMLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZW5zaW9uVXJsKHVybExpa2UpIHtcclxuICBjb25zdCBFWFRfUFJPVE9DT0xTID0gWydjaHJvbWUtZXh0ZW5zaW9uOicsICdtb3otZXh0ZW5zaW9uOiddO1xyXG5cclxuICBpZiAodHlwZW9mIHVybExpa2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIEVYVF9QUk9UT0NPTFMpIHtcclxuICAgICAgaWYgKHVybExpa2Uuc3RhcnRzV2l0aChwcm90b2NvbCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHVybExpa2U/LnByb3RvY29sKSB7XHJcbiAgICByZXR1cm4gRVhUX1BST1RPQ09MUy5pbmNsdWRlcyh1cmxMaWtlLnByb3RvY29sKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYW4gYWRkcmVzcyBpcyBpbiBhIHBhc3NlZCBsaXN0IG9mIG9iamVjdHMgd2l0aCBhZGRyZXNzIHByb3BlcnRpZXMuIFRoZSBjaGVjayBpcyBwZXJmb3JtZWQgb24gdGhlXHJcbiAqIGxvd2VyY2FzZWQgdmVyc2lvbiBvZiB0aGUgYWRkcmVzc2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyB0byBjaGVja1xyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gVGhlIGFycmF5IG9mIG9iamVjdHMgdG8gY2hlY2tcclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGRyZXNzIGlzIGluIHRoZSBsaXN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFeGlzdGluZ0FkZHJlc3NlcyhhZGRyZXNzLCBsaXN0ID0gW10pIHtcclxuICBpZiAoIWFkZHJlc3MpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1hdGNoZXNBZGRyZXNzID0gKG9iaikgPT4ge1xyXG4gICAgcmV0dXJuIG9iai5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbGlzdC5zb21lKG1hdGNoZXNBZGRyZXNzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJuR3JlYXRlclRoYW4oYSwgYikge1xyXG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5ndChiLCAxMCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBibkxlc3NUaGFuKGEsIGIpIHtcclxuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEJpZ051bWJlcihhLCAxMCkubHQoYiwgMTApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYm5HcmVhdGVyVGhhbkVxdWFsVG8oYSwgYikge1xyXG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5ndGUoYiwgMTApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYm5MZXNzVGhhbkVxdWFsVG8oYSwgYikge1xyXG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5sdGUoYiwgMTApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKHVybCkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldElzQnJvd3NlckRlcHJlY2F0ZWQoXHJcbiAgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLFxyXG4pIHtcclxuICByZXR1cm4gYnJvd3Nlci5zYXRpc2ZpZXMoT1VUREFURURfQlJPV1NFUl9WRVJTSU9OUykgPz8gZmFsc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkxIb3N0KHVybCkge1xyXG4gIHJldHVybiBnZXRVUkwodXJsKT8uaG9zdCB8fCAnJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3ROYW1lKHVybCkge1xyXG4gIHJldHVybiBnZXRVUkwodXJsKT8uaG9zdG5hbWUgfHwgJyc7XHJcbn1cclxuXHJcbi8vIE9uY2Ugd2UgcmVhY2ggdGhpcyB0aHJlc2hvbGQsIHdlIHN3aXRjaCB0byBoaWdoZXIgdW5pdFxyXG5jb25zdCBNSU5VVEVfQ1VUT0ZGID0gOTAgKiA2MDtcclxuY29uc3QgU0VDT05EX0NVVE9GRiA9IDkwO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRvSHVtYW5SZWFkYWJsZVRpbWUgPSAodCwgbWlsbGlzZWNvbmRzKSA9PiB7XHJcbiAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkIHx8IG1pbGxpc2Vjb25kcyA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5jZWlsKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xyXG4gIGlmIChzZWNvbmRzIDw9IFNFQ09ORF9DVVRPRkYpIHtcclxuICAgIHJldHVybiB0KCdnYXNUaW1pbmdTZWNvbmRzU2hvcnQnLCBbc2Vjb25kc10pO1xyXG4gIH1cclxuICBpZiAoc2Vjb25kcyA8PSBNSU5VVEVfQ1VUT0ZGKSB7XHJcbiAgICByZXR1cm4gdCgnZ2FzVGltaW5nTWludXRlc1Nob3J0JywgW01hdGguY2VpbChzZWNvbmRzIC8gNjApXSk7XHJcbiAgfVxyXG4gIHJldHVybiB0KCdnYXNUaW1pbmdIb3Vyc1Nob3J0JywgW01hdGguY2VpbChzZWNvbmRzIC8gMzYwMCldKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNsaXBib2FyZCgpIHtcclxuICB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoJycpO1xyXG59XHJcblxyXG5jb25zdCBzb2xpZGl0eVR5cGVzID0gKCkgPT4ge1xyXG4gIGNvbnN0IHR5cGVzID0gW1xyXG4gICAgJ2Jvb2wnLFxyXG4gICAgJ2FkZHJlc3MnLFxyXG4gICAgJ3N0cmluZycsXHJcbiAgICAnYnl0ZXMnLFxyXG4gICAgJ2ludCcsXHJcbiAgICAndWludCcsXHJcbiAgICAnZml4ZWQnLFxyXG4gICAgJ3VmaXhlZCcsXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgaW50cyA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxyXG4gICAgKF8sIGluZGV4KSA9PiBgaW50JHsoaW5kZXggKyAxKSAqIDh9YCxcclxuICApO1xyXG4gIGNvbnN0IHVpbnRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoMzIpKS5tYXAoXHJcbiAgICAoXywgaW5kZXgpID0+IGB1aW50JHsoaW5kZXggKyAxKSAqIDh9YCxcclxuICApO1xyXG4gIGNvbnN0IGJ5dGVzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoMzIpKS5tYXAoXHJcbiAgICAoXywgaW5kZXgpID0+IGBieXRlcyR7aW5kZXggKyAxfWAsXHJcbiAgKTtcclxuXHJcbiAgLyoqXHJcbiAgICogZml4ZWQgYW5kIHVmaXhlZFxyXG4gICAqIFRoaXMgdmFsdWUgdHlwZSBhbHNvIGNhbiBiZSBkZWNsYXJlZCBrZXl3b3JkcyBzdWNoIGFzIHVmaXhlZE14TiBhbmQgZml4ZWRNeE4uXHJcbiAgICogVGhlIE0gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGJpdHMgdGhhdCB0aGUgdHlwZSB0YWtlcyxcclxuICAgKiB3aXRoIE4gcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdGhhdCBhcmUgYXZhaWxhYmxlLlxyXG4gICAqICBNIGhhcyB0byBiZSBkaXZpc2libGUgYnkgOCwgYW5kIGEgbnVtYmVyIGZyb20gOCB0byAyNTYuXHJcbiAgICogTiBoYXMgdG8gYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDgwLCBhbHNvIGJlaW5nIGluY2x1c2l2ZS5cclxuICAgKi9cclxuICBjb25zdCBmaXhlZE0gPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcclxuICAgIChfLCBpbmRleCkgPT4gYGZpeGVkJHsoaW5kZXggKyAxKSAqIDh9YCxcclxuICApO1xyXG4gIGNvbnN0IHVmaXhlZE0gPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcclxuICAgIChfLCBpbmRleCkgPT4gYHVmaXhlZCR7KGluZGV4ICsgMSkgKiA4fWAsXHJcbiAgKTtcclxuICBjb25zdCBmaXhlZCA9IEFycmF5LmZyb20obmV3IEFycmF5KDgwKSkubWFwKChfLCBpbmRleCkgPT5cclxuICAgIGZpeGVkTS5tYXAoKGFGaXhlZE0pID0+IGAke2FGaXhlZE19eCR7aW5kZXggKyAxfWApLFxyXG4gICk7XHJcbiAgY29uc3QgdWZpeGVkID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoODApKS5tYXAoKF8sIGluZGV4KSA9PlxyXG4gICAgdWZpeGVkTS5tYXAoKGF1Rml4ZWRNKSA9PiBgJHthdUZpeGVkTX14JHtpbmRleCArIDF9YCksXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIFtcclxuICAgIC4uLnR5cGVzLFxyXG4gICAgLi4uaW50cyxcclxuICAgIC4uLnVpbnRzLFxyXG4gICAgLi4uYnl0ZXMsXHJcbiAgICAuLi5maXhlZC5mbGF0KCksXHJcbiAgICAuLi51Zml4ZWQuZmxhdCgpLFxyXG4gIF07XHJcbn07XHJcblxyXG5jb25zdCBTT0xJRElUWV9UWVBFUyA9IHNvbGlkaXR5VHlwZXMoKTtcclxuXHJcbmNvbnN0IHN0cmlwQXJyYXlUeXBlID0gKHBvdGVudGlhbEFycmF5VHlwZSkgPT5cclxuICBwb3RlbnRpYWxBcnJheVR5cGUucmVwbGFjZSgvXFxbW1swLTldKlxcXSovZ3UsICcnKTtcclxuXHJcbmNvbnN0IHN0cmlwT25lTGF5ZXJvZk5lc3RpbmcgPSAocG90ZW50aWFsQXJyYXlUeXBlKSA9PlxyXG4gIHBvdGVudGlhbEFycmF5VHlwZS5yZXBsYWNlKC9cXFtbWzAtOV0qXFxdL3UsICcnKTtcclxuXHJcbmNvbnN0IGlzQXJyYXlUeXBlID0gKHBvdGVudGlhbEFycmF5VHlwZSkgPT5cclxuICBwb3RlbnRpYWxBcnJheVR5cGUubWF0Y2goL1xcW1tbMC05XSpcXF0qL3UpICE9PSBudWxsO1xyXG5cclxuY29uc3QgaXNTb2xpZGl0eVR5cGUgPSAodHlwZSkgPT4gU09MSURJVFlfVFlQRVMuaW5jbHVkZXModHlwZSk7XHJcblxyXG5leHBvcnQgY29uc3Qgc2FuaXRpemVNZXNzYWdlID0gKG1zZywgcHJpbWFyeVR5cGUsIHR5cGVzKSA9PiB7XHJcbiAgaWYgKCF0eXBlcykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR5cGVzIGRlZmluaXRpb25gKTtcclxuICB9XHJcblxyXG4gIC8vIFByaW1hcnkgdHlwZSBjYW4gYmUgYW4gYXJyYXkuXHJcbiAgY29uc3QgaXNBcnJheSA9IHByaW1hcnlUeXBlICYmIGlzQXJyYXlUeXBlKHByaW1hcnlUeXBlKTtcclxuICBpZiAoaXNBcnJheSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdmFsdWU6IG1zZy5tYXAoKHZhbHVlKSA9PlxyXG4gICAgICAgIHNhbml0aXplTWVzc2FnZSh2YWx1ZSwgc3RyaXBPbmVMYXllcm9mTmVzdGluZyhwcmltYXJ5VHlwZSksIHR5cGVzKSxcclxuICAgICAgKSxcclxuICAgICAgdHlwZTogcHJpbWFyeVR5cGUsXHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAoaXNTb2xpZGl0eVR5cGUocHJpbWFyeVR5cGUpKSB7XHJcbiAgICByZXR1cm4geyB2YWx1ZTogbXNnLCB0eXBlOiBwcmltYXJ5VHlwZSB9O1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgbm90LCBhc3N1bWUgdG8gYmUgc3RydWN0XHJcbiAgY29uc3QgYmFzZVR5cGUgPSBpc0FycmF5ID8gc3RyaXBBcnJheVR5cGUocHJpbWFyeVR5cGUpIDogcHJpbWFyeVR5cGU7XHJcblxyXG4gIGNvbnN0IGJhc2VUeXBlRGVmaW5pdGlvbnMgPSB0eXBlc1tiYXNlVHlwZV07XHJcbiAgaWYgKCFiYXNlVHlwZURlZmluaXRpb25zKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJpbWFyeSB0eXBlIGRlZmluaXRpb25gKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhbml0aXplZFN0cnVjdCA9IHt9O1xyXG4gIGNvbnN0IG1zZ0tleXMgPSBPYmplY3Qua2V5cyhtc2cpO1xyXG4gIG1zZ0tleXMuZm9yRWFjaCgobXNnS2V5KSA9PiB7XHJcbiAgICBjb25zdCBkZWZpbmVkVHlwZSA9IE9iamVjdC52YWx1ZXMoYmFzZVR5cGVEZWZpbml0aW9ucykuZmluZChcclxuICAgICAgKGJhc2VUeXBlRGVmaW5pdGlvbikgPT4gYmFzZVR5cGVEZWZpbml0aW9uLm5hbWUgPT09IG1zZ0tleSxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCFkZWZpbmVkVHlwZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2FuaXRpemVkU3RydWN0W21zZ0tleV0gPSBzYW5pdGl6ZU1lc3NhZ2UoXHJcbiAgICAgIG1zZ1ttc2dLZXldLFxyXG4gICAgICBkZWZpbmVkVHlwZS50eXBlLFxyXG4gICAgICB0eXBlcyxcclxuICAgICk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHsgdmFsdWU6IHNhbml0aXplZFN0cnVjdCwgdHlwZTogcHJpbWFyeVR5cGUgfTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NldEltYWdlVVJMKGltYWdlLCBpcGZzR2F0ZXdheSkge1xyXG4gIGlmICghaW1hZ2UgfHwgIWlwZnNHYXRld2F5IHx8IHR5cGVvZiBpbWFnZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIGlmIChpbWFnZS5zdGFydHNXaXRoKCdpcGZzOi8vJykpIHtcclxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRJcGZzVXJsKGlwZnNHYXRld2F5LCBpbWFnZSwgdHJ1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBpbWFnZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsUGxhY2VzUmVtb3ZpbmdFeHRyYVplcm9lcyhcclxuICBudW1iZXJpc2gsXHJcbiAgbnVtYmVyT2ZEZWNpbWFsUGxhY2VzLFxyXG4pIHtcclxuICBpZiAobnVtYmVyaXNoID09PSB1bmRlZmluZWQgfHwgbnVtYmVyaXNoID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhcclxuICAgIG5ldyBOdW1lcmljKG51bWJlcmlzaCwgMTApLnRvRml4ZWQobnVtYmVyT2ZEZWNpbWFsUGxhY2VzKSxcclxuICAgIDEwLFxyXG4gICkudG9OdW1iZXIoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIFNMSVAtNDQgcHJvdG9jb2wgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkXHJcbiAqIGBjb2luX3R5cGVgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gY29pblR5cGUgLSBUaGUgU0xJUC00NCBgY29pbl90eXBlYCB2YWx1ZSB3aG9zZSBuYW1lXHJcbiAqIHRvIHJldHJpZXZlLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgbmFtZSBvZiB0aGUgcHJvdG9jb2wgaWYgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29pblR5cGVUb1Byb3RvY29sTmFtZShjb2luVHlwZSkge1xyXG4gIGlmIChTdHJpbmcoY29pblR5cGUpID09PSAnMScpIHtcclxuICAgIHJldHVybiAnVGVzdCBOZXR3b3Jrcyc7XHJcbiAgfVxyXG4gIHJldHVybiBzbGlwNDRbY29pblR5cGVdPy5uYW1lIHx8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIFwibnVsbGlzaG5lc3NcIi4gVXNlZCB0byBndWFyZCBhIHNlY3Rpb24gb2YgYSBjb21wb25lbnQgZnJvbSBiZWluZ1xyXG4gKiByZW5kZXJlZCBiYXNlZCBvbiBhIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBBIHZhbHVlIChsaXRlcmFsbHkgYW55dGhpbmcpLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bGxpc2godmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuXG5cclxuLyoqXHJcbiAqIFRoZSBtZXRob2QgZXNjYXBlIFJUTCBjaGFyYWN0ZXIgaW4gc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICogQHJldHVybnMgeyhzdHJpbmd8Kil9IGVzY2FwZWQgc3RyaW5nIG9yIG9yaWdpbmFsIHBhcmFtIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2FuaXRpemVTdHJpbmcgPSAodmFsdWUpID0+IHtcclxuICBpZiAoIXZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGlmICghbG9kYXNoLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBjb25zdCByZWdleCA9IC9cXHUyMDJFL2dpdTtcclxuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWdleCwgJ1xcXFx1MjAyRScpO1xyXG59O1xyXG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcCJ9
